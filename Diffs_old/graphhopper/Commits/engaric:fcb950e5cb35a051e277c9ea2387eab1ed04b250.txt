diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
index 2ecb0f735c..ab20422475 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
@@ -162,18 +162,27 @@ public long getTotalRouteTime() {
 	}
 
 	public String getErrorMessage() {
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		
+		JsonObject error= jObject.getAsJsonObject("error");
+	//	JsonArray errors = info.getAsJsonArray("errors");
+		//JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		//		.getAsJsonPrimitive("message");
+		JsonPrimitive errorMessage = error.getAsJsonObject()
 				.getAsJsonPrimitive("message");
 		return errorMessage.getAsString();
 
 	}
 
 	public int getStatusCode() {
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
-				.getAsJsonPrimitive("statuscode");
-		return errorMessage.getAsInt();
+	//	JsonArray errors = info.getAsJsonArray("errors");
+		
+		JsonObject error= jObject.getAsJsonObject("error");
+	//	JsonArray errors = info.getAsJsonArray("errors");
+
+		JsonPrimitive statusCode = error.getAsJsonPrimitive("statuscode");
+		//JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+		//		.getAsJsonPrimitive("statuscode");
+		return statusCode.getAsInt();
 
 	}
 
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
index 7bc129c934..6bb909bd68 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
@@ -13,6 +13,7 @@
 import cucumber.api.Scenario;
 import cucumber.api.java.After;
 import cucumber.api.java.Before;
+import cucumber.api.java.en.And;
 import cucumber.api.java.en.Given;
 import cucumber.api.java.en.Then;
 import cucumber.api.java.en.When;
@@ -170,6 +171,23 @@ public void I_should_be_able_to_verify_the_response_message_as(
 		graphUiUtil.verifyErrorMessage(responseMessage);
 
 	}
+	
+	@Then("^I should be able to verify the http statuscode as \"([^\"]*)\"$")
+	public void I_should_be_able_to_verify_the_http_responseCode_as(int statusCode) {
+
+		graphUiUtil.verifyHttpStatusCode(statusCode);
+
+	}
+
+	@Then("^I should be able to verify the http response message as \"([^\"]*)\"$")
+	public void I_should_be_able_to_verify_the_http_response_message_as(
+			String responseMessage) {
+
+		graphUiUtil.verifyHttpErrorMessage(responseMessage);
+
+	}
+
+	
 
 	@When("^I request for a route$")
 	public void I_request_for_route() {
@@ -206,6 +224,14 @@ public void I_request_for_route() {
 		}
 
 	}
+	
+	@And("^I request for HTTP \"([^\"]*)\" method$")
+	public void I_request_for_http_mehtod(String httpMethod)
+	{
+		graphUiUtil.setHTTPMethod(httpMethod);
+	}
+	
+	
 
 	@After("@SampleScenario")
 	public void I_should_be_able_to_capture_a_screenshot(Scenario sc)
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
index 6784e24280..6b2a26ded5 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
@@ -25,9 +25,16 @@
 import org.alternativevision.gpx.beans.Route;
 import org.alternativevision.gpx.beans.Waypoint;
 import org.apache.commons.io.IOUtils;
+import org.apache.http.HttpRequest;
+import org.apache.http.StatusLine;
 import org.apache.http.client.ClientProtocolException;
 import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.impl.client.CloseableHttpClient;
 import org.junit.Assert;
 import org.openqa.selenium.By;
@@ -63,6 +70,9 @@
 	JavascriptExecutor js = (JavascriptExecutor) driver;
 	WebElement we;
 	private BufferedImage actualMap;
+	private String httpMethod="";
+	private int actualResponseCode;
+	private String actualResponseMsg;
 
 	private static final Logger LOG = LoggerFactory
 			.getLogger(GraphHopperUIUtil.class);
@@ -708,6 +718,10 @@ void sendAndGetResponse(StringBuffer sb) {
 					.toString());
 			serviceResponse = IOUtils.toString(httpResponse.getEntity()
 					.getContent(), "UTF-8");
+			
+			final StatusLine statusLine = httpResponse.getStatusLine();
+			actualResponseCode = statusLine.getStatusCode();
+			actualResponseMsg = statusLine.getReasonPhrase();
 
 		} catch (IOException e) {
 			LOG.info("Exception raised whilst attempting to call graphhopper server "
@@ -739,19 +753,50 @@ public CloseableHttpResponse dispatchServiceRequest(String requestUrl)
 		return doSendAndGetResponse(serviceUrl);
 	}
 
-	private void addCustomHeaders(HttpGet httpget) {
+	private void addCustomHeaders(HttpUriRequest httpRequest) {
 		for (Entry<String, String> header : customHeaders.entrySet()) {
-			httpget.addHeader(header.getKey(), header.getValue());
+			httpRequest.addHeader(header.getKey(), header.getValue());
 		}
 	}
 
 	CloseableHttpResponse doSendAndGetResponse(String serviceUrl)
 			throws IOException, ClientProtocolException {
 		CloseableHttpClient httpClient = HttpClientUtils.createClient();
-		HttpGet httpget = new HttpGet(serviceUrl);
-		addCustomHeaders(httpget);
+		
+		HttpUriRequest httpRequest=null;
+		
+	switch (httpMethod) {
+	case "PUT":
+		httpRequest = new HttpPut(serviceUrl);
+		
+		break;
+	case "GET":
+		
+		httpRequest = new HttpGet(serviceUrl);
+		
+		break;
+		
+	case "DEL":
+		
+		httpRequest = new HttpDelete(serviceUrl);
+		
+		break;
+		
+	case "POST":
+		
+		httpRequest = new HttpPost(serviceUrl);
+		
+		break;
+
+	default:
+		httpRequest = new HttpGet(serviceUrl);
+		break;
+	}
+		
+		//HttpGet httpget = new HttpGet(serviceUrl);
+		addCustomHeaders(httpRequest);
 
-		return httpClient.execute(httpget);
+		return httpClient.execute(httpRequest);
 	}
 
 	protected void getRouteFromServiceWithParameters() {
@@ -969,4 +1014,22 @@ public String getNearestPointDistance() {
 		return GPHJSONUtil.getNearestPointDistance();
 	}
 
+	public void setHTTPMethod(String httpMethod) {
+		
+		this.httpMethod=httpMethod;
+		
+
+		
+	}
+
+	public void verifyHttpStatusCode(int statusCode) {
+		Assert.assertTrue("Actual http Status Code"+ actualResponseCode+ "i s not matching with "+statusCode,statusCode==actualResponseCode);		
+	}
+
+	public void verifyHttpErrorMessage(String responseMessage) {
+		Assert.assertTrue("Actual http Error Message "+ actualResponseMsg+ " is not matching with "+responseMessage,responseMessage.equalsIgnoreCase(actualResponseMsg));
+		
+	}
+
+	
 }
diff --git a/acceptancetesting/src/test/cucumber/Routing-Errors.feature b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
new file mode 100644
index 0000000000..b399d0c116
--- /dev/null
+++ b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
@@ -0,0 +1,494 @@
+Feature: Verify a route from A to B
+   As a user
+   I want to get a valid Error message and status code for a invalid route request
+
+  #Error Messages
+  #Successful request
+  @Routing @ErrorMessages
+  Scenario: Successful request with all parameters
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "car"
+    And I have avoidances as ""
+    And I have weighting as "fastest"
+    And I have locale as "en"
+    And I have debug as "true"
+    And I have points_encoded as "true"
+    And I have points_calc as "true"
+    And I have instructions as "true"
+    And I have algorithm as "astar"
+    And I have type as "json"
+    When I request for a route
+    Then I should be able to verify the http response message as "OK"
+    Then I should be able to verify the http statuscode as "200"
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco                | waypointdesc                | azimuth | direction | time | distance | avoidance |
+      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 4050 | 112.5    |           |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages @Current
+  Scenario Outline: Incorrect Parameter Value for "Vehicle"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the http response message as "<httpErrorMessage>"
+    Then I should be able to verify the http statuscode as "<statusCode>"
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | errorMessage                                                  | statusCode | httpErrorMessage |
+      | 123         |            | fastest   | Vehicle 123 is not a valid vehicle. Valid vehicles are car.   | 400        | Bad Request                |
+      | foot        |            | fastest   | Vehicle foot is not a valid vehicle. Valid vehicles are car.  | 400        | Bad Request                 |
+      | cycle       |            | fastest   | Vehicle cycle is not a valid vehicle. Valid vehicles are car. | 400        | Bad Request                 |
+      | Bike        |            | fastest   | Vehicle Bike is not a valid vehicle. Valid vehicles are car.  | 400        | Bad Request                 |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Name "vehicles"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage | statusCode |
+      | car         |            | fastest   | json           |              | 400        |
+
+  # Parameter :  vehicle
+  @Routing @ErrorMessages
+  Scenario Outline: Missing Parameter "vehicle"
+    Given I have route points as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
+      | car         |            | fastest   | json           | No point parameter provided | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Value "point"
+    Given I have route point as
+      | pointA           | pointB              |
+      | 50.729961,string | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         |            | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Incorrect Parameter Name "points"
+    Given I have route points as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicles as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                       | statusCode |
+      | car         |            | fastest   | json           | Parameter points is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  point
+  @Routing @ErrorMessages
+  Scenario Outline: Missing Parameter "point"
+    Given I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
+      | car         |            | fastest   | json           | No point parameter provided | 400        |
+
+  # Parameter :  avoidances
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "avoidances"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  avoidances
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "avoidances"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  weighting
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "weighting"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  weighting
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "weighting"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  locale
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "locale"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have locale as "<locale>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | locale | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | en     | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  locale
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "locale"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have locals as "<locale>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | locale | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | en     | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  instructions
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "instructions"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have instructions as "<instructions>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | instructions | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | msg("box")   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  instructions
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "instructions"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have instruction as "<instructions>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | instructions | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | true         | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  algorithm
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "algorithm"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have algorithm as "<algorithm>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | algorithm | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | xyz       | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         | trees      | faster    | dijkstra  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         | trees      | faster    | astar     | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+      | car         | trees      | faster    | astarbi   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  algorithm
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "algorithm"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have algorithms as "<algorithm>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | algorithm | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | dijkstra  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  points_encoded
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "points_encoded"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have points_encoded as "<points_encoded>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | points_encoded | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | xyz            | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  points_encoded
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "points_encoded"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have points_encodedSSS as "<algorithm>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | points_encoded | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | true           | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  debug
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "debug"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have debug as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | debug | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | xyz   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  debug
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "debug"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have debug as "<debug>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | debug | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | true  | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  calc_points
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have calc_points as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | xyz         | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  calc_points
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have calc_points as "<calc_points>"
+    And I have weightings as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | true        | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  Type
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Value for "type"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have calc_points as "<debug>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | faster    | xyz         | txt            | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  # Parameter :  Type
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid Parameter Name for "calc_points"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidance as "<avoidances>"
+    And I have calc_pointSSS as "<calc_points>"
+    And I have weightings as "<routeType>"
+    And I have responseType as "<responseFormat>"
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | calc_points | responseFormat | errorMessage                                                                                                              | statusCode |
+      | car         | trees      | fastest   | true        | json           | Parameter calc_pointSSS is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
+
+  @Routing @ErrorMessages
+  Scenario Outline: Invalid http method "PUT"
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.729961,-3.524853 | 50.723364,-3.523895 |
+    Given I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    And I have type as "<responseFormat>"
+    And I request for HTTP "PUT" method
+    When I request for a route
+    Then I should be able to verify the response message as "<errorMessage>"
+    Then I should be able to verify the statuscode as "<statusCode>"
+
+    Examples: 
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
+      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 405        |
diff --git a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
index 56fc728bd7..359e625b40 100644
--- a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
@@ -150,8 +150,8 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco         | waypointdesc                           | azimuth | direction | time  | distance | avoidance |
-      | 4             | 50.726418,-3.52381 | Turn slight left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
+      | wayPointIndex | waypointco         | waypointdesc                    | azimuth | direction | time  | distance | avoidance |
+      | 4             | 50.726418,-3.52381 | Turn left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -297,7 +297,7 @@ Feature: Verify a route from A to B
       | car         |            | fastest   |
 
   # Access Limited To
-  @Routing
+  @Routing @Current
   Scenario Outline: Verify  Access Limited To  Restrictions on a Route (North Street-Exeter)
     Given I have route point as
       | pointA              | pointB              |
@@ -308,7 +308,7 @@ Feature: Verify a route from A to B
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco       | waypointdesc               | azimuth | direction | time  | distance | avoidance |
-      | 2             | 50.72258,-3.5326 | Continue onto SOUTH STREET | 135.0   | SE        | 15537 | 194.2    |           |
+      | 2             | 50.72258,-3.5326 | Continue onto SOUTH STREET | 135.0   | SE        | 30038 | 379.1    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -324,8 +324,8 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco         | waypointdesc                           | azimuth | direction | time  | distance | avoidance |
-      | 5             | 50.726418,-3.52381 | Turn slight left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
+      | wayPointIndex | waypointco         | waypointdesc                    | azimuth | direction | time  | distance | avoidance |
+      | 5             | 50.726418,-3.52381 | Turn left onto BAMPFYLDE STREET | 45.0    | NE        | 10510 | 131.4    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
@@ -832,105 +832,3 @@ Feature: Verify a route from A to B
     Examples: 
       | vehicleType | avoidances | routeType |
       | car         |            | fastest   |
-
-  #Error Messages
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Value for "Vehicle"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | errorMessage                                                 | statusCode |
-      | 123         |            | fastest   | Vehicle 123 is not a valid vehicle. Valid vehicles are car. 	| 400        |
-      | foot        |            | fastest   | Vehicle foot is not a valid vehicle. Valid vehicles are car. | 400        |
-      | cycle       |            | fastest   | Vehicle cycle is not a valid vehicle. Valid vehicles are car.| 400        |
-      | Bike        |            | fastest   | Vehicle Bike is not a valid vehicle. Valid vehicles are car. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Name "vehicles"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage | statusCode |
-      | car         |            | fastest   | json           |              | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Value "point"
-    Given I have route point as
-      | pointA           | pointB              |
-      | 50.729961,string | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
-      | car         |            | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Incorrect Parameter Name "points"
-    Given I have route points as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    And I have vehicles as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                       | statusCode |
-      | car         |            | fastest   | json           | Parameter points is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Missing Parameter "point"
-    Given I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                | statusCode |
-      | car         |            | fastest   | json           | No point parameter provided | 400        |
-
-  @Routing @ErrorMessages
-  Scenario Outline: Invalid Parameter Value for "avoidances"
-    Given I have route point as
-      | pointA              | pointB              |
-      | 50.729961,-3.524853 | 50.723364,-3.523895 |
-    Given I have vehicle as "<vehicleType>"
-    And I have avoidances as "<avoidances>"
-    And I have weighting as "<routeType>"
-    And I have type as "<responseFormat>"
-    When I request for a route
-    Then I should be able to verify the response message as "<errorMessage>"
-    Then I should be able to verify the statuscode as "<statusCode>"
-
-    Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                                                                                     | statusCode |
-      | car         | trees      | fastest   | json           | Parameter blah is not a valid parameter for resource nearest. Valid parameters for requested resource are point. | 400        |
diff --git a/acceptancetesting/src/test/cucumber/routing.feature b/acceptancetesting/src/test/cucumber/routing.feature
index 2086f84143..91ff515b2f 100644
--- a/acceptancetesting/src/test/cucumber/routing.feature
+++ b/acceptancetesting/src/test/cucumber/routing.feature
@@ -909,7 +909,7 @@ Feature: Verify a route from A to B
       | vehicleType | avoidances | routeType |
       | car         |            | fastest   |
 
-  @Routing
+  @Routing @Current
   Scenario Outline: Verify  Route using 2 intermediate waypoints (Oxford to LONDON )
     Given I have route point as
       | pointA              | pointB              | pointC             | pointD              |
@@ -919,11 +919,11 @@ Feature: Verify a route from A to B
     And I have weighting as "<routeType>"
     When I request for a route
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco          | waypointdesc                          | azimuth | direction | time   | distance | avoidance |
-      | 5             | 51.748432,-1.261457 | Turn right onto THAMES STREET (A420)  | 108.0   | E         | 5178   | 83.9     |           |
-      | 21            | 51.823032,-1.290707 | Continue onto BANBURY ROAD (A4260)    | 314.0   | NW        | 556101 | 11829.3  |           |
-      | 32            | 52.057273,-1.340269 | Turn left onto BLOXHAM ROAD (A361)    | 253.0   | W         | 6069   | 75.9     |           |
-      | 67            | 52.288814,-1.607721 | Turn left onto BIRMINGHAM ROAD (A425) | 130.0   | SE        | 26878  | 396.7    |           |
+      | wayPointIndex | waypointco          | waypointdesc                              | azimuth | direction | time   | distance | avoidance |
+      | 5             | 51.748432,-1.261457 | Turn left onto THAMES STREET (A420)       | 275.0   | W         | 5517   | 145.6    |           |
+      | 21            | 51.922501,-1.324913 | Turn slight left onto OXFORD ROAD (A4260) | 342.0   | N         | 243586 | 6342.0   |           |
+      | 32            | 52.056919,-1.341208 | Turn right onto BEARGARDEN ROAD           | 324.0   | NW        | 24343  | 304.3    |           |
+      | 67            | 52.288814,-1.607721 | Turn left onto BIRMINGHAM ROAD (A425)     | 130.0   | SE        | 26878  | 396.7    |           |
 
     Examples: 
       | vehicleType | avoidances | routeType |
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f1d7256b66..2456cf044b 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -95,7 +95,8 @@
  * @see GraphHopperAPI
  * @author Peter Karich
  */
-public class GraphHopper implements GraphHopperAPI {
+public class GraphHopper implements GraphHopperAPI
+{
 	private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 	// for graph:
@@ -144,18 +145,20 @@
 	private final AtomicLong visitedSum = new AtomicLong(0);
 
 	/**
-	 * Certain readers require additional arguments so this can be passed to
-	 * them as a constructor parameter
+	 * Certain readers require additional arguments so this can be passed to them as a constructor
+	 * parameter
 	 */
 	private CmdArgs args;
 
-	public GraphHopper() {
+	public GraphHopper()
+	{
 	}
 
 	/**
 	 * For testing only
 	 */
-	protected GraphHopper loadGraph(GraphStorage g) {
+	protected GraphHopper loadGraph( GraphStorage g )
+	{
 		this.graph = g;
 		fullyLoaded = true;
 		initLocationIndex();
@@ -163,11 +166,11 @@ protected GraphHopper loadGraph(GraphStorage g) {
 	}
 
 	/**
-	 * Specify which vehicles can be read by this GraphHopper instance. An
-	 * encoding manager defines how data from every vehicle is written (und
-	 * read) into edges of the graph.
+	 * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
+	 * how data from every vehicle is written (und read) into edges of the graph.
 	 */
-	public GraphHopper setEncodingManager(EncodingManager em) {
+	public GraphHopper setEncodingManager( EncodingManager em )
+	{
 		ensureNotLoaded();
 		this.encodingManager = em;
 		if (em.needsTurnCostsSupport())
@@ -176,19 +179,23 @@ public GraphHopper setEncodingManager(EncodingManager em) {
 		return this;
 	}
 
-	FlagEncoder getDefaultVehicle() {
-		if (encodingManager == null) {
+	FlagEncoder getDefaultVehicle()
+	{
+		if (encodingManager == null)
+		{
 			throw new IllegalStateException("No encoding manager specified or loaded");
 		}
 
 		return encodingManager.fetchEdgeEncoders().get(0);
 	}
 
-	public EncodingManager getEncodingManager() {
+	public EncodingManager getEncodingManager()
+	{
 		return encodingManager;
 	}
 
-	public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
+	public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+	{
 		if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
 			setElevation(false);
 		else
@@ -200,24 +207,25 @@ public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
 	/**
 	 * Threads for data reading.
 	 */
-	protected int getWorkerThreads() {
+	protected int getWorkerThreads()
+	{
 		return workerThreads;
 	}
 
 	/**
-	 * Return maximum distance (in meter) to reduce points via douglas peucker
-	 * while OSM import.
+	 * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
 	 */
-	protected double getWayPointMaxDistance() {
+	protected double getWayPointMaxDistance()
+	{
 		return osmReaderWayPointMaxDistance;
 	}
 
 	/**
-	 * This parameter specifies how to reduce points via douglas peucker while
-	 * OSM import. Higher value means more details, unit is meter. Default is 1.
-	 * Disable via 0.
+	 * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+	 * value means more details, unit is meter. Default is 1. Disable via 0.
 	 */
-	public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
+	public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+	{
 		this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
 		return this;
 	}
@@ -225,55 +233,61 @@ public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
 	/**
 	 * Sets the default traversal mode used for the algorithms and preparation.
 	 */
-	public GraphHopper setTraversalMode(TraversalMode traversalMode) {
+	public GraphHopper setTraversalMode( TraversalMode traversalMode )
+	{
 		this.traversalMode = traversalMode;
 		return this;
 	}
 
-	public TraversalMode getTraversalMode() {
+	public TraversalMode getTraversalMode()
+	{
 		return traversalMode;
 	}
 
 	/**
-	 * Configures the underlying storage and response to be used on a well
-	 * equipped server. Result also optimized for usage in the web module i.e.
-	 * try reduce network IO.
+	 * Configures the underlying storage and response to be used on a well equipped server. Result
+	 * also optimized for usage in the web module i.e. try reduce network IO.
 	 */
-	public GraphHopper forServer() {
+	public GraphHopper forServer()
+	{
 		setSimplifyResponse(true);
 		return setInMemory();
 	}
 
 	/**
-	 * Configures the underlying storage to be used on a Desktop computer or
-	 * within another Java application with enough RAM but no network latency.
+	 * Configures the underlying storage to be used on a Desktop computer or within another Java
+	 * application with enough RAM but no network latency.
 	 */
-	public GraphHopper forDesktop() {
+	public GraphHopper forDesktop()
+	{
 		setSimplifyResponse(false);
 		return setInMemory();
 	}
 
 	/**
-	 * Configures the underlying storage to be used on a less powerful machine
-	 * like Android or Raspberry Pi with only few MB of RAM.
+	 * Configures the underlying storage to be used on a less powerful machine like Android or
+	 * Raspberry Pi with only few MB of RAM.
 	 */
-	public GraphHopper forMobile() {
+	public GraphHopper forMobile()
+	{
 		setSimplifyResponse(false);
 		return setMemoryMapped();
 	}
 
 	/**
-	 * Precise location resolution index means also more space (disc/RAM) could
-	 * be consumed and probably slower query times, which would be e.g. not
-	 * suitable for Android. The resolution specifies the tile width (in meter).
+	 * Precise location resolution index means also more space (disc/RAM) could be consumed and
+	 * probably slower query times, which would be e.g. not suitable for Android. The resolution
+	 * specifies the tile width (in meter).
 	 */
-	public GraphHopper setPreciseIndexResolution(int precision) {
+	public GraphHopper setPreciseIndexResolution( int precision )
+	{
 		ensureNotLoaded();
 		preciseIndexResolution = precision;
 		return this;
 	}
 
-	public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+	public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+	{
 		this.minNetworkSize = minNetworkSize;
 		this.minOneWayNetworkSize = minOneWayNetworkSize;
 	}
@@ -281,23 +295,23 @@ public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
 	/**
 	 * This method call results in an in-memory graph.
 	 */
-	public GraphHopper setInMemory() {
+	public GraphHopper setInMemory()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.RAM_STORE;
 		return this;
 	}
 
 	/**
-	 * Only valid option for in-memory graph and if you e.g. want to disable
-	 * store on flush for unit tests. Specify storeOnFlush to true if you want
-	 * that existing data will be loaded FROM disc and all in-memory data will
-	 * be flushed TO disc after flush is called e.g. while OSM import.
+	 * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
+	 * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+	 * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
 	 * <p>
-	 * 
-	 * @param storeOnFlush
-	 *            true by default
+	 *
+	 * @param storeOnFlush true by default
 	 */
-	public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
+	public GraphHopper setStoreOnFlush( boolean storeOnFlush )
+	{
 		ensureNotLoaded();
 		if (storeOnFlush)
 			dataAccessType = DAType.RAM_STORE;
@@ -307,10 +321,10 @@ public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
 	}
 
 	/**
-	 * Enable memory mapped configuration if not enough memory is available on
-	 * the target platform.
+	 * Enable memory mapped configuration if not enough memory is available on the target platform.
 	 */
-	public GraphHopper setMemoryMapped() {
+	public GraphHopper setMemoryMapped()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.MMAP;
 		return this;
@@ -319,50 +333,52 @@ public GraphHopper setMemoryMapped() {
 	/**
 	 * Not yet stable enough to offer it for everyone
 	 */
-	private GraphHopper setUnsafeMemory() {
+	private GraphHopper setUnsafeMemory()
+	{
 		ensureNotLoaded();
 		dataAccessType = DAType.UNSAFE_STORE;
 		return this;
 	}
 
 	/**
-	 * Enables the use of contraction hierarchies to reduce query times. Enabled
-	 * by default.
+	 * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
 	 * <p/>
-	 * 
-	 * @param weighting
-	 *            can be "fastest", "shortest" or your own weight-calculation
-	 *            type.
+	 *
+	 * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
 	 * @see #setCHEnable(boolean)
 	 */
-	public GraphHopper setCHWeighting(String weighting) {
+	public GraphHopper setCHWeighting( String weighting )
+	{
 		ensureNotLoaded();
 		chWeightingStr = weighting;
 		return this;
 	}
 
-	public String getCHWeighting() {
+	public String getCHWeighting()
+	{
 		return chWeightingStr;
 	}
 
 	/**
-	 * Disables the "CH-preparation" preparation only. Use only if you know what
-	 * you do. To disable the full usage of CH use setCHEnable(false) instead.
+	 * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+	 * the full usage of CH use setCHEnable(false) instead.
 	 */
-	public GraphHopper setDoPrepare(boolean doPrepare) {
+	public GraphHopper setDoPrepare( boolean doPrepare )
+	{
 		this.doPrepare = doPrepare;
 		return this;
 	}
 
 	/**
-	 * Enables or disables contraction hierarchies (CH). This speed-up mode is
-	 * enabled by default. Disabling CH is only recommended for short routes or
-	 * in combination with setDefaultWeightLimit and called flexibility mode
+	 * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+	 * Disabling CH is only recommended for short routes or in combination with
+	 * setDefaultWeightLimit and called flexibility mode
 	 * <p>
-	 * 
+	 *
 	 * @see #setDefaultWeightLimit(double)
 	 */
-	public GraphHopper setCHEnable(boolean enable) {
+	public GraphHopper setCHEnable( boolean enable )
+	{
 		ensureNotLoaded();
 		algoFactory = null;
 		chEnabled = enable;
@@ -370,60 +386,64 @@ public GraphHopper setCHEnable(boolean enable) {
 	}
 
 	/**
-	 * This methods stops the algorithm from searching further if the resulting
-	 * path would go over specified weight, important if CH is disabled. The
-	 * unit is defined by the used weighting created from createWeighting, e.g.
-	 * distance for shortest or seconds for the standard FastestWeighting
-	 * implementation.
+	 * This methods stops the algorithm from searching further if the resulting path would go over
+	 * specified weight, important if CH is disabled. The unit is defined by the used weighting
+	 * created from createWeighting, e.g. distance for shortest or seconds for the standard
+	 * FastestWeighting implementation.
 	 */
-	public void setDefaultWeightLimit(double defaultWeightLimit) {
+	public void setDefaultWeightLimit( double defaultWeightLimit )
+	{
 		this.defaultWeightLimit = defaultWeightLimit;
 	}
 
-	public boolean isCHEnabled() {
+	public boolean isCHEnabled()
+	{
 		return chEnabled;
 	}
 
 	/**
-	 * @return true if storing and fetching elevation data is enabled. Default
-	 *         is false
+	 * @return true if storing and fetching elevation data is enabled. Default is false
 	 */
-	public boolean hasElevation() {
+	public boolean hasElevation()
+	{
 		return elevation;
 	}
 
 	/**
 	 * Enable storing and fetching elevation data. Default is false
 	 */
-	public GraphHopper setElevation(boolean includeElevation) {
+	public GraphHopper setElevation( boolean includeElevation )
+	{
 		this.elevation = includeElevation;
 		return this;
 	}
 
 	/**
-	 * This method specifies if the import should include way names to be able
-	 * to return instructions for a route.
+	 * This method specifies if the import should include way names to be able to return
+	 * instructions for a route.
 	 */
-	public GraphHopper setEnableInstructions(boolean b) {
+	public GraphHopper setEnableInstructions( boolean b )
+	{
 		ensureNotLoaded();
 		enableInstructions = b;
 		return this;
 	}
 
 	/**
-	 * This methods enables gps point calculation. If disabled only distance
-	 * will be calculated.
+	 * This methods enables gps point calculation. If disabled only distance will be calculated.
 	 */
-	public GraphHopper setEnableCalcPoints(boolean b) {
+	public GraphHopper setEnableCalcPoints( boolean b )
+	{
 		calcPoints = b;
 		return this;
 	}
 
 	/**
-	 * This method specifies if the returned path should be simplified or not,
-	 * via douglas-peucker or similar algorithm.
+	 * This method specifies if the returned path should be simplified or not, via douglas-peucker
+	 * or similar algorithm.
 	 */
-	private GraphHopper setSimplifyResponse(boolean doSimplify) {
+	private GraphHopper setSimplifyResponse( boolean doSimplify )
+	{
 		this.simplifyResponse = doSimplify;
 		return this;
 	}
@@ -431,7 +451,8 @@ private GraphHopper setSimplifyResponse(boolean doSimplify) {
 	/**
 	 * Sets the graphhopper folder.
 	 */
-	public GraphHopper setGraphHopperLocation(String ghLocation) {
+	public GraphHopper setGraphHopperLocation( String ghLocation )
+	{
 		ensureNotLoaded();
 		if (ghLocation == null)
 			throw new IllegalArgumentException("graphhopper location cannot be null");
@@ -440,15 +461,17 @@ public GraphHopper setGraphHopperLocation(String ghLocation) {
 		return this;
 	}
 
-	public String getGraphHopperLocation() {
+	public String getGraphHopperLocation()
+	{
 		return ghLocation;
 	}
 
 	/**
-	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
-	 * .osm.gz) or a protobuf file (.pbf).
+	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
+	 * (.pbf).
 	 */
-	public GraphHopper setOSMFile(String osmFileStr) {
+	public GraphHopper setOSMFile( String osmFileStr )
+	{
 		ensureNotLoaded();
 		if (Helper.isEmpty(osmFileStr))
 			throw new IllegalArgumentException("OSM file cannot be empty.");
@@ -457,40 +480,43 @@ public GraphHopper setOSMFile(String osmFileStr) {
 		return this;
 	}
 
-	public String getOSMFile() {
+	public String getOSMFile()
+	{
 		return osmFile;
 	}
 
 	/**
 	 * The underlying graph used in algorithms.
 	 * <p>
-	 * 
-	 * @throws IllegalStateException
-	 *             if graph is not instantiated.
+	 *
+	 * @throws IllegalStateException if graph is not instantiated.
 	 */
-	public GraphStorage getGraph() {
+	public GraphStorage getGraph()
+	{
 		if (graph == null)
 			throw new IllegalStateException("Graph not initialized");
 
 		return graph;
 	}
 
-	public void setGraph(GraphStorage graph) {
+	public void setGraph( GraphStorage graph )
+	{
 		this.graph = graph;
 	}
 
-	protected void setLocationIndex(LocationIndex locationIndex) {
+	protected void setLocationIndex( LocationIndex locationIndex )
+	{
 		this.locationIndex = locationIndex;
 	}
 
 	/**
 	 * The location index created from the graph.
 	 * <p>
-	 * 
-	 * @throws IllegalStateException
-	 *             if index is not initialized
+	 *
+	 * @throws IllegalStateException if index is not initialized
 	 */
-	public LocationIndex getLocationIndex() {
+	public LocationIndex getLocationIndex()
+	{
 		if (locationIndex == null)
 			throw new IllegalStateException("Location index not initialized");
 
@@ -500,37 +526,40 @@ public LocationIndex getLocationIndex() {
 	/**
 	 * Sorts the graph which requires more RAM while import. See #12
 	 */
-	public GraphHopper setSortGraph(boolean sortGraph) {
+	public GraphHopper setSortGraph( boolean sortGraph )
+	{
 		ensureNotLoaded();
 		this.sortGraph = sortGraph;
 		return this;
 	}
 
 	/**
-	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only
-	 * filesystems it is not possible to create a lock file and so we can avoid
-	 * write locks.
+	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+	 * possible to create a lock file and so we can avoid write locks.
 	 */
-	public GraphHopper setAllowWrites(boolean allowWrites) {
+	public GraphHopper setAllowWrites( boolean allowWrites )
+	{
 		this.allowWrites = allowWrites;
 		return this;
 	}
 
-	public boolean isAllowWrites() {
+	public boolean isAllowWrites()
+	{
 		return allowWrites;
 	}
 
-	public TranslationMap getTranslationMap() {
+	public TranslationMap getTranslationMap()
+	{
 		return trMap;
 	}
 
 	/**
-	 * Reads configuration from a CmdArgs object. Which can be manually filled,
-	 * or via main(String[] args) ala CmdArgs.read(args) or via configuration
-	 * file ala CmdArgs.readFromConfig("config.properties",
-	 * "graphhopper.config")
+	 * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
+	 * args) ala CmdArgs.read(args) or via configuration file ala
+	 * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
 	 */
-	public GraphHopper init(CmdArgs args) {
+	public GraphHopper init( CmdArgs args )
+	{
 		args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
 		this.args = args;
 		String tmpOsmFile = args.get("osmreader.osm", "");
@@ -540,7 +569,8 @@ public GraphHopper init(CmdArgs args) {
 		dataReader = args.get("reader.implementation", dataReader);
 
 		String graphHopperFolder = args.get("graph.location", "");
-		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+		{
 			if (Helper.isEmpty(osmFile))
 				throw new IllegalArgumentException("You need to specify an OSM file.");
 
@@ -556,7 +586,7 @@ public GraphHopper init(CmdArgs args) {
 
 		sortGraph = args.getBool("graph.doSort", sortGraph);
 		removeZipped = args.getBool("graph.removeZipped", removeZipped);
-		int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
+		int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
 		if (args.get("graph.locktype", "native").equals("simple"))
 			lockFactory = new SimpleFSLockFactory();
 		else
@@ -569,11 +599,14 @@ public GraphHopper init(CmdArgs args) {
 		String baseURL = args.get("graph.elevation.baseurl", "");
 		DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
 		ElevationProvider tmpProvider = ElevationProvider.NOOP;
-		if (eleProviderStr.equalsIgnoreCase("srtm")) {
+		if (eleProviderStr.equalsIgnoreCase("srtm"))
+		{
 			tmpProvider = new SRTMProvider();
-		} else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
+		} else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+		{
 			CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
+			cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
+					true));
 			tmpProvider = cgiarProvider;
 		}
 
@@ -601,7 +634,8 @@ public GraphHopper init(CmdArgs args) {
 		logMessages = args.getDouble("prepare.logmessages", logMessages);
 
 		// osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+		osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
+				osmReaderWayPointMaxDistance);
 		String flagEncoders = args.get("graph.flagEncoders", "");
 		if (!flagEncoders.isEmpty())
 			setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
@@ -618,23 +652,27 @@ public GraphHopper init(CmdArgs args) {
 		return this;
 	}
 
-	private void printInfo() {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
+	private void printInfo()
+	{
+		logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
+				+ Constants.getVersions() + ")");
 		if (graph != null)
 			logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
 	}
 
 	/**
-	 * Imports provided data from disc and creates graph. Depending on the
-	 * settings the resulting graph will be stored to disc so on a second call
-	 * this method will only load the graph from disc which is usually a lot
-	 * faster.
+	 * Imports provided data from disc and creates graph. Depending on the settings the resulting
+	 * graph will be stored to disc so on a second call this method will only load the graph from
+	 * disc which is usually a lot faster.
 	 */
-	public GraphHopper importOrLoad() {
-		if (!load(ghLocation)) {
+	public GraphHopper importOrLoad()
+	{
+		if (!load(ghLocation))
+		{
 			printInfo();
 			process(ghLocation);
-		} else {
+		} else
+		{
 			printInfo();
 		}
 		return this;
@@ -643,11 +681,14 @@ public GraphHopper importOrLoad() {
 	/**
 	 * Creates the graph from OSM data.
 	 */
-	private GraphHopper process(String graphHopperLocation) {
+	private GraphHopper process( String graphHopperLocation )
+	{
 		setGraphHopperLocation(graphHopperLocation);
 		Lock lock = null;
-		try {
-			if (graph.getDirectory().getDefaultType().isStoring()) {
+		try
+		{
+			if (graph.getDirectory().getDefaultType().isStoring())
+			{
 				lockFactory.setLockDir(new File(graphHopperLocation));
 				lock = lockFactory.create(fileLockName, true);
 				if (!lock.tryLock())
@@ -656,24 +697,28 @@ private GraphHopper process(String graphHopperLocation) {
 									+ graphHopperLocation, lock.getObtainFailedReason());
 			}
 
-			try {
+			try
+			{
 				importData();
 				graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-			} catch (IOException ex) {
+			} catch (IOException ex)
+			{
 				throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
 			}
 			cleanUp();
 			optimize();
 			postProcessing();
 			flush();
-		} finally {
+		} finally
+		{
 			if (lock != null)
 				lock.release();
 		}
 		return this;
 	}
 
-	protected DataReader importData() throws IOException {
+	protected DataReader importData() throws IOException
+	{
 		ensureWriteAccess();
 		if (graph == null)
 			throw new IllegalStateException("Load graph before importing OSM data");
@@ -689,7 +734,8 @@ protected DataReader importData() throws IOException {
 		return reader;
 	}
 
-	protected DataReader createReader(GraphStorage tmpGraph) {
+	protected DataReader createReader( GraphStorage tmpGraph )
+	{
 		DataReader reader;
 		if ("OSM".equals(dataReader))
 			reader = new OSMReader(tmpGraph);
@@ -699,54 +745,66 @@ else if ("OSDPN".equals(dataReader))
 			reader = new OsDpnReader(tmpGraph, args);
 		else if ("OSHN".equals(dataReader))
 			reader = new OsHnReader(tmpGraph);
-		else {
+		else
+		{
 			String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
 			throw new IllegalArgumentException(exceptionMessage);
 		}
 		return initReader(reader);
 	}
 
-	protected DataReader initReader(DataReader reader) {
+	protected DataReader initReader( DataReader reader )
+	{
 		if (osmFile == null)
 			throw new IllegalArgumentException("No OSM file specified");
 
 		logger.info("start creating graph from " + osmFile);
 		File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider).setWorkerThreads(workerThreads)
-                .setEncodingManager(encodingManager).setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+		return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
+				.setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
+				.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
 	}
 
 	/**
 	 * Opens existing graph.
 	 * <p/>
-	 * 
-	 * @param graphHopperFolder
-	 *            is the folder containing graphhopper files (which can be
-	 *            compressed too)
+	 *
+	 * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
+	 *            too)
 	 */
 	@Override
-	public boolean load(String graphHopperFolder) {
+	public boolean load( String graphHopperFolder )
+	{
 		if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
+			throw new IllegalStateException(
+					"graphHopperLocation is not specified. call init before");
 
 		if (fullyLoaded)
 			throw new IllegalStateException("graph is already successfully loaded");
 
-		if (graphHopperFolder.endsWith("-gh")) {
+		if (graphHopperFolder.endsWith("-gh"))
+		{
 			// do nothing
-		} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml")) {
+		} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+		{
 			throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-		} else if (!graphHopperFolder.contains(".")) {
+		} else if (!graphHopperFolder.contains("."))
+		{
 			if (new File(graphHopperFolder + "-gh").exists())
 				graphHopperFolder += "-gh";
-		} else {
+		} else
+		{
 			File compressed = new File(graphHopperFolder + ".ghz");
-			if (compressed.exists() && !compressed.isDirectory()) {
-				try {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-				} catch (IOException ex) {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath() + " to "
-                            + graphHopperFolder, ex);
+			if (compressed.exists() && !compressed.isDirectory())
+			{
+				try
+				{
+					new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
+							removeZipped);
+				} catch (IOException ex)
+				{
+					throw new RuntimeException("Couldn't extract file "
+							+ compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
 				}
 			}
 		}
@@ -774,11 +832,13 @@ else if (encodingManager.needsAttributeStorageSupport())
 		graph.setSegmentSize(defaultSegmentSize);
 
 		Lock lock = null;
-		try {
+		try
+		{
 			// create locks only if writes are allowed, if they are not allowed
 			// a lock cannot be created
 			// (e.g. on a read only filesystem locks would fail)
-			if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
+			if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+			{
 				lockFactory.setLockDir(new File(ghLocation));
 				lock = lockFactory.create(fileLockName, false);
 				if (!lock.tryLock())
@@ -793,27 +853,31 @@ else if (encodingManager.needsAttributeStorageSupport())
 			postProcessing();
 			fullyLoaded = true;
 			return true;
-		} finally {
+		} finally
+		{
 			if (lock != null)
 				lock.release();
 		}
 	}
 
-	public RoutingAlgorithmFactory getAlgorithmFactory() {
+	public RoutingAlgorithmFactory getAlgorithmFactory()
+	{
 		if (algoFactory == null)
 			this.algoFactory = new RoutingAlgorithmFactorySimple();
 
 		return algoFactory;
 	}
 
-	public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+	public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+	{
 		this.algoFactory = algoFactory;
 	}
 
 	/**
 	 * Sets EncodingManager, does the preparation and creates the locationIndex
 	 */
-	protected void postProcessing() {
+	protected void postProcessing()
+	{
 		initLocationIndex();
 		if (chEnabled)
 			algoFactory = createPrepare();
@@ -824,68 +888,79 @@ protected void postProcessing() {
 			prepare();
 	}
 
-	private boolean isPrepared() {
+	private boolean isPrepared()
+	{
 		return "true".equals(graph.getProperties().get("prepare.done"));
 	}
 
-	protected RoutingAlgorithmFactory createPrepare() {
+	protected RoutingAlgorithmFactory createPrepare()
+	{
 		FlagEncoder defaultVehicle = getDefaultVehicle();
 		Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("",
-                DAType.RAM_INT), (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
+		PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
+				new GHDirectory("", DAType.RAM_INT), (LevelGraph) graph, defaultVehicle, weighting,
+				traversalMode);
 		tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
-				.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+		.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
 
 		return tmpPrepareCH;
 	}
 
 	/**
-	 * Based on the weightingParameters and the specified vehicle a Weighting
-	 * instance can be created. Note that all URL parameters are available in
-	 * the weightingParameters as String if you use the GraphHopper Web module.
+	 * Based on the weightingParameters and the specified vehicle a Weighting instance can be
+	 * created. Note that all URL parameters are available in the weightingParameters as String if
+	 * you use the GraphHopper Web module.
 	 * <p>
-	 * 
+	 *
 	 * @see WeightingMap
-	 * @param weightingMap
-	 *            all parameters influencing the weighting. E.g. parameters
-	 *            coming via GHRequest.getHints or directly via "&api.xy=" from
-	 *            the URL of the web UI
-	 * @param encoder
-	 *            the required vehicle
+	 * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+	 *            GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
+	 * @param encoder the required vehicle
 	 * @return the weighting to be used for route calculation
 	 */
-	public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder) {
+	public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+	{
 		String weighting = weightingMap.getWeighting();
 		Weighting result;
 
-		if ("shortest".equalsIgnoreCase(weighting)) {
+		if ("shortest".equalsIgnoreCase(weighting))
+		{
 			result = new ShortestWeighting();
-		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
+		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+		{
 			if (encoder.supports(PriorityWeighting.class))
 				result = new PriorityWeighting(encoder);
 			else
 				result = new FastestWeighting(encoder);
-		} else if ("fastavoid".equalsIgnoreCase(weighting)) {
+		} else if ("fastavoid".equalsIgnoreCase(weighting))
+		{
 			String avoidanceString = weightingMap.get("avoidances", "cliff");
 			String[] avoidances = avoidanceString.split(",");
-			if (encoder.supports(PriorityWeighting.class)) {
+			if (encoder.supports(PriorityWeighting.class))
+			{
 				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 						.getExtension();
 				result = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension,
 						avoidances);
-			} else {
+			} else
+			{
 				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 						.getExtension();
 				result = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
 			}
-		} else if ("shortavoid".equalsIgnoreCase(weighting)) {
+		} else if ("shortavoid".equalsIgnoreCase(weighting))
+		{
 			AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 					.getExtension();
 			String avoidanceString = weightingMap.get("avoidances", "cliff");
 			String[] avoidances = avoidanceString.split(",");
 			result = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
-		} else {
-			throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+		} else
+		{
+			throw new UnsupportedOperationException(
+					"Weighting "
+							+ weighting
+							+ " not supported. Valid weightings are shorted, fastest, fastavoid, shortavoid");
 		}
 		return result;
 	}
@@ -893,61 +968,71 @@ public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder)
 	/**
 	 * Potentially wraps the specified weighting into a TurnWeighting instance.
 	 */
-	public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
+	public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
+	{
 		if (encoder.supports(TurnWeighting.class))
 			return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
 		return weighting;
 	}
 
 	@Override
-	public GHResponse route(GHRequest request) {
+	public GHResponse route( GHRequest request )
+	{
 		GHResponse response = new GHResponse();
 		List<Path> paths = getPaths(request, response);
 		if (response.hasErrors())
 			return response;
 
-        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+		boolean tmpEnableInstructions = request.getHints().getBool("instructions",
+				enableInstructions);
 		boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
 		double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
 		Locale locale = request.getLocale();
 		DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
 		new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker)
-				.setEnableInstructions(tmpEnableInstructions)
-				.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
-				.doWork(response, paths, trMap.getWithFallBack(locale));
+		.setEnableInstructions(tmpEnableInstructions)
+		.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+		.doWork(response, paths, trMap.getWithFallBack(locale));
 		return response;
 	}
 
-	protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+	protected List<Path> getPaths( GHRequest request, GHResponse rsp )
+	{
 		if (graph == null || !fullyLoaded)
 			throw new IllegalStateException("Call load or importOrLoad before routing");
 
 		if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+			throw new IllegalStateException(
+					"You need to create a new GraphHopper instance as it is already closed");
 
 		String vehicle = request.getVehicle();
 		if (vehicle.isEmpty())
 			vehicle = getDefaultVehicle().toString();
 
-		if (!encodingManager.supports(vehicle)) {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. " + "Supported are: "
-                    + getEncodingManager()));
+		if (!encodingManager.supports(vehicle))
+		{
+			rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+					+ "Supported are: " + getEncodingManager()));
 			return Collections.emptyList();
 		}
 
 		TraversalMode tMode;
 		String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-		try {
+		try
+		{
 			tMode = TraversalMode.fromString(tModeStr);
-		} catch (Exception ex) {
+		} catch (Exception ex)
+		{
 			rsp.addError(ex);
 			return Collections.emptyList();
 		}
 
 		List<GHPoint> points = request.getPoints();
-		if (points.size() < 2) {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
+		if (points.size() < 2)
+		{
+			rsp.addError(new IllegalStateException(
+					"At least 2 points has to be specified, but was:" + points.size()));
 			return Collections.emptyList();
 		}
 
@@ -958,11 +1043,13 @@ public GHResponse route(GHRequest request) {
 
 		StopWatch sw = new StopWatch().start();
 		List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
-		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
+		{
 			GHPoint point = points.get(placeIndex);
 			QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
 			if (!res.isValid())
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+				rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
+						+ point));
 
 			qResults.add(res);
 		}
@@ -974,11 +1061,13 @@ public GHResponse route(GHRequest request) {
 
 		QueryGraph queryGraph;
 		RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-		if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString())) {
+		if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+		{
 			// fall back to normal traversing
 			tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
 			queryGraph = new QueryGraph(graph.getBaseGraph());
-		} else {
+		} else
+		{
 			queryGraph = new QueryGraph(graph);
 		}
 
@@ -986,15 +1075,26 @@ public GHResponse route(GHRequest request) {
 
 		List<Path> paths = new ArrayList<Path>(points.size() - 1);
 		QueryResult fromQResult = qResults.get(0);
-		Weighting weighting = createWeighting(request.getHints(), encoder);
+		Weighting weighting = null;
+		try
+		{
+			weighting = createWeighting(request.getHints(), encoder);
+		} catch (UnsupportedOperationException e)
+		{
+			// Message will define what is acceptable.
+			rsp.addError(new IllegalArgumentException(e.getMessage()));
+			return Collections.emptyList();
+		}
 		weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
 		double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
-        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode)
-                .flagEncoder(encoder).weighting(weighting).build();
+		String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request
+				.getAlgorithm();
+		AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr)
+				.traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
 
-		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+		{
 			QueryResult toQResult = qResults.get(placeIndex);
 			sw = new StopWatch().start();
 			RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
@@ -1004,10 +1104,12 @@ public GHResponse route(GHRequest request) {
 			sw = new StopWatch().start();
 			Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
 			if (path.getTime() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
+				throw new RuntimeException("Time was negative. Please report as bug and include:"
+						+ request);
 
 			paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+			debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
+					+ path.getDebugInfo();
 
 			visitedSum.addAndGet(algo.getVisitedNodes());
 			fromQResult = toQResult;
@@ -1017,18 +1119,21 @@ public GHResponse route(GHRequest request) {
 			return Collections.emptyList();
 
 		if (points.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size()
-							+ ", paths:" + paths.size());
+			throw new RuntimeException(
+					"There should be exactly one more places than paths. places:" + points.size()
+					+ ", paths:" + paths.size());
 
 		rsp.setDebugInfo(debug);
 		return paths;
 	}
 
-	protected LocationIndex createLocationIndex(Directory dir) {
+	protected LocationIndex createLocationIndex( Directory dir )
+	{
 		LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
 		tmpIndex.setResolution(preciseIndexResolution);
 		tmpIndex.setMaxRegionSearch(maxRegionSearch);
-		if (!tmpIndex.loadExisting()) {
+		if (!tmpIndex.loadExisting())
+		{
 			ensureWriteAccess();
 			tmpIndex.prepareIndex();
 		}
@@ -1039,14 +1144,16 @@ protected LocationIndex createLocationIndex(Directory dir) {
 	/**
 	 * Initializes the location index after the import is done.
 	 */
-	protected void initLocationIndex() {
+	protected void initLocationIndex()
+	{
 		if (locationIndex != null)
 			throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
 		locationIndex = createLocationIndex(graph.getDirectory());
 	}
 
-	protected void optimize() {
+	protected void optimize()
+	{
 		logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
 		graph.optimize();
 		logger.info("finished optimize (" + Helper.getMemInfo() + ")");
@@ -1054,9 +1161,11 @@ protected void optimize() {
 		// Later: move this into the GraphStorage.optimize method
 		// Or: Doing it after preparation to optimize shortcuts too. But not
 		// possible yet #12
-		if (sortGraph) {
+		if (sortGraph)
+		{
 			if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
+				throw new IllegalArgumentException(
+						"Sorting prepared LevelGraph is not possible yet. See #12");
 
 			GraphStorage newGraph = GHUtility.newStorage(graph);
 			GHUtility.sortDFS(graph, newGraph);
@@ -1065,20 +1174,25 @@ protected void optimize() {
 		}
 	}
 
-	protected void prepare() {
+	protected void prepare()
+	{
 		boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
-		if (tmpPrepare) {
+		if (tmpPrepare)
+		{
 			ensureWriteAccess();
-            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+			logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... ("
+					+ Helper.getMemInfo() + ")");
 			((PrepareContractionHierarchies) algoFactory).doWork();
 			graph.getProperties().put("prepare.date", formatDateTime(new Date()));
 		}
 		graph.getProperties().put("prepare.done", tmpPrepare);
 	}
 
-	protected void cleanUp() {
+	protected void cleanUp()
+	{
 		int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
+		PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
+				encodingManager);
 		preparation.setMinNetworkSize(minNetworkSize);
 		preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
 		logger.info("start finding subnetworks, " + Helper.getMemInfo());
@@ -1091,40 +1205,45 @@ protected void cleanUp() {
 				+ " less nodes. Remaining subnetworks:" + remainingSubnetworks);
 	}
 
-	protected void flush() {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
-                + Helper.getMemInfo() + ")");
+	protected void flush()
+	{
+		logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
+				+ ", " + Helper.getMemInfo() + ")");
 		graph.flush();
 		fullyLoaded = true;
 	}
 
 	/**
-	 * Releases all associated resources like memory or files. But it does not
-	 * remove them. To remove the files created in graphhopperLocation you have
-	 * to call clean().
+	 * Releases all associated resources like memory or files. But it does not remove them. To
+	 * remove the files created in graphhopperLocation you have to call clean().
 	 */
-	public void close() {
+	public void close()
+	{
 		if (graph != null)
 			graph.close();
 
 		if (locationIndex != null)
 			locationIndex.close();
 
-		try {
+		try
+		{
 			lockFactory.forceRemove(fileLockName, true);
-		} catch (Exception ex) {
+		} catch (Exception ex)
+		{
 			// silently fail e.g. on Windows where we cannot remove an
 			// unreleased native lock
 		}
 	}
 
 	/**
-	 * Removes the on-disc routing files. Call only after calling close or
-	 * before importOrLoad or load
+	 * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
+	 * load
 	 */
-	public void clean() {
+	public void clean()
+	{
 		if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+			throw new IllegalStateException(
+					"Cannot clean GraphHopper without specified graphHopperLocation");
 
 		File folder = new File(getGraphHopperLocation());
 		Helper.removeDir(folder);
@@ -1132,44 +1251,53 @@ public void clean() {
 
 	// make sure this is identical to buildDate used in pom.xml
 	// <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-	private String formatDateTime(Date date) {
+	private String formatDateTime( Date date )
+	{
 		return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
 	}
 
-	protected void ensureNotLoaded() {
+	protected void ensureNotLoaded()
+	{
 		if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+			throw new IllegalStateException(
+					"No configuration changes are possible after loading the graph");
 	}
 
-	protected void ensureWriteAccess() {
+	protected void ensureWriteAccess()
+	{
 		if (!allowWrites)
 			throw new IllegalStateException("Writes are not allowed!");
 	}
 
 	/**
-	 * Returns the current sum of the visited nodes while routing. Mainly for
-	 * statistic and debugging purposes.
+	 * Returns the current sum of the visited nodes while routing. Mainly for statistic and
+	 * debugging purposes.
 	 */
-	public long getVisitedSum() {
+	public long getVisitedSum()
+	{
 		return visitedSum.get();
 	}
 
-	public GraphHopper setAsOSMReader() {
+	public GraphHopper setAsOSMReader()
+	{
 		dataReader = "OSM";
 		return this;
 	}
 
-	public GraphHopper setAsItnReader() {
+	public GraphHopper setAsItnReader()
+	{
 		dataReader = "OSITN";
 		return this;
 	}
 
-	public GraphHopper setAsHnReader() {
+	public GraphHopper setAsHnReader()
+	{
 		dataReader = "OSHN";
 		return this;
 	}
 
-	public GraphHopper setAsDpnReader() {
+	public GraphHopper setAsDpnReader()
+	{
 		dataReader = "OSDPN";
 		return this;
 	}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
index a1f166c0e1..29ca7faeec 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAvoidanceDecorator.java
@@ -7,16 +7,22 @@
 public abstract class AbstractAvoidanceDecorator implements EncoderDecorator {
 
 	protected EncodedValue wayTypeEncoder;
+	protected int originalShift;
 	public static final int KEY = 303;
 
 	protected abstract void defineEncoder(int shift);
 	protected abstract EdgeAttribute[] getEdgeAttributesOfInterest();
 
 	public int defineWayBits(int shift) {
+		originalShift = shift;
 		defineEncoder(shift);
 		shift += wayTypeEncoder.getBits();
 		return shift;
 	}
+	
+	public int getOriginalShift() {
+		return originalShift;
+	}
 
 	public InstructionAnnotation getAnnotation( long flags, Translation tr )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
index 84975c7e58..983f3db2f8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncoderDecorator.java
@@ -12,4 +12,5 @@
 	double getDouble(long flags);
 	long getLong(long flags);
 	boolean supports(int key);
+	int getOriginalShift();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 97cbc3953e..6f002c31f3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -470,7 +470,8 @@ public void applyWayTags( Way way, EdgeIteratorState edge )
 	}
 
 	/**
-	 * Each encoder decorator should be used only once and in a defined order
+	 * Each encoder decorator should be used only once for storage and in a defined order.
+	 * However each encoder needs its decorator list to be configured the same way.
 	 */
 	private void configureDecoratorSet()
 	{
@@ -493,6 +494,20 @@ private void configureDecoratorSet()
 		{
 			shift = decorator.defineWayBits(shift);
 		}
+		for (AbstractFlagEncoder encoder : edgeEncoders)
+		{
+			List<EncoderDecorator> decoratorList = encoder.getEncoderDecorators();
+			if (null != decoratorList)
+			{
+				for (EncoderDecorator encoderDecorator : decoratorList)
+				{
+					EncoderDecorator configuredDecorator = decoratorMap.get(encoderDecorator.getClass());
+					if(configuredDecorator != encoderDecorator) {
+						encoderDecorator.defineWayBits(configuredDecorator.getOriginalShift());
+					}
+				}
+			}
+		}
 	}
 
 	public List<EncoderDecorator> getDecorators()
diff --git a/web/src/main/java/com/graphhopper/http/APIException.java b/web/src/main/java/com/graphhopper/http/APIException.java
new file mode 100644
index 0000000000..70f9634612
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/APIException.java
@@ -0,0 +1,26 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus;
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class APIException extends Exception {
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+	private HttpStatus.Code statusCode;
+
+	public APIException(Code statusCode, String message) {
+		super(message);
+		this.statusCode = statusCode;
+	}
+	
+	public HttpStatus.Code getStatusCode() {
+		return statusCode;
+	}
+	
+	public String getStatusMessage() {
+		return getMessage();
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/ApiResource.java b/web/src/main/java/com/graphhopper/http/ApiResource.java
new file mode 100644
index 0000000000..24d654d8fe
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/ApiResource.java
@@ -0,0 +1,147 @@
+package com.graphhopper.http;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.servlet.http.HttpServletRequest;
+ 
+ 
+public enum ApiResource {
+	ROUTE("route", new String[]{"point","vehicle"}, new String[] { "point", "locale", "instructions", "vehicle", "weighting", "algorithm", "points_encoded", "debug", "calc_points","tye","avoidances" }),
+    NEAREST("nearest", new String[]{"point"}, new String[] { "point"}),
+	INFO("info", new String[]{}, new String[] { });
+	   
+	
+    public String[] getMandatoryValues() {
+        return mandatoryValues;
+    }
+ 
+ 
+    public String[] getValidValues() {
+        return validValues;
+    }
+ 
+ 
+    public String getResourceName() {
+        return resourceName;
+    }
+ 
+ 
+    private String resourceName;
+    private String[] mandatoryValues;
+    private String[] validValues;
+ 
+ 
+    private ApiResource(String resourceName, String[] mandatoryValues, String[] validValues) {
+        this.resourceName = resourceName;
+        this.mandatoryValues = mandatoryValues;
+        this.validValues = validValues;
+    }
+   
+    /**
+     * Scans through all the request parameters. Checks if the mandatory field
+     * exists for a resource. Checks if all the request parameters are valid for
+     * the resource. Throws appropriate exceptions if not
+     *
+     * @param HttpServletRequest
+     * @param APIResource
+     *
+     * @throws MissingParameterException
+     * @throws NoSuchParameterException
+     */
+    public void checkAllRequestParameters(HttpServletRequest request)
+            throws MissingParameterException, NoSuchParameterException, InvalidParameterException {
+        // Check if the mandatory parameter exists in the request
+        String value =  this.getMandatoryValues()[0];
+        boolean mandatoryValueExists = checkMandatoryValue(request, value);
+        if( mandatoryValueExists && this.getMandatoryValues().length > 1 )
+        {
+            value =  this.getMandatoryValues()[1];
+            mandatoryValueExists = checkMandatoryValue(request, value);
+        }
+        if(!mandatoryValueExists)
+        {
+            throw new MissingParameterException(value);
+        }
+       
+        // Now check for all the valid parameters for the resource
+        checkValidParameters(request);
+    }
+   
+    /**
+     * Checks if the given mandatory value exists in the request parameters
+     *
+     * @param parameters Enumeration<String>
+     * @param mandatoryValue
+     * @return
+     */
+    private boolean checkMandatoryValue(HttpServletRequest request, String mandatoryValue)
+    {
+        Set<String> keys = request.getParameterMap().keySet();
+        for(String key: keys)
+       {
+            if(mandatoryValue.equalsIgnoreCase(key))
+            {
+                return true;
+            }
+        }       
+        return false;
+    }
+   
+    /**
+     * Checks if all the valid parameters exist in the request for the resource
+     *
+     * @param request
+     * @throws NoSuchParameterException
+     * @throws InvalidParameterException
+     */
+    private void checkValidParameters(HttpServletRequest request) throws NoSuchParameterException, InvalidParameterException
+    {
+        // Now check for all the valid parameters for the resource
+        List<String> list = Arrays.asList(this.getValidValues());
+        Map<String, String[]> parameterMap = request.getParameterMap();
+        for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
+            String parameterName = entry.getKey().toLowerCase();
+            if (!list.contains(parameterName)) {
+                throw new NoSuchParameterException(getInvalidParameterMessage(
+                        parameterName, this.getResourceName(), this.getValidValues()));
+            }
+        }
+    }
+ 
+ 
+    /**
+     * Builds the message when the parameter provided is invalid
+     *
+     * @param invalid
+     * @param parameter
+     * @param validValues
+     * @return message String
+     */
+    private String getInvalidParameterMessage(String invalid, String parameter,
+            String[] validValues) {
+        StringBuilder sb = new StringBuilder();
+ 
+ 
+        sb.append("Parameter ").append(invalid)
+        .append(" is not a valid parameter for resource ")
+        .append(parameter)
+        .append(". Valid parameters for requested resource are ");
+ 
+ 
+        List<String> validList = Arrays.asList(validValues);
+        for (String valid : validList) {
+            sb.append(valid).append(", ");
+        }
+        String message = sb.substring(0, sb.length() - 2) + ".";
+ 
+ 
+        return message;
+    }
+ 
+ 
+ 
+ 
+}
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 9ca5a32c23..40bcf716c4 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,48 +17,45 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_OK;
+
+import java.io.IOException;
 
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-import static javax.servlet.http.HttpServletResponse.SC_OK;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * @author Peter Karich
  */
-public class GHBaseServlet extends HttpServlet
-{
+public class GHBaseServlet extends HttpServlet {
     protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonpAllowed")
-    private boolean jsonpAllowed;
+    protected boolean jsonpAllowed;
 
-    protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException, IOException
-    {
+    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JSONObject json) throws JSONException,
+            IOException {
         String type = getParam(req, "type", "json");
         res.setCharacterEncoding("UTF-8");
         boolean debug = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
-        if ("jsonp".equals(type))
-        {
+        if ("jsonp".equals(type)) {
             res.setContentType("application/javascript");
-            if (!jsonpAllowed)
-            {
+            if (!jsonpAllowed) {
                 writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
-            if (callbackName == null)
-            {
+            if (callbackName == null) {
                 writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
@@ -68,8 +65,7 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
 
-        } else
-        {
+        } else {
             res.setContentType("application/json");
             if (debug)
                 writeResponse(res, json.toString(2));
@@ -78,31 +74,26 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
         }
     }
 
-    protected void writeError( HttpServletResponse res, int code, String message )
-    {
+    protected void writeError(HttpServletResponse res, int code, String message) {
         JSONObject json = new JSONObject();
         json.put("message", message);
         writeJsonError(res, code, json);
     }
 
-    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
-    {
-        try
-        {
+    protected void writeJsonError(HttpServletResponse res, int code, JSONObject json) {
+        try {
             // no type parameter check here as jsonp does not work if an error
             // also no debug parameter yet
             res.setContentType("application/json");
             res.setCharacterEncoding("UTF-8");
             res.setStatus(code);
             res.getWriter().append(json.toString(2));
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write error " + ex.getMessage());
         }
     }
 
-    protected String getParam( HttpServletRequest req, String string, String _default )
-    {
+    protected String getParam(HttpServletRequest req, String string, String _default) {
         String[] l = req.getParameterMap().get(string);
         if (l != null && l.length > 0)
             return l[0];
@@ -110,57 +101,43 @@ protected String getParam( HttpServletRequest req, String string, String _defaul
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String string )
-    {
+    protected String[] getParams(HttpServletRequest req, String string) {
         String[] l = req.getParameterMap().get(string);
-        if (l != null && l.length > 0)
-        {
+        if (l != null && l.length > 0) {
             return l;
         }
         return new String[0];
     }
 
-    protected long getLongParam( HttpServletRequest req, String string, long _default )
-    {
-        try
-        {
+    protected long getLongParam(HttpServletRequest req, String string, long _default) {
+        try {
             return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
-    {
-        try
-        {
+    protected boolean getBooleanParam(HttpServletRequest req, String string, boolean _default) {
+        try {
             return Boolean.parseBoolean(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String string, double _default )
-    {
-        try
-        {
+    protected double getDoubleParam(HttpServletRequest req, String string, double _default) {
+        try {
             return Double.parseDouble(getParam(req, string, "" + _default));
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             return _default;
         }
     }
 
-    public void writeResponse( HttpServletResponse res, String str )
-    {
-        try
-        {
+    public void writeResponse(HttpServletResponse res, String str) {
+        try {
             res.setStatus(SC_OK);
             res.getWriter().append(str);
-        } catch (IOException ex)
-        {
+        } catch (IOException ex) {
             logger.error("Cannot write message:" + str, ex);
         }
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 799a0eb07f..16060af410 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,21 +17,16 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPoint;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 
-import org.json.JSONObject;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -45,266 +40,312 @@
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
 
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-import java.util.Map.Entry;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
  * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
  * used otherwise. See the full API response format in docs/web/api-doc.md
  * <p/>
+ *
  * @author Peter Karich
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
-    @Inject
-    private GraphHopper hopper;
-    
-    @Named("internalErrorsAllowed")
-    private boolean internalErrorsAllowed;
-
-    @Override
-    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
-    {
-        List<GHPoint> infoPoints = getPoints(httpReq, "point");
-
-        // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
-        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
-        boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
-        boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
-
-        String vehicleStr = getParam(httpReq, "vehicle", "car");
-        String weighting = getParam(httpReq, "weighting", "fastest");
-        String algoStr = getParam(httpReq, "algorithm", "");
-        String localeStr = getParam(httpReq, "locale", "en");
-
-        StopWatch sw = new StopWatch().start();
-        GHResponse ghRsp;
-        if (!hopper.getEncodingManager().supports(vehicleStr))
-        {
-        	String supported = hopper.getGraph().getEncodingManager().toString();
-        	String errMesg = String.format("Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr, supported);
-            ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
-        } else if (enableElevation && !hopper.hasElevation())
-        {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
-        } else
-        {
-            FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-            GHRequest request = new GHRequest(infoPoints);
-
-            initHints(request, httpReq.getParameterMap());
-            request.setVehicle(algoVehicle.toString()).
-                    setWeighting(weighting).
-                    setAlgorithm(algoStr).
-                    setLocale(localeStr).
-                    getHints().
-                    put("calcPoints", calcPoints).
-                    put("instructions", enableInstructions).
-                    put("wayPointMaxDistance", minPathPrecision);
-
-            ghRsp = hopper.route(request);
-        }
-
-        float took = sw.stop().getSeconds();
-        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
-        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
-                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
-
-        if (ghRsp.hasErrors())
-            logger.error(logStr + ", errors:" + ghRsp.getErrors());
-        else
-            logger.info(logStr + ", distance: " + ghRsp.getDistance()
-                    + ", time:" + Math.round(ghRsp.getTime() / 60000f)
-                    + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
-
-        if (writeGPX)
-        {
-            String xml = createGPXString(httpReq, httpRes, ghRsp);
-            if (ghRsp.hasErrors())
-            {
-                httpRes.setStatus(SC_BAD_REQUEST);
-                httpRes.getWriter().append(xml);
-            } else
-                writeResponse(httpRes, xml);
-        } else
-        {
-            Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation, enableInstructions);
-            Object infoMap = map.get("info");
-            if (infoMap != null)
-                ((Map) infoMap).put("took", Math.round(took * 1000));
-
-            if (ghRsp.hasErrors())
-            {
-                writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
-            } else
-                writeJson(httpReq, httpRes, new JSONObject(map));
-        }
-    }
-
-    protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
-    {
-        boolean includeElevation = getBooleanParam(req, "elevation", false);
-        res.setCharacterEncoding("UTF-8");
-        res.setContentType("application/xml");
-        String trackName = getParam(req, "track", "GraphHopper Track");
-        res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-        long time = getLongParam(req, "millis", System.currentTimeMillis());
-        if (rsp.hasErrors())
-            return errorsToXML(rsp.getErrors());
-        else
-            return rsp.getInstructions().createGPX(trackName, time, includeElevation);
-    }
-
-    String errorsToXML( List<Throwable> list )
-    {
-        try
-        {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            DocumentBuilder builder = factory.newDocumentBuilder();
-            Document doc = builder.newDocument();
-            Element gpxElement = doc.createElement("gpx");
-            gpxElement.setAttribute("creator", "GraphHopper");
-            gpxElement.setAttribute("version", "1.1");
-            doc.appendChild(gpxElement);
-
-            Element mdElement = doc.createElement("metadata");
-            gpxElement.appendChild(mdElement);
-
-            Element extensionsElement = doc.createElement("extensions");
-            mdElement.appendChild(extensionsElement);
-
-            Element messageElement = doc.createElement("message");
-            extensionsElement.appendChild(messageElement);
-            messageElement.setTextContent(list.get(0).getMessage());
-
-            Element hintsElement = doc.createElement("hints");
-            extensionsElement.appendChild(hintsElement);
-
-            for (Throwable t : list)
-            {
-                Element error = doc.createElement("error");
-                hintsElement.appendChild(error);
-                error.setAttribute("message", t.getMessage());
-                if(internalErrorsAllowed) {
-                	error.setAttribute("details", t.getClass().getName());
-                }
-            }
-            TransformerFactory transformerFactory = TransformerFactory.newInstance();
-            Transformer transformer = transformerFactory.newTransformer();
-            StringWriter writer = new StringWriter();
-            transformer.transform(new DOMSource(doc), new StreamResult(writer));
-            return writer.toString();
-        } catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    protected Map<String, Object> createJson( GHResponse rsp,
-                                              boolean calcPoints, boolean pointsEncoded,
-                                              boolean includeElevation, boolean enableInstructions )
-    {
-        Map<String, Object> json = new HashMap<String, Object>();
-
-        if (rsp.hasErrors())
-        {
-        	Map<String, String> map = new HashMap<String, String>();
-            json.put("error",map);
-            Throwable throwable = rsp.getErrors().get(0);
-            map.put("message", throwable.getMessage());
-            map.put("statuscode", "404");
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
-            {
-                Map<String, String> hintMap = new HashMap<String, String>();
-                hintMap.put("message", t.getMessage());
-//                if(internalErrorsAllowed) {
-                hintMap.put("details", t.getClass().getName());
-//                }
-                list.add(hintMap);
-            }
-            json.put("hints", list);
-        } else
-        {
-            Map<String, Object> jsonInfo = new HashMap<String, Object>();
-            json.put("info", jsonInfo);
-//            jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
-            Map<String, Object> jsonPath = new HashMap<String, Object>();
-            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getTime());
-
-            if (calcPoints)
-            {
-                jsonPath.put("points_encoded", pointsEncoded);
-
-                PointList points = rsp.getPoints();
-                if (points.getSize() >= 2)
-                {
-                    BBox maxBounds = hopper.getGraph().getBounds();
-                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
-                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
-                }
-
-                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-                if (enableInstructions)
-                {
-                    InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson());
-                }
-            }
-            json.put("paths", Collections.singletonList(jsonPath));
-        }
-        return json;
-    }
-
-    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
-        if (pointsEncoded)
-            return WebHelper.encodePolyline(points, includeElevation);
-
-        Map<String, Object> jsonPoints = new HashMap<String, Object>();
-        jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-        return jsonPoints;
-    }
-
-    protected List<GHPoint> getPoints( HttpServletRequest req, String key )
-    {
-        String[] pointsAsStr = getParams(req, key);
-        final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
-        for (String str : pointsAsStr)
-        {
-            String[] fromStrs = str.split(",");
-            if (fromStrs.length == 2)
-            {
-                GHPoint point = GHPoint.parse(str);
-                if (point != null)
-                {
-                    infoPoints.add(point);
-                }
-            }
-        }
-
-        return infoPoints;
-    }
-
-    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
-    {
-        WeightingMap m = request.getHints();
-        for (Entry<String, String[]> e : parameterMap.entrySet())
-        {
-            if (e.getValue().length == 1)
-                m.put(e.getKey(), e.getValue()[0]);
-        }
-    }
+	@Inject
+	private GraphHopper hopper;
+
+	@Named("internalErrorsAllowed")
+	private boolean internalErrorsAllowed;
+
+	@Override
+	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
+	        throws ServletException, IOException
+	{
+		List<GHPoint> infoPoints = getPoints(httpReq, "point");
+
+		// we can reduce the path length based on the maximum differences to the
+		// original coordinates
+		double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+		boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+		boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+		boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+		boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
+		boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
+
+		String vehicleStr = getParam(httpReq, "vehicle", "car");
+		String weighting = getParam(httpReq, "weighting", "fastest");
+		String algoStr = getParam(httpReq, "algorithm", AlgorithmOptions.DIJKSTRA_BI);
+		String localeStr = getParam(httpReq, "locale", "en");
+
+		StopWatch sw = new StopWatch().start();
+		GHResponse ghRsp;
+
+		String instructionsString = getParam(httpReq, "instructions", "true");
+		if (!AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr)
+		        && !AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr)
+		        && !AlgorithmOptions.DIJKSTRA.equalsIgnoreCase(algoStr)
+		        && !AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr)
+		        && !AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
+		{
+			String errMesg = String
+			        .format("%s is not a valid value for parameter algorithm. Valid values are %s, %s, %s, %s or %s",
+			                algoStr, AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+			                AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+			                AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
+			ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+		} else if (!"true".equalsIgnoreCase(instructionsString)
+		        && !"false".equalsIgnoreCase(instructionsString))
+		{
+			String errMesg = String
+			        .format("%s is not a valid value for parameter instructions. Valid vehicles are true or false",
+			                instructionsString);
+			ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+		} else if (!hopper.getEncodingManager().supports(vehicleStr))
+		{
+			String supported = hopper.getGraph().getEncodingManager().toString();
+			String errMesg = String.format(
+			        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
+			        supported);
+			ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+		} else if (enableElevation && !hopper.hasElevation())
+		{
+			ghRsp = new GHResponse().addError(new IllegalArgumentException(
+			        "Elevation not supported!"));
+		} else
+		{
+			FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
+			GHRequest request = new GHRequest(infoPoints);
+
+			initHints(request, httpReq.getParameterMap());
+			request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
+			        .setAlgorithm(algoStr).setLocale(localeStr).getHints()
+			        .put("calcPoints", calcPoints).put("instructions", enableInstructions)
+			        .put("wayPointMaxDistance", minPathPrecision);
+
+			ghRsp = hopper.route(request);
+		}
+
+		float took = sw.stop().getSeconds();
+		String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
+		        + httpReq.getHeader("User-Agent");
+		String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+		        + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+
+		if (ghRsp.hasErrors())
+			logger.error(logStr + ", errors:" + ghRsp.getErrors());
+		else
+			logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
+			        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
+			        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
+
+		if (writeGPX)
+		{
+			String xml = createGPXString(httpReq, httpRes, ghRsp);
+			if (ghRsp.hasErrors())
+			{
+				httpRes.setStatus(SC_BAD_REQUEST);
+				httpRes.getWriter().append(xml);
+			} else
+				writeResponse(httpRes, xml);
+		} else
+		{
+			String type = getParam(httpReq, "type", "json");
+			if (!"json".equalsIgnoreCase(type) || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
+			{
+				String errorMessage = type
+				        + " is not a valid value for parameter type. Valid values are ";
+				errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
+				ghRsp.addError(new IllegalArgumentException(errorMessage));
+			}
+			Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation,
+			        enableInstructions);
+			Object infoMap = map.get("info");
+			if (infoMap != null)
+				((Map) infoMap).put("took", Math.round(took * 1000));
+
+			if (ghRsp.hasErrors())
+			{
+				writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+			} else
+				writeJson(httpReq, httpRes, new JSONObject(map));
+		}
+	}
+
+	protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
+	        GHResponse rsp )
+	{
+		boolean includeElevation = getBooleanParam(req, "elevation", false);
+		res.setCharacterEncoding("UTF-8");
+		res.setContentType("application/xml");
+		String trackName = getParam(req, "track", "GraphHopper Track");
+		res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
+		long time = getLongParam(req, "millis", System.currentTimeMillis());
+		if (rsp.hasErrors())
+			return errorsToXML(rsp.getErrors());
+		else
+			return rsp.getInstructions().createGPX(trackName, time, includeElevation);
+	}
+
+	String errorsToXML( List<Throwable> list )
+	{
+		try
+		{
+			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+			DocumentBuilder builder = factory.newDocumentBuilder();
+			Document doc = builder.newDocument();
+			Element gpxElement = doc.createElement("gpx");
+			gpxElement.setAttribute("creator", "GraphHopper");
+			gpxElement.setAttribute("version", "1.1");
+			doc.appendChild(gpxElement);
+
+			Element mdElement = doc.createElement("metadata");
+			gpxElement.appendChild(mdElement);
+
+			Element extensionsElement = doc.createElement("extensions");
+			mdElement.appendChild(extensionsElement);
+
+			Element messageElement = doc.createElement("message");
+			extensionsElement.appendChild(messageElement);
+			messageElement.setTextContent(list.get(0).getMessage());
+
+			Element hintsElement = doc.createElement("hints");
+			extensionsElement.appendChild(hintsElement);
+
+			for (Throwable t : list)
+			{
+				Element error = doc.createElement("error");
+				hintsElement.appendChild(error);
+				error.setAttribute("message", t.getMessage());
+				if (internalErrorsAllowed)
+				{
+					error.setAttribute("details", t.getClass().getName());
+				}
+			}
+			TransformerFactory transformerFactory = TransformerFactory.newInstance();
+			Transformer transformer = transformerFactory.newTransformer();
+			StringWriter writer = new StringWriter();
+			transformer.transform(new DOMSource(doc), new StreamResult(writer));
+			return writer.toString();
+		} catch (Exception ex)
+		{
+			throw new RuntimeException(ex);
+		}
+	}
+
+	protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
+	        boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
+	{
+		Map<String, Object> json = new HashMap<String, Object>();
+
+		if (rsp.hasErrors())
+		{
+			Map<String, String> map = new HashMap<String, String>();
+			json.put("error", map);
+			Throwable throwable = rsp.getErrors().get(0);
+			map.put("message", throwable.getMessage());
+			map.put("statuscode", "404");
+			List<Map<String, String>> list = new ArrayList<Map<String, String>>();
+			for (Throwable t : rsp.getErrors())
+			{
+				Map<String, String> hintMap = new HashMap<String, String>();
+				hintMap.put("message", t.getMessage());
+				// if(internalErrorsAllowed) {
+				hintMap.put("details", t.getClass().getName());
+				// }
+				list.add(hintMap);
+			}
+			json.put("hints", list);
+		} else
+		{
+			Map<String, Object> jsonInfo = new HashMap<String, Object>();
+			json.put("info", jsonInfo);
+			// jsonInfo.put("copyrights", Arrays.asList("GraphHopper",
+			// "OpenStreetMap contributors"));
+			Map<String, Object> jsonPath = new HashMap<String, Object>();
+			jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+			jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+			jsonPath.put("time", rsp.getTime());
+
+			if (calcPoints)
+			{
+				jsonPath.put("points_encoded", pointsEncoded);
+
+				PointList points = rsp.getPoints();
+				if (points.getSize() >= 2)
+				{
+					BBox maxBounds = hopper.getGraph().getBounds();
+					BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
+					        maxBounds.minLat, maxBounds.maxLat);
+					jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+				}
+
+				jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+				if (enableInstructions)
+				{
+					InstructionList instructions = rsp.getInstructions();
+					jsonPath.put("instructions", instructions.createJson());
+				}
+			}
+			json.put("paths", Collections.singletonList(jsonPath));
+		}
+		return json;
+	}
+
+	protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+	{
+		if (pointsEncoded)
+			return WebHelper.encodePolyline(points, includeElevation);
+
+		Map<String, Object> jsonPoints = new HashMap<String, Object>();
+		jsonPoints.put("type", "LineString");
+		jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+		return jsonPoints;
+	}
+
+	protected List<GHPoint> getPoints( HttpServletRequest req, String key )
+	{
+		String[] pointsAsStr = getParams(req, key);
+		final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
+		for (String str : pointsAsStr)
+		{
+			String[] fromStrs = str.split(",");
+			if (fromStrs.length == 2)
+			{
+				GHPoint point = GHPoint.parse(str);
+				if (point != null)
+				{
+					infoPoints.add(point);
+				}
+			}
+		}
+
+		return infoPoints;
+	}
+
+	protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
+	{
+		WeightingMap m = request.getHints();
+		for (Entry<String, String[]> e : parameterMap.entrySet())
+		{
+			if (e.getValue().length == 1)
+				m.put(e.getKey(), e.getValue()[0]);
+		}
+	}
 }
diff --git a/web/src/main/java/com/graphhopper/http/InvalidParameterException.java b/web/src/main/java/com/graphhopper/http/InvalidParameterException.java
new file mode 100644
index 0000000000..526d4ce38e
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/InvalidParameterException.java
@@ -0,0 +1,17 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class InvalidParameterException extends APIException {
+
+	public InvalidParameterException(String message )
+    {
+	    super(Code.BAD_REQUEST, message);
+    }
+
+	/**
+	 * 
+	 */
+    private static final long serialVersionUID = 1L;
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/MissingParameterException.java b/web/src/main/java/com/graphhopper/http/MissingParameterException.java
new file mode 100644
index 0000000000..5300e9ba2f
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/MissingParameterException.java
@@ -0,0 +1,18 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus;
+
+public class MissingParameterException extends APIException {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+	
+	private static String message = "No %s parameter provided.";
+
+	public MissingParameterException(String parameter) {
+		super(HttpStatus.Code.BAD_REQUEST, String.format(message , parameter));
+	}
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java b/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java
new file mode 100644
index 0000000000..aaf6cf4d18
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/NoSuchParameterException.java
@@ -0,0 +1,16 @@
+package com.graphhopper.http;
+
+import org.eclipse.jetty.http.HttpStatus.Code;
+
+public class NoSuchParameterException extends APIException {
+
+	public NoSuchParameterException(String message) {
+		super(Code.BAD_REQUEST, message);
+	}
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+
+}
