diff --git a/acceptancetesting/src/test/cucumber/DPNRouting.feature b/acceptancetesting/src/test/cucumber/DPNRouting.feature
index 57bd62a0f0..3fc0146a5e 100644
--- a/acceptancetesting/src/test/cucumber/DPNRouting.feature
+++ b/acceptancetesting/src/test/cucumber/DPNRouting.feature
@@ -775,3 +775,21 @@ Feature: Verify a route from A to B
     Examples: 
       | vehicleType  | avoidances | routeType |
       | mountainbike | Cliff      | fastavoid |
+#2 intermediate waypoints for mountainbike
+ @Routing
+  Scenario Outline: Verify  Route using( 2 intermediate waypoints for mountainbike )
+    Given I have route point as
+      | pointA            | pointB              | pointC             | pointD              |
+      | 54.2948,-2.204429 | 54.276757,-2.196492 | 54.26687,-2.203109 | 54.256984,-2.208218 |
+    And I have vehicle as "<vehicleType>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                        | azimuth | direction | time   | distance | avoidance |
+      | 2             | 54.295461,-2.20503  | Turn slight right onto Route        | 39.0    | NE        | 94634  | 131.4    | Boulders  |
+      | 13            | 54.273671,-2.196382 | Turn sharp right onto Cam High Road | 227.0   | SW        | 651877 | 905.4    |           |
+      | 16            | 54.257446,-2.215557 | Continue onto Oughtershaw Road      | 138.0   | SE        | 116685 | 162.1    |           |
+
+    Examples: 
+      | vehicleType  | avoidances | routeType |
+      | mountainbike |            |           |
diff --git a/acceptancetesting/src/test/cucumber/routing.feature b/acceptancetesting/src/test/cucumber/routing.feature
index 44d2ddd353..ef89e72d6e 100644
--- a/acceptancetesting/src/test/cucumber/routing.feature
+++ b/acceptancetesting/src/test/cucumber/routing.feature
@@ -979,3 +979,21 @@ Feature: Verify a route from A to B
     Examples: 
       | vehicleType | avoidances | routeType |
       | car         |            | fastest   |
+
+  #[ROUTE-133 ]Routing to a waypoint close to motorway stops on motorway instead of routing through local roads
+  @Routing
+  Scenario Outline: Verify  waypoints on a Route
+    Given I have route point as
+      | pointA              | pointB              |
+      | 50.949322,-1.483392 | 50.961009,-1.424954 |
+    And I have vehicle as "<vehicleType>"
+    And I have avoidances as "<avoidances>"
+    And I have weighting as "<routeType>"
+    When I request for a route
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc  | azimuth | direction | time   | distance | avoidance            |
+      | 4             | 50.946653,-1.476133 | At roundabout | 118.0   | SE        | 143795 | 3994.5   | take exit 1 onto M27 |
+
+    Examples: 
+      | vehicleType | avoidances | routeType |
+      | car         |            | shortest  |
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 2456cf044b..19dc5fed1d 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -39,6 +39,7 @@
 import com.graphhopper.reader.osgb.hn.OsHnReader;
 import com.graphhopper.reader.osgb.itn.OsItnReader;
 import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.EscapePrivateWeighting;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithm;
@@ -974,6 +975,16 @@ public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEnco
 			return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
 		return weighting;
 	}
+	
+	/**
+	 * Potentially wraps the specified weighting into a EscapePrivateWeighting instance.
+	 */
+	public Weighting createEscapePrivateWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
+	{
+		if (encoder.supports(EscapePrivateWeighting.class))
+			return new EscapePrivateWeighting(graph, encoder, weighting);
+		return weighting;
+	}
 
 	@Override
 	public GHResponse route( GHRequest request )
@@ -1086,6 +1097,7 @@ public GHResponse route( GHRequest request )
 			return Collections.emptyList();
 		}
 		weighting = createTurnWeighting(weighting, queryGraph, encoder);
+		weighting = createEscapePrivateWeighting(weighting, queryGraph, encoder);
 
 		double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
 		String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/itn/OSITNWay.java b/core/src/main/java/com/graphhopper/reader/osgb/itn/OSITNWay.java
index 9bc0c990f2..2ab8eec0f2 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/itn/OSITNWay.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/itn/OSITNWay.java
@@ -61,6 +61,7 @@
     public static OSITNWay create(long id, XMLStreamReader parser) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
         OSITNWay way = new OSITNWay(id);
         parser.nextTag();
+        way.setTag("highway","road");
         way.readTags(parser);
         logger.info(way.toString());
         return way;
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java b/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
index b714f0062c..caf6560dae 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
@@ -46,7 +46,7 @@ public void applyWayAttribute(RoutingElement way )
      */    
     public static RoadClassification lookup(String dataName) {
     	try {
-    		RoadClassification valueOf = RoadClassification.valueOf(dataName.replace(" ", "").replace("–", "").toUpperCase());
+    		RoadClassification valueOf = RoadClassification.valueOf(dataName.replace(" ", "").replace("-", "").toUpperCase());
     		return valueOf;
     	}
     	catch (IllegalArgumentException | NullPointerException e) {
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 4a77796207..c29870bb26 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.util.DistancePlaneProjection;
+
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
@@ -78,6 +79,11 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
+        if (weighting instanceof EscapePrivateWeighting)
+        {
+	        EscapePrivateWeighting escapeWeighting = (EscapePrivateWeighting) weighting;
+	        escapeWeighting.setFromTo(from, to);
+        }
         to1 = to;
         weightApprox.setGoalNode(to);
         currEdge = createEdgeEntry(from, 0);
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 7e92c25b06..b6c2051342 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -58,6 +58,11 @@ public Path calcPath( int from, int to )
         createAndInitPath();
         initFrom(from, 0);
         initTo(to, 0);
+        if (weighting instanceof EscapePrivateWeighting)
+        {
+	        EscapePrivateWeighting escapeWeighting = (EscapePrivateWeighting) weighting;
+	        escapeWeighting.setFromTo(from, to);
+        }
         runAlgo();
         return extractPath();
     }
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index f207b85e86..6b016d5d09 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -60,6 +60,11 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
+        if (weighting instanceof EscapePrivateWeighting)
+        {
+	        EscapePrivateWeighting escapeWeighting = (EscapePrivateWeighting) weighting;
+	        escapeWeighting.setFromTo(from, to);
+        }
         this.to = to;
         currEdge = createEdgeEntry(from, 0);
         if (!traversalMode.isEdgeBased())
diff --git a/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java b/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
index 0d24ed5d02..0751ed6efe 100644
--- a/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
@@ -17,15 +17,18 @@
 	private int start;
 	private int end;
 
-	public EscapePrivateWeighting( Graph graph, FlagEncoder encoder, Weighting weighting, int start, int end )
+	public EscapePrivateWeighting( Graph graph, FlagEncoder encoder, Weighting weighting)
     {
 	    super();
 	    this.graph = graph;
 	    this.encoder = encoder;
 	    this.innerWeighting = weighting;
-	    this.start = start;
-	    this.end = end;
     }
+	
+	public void setFromTo(int from , int to) {
+		start = from;
+		end = to;
+	}
 
 	@Override
 	public double getMinWeight( double distance )
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index f7debdc241..2f4f4ab9d9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -30,406 +30,393 @@
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
  * <p>
+ * 
  * @author Peter Karich
  * @author Nop
  */
 public class CarFlagEncoder extends AbstractFlagEncoder
 {
-    protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<>();
-    protected final Set<String> badSurfaceSpeedMap = new HashSet<>();
-    /**
-     * A map which associates string to speed. Get some impression:
-     * http://www.itoworld.com/map/124#fullscreen
-     * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
-     */
-    protected final Map<String, Integer> defaultSpeedMap = new HashMap<>();
-
-    protected final Map<String, String> environmentMaxSpeedMap = new HashMap<>();
-
-    /**
-     * 1mph = 1.60934kph
-     */
-    public static final int SEVENTY_MPH_IN_KPH = (int)parseSpeed("70mph");
-    public static final int SIXTY_MPH_IN_KPH = (int)parseSpeed("60mph");;
-    public static final int THIRTY_MPH_IN_KPH = (int)parseSpeed("30mph");;
-
-    /**
-     * Should be only instantied via EncodingManager
-     */
-    public CarFlagEncoder()
-    {
-        this(5, 5, 0);
-    }
-
-    public CarFlagEncoder( String propertiesStr )
-    {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
-    }
-
-    public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
-        super(speedBits, speedFactor, maxTurnCosts);
-        restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
-
-        restrictedValues.add("private");
-        restrictedValues.add("agricultural");
-        restrictedValues.add("forestry");
-        restrictedValues.add("no");
-        restrictedValues.add("restricted");
-        restrictedValues.add("delivery");
-        restrictedValues.add("military");
-
-        intendedValues.add("yes");
-        intendedValues.add("permissive");
-
-        potentialBarriers.add("gate");
-        potentialBarriers.add("lift_gate");
-        potentialBarriers.add("kissing_gate");
-        potentialBarriers.add("swing_gate");
-
-        absoluteBarriers.add("bollard");
-        absoluteBarriers.add("stile");
-        absoluteBarriers.add("turnstile");
-        absoluteBarriers.add("cycle_barrier");
-        absoluteBarriers.add("motorcycle_barrier");
-        absoluteBarriers.add("block");
-
-        trackTypeSpeedMap.put("grade1", 20); // paved
-        trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
-        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
-        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
-        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
-
-        badSurfaceSpeedMap.add("cobblestone");
-        badSurfaceSpeedMap.add("grass_paver");
-        badSurfaceSpeedMap.add("gravel");
-        badSurfaceSpeedMap.add("sand");
-        badSurfaceSpeedMap.add("paving_stones");
-        badSurfaceSpeedMap.add("dirt");
-        badSurfaceSpeedMap.add("ground");
-        badSurfaceSpeedMap.add("grass");
-
-        maxPossibleSpeed = 100;
-        
-        // autobahn
-        defaultSpeedMap.put("motorway", 100);
-        defaultSpeedMap.put("motorway_link", 70);
-        defaultSpeedMap.put("motorroad", 90);
-        // bundesstraße
-        defaultSpeedMap.put("trunk", 70);
-        defaultSpeedMap.put("trunk_link", 65);
-        // linking bigger town
-        defaultSpeedMap.put("primary", 65);
-        defaultSpeedMap.put("primary_link", 60);
-        // linking towns + villages
-        defaultSpeedMap.put("secondary", 60);
-        defaultSpeedMap.put("secondary_link", 50);
-        // streets without middle line separation
-        defaultSpeedMap.put("tertiary", 50);
-        defaultSpeedMap.put("tertiary_link", 40);
-        defaultSpeedMap.put("unclassified", 30);
-        defaultSpeedMap.put("residential", 30);
-        // spielstraße
-        defaultSpeedMap.put("living_street", 5);
-        defaultSpeedMap.put("service", 20);
-        // unknown road
-        defaultSpeedMap.put("road", 20);
-        // forestry stuff
-        defaultSpeedMap.put("track", 15);
-
-        addNationalUKSpeedMapping();
-        addRoadTypeUKSpeedMapping();
-
-        // You can not drive down a pedestrianised street
-        defaultSpeedMap.put("Pedestrianised Street", 0);
-        // Private Road - Publicly Accessible are NOT traversible
-        // defaultSpeedMap.put("Private Road - Restricted Access", 0);
-        // Private Road - Publicly Accessible are NOT traversible
-        // defaultSpeedMap.put("Private Road - Publicly Accessible", 10);
-
-        //        defaultSpeedMap.put("Alley", 0);
-
-        // osgb:type
-        vehicleQualifierTypeExclusions.add("Buses");
-        vehicleQualifierTypeExclusions.add("Coaches");
-        vehicleQualifierTypeExclusions.add("Mopeds");
-        vehicleQualifierTypeExclusions.add("Motor Cycles");
-        vehicleQualifierTypeExclusions.add("HGV's");
-        vehicleQualifierTypeExclusions.add("LGV's");
-        vehicleQualifierTypeExclusions.add("Towed Caravans");
-        vehicleQualifierTypeExclusions.add("Cycles");
-        vehicleQualifierTypeExclusions.add("Tracked Vehicles");
-        // osgb:use
-        vehicleQualifierTypeExclusions.add("Taxi");
-        vehicleQualifierTypeExclusions.add("Taxis"); // Added from analysing the actual data
-        vehicleQualifierTypeExclusions.add("School Bus");
-        vehicleQualifierTypeExclusions.add("Patron");
-        vehicleQualifierTypeExclusions.add("Access");
-        vehicleQualifierTypeExclusions.add("Resident");
-        vehicleQualifierTypeExclusions.add("Emergency Vehicle");
-        vehicleQualifierTypeExclusions.add("Public Transport");
-        vehicleQualifierTypeExclusions.add("Authorised Vehicle");
-        vehicleQualifierTypeExclusions.add("Local Bus");
-        vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual data
-        vehicleQualifierTypeExclusions.add("Escorted Traffic");
-        vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the actual data
-
-
-
-        vehicleQualifierTypeInclusions.add("Motor Vehicles");
-        vehicleQualifierTypeInclusions.add("All Vehicles");
-
-
-        //        environmentMaxSpeedMap.put("Rural", 60);
-        environmentMaxSpeedMap.put("Urban:Single Carriageway", ""+THIRTY_MPH_IN_KPH);
-
-
-    }
+	protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<>();
+	protected final Set<String> badSurfaceSpeedMap = new HashSet<>();
+	/**
+	 * A map which associates string to speed. Get some impression:
+	 * http://www.itoworld.com/map/124#fullscreen
+	 * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
+	 */
+	protected final Map<String, Integer> defaultSpeedMap = new HashMap<>();
+
+	protected final Map<String, String> environmentMaxSpeedMap = new HashMap<>();
+
+	/**
+	 * 1mph = 1.60934kph
+	 */
+	public static final int SEVENTY_MPH_IN_KPH = (int) parseSpeed("70mph");
+	public static final int SIXTY_MPH_IN_KPH = (int) parseSpeed("60mph");;
+	public static final int THIRTY_MPH_IN_KPH = (int) parseSpeed("30mph");;
+
+	/**
+	 * Should be only instantied via EncodingManager
+	 */
+	public CarFlagEncoder()
+	{
+		this(5, 5, 0);
+	}
+
+	public CarFlagEncoder( String propertiesStr )
+	{
+		this((int) parseLong(propertiesStr, "speedBits", 5), parseDouble(propertiesStr,
+		        "speedFactor", 5), parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+		this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+	}
+
+	public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+	{
+		super(speedBits, speedFactor, maxTurnCosts);
+		restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
+
+		restrictedValues.add("private");
+		restrictedValues.add("agricultural");
+		restrictedValues.add("forestry");
+		restrictedValues.add("no");
+		restrictedValues.add("restricted");
+		restrictedValues.add("delivery");
+		restrictedValues.add("military");
+
+		intendedValues.add("yes");
+		intendedValues.add("permissive");
+
+		potentialBarriers.add("gate");
+		potentialBarriers.add("lift_gate");
+		potentialBarriers.add("kissing_gate");
+		potentialBarriers.add("swing_gate");
+
+		absoluteBarriers.add("bollard");
+		absoluteBarriers.add("stile");
+		absoluteBarriers.add("turnstile");
+		absoluteBarriers.add("cycle_barrier");
+		absoluteBarriers.add("motorcycle_barrier");
+		absoluteBarriers.add("block");
+
+		trackTypeSpeedMap.put("grade1", 20); // paved
+		trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
+		trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
+		trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+		trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+
+		badSurfaceSpeedMap.add("cobblestone");
+		badSurfaceSpeedMap.add("grass_paver");
+		badSurfaceSpeedMap.add("gravel");
+		badSurfaceSpeedMap.add("sand");
+		badSurfaceSpeedMap.add("paving_stones");
+		badSurfaceSpeedMap.add("dirt");
+		badSurfaceSpeedMap.add("ground");
+		badSurfaceSpeedMap.add("grass");
+
+		maxPossibleSpeed = 100;
+
+		// autobahn
+		defaultSpeedMap.put("motorway", 100);
+		defaultSpeedMap.put("motorway_link", 70);
+		defaultSpeedMap.put("motorroad", 90);
+		// bundesstraße
+		defaultSpeedMap.put("trunk", 70);
+		defaultSpeedMap.put("trunk_link", 65);
+		// linking bigger town
+		defaultSpeedMap.put("primary", 65);
+		defaultSpeedMap.put("primary_link", 60);
+		// linking towns + villages
+		defaultSpeedMap.put("secondary", 60);
+		defaultSpeedMap.put("secondary_link", 50);
+		// streets without middle line separation
+		defaultSpeedMap.put("tertiary", 50);
+		defaultSpeedMap.put("tertiary_link", 40);
+		defaultSpeedMap.put("unclassified", 30);
+		defaultSpeedMap.put("residential", 30);
+		// spielstraße
+		defaultSpeedMap.put("living_street", 5);
+		defaultSpeedMap.put("service", 20);
+		// unknown road
+		defaultSpeedMap.put("road", 20);
+		// forestry stuff
+		defaultSpeedMap.put("track", 15);
+
+		addNationalUKSpeedMapping();
+		addRoadTypeUKSpeedMapping();
+
+		// osgb:type
+		vehicleQualifierTypeExclusions.add("Buses");
+		vehicleQualifierTypeExclusions.add("Coaches");
+		vehicleQualifierTypeExclusions.add("Mopeds");
+		vehicleQualifierTypeExclusions.add("Motor Cycles");
+		vehicleQualifierTypeExclusions.add("HGV's");
+		vehicleQualifierTypeExclusions.add("LGV's");
+		vehicleQualifierTypeExclusions.add("Towed Caravans");
+		vehicleQualifierTypeExclusions.add("Cycles");
+		vehicleQualifierTypeExclusions.add("Tracked Vehicles");
+		// osgb:use
+		vehicleQualifierTypeExclusions.add("Taxi");
+		vehicleQualifierTypeExclusions.add("Taxis"); // Added from analysing the actual data
+		vehicleQualifierTypeExclusions.add("School Bus");
+		vehicleQualifierTypeExclusions.add("Patron");
+		vehicleQualifierTypeExclusions.add("Access");
+		vehicleQualifierTypeExclusions.add("Resident");
+		vehicleQualifierTypeExclusions.add("Emergency Vehicle");
+		vehicleQualifierTypeExclusions.add("Public Transport");
+		vehicleQualifierTypeExclusions.add("Authorised Vehicle");
+		vehicleQualifierTypeExclusions.add("Local Bus");
+		vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual data
+		vehicleQualifierTypeExclusions.add("Escorted Traffic");
+		vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the
+																	 // actual data
+
+		vehicleQualifierTypeInclusions.add("Motor Vehicles");
+		vehicleQualifierTypeInclusions.add("All Vehicles");
+
+		environmentMaxSpeedMap.put("Urban:Single Carriageway", "" + THIRTY_MPH_IN_KPH);
+	}
 
 	private void addNationalUKSpeedMapping()
-    {
-	    defaultSpeedMap.put("GB:motorway", SEVENTY_MPH_IN_KPH);
-	    defaultSpeedMap.put("GB:nsl_dual", SEVENTY_MPH_IN_KPH);
-	    defaultSpeedMap.put("GB:nsl_single", SIXTY_MPH_IN_KPH);
-    }
+	{
+		defaultSpeedMap.put("GB:motorway", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("GB:nsl_dual", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("GB:nsl_single", SIXTY_MPH_IN_KPH);
+	}
 
 	private void addRoadTypeUKSpeedMapping()
-    {
-	    defaultSpeedMap.put("Motorway", SEVENTY_MPH_IN_KPH);
-        defaultSpeedMap.put("A Road", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
-        //        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("A Road-Single Carriageway", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
-        //        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway", SEVENTY_MPH_IN_KPH);
-        defaultSpeedMap.put("A Road", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
-        //        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("A Road-Dual Carriageway", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
-        //        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway-Slip Road", SEVENTY_MPH_IN_KPH);
-        defaultSpeedMap.put("A Road-Slip Road", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
-        //        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway-Roundabout", SEVENTY_MPH_IN_KPH);
-        defaultSpeedMap.put("A Road-Roundabout", SIXTY_MPH_IN_KPH);
-        defaultSpeedMap.put("B Road-Roundabout", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Minor Road-Roundabout", THIRTY_MPH_IN_KPH);
-        defaultSpeedMap.put("Local Street-Roundabout", THIRTY_MPH_IN_KPH);
-    }
-
-    /**
-     * Define the place of the speedBits in the edge flags for car.
-     */
-    @Override
-    public int defineWayBits( int index, int shift )
-    {
-        // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), 
-                                              maxPossibleSpeed);
-        return shift + speedEncoder.getBits();
-    }
-
-    protected double getSpeed( Way way )
-    {
-    	String typeMax = way.getTag("maxspeed:type");
-    	Integer speed = defaultSpeedMap.get(typeMax);
-    	if(null==speed) {
-    		String highwayValue = way.getTag("highway");
-    		speed = defaultSpeedMap.get(highwayValue);
-    		if (speed == null)
-    			throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
-
-    		if (highwayValue.equals("track"))
-    		{
-    			String tt = way.getTag("tracktype");
-    			if (!Helper.isEmpty(tt))
-    			{
-    				Integer tInt = trackTypeSpeedMap.get(tt);
-    				if (tInt != null)
-    					speed = tInt;
-    			}
-    		}
-    	}
-
-        return speed;
-    }
-
-    @Override
-    public long acceptWay( Way way )
-    {
-        String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
-                String motorcarTag = way.getTag("motorcar");
-                if (motorcarTag == null)
-                    motorcarTag = way.getTag("motor_vehicle");
-
-                if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle") || "yes".equals(motorcarTag))
-                    return acceptBit | ferryBit;
-            }
-            return 0;
-        }
-
-        if ("track".equals(highwayValue))
-        {
-            String tt = way.getTag("tracktype");
-            if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
-                return 0;
-        }
-
-        // absolute barriers always block
-        if (way.hasTag("barrier", absoluteBarriers))
-            return 0;
-
-        // movable barriers block always for cars
-        if (way.hasTag("barrier", potentialBarriers))
-            return 0;
-
-
-        if (!defaultSpeedMap.containsKey(highwayValue))
-            return 0;
-
-        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            return 0;
-
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        boolean hasFordFlag = way.hasTag("ford");
-        if (isBlockFords() && ("ford".equals(highwayValue) || hasFordFlag) && !carsAllowed)
-            return 0;
-
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
-            return 0;
-
-        // do not drive cars over railways (sometimes incorrectly mapped!)
-        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
-            return 0;
-
-        return acceptBit;
-    }
-
-    @Override
-    public long handleWayTags( Way way, long allowed, long relationFlags )
-    {
-        if (!isAccept(allowed))
-            return 0;
-
-        long encoded;
-        if (!isFerry(allowed))
-        {
-            // get assumed speed from highway type
-            double speed = getSpeed(way);
-
-            // set the max speed tag for the environment
-            String environment = way.getTag("environment");
-            if (!Helper.isEmpty(environment))
-            {
-                String maxSpeed = environmentMaxSpeedMap.get(environment);
-                if (!Helper.isEmpty(maxSpeed)) {
-                    //                    System.out.println(">>>>>>>>>>>>>>> Set max speed to " + maxSpeed);
-                    way.setTag("maxspeed", maxSpeed);
-                }
-            }
-
-            speed = applyMaxSpeed(way, speed, true);
-
-            // limit speed to max 30 km/h if bad surface
-            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
-                speed = 30;
-
-            encoded = setSpeed(0, speed);
-
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
-            if (isRoundabout)
-                encoded = setBool(encoded, K_ROUNDABOUT, true);
-
-            boolean isOneway = way.hasTag("oneway", oneways)
-                    || way.hasTag("vehicle:backward")
-                    || way.hasTag("vehicle:forward")
-                    || way.hasTag("motor_vehicle:backward")
-                    || way.hasTag("motor_vehicle:forward");
-
-            if (isOneway || isRoundabout)
-            {
-                boolean isBackward = way.hasTag("oneway", "-1")
-                        || way.hasTag("vehicle:forward", "no")
-                        || way.hasTag("motor_vehicle:forward", "no");
-                if (isBackward)
-                    encoded |= backwardBit;
-                else
-                    encoded |= forwardBit;
-            } else
-                encoded |= directionBitMask;
-
-        } else
-        {
-            encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
-            encoded |= directionBitMask;
-        }
-        return encoded;
-    }
-
-    public String getWayInfo(Way way )
-    {
-        String str = "";
-        String highwayValue = way.getTag("highway");
-        // for now only motorway links
-        if ("motorway_link".equals(highwayValue))
-        {
-            String destination = way.getTag("destination");
-            if (!Helper.isEmpty(destination))
-            {
-                int counter = 0;
-                for (String d : destination.split(";"))
-                {
-                    if (d.trim().isEmpty())
-                        continue;
-
-                    if (counter > 0)
-                        str += ", ";
-
-                    str += d.trim();
-                    counter++;
-                }
-            }
-        }
-        if (str.isEmpty())
-            return str;
-        // I18N
-        if (str.contains(","))
-            return "destinations: " + str;
-        else
-            return "destination: " + str;
-    }
-
-    @Override
-    public String toString()
-    {
-        return "car";
-    }
-
-    @Override
-    public long handleRelationTags(Relation relation, long oldRelationFlags) {
-        return oldRelationFlags;
-    }
+	{
+		defaultSpeedMap.put("Motorway", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("A Road", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
+		// defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("A Road-Single Carriageway", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
+		// defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("A Road", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
+		// defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("A Road-Dual Carriageway", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
+		// defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway-Slip Road", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("A Road-Slip Road", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street", THIRTY_MPH_IN_KPH);
+		// defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway-Roundabout", SEVENTY_MPH_IN_KPH);
+		defaultSpeedMap.put("A Road-Roundabout", SIXTY_MPH_IN_KPH);
+		defaultSpeedMap.put("B Road-Roundabout", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Minor Road-Roundabout", THIRTY_MPH_IN_KPH);
+		defaultSpeedMap.put("Local Street-Roundabout", THIRTY_MPH_IN_KPH);
+	}
+
+	/**
+	 * Define the place of the speedBits in the edge flags for car.
+	 */
+	@Override
+	public int defineWayBits( int index, int shift )
+	{
+		// first two bits are reserved for route handling in superclass
+		shift = super.defineWayBits(index, shift);
+		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor,
+		        defaultSpeedMap.get("secondary"), maxPossibleSpeed);
+		return shift + speedEncoder.getBits();
+	}
+
+	protected double getSpeed( Way way )
+	{
+		String typeMax = way.getTag("maxspeed:type");
+		Integer speed = defaultSpeedMap.get(typeMax);
+		if (null == speed)
+		{
+			String highwayValue = way.getTag("highway");
+			speed = defaultSpeedMap.get(highwayValue);
+			if (speed == null)
+				throw new IllegalStateException(toString() + ", no speed found for: "
+				        + highwayValue + ", tags: " + way);
+
+			if (highwayValue.equals("track"))
+			{
+				String tt = way.getTag("tracktype");
+				if (!Helper.isEmpty(tt))
+				{
+					Integer tInt = trackTypeSpeedMap.get(tt);
+					if (tInt != null)
+						speed = tInt;
+				}
+			}
+		}
+		return speed;
+	}
+
+	@Override
+	public long acceptWay( Way way )
+	{
+		String highwayValue = way.getTag("highway");
+		if (highwayValue == null)
+		{
+			if (way.hasTag("route", ferries))
+			{
+				String motorcarTag = way.getTag("motorcar");
+				if (motorcarTag == null)
+					motorcarTag = way.getTag("motor_vehicle");
+
+				if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle")
+				        || "yes".equals(motorcarTag))
+					return acceptBit | ferryBit;
+			}
+			return 0;
+		}
+
+		if ("track".equals(highwayValue))
+		{
+			String tt = way.getTag("tracktype");
+			if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
+				return 0;
+		}
+
+		// absolute barriers always block
+		if (way.hasTag("barrier", absoluteBarriers))
+			return 0;
+
+		// movable barriers block always for cars
+		if (way.hasTag("barrier", potentialBarriers))
+			return 0;
+
+		if (!defaultSpeedMap.containsKey(highwayValue))
+			return 0;
+
+		if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+			return 0;
+
+		// do not drive street cars into fords
+		boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+		boolean hasFordFlag = way.hasTag("ford");
+		if (isBlockFords() && ("ford".equals(highwayValue) || hasFordFlag) && !carsAllowed)
+			return 0;
+
+		// check access restrictions
+		if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+			return 0;
+
+		// do not drive cars over railways (sometimes incorrectly mapped!)
+		if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+			return 0;
+
+		return acceptBit;
+	}
+
+	@Override
+	public long handleWayTags( Way way, long allowed, long relationFlags )
+	{
+		if (!isAccept(allowed))
+			return 0;
+		long encoded;
+		if (!isFerry(allowed))
+		{
+
+			// get assumed speed from highway type
+			double speed = getSpeed(way);
+
+			// set the max speed tag for the environment
+			String environment = way.getTag("environment");
+			if (!Helper.isEmpty(environment))
+			{
+				String maxSpeed = environmentMaxSpeedMap.get(environment);
+				if (!Helper.isEmpty(maxSpeed))
+				{
+					// System.out.println(">>>>>>>>>>>>>>> Set max speed to " + maxSpeed);
+					way.setTag("maxspeed", maxSpeed);
+				}
+			}
+			speed = applyMaxSpeed(way, speed, true);
+			// limit speed to max 30 km/h if bad surface
+			if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
+				speed = 30;
+
+			encoded = setSpeed(0, speed);
+
+			boolean isRoundabout = way.hasTag("junction", "roundabout");
+			if (isRoundabout)
+				encoded = setBool(encoded, K_ROUNDABOUT, true);
+
+			boolean isOneway = way.hasTag("oneway", oneways) || way.hasTag("vehicle:backward")
+			        || way.hasTag("vehicle:forward") || way.hasTag("motor_vehicle:backward")
+			        || way.hasTag("motor_vehicle:forward");
+
+			if (isOneway || isRoundabout)
+			{
+				boolean isBackward = way.hasTag("oneway", "-1")
+				        || way.hasTag("vehicle:forward", "no")
+				        || way.hasTag("motor_vehicle:forward", "no");
+				if (isBackward)
+					encoded |= backwardBit;
+				else
+					encoded |= forwardBit;
+			} else
+				encoded |= directionBitMask;
+
+		} else
+		{
+			encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"),
+			        defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
+			encoded |= directionBitMask;
+		}
+
+		return encoded;
+	}
+
+	public String getWayInfo( Way way )
+	{
+		String str = "";
+		String highwayValue = way.getTag("highway");
+		// for now only motorway links
+		if ("motorway_link".equals(highwayValue))
+		{
+			String destination = way.getTag("destination");
+			if (!Helper.isEmpty(destination))
+			{
+				int counter = 0;
+				for (String d : destination.split(";"))
+				{
+					if (d.trim().isEmpty())
+						continue;
+
+					if (counter > 0)
+						str += ", ";
+
+					str += d.trim();
+					counter++;
+				}
+			}
+		}
+		if (str.isEmpty())
+			return str;
+		// I18N
+		if (str.contains(","))
+			return "destinations: " + str;
+		else
+			return "destination: " + str;
+	}
+
+	@Override
+	public String toString()
+	{
+		return "car";
+	}
+
+	@Override
+	public long handleRelationTags( Relation relation, long oldRelationFlags )
+	{
+		return oldRelationFlags;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
index cea014217a..bd9f637505 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
@@ -39,9 +39,13 @@ public long getLong( long flags, int key )
 	public long handleWayTags( Way way, long allowed, long relationFlags )
 	{
 	    long superHandled =  super.handleWayTags(way, allowed, relationFlags);
-	    System.err.println("SUPER"+ superHandled);
-	    return superHandled |= startStopEncoder.setValue(superHandled, way.hasTag("access", "no")?1:0);
+	    return superHandled |= startStopEncoder.setValue(superHandled, noThroughWayAccess(way));
 	}
+
+	private int noThroughWayAccess( Way way )
+    {
+	    return way.hasTag("access", "no")||way.hasTag("service", "alley")?1:0;
+    }
 	
 	/**
      * Define the place of the speedBits in the edge flags for car.
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 5ca18aa337..828720f5b3 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -24,86 +24,88 @@
  */
 public class GHPoint
 {
-    public double lat = Double.NaN;
-    public double lon = Double.NaN;
+	public double lat = Double.NaN;
+	public double lon = Double.NaN;
 
-    public GHPoint()
-    {
-    }
+	public GHPoint()
+	{
+	}
 
-    public GHPoint( double lat, double lon )
-    {
-        this.lat = lat;
-        this.lon = lon;
-    }
+	public GHPoint( double lat, double lon )
+	{
+		this.lat = lat;
+		this.lon = lon;
+	}
 
-    public double getLon()
-    {
-        return lon;
-    }
+	public double getLon()
+	{
+		return lon;
+	}
 
-    public double getLat()
-    {
-        return lat;
-    }
+	public double getLat()
+	{
+		return lat;
+	}
 
-    public boolean isValid()
-    {
-        return !Double.isNaN(lat) && !Double.isNaN(lon);
-    }
+	public boolean isValid()
+	{
+		return !Double.isNaN(lat) && !Double.isNaN(lon);
+	}
 
-    @Override
-    public int hashCode()
-    {
-        int hash = 7;
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
-        return hash;
-    }
+	@Override
+	public int hashCode()
+	{
+		int hash = 7;
+		hash = 83
+				* hash
+				+ (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
+		hash = 83
+				* hash
+				+ (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
+		return hash;
+	}
 
-    @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-            return false;
+	@Override
+	public boolean equals( Object obj )
+	{
+		if (obj == null)
+			return false;
 
-        @SuppressWarnings("unchecked")
-        final GHPoint other = (GHPoint) obj;
-        return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
-    }
+		@SuppressWarnings("unchecked")
+		final GHPoint other = (GHPoint) obj;
+		return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
+	}
 
-    @Override
-    public String toString()
-    {
-        return lat + "," + lon;
-    }
+	@Override
+	public String toString()
+	{
+		return lat + "," + lon;
+	}
 
-    /**
-     * Attention: geoJson is LON,LAT
-     */
-    public Double[] toGeoJson()
-    {
-        return new Double[]
-        {
-            lon, lat
-        };
-    }
+	/**
+	 * Attention: geoJson is LON,LAT
+	 */
+	public Double[] toGeoJson()
+	{
+		return new Double[] { lon, lat };
+	}
 
-    public static GHPoint parse( String str )
-    {
-        // if the point is in the format of lat,lon we don't need to call geocoding service
-        String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2)
-        {
-            try
-            {
-                double fromLat = Double.parseDouble(fromStrs[0]);
-                double fromLon = Double.parseDouble(fromStrs[1]);
-                return new GHPoint(fromLat, fromLon);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return null;
-    }
+	public static GHPoint parse( String str )
+	{
+		// if the point is in the format of lat,lon we don't need to call geocoding service
+		String[] fromStrs = str.split(",");
+		if (fromStrs.length == 2)
+		{
+			try
+			{
+				double fromLat = Double.parseDouble(fromStrs[0]);
+				double fromLon = Double.parseDouble(fromStrs[1]);
+				return new GHPoint(fromLat, fromLon);
+			} catch (NumberFormatException | NullPointerException ex)
+			{
+				// Fall through to return a null below
+			}
+		}
+		return null;
+	}
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/AlleyTest.java b/core/src/test/java/com/graphhopper/reader/osgb/AlleyTest.java
index 07c7a98536..2e3d041554 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/AlleyTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/AlleyTest.java
@@ -13,6 +13,7 @@
 
 public class AlleyTest extends AbstractOsItnReaderTest {
 
+	//TODO update for new behavious related to no through roads.
     /**
      * Alleys are not supported routes. This test is a simple (node A) - alley - (node B) - A Road - (node C) network.
      * This means the alley should not be traversible and only nodes B and C should be present.
@@ -28,9 +29,10 @@ public void testAlley() throws IOException {
         readGraphFile(graph, file);
         final EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
         printNodes(explorer, 5);
-        assertEquals(2, graph.getNodes());
-        assertEquals(1, count(explorer.setBaseNode(0)));
+        assertEquals(3, graph.getNodes());
+        assertEquals(2, count(explorer.setBaseNode(0)));
         assertEquals(1, count(explorer.setBaseNode(1)));
+        assertEquals(1, count(explorer.setBaseNode(2)));
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/EmergencyVehicleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/EmergencyVehicleFlagEncoderTest.java
new file mode 100644
index 0000000000..335ab298b5
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/osgb/EmergencyVehicleFlagEncoderTest.java
@@ -0,0 +1,48 @@
+package com.graphhopper.reader.osgb;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EmergencyVehicleFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphHopperStorage;
+
+public class EmergencyVehicleFlagEncoderTest extends AbstractOsItnReaderTest{
+
+    private EmergencyVehicleFlagEncoder emvEncoder;
+    
+    @Before
+    public void initEncoding() {
+        if (turnCosts) {
+            emvEncoder = new EmergencyVehicleFlagEncoder("speedBits=5|speedfactor=5|turncosts=3");
+        } else {
+        	emvEncoder = new EmergencyVehicleFlagEncoder("speedBits=5|speedfactor=5|turncosts=0");
+        }
+
+        carOutEdges = new DefaultEdgeFilter(emvEncoder, false, true);
+        carInEdges = new DefaultEdgeFilter(emvEncoder, true, false);
+        encodingManager = createEncodingManager();
+    }
+
+	protected EncodingManager createEncodingManager() {
+        return new EncodingManager(emvEncoder);
+    }
+    
+    @Test
+    public void testReadSimplePrivateCrossRoads() throws IOException {
+        final boolean turnRestrictionsImport = false;
+        final boolean is3D = false;
+        final GraphHopperStorage graph = configureStorage(turnRestrictionsImport, is3D);
+
+        final File file = new File("./src/test/resources/com/graphhopper/reader/os-itn-simple-private-crossroad.xml");
+        readGraphFile(graph, file);
+        assertEquals(5, graph.getNodes());
+        checkSimpleNodeNetwork(graph);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java b/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
index 8bff06549d..bc1434ac91 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
@@ -48,27 +48,28 @@ public void testReadTagsForRoundabout() throws XMLStreamException, MismatchedDim
 	
 	@Test
 	public void testReadTagsForPrivatePublicallyAccessibleRoads() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		String wayWithRoundabout = "<?xml version='1.0' encoding='UTF-8'?>\n" + 
+		String privatePublic = "<?xml version='1.0' encoding='UTF-8'?>\n" + 
 				"<osgb:FeatureCollection xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb'\n" + 
 				"	xmlns:gml='http://www.opengis.net/gml' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n" + 
 				"	xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd'\n" + 
 				"	fid='GDS-58096-1'>" +
-				"		<osgb:RoadLink fid='osgb4000000009314037'>\n" + 
-				"<osgb:descriptiveTerm>Private Road – Publicly Accessible</osgb:descriptiveTerm>\n" + 
+				"<osgb:RoadLink fid='osgb4000000025030155'>\n" + 
+				"<osgb:descriptiveGroup>Road Topology</osgb:descriptiveGroup>\n" + 
+				"<osgb:descriptiveTerm>Private Road - Publicly Accessible</osgb:descriptiveTerm>\n" + 
 				"<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>\n" + 
-				"<osgb:length>12.04</osgb:length>\n" + 
+				"<osgb:length>103.74</osgb:length>\n" + 
 				"<osgb:polyline>\n" + 
 				"<gml:LineString srsName='osgb:BNG'>\n" + 
-				"<gml:coordinates>356370.000,430137.000 356367.000,430139.000 356366.000,430141.000 356365.386,430142.099 356365.000,430144.000 356365.000,430146.000 356365.000,430147.000 </gml:coordinates>\n" + 
+				"<gml:coordinates>166785.778,26371.534 166767.559,26395.371 166746.384,26421.542 166732.941,26438.078 166725.804,26447.595 166722.647,26453.691 </gml:coordinates>\n" + 
 				"</gml:LineString>\n" + 
 				"</osgb:polyline>\n" + 
-				"<osgb:directedNode orientation='-' xlink:href='#osgb4000000009126286'/>\n" + 
-				"<osgb:directedNode orientation='+' xlink:href='#osgb4000000009126257'/>\n" + 
-				"<osgb:referenceToTopographicArea xlink:href='#osgb1000000214086160'/>\n" + 
-				"</osgb:RoadLink>"; 
+				"<osgb:directedNode orientation='-' xlink:href='#osgb4000000025030107'/>\n" + 
+				"<osgb:directedNode orientation='+' xlink:href='#osgb4000000025030094'/>\n" + 
+				"<osgb:referenceToTopographicArea xlink:href='#osgb1000002033801767'/>\n" + 
+				"</osgb:RoadLink>\n";
 		
 		XMLInputFactory factory = XMLInputFactory.newInstance();
-		StringReader stringReader = new StringReader(wayWithRoundabout);
+		StringReader stringReader = new StringReader(privatePublic);
 		XMLStreamReader parser = factory.createXMLStreamReader(stringReader);
 		OSITNWay way = OSITNWay.create(0, parser);
 		assertEquals("private", way.getTag("access"));
@@ -76,13 +77,13 @@ public void testReadTagsForPrivatePublicallyAccessibleRoads() throws XMLStreamEx
 	
 	@Test
 	public void testReadTagsPrivateRestrictedRoads() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		String wayWithRoundabout = "<?xml version='1.0' encoding='UTF-8'?>\n" + 
+		String privateRestricted = "<?xml version='1.0' encoding='UTF-8'?>\n" + 
 				"<osgb:FeatureCollection xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb'\n" + 
 				"	xmlns:gml='http://www.opengis.net/gml' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n" + 
 				"	xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd'\n" + 
 				"	fid='GDS-58096-1'>" +
 				"		<osgb:RoadLink fid='osgb4000000009314037'>\n" + 
-				"<osgb:descriptiveTerm>Private Road – Restricted Access</osgb:descriptiveTerm>\n" + 
+				"<osgb:descriptiveTerm>Private Road - Restricted Access</osgb:descriptiveTerm>\n" + 
 				"<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>\n" + 
 				"<osgb:length>12.04</osgb:length>\n" + 
 				"<osgb:polyline>\n" + 
@@ -96,7 +97,7 @@ public void testReadTagsPrivateRestrictedRoads() throws XMLStreamException, Mism
 				"</osgb:RoadLink>"; 
 		
 		XMLInputFactory factory = XMLInputFactory.newInstance();
-		StringReader stringReader = new StringReader(wayWithRoundabout);
+		StringReader stringReader = new StringReader(privateRestricted);
 		XMLStreamReader parser = factory.createXMLStreamReader(stringReader);
 		OSITNWay way = OSITNWay.create(0, parser);
 		assertEquals("no", way.getTag("access"));
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadPubliclyAccessibleTest.java b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadPubliclyAccessibleTest.java
index 83b2394b8a..386ad70ffe 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadPubliclyAccessibleTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadPubliclyAccessibleTest.java
@@ -30,7 +30,7 @@ public void init() {
 
     @Test
     public void testVisitWayAttribute() {
-        visitor.visitWayAttribute("Private Road – Publicly Accessible".toLowerCase().replace(" ", "").replace("–", ""), way);
+        visitor.visitWayAttribute("Private Road - Publicly Accessible".toLowerCase().replace(" ", "").replace("-", ""), way);
         verify(way).setTag("access", "private");
         verifyNoMoreInteractions(way);
     }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadRestrictedAccessTest.java b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadRestrictedAccessTest.java
index 47ea9e91fc..22d34c047f 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadRestrictedAccessTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/PrivateRoadRestrictedAccessTest.java
@@ -30,7 +30,7 @@ public void init() {
 
     @Test
     public void testVisitWayAttribute() {
-        visitor.visitWayAttribute("Private Road – Restricted Access".toLowerCase().replace(" ", "").replace("–", ""), way);
+        visitor.visitWayAttribute("Private Road - Restricted Access".toLowerCase().replace(" ", "").replace("-", ""), way);
         verify(way).setTag("access", "no");
         verifyNoMoreInteractions(way);
     }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/RoadClassificationTest.java b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/RoadClassificationTest.java
index b3ce2e6d8b..4eb439464c 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/RoadClassificationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/roadclassification/RoadClassificationTest.java
@@ -19,8 +19,8 @@ public void testLookup()
 		assertEquals(RoadClassification.MINORROAD, RoadClassification.lookup("Minor Road"));
 		assertEquals(RoadClassification.MOTORWAY, RoadClassification.lookup("Motorway"));
 		assertEquals(RoadClassification.PEDESTRIANISEDSTREET, RoadClassification.lookup("Pedestrianised Street"));
-		assertEquals(RoadClassification.PRIVATEROADPUBLICLYACCESSIBLE, RoadClassification.lookup("Private Road – Publicly Accessible"));
-		assertEquals(RoadClassification.PRIVATEROADRESTRICTEDACCESS, RoadClassification.lookup("Private Road – Restricted Access"));
+		assertEquals(RoadClassification.PRIVATEROADPUBLICLYACCESSIBLE, RoadClassification.lookup("Private Road - Publicly Accessible"));
+		assertEquals(RoadClassification.PRIVATEROADRESTRICTEDACCESS, RoadClassification.lookup("Private Road - Restricted Access"));
 		assertEquals(RoadClassification.SINGLECARRIAGEWAY, RoadClassification.lookup("Single Carriageway"));
 		assertEquals(RoadClassification.URBAN, RoadClassification.lookup("Urban"));
 		assertEquals(RoadClassification.ROUNDABOUT, RoadClassification.lookup("Roundabout"));
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 91f4002e5b..34c0f1bf3d 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,13 +30,11 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.Way;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EmergencyVehicleFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.routing.util.ShortestWeighting;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
@@ -59,956 +57,1001 @@
  */
 public abstract class AbstractRoutingAlgorithmTester
 {
-    // problem is: matrix graph is expensive to create to cache it in a static variable
-    private static Graph matrixGraph;
-    protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT,EMV");
-    protected FlagEncoder carEncoder;
-    protected FlagEncoder footEncoder;
-    protected EmergencyVehicleFlagEncoder emvEncoder;
-    protected AlgorithmOptions defaultOpts;
-
-    @Before
-    public void setUp()
-    {
-        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
-        emvEncoder = (EmergencyVehicleFlagEncoder) encodingManager.getEncoder("EMV");
-        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
-                weighting(new ShortestWeighting()).build();
-    }
-
-    protected Graph createGraph( EncodingManager em, boolean is3D )
-    {
-        return new GraphBuilder(em).set3D(is3D).create();
-    }
-
-    protected Graph createGraph( boolean is3D )
-    {
-        return createGraph(encodingManager, is3D);
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g )
-    {
-        return createAlgo(g, defaultOpts);
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {
-        return createFactory(g, opts).createAlgo(g, opts);
-    }
-
-    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
-
-    @Test
-    public void testCalcShortestPath()
-    {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
-        Path p = algo.calcPath(0, 7);
-        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
-        assertEquals(p.toString(), 62.1, p.getDistance(), .1);
-    }
-
-    @Test
-    public void testWeightLimit()
-    {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
-        algo.setWeightLimit(10);
-        Path p = algo.calcPath(0, 7);
-        assertTrue(algo.getVisitedNodes() < 7);
-        assertFalse(p.isFound());
-        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
-    }
-
-    @Test
-    public void testWeightLimit_issue380()
-    {
-        Graph graph = createGraph(false);
-        initGraphWeightLimit(graph);
-        RoutingAlgorithm algo = createAlgo(graph);
-        algo.setWeightLimit(3);
-        Path p = algo.calcPath(0, 4);
-        assertTrue(p.isFound());
-        assertEquals(3.0, p.getWeight(), 1e-6);
-
-        algo = createAlgo(graph);
-        algo.setWeightLimit(3);
-        p = algo.calcPath(0, 3);
-        assertTrue(p.isFound());
-        assertEquals(3.0, p.getWeight(), 1e-6);
-    }
-
-    // see calc-fastest-graph.svg
-    @Test
-    public void testCalcFastestPath()
-    {
-        Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest, carEncoder);
-        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
-        assertEquals(p1.toString(), 144823, p1.getTime());
-
-        Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest, carEncoder);
-        Path p2 = createAlgo(graphFastest,
-                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
-                calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
-        assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
-        assertEquals(p2.toString(), 111437, p2.getTime());
-    }
-
-    // 0-1-2-3
-    // |/|/ /|
-    // 4-5-- |
-    // |/ \--7
-    // 6----/
-    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
-    {
-        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
-
-        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
-
-        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
-
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
-
-        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
-
-        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
-
-        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
-
-        updateDistancesFor(graph, 0, 0.002, 0);
-        updateDistancesFor(graph, 1, 0.002, 0.001);
-        updateDistancesFor(graph, 2, 0.002, 0.002);
-        updateDistancesFor(graph, 3, 0.002, 0.003);
-        updateDistancesFor(graph, 4, 0.0015, 0);
-        updateDistancesFor(graph, 5, 0.0015, 0.001);
-        updateDistancesFor(graph, 6, 0, 0);
-        updateDistancesFor(graph, 7, 0.001, 0.003);
-
-        edge12.setDistance(edge12.getDistance() * 2);
-        edge53.setDistance(edge53.getDistance() * 2);
-    }
-
-    @Test
-    public void testCalcFootPath()
-    {
-        Graph graphShortest = createGraph(false);
-        initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
-                weighting(new ShortestWeighting()).build()).
-                calcPath(0, 7);
-        assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
-        assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
-        assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
-    }
-    
-    @Test
-    /**
-     * 0-7 can take route 4-5-2-3 despite first and last edge being private as must be able to leave a private start point or reach a private destination
-     */
-    public void testCalcStartEndOnlyPrivatePath()
-    {
-    	Way way = new OSMWay(1L);
-    	way.setTag("access", "no");
-    	way.setTag("highway","track");
-    	way.setTag("tracktype","grade3");
-        Graph graphShortest = createGraph(false);
-        initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
-        
-        GHUtility.printEdgeInfo(graphShortest, emvEncoder);
-        GHUtility.printInfo(graphShortest, 0,20, EdgeFilter.ALL_EDGES);
-        RoutingAlgorithm algo = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(emvEncoder).
-                weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting(), 4, 3)).build());
-		
-        Path p1 = algo.calcPath(4, 3);
-        assertEquals(Helper.createTList(4, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6); 
-    }
-    
-    @Test
-    /**
-     * 0-7 cannot take shortest route 0-4-6-7 so must instead take 0-1-5-7
-     */
-    public void testCalcWontTraversePrivatePath()
-    {
-    	Way way = new OSMWay(1L);
-    	way.setTag("access", "no");
-    	way.setTag("highway","track");
-    	way.setTag("tracktype","grade3");
-        Graph graphShortest = createGraph(false);
-        initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
-        
-        GHUtility.printEdgeInfo(graphShortest, emvEncoder);
-        GHUtility.printInfo(graphShortest, 0,20, EdgeFilter.ALL_EDGES);
-        RoutingAlgorithm algo = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(emvEncoder).
-                weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting(), 0, 7)).build());
+
+	// problem is: matrix graph is expensive to create to cache it in a static variable
+	private static Graph matrixGraph;
+	protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT,EMV");
+	protected FlagEncoder carEncoder;
+	protected FlagEncoder footEncoder;
+	protected EmergencyVehicleFlagEncoder emvEncoder;
+	protected AlgorithmOptions defaultOpts;
+
+	@Before
+	public void setUp()
+	{
+		carEncoder = encodingManager.getEncoder("CAR");
+		footEncoder = encodingManager.getEncoder("FOOT");
+		emvEncoder = (EmergencyVehicleFlagEncoder) encodingManager.getEncoder("EMV");
+		defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder)
+		        .weighting(new ShortestWeighting()).build();
+	}
+
+	protected Graph createGraph( EncodingManager em, boolean is3D )
+	{
+		return new GraphBuilder(em).set3D(is3D).create();
+	}
+
+	protected Graph createGraph( boolean is3D )
+	{
+		return createGraph(encodingManager, is3D);
+	}
+
+	public RoutingAlgorithm createAlgo( Graph g )
+	{
+		return createAlgo(g, defaultOpts);
+	}
+
+	public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+	{
+		return createFactory(g, opts).createAlgo(g, opts);
+	}
+
+	public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
+
+	@Test
+	public void testCalcShortestPath()
+	{
+		Graph graph = createTestGraph();
+		RoutingAlgorithm algo = createAlgo(graph);
+		Path p = algo.calcPath(0, 7);
+		assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+		assertEquals(p.toString(), 62.1, p.getDistance(), .1);
+	}
+
+	@Test
+	public void testWeightLimit()
+	{
+		Graph graph = createTestGraph();
+		RoutingAlgorithm algo = createAlgo(graph);
+		algo.setWeightLimit(10);
+		Path p = algo.calcPath(0, 7);
+		assertTrue(algo.getVisitedNodes() < 7);
+		assertFalse(p.isFound());
+		assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
+	}
+
+	@Test
+	public void testWeightLimit_issue380()
+	{
+		Graph graph = createGraph(false);
+		initGraphWeightLimit(graph);
+		RoutingAlgorithm algo = createAlgo(graph);
+		algo.setWeightLimit(3);
+		Path p = algo.calcPath(0, 4);
+		assertTrue(p.isFound());
+		assertEquals(3.0, p.getWeight(), 1e-6);
+
+		algo = createAlgo(graph);
+		algo.setWeightLimit(3);
+		p = algo.calcPath(0, 3);
+		assertTrue(p.isFound());
+		assertEquals(3.0, p.getWeight(), 1e-6);
+	}
+
+	// see calc-fastest-graph.svg
+	@Test
+	public void testCalcFastestPath()
+	{
+		Graph graphShortest = createGraph(false);
+		initDirectedAndDiffSpeed(graphShortest, carEncoder);
+		Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
+		assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+		assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+		assertEquals(p1.toString(), 144823, p1.getTime());
+
+		Graph graphFastest = createGraph(false);
+		initDirectedAndDiffSpeed(graphFastest, carEncoder);
+		Path p2 = createAlgo(
+		        graphFastest,
+		        AlgorithmOptions.start().flagEncoder(carEncoder)
+		                .weighting(new FastestWeighting(carEncoder)).build()).calcPath(0, 3);
+		assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
+		assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
+		assertEquals(p2.toString(), 111437, p2.getTime());
+	}
+
+	// 0-1-2-3
+	// |/|/ /|
+	// 4-5-- |
+	// |/ \--7
+	// 6----/
+	protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
+	{
+		graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+		graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
+
+		graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+		graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+		EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
+
+		graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+		graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
+
+		EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+		graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
+
+		graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+		graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
+
+		graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+		graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
+
+		graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
+
+		updateDistancesFor(graph, 0, 0.002, 0);
+		updateDistancesFor(graph, 1, 0.002, 0.001);
+		updateDistancesFor(graph, 2, 0.002, 0.002);
+		updateDistancesFor(graph, 3, 0.002, 0.003);
+		updateDistancesFor(graph, 4, 0.0015, 0);
+		updateDistancesFor(graph, 5, 0.0015, 0.001);
+		updateDistancesFor(graph, 6, 0, 0);
+		updateDistancesFor(graph, 7, 0.001, 0.003);
+
+		edge12.setDistance(edge12.getDistance() * 2);
+		edge53.setDistance(edge53.getDistance() * 2);
+	}
+
+	@Test
+	public void testCalcFootPath()
+	{
+		Graph graphShortest = createGraph(false);
+		initFootVsCar(graphShortest);
+		Path p1 = createAlgo(
+		        graphShortest,
+		        AlgorithmOptions.start().flagEncoder(footEncoder)
+		                .weighting(new ShortestWeighting()).build()).calcPath(0, 7);
+		assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
+		assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
+		assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
+	}
+
+	@Test
+	/**
+	 * 0-7 can take route 4-5-2-3 despite first and last edge being private as must be able to leave a private start point or reach a private destination
+	 */
+	public void testCalcStartEndOnlyPrivatePath()
+	{
+		Way way = new OSMWay(1L);
+		way.setTag("access", "no");
+		way.setTag("highway", "track");
+		way.setTag("tracktype", "grade3");
+		Graph graphShortest = createGraph(false);
+		initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
+
+		GHUtility.printEdgeInfo(graphShortest, emvEncoder);
+		GHUtility.printInfo(graphShortest, 0, 20, EdgeFilter.ALL_EDGES);
+		RoutingAlgorithm algo = createAlgo(graphShortest,
+		AlgorithmOptions.start().flagEncoder(emvEncoder).
+		weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting())).build());
+
+		Path p1 = algo.calcPath(4, 3);
+		assertEquals(Helper.createTList(4, 5, 2, 3), p1.calcNodes());
+		assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
+	}
+
+	@Test
+	/**
+	 * 0-7 cannot take shortest route 0-4-6-7 so must instead take 0-1-5-7
+	 */
+	public void testCalcWontTraversePrivatePath()
+	{
+		Way way = new OSMWay(1L);
+		way.setTag("access", "no");
+		way.setTag("highway", "track");
+		way.setTag("tracktype", "grade3");
+		Graph graphShortest = createGraph(false);
+		initPrivateSections(graphShortest, emvEncoder.handleWayTags(way, 16, 0));
+
+		GHUtility.printEdgeInfo(graphShortest, emvEncoder);
+		GHUtility.printInfo(graphShortest, 0, 20, EdgeFilter.ALL_EDGES);
+		RoutingAlgorithm algo = createAlgo(graphShortest,
+		AlgorithmOptions.start().flagEncoder(emvEncoder).
+		weighting(new EscapePrivateWeighting(graphShortest, emvEncoder, new ShortestWeighting())).build());
 		Path p1 = algo.calcPath(0, 7);
 		assertEquals(Helper.createTList(0, 1, 5, 7), p1.calcNodes());
-        assertEquals(p1.toString(), 19000, p1.getDistance(), 1e-6); 
-    }
-
-    protected void initFootVsCar( Graph graph )
-    {
-        graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
-
-        graph.edge(1, 4).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(20000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, true));
-
-        graph.edge(5, 2).setDistance(5000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(5, 3).setDistance(11000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(4, 6).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(5, 4).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(5, 6).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
-
-        graph.edge(6, 7).setDistance(5000).setFlags(carEncoder.setProperties(20, true, true));
-    }
-    
-    protected void initPrivateSections( Graph graph, long privateSectionFlagValue  )
-    {
-        graph.edge(0, 1).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
-        graph.edge(0, 4).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true) );
-
-        graph.edge(1, 4).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(20000).setFlags(emvEncoder.setProperties(10, true, true));
-
-        graph.edge(5, 2).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
-        graph.edge(2, 3).setDistance(5000).setFlags(privateSectionFlagValue);
-
-        graph.edge(5, 3).setDistance(11000).setFlags(privateSectionFlagValue);
-        graph.edge(3, 7).setDistance(7000).setFlags(privateSectionFlagValue);
-
-        graph.edge(4, 6).setDistance(5000).setFlags(privateSectionFlagValue);
-        graph.edge(5, 4).setDistance(7000).setFlags(privateSectionFlagValue);
-
-        graph.edge(5, 6).setDistance(7000).setFlags(privateSectionFlagValue);
-        graph.edge(7, 5).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
-
-        graph.edge(6, 7).setDistance(6000).setFlags(emvEncoder.setProperties(10, true, true));
-    }
-
-    // see test-graph.svg !
-    protected Graph createTestGraph()
-    {
-        Graph graph = createGraph(false);
-
-        graph.edge(0, 1, 7, true);
-        graph.edge(0, 4, 6, true);
-
-        graph.edge(1, 4, 2, true);
-        graph.edge(1, 5, 8, true);
-        graph.edge(1, 2, 2, true);
-
-        graph.edge(2, 5, 5, true);
-        graph.edge(2, 3, 2, true);
-
-        graph.edge(3, 5, 2, true);
-        graph.edge(3, 7, 10, true);
-
-        graph.edge(4, 6, 4, true);
-        graph.edge(4, 5, 7, true);
-
-        graph.edge(5, 6, 2, true);
-        graph.edge(5, 7, 1, true);
-
-        EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
-
-        updateDistancesFor(graph, 0, 0.0010, 0.00001);
-        updateDistancesFor(graph, 1, 0.0008, 0.0000);
-        updateDistancesFor(graph, 2, 0.0005, 0.0001);
-        updateDistancesFor(graph, 3, 0.0006, 0.0002);
-        updateDistancesFor(graph, 4, 0.0009, 0.0001);
-        updateDistancesFor(graph, 5, 0.0007, 0.0001);
-        updateDistancesFor(graph, 6, 0.0009, 0.0002);
-        updateDistancesFor(graph, 7, 0.0008, 0.0003);
-
-        edge6_7.setDistance(5 * edge6_7.getDistance());
-        return graph;
-    }
-
-    @Test
-    public void testNoPathFound()
-    {
-        Graph graph = createGraph(false);
-        assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
-
-        // two disconnected areas
-        graph.edge(0, 1, 7, true);
-
-        graph.edge(5, 6, 2, true);
-        graph.edge(5, 7, 1, true);
-        graph.edge(5, 8, 1, true);
-        graph.edge(7, 8, 1, true);
-        RoutingAlgorithm algo = createAlgo(graph);
-        assertFalse(algo.calcPath(0, 5).isFound());
-        // assertEquals(3, algo.getVisitedNodes());
-
-        // disconnected as directed graph
-        graph = createGraph(false);
-        graph.edge(0, 1, 1, false);
-        graph.edge(0, 2, 1, true);
-        assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
-    }
-
-    @Test
-    public void testWikipediaShortestPath()
-    {
-        Graph graph = createWikipediaTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 4);
-        assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), 4, p.calcNodes().size());
-    }
-
-    @Test
-    public void testCalcIf1EdgeAway()
-    {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(1, 2);
-        assertEquals(Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 35.1, p.getDistance(), .1);
-    }
-
-    // see wikipedia-graph.svg !
-    protected Graph createWikipediaTestGraph()
-    {
-        Graph graph = createGraph(false);
-        graph.edge(0, 1, 7, true);
-        graph.edge(0, 2, 9, true);
-        graph.edge(0, 5, 14, true);
-        graph.edge(1, 2, 10, true);
-        graph.edge(1, 3, 15, true);
-        graph.edge(2, 5, 2, true);
-        graph.edge(2, 3, 11, true);
-        graph.edge(3, 4, 6, true);
-        graph.edge(4, 5, 9, true);
-        return graph;
-    }
-
-    // 0-1-2-3-4
-    // |     / |
-    // |    8  |
-    // \   /   |
-    //  7-6----5
-    public static Graph initBiGraph( Graph graph )
-    {
-        // distance will be overwritten in second step as we need to calculate it from lat,lon
-        graph.edge(0, 1, 1, true);
-        graph.edge(1, 2, 1, true);
-        graph.edge(2, 3, 1, true);
-        graph.edge(3, 4, 1, true);
-        graph.edge(4, 5, 1, true);
-        graph.edge(5, 6, 1, true);
-        graph.edge(6, 7, 1, true);
-        graph.edge(7, 0, 1, true);
-        graph.edge(3, 8, 1, true);
-        graph.edge(8, 6, 1, true);
-
-        // we need lat,lon for edge precise queries because the distances of snapped point 
-        // to adjacent nodes is calculated from lat,lon of the necessary points
-        updateDistancesFor(graph, 0, 0.001, 0);
-        updateDistancesFor(graph, 1, 0.100, 0.0005);
-        updateDistancesFor(graph, 2, 0.010, 0.0010);
-        updateDistancesFor(graph, 3, 0.001, 0.0011);
-        updateDistancesFor(graph, 4, 0.001, 0.00111);
-
-        updateDistancesFor(graph, 8, 0.0005, 0.0011);
-
-        updateDistancesFor(graph, 7, 0, 0);
-        updateDistancesFor(graph, 6, 0, 0.001);
-        updateDistancesFor(graph, 5, 0, 0.004);
-        return graph;
-    }
-
-    private static final DistanceCalc distCalc = new DistanceCalcEarth();
-
-    public static void updateDistancesFor( Graph g, int node, double lat, double lon )
-    {
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(node, lat, lon);
-        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
-        while (iter.next())
-        {
-            int adj = iter.getAdjNode();
-            double adjLat = na.getLatitude(adj);
-            double adjLon = na.getLongitude(adj);
-            iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
-            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
-        }
-    }
-
-    @Test
-    public void testBidirectional()
-    {
-        Graph graph = createGraph(false);
-        initBiGraph(graph);
-
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        Path p = createAlgo(graph).calcPath(0, 4);
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
-        assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
-
-        p = createAlgo(graph).calcPath(1, 2);
-        // the other way around is even larger as 0-1 is already 11008.452
-        assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
-    }
-
-    // 1-2-3-4-5
-    // |     / |
-    // |    9  |
-    // \   /   /
-    //  8-7-6-/
-    @Test
-    public void testBidirectional2()
-    {
-        Graph graph = createGraph(false);
-
-        graph.edge(0, 1, 100, true);
-        graph.edge(1, 2, 1, true);
-        graph.edge(2, 3, 1, true);
-        graph.edge(3, 4, 1, true);
-        graph.edge(4, 5, 20, true);
-        graph.edge(5, 6, 10, true);
-        graph.edge(6, 7, 5, true);
-        graph.edge(7, 0, 5, true);
-        graph.edge(3, 8, 20, true);
-        graph.edge(8, 6, 20, true);
-
-        Path p = createAlgo(graph).calcPath(0, 4);
-        assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), 5, p.calcNodes().size());
-        assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
-    }
-
-    @Test
-    public void testRekeyBugOfIntBinHeap()
-    {
-        // using Dijkstra + IntBinHeap then rekey loops endlessly
-        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
-        assertEquals(12, p.calcNodes().size());
-
-        TIntList list = p.calcNodes();
-        if (!Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91).equals(list)
-                && !Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list))
-        {
-            assertTrue("wrong locations: " + list.toString(), false);
-        }
-        assertEquals(66f, p.getDistance(), 1e-3);
-    }
-
-    @Test
-    public void testBug1()
-    {
-        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
-        assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
-        assertEquals(3, p.calcNodes().size());
-        assertEquals(17, p.getDistance(), 1e-5);
-    }
-
-    @Test
-    public void testCorrectWeight()
-    {
-        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
-        assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
-        assertEquals(38f, p.getDistance(), 1e-3);
-    }
-
-    @Test
-    public void testCannotCalculateSP()
-    {
-        Graph graph = createGraph(false);
-        graph.edge(0, 1, 1, false);
-        graph.edge(1, 2, 1, false);
-
-        Path p = createAlgo(graph).calcPath(0, 2);
-        assertEquals(p.toString(), 3, p.calcNodes().size());
-    }
-
-    @Test
-    public void testDirectedGraphBug1()
-    {
-        Graph graph = createGraph(false);
-        graph.edge(0, 1, 3, false);
-        graph.edge(1, 2, 2.99, false);
-
-        graph.edge(0, 3, 2, false);
-        graph.edge(3, 4, 3, false);
-        graph.edge(4, 2, 1, false);
-
-        Path p = createAlgo(graph).calcPath(0, 2);
-        assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
-        assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), 3, p.calcNodes().size());
-    }
-
-    @Test
-    public void testDirectedGraphBug2()
-    {
-        Graph graph = createGraph(false);
-        graph.edge(0, 1, 1, false);
-        graph.edge(1, 2, 1, false);
-        graph.edge(2, 3, 1, false);
-
-        graph.edge(3, 1, 4, true);
-
-        Path p = createAlgo(graph).calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
-    }
-
-    // a-b-0-c-1
-    // |   |  _/\
-    // |  /  /  |
-    // d-2--3-e-4
-    @Test
-    public void testWithCoordinates()
-    {
-        Graph graph = createGraph(false);
-        NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 0, 2);
-        na.setNode(1, 0, 3.5);
-        na.setNode(2, 1, 1);
-        na.setNode(3, 1.5, 2.5);
-        na.setNode(4, 0.5, 4.5);
-
-        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
-        graph.edge(2, 3, 2, true);
-        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(1, 3.5));
-
-        graph.edge(0, 2, 0.8, true).setWayGeometry(Helper.createPointList(0, 1.6, 0, 0, 1, 0));
-        graph.edge(0, 2, 1.2, true);
-        graph.edge(1, 3, 1.3, true);
-        graph.edge(1, 4, 1, true);
-
-        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
-        RoutingAlgorithmFactory prepare = createFactory(graph, opts);
-        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
-        assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
-        assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
-        assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
-
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
-        // System.out.println(p.toDetailsString());
-        assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
-        assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
-        assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
-    }
-
-    @Test
-    public void testCalcIfEmptyWay()
-    {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 0);
-        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
-    }
-
-    @Test
-    public void testViaEdges_FromEqualsTo()
-    {
-        Graph graph = createTestGraph();
-        // identical tower nodes
-        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
-        assertTrue(p.isFound());
-        assertEquals(Helper.createTList(0), p.calcNodes());
-        // assertEquals(1, p.calcPoints().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
-
-        // identical query points on edge
-        p = calcPath(graph, 0, 1, 0, 1);
-        assertTrue(p.isFound());
-        assertEquals(Helper.createTList(8), p.calcNodes());
-        // assertEquals(1, p.calcPoints().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
-
-        // very close
-        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
-        assertEquals(p.toString(), 1.11, p.getDistance(), .1);
-    }
-
-    @Test
-    public void testViaEdges_BiGraph()
-    {
-        Graph graph = createGraph(false);
-        initBiGraph(graph);
-
-        // 0-7 to 4-3        
-        Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
-        assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
-
-        // 0-1 to 2-3
-        p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
-    }
-
-    @Test
-    public void testViaEdges_WithCoordinates()
-    {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 2, 3);
-        assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
-        assertEquals(p.toString(), 56.7, p.getDistance(), .1);
-    }
-
-    @Test
-    public void testViaEdges_SpecialCases()
-    {
-        Graph graph = createGraph(false);
-        // 0->1\
-        // |    2
-        // 4<-3/
-        graph.edge(0, 1, 7, false);
-        graph.edge(1, 2, 7, true);
-        graph.edge(2, 3, 7, true);
-        graph.edge(3, 4, 7, false);
-        graph.edge(4, 0, 7, true);
-
-        updateDistancesFor(graph, 4, 0, 0);
-        updateDistancesFor(graph, 0, 0.00010, 0);
-        updateDistancesFor(graph, 1, 0.00010, 0.0001);
-        updateDistancesFor(graph, 2, 0.00005, 0.00015);
-        updateDistancesFor(graph, 3, 0, 0.0001);
-
-        // 0-1 to 3-4
-        Path p = calcPathViaQuery(graph, 0.00010, 0.00001, 0, 0.00009);
-        assertEquals(Helper.createTList(6, 1, 2, 3, 5), p.calcNodes());
-        assertEquals(p.toString(), 26.81, p.getDistance(), .1);
-
-        // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
-        assertEquals(Helper.createTList(5, 6), p.calcNodes());
-        assertEquals(p.toString(), 6.2, p.getDistance(), .1);
-
-        // 'from' and 'to' edge share one node '2': 1-2 to 3-2
-        p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
-        assertEquals(p.toString(), Helper.createTList(6, 2, 5), p.calcNodes());
-        assertEquals(p.toString(), 12.57, p.getDistance(), .1);
-    }
-
-    @Test
-    public void testQueryGraphAndFastest()
-    {
-        Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph, carEncoder);
-        Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
-        assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
-        assertEquals(602.98, p.getDistance(), 1e-1);
-    }
-
-    // Problem: for contraction hierarchy we cannot easily select egdes by nodes as some edges are skipped
-    Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat, double toLon )
-    {
-        return calcPathViaQuery("shortest", graph, fromLat, fromLon, toLat, toLon);
-    }
-
-    Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
-    {
-        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
-        index.prepareIndex();
-        QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
-        QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
-        Weighting w = new ShortestWeighting();
-        if (weighting.equalsIgnoreCase("fastest"))
-            w = new FastestWeighting(carEncoder);
-
-        // correct order for CH: in factory do prepare and afterwards wrap in query graph
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
-        RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
-        return factory.createAlgo(qGraph, opts).
-                calcPath(from.getClosestNode(), to.getClosestNode());
-    }
-
-    Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
-    {
-        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
-        QueryResult from = newQR(graph, fromNode1, fromNode2);
-        QueryResult to = newQR(graph, toNode1, toNode2);
-
-        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
-        return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
-    }
-
-    /**
-     * Creates query result on edge (node1-node2) very close to node1.
-     */
-    QueryResult newQR( Graph graph, int node1, int node2 )
-    {
-        EdgeIteratorState edge = GHUtility.getEdge(graph, node1, node2);
-        if (edge == null)
-            throw new IllegalStateException("edge not found? " + node1 + "-" + node2);
-
-        NodeAccess na = graph.getNodeAccess();
-        double lat = na.getLatitude(edge.getBaseNode());
-        double lon = na.getLongitude(edge.getBaseNode());
-        double latAdj = na.getLatitude(edge.getAdjNode());
-        double lonAdj = na.getLongitude(edge.getAdjNode());
-        // calculate query point near the base node but not directly on it!
-        QueryResult res = new QueryResult(lat + (latAdj - lat) * .1, lon + (lonAdj - lon) * .1);
-        res.setClosestNode(edge.getBaseNode());
-        res.setClosestEdge(edge);
-        res.setWayIndex(0);
-        res.setSnappedPosition(QueryResult.Position.EDGE);
-        res.calcSnappedPoint(distCalc);
-        return res;
-    }
-
-    @Test
-    public void testTwoWeightsPerEdge()
-    {
-        FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        Graph graph = initEleGraph(createGraph(new EncodingManager(encoder), true));
-        // force the other path
-        GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
-
-        // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
-        // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
-//        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
-        assertEquals(85124371, p.getTime());
-        assertEquals(425622, p.getDistance(), 1);
-        assertEquals(85124.4, p.getWeight(), 1);
-    }
-
-    @Test
-    public void test0SpeedButUnblocked_Issue242()
-    {
-        Graph graph = createGraph(false);
-        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
-
-        graph.edge(0, 1).setFlags(flags).setDistance(10);
-        graph.edge(1, 2).setFlags(flags).setDistance(10);
-
-        RoutingAlgorithm algo = createAlgo(graph);
-        try
-        {
-            Path p = algo.calcPath(0, 2);
-            assertTrue(false);
-        } catch (Exception ex)
-        {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
-        }
-    }
-
-    @Test
-    public void testTwoWeightsPerEdge2()
-    {
-        // other direction should be different!
-        Graph graph = initEleGraph(createGraph(true));
-        Path p = createAlgo(graph).calcPath(0, 10);
-        // GHUtility.printEdgeInfo(graph, carEncoder);
-        assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
-        Weighting fakeWeighting = new Weighting()
-        {
-            @Override
-            public double getMinWeight( double distance )
-            {
-                return distance;
-            }
-
-            @Override
-            public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
-            {
-                int adj = edgeState.getAdjNode();
-                int base = edgeState.getBaseNode();
-                if (reverse)
-                {
-                    int tmp = base;
-                    base = adj;
-                    adj = tmp;
-                }
-
-                // a 'hill' at node 6
-                if (adj == 6)
-                    return 3 * edgeState.getDistance();
-                else if (base == 6)
-                    return edgeState.getDistance() * 0.9;
-                else if (adj == 4)
-                    return 2 * edgeState.getDistance();
-
-                return edgeState.getDistance() * 0.8;
-            }
-        };
-
-        graph = initEleGraph(createGraph(true));
-        QueryResult from = newQR(graph, 3, 0);
-        QueryResult to = newQR(graph, 10, 9);
-
-        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
-        RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
-        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
-        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
-        assertEquals(37009621, p.getTime());
-        assertEquals(616827, p.getDistance(), 1);
-        assertEquals(493462, p.getWeight(), 1);
-    }
-
-    // 0-1-2
-    // |\| |
-    // 3 4-11
-    // | | |
-    // 5-6-7
-    // | |\|
-    // 8-9-10
-    Graph initEleGraph( Graph g )
-    {
-        g.edge(0, 1, 10, true);
-        g.edge(0, 4, 12, true);
-        g.edge(0, 3, 5, true);
-        g.edge(1, 2, 10, true);
-        g.edge(1, 4, 5, true);
-        g.edge(3, 5, 5, false);
-        g.edge(5, 6, 10, true);
-        g.edge(5, 8, 10, true);
-        g.edge(6, 4, 5, true);
-        g.edge(6, 7, 10, true);
-        g.edge(6, 10, 12, true);
-        g.edge(6, 9, 12, true);
-        g.edge(2, 11, 5, false);
-        g.edge(4, 11, 10, true);
-        g.edge(7, 11, 5, true);
-        g.edge(7, 10, 5, true);
-        g.edge(8, 9, 10, false);
-        g.edge(9, 8, 9, false);
-        g.edge(10, 9, 10, false);
-        updateDistancesFor(g, 0, 3, 0);
-        updateDistancesFor(g, 3, 2.5, 0);
-        updateDistancesFor(g, 5, 1, 0);
-        updateDistancesFor(g, 8, 0, 0);
-        updateDistancesFor(g, 1, 3, 1);
-        updateDistancesFor(g, 4, 2, 1);
-        updateDistancesFor(g, 6, 1, 1);
-        updateDistancesFor(g, 9, 0, 1);
-        updateDistancesFor(g, 2, 3, 2);
-        updateDistancesFor(g, 11, 2, 2);
-        updateDistancesFor(g, 7, 1, 2);
-        updateDistancesFor(g, 10, 0, 2);
-        return g;
-    }
-
-    public static Graph initGraphWeightLimit( Graph g )
-    {
-        //      0----1
-        //     /     |
-        //    7--    |
-        //   /   |   |
-        //   6---5   |
-        //   |   |   |
-        //   4---3---2
-
-        g.edge(0, 1, 1, true);
-        g.edge(1, 2, 1, true);
-
-        g.edge(3, 2, 1, true);
-        g.edge(3, 5, 1, true);
-        g.edge(5, 7, 1, true);
-        g.edge(3, 4, 1, true);
-        g.edge(4, 6, 1, true);
-        g.edge(6, 7, 1, true);
-        g.edge(6, 5, 1, true);
-        g.edge(0, 7, 1, true);
-        return g;
-    }
-
-    public Graph getMatrixGraph()
-    {
-        return getMatrixAlikeGraph();
-    }
-
-    public static Graph getMatrixAlikeGraph()
-    {
-        if (matrixGraph == null)
-            matrixGraph = createMatrixAlikeGraph();
-        return matrixGraph;
-    }
-
-    private static Graph createMatrixAlikeGraph()
-    {
-        int WIDTH = 10;
-        int HEIGHT = 15;
-        Graph tmpGraph = new GraphBuilder(encodingManager).create();
-        int[][] matrix = new int[WIDTH][HEIGHT];
-        int counter = 0;
-        Random rand = new Random(12);
-        boolean print = false;
-        for (int h = 0; h < HEIGHT; h++)
-        {
-            if (print)
-            {
-                for (int w = 0; w < WIDTH; w++)
-                {
-                    System.out.print(" |\t           ");
-                }
-                System.out.println();
-            }
-
-            for (int w = 0; w < WIDTH; w++)
-            {
-                matrix[w][h] = counter++;
-                if (h > 0)
-                {
-                    float dist = 5 + Math.abs(rand.nextInt(5));
-                    if (print)
-                        System.out.print(" " + (int) dist + "\t           ");
-
-                    tmpGraph.edge(matrix[w][h], matrix[w][h - 1], dist, true);
-                }
-            }
-            if (print)
-            {
-                System.out.println();
-                if (h > 0)
-                {
-                    for (int w = 0; w < WIDTH; w++)
-                    {
-                        System.out.print(" |\t           ");
-                    }
-                    System.out.println();
-                }
-            }
-
-            for (int w = 0; w < WIDTH; w++)
-            {
-                if (w > 0)
-                {
-                    float dist = 5 + Math.abs(rand.nextInt(5));
-                    if (print)
-                        System.out.print("-- " + (int) dist + "\t-- ");
-                    tmpGraph.edge(matrix[w][h], matrix[w - 1][h], dist, true);
-                }
-                if (print)
-                    System.out.print("(" + matrix[w][h] + ")\t");
-            }
-            if (print)
-                System.out.println();
-        }
-
-        return tmpGraph;
-    }
+		assertEquals(p1.toString(), 19000, p1.getDistance(), 1e-6);
+	}
+
+	protected void initFootVsCar( Graph graph )
+	{
+		graph.edge(0, 1)
+		        .setDistance(7000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(10, true, false));
+		graph.edge(0, 4)
+		        .setDistance(5000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(20, true, false));
+
+		graph.edge(1, 4).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
+		graph.edge(1, 5).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
+		graph.edge(1, 2)
+		        .setDistance(20000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(10, true, true));
+
+		graph.edge(5, 2).setDistance(5000).setFlags(carEncoder.setProperties(10, true, false));
+		graph.edge(2, 3)
+		        .setDistance(5000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(10, true, false));
+
+		graph.edge(5, 3).setDistance(11000).setFlags(carEncoder.setProperties(20, true, false));
+		graph.edge(3, 7)
+		        .setDistance(7000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(10, true, false));
+
+		graph.edge(4, 6).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
+		graph.edge(5, 4)
+		        .setDistance(7000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(10, true, false));
+
+		graph.edge(5, 6).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
+		graph.edge(7, 5)
+		        .setDistance(5000)
+		        .setFlags(
+		                footEncoder.setProperties(5, true, true)
+		                        | carEncoder.setProperties(20, true, false));
+
+		graph.edge(6, 7).setDistance(5000).setFlags(carEncoder.setProperties(20, true, true));
+	}
+
+	protected void initPrivateSections( Graph graph, long privateSectionFlagValue )
+	{
+		graph.edge(0, 1).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+		graph.edge(0, 4).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
+
+		graph.edge(1, 4).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+		graph.edge(1, 5).setDistance(7000).setFlags(emvEncoder.setProperties(10, true, true));
+		graph.edge(1, 2).setDistance(20000).setFlags(emvEncoder.setProperties(10, true, true));
+
+		graph.edge(5, 2).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
+		graph.edge(2, 3).setDistance(5000).setFlags(privateSectionFlagValue);
+
+		graph.edge(5, 3).setDistance(11000).setFlags(privateSectionFlagValue);
+		graph.edge(3, 7).setDistance(7000).setFlags(privateSectionFlagValue);
+
+		graph.edge(4, 6).setDistance(5000).setFlags(privateSectionFlagValue);
+		graph.edge(5, 4).setDistance(7000).setFlags(privateSectionFlagValue);
+
+		graph.edge(5, 6).setDistance(7000).setFlags(privateSectionFlagValue);
+		graph.edge(7, 5).setDistance(5000).setFlags(emvEncoder.setProperties(10, true, true));
+
+		graph.edge(6, 7).setDistance(6000).setFlags(emvEncoder.setProperties(10, true, true));
+	}
+
+	// see test-graph.svg !
+	protected Graph createTestGraph()
+	{
+		Graph graph = createGraph(false);
+
+		graph.edge(0, 1, 7, true);
+		graph.edge(0, 4, 6, true);
+
+		graph.edge(1, 4, 2, true);
+		graph.edge(1, 5, 8, true);
+		graph.edge(1, 2, 2, true);
+
+		graph.edge(2, 5, 5, true);
+		graph.edge(2, 3, 2, true);
+
+		graph.edge(3, 5, 2, true);
+		graph.edge(3, 7, 10, true);
+
+		graph.edge(4, 6, 4, true);
+		graph.edge(4, 5, 7, true);
+
+		graph.edge(5, 6, 2, true);
+		graph.edge(5, 7, 1, true);
+
+		EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
+
+		updateDistancesFor(graph, 0, 0.0010, 0.00001);
+		updateDistancesFor(graph, 1, 0.0008, 0.0000);
+		updateDistancesFor(graph, 2, 0.0005, 0.0001);
+		updateDistancesFor(graph, 3, 0.0006, 0.0002);
+		updateDistancesFor(graph, 4, 0.0009, 0.0001);
+		updateDistancesFor(graph, 5, 0.0007, 0.0001);
+		updateDistancesFor(graph, 6, 0.0009, 0.0002);
+		updateDistancesFor(graph, 7, 0.0008, 0.0003);
+
+		edge6_7.setDistance(5 * edge6_7.getDistance());
+		return graph;
+	}
+
+	@Test
+	public void testNoPathFound()
+	{
+		Graph graph = createGraph(false);
+		assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
+
+		// two disconnected areas
+		graph.edge(0, 1, 7, true);
+
+		graph.edge(5, 6, 2, true);
+		graph.edge(5, 7, 1, true);
+		graph.edge(5, 8, 1, true);
+		graph.edge(7, 8, 1, true);
+		RoutingAlgorithm algo = createAlgo(graph);
+		assertFalse(algo.calcPath(0, 5).isFound());
+		// assertEquals(3, algo.getVisitedNodes());
+
+		// disconnected as directed graph
+		graph = createGraph(false);
+		graph.edge(0, 1, 1, false);
+		graph.edge(0, 2, 1, true);
+		assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
+	}
+
+	@Test
+	public void testWikipediaShortestPath()
+	{
+		Graph graph = createWikipediaTestGraph();
+		Path p = createAlgo(graph).calcPath(0, 4);
+		assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
+		assertEquals(p.toString(), 4, p.calcNodes().size());
+	}
+
+	@Test
+	public void testCalcIf1EdgeAway()
+	{
+		Graph graph = createTestGraph();
+		Path p = createAlgo(graph).calcPath(1, 2);
+		assertEquals(Helper.createTList(1, 2), p.calcNodes());
+		assertEquals(p.toString(), 35.1, p.getDistance(), .1);
+	}
+
+	// see wikipedia-graph.svg !
+	protected Graph createWikipediaTestGraph()
+	{
+		Graph graph = createGraph(false);
+		graph.edge(0, 1, 7, true);
+		graph.edge(0, 2, 9, true);
+		graph.edge(0, 5, 14, true);
+		graph.edge(1, 2, 10, true);
+		graph.edge(1, 3, 15, true);
+		graph.edge(2, 5, 2, true);
+		graph.edge(2, 3, 11, true);
+		graph.edge(3, 4, 6, true);
+		graph.edge(4, 5, 9, true);
+		return graph;
+	}
+
+	// 0-1-2-3-4
+	// | / |
+	// | 8 |
+	// \ / |
+	// 7-6----5
+	public static Graph initBiGraph( Graph graph )
+	{
+		// distance will be overwritten in second step as we need to calculate it from lat,lon
+		graph.edge(0, 1, 1, true);
+		graph.edge(1, 2, 1, true);
+		graph.edge(2, 3, 1, true);
+		graph.edge(3, 4, 1, true);
+		graph.edge(4, 5, 1, true);
+		graph.edge(5, 6, 1, true);
+		graph.edge(6, 7, 1, true);
+		graph.edge(7, 0, 1, true);
+		graph.edge(3, 8, 1, true);
+		graph.edge(8, 6, 1, true);
+
+		// we need lat,lon for edge precise queries because the distances of snapped point
+		// to adjacent nodes is calculated from lat,lon of the necessary points
+		updateDistancesFor(graph, 0, 0.001, 0);
+		updateDistancesFor(graph, 1, 0.100, 0.0005);
+		updateDistancesFor(graph, 2, 0.010, 0.0010);
+		updateDistancesFor(graph, 3, 0.001, 0.0011);
+		updateDistancesFor(graph, 4, 0.001, 0.00111);
+
+		updateDistancesFor(graph, 8, 0.0005, 0.0011);
+
+		updateDistancesFor(graph, 7, 0, 0);
+		updateDistancesFor(graph, 6, 0, 0.001);
+		updateDistancesFor(graph, 5, 0, 0.004);
+		return graph;
+	}
+
+	private static final DistanceCalc distCalc = new DistanceCalcEarth();
+
+	public static void updateDistancesFor( Graph g, int node, double lat, double lon )
+	{
+		NodeAccess na = g.getNodeAccess();
+		na.setNode(node, lat, lon);
+		EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
+		while (iter.next())
+		{
+			int adj = iter.getAdjNode();
+			double adjLat = na.getLatitude(adj);
+			double adjLon = na.getLongitude(adj);
+			iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+			// System.out.println(node + "->" + adj + ": " + iter.getDistance());
+		}
+	}
+
+	@Test
+	public void testBidirectional()
+	{
+		Graph graph = createGraph(false);
+		initBiGraph(graph);
+
+		// PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+		Path p = createAlgo(graph).calcPath(0, 4);
+		// PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+		assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
+		assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
+
+		p = createAlgo(graph).calcPath(1, 2);
+		// the other way around is even larger as 0-1 is already 11008.452
+		assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
+		assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
+	}
+
+	// 1-2-3-4-5
+	// | / |
+	// | 9 |
+	// \ / /
+	// 8-7-6-/
+	@Test
+	public void testBidirectional2()
+	{
+		Graph graph = createGraph(false);
+
+		graph.edge(0, 1, 100, true);
+		graph.edge(1, 2, 1, true);
+		graph.edge(2, 3, 1, true);
+		graph.edge(3, 4, 1, true);
+		graph.edge(4, 5, 20, true);
+		graph.edge(5, 6, 10, true);
+		graph.edge(6, 7, 5, true);
+		graph.edge(7, 0, 5, true);
+		graph.edge(3, 8, 20, true);
+		graph.edge(8, 6, 20, true);
+
+		Path p = createAlgo(graph).calcPath(0, 4);
+		assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
+		assertEquals(p.toString(), 5, p.calcNodes().size());
+		assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
+	}
+
+	@Test
+	public void testRekeyBugOfIntBinHeap()
+	{
+		// using Dijkstra + IntBinHeap then rekey loops endlessly
+		Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
+		assertEquals(12, p.calcNodes().size());
+
+		TIntList list = p.calcNodes();
+		if (!Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91).equals(list)
+		        && !Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list))
+		{
+			assertTrue("wrong locations: " + list.toString(), false);
+		}
+		assertEquals(66f, p.getDistance(), 1e-3);
+	}
+
+	@Test
+	public void testBug1()
+	{
+		Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
+		assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
+		assertEquals(3, p.calcNodes().size());
+		assertEquals(17, p.getDistance(), 1e-5);
+	}
+
+	@Test
+	public void testCorrectWeight()
+	{
+		Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
+		assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
+		assertEquals(38f, p.getDistance(), 1e-3);
+	}
+
+	@Test
+	public void testCannotCalculateSP()
+	{
+		Graph graph = createGraph(false);
+		graph.edge(0, 1, 1, false);
+		graph.edge(1, 2, 1, false);
+
+		Path p = createAlgo(graph).calcPath(0, 2);
+		assertEquals(p.toString(), 3, p.calcNodes().size());
+	}
+
+	@Test
+	public void testDirectedGraphBug1()
+	{
+		Graph graph = createGraph(false);
+		graph.edge(0, 1, 3, false);
+		graph.edge(1, 2, 2.99, false);
+
+		graph.edge(0, 3, 2, false);
+		graph.edge(3, 4, 3, false);
+		graph.edge(4, 2, 1, false);
+
+		Path p = createAlgo(graph).calcPath(0, 2);
+		assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
+		assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
+		assertEquals(p.toString(), 3, p.calcNodes().size());
+	}
+
+	@Test
+	public void testDirectedGraphBug2()
+	{
+		Graph graph = createGraph(false);
+		graph.edge(0, 1, 1, false);
+		graph.edge(1, 2, 1, false);
+		graph.edge(2, 3, 1, false);
+
+		graph.edge(3, 1, 4, true);
+
+		Path p = createAlgo(graph).calcPath(0, 3);
+		assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
+	}
+
+	// a-b-0-c-1
+	// | | _/\
+	// | / / |
+	// d-2--3-e-4
+	@Test
+	public void testWithCoordinates()
+	{
+		Graph graph = createGraph(false);
+		NodeAccess na = graph.getNodeAccess();
+		na.setNode(0, 0, 2);
+		na.setNode(1, 0, 3.5);
+		na.setNode(2, 1, 1);
+		na.setNode(3, 1.5, 2.5);
+		na.setNode(4, 0.5, 4.5);
+
+		graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
+		graph.edge(2, 3, 2, true);
+		graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(1, 3.5));
+
+		graph.edge(0, 2, 0.8, true).setWayGeometry(Helper.createPointList(0, 1.6, 0, 0, 1, 0));
+		graph.edge(0, 2, 1.2, true);
+		graph.edge(1, 3, 1.3, true);
+		graph.edge(1, 4, 1, true);
+
+		AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder,
+		        new ShortestWeighting());
+		RoutingAlgorithmFactory prepare = createFactory(graph, opts);
+		Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
+		assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
+		assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
+		assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+
+		// PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+		p = prepare.createAlgo(graph, opts).calcPath(2, 1);
+		// System.out.println(p.toDetailsString());
+		assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
+		assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5),
+		        p.calcPoints());
+		assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+	}
+
+	@Test
+	public void testCalcIfEmptyWay()
+	{
+		Graph graph = createTestGraph();
+		Path p = createAlgo(graph).calcPath(0, 0);
+		assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
+		assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+	}
+
+	@Test
+	public void testViaEdges_FromEqualsTo()
+	{
+		Graph graph = createTestGraph();
+		// identical tower nodes
+		Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+		assertTrue(p.isFound());
+		assertEquals(Helper.createTList(0), p.calcNodes());
+		// assertEquals(1, p.calcPoints().size());
+		assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+		// identical query points on edge
+		p = calcPath(graph, 0, 1, 0, 1);
+		assertTrue(p.isFound());
+		assertEquals(Helper.createTList(8), p.calcNodes());
+		// assertEquals(1, p.calcPoints().size());
+		assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+		// very close
+		p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+		assertEquals(Helper.createTList(8, 9), p.calcNodes());
+		assertEquals(p.toString(), 1.11, p.getDistance(), .1);
+	}
+
+	@Test
+	public void testViaEdges_BiGraph()
+	{
+		Graph graph = createGraph(false);
+		initBiGraph(graph);
+
+		// 0-7 to 4-3
+		Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
+		assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
+		assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
+
+		// 0-1 to 2-3
+		p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
+		assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+		assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
+	}
+
+	@Test
+	public void testViaEdges_WithCoordinates()
+	{
+		Graph graph = createTestGraph();
+		Path p = calcPath(graph, 0, 1, 2, 3);
+		assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
+		assertEquals(p.toString(), 56.7, p.getDistance(), .1);
+	}
+
+	@Test
+	public void testViaEdges_SpecialCases()
+	{
+		Graph graph = createGraph(false);
+		// 0->1\
+		// | 2
+		// 4<-3/
+		graph.edge(0, 1, 7, false);
+		graph.edge(1, 2, 7, true);
+		graph.edge(2, 3, 7, true);
+		graph.edge(3, 4, 7, false);
+		graph.edge(4, 0, 7, true);
+
+		updateDistancesFor(graph, 4, 0, 0);
+		updateDistancesFor(graph, 0, 0.00010, 0);
+		updateDistancesFor(graph, 1, 0.00010, 0.0001);
+		updateDistancesFor(graph, 2, 0.00005, 0.00015);
+		updateDistancesFor(graph, 3, 0, 0.0001);
+
+		// 0-1 to 3-4
+		Path p = calcPathViaQuery(graph, 0.00010, 0.00001, 0, 0.00009);
+		assertEquals(Helper.createTList(6, 1, 2, 3, 5), p.calcNodes());
+		assertEquals(p.toString(), 26.81, p.getDistance(), .1);
+
+		// overlapping edges: 2-3 and 3-2
+		p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
+		assertEquals(Helper.createTList(5, 6), p.calcNodes());
+		assertEquals(p.toString(), 6.2, p.getDistance(), .1);
+
+		// 'from' and 'to' edge share one node '2': 1-2 to 3-2
+		p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
+		assertEquals(p.toString(), Helper.createTList(6, 2, 5), p.calcNodes());
+		assertEquals(p.toString(), 12.57, p.getDistance(), .1);
+	}
+
+	@Test
+	public void testQueryGraphAndFastest()
+	{
+		Graph graph = createGraph(false);
+		initDirectedAndDiffSpeed(graph, carEncoder);
+		Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
+		assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
+		assertEquals(602.98, p.getDistance(), 1e-1);
+	}
+
+	// Problem: for contraction hierarchy we cannot easily select egdes by nodes as some edges are
+	// skipped
+	Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+	{
+		return calcPathViaQuery("shortest", graph, fromLat, fromLon, toLat, toLon);
+	}
+
+	Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon,
+	        double toLat, double toLon )
+	{
+		LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
+		index.prepareIndex();
+		QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
+		QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
+		Weighting w = new ShortestWeighting();
+		if (weighting.equalsIgnoreCase("fastest"))
+			w = new FastestWeighting(carEncoder);
+
+		// correct order for CH: in factory do prepare and afterwards wrap in query graph
+		AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w)
+		        .build();
+		RoutingAlgorithmFactory factory = createFactory(graph, opts);
+		QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+		return factory.createAlgo(qGraph, opts)
+		        .calcPath(from.getClosestNode(), to.getClosestNode());
+	}
+
+	Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
+	{
+		// lookup two edges: fromNode1-fromNode2 and toNode1-toNode2
+		QueryResult from = newQR(graph, fromNode1, fromNode2);
+		QueryResult to = newQR(graph, toNode1, toNode2);
+
+		RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
+		QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+		return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(),
+		        to.getClosestNode());
+	}
+
+	/**
+	 * Creates query result on edge (node1-node2) very close to node1.
+	 */
+	QueryResult newQR( Graph graph, int node1, int node2 )
+	{
+		EdgeIteratorState edge = GHUtility.getEdge(graph, node1, node2);
+		if (edge == null)
+			throw new IllegalStateException("edge not found? " + node1 + "-" + node2);
+
+		NodeAccess na = graph.getNodeAccess();
+		double lat = na.getLatitude(edge.getBaseNode());
+		double lon = na.getLongitude(edge.getBaseNode());
+		double latAdj = na.getLatitude(edge.getAdjNode());
+		double lonAdj = na.getLongitude(edge.getAdjNode());
+		// calculate query point near the base node but not directly on it!
+		QueryResult res = new QueryResult(lat + (latAdj - lat) * .1, lon + (lonAdj - lon) * .1);
+		res.setClosestNode(edge.getBaseNode());
+		res.setClosestEdge(edge);
+		res.setWayIndex(0);
+		res.setSnappedPosition(QueryResult.Position.EDGE);
+		res.calcSnappedPoint(distCalc);
+		return res;
+	}
+
+	@Test
+	public void testTwoWeightsPerEdge()
+	{
+		FlagEncoder encoder = new Bike2WeightFlagEncoder();
+		Graph graph = initEleGraph(createGraph(new EncodingManager(encoder), true));
+		// force the other path
+		GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
+
+		// for two weights per edge it happened that Path (and also the Weighting) read the wrong
+		// side
+		// of the speed and read 0 => infinity weight => overflow of millis => negative millis!
+		Path p = createAlgo(
+		        graph,
+		        AlgorithmOptions.start().flagEncoder(encoder)
+		                .weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
+		// assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
+		assertEquals(85124371, p.getTime());
+		assertEquals(425622, p.getDistance(), 1);
+		assertEquals(85124.4, p.getWeight(), 1);
+	}
+
+	@Test
+	public void test0SpeedButUnblocked_Issue242()
+	{
+		Graph graph = createGraph(false);
+		long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+
+		graph.edge(0, 1).setFlags(flags).setDistance(10);
+		graph.edge(1, 2).setFlags(flags).setDistance(10);
+
+		RoutingAlgorithm algo = createAlgo(graph);
+		try
+		{
+			Path p = algo.calcPath(0, 2);
+			assertTrue(false);
+		} catch (Exception ex)
+		{
+			assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
+		}
+	}
+
+	@Test
+	public void testTwoWeightsPerEdge2()
+	{
+		// other direction should be different!
+		Graph graph = initEleGraph(createGraph(true));
+		Path p = createAlgo(graph).calcPath(0, 10);
+		// GHUtility.printEdgeInfo(graph, carEncoder);
+		assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
+		Weighting fakeWeighting = new Weighting()
+		{
+			@Override
+			public double getMinWeight( double distance )
+			{
+				return distance;
+			}
+
+			@Override
+			public double calcWeight( EdgeIteratorState edgeState, boolean reverse,
+			        int prevOrNextEdgeId )
+			{
+				int adj = edgeState.getAdjNode();
+				int base = edgeState.getBaseNode();
+				if (reverse)
+				{
+					int tmp = base;
+					base = adj;
+					adj = tmp;
+				}
+
+				// a 'hill' at node 6
+				if (adj == 6)
+					return 3 * edgeState.getDistance();
+				else if (base == 6)
+					return edgeState.getDistance() * 0.9;
+				else if (adj == 4)
+					return 2 * edgeState.getDistance();
+
+				return edgeState.getDistance() * 0.8;
+			}
+		};
+
+		graph = initEleGraph(createGraph(true));
+		QueryResult from = newQR(graph, 3, 0);
+		QueryResult to = newQR(graph, 10, 9);
+
+		AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder)
+		        .weighting(fakeWeighting).build();
+		RoutingAlgorithmFactory factory = createFactory(graph, opts);
+		QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+		p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
+		assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
+		assertEquals(37009621, p.getTime());
+		assertEquals(616827, p.getDistance(), 1);
+		assertEquals(493462, p.getWeight(), 1);
+	}
+
+	// 0-1-2
+	// |\| |
+	// 3 4-11
+	// | | |
+	// 5-6-7
+	// | |\|
+	// 8-9-10
+	Graph initEleGraph( Graph g )
+	{
+		g.edge(0, 1, 10, true);
+		g.edge(0, 4, 12, true);
+		g.edge(0, 3, 5, true);
+		g.edge(1, 2, 10, true);
+		g.edge(1, 4, 5, true);
+		g.edge(3, 5, 5, false);
+		g.edge(5, 6, 10, true);
+		g.edge(5, 8, 10, true);
+		g.edge(6, 4, 5, true);
+		g.edge(6, 7, 10, true);
+		g.edge(6, 10, 12, true);
+		g.edge(6, 9, 12, true);
+		g.edge(2, 11, 5, false);
+		g.edge(4, 11, 10, true);
+		g.edge(7, 11, 5, true);
+		g.edge(7, 10, 5, true);
+		g.edge(8, 9, 10, false);
+		g.edge(9, 8, 9, false);
+		g.edge(10, 9, 10, false);
+		updateDistancesFor(g, 0, 3, 0);
+		updateDistancesFor(g, 3, 2.5, 0);
+		updateDistancesFor(g, 5, 1, 0);
+		updateDistancesFor(g, 8, 0, 0);
+		updateDistancesFor(g, 1, 3, 1);
+		updateDistancesFor(g, 4, 2, 1);
+		updateDistancesFor(g, 6, 1, 1);
+		updateDistancesFor(g, 9, 0, 1);
+		updateDistancesFor(g, 2, 3, 2);
+		updateDistancesFor(g, 11, 2, 2);
+		updateDistancesFor(g, 7, 1, 2);
+		updateDistancesFor(g, 10, 0, 2);
+		return g;
+	}
+
+	public static Graph initGraphWeightLimit( Graph g )
+	{
+		// 0----1
+		// / |
+		// 7-- |
+		// / | |
+		// 6---5 |
+		// | | |
+		// 4---3---2
+
+		g.edge(0, 1, 1, true);
+		g.edge(1, 2, 1, true);
+
+		g.edge(3, 2, 1, true);
+		g.edge(3, 5, 1, true);
+		g.edge(5, 7, 1, true);
+		g.edge(3, 4, 1, true);
+		g.edge(4, 6, 1, true);
+		g.edge(6, 7, 1, true);
+		g.edge(6, 5, 1, true);
+		g.edge(0, 7, 1, true);
+		return g;
+	}
+
+	public Graph getMatrixGraph()
+	{
+		return getMatrixAlikeGraph();
+	}
+
+	public static Graph getMatrixAlikeGraph()
+	{
+		if (matrixGraph == null)
+			matrixGraph = createMatrixAlikeGraph();
+		return matrixGraph;
+	}
+
+	private static Graph createMatrixAlikeGraph()
+	{
+		int WIDTH = 10;
+		int HEIGHT = 15;
+		Graph tmpGraph = new GraphBuilder(encodingManager).create();
+		int[][] matrix = new int[WIDTH][HEIGHT];
+		int counter = 0;
+		Random rand = new Random(12);
+		boolean print = false;
+		for (int h = 0; h < HEIGHT; h++)
+		{
+			if (print)
+			{
+				for (int w = 0; w < WIDTH; w++)
+				{
+					System.out.print(" |\t           ");
+				}
+				System.out.println();
+			}
+
+			for (int w = 0; w < WIDTH; w++)
+			{
+				matrix[w][h] = counter++;
+				if (h > 0)
+				{
+					float dist = 5 + Math.abs(rand.nextInt(5));
+					if (print)
+						System.out.print(" " + (int) dist + "\t           ");
+
+					tmpGraph.edge(matrix[w][h], matrix[w][h - 1], dist, true);
+				}
+			}
+			if (print)
+			{
+				System.out.println();
+				if (h > 0)
+				{
+					for (int w = 0; w < WIDTH; w++)
+					{
+						System.out.print(" |\t           ");
+					}
+					System.out.println();
+				}
+			}
+
+			for (int w = 0; w < WIDTH; w++)
+			{
+				if (w > 0)
+				{
+					float dist = 5 + Math.abs(rand.nextInt(5));
+					if (print)
+						System.out.print("-- " + (int) dist + "\t-- ");
+					tmpGraph.edge(matrix[w][h], matrix[w - 1][h], dist, true);
+				}
+				if (print)
+					System.out.print("(" + matrix[w][h] + ")\t");
+			}
+			if (print)
+				System.out.println();
+		}
+
+		return tmpGraph;
+	}
 }
diff --git a/core/src/test/resources/com/graphhopper/reader/os-itn-simple-private-crossroad.xml b/core/src/test/resources/com/graphhopper/reader/os-itn-simple-private-crossroad.xml
new file mode 100644
index 0000000000..9138e008af
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/os-itn-simple-private-crossroad.xml
@@ -0,0 +1,167 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osgb:FeatureCollection xmlns:osgb='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb'
+	xmlns:gml='http://www.opengis.net/gml' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
+	xsi:schemaLocation='http://www.ordnancesurvey.co.uk/xml/namespaces/osgb http://www.ordnancesurvey.co.uk/xml/schema/v7/OSDNFFeatures.xsd'
+	fid='GDS-58096-1'>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277880'>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>290000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277881'>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>280000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277882'>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>270000.000,90000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277883'>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>280000.000,85000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadNode fid='osgb4000000025277884'>
+			<osgb:point>
+				<gml:Point srsName='osgb:BNG'>
+					<gml:coordinates>280000.000,95000.000</gml:coordinates>
+				</gml:Point>
+			</osgb:point>
+			<osgb:referenceToTopographicArea xlink:href='#osgb1000002062025665' />
+		</osgb:RoadNode>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288017">
+			<osgb:descriptiveTerm>Private Road - Publicly Accessible</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>290000.000,90000.000 280000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277880" />
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277881" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288018">
+			<osgb:descriptiveTerm>Private Road - Publicly Accessible</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>280000.000,90000.000 270000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277881" />
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277882" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639"></osgb:referenceToTopographicArea>
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288019">
+			<osgb:descriptiveTerm>Private Road - Publicly Accessible</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>280000.000,85000.000 280000.000,90000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277883"></osgb:directedNode>
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277881" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:networkMember>
+		<osgb:RoadLink fid="osgb4000000025288020">
+			<osgb:descriptiveTerm>Private Road - Publicly Accessible</osgb:descriptiveTerm>
+			<osgb:natureOfRoad>Single Carriageway</osgb:natureOfRoad>
+			<osgb:length>538.90</osgb:length>
+			<osgb:polyline>
+				<gml:LineString srsName="osgb:BNG">
+					<gml:coordinates>280000.000,90000.000 280000.000,95000.000 </gml:coordinates>
+				</gml:LineString>
+			</osgb:polyline>
+			<osgb:directedNode orientation="-" xlink:href="#osgb4000000025277881" />
+			<osgb:directedNode orientation="+" xlink:href="#osgb4000000025277884" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010639" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062041282" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010640" />
+			<osgb:referenceToTopographicArea xlink:href="#osgb1000002062010474" />
+		</osgb:RoadLink>
+	</osgb:networkMember>
+	<osgb:roadInformationMember>
+		<osgb:RoadNodeInformation fid='osgb4000000025220155'>
+			<osgb:environmentQualifier>
+				<osgb:classification>Mini Roundabout</osgb:classification>
+			</osgb:environmentQualifier>
+			<osgb:referenceToRoadNode xlink:href='#osgb4000000025278486' />
+		</osgb:RoadNodeInformation>
+	</osgb:roadInformationMember>
+	<osgb:roadMember>
+		<osgb:Road fid='osgb4000000025366114'>
+			<osgb:descriptiveGroup>Named Road</osgb:descriptiveGroup>
+			<osgb:roadName>BONHAY ROAD</osgb:roadName>
+			<osgb:networkMember xlink:href='#osgb4000000025288017' />
+			<osgb:networkMember xlink:href='#osgb4000000025288018' />
+			<osgb:boundedBy>
+				<gml:Box srsName='osgb:BNG'>
+					<gml:coordinates>291211.000,92187.000 291549.000,93434.920</gml:coordinates>
+				</gml:Box>
+			</osgb:boundedBy>
+		</osgb:Road>
+	</osgb:roadMember>
+	<osgb:roadMember>
+		<osgb:Road fid='osgb4000000025366115'>
+			<osgb:descriptiveGroup>Named Road</osgb:descriptiveGroup>
+			<osgb:roadName>OTHER ROAD</osgb:roadName>
+			<osgb:networkMember xlink:href='#osgb4000000025288019' />
+			<osgb:networkMember xlink:href='#osgb4000000025288020' />
+			<osgb:boundedBy>
+				<gml:Box srsName='osgb:BNG'>
+					<gml:coordinates>291211.000,92187.000 291549.000,93434.920</gml:coordinates>
+				</gml:Box>
+			</osgb:boundedBy>
+		</osgb:Road>
+	</osgb:roadMember>
+	<osgb:boundedBy>
+		<gml:Box srsName='osgb:BNG'>
+			<gml:coordinates>290822.000,91912.000 293199.000,94222.000</gml:coordinates>
+		</gml:Box>
+	</osgb:boundedBy>
+</osgb:FeatureCollection>
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 40bcf716c4..20b73f871a 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -21,6 +21,10 @@
 import static javax.servlet.http.HttpServletResponse.SC_OK;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -28,117 +32,201 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.eclipse.jetty.http.HttpStatus;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.shapes.GHPoint;
+
 /**
  * @author Peter Karich
  */
-public class GHBaseServlet extends HttpServlet {
-    protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
-    @Inject
-    @Named("jsonpAllowed")
-    protected boolean jsonpAllowed;
-
-    protected void writeJson(HttpServletRequest req, HttpServletResponse res, JSONObject json) throws JSONException,
-            IOException {
-        String type = getParam(req, "type", "json");
-        res.setCharacterEncoding("UTF-8");
-        boolean debug = getBooleanParam(req, "debug", false) || getBooleanParam(req, "pretty", false);
-        if ("jsonp".equals(type)) {
-            res.setContentType("application/javascript");
-            if (!jsonpAllowed) {
-                writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
-                return;
-            }
-
-            String callbackName = getParam(req, "callback", null);
-            if (callbackName == null) {
-                writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
-                return;
-            }
-
-            if (debug)
-                writeResponse(res, callbackName + "(" + json.toString(2) + ")");
-            else
-                writeResponse(res, callbackName + "(" + json.toString() + ")");
-
-        } else {
-            res.setContentType("application/json");
-            if (debug)
-                writeResponse(res, json.toString(2));
-            else
-                writeResponse(res, json.toString());
-        }
-    }
-
-    protected void writeError(HttpServletResponse res, int code, String message) {
-        JSONObject json = new JSONObject();
-        json.put("message", message);
-        writeJsonError(res, code, json);
-    }
-
-    protected void writeJsonError(HttpServletResponse res, int code, JSONObject json) {
-        try {
-            // no type parameter check here as jsonp does not work if an error
-            // also no debug parameter yet
-            res.setContentType("application/json");
-            res.setCharacterEncoding("UTF-8");
-            res.setStatus(code);
-            res.getWriter().append(json.toString(2));
-        } catch (IOException ex) {
-            logger.error("Cannot write error " + ex.getMessage());
-        }
-    }
-
-    protected String getParam(HttpServletRequest req, String string, String _default) {
-        String[] l = req.getParameterMap().get(string);
-        if (l != null && l.length > 0)
-            return l[0];
-
-        return _default;
-    }
-
-    protected String[] getParams(HttpServletRequest req, String string) {
-        String[] l = req.getParameterMap().get(string);
-        if (l != null && l.length > 0) {
-            return l;
-        }
-        return new String[0];
-    }
-
-    protected long getLongParam(HttpServletRequest req, String string, long _default) {
-        try {
-            return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex) {
-            return _default;
-        }
-    }
-
-    protected boolean getBooleanParam(HttpServletRequest req, String string, boolean _default) {
-        try {
-            return Boolean.parseBoolean(getParam(req, string, "" + _default));
-        } catch (Exception ex) {
-            return _default;
-        }
-    }
-
-    protected double getDoubleParam(HttpServletRequest req, String string, double _default) {
-        try {
-            return Double.parseDouble(getParam(req, string, "" + _default));
-        } catch (Exception ex) {
-            return _default;
-        }
-    }
-
-    public void writeResponse(HttpServletResponse res, String str) {
-        try {
-            res.setStatus(SC_OK);
-            res.getWriter().append(str);
-        } catch (IOException ex) {
-            logger.error("Cannot write message:" + str, ex);
-        }
-    }
+public class GHBaseServlet extends HttpServlet
+{
+	protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
+	@Inject
+	@Named("jsonpAllowed")
+	protected boolean jsonpAllowed;
+
+	protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json )
+			throws JSONException, IOException
+	{
+		String type = getParam(req, "type", "json");
+		res.setCharacterEncoding("UTF-8");
+		boolean debug = getBooleanParam(req, "debug", false)
+				|| getBooleanParam(req, "pretty", false);
+		if ("jsonp".equals(type))
+		{
+			res.setContentType("application/javascript");
+			if (!jsonpAllowed)
+			{
+				writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+				return;
+			}
+
+			String callbackName = getParam(req, "callback", null);
+			if (callbackName == null)
+			{
+				writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
+				return;
+			}
+
+			if (debug)
+				writeResponse(res, callbackName + "(" + json.toString(2) + ")");
+			else
+				writeResponse(res, callbackName + "(" + json.toString() + ")");
+
+		} else
+		{
+			res.setContentType("application/json");
+			if (debug)
+				writeResponse(res, json.toString(2));
+			else
+				writeResponse(res, json.toString());
+		}
+	}
+
+	protected void writeError( HttpServletResponse res, int code, String message )
+	{
+		JSONObject json = new JSONObject();
+		json.put("message", message);
+		writeJsonError(res, code, json);
+	}
+
+	protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
+	{
+		try
+		{
+			// no type parameter check here as jsonp does not work if an error
+			// also no debug parameter yet
+			res.setContentType("application/json");
+			res.setCharacterEncoding("UTF-8");
+			res.setStatus(code);
+			res.getWriter().append(json.toString(2));
+		} catch (IOException ex)
+		{
+			logger.error("Cannot write error " + ex.getMessage());
+		}
+	}
+
+	protected String getParam( HttpServletRequest req, String string, String _default )
+	{
+		String[] l = req.getParameterMap().get(string);
+		if (l != null && l.length > 0)
+			return l[0];
+
+		return _default;
+	}
+
+	protected String[] getParams( HttpServletRequest req, String string )
+	{
+		String[] l = req.getParameterMap().get(string);
+		if (l != null && l.length > 0)
+		{
+			return l;
+		}
+		return new String[0];
+	}
+
+	protected long getLongParam( HttpServletRequest req, String string, long _default )
+	{
+		try
+		{
+			return Long.parseLong(getParam(req, string, "" + _default));
+		} catch (Exception ex)
+		{
+			return _default;
+		}
+	}
+
+	protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
+	{
+		try
+		{
+			return Boolean.parseBoolean(getParam(req, string, "" + _default));
+		} catch (Exception ex)
+		{
+			return _default;
+		}
+	}
+
+	protected double getDoubleParam( HttpServletRequest req, String string, double _default )
+	{
+		try
+		{
+			return Double.parseDouble(getParam(req, string, "" + _default));
+		} catch (Exception ex)
+		{
+			return _default;
+		}
+	}
+
+	protected List<GHPoint> getPoints( HttpServletRequest req, String key )
+			throws InvalidParameterException
+			{
+		String[] pointsAsStr = getParams(req, key);
+		final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
+		for (String str : pointsAsStr)
+		{
+			GHPoint point = GHPoint.parse(str);
+			if (point != null)
+			{
+				infoPoints.add(point);
+			} else
+			{
+				throw new InvalidParameterException(
+						"Point "
+								+ str
+								+ " is not a valid point. Point must be a comma separated coordinate in WGS84 projection.");
+			}
+		}
+
+		return infoPoints;
+			}
+
+	protected void processResponseErrors( GHResponse rsp, Map<String, Object> json,
+	        boolean internalErrorsAllowed )
+	{
+		if (rsp.hasErrors())
+		{
+			Map<String, String> map = new HashMap<String, String>();
+			json.put("error", map);
+			Throwable throwable = rsp.getErrors().get(0);
+			map.put("message", throwable.getMessage());
+			String statusCode = "" + HttpStatus.BAD_REQUEST_400;
+			if (throwable instanceof APIException)
+			{
+				statusCode = "" + ((APIException) throwable).getStatusCode().getCode();
+				logger.error("Unhandled exception, defaulting it to 400");
+			}
+			map.put("statuscode", statusCode);
+			List<Map<String, String>> list = new ArrayList<Map<String, String>>();
+			for (Throwable t : rsp.getErrors())
+			{
+				Map<String, String> hintMap = new HashMap<String, String>();
+				hintMap.put("message", t.getMessage());
+				if (internalErrorsAllowed)
+				{
+					hintMap.put("details", t.getClass().getName());
+				}
+				list.add(hintMap);
+			}
+			json.put("hints", list);
+		}
+	}
+
+	public void writeResponse( HttpServletResponse res, String str )
+	{
+		try
+		{
+			res.setStatus(SC_OK);
+			res.getWriter().append(str);
+		} catch (IOException ex)
+		{
+			logger.error("Cannot write message:" + str, ex);
+		}
+	}
 }
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index ec01d532ec..6057e8a0ee 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -17,59 +17,61 @@
  */
 package com.graphhopper.http;
 
-import com.google.inject.servlet.ServletModule;
-import com.graphhopper.util.CmdArgs;
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.inject.Singleton;
 
+import com.google.inject.servlet.ServletModule;
+import com.graphhopper.util.CmdArgs;
+
 /**
  * @author Peter Karich
  */
 public class GHServletModule extends ServletModule
 {
-    protected Map<String, String> params = new HashMap<String, String>();
-    protected final CmdArgs args;
+	protected Map<String, String> params = new HashMap<String, String>();
+	protected final CmdArgs args;
+
+	public GHServletModule( CmdArgs args )
+	{
+		this.args = args;
+		params.put("mimeTypes", "text/html," + "text/plain," + "text/xml,"
+				+ "application/xhtml+xml," + "text/css," + "application/json,"
+				+ "application/javascript," + "image/svg+xml");
+	}
+
+	@Override
+	protected void configureServlets()
+	{
+		filter("*").through(GHGZIPHook.class, params);
+		bind(GHGZIPHook.class).in(Singleton.class);
 
-    public GHServletModule( CmdArgs args )
-    {
-        this.args = args;
-        params.put("mimeTypes", "text/html,"
-                + "text/plain,"
-                + "text/xml,"
-                + "application/xhtml+xml,"
-                + "text/css,"
-                + "application/json,"
-                + "application/javascript,"
-                + "image/svg+xml");
-    }
+		filter("*").through(CORSFilter.class, params);
+		bind(CORSFilter.class).in(Singleton.class);
 
-    @Override
-    protected void configureServlets()
-    {
-        filter("*").through(GHGZIPHook.class, params);
-        bind(GHGZIPHook.class).in(Singleton.class);
+		filter("*").through(IPFilter.class);
+		bind(IPFilter.class).toInstance(
+				new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
 
-        filter("*").through(CORSFilter.class, params);
-        bind(CORSFilter.class).in(Singleton.class);
+		serve("/i18n","/i18n/").with(I18NServlet.class);
+		bind(I18NServlet.class).in(Singleton.class);
 
-        filter("*").through(IPFilter.class);
-        bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+		serve("/info","/info/").with(InfoServlet.class);
+		bind(InfoServlet.class).in(Singleton.class);
 
-        serve("/i18n*").with(I18NServlet.class);
-        bind(I18NServlet.class).in(Singleton.class);
+		serve("/route","/route/").with(GraphHopperServlet.class);
+		bind(GraphHopperServlet.class).in(Singleton.class);
 
-        serve("/info*").with(InfoServlet.class);
-        bind(InfoServlet.class).in(Singleton.class);
+		if (args.getBool("update.enable", true))
+		{
+			serve("/update*").with(UpdateServlet.class);
+			bind(UpdateServlet.class).in(Singleton.class);
+		}
+		serve("/nearest","/nearest/").with(NearestServlet.class);
+		bind(NearestServlet.class).in(Singleton.class);
 
-        serve("/route*").with(GraphHopperServlet.class);
-        bind(GraphHopperServlet.class).in(Singleton.class);
-        
-        if(args.getBool("update.enable", true)) {
-        	serve("/update*").with(UpdateServlet.class);
-        	bind(UpdateServlet.class).in(Singleton.class);
-        }
-        serve("/nearest*").with(NearestServlet.class);
-        bind(NearestServlet.class).in(Singleton.class);
-    }
+//		serve("/*").with(InvalidRequestServlet.class);
+//		bind(InvalidRequestServlet.class).in(Singleton.class);
+	}
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 6ea99ccb2c..7e9067b6ff 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -41,7 +41,7 @@
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
 
-import org.eclipse.jetty.http.HttpStatus;
+import org.json.JSONException;
 import org.json.JSONObject;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -75,408 +75,384 @@
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
-	@Inject
-	private GraphHopper hopper;
-
-	@Named("internalErrorsAllowed")
-	private boolean internalErrorsAllowed;
-
-	@Override
-	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
-	        throws ServletException, IOException
-	{
-
-		boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
-		double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
-		boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
-		boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
-		boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
-		boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
-
-		String vehicleStr = getParam(httpReq, "vehicle", null);
-		String weighting = getParam(httpReq, "weighting", "fastest");
-		String algoStr = getParam(httpReq, "algorithm", null);
-		String localeStr = getParam(httpReq, "locale", "en_GB").replace('-', '_');
-
-		StopWatch sw = new StopWatch().start();
-		GHResponse ghRsp = null;
-
-		String instructionsString = getParam(httpReq, "instructions", "true");
-		String pointsEncodedString = getParam(httpReq, "points_encoded", "true");
-		String calcPointsString = getParam(httpReq, "calc_points", "true");
-		String debugString = getParam(httpReq, "debug", "true");
-		String prettyString = getParam(httpReq, "pretty", "true");
-		String avoidancesString = getParam(httpReq, "avoidances", null);
-		List<GHPoint> infoPoints = null;
-		try
-		{
-			ApiResource.ROUTE.checkAllRequestParameters(httpReq);
-
-			infoPoints = getPoints(httpReq, "point");
-
-			// we can reduce the path length based on the maximum differences to the original
-			// coordinates
-
-			if (!new CaseInsensitiveStringListValidator()
-			        .isValid(localeStr, TranslationMap.LOCALES))
-			{
-				String errMesg = buildErrorMessageString(localeStr, "locale",
-				        TranslationMap.LOCALES);
-				ghRsp = new GHResponse()
-				.addError(new InvalidParameterException(errMesg.toString()));
-			} else if (null != algoStr
-					&& !new CaseInsensitiveStringListValidator().isValid(algoStr,
-							AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
-							AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
-							AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
-			{
-				String errMesg = buildErrorMessageString(algoStr, "algorithm",
-				        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
-				        AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
-				        AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(instructionsString))
-			{
-				String errMesg = buildBooleanErrorMessageString(instructionsString, "instructions");
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(pointsEncodedString))
-			{
-				String errMesg = buildBooleanErrorMessageString(pointsEncodedString,
-				        "points_encoded");
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(calcPointsString))
-			{
-				String errMesg = buildBooleanErrorMessageString(calcPointsString, "calc_points");
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(debugString))
-			{
-				String errMesg = buildBooleanErrorMessageString(debugString, "debug");
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(prettyString))
-			{
-				String errMesg = buildBooleanErrorMessageString(prettyString, "pretty");
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!hopper.getEncodingManager().supports(vehicleStr))
-			{
-				String supported = hopper.getGraph().getEncodingManager().toString();
-				String errMesg = String.format(
-				        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
-				        supported);
-				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (enableElevation && !hopper.hasElevation())
-			{
-				ghRsp = new GHResponse().addError(new InvalidParameterException(
-				        "Elevation not supported!"));
-			} else
-			{
-				FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-
-				// Lots of lovely braces. I will tidy this up next week... promise!
-				if (avoidancesString != null)
-				{
-					List<String> allowedAvoidances = new ArrayList<>();
-					// Check Avoidances
-					if (algoVehicle instanceof AbstractFlagEncoder)
-					{
-						AbstractFlagEncoder abstractFlagEncoder = (AbstractFlagEncoder) algoVehicle;
-						List<EncoderDecorator> encoderDecorators = abstractFlagEncoder
-						        .getEncoderDecorators();
-						if (encoderDecorators != null)
-						{
-							for (EncoderDecorator encoderDecorator : encoderDecorators)
-							{
-								if (encoderDecorator instanceof AbstractAvoidanceDecorator)
-								{
-									AbstractAvoidanceDecorator abstractAvoidanceDecorator = (AbstractAvoidanceDecorator) encoderDecorator;
-									allowedAvoidances.addAll(Arrays
-									        .asList(abstractAvoidanceDecorator
-									                .getEdgeAttributesOfInterestNames()));
-								}
-							}
-						}
-					}
-					String avoidanceArray[] = avoidancesString.split(",");
-					for (String avoidance : avoidanceArray)
-					{
-						if (!allowedAvoidances.contains(avoidance.trim()))
-						{
-							String errMesg = buildErrorMessageString(avoidance, "avoidances",
-									allowedAvoidances);
-							ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg
-									.toString()));
-						}
-					}
-				}
-
-				if (ghRsp == null)
-				{
-					GHRequest request = new GHRequest(infoPoints);
-
-					initHints(request, httpReq.getParameterMap());
-					request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
-					        .setAlgorithm(algoStr).setLocale(localeStr).getHints()
-					        .put("calcPoints", calcPoints).put("instructions", enableInstructions)
-					        .put("wayPointMaxDistance", minPathPrecision);
-					ghRsp = hopper.route(request);
-				}
-			}
-		} catch (NoSuchParameterException | MissingParameterException | InvalidParameterException e)
-		{
-			ghRsp = new GHResponse().addError(e);
-		}
-		float took = sw.stop().getSeconds();
-		String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
-		        + httpReq.getHeader("User-Agent");
-		String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
-		        + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
-
-		if (ghRsp.hasErrors())
-			logger.error(logStr + ", errors:" + ghRsp.getErrors());
-		else
-			logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
-			        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
-			        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
-
-		if (writeGPX)
-		{
-			String xml = createGPXString(httpReq, httpRes, ghRsp);
-			if (ghRsp.hasErrors())
-			{
-				httpRes.setStatus(SC_BAD_REQUEST);
-				httpRes.getWriter().append(xml);
-			} else
-				writeResponse(httpRes, xml);
-		} else
-		{
-			String type = getParam(httpReq, "type", "json");
-			if (!"json".equalsIgnoreCase(type) || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
-			{
-				String errorMessage = type
-				        + " is not a valid value for parameter type. Valid values are ";
-				errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
-				ghRsp.addError(new InvalidParameterException(errorMessage));
-			}
-			Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation,
-			        enableInstructions);
-			Object infoMap = map.get("info");
-			if (infoMap != null)
-				((Map) infoMap).put("took", Math.round(took * 1000));
-
-			if (ghRsp.hasErrors())
-			{
-				writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
-			} else
-				writeJson(httpReq, httpRes, new JSONObject(map));
-		}
-	}
-
-	private String buildBooleanErrorMessageString( String paramValue, String paramName )
-	{
-		return buildErrorMessageString(paramValue, paramName,
-		        Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
-	}
-
-	private String buildErrorMessageString( String paramValue, String paramName,
-	        String... validValues )
-	{
-		return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
-	}
-
-	private String buildErrorMessageString( String paramValue, String paramName,
-	        List<String> validValues )
-	{
-		StringBuilder errMesg = new StringBuilder(paramValue)
-		        .append(" is not a valid value for parameter ").append(paramName)
-		        .append(". Valid values are ");
-		for (int i = 0; i < validValues.size(); i++)
-		{
-			String validStr = validValues.get(i);
-			if (i == validValues.size() - 1)
-			{
-				errMesg.append(" or ");
-			}
-			errMesg.append(validStr);
-			if (i < validValues.size() - 2)
-			{
-				errMesg.append(", ");
-			}
-		}
-		return errMesg.toString();
-	}
-
-	protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
-	        GHResponse rsp )
-	{
-		boolean includeElevation = getBooleanParam(req, "elevation", false);
-		res.setCharacterEncoding("UTF-8");
-		res.setContentType("application/xml");
-		String trackName = getParam(req, "track", "GraphHopper Track");
-		res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-		long time = getLongParam(req, "millis", System.currentTimeMillis());
-		if (rsp.hasErrors())
-			return errorsToXML(rsp.getErrors());
-		else
-			return rsp.getInstructions().createGPX(trackName, time, includeElevation);
-	}
-
-	String errorsToXML( List<Throwable> list )
-	{
-		try
-		{
-			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-			DocumentBuilder builder = factory.newDocumentBuilder();
-			Document doc = builder.newDocument();
-			Element gpxElement = doc.createElement("gpx");
-			gpxElement.setAttribute("creator", "GraphHopper");
-			gpxElement.setAttribute("version", "1.1");
-			doc.appendChild(gpxElement);
-
-			Element mdElement = doc.createElement("metadata");
-			gpxElement.appendChild(mdElement);
-
-			Element extensionsElement = doc.createElement("extensions");
-			mdElement.appendChild(extensionsElement);
-
-			Element messageElement = doc.createElement("message");
-			extensionsElement.appendChild(messageElement);
-			messageElement.setTextContent(list.get(0).getMessage());
-
-			Element hintsElement = doc.createElement("hints");
-			extensionsElement.appendChild(hintsElement);
-
-			for (Throwable t : list)
-			{
-				Element error = doc.createElement("error");
-				hintsElement.appendChild(error);
-				error.setAttribute("message", t.getMessage());
-				if (internalErrorsAllowed)
-				{
-					error.setAttribute("details", t.getClass().getName());
-				}
-			}
-			TransformerFactory transformerFactory = TransformerFactory.newInstance();
-			Transformer transformer = transformerFactory.newTransformer();
-			StringWriter writer = new StringWriter();
-			transformer.transform(new DOMSource(doc), new StreamResult(writer));
-			return writer.toString();
-		} catch (Exception ex)
-		{
-			throw new RuntimeException(ex);
-		}
-	}
-
-	protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
-	        boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
-	{
-		Map<String, Object> json = new HashMap<String, Object>();
-
-		if (rsp.hasErrors())
-		{
-			Map<String, String> map = new HashMap<String, String>();
-			json.put("error", map);
-			Throwable throwable = rsp.getErrors().get(0);
-			map.put("message", throwable.getMessage());
-			String statusCode = "" + HttpStatus.BAD_REQUEST_400;
-			if (throwable instanceof APIException)
-			{
-				statusCode = "" + ((APIException) throwable).getStatusCode().getCode();
-				logger.error("Unhandled exception, defaulting it to 400");
-			}
-			map.put("statuscode", statusCode);
-			List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-			for (Throwable t : rsp.getErrors())
-			{
-				Map<String, String> hintMap = new HashMap<String, String>();
-				hintMap.put("message", t.getMessage());
-				if (internalErrorsAllowed)
-				{
-					hintMap.put("details", t.getClass().getName());
-				}
-				list.add(hintMap);
-			}
-			json.put("hints", list);
-		} else
-		{
-			Map<String, Object> jsonInfo = new HashMap<String, Object>();
-			json.put("info", jsonInfo);
-			// jsonInfo.put("copyrights", Arrays.asList("GraphHopper",
-			// "OpenStreetMap contributors"));
-			Map<String, Object> jsonPath = new HashMap<String, Object>();
-			jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-			jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-			jsonPath.put("time", rsp.getTime());
-
-			if (calcPoints)
-			{
-				jsonPath.put("points_encoded", pointsEncoded);
-
-				PointList points = rsp.getPoints();
-				if (points.getSize() >= 2)
-				{
-					BBox maxBounds = hopper.getGraph().getBounds();
-					BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
-					        maxBounds.minLat, maxBounds.maxLat);
-					jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
-				}
-
-				jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-				if (enableInstructions)
-				{
-					InstructionList instructions = rsp.getInstructions();
-					jsonPath.put("instructions", instructions.createJson());
-				}
-			}
-			json.put("paths", Collections.singletonList(jsonPath));
-		}
-		return json;
-	}
-
-	protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-	{
-		if (pointsEncoded)
-			return WebHelper.encodePolyline(points, includeElevation);
-
-		Map<String, Object> jsonPoints = new HashMap<String, Object>();
-		jsonPoints.put("type", "LineString");
-		jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-		return jsonPoints;
-	}
-
-	protected List<GHPoint> getPoints( HttpServletRequest req, String key )
-			throws InvalidParameterException
-			{
-		String[] pointsAsStr = getParams(req, key);
-		final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
-		for (String str : pointsAsStr)
-		{
-			String[] fromStrs = str.split(",");
-			if (fromStrs.length == 2)
-			{
-				GHPoint point = GHPoint.parse(str);
-				if (point != null)
-				{
-					infoPoints.add(point);
-				}
-			} else
-			{
-				throw new InvalidParameterException(
-						"Point "
-								+ str
-								+ " is not a valid point. Point must be a comma separated coordinate in WGS84 projection.");
-			}
-		}
-
-		return infoPoints;
-			}
-
-	protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
-	{
-		WeightingMap m = request.getHints();
-		for (Entry<String, String[]> e : parameterMap.entrySet())
-		{
-			if (e.getValue().length == 1)
-				m.put(e.getKey(), e.getValue()[0]);
-		}
-	}
+    private static final long serialVersionUID = 1L;
+
+    @Inject
+    private GraphHopper hopper;
+
+    @Inject
+    @Named("internalErrorsAllowed")
+    private boolean internalErrorsAllowed;
+
+    @Override
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
+            throws ServletException, IOException
+    {
+        getGHResponse(httpReq, httpRes);
+    }
+
+    public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse httpRes )
+            throws JSONException, IOException
+    {
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
+        boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
+
+        String vehicleStr = getParam(httpReq, "vehicle", null);
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", null);
+        String localeStr = getParam(httpReq, "locale", "en").replace('-', '_');
+
+        StopWatch sw = new StopWatch().start();
+
+        String instructionsString = getParam(httpReq, "instructions", "true");
+        String pointsEncodedString = getParam(httpReq, "points_encoded", "true");
+        String calcPointsString = getParam(httpReq, "calc_points", "true");
+        String debugString = getParam(httpReq, "debug", "true");
+        String prettyString = getParam(httpReq, "pretty", "true");
+        String avoidancesString = getParam(httpReq, "avoidances", null);
+
+        GHResponse ghRsp = null;
+        List<GHPoint> infoPoints;
+
+        try
+        {
+            infoPoints = getPoints(httpReq, "point");
+        } catch (InvalidParameterException e)
+        {
+            return new GHResponse().addError(e);
+        }
+
+        try
+        {
+            ApiResource.ROUTE.checkAllRequestParameters(httpReq);
+
+            // we can reduce the path length based on the maximum differences to the original
+            // coordinates
+
+            if (!new CaseInsensitiveStringListValidator()
+                    .isValid(localeStr, TranslationMap.LOCALES))
+            {
+                String errMesg = buildErrorMessageString(localeStr, "locale",
+                        TranslationMap.LOCALES);
+                ghRsp = new GHResponse()
+                        .addError(new InvalidParameterException(errMesg.toString()));
+            } else if (null != algoStr
+                    && !new CaseInsensitiveStringListValidator().isValid(algoStr,
+                            AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+                            AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+                            AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
+            {
+                String errMesg = buildErrorMessageString(algoStr, "algorithm",
+                        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+                        AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+                        AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!new BooleanValidator().isValid(instructionsString))
+            {
+                String errMesg = buildBooleanErrorMessageString(instructionsString, "instructions");
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!new BooleanValidator().isValid(pointsEncodedString))
+            {
+                String errMesg = buildBooleanErrorMessageString(pointsEncodedString,
+                        "points_encoded");
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!new BooleanValidator().isValid(calcPointsString))
+            {
+                String errMesg = buildBooleanErrorMessageString(calcPointsString, "calc_points");
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!new BooleanValidator().isValid(debugString))
+            {
+                String errMesg = buildBooleanErrorMessageString(debugString, "debug");
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!new BooleanValidator().isValid(prettyString))
+            {
+                String errMesg = buildBooleanErrorMessageString(prettyString, "pretty");
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (!hopper.getEncodingManager().supports(vehicleStr))
+            {
+                String supported = hopper.getGraph().getEncodingManager().toString();
+                String errMesg = String.format(
+                        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
+                        supported);
+                ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
+            } else if (enableElevation && !hopper.hasElevation())
+            {
+                ghRsp = new GHResponse().addError(new InvalidParameterException(
+                        "Elevation not supported!"));
+            } else
+            {
+                FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
+
+                // Lots of lovely braces. I will tidy this up next week... promise!
+                if (avoidancesString != null)
+                {
+                    List<String> allowedAvoidances = new ArrayList<>();
+                    // Check Avoidances
+                    if (algoVehicle instanceof AbstractFlagEncoder)
+                    {
+                        AbstractFlagEncoder abstractFlagEncoder = (AbstractFlagEncoder) algoVehicle;
+                        List<EncoderDecorator> encoderDecorators = abstractFlagEncoder
+                                .getEncoderDecorators();
+                        if (encoderDecorators != null)
+                        {
+                            for (EncoderDecorator encoderDecorator : encoderDecorators)
+                            {
+                                if (encoderDecorator instanceof AbstractAvoidanceDecorator)
+                                {
+                                    AbstractAvoidanceDecorator abstractAvoidanceDecorator = (AbstractAvoidanceDecorator) encoderDecorator;
+                                    allowedAvoidances.addAll(Arrays
+                                            .asList(abstractAvoidanceDecorator
+                                                    .getEdgeAttributesOfInterestNames()));
+                                }
+                            }
+                        }
+                    }
+                    String avoidanceArray[] = avoidancesString.split(",");
+                    for (String avoidance : avoidanceArray)
+                    {
+                        if (!allowedAvoidances.contains(avoidance.trim()))
+                        {
+                            String errMesg = buildErrorMessageString(avoidance, "avoidances",
+                                    allowedAvoidances);
+                            ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg
+                                    .toString()));
+                        }
+                    }
+                }
+
+                if (ghRsp == null)
+                {
+                    GHRequest request = new GHRequest(infoPoints);
+
+                    initHints(request, httpReq.getParameterMap());
+                    request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
+                            .setAlgorithm(algoStr).setLocale(localeStr).getHints()
+                            .put("calcPoints", calcPoints).put("instructions", enableInstructions)
+                            .put("wayPointMaxDistance", minPathPrecision);
+                    ghRsp = hopper.route(request);
+                }
+            }
+        } catch (NoSuchParameterException | MissingParameterException | InvalidParameterException e)
+        {
+            ghRsp = new GHResponse().addError(e);
+        } finally
+        {
+
+            float took = sw.stop().getSeconds();
+            String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
+                    + httpReq.getHeader("User-Agent");
+            String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+                    + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+
+            if (ghRsp.hasErrors())
+                logger.error(logStr + ", errors:" + ghRsp.getErrors());
+            else
+                logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
+                        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
+                        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
+
+            if (writeGPX)
+            {
+                String xml = createGPXString(httpReq, httpRes, ghRsp);
+                if (ghRsp.hasErrors())
+                {
+                    httpRes.setStatus(SC_BAD_REQUEST);
+                    httpRes.getWriter().append(xml);
+                } else
+                    writeResponse(httpRes, xml);
+            } else
+            {
+                String type = getParam(httpReq, "type", "json");
+                if (!"json".equalsIgnoreCase(type)
+                        || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
+                {
+                    String errorMessage = type
+                            + " is not a valid value for parameter type. Valid values are ";
+                    errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
+                    ghRsp.addError(new InvalidParameterException(errorMessage));
+                }
+                Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded,
+                        enableElevation, enableInstructions);
+                Object infoMap = map.get("info");
+                if (infoMap != null)
+                    ((Map) infoMap).put("took", Math.round(took * 1000));
+
+                if (ghRsp.hasErrors())
+                {
+                    writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+                } else
+                    writeJson(httpReq, httpRes, new JSONObject(map));
+
+            }
+
+        }
+
+        return ghRsp;
+    }
+
+    private String buildBooleanErrorMessageString( String paramValue, String paramName )
+    {
+        return buildErrorMessageString(paramValue, paramName,
+                Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
+    }
+
+    private String buildErrorMessageString( String paramValue, String paramName,
+            String... validValues )
+    {
+        return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
+    }
+
+    private String buildErrorMessageString( String paramValue, String paramName,
+            List<String> validValues )
+    {
+        StringBuilder errMesg = new StringBuilder(paramValue)
+                .append(" is not a valid value for parameter ").append(paramName)
+                .append(". Valid values are ");
+        for (int i = 0; i < validValues.size(); i++)
+        {
+            String validStr = validValues.get(i);
+            if (i == validValues.size() - 1)
+            {
+                errMesg.append(" or ");
+            }
+            errMesg.append(validStr);
+            if (i < validValues.size() - 2)
+            {
+                errMesg.append(", ");
+            }
+        }
+        return errMesg.toString();
+    }
+
+    protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
+            GHResponse rsp )
+    {
+        boolean includeElevation = getBooleanParam(req, "elevation", false);
+        res.setCharacterEncoding("UTF-8");
+        res.setContentType("application/xml");
+        String trackName = getParam(req, "track", "GraphHopper Track");
+        res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
+        long time = getLongParam(req, "millis", System.currentTimeMillis());
+        if (rsp.hasErrors())
+            return errorsToXML(rsp.getErrors());
+        else
+            return rsp.getInstructions().createGPX(trackName, time, includeElevation);
+    }
+
+    private String errorsToXML( List<Throwable> list )
+    {
+        try
+        {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
+
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
+
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
+
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(list.get(0).getMessage());
+
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
+
+            for (Throwable t : list)
+            {
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                if (internalErrorsAllowed)
+                {
+                    error.setAttribute("details", t.getClass().getName());
+                }
+            }
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            StringWriter writer = new StringWriter();
+            transformer.transform(new DOMSource(doc), new StreamResult(writer));
+            return writer.toString();
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
+            boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
+    {
+        Map<String, Object> json = new HashMap<String, Object>();
+
+        if (rsp.hasErrors())
+        {
+            processResponseErrors(rsp, json, internalErrorsAllowed);
+
+        } else
+        {
+            Map<String, Object> jsonInfo = new HashMap<String, Object>();
+            json.put("info", jsonInfo);
+            // jsonInfo.put("copyrights", Arrays.asList("GraphHopper",
+            // "OpenStreetMap contributors"));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+            jsonPath.put("time", rsp.getTime());
+
+            if (calcPoints)
+            {
+                jsonPath.put("points_encoded", pointsEncoded);
+
+                PointList points = rsp.getPoints();
+                if (points.getSize() >= 2)
+                {
+                    BBox maxBounds = hopper.getGraph().getBounds();
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
+                            maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
+
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+                if (enableInstructions)
+                {
+                    InstructionList instructions = rsp.getInstructions();
+                    jsonPath.put("instructions", instructions.createJson());
+                }
+            }
+            json.put("paths", Collections.singletonList(jsonPath));
+        }
+        return json;
+    }
+
+    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+    {
+        if (pointsEncoded)
+            return WebHelper.encodePolyline(points, includeElevation);
+
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
+        jsonPoints.put("type", "LineString");
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+        return jsonPoints;
+    }
+
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    {
+        WeightingMap m = request.getHints();
+        for (Entry<String, String[]> e : parameterMap.entrySet())
+        {
+            if (e.getValue().length == 1)
+                m.put(e.getKey(), e.getValue()[0]);
+        }
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index 8de227530b..384de89945 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -15,20 +15,33 @@
  */
 package com.graphhopper.http;
 
-import org.json.JSONObject;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
+
+import org.json.JSONObject;
 
 public class InvalidRequestServlet extends GHBaseServlet
 {
-    @Override
-    protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
-        JSONObject json = new JSONObject();
-        json.put("message", "Not found");
-        writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
-    }
-}
+	@Override
+	protected void service( HttpServletRequest req, HttpServletResponse res )
+			throws ServletException, IOException
+	{
+		String resource = req.getRequestURI();
+		if (resource.startsWith("/") && resource.length() > 1)
+		{
+			resource = resource.substring(1, resource.length());
+		}
+		JSONObject json = new JSONObject();
+		Map<String, Object> map = new HashMap<>();
+		map.put("statuscode", "" + HttpServletResponse.SC_NOT_FOUND);
+		map.put("message", "Resource " + resource
+				+ " does not exist. Valid resources are route, nearest.");
+		json.put("error", map);
+		writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
+	}
+}
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
index 5696fce229..0d55b97015 100644
--- a/web/src/main/java/com/graphhopper/http/NearestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,6 +17,23 @@
  */
 package com.graphhopper.http;
 
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
@@ -25,62 +42,75 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-import org.json.JSONArray;
-import org.json.JSONObject;
-
-import javax.inject.Inject;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
 
 /**
  * @author svantulden
  */
 public class NearestServlet extends GHBaseServlet
 {
-    @Inject
-    private GraphHopper hopper;
-    private final DistanceCalc calc = Helper.DIST_EARTH;
-
-    @Override
-    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
-    {
-        String pointStr = getParam(httpReq, "point", null);
-        boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
-
-        JSONObject result = new JSONObject();
-        if (pointStr != null && !pointStr.equalsIgnoreCase(""))
-        {
-            GHPoint place = GHPoint.parse(pointStr);
-            LocationIndex index = hopper.getLocationIndex();
-            QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
-
-            if (!qr.isValid())
-            {
-                result.put("error", "Nearest point cannot be found!");
-            } else
-            {
-                GHPoint3D snappedPoint = qr.getSnappedPoint();
-                result.put("type", "Point");
-
-                JSONArray coord = new JSONArray();
-                coord.put(snappedPoint.lon);
-                coord.put(snappedPoint.lat);
-
-                if (hopper.hasElevation() && enabledElevation)
-                    coord.put(snappedPoint.ele);
-
-                result.put("coordinates", coord);
-
-                // Distance from input to snapped point in meters
-                result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
-            }
-        } else
-        {
-            result.put("error", "No lat/lon specified!");
-        }
-
-        writeJson(httpReq, httpRes, result);
-    }
+	@Inject
+	private GraphHopper hopper;
+
+	@Named("internalErrorsAllowed")
+	private boolean internalErrorsAllowed;
+
+	private final DistanceCalc calc = Helper.DIST_EARTH;
+
+	@Override
+	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
+	        throws ServletException, IOException
+	{
+		GHResponse ghRsp = null;
+		Map<String, Object> map = new HashMap<>();
+		try
+		{
+			ApiResource.NEAREST.checkAllRequestParameters(httpReq);
+
+			List<GHPoint> infoPoints = getPoints(httpReq, "point");
+			if (infoPoints.size() > 1)
+			{
+				throw new InvalidParameterException(
+				        "Only one point should be specified and it must be a comma separated coordinate in WGS84 projection.");
+			}
+
+			boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
+
+			GHPoint place = infoPoints.get(0);
+			LocationIndex index = hopper.getLocationIndex();
+			QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
+			if (!qr.isValid())
+			{
+				map.put("error", "Nearest point cannot be found!");
+			} else
+			{
+				GHPoint3D snappedPoint = qr.getSnappedPoint();
+				map.put("type", "Point");
+
+				JSONArray coord = new JSONArray();
+				coord.put(snappedPoint.lon);
+				coord.put(snappedPoint.lat);
+
+				if (hopper.hasElevation() && enabledElevation)
+					coord.put(snappedPoint.ele);
+
+				map.put("coordinates", coord);
+
+				// Distance from input to snapped point in meters
+				map.put("distance",
+				        calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
+			}
+		} catch (NoSuchParameterException | MissingParameterException | InvalidParameterException e)
+		{
+			ghRsp = new GHResponse().addError(e);
+		}
+
+		if (ghRsp == null || ghRsp.hasErrors())
+		{
+			processResponseErrors(ghRsp, map, internalErrorsAllowed);
+			writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+		} else
+		{
+			writeJson(httpReq, httpRes, new JSONObject(map));
+		}
+	}
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletTest.java
index 078a564293..6d06064440 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletTest.java
@@ -1,38 +1,637 @@
 package com.graphhopper.http;
 
 import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.google.inject.AbstractModule;
+import com.google.inject.Guice;
+import com.google.inject.Injector;
+import com.google.inject.name.Names;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.AbstractAvoidanceDecorator;
+import com.graphhopper.routing.util.AbstractFlagEncoder;
+import com.graphhopper.routing.util.EncoderDecorator;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphStorage;
 
 public class GraphHopperServletTest
 {
 
-	ApiResource apiResource = ApiResource.ROUTE;
+    private Injector injector;
+
+    @Mock
+    HttpServletRequest httpServletRequest;
+
+    @Mock
+    HttpServletResponse httpServletResponse;
+
+    Map<String, String[]> allParameters;
+
+    GraphHopperServlet graphHopperServlet;
+
+    GHResponse value = new GHResponse();
+
+    @Mock
+    private GraphHopper graphHopper;
+
+    @Mock
+    private EncodingManager encodingManager;
+
+    @Mock
+    private AbstractFlagEncoder flagEncoder;
+
+    @Mock
+    private GraphStorage graphStorage;
+
+    @Mock
+    private List<EncoderDecorator> encoderDecorators;
+
+    @Mock
+    private Iterator<EncoderDecorator> iterator;
+
+    @Mock
+    private AbstractAvoidanceDecorator abstractAvoidanceDecorator;
+
+    private final String[] POINTS = { "50.728198,-3.534516", "50.726807,-3.530156" };
+    private final String UNPARSABLE_POINT = "50A.45";
+
+    private final String[] LOCALES = { "bg", "ca", "cz", "de_DE", "el", "en_US", "es", "fa", "fil",
+            "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "ne", "nl", "pl_PL", "pt_BR", "pt_PT",
+            "ro", "ru", "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN", "en_GB" };
+    private final String WRONG_LOCALE = "kl_KL";
+
+    private final String[] ALGORITHMS = { AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+            AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+            AlgorithmOptions.DIJKSTRA_ONE_TO_MANY };
+    private final String WRONG_ALGORITHM = "dekker";
+
+    private final String[] VEHICLES = { "car", "bike", "foot" };
+    private final String WRONG_VEHICLE = "flying_carpet";
+
+    private final String[] INSTRUCTIONS = { "false" }, POINTS_ENCODED = { "true", "false" },
+            DEBUG = { "true", "false" }, PRETTY = { "true", "false" }, CALC_POINTS = { "true",
+                    "false" };
+    private final String WRONG_INSTRUCTION = "uncertain";
+    private final String WRONG_POINTS_ENCODED = "uncertain";
+    private final String WRONG_DEBUG = "uncertain";
+    private final String WRONG_PRETTY = "uncertain";
+    private final String WRONG_CALC_POINTS = "uncertain";
+
+    private final String[] WEIGHTINGS = { "fastest", "shortest" };
+    private final String WRONG_WEIGHTING = "slowest";
+
+    private final String[] AVOIDANCES = { "aroad", "boulders", "cliff", "inlandwater", "marsh",
+            "quarryorpit", "scree", "rock", "mud", "sand", "shingle", "spoil", "tidalwater" };
+    private final String WRONG_AVOIDANCE = "zxcv";
+
+    private final String[] TYPES = { "json" };
+    private final String WRONG_TYPE = "pdf";
+
+    @Before
+    public void setUp() throws Exception
+    {
+        MockitoAnnotations.initMocks(this);
+        injector = Guice.createInjector(new AbstractModule()
+        {
+            @Override
+            protected void configure()
+            {
+                bind(GraphHopper.class).toInstance(graphHopper);
+                bind(Boolean.class).annotatedWith(Names.named("internalErrorsAllowed")).toInstance(
+                        false);
+                bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(false);
+            }
+        });
+
+        graphHopperServlet = injector.getInstance(GraphHopperServlet.class);
+        when(httpServletResponse.getWriter()).thenReturn(mock(PrintWriter.class));
+        allParameters = new HashMap<>();
+        when(graphHopper.getEncodingManager()).thenReturn(encodingManager);
+        when(graphHopper.hasElevation()).thenReturn(false);
+
+        when(encodingManager.supports(anyString())).thenReturn(true);
+        when(encodingManager.getEncoder(anyString())).thenReturn(flagEncoder);
+        when(flagEncoder.toString()).thenReturn("unknown");
+
+        when(graphHopper.route(any(GHRequest.class))).thenReturn(value);
+
+    }
+
+    @After
+    public void tearDown() throws Exception
+    {
+        injector = null;
+    }
+
+    private String buildErrorMessageString( String paramValue, String paramName,
+            List<String> validValues )
+    {
+        StringBuilder errMesg = new StringBuilder(paramValue)
+                .append(" is not a valid value for parameter ").append(paramName)
+                .append(". Valid values are ");
+        for (int i = 0; i < validValues.size(); i++)
+        {
+            String validStr = validValues.get(i);
+            if (i == validValues.size() - 1)
+            {
+                errMesg.append(" or ");
+            }
+            errMesg.append(validStr);
+            if (i < validValues.size() - 2)
+            {
+                errMesg.append(", ");
+            }
+        }
+        return errMesg.toString();
+    }
+
+    private String buildErrorMessageString( String paramValue, String paramName,
+            String... validValues )
+    {
+        return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
+    }
+
+    @Test
+    public void statusCodeForCorrectParameters() throws ServletException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        graphHopperServlet.doGet(httpServletRequest, httpServletResponse);
+        verify(httpServletResponse, never()).setStatus(SC_BAD_REQUEST);
+    }
+
+    @Test
+    public void testGetGHResponseWithValidPoints() throws IOException, MissingParameterException,
+            NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                .hasErrors());
+    }
+
+    @Test
+    public void testGetGHResponseWithUnparsablePoint() throws IOException,
+            MissingParameterException, NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", new String[] { UNPARSABLE_POINT });
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(
+                "Point "
+                        + UNPARSABLE_POINT
+                        + " is not a valid point. Point must be a comma separated coordinate in WGS84 projection.",
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectLocales() throws IOException,
+            MissingParameterException, NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+        for (String locale : LOCALES)
+        {
+            allParameters.put("locale", new String[] { locale });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithWrongLocale() throws IOException, MissingParameterException,
+            NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { WRONG_LOCALE });
+        allParameters.put("instructions", new String[] { "false" });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(buildErrorMessageString(WRONG_LOCALE, "locale", LOCALES), graphHopperServlet
+                .getGHResponse(httpServletRequest, httpServletResponse).getErrors().get(0)
+                .getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectAlgorithms() throws IOException,
+            MissingParameterException, NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String algorithm : ALGORITHMS)
+        {
+            allParameters.put("algorithm", new String[] { algorithm });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithWrongAlgorithm() throws IOException,
+            MissingParameterException, NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("algorithm", new String[] { WRONG_ALGORITHM });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(buildErrorMessageString(WRONG_ALGORITHM, "algorithm", ALGORITHMS),
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectTypes() throws IOException, MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, ServletException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String type : TYPES)
+        {
+            allParameters.put("type", new String[] { type });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithWrongType() throws IOException, MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, ServletException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("type", new String[] { WRONG_TYPE });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(WRONG_TYPE
+                + " is not a valid value for parameter type. Valid values are GPX or JSON.",
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectVehicles() throws IOException,
+            MissingParameterException, NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                .hasErrors());
+    }
+
+    @Test
+    public void testGetGHResponseWithWrongVehicle() throws IOException, MissingParameterException,
+            NoSuchParameterException, InvalidParameterException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { WRONG_VEHICLE });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        when(graphHopper.getGraph()).thenReturn(graphStorage);
+        when(graphStorage.getEncodingManager()).thenReturn(encodingManager);
+        when(encodingManager.supports(anyString())).thenReturn(false);
+        when(encodingManager.toString()).thenReturn("*supported vehicles*");
+
+        GHResponse ghResponse = graphHopperServlet.getGHResponse(httpServletRequest,
+                httpServletResponse);
+
+        assertEquals(
+                "Vehicle flying_carpet is not a valid vehicle. Valid vehicles are *supported vehicles*",
+                ghResponse.getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectInstructions() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        for (String instruction : INSTRUCTIONS)
+        {
+            allParameters.put("instructions", new String[] { instruction });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            GHResponse ghResponse = graphHopperServlet.getGHResponse(httpServletRequest,
+                    httpServletResponse);
+
+            assertFalse(ghResponse.hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectInstruction() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("instructions", new String[] { WRONG_INSTRUCTION });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(
+                WRONG_INSTRUCTION
+                        + " is not a valid value for parameter instructions. Valid values are true or false",
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectPointsEncoded() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String point_encoded : POINTS_ENCODED)
+        {
+            allParameters.put("points_encoded", new String[] { point_encoded });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectPointsEncoded() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("points_encoded", new String[] { WRONG_POINTS_ENCODED });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(
+                buildErrorMessageString(WRONG_POINTS_ENCODED, "points_encoded", POINTS_ENCODED),
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectDebug() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String debug : DEBUG)
+        {
+            allParameters.put("debug", new String[] { debug });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectDebug() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("debug", new String[] { WRONG_DEBUG });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(buildErrorMessageString(WRONG_DEBUG, "debug", DEBUG), graphHopperServlet
+                .getGHResponse(httpServletRequest, httpServletResponse).getErrors().get(0)
+                .getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectPretty() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String pretty : PRETTY)
+        {
+            allParameters.put("pretty", new String[] { pretty });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectPretty() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+
+        allParameters.put("pretty", new String[] { WRONG_PRETTY });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(buildErrorMessageString(WRONG_PRETTY, "pretty", PRETTY), graphHopperServlet
+                .getGHResponse(httpServletRequest, httpServletResponse).getErrors().get(0)
+                .getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectCalcPoints() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String calcPoint : CALC_POINTS)
+        {
+            allParameters.put("calc_points", new String[] { calcPoint });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectCalcPoints() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        allParameters.put("calc_points", new String[] { WRONG_CALC_POINTS });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        assertEquals(buildErrorMessageString(WRONG_CALC_POINTS, "calc_points", CALC_POINTS),
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectWeighting() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String weighting : WEIGHTINGS)
+        {
+            allParameters.put("weighting", new String[] { weighting });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
+
+    @Test
+    public void testGetGHResponseWithIncorrectWeighting() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        allParameters.put("weighting", new String[] { WRONG_WEIGHTING });
+
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+        GHResponse ghResponse = graphHopperServlet.getGHResponse(httpServletRequest,
+                httpServletResponse);
+
+        assertEquals(1, ghResponse.getErrors().size());
+        // TODO Generate appropriate error message in GraphhopperServletClass
+        // assertEquals(buildErrorMessageString(WRONG_WEIGHTING, "calc_points", WEIGHTINGS),
+        // ghResponse.getErrors().get(0).getMessage());
+
+    }
+
+    @Test
+    public void testGetGHResponseWithCorrectAvoidances() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
+        allParameters.put("instructions", new String[] { "false" });
+
+        for (String avoidances : AVOIDANCES)
+        {
+            allParameters.put("avoidances", new String[] { avoidances });
+            when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
+
+            when(flagEncoder.getEncoderDecorators()).thenReturn(encoderDecorators);
+            when(encoderDecorators.iterator()).thenReturn(iterator);
+            when(iterator.hasNext()).thenReturn(true, false);
+            when(iterator.next()).thenReturn(abstractAvoidanceDecorator);
+            when(abstractAvoidanceDecorator.getEdgeAttributesOfInterestNames()).thenReturn(
+                    AVOIDANCES);
+
+            assertFalse(graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                    .hasErrors());
+        }
+    }
 
-	@Test
-	public void testErrorStatusCode() throws ServletException, IOException
-	{
-		HttpServletRequest httpServletRequest = mock(HttpServletRequest.class);
+    @Test
+    public void testGetGHResponseWithIncorrectAvoidances() throws MissingParameterException,
+            NoSuchParameterException, InvalidParameterException, IOException
+    {
+        allParameters.put("point", POINTS);
+        allParameters.put("vehicle", new String[] { VEHICLES[0] });
+        allParameters.put("locale", new String[] { LOCALES[0] });
 
-		when(httpServletRequest.getParameter("vehicle")).thenReturn("car");
-		when(httpServletRequest.getParameter("point")).thenReturn(null);
+        allParameters.put("avoidances", new String[] { WRONG_AVOIDANCE });
+        when(httpServletRequest.getParameterMap()).thenReturn(allParameters);
 
-		GraphHopperServlet servlet = new GraphHopperServlet();
-		HttpServletResponse httpServletResponse = mock(HttpServletResponse.class);
-		when(httpServletResponse.getWriter()).thenReturn(mock(PrintWriter.class));
-		servlet.doGet(httpServletRequest, httpServletResponse);
-		verify(httpServletResponse).setStatus(SC_BAD_REQUEST);
+        when(flagEncoder.getEncoderDecorators()).thenReturn(encoderDecorators);
+        when(encoderDecorators.iterator()).thenReturn(iterator);
+        when(iterator.hasNext()).thenReturn(true, false);
+        when(iterator.next()).thenReturn(abstractAvoidanceDecorator);
+        when(abstractAvoidanceDecorator.getEdgeAttributesOfInterestNames()).thenReturn(AVOIDANCES);
 
-	}
+        assertEquals(buildErrorMessageString(WRONG_AVOIDANCE, "avoidances", AVOIDANCES),
+                graphHopperServlet.getGHResponse(httpServletRequest, httpServletResponse)
+                        .getErrors().get(0).getMessage());
+    }
 
 }
