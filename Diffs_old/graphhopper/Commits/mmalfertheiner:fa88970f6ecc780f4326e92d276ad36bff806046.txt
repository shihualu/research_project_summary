diff --git a/.gitattributes b/.gitattributes
index ca8f2dfd33..9229c31f2c 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -3,6 +3,7 @@
 
 # Explicitly declare text files we want to always be normalized and converted 
 # to native line endings on checkout.
+*.sh text
 *.java text
 *.xml text
 *.js text
diff --git a/android/app/build.gradle b/android/app/build.gradle
index d1437430be..152d1dbb52 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -6,8 +6,8 @@ android {
 
     defaultConfig {
         applicationId "com.graphhopper.android"
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion 10
+        targetSdkVersion 22
     }
 
     buildTypes {
@@ -35,7 +35,7 @@ configurations.all {
  **/
 
 dependencies {
-    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.4-SNAPSHOT') {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.5-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
@@ -46,6 +46,6 @@ dependencies {
     compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.1'
     compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.1'
 
-    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.10'
-    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.10'
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.12'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.12'
 }
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 717a64c65e..c76f32f7cc 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -76,13 +76,13 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.7.10</version>
+            <version>1.7.12</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.10</version>
+            <version>1.7.12</version>
         </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
@@ -126,7 +126,7 @@
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 8 = platform 2.2) -->                        
-                        <platform>10</platform>
+                        <platform>22</platform>
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index 4908215b43..aa1cea3964 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -1,29 +1,29 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.graphhopper.android"
-          android:versionCode="1"
-          android:versionName="0.1" >
+    package="com.graphhopper.android"
+    android:versionCode="1"
+    android:versionName="0.1" >
 
     <!-- mapsforge cache and saving maps -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    
+
     <!-- necessary to easily download maps via wifi -->
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
     <uses-sdk
-        android:minSdkVersion="8"
-        android:targetSdkVersion="19" />
+        android:minSdkVersion="10"
+        android:targetSdkVersion="22" />
 
     <application
-        android:allowBackup="true"
+        android:hardwareAccelerated="false"
+        android:allowBackup="true"        
         android:icon="@drawable/logo"
-        android:label="@string/app_name"        
+        android:label="@string/app_name"
         android:theme="@style/AppTheme" >
-        
         <activity
             android:name=".MainActivity"
-            android:label="@string/title_activity_main" 
-            android:screenOrientation="portrait">
+            android:label="@string/title_activity_main"
+            android:screenOrientation="portrait" >
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
index 63f874629a..becd0e6280 100644
--- a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -15,30 +15,37 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-public class AndroidDownloader extends Downloader {
-
-    public AndroidDownloader() {
+public class AndroidDownloader extends Downloader
+{
+    public AndroidDownloader()
+    {
         super("GraphHopper Android");
     }
 
-    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
+    @Override
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
         HttpEntity entity = getEntity(url);
         InputStream iStream = entity.getContent();
         final long length = entity.getContentLength();
 
-        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
             @Override
-            public void update(long sumBytes) {
+            public void update( long sumBytes )
+            {
                 progressListener.update((int) (100 * sumBytes / length));
             }
         });
     }
 
-    private HttpEntity getEntity(String url) {
+    private HttpEntity getEntity( String url )
+    {
         // there is something broken with HTTPS and Android HttpURLConnection
         HttpClient httpclient = new DefaultHttpClient();
         HttpGet httpget = new HttpGet(url);
-        try {
+        try
+        {
             HttpResponse response = httpclient.execute(httpget);
             HttpEntity entity = response.getEntity();
             if (entity == null)
@@ -46,13 +53,15 @@ private HttpEntity getEntity(String url) {
 
             return entity;
 
-        } catch (Exception ex) {
+        } catch (Exception ex)
+        {
             throw new RuntimeException(ex);
         }
     }
 
     @Override
-    public String downloadAsString(String url) throws IOException {
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
+    {
         return Helper.isToString(getEntity(url).getContent());
     }
 }
diff --git a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index 62923ec579..e60f0d4663 100644
--- a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,7 +20,7 @@ protected C doInBackground( A... params )
         }
     }
 
-	public boolean hasError()
+    public boolean hasError()
     {
         return error != null;
     }
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 3cd489e212..b75c9b5e46 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -77,6 +77,7 @@
     private String downloadURL;
     private File mapsFolder;
     private TileCache tileCache;
+    private TileRendererLayer tileRendererLayer;
 
     protected boolean onMapTap( LatLong tapLatLong, Point layerXY, Point tapXY )
     {
@@ -177,6 +178,14 @@ protected void onDestroy()
         hopper = null;
         // necessary?
         System.gc();
+
+        // Cleanup Mapsforge
+        this.mapView.getLayerManager().getLayers().remove(this.tileRendererLayer);
+        this.tileRendererLayer.onDestroy();
+        this.tileCache.destroy();
+        this.mapView.getModel().mapViewPosition.destroy();
+        this.mapView.destroy();
+        AndroidGraphicFactory.clearResourceMemoryCache();
     }
 
     boolean isReady()
@@ -240,7 +249,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL, false).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -261,7 +270,7 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if(nameList.isEmpty())
+                if (nameList.isEmpty())
                 {
                     logUser("No maps created for your version!? " + fileListURL);
                     return;
@@ -296,7 +305,7 @@ public void onSelect( String selectedArea, String selectedFile )
     }
 
     private void chooseArea( Button button, final Spinner spinner,
-            List<String> nameList, final MySpinnerListener mylistener )
+                             List<String> nameList, final MySpinnerListener mylistener )
     {
         final Map<String, String> nameToFullName = new TreeMap<String, String>();
         for (String fullName : nameList)
@@ -403,15 +412,15 @@ void loadMap( File areaFolder )
 
         mapView.getLayerManager().getLayers().clear();
 
-        TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
-        		mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
-                {
-                    @Override
-                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
-                    {
-                        return onMapTap(tapLatLong, layerXY, tapXY);
-                    }
-                };
+        tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
+                mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
+        {
+            @Override
+            public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
+            {
+                return onMapTap(tapLatLong, layerXY, tapXY);
+            }
+        };
         tileRendererLayer.setTextScale(1.5f);
         tileRendererLayer.setXmlRenderTheme(InternalRenderTheme.OSMARENDER);
         mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(mapDataStore.boundingBox().getCenterPoint(), (byte) 15));
@@ -462,9 +471,9 @@ private Polyline createPolyline( GHResponse response )
         paintStroke.setStyle(Style.STROKE);
         paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
-        {
-            25, 15
-        });
+                {
+                        25, 15
+                });
         paintStroke.setStrokeWidth(8);
 
         // TODO: new mapsforge version wants an mapsforge-paint, not an android paint.
@@ -489,7 +498,7 @@ private Marker createMarker( LatLong p, int resource )
     }
 
     public void calcPath( final double fromLat, final double fromLon,
-            final double toLat, final double toLon )
+                          final double toLat, final double toLon )
     {
 
         log("calculating path ...");
@@ -546,6 +555,7 @@ private void logUser( String str )
         log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
+
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
 
     @Override
diff --git a/core/files/N43E007hgt.zip b/core/files/N43E007.hgt.zip
similarity index 100%
rename from core/files/N43E007hgt.zip
rename to core/files/N43E007.hgt.zip
diff --git a/core/files/N49E011hgt.zip b/core/files/N49E011.hgt.zip
similarity index 100%
rename from core/files/N49E011hgt.zip
rename to core/files/N49E011.hgt.zip
diff --git a/core/files/N50E011hgt.zip b/core/files/N50E011.hgt.zip
similarity index 100%
rename from core/files/N50E011hgt.zip
rename to core/files/N50E011.hgt.zip
diff --git a/core/files/N52E008.hgt.zip b/core/files/N52E008.hgt.zip
new file mode 100644
index 0000000000..bbc3b2e502
Binary files /dev/null and b/core/files/N52E008.hgt.zip differ
diff --git a/core/files/N55W003hgt.zip b/core/files/N55W003.hgt.zip
similarity index 100%
rename from core/files/N55W003hgt.zip
rename to core/files/N55W003.hgt.zip
diff --git a/core/files/N55W004hgt.zip b/core/files/N55W004hgt.zip
deleted file mode 100644
index 3073befc2f..0000000000
Binary files a/core/files/N55W004hgt.zip and /dev/null differ
diff --git a/core/files/S29W072hgt.zip b/core/files/S29W072.hgt.zip
similarity index 100%
rename from core/files/S29W072hgt.zip
rename to core/files/S29W072.hgt.zip
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index ce57eabe50..4504ea36df 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,5 @@
 0.5
+    breaking change in HTTP API: error JSON format changed to be message:"" instead of within info.errors, see updated api documentation
     made GHResponse.getMillis, Path.getMillis, GPXEntry.getMillis deprecated, use getTime instead
     in AbstractFlagEncoder, parse*() and getStr() are now deprecated, use properties.get* instead
 
diff --git a/core/files/intellij-settings.jar b/core/files/intellij-settings.jar
new file mode 100644
index 0000000000..a7553f8d0e
Binary files /dev/null and b/core/files/intellij-settings.jar differ
diff --git a/core/files/map-bug432.osm.gz b/core/files/map-bug432.osm.gz
new file mode 100644
index 0000000000..e12a1de28d
Binary files /dev/null and b/core/files/map-bug432.osm.gz differ
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index abf201e54b..253bd32cb4 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca cz de_DE el es fa fil fi fr gl he hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
+translations="en_US SKIP ar bg ca cz de_DE el es fa fil fi fr gl he hsb hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index f68f7cf332..4337f00b3d 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -20,25 +20,32 @@
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
  * <p/>
+ *
  * @author Peter Karich
  * @author ratrun
  */
 public class GHRequest
 {
     private String algo = "";
-    private List<GHPoint> points;
+    private final List<GHPoint> points;
     private final WeightingMap hints = new WeightingMap();
     private String vehicle = "";
     private boolean possibleToAdd = false;
     private Locale locale = Locale.US;
 
+    // List of favored start (1st element) and arrival heading (all other).
+    // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+    private final List<Double> favoredHeadings;
+
     public GHRequest()
     {
         this(5);
@@ -47,49 +54,152 @@ public GHRequest()
     public GHRequest( int size )
     {
         points = new ArrayList<GHPoint>(size);
+        favoredHeadings = new ArrayList<Double>(size);
         possibleToAdd = true;
     }
 
     /**
-     * Calculate the path from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon).
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
+     * with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference.
+     */
+    public GHRequest( double fromLat, double fromLon, double toLat, double toLon,
+                      double startHeading, double endHeading )
+    {
+        this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon), startHeading, endHeading);
+    }
+
+    /**
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
     {
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
+
     /**
-     * Calculate the path from specified startPlace to endPlace.
+     * Set routing request from specified startPlace to endPlace with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading )
     {
         if (startPlace == null)
             throw new IllegalStateException("'from' cannot be null");
 
         if (endPlace == null)
             throw new IllegalStateException("'to' cannot be null");
+
         points = new ArrayList<GHPoint>(2);
         points.add(startPlace);
         points.add(endPlace);
+
+        favoredHeadings = new ArrayList<Double>(2);
+        validateAzimuthValue(startHeading);
+        favoredHeadings.add(startHeading);
+        validateAzimuthValue(endHeading);
+        favoredHeadings.add(endHeading);
     }
 
-    public GHRequest( List<GHPoint> points )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    {
+        this(startPlace, endPlace, Double.NaN, Double.NaN);
+    }
+
+
+    /**
+     * Set routing request
+     *
+     * @param points          List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     * @param favoredHeadings List of favored headings for starting (start point) and arrival (via and end points)
+     *                        Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
     {
+        if (points.size() != favoredHeadings.size())
+            throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size() +
+                    ") must match size of points (" + points.size() + ")");
+
+        for (Double heading : favoredHeadings)
+        {
+            validateAzimuthValue(heading);
+        }
         this.points = points;
+        this.favoredHeadings = favoredHeadings;
     }
 
-    public GHRequest addPoint( GHPoint point )
+    /**
+     * Set routing request
+     *
+     * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     */
+    public GHRequest( List<GHPoint> points )
+    {
+        this(points, Collections.nCopies(points.size(), Double.NaN));
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point          geographical position (see GHPoint)
+     * @param favoredHeading north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest addPoint( GHPoint point, Double favoredHeading )
     {
         if (point == null)
             throw new IllegalArgumentException("point cannot be null");
+
+
         if (!possibleToAdd)
             throw new IllegalStateException("Please call empty constructor if you intent to use "
                     + "more than two places via addPlace method.");
 
         points.add(point);
+        validateAzimuthValue(favoredHeading);
+        favoredHeadings.add(favoredHeading);
+        return this;
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point geographical position (see GHPoint)
+     */
+    public GHRequest addPoint( GHPoint point )
+    {
+        addPoint(point, Double.NaN);
         return this;
     }
 
+    /**
+     * @return north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public double getFavoredHeading( int i )
+    {
+        return favoredHeadings.get(i);
+    }
+
+    /**
+     * @return if there exist a preferred heading for start/via/end point i
+     */
+    public boolean hasFavoredHeading( int i )
+    {
+        if (i >= favoredHeadings.size())
+            throw new IndexOutOfBoundsException("Index: " + i + " too large for list of size " + favoredHeadings.size());
+
+        return !Double.isNaN(favoredHeadings.get(i));
+    }
+
+    // validate Azimuth entry
+    private void validateAzimuthValue( Double heading )
+    {
+        // heading must be in (0, 360) oder Nan
+        if (!Double.isNaN(heading) && ((Double.compare(heading, 360) > 0) || (Double.compare(heading, 0) < 0)))
+        {
+            throw new IllegalArgumentException("Heading " + heading + " must be in range (0,360) or NaN");
+        }
+    }
+
     public List<GHPoint> getPoints()
     {
         return points;
@@ -163,9 +273,12 @@ public String toString()
         for (GHPoint point : points)
         {
             if (res.isEmpty())
+            {
                 res = point.toString();
-            else
+            } else
+            {
                 res += "; " + point.toString();
+            }
         }
         return res + "(" + algo + ")";
     }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 985995ddc6..9aebf05720 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -110,7 +111,7 @@ public GHResponse setDistance( double distance )
     /**
      * This method returns the distance of the path. Always prefer this method over
      * getPoints().calcDistance
-     * <p>
+     * <p/>
      * @return distance in meter
      */
     public double getDistance()
@@ -191,8 +192,8 @@ public BBox calcRouteBBox( BBox _fallback )
     @Override
     public String toString()
     {
-        String str = "nodes:" + list.getSize() + ": " + list.toString();
-        if (!instructions.isEmpty())
+        String str = "nodes:" + list.getSize() + "; " + list.toString();
+        if (instructions != null && !instructions.isEmpty())
             str += ", " + instructions.toString();
 
         if (hasErrors())
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index b047f17bed..c9f087d245 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -26,9 +26,13 @@
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
@@ -36,14 +40,12 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
- * @see GraphHopperAPI
+ *
  * @author Peter Karich
+ * @see GraphHopperAPI
  */
 public class GraphHopper implements GraphHopperAPI
 {
@@ -87,7 +89,7 @@
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils    
+    // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private final AtomicLong visitedSum = new AtomicLong(0);
@@ -124,9 +126,7 @@ public GraphHopper setEncodingManager( EncodingManager em )
     FlagEncoder getDefaultVehicle()
     {
         if (encodingManager == null)
-        {
             throw new IllegalStateException("No encoding manager specified or loaded");
-        }
 
         return encodingManager.fetchEdgeEncoders().get(0);
     }
@@ -248,7 +248,8 @@ public GraphHopper setInMemory()
      * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
-     * <p>
+     * <p/>
+     *
      * @param storeOnFlush true by default
      */
     public GraphHopper setStoreOnFlush( boolean storeOnFlush )
@@ -284,6 +285,7 @@ private GraphHopper setUnsafeMemory()
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
+     *
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
@@ -313,7 +315,8 @@ public GraphHopper setDoPrepare( boolean doPrepare )
      * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
      * Disabling CH is only recommended for short routes or in combination with
      * setDefaultWeightLimit and called flexibility mode
-     * <p>
+     * <p/>
+     *
      * @see #setDefaultWeightLimit(double)
      */
     public GraphHopper setCHEnable( boolean enable )
@@ -426,7 +429,8 @@ public String getOSMFile()
 
     /**
      * The underlying graph used in algorithms.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if graph is not instantiated.
      */
     public GraphStorage getGraph()
@@ -440,6 +444,7 @@ public GraphStorage getGraph()
     public void setGraph( GraphStorage graph )
     {
         this.graph = graph;
+        fullyLoaded = true;
     }
 
     protected void setLocationIndex( LocationIndex locationIndex )
@@ -449,7 +454,8 @@ protected void setLocationIndex( LocationIndex locationIndex )
 
     /**
      * The location index created from the graph.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex()
@@ -685,6 +691,7 @@ protected OSMReader initOSMReader( OSMReader reader )
     /**
      * Opens existing graph.
      * <p/>
+     *
      * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
      * too)
      */
@@ -787,9 +794,12 @@ protected void postProcessing()
     {
         initLocationIndex();
         if (chEnabled)
+        {
+            if (algoFactory != null)
+                throw new IllegalStateException("Customizing of the routing algorithm factory is currently not supported");
+
             algoFactory = createPrepare();
-        else
-            algoFactory = new RoutingAlgorithmFactorySimple();
+        }
 
         if (!isPrepared())
             prepare();
@@ -818,12 +828,13 @@ protected RoutingAlgorithmFactory createPrepare()
      * Based on the weightingParameters and the specified vehicle a Weighting instance can be
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
-     * <p>
-     * @see WeightingMap
+     * <p/>
+     *
      * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
      * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
      * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
+     * @see WeightingMap
      */
     public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
@@ -836,9 +847,9 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
         } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
         {
             if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
+                result = new PriorityWeighting(encoder, weightingMap);
             else
-                result = new FastestWeighting(encoder);
+                result = new FastestWeighting(encoder, weightingMap);
         } else
         {
             throw new UnsupportedOperationException("weighting " + weighting + " not supported");
@@ -963,9 +974,26 @@ public GHResponse route( GHRequest request )
                 algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
                 build();
 
+        boolean viaTurnPenalty = request.getHints().getBool("pass_through", false);
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
+
+            if (placeIndex == 1)
+            {
+                // enforce start direction
+                queryGraph.enforceHeading(fromQResult.getClosestNode(), request.getFavoredHeading(0), false);
+            } else if (viaTurnPenalty)
+            {
+                // enforce straight start after via stop
+                EdgeIteratorState incomingVirtualEdge = paths.get(placeIndex - 2).getFinalEdge();
+                queryGraph.enforceHeadingByEdgeId(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge(), false);
+            }
+
             QueryResult toQResult = qResults.get(placeIndex);
+
+            // enforce end direction
+            queryGraph.enforceHeading(toQResult.getClosestNode(), request.getFavoredHeading(placeIndex), true);
+
             sw = new StopWatch().start();
             RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
             algo.setWeightLimit(weightLimit);
@@ -979,6 +1007,9 @@ public GHResponse route( GHRequest request )
             paths.add(path);
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
 
+            // reset all direction enforcements in queryGraph to avoid influencing next path
+            queryGraph.clearUnfavoredStatus();
+
             visitedSum.addAndGet(algo.getVisitedNodes());
             fromQResult = toQResult;
         }
@@ -1040,12 +1071,12 @@ protected void optimize()
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
+        boolean tmpPrepare = doPrepare && getAlgorithmFactory() instanceof PrepareContractionHierarchies;
         if (tmpPrepare)
         {
             ensureWriteAccess();
             logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
-            ((PrepareContractionHierarchies) algoFactory).doWork();
+            ((PrepareContractionHierarchies) getAlgorithmFactory()).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
@@ -1053,22 +1084,24 @@ protected void prepare()
 
     protected void cleanUp()
     {
-        int prev = graph.getNodes();
+        int prevNodeCount = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
         preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
+        int currNodeCount = graph.getNodes();
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + currNodeCount
+                + ", there were " + preparation.getSubNetworks()
+                + " subnetworks. removed them => " + (prevNodeCount - currNodeCount)
+                + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
+        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
+                + Helper.getMemInfo() + ")");
         graph.flush();
         fullyLoaded = true;
     }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 9f76e601b5..f1bc8e66d8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -27,7 +27,7 @@
     /**
      * Connects to the specified service (graphhopper URL) or loads a graph from the graphhopper
      * folder.
-     * <p>
+     * <p/>
      * @return true if successfully connected or loaded
      */
     boolean load( String urlOrFile );
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 4036672e37..6fcb3fc3aa 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -21,6 +21,7 @@
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
 import java.util.List;
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index d006901e16..7933a9f6f9 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -79,7 +79,7 @@ public GHBitSet copyTo( GHBitSet bs )
             int len = size();
             bs.ensureCapacity(len);
             for (int index = super.nextSetBit(0); index >= 0;
-                    index = super.nextSetBit(index + 1))
+                 index = super.nextSetBit(index + 1))
             {
                 bs.add(index);
             }
diff --git a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
index 4eca459cb2..53e9a4684f 100644
--- a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
+++ b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
@@ -18,7 +18,9 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -472,6 +474,7 @@ static int binarySearch( long keys[], int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long guessedKey = keys[guess];
             if (guessedKey < key)
diff --git a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
index 7aaab98cc1..7b17fad7e7 100644
--- a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
+++ b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
@@ -19,6 +19,7 @@
 
 import gnu.trove.iterator.TIntIterator;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Map.Entry;
 import java.util.TreeMap;
 
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index faee1ee386..78bf9bc378 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.BitUtil;
+
 import java.util.TreeMap;
 
 /**
@@ -67,7 +68,7 @@ public void insert( int key, int value )
     public int peekValue()
     {
         long key = map.firstEntry().getKey();
-        return (int) (key >>> 32);
+        return (int) (key >> 32);
     }
 
     public int peekKey()
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 906242e37b..96c55d345f 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -104,6 +104,7 @@ static long binarySearch( DataAccess da, long start, long len, long key )
         byte[] longBytes = new byte[8];
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long tmp = guess << 3;
             da.getBytes(tmp, longBytes, 8);
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
index 967b117b0e..e1f451a42d 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/coll/SparseArray.java b/core/src/main/java/com/graphhopper/coll/SparseArray.java
index 7b48993699..c9d9bf0392 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseArray.java
@@ -373,7 +373,8 @@ private static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
diff --git a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
index 220c23d2f2..b3e95ef529 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
@@ -396,7 +396,8 @@ static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -434,6 +435,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private int[] mKeys;
     private int[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
index e84b46824c..2398eceec7 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
@@ -400,7 +400,8 @@ static int binarySearch( long[] a, int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -438,6 +439,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private long[] mKeys;
     private long[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index 00de04f07b..c676cfad4a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -131,7 +131,7 @@ public void setTag( String name, Object value )
      */
     public boolean hasTag( String key, Object value )
     {
-        return value.equals(properties.get(key));
+        return value.equals(getTag(key, ""));
     }
 
     /**
@@ -161,7 +161,7 @@ public boolean hasTag( String key, String... values )
      */
     public final boolean hasTag( String key, Set<String> values )
     {
-        return values.contains(properties.get(key));
+        return values.contains(getTag(key, ""));
     }
 
     /**
@@ -172,12 +172,25 @@ public boolean hasTag( List<String> keyList, Set<String> values )
     {
         for (String key : keyList)
         {
-            if (values.contains(properties.get(key)))
+            if (values.contains(getTag(key, "")))
                 return true;
         }
         return false;
     }
 
+    /**
+     * Returns the first existing tag of the specified list where the order is important.
+     */
+    public String getFirstPriorityTag( List<String> restrictions )
+    {
+        for (String str : restrictions)
+        {
+            if (hasTag(str))
+                return getTag(str);
+        }
+        return "";
+    }
+
     public void removeTag( String name )
     {
         properties.remove(name);
@@ -202,5 +215,5 @@ public boolean isType( int type )
     public String toString()
     {
         return properties.toString();
-    }        
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index 276227a0e5..43c5e70f38 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -240,6 +240,7 @@ public void close() throws IOException
                 pbfReaderThread.interrupt();
         }
     }
+
     Thread pbfReaderThread;
 
     private void openPBFReader( InputStream stream )
diff --git a/core/src/main/java/com/graphhopper/reader/OSMNode.java b/core/src/main/java/com/graphhopper/reader/OSMNode.java
index d8153cbea4..ea42f49425 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMNode.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMNode.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import com.graphhopper.util.PointAccess;
+
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 8cbf5e5111..e32247d2b3 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static com.graphhopper.util.Helper.nf;
+
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
@@ -48,6 +49,7 @@
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TLongObjectHashMap;
+
 import java.util.*;
 
 /**
@@ -57,7 +59,7 @@
  * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
  * osmNodeIdToIndexMap returns EMPTY.
- * <p>
+ * <p/>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
  * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
  * of the relation.
@@ -658,7 +660,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
+    Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
     {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
@@ -777,14 +779,20 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
                     pillarNodes.add(lat, lon);
             }
         }
-        if (towerNodeDistance == 0)
+        if (towerNodeDistance < 0.0001)
         {
             // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very release points.
+            // but end up in two very close points.
             zeroCounter++;
             towerNodeDistance = 0.0001;
         }
 
+        if (Double.isInfinite(towerNodeDistance) || Double.isNaN(towerNodeDistance))
+        {
+            logger.warn("Bug in OSM or GraphHopper. Illegal tower node distance " + towerNodeDistance + " reset to 1m, osm way " + wayOsmId);
+            towerNodeDistance = 1;
+        }
+
         EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2)
         {
@@ -893,7 +901,7 @@ private long createNewNodeId()
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
-     * <p>
+     * <p/>
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
@@ -997,10 +1005,11 @@ public OSMReader setOSMFile( File osmFile )
 
     private void printInfo( String str )
     {
-        LoggerFactory.getLogger(getClass()).info(
-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+        logger.info("finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+                + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+                + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
+                + ", zeroCounter:" + zeroCounter
+                + " " + Helper.getMemInfo());
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index c3e922d7e7..27c5c7051a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -7,11 +7,12 @@
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
- * <p>
+ * <p/>
  * @author Karl HÃ¼bner
  */
 public class OSMTurnRelation
@@ -69,13 +70,13 @@ long getOsmIdTo()
 
     /**
      * Transforms this relation into a collection of turn cost entries
-     * <p>
+     * <p/>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
     public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
+                                                                   EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
     {
         int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 0c612d5e7b..9ef7e4664e 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -25,7 +25,7 @@
 
 /**
  * This class helps to store lat,lon,ele for every node parsed in OSMReader
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PillarInfo implements PointAccess
@@ -61,7 +61,7 @@ public void ensureNode( int nodeId )
     {
         long tmp = (long) nodeId * rowSizeInBytes;
         da.ensureCapacity(tmp + rowSizeInBytes);
-    }        
+    }
 
     @Override
     public void setNode( int nodeId, double lat, double lon )
diff --git a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
index 7b6a6438ba..977337760a 100644
--- a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.Helper;
+
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 0de2549665..ada6645c76 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
+
 import java.awt.image.Raster;
 import java.io.*;
 import java.net.SocketTimeoutException;
@@ -31,6 +32,7 @@
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
+
 import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
 import org.apache.xmlgraphics.image.codec.util.SeekableStream;
@@ -41,14 +43,14 @@
  * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
  * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
  * http://graphhopper.com/public/license/CGIAR.txt
- * <p>
+ * <p/>
  * Every zip contains readme.txt with the necessary information e.g.:
  * <ol>
  * <li>
  * All GeoTiffs with 6000 x 6000 pixels.
  * </li>
  * </ol>
- * <p>
+ * <p/>
  * @author NopMap
  * @author Peter Karich
  */
@@ -60,7 +62,7 @@
     private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
     private File cacheDir = new File("/tmp/cgiar");
     // for alternatives see #346
-    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";    
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
     private Directory dir;
     private DAType daType = DAType.MMAP;
     final double precision = 1e7;
@@ -105,6 +107,11 @@ public ElevationProvider setCacheDir( File cacheDir )
         return this;
     }
 
+    protected File getCacheDir()
+    {
+        return cacheDir;
+    }        
+
     @Override
     public ElevationProvider setBaseURL( String baseUrl )
     {
@@ -210,7 +217,7 @@ public double getEle( double lat, double lon )
                     {
                         entry = zis.getNextEntry();
                     }
-
+                    
                     ss = SeekableStream.wrapInputStream(zis, true);
                     TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
                     raster = imageDecoder.decodeAsRaster();
@@ -315,6 +322,9 @@ private Directory getDirectory()
     public static void main( String[] args )
     {
         CGIARProvider provider = new CGIARProvider();
+        
+        System.out.println(provider.getEle(46, -20));
+        
         // 337.0
         System.out.println(provider.getEle(49.949784, 11.57517));
         // 453.0
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index aed7740ae7..293b6a6e6d 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index 838e567948..3809f71c94 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DataAccess;
+
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
@@ -29,7 +30,7 @@
 
 /**
  * One rectangle of height data from Shuttle Radar Topography Mission.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class HeightTile
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index e5d6b150ab..2c98e431dd 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -23,20 +23,22 @@
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
+
 import java.io.*;
 import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
- * <p>
+ * Elevation data from NASA (SRTM).
+ * <p/>
  * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
  * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
  * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
  * 90 meters in extent.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SRTMProvider implements ElevationProvider
@@ -91,7 +93,8 @@ public static void main( String[] args ) throws IOException
     private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
     private final double precision = 1e7;
     private final double invPrecision = 1 / precision;
-    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
+    // possible alternatives see #451
+    // http://mirror.ufs.ac.za/datasets/SRTM3/
     private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
     private boolean calcMean = false;
 
@@ -116,9 +119,9 @@ private SRTMProvider init()
         try
         {
             String strs[] =
-            {
-                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-            };
+                    {
+                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+                    };
             for (String str : strs)
             {
                 InputStream is = getClass().getResourceAsStream(str + "_names.txt");
@@ -268,7 +271,7 @@ public double getEle( double lat, double lon )
                 heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
                     File file = new File(cacheDir, new File(zippedURL).getName());
                     InputStream is;
                     // get zip file if not already in cacheDir - unzip later and in-memory only!
@@ -287,8 +290,8 @@ public double getEle( double lat, double lon )
                                 continue;
                             } catch (FileNotFoundException ex)
                             {
-                                // now try different URL (with point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                                // now try different URL (without point!), necessary if mirror is used
+                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
                                 continue;
                             }
                         }
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
index 58ab2d598c..a862aaf326 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
@@ -12,9 +12,9 @@
 
 import java.io.IOException;
 import java.util.*;
-import java.util.logging.Level;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -85,13 +85,11 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
 
         // Build the list of active and unsupported features in the file.
         List<String> supportedFeatures = Arrays.asList("OsmSchema-V0.6", "DenseNodes");
-        List<String> activeFeatures = new ArrayList<String>();
         List<String> unsupportedFeatures = new ArrayList<String>();
         for (String feature : header.getRequiredFeaturesList())
         {
             if (supportedFeatures.contains(feature))
             {
-                activeFeatures.add(feature);
             } else
             {
                 unsupportedFeatures.add(feature);
@@ -140,7 +138,7 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
         Iterator<Integer> valueIterator = values.iterator();
         if (keyIterator.hasNext())
         {
-            Map<String, String> tags = new HashMap<String, String>();
+            Map<String, String> tags = new HashMap<String, String>(keys.size());
             while (keyIterator.hasNext())
             {
                 String key = fieldDecoder.decodeString(keyIterator.next());
@@ -291,8 +289,8 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
     }
 
     private void buildRelationMembers( OSMRelation relation,
-            List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
-            PbfFieldDecoder fieldDecoder )
+                                       List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
+                                       PbfFieldDecoder fieldDecoder )
     {
 
         ArrayList<OSMRelation.Member> members = relation.getMembers();
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
index 421979704f..6ff39041c0 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
@@ -2,6 +2,7 @@
 package com.graphhopper.reader.pbf;
 
 import com.graphhopper.reader.OSMElement;
+
 import java.util.Date;
 
 import java.util.LinkedList;
@@ -37,7 +38,7 @@
      * @param sink The sink to send all decoded entities to.
      */
     public PbfDecoder( PbfStreamSplitter streamSplitter, ExecutorService executorService, int maxPendingBlobs,
-            Sink sink )
+                       Sink sink )
     {
         this.streamSplitter = streamSplitter;
         this.executorService = executorService;
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
index 7615e10ae1..a1921bed2e 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
@@ -9,7 +9,7 @@
  * Manages decoding of the lower level PBF data structures.
  * <p/>
  * @author Brett Henderson
- * <p/>
+ *         <p/>
  */
 public class PbfFieldDecoder
 {
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 4a77796207..80b88f570f 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -79,8 +79,10 @@ public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
         to1 = to;
+
         weightApprox.setGoalNode(to);
-        currEdge = createEdgeEntry(from, 0);
+        double weightToGoal = weightApprox.approximate(from);
+        currEdge = new AStarEdge(EdgeIterator.NO_EDGE, from, 0 + weightToGoal, 0);
         if (!traversalMode.isEdgeBased())
         {
             fromMap.put(from, currEdge);
@@ -159,9 +161,9 @@ protected Path extractPath()
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 46ea986a06..7fd97d3d22 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -24,6 +24,7 @@
 import java.util.PriorityQueue;
 
 import com.graphhopper.routing.AStar.AStarEdge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 
@@ -93,17 +94,24 @@ public AStarBidirection setApproximation( WeightApproximator approx )
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
+        currFrom = new AStarEdge(EdgeIterator.NO_EDGE, from, weight, weight);
         weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
+
+        if (currTo != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapFrom.put(from, currFrom);
@@ -126,11 +134,18 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
+        currTo = new AStarEdge(EdgeIterator.NO_EDGE, to, weight, weight);
         weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
+
+        if (currFrom != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapTo.put(to, currTo);
@@ -169,10 +184,15 @@ protected Path extractPath()
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
+    }
+
+    @Override
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
     @Override
@@ -217,7 +237,7 @@ boolean fillEdgesTo()
     }
 
     private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
-            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -261,7 +281,6 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
         }
     }
 
-//    @Override -> TODO use only weight => then a simple EdgeEntry is possible
     public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent, int currLoc )
     {
         AStarEdge entryOther = bestWeightMapOther.get(currLoc);
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 7e92c25b06..c0c2fcd0f0 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,7 +40,9 @@
 
     protected abstract Path createAndInitPath();
 
-    abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
+    protected abstract double getCurrentFromWeight();
+
+    protected abstract double getCurrentToWeight();
 
     abstract boolean fillEdgesFrom();
 
@@ -66,11 +68,19 @@ protected void runAlgo()
     {
         while (!finished() && !isWeightLimitExceeded())
         {
-            if (!finishedFrom)
+            if (!finishedFrom && !finishedTo)
+            {
+                if (getCurrentFromWeight() < getCurrentToWeight())
+                    finishedFrom = !fillEdgesFrom();
+                else
+                    finishedTo = !fillEdgesTo();
+            } else if (!finishedFrom)
+            {
                 finishedFrom = !fillEdgesFrom();
-
-            if (!finishedTo)
+            } else
+            {
                 finishedTo = !fillEdgesTo();
+            }
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 174aa1795a..e52e24dd5a 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -90,9 +90,9 @@ protected void checkAlreadyRun()
         alreadyRun = true;
     }
 
-    protected EdgeEntry createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new EdgeEntry(EdgeIterator.NO_EDGE, node, dist);
+        return new EdgeEntry(EdgeIterator.NO_EDGE, node, weight);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
index 6cd1313e15..433ff9cff8 100644
--- a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -30,7 +30,7 @@
  *        weighting(weighting).
  *        build();
  * </pre>
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class AlgorithmOptions
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 439a6aea69..0b770831d9 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -36,7 +36,7 @@
  * Calculates best path in bidirectional way.
  * <p/>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -67,9 +67,9 @@ protected void initCollections( int nodes )
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
+        currFrom = createEdgeEntry(from, weight);
         openSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -93,9 +93,9 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
+        currTo = createEdgeEntry(to, weight);
         openSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -135,10 +135,15 @@ protected Path extractPath()
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
+    }
+
+    @Override
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
     @Override
@@ -186,7 +191,7 @@ protected boolean isWeightLimitExceeded()
     }
 
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
-            TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+                    TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
         int currNode = currEdge.adjNode;
         EdgeIterator iter = explorer.setBaseNode(currNode);
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 6cc1649de1..a114e7b61b 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -25,6 +25,7 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index a96c414f44..49137f0146 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -25,6 +25,7 @@
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -194,6 +195,14 @@ public Path extract()
         return setFound(true);
     }
 
+    /**
+     * Yields the final edge of the path
+     */
+    public EdgeIteratorState getFinalEdge()
+    {
+        return graph.getEdgeProps(edgeIds.get(edgeIds.size() - 1), endNode);
+    }
+
     /**
      * @return the time it took to extract the path in nano (!) seconds
      */
@@ -251,7 +260,7 @@ protected long calcMillis( double distance, long flags, boolean revert )
     /**
      * Iterates over all edges in this path sorted from start to end and calls the visitor callback
      * for every edge.
-     * <p>
+     * <p/>
      * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
      * be stored.
      */
@@ -323,7 +332,7 @@ public void next( EdgeIteratorState eb, int i )
 
     /**
      * This method calculated a list of points for this path
-     * <p>
+     * <p/>
      * @return this path its geometry
      */
     public PointList calcPoints()
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
index 39cb980c28..09a27cad73 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidir.java
@@ -35,7 +35,7 @@
     private EdgeWrapper edgeWTo;
 
     public PathBidir( Graph g, FlagEncoder encoder,
-            EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
+                      EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
     {
         super(g, encoder);
         this.edgeWFrom = edgesFrom;
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ffbb943041..0c7a41b8d8 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
@@ -33,16 +35,14 @@
 import gnu.trove.procedure.TObjectProcedure;
 import gnu.trove.set.hash.TIntHashSet;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
+import java.util.*;
 
 /**
  * A class which is used to query the underlying graph with real GPS points. It does so by
  * introducing virtual nodes and edges. It is lightweight in order to be created every time a new
  * query comes in, which makes the behaviour thread safe.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class QueryGraph implements Graph
@@ -58,13 +58,15 @@
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
      * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
-    private List<EdgeIteratorState> virtualEdges;
-    private final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
+    List<VirtualEdgeIteratorState> virtualEdges;
+    final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
 
     /**
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
+    private static final AngleCalc ac = new AngleCalc();
+    private List<VirtualEdgeIteratorState> modifiedEdges = new ArrayList<VirtualEdgeIteratorState>(5);
 
     public QueryGraph( Graph graph )
     {
@@ -117,7 +119,7 @@ public void lookup( List<QueryResult> resList )
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
         // initialize all none-final variables
-        virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
+        virtualEdges = new ArrayList<VirtualEdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
         baseGraph.virtualEdges = virtualEdges;
@@ -131,11 +133,10 @@ public void lookup( List<QueryResult> resList )
         for (QueryResult res : resList)
         {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
-            EdgeIteratorState closestEdge = res.getClosestEdge();
-
             if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            EdgeIteratorState closestEdge = res.getClosestEdge();
             if (closestEdge == null)
                 throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
 
@@ -219,6 +220,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                 GHPoint3D prevPoint = fullPL.toGHPoint(0);
                 int adjNode = closestEdge.getAdjNode();
+                int origTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
+                int origRevTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
                 long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
@@ -244,7 +247,8 @@ public int compare( QueryResult o1, QueryResult o2 )
                     }
 
                     queryResults.add(res);
-                    createEdges(prevPoint, prevWayIndex,
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
                             fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
 
@@ -267,7 +271,9 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                 // two edges between last result and adjacent node are still missing if not all points skipped
                 if (addedEdges)
-                    createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
+                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
                             fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
@@ -328,9 +334,10 @@ public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
         }
     }
 
-    private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
-            PointList fullPL, EdgeIteratorState closestEdge,
-            int prevNodeId, int nodeId, long reverseFlags )
+    private void createEdges( int origTraversalKey, int origRevTraversalKey,
+                              GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+                              PointList fullPL, EdgeIteratorState closestEdge,
+                              int prevNodeId, int nodeId, long reverseFlags )
     {
         int max = wayIndex + 1;
         // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
@@ -347,15 +354,110 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
-        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
-                baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId, nodeId, prevNodeId,
-                baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
+        VirtualEdgeIteratorState baseEdge = new VirtualEdgeIteratorState(origTraversalKey,
+                virtEdgeId, prevNodeId, nodeId, baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
+        VirtualEdgeIteratorState baseReverseEdge = new VirtualEdgeIteratorState(origRevTraversalKey,
+                virtEdgeId, nodeId, prevNodeId, baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
 
         virtualEdges.add(baseEdge);
         virtualEdges.add(baseReverseEdge);
     }
 
+    /**
+     * set edges at virtual node unfavored which require at least a turn of 100Â° from favoredHeading
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param favoredHeading north based azimuth of favored heading between 0 and 360
+     * @param incoming if true, incoming edges are unfavored, else outgoing edges
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeading( int nodeId, Double favoredHeading, boolean incoming )
+    {
+        if (!isInitialized())
+            throw new IllegalStateException("QueryGraph.lookup has to be called in before heading enforcement");
+
+        if (Double.isNaN(favoredHeading))
+            return false;
+
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        int virtNodeIDintern = nodeId - mainNodes;
+        favoredHeading = ac.convertAzimuth2xaxisAngle(favoredHeading);
+
+        // either penalize incoming or outgoing edges
+        List<Integer> edgePositions = incoming ? Arrays.asList(VE_BASE, VE_ADJ_REV) : Arrays.asList(VE_BASE_REV, VE_ADJ);
+        boolean enforcementOccured = false;
+        for (int edgePos : edgePositions)
+        {
+            VirtualEdgeIteratorState edge = virtualEdges.get(virtNodeIDintern * 4 + edgePos);
+
+            PointList wayGeo = edge.fetchWayGeometry(3);
+            double edgeOrientation;
+            if (incoming)
+            {
+                int numWayPoints = wayGeo.getSize();
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(numWayPoints - 2), wayGeo.getLon(numWayPoints - 2),
+                        wayGeo.getLat(numWayPoints - 1), wayGeo.getLon(numWayPoints - 1));
+            } else
+            {
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(0), wayGeo.getLon(0),
+                        wayGeo.getLat(1), wayGeo.getLon(1));
+            }
+
+            edgeOrientation = ac.alignOrientation(favoredHeading, edgeOrientation);
+            double delta = (edgeOrientation - favoredHeading);
+
+            if (Math.abs(delta) > 1.74) // penalize if a turn of more than 100Â°
+            {
+                edge.setVirtualEdgePreference(true, false);
+                modifiedEdges.add(edge);
+                //also apply to opposite edge for reverse routing
+                VirtualEdgeIteratorState reverseEdge = virtualEdges.get(virtNodeIDintern * 4 + getPosOfReverseEdge(edgePos));
+                reverseEdge.setVirtualEdgePreference(true, true);
+                modifiedEdges.add(reverseEdge);
+                enforcementOccured = true;
+            }
+
+        }
+        return enforcementOccured;
+    }
+
+    /**
+     * set specific edge at virtual node unfavored, to enforce routing along other edges
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param edgeId edge to become unfavored
+     * @param incoming if true, incoming edge is unfavored, else outgoing edge
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeadingByEdgeId( int nodeId, int edgeId, boolean incoming )
+    {
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, nodeId);
+        VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeProps(edgeId, incomingEdge.getBaseNode());
+        incomingEdge.setVirtualEdgePreference(true, !incoming);
+        modifiedEdges.add(incomingEdge);
+        reverseEdge.setVirtualEdgePreference(true, incoming);
+        modifiedEdges.add(reverseEdge);
+        return true;
+    }
+
+    /**
+     * removes the unfavored status of all virtual edges
+     */
+    public void clearUnfavoredStatus()
+    {
+        for (VirtualEdgeIteratorState edge : modifiedEdges)
+        {
+            edge.setVirtualEdgePreference(false, false);
+            edge.setVirtualEdgePreference(false, true);
+        }
+
+    }
+
     @Override
     public int getNodes()
     {
@@ -473,12 +575,8 @@ public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
         EdgeIteratorState eis = virtualEdges.get(edgeId);
         if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
+        edgeId = getPosOfReverseEdge(edgeId);
 
-        // find reverse edge via convention. see virtualEdges comment above
-        if (edgeId % 2 == 0)
-            edgeId++;
-        else
-            edgeId--;
         EdgeIteratorState eis2 = virtualEdges.get(edgeId);
         if (eis2.getAdjNode() == adjNode)
             return eis2;
@@ -486,6 +584,17 @@ public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
                 + ". found edges were:" + eis + ", " + eis2);
     }
 
+    private int getPosOfReverseEdge( int edgeId )
+    {
+        // find reverse edge via convention. see virtualEdges comment above
+        if (edgeId % 2 == 0)
+            edgeId++;
+        else
+            edgeId--;
+
+        return edgeId;
+    }
+
     @Override
     public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
     {
@@ -568,7 +677,7 @@ public EdgeIterator setBaseNode( int baseNode )
      * Creates a fake edge iterator pointing to multiple edge states.
      */
     private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
-            int node, int virtNode )
+                                  int node, int virtNode )
     {
         VirtualEdgeIterator existingIter = node2EdgeMap.get(node);
         if (existingIter == null)
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index 58d0f17a3a..675ed64816 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -24,5 +24,5 @@
  */
 public interface RoutingAlgorithmFactory
 {
-    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );   
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index ae6609148f..e3e11cef2b 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -25,15 +25,14 @@
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
 {
     @Override
     public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {        
-        AbstractRoutingAlgorithm algo;
+    {
         String algoStr = opts.getAlgorithm();
         if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
         {
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index 22abb0004f..b461ed4c7b 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -15,18 +15,16 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
+
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- *
  * @author Peter Karich
  */
-class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState {
+class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
+{
     private final List<EdgeIteratorState> edges;
     private int current;
 
@@ -133,6 +131,12 @@ public EdgeIteratorState setName( String name )
         return edges.get(current).setName(name);
     }
 
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default)
+    {
+        return edges.get(current).getBoolean(key, reverse, _default);
+    }
+
     @Override
     public String toString()
     {
@@ -194,5 +198,5 @@ public void setSkippedEdges( int edge1, int edge2 )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
similarity index 72%
rename from core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
rename to core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index 9552052d02..15b276508a 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -15,14 +15,16 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 
 /**
  * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ * <p/>
+ * Note, this class is not suited for public use and can change with minor releases unexpectedly or
+ * even gets removed.
  */
-class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState {
+public class VirtualEdgeIteratorState implements EdgeIteratorState, EdgeSkipIterState
+{
     private final PointList pointList;
     private final int edgeId;
     private double distance;
@@ -30,9 +32,15 @@
     private String name;
     private final int baseNode;
     private final int adjNode;
+    private final int originalTraversalKey;
+    // indication if edges are dispreferred as start/stop edge 
+    private boolean unfavoredReverseEdge;
+    private boolean unfavored;
 
-    public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+
+    public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
     {
+        this.originalTraversalKey = originalTraversalKey;
         this.edgeId = edgeId;
         this.baseNode = baseNode;
         this.adjNode = adjNode;
@@ -42,6 +50,17 @@ public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance
         this.pointList = pointList;
     }
 
+    /**
+     * This method returns the original edge via its traversal key. I.e. also the direction is
+     * already correctly encoded.
+     * <p/>
+     * @see GHUtility#createEdgeKey(int, int, int, boolean)
+     */
+    public int getOriginalTraversalKey()
+    {
+        return originalTraversalKey;
+    }
+
     @Override
     public int getEdge()
     {
@@ -125,7 +144,33 @@ public EdgeIteratorState setName( String name )
         this.name = name;
         return this;
     }
+    
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default )
+    {
+        if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
+        {
+            if (reverse)
+                return unfavoredReverseEdge;
+            else
+                return unfavored;
+        }
+        // for non-existent keys return default
+        return _default;
+    }
 
+    /**
+     * set edge to unfavored status for routing from/to start/stop points
+     * @param reverse indicates if forward or backward direction is affected
+     */
+    public void setVirtualEdgePreference( boolean unfavored, boolean reverse )
+    {
+        if (reverse)
+              unfavoredReverseEdge = unfavored;
+        else
+            this.unfavored = unfavored;
+    }
+    
     @Override
     public String toString()
     {
@@ -191,5 +236,5 @@ public double getWeight()
     {
         throw new UnsupportedOperationException("Not supported.");
     }
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index d020cb5d8a..03a5aaeeb6 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -25,8 +25,8 @@
 /**
  * Recursivly unpack shortcuts.
  * <p/>
- * @see PrepareContractionHierarchies
  * @author Peter Karich
+ * @see PrepareContractionHierarchies
  */
 public class Path4CH extends PathBidirRef
 {
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 9fa3bf8ed4..1c2ec4c4bf 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -24,7 +24,7 @@
 
 /**
  * Used in CH preparation and therefor assumed that all edges are of type EdgeSkipIterState
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PreparationWeighting implements Weighting
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 114fd3da8d..c7c900cd97 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -27,7 +27,9 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -385,15 +387,16 @@ public void close()
         sortedNodes = null;
         oldPriorities = null;
     }
+
     AddShortcutHandler addScHandler = new AddShortcutHandler();
     CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
 
     interface ShortcutHandler
     {
         void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount );
+                            double existingDirectWeight, double distance,
+                            EdgeIterator outgoingEdges,
+                            int skippedEdge1, int incomingEdgeOrigCount );
 
         int getNode();
     }
@@ -420,9 +423,9 @@ public int getNode()
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double distance,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             shortcuts++;
             originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
@@ -452,9 +455,9 @@ public AddShortcutHandler setNode( int n )
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double existingDistSum,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double existingDistSum,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             // FOUND shortcut 
             // but be sure that it is the only shortcut in the collection 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index 6aee636cba..7fed0cca87 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -21,7 +21,7 @@
 /**
  * The flags are stored differently for shortcuts: just a weight and the direction flags. Currently
  * it is not allowed to store multiple vehicles.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PrepareEncoder
@@ -44,7 +44,7 @@ public static final long getScFwdDir()
     /**
      * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
      * changing the directions of flags1.
-     * <p>
+     * <p/>
      * @return true if flags2 is enabled in both directions or if both flags are pointing into the
      * same direction.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index fcd29bbe86..03801d4a92 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -24,6 +24,7 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.util.*;
+
 import java.util.*;
 
 /**
@@ -38,7 +39,7 @@
 public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
 {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-    private final static int K_FORWARD = 0, K_BACKWARD = 1;
+    protected final static int K_FORWARD = 0, K_BACKWARD = 1;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
@@ -68,24 +69,25 @@
 
     /* restriction definitions where order is important */
     protected final List<String> restrictions = new ArrayList<String>(5);
-    protected final HashSet<String> intendedValues = new HashSet<String>(5);
-    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected final HashSet<String> ferries = new HashSet<String>(5);
-    protected final HashSet<String> oneways = new HashSet<String>(5);
-    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+    protected final Set<String> intendedValues = new HashSet<String>(5);
+    protected final Set<String> restrictedValues = new HashSet<String>(5);
+    protected final Set<String> ferries = new HashSet<String>(5);
+    protected final Set<String> oneways = new HashSet<String>(5);
+    protected final Set<String> acceptedRailways = new HashSet<String>(5);
     // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
-    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+    protected final Set<String> absoluteBarriers = new HashSet<String>(5);
+    protected final Set<String> potentialBarriers = new HashSet<String>(5);
     private boolean blockByDefault = true;
     private boolean blockFords = true;
     protected final int speedBits;
     protected final double speedFactor;
 
-    public AbstractFlagEncoder(PMap properties) {
+    public AbstractFlagEncoder( PMap properties )
+    {
         throw new RuntimeException("This method must be overridden in derived classes");
     }
 
-    public AbstractFlagEncoder(String propertiesStr)
+    public AbstractFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -141,7 +143,7 @@ public boolean isBlockFords()
 
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineNodeBits( int index, int shift )
@@ -152,7 +154,6 @@ public int defineNodeBits( int index, int shift )
     /**
      * Defines bits used for edge flags used for access, speed etc.
      * <p/>
-     * @param index
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -179,7 +180,7 @@ public int defineWayBits( int index, int shift )
 
     /**
      * Defines the bits which are used for relation flags.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineRelationBits( int index, int shift )
@@ -290,15 +291,24 @@ public long setAccess( long flags, boolean forward, boolean backward )
     @Override
     public long setSpeed( long flags, double speed )
     {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed
+        if (speed < 0 || Double.isNaN(speed))
+            throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed
                     + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, false);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
+
         return speedEncoder.setDoubleValue(flags, speed);
     }
 
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        return setAccess(speedEncoder.setDoubleValue(flags, 0), false, false);
+    }
+
     @Override
     public double getSpeed( long flags )
     {
@@ -378,11 +388,24 @@ public boolean equals( Object obj )
     /**
      * @return the speed in km/h
      */
-    protected static double parseSpeed( String str )
+    protected double parseSpeed( String str )
     {
         if (Helper.isEmpty(str))
             return -1;
 
+        // on some German autobahns and a very few other places
+        if ("none".equals(str))
+            return 140;
+
+        if (str.endsWith(":rural") || str.endsWith(":trunk"))
+            return 80;
+
+        if (str.endsWith(":urban"))
+            return 50;
+
+        if (str.equals("walk") || str.endsWith(":living_street"))
+            return 6;
+
         try
         {
             int val;
@@ -555,7 +578,7 @@ long getNodeBitMask()
 
     /**
      * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
+     * <p/>
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -564,7 +587,7 @@ public int defineTurnBits( int index, int shift )
         if (maxTurnCosts == 0)
             return shift;
 
-        // optimization for turn restrictions only 
+        // optimization for turn restrictions only
         else if (maxTurnCosts == 1)
         {
             turnRestrictionBit = 1L << shift;
@@ -580,7 +603,7 @@ public final long getValue( long flags )
             {
                 // find value
                 flags &= mask;
-                flags >>= shift;
+                flags >>>= shift;
                 return flags;
             }
         };
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
index 5df84cfe62..6164434da5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -3,49 +3,52 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 
 /**
- * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * Approximates the distance to the goal node by weighting the beeline distance according to the
+ * distance weighting
+ * <p/>
  * @author jansoe
  */
-public class BeelineWeightApproximator implements WeightApproximator {
-
-    private NodeAccess nodeAccess;
-    private Weighting weighting;
-    private DistanceCalc distanceCalc;
-    double toLat, toLon;
-
-    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+public class BeelineWeightApproximator implements WeightApproximator
+{
+    private final NodeAccess nodeAccess;
+    private final Weighting weighting;
+    private DistanceCalc distanceCalc = Helper.DIST_EARTH;
+    private double toLat, toLon;
+
+    public BeelineWeightApproximator( NodeAccess nodeAccess, Weighting weighting )
+    {
         this.nodeAccess = nodeAccess;
         this.weighting = weighting;
-        setDistanceCalc(new DistanceCalcEarth());
     }
 
-    public void setGoalNode(int toNode){
+    @Override
+    public void setGoalNode( int toNode )
+    {
         toLat = nodeAccess.getLatitude(toNode);
         toLon = nodeAccess.getLongitude(toNode);
     }
 
     @Override
-    public WeightApproximator duplicate() {
+    public WeightApproximator duplicate()
+    {
         return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
     }
 
-
     @Override
-    public double approximate(int fromNode) {
-
-        double fromLat, fromLon, dist2goal, weight2goal;
-        fromLat  = nodeAccess.getLatitude(fromNode);
-        fromLon = nodeAccess.getLongitude(fromNode);
-        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
-        weight2goal = weighting.getMinWeight(dist2goal);
-
+    public double approximate( int fromNode )
+    {
+        double fromLat = nodeAccess.getLatitude(fromNode);
+        double fromLon = nodeAccess.getLongitude(fromNode);
+        double dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        double weight2goal = weighting.getMinWeight(dist2goal);
         return weight2goal;
     }
 
-    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
+    public BeelineWeightApproximator setDistanceCalc( DistanceCalc distanceCalc )
+    {
         this.distanceCalc = distanceCalc;
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 7d9786cac2..8f0d7eb0e4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -23,16 +23,17 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
+
 import static com.graphhopper.util.Helper.*;
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder
 {
-    private EncodedDoubleValue reverseSpeed;
+    private EncodedDoubleValue reverseSpeedEncoder;
 
     public Bike2WeightFlagEncoder()
     {
@@ -44,7 +45,7 @@ public Bike2WeightFlagEncoder( String propertiesStr )
         super(new PMap(propertiesStr));
     }
 
-    public Bike2WeightFlagEncoder(PMap properties)
+    public Bike2WeightFlagEncoder( PMap properties )
     {
         super(properties);
     }
@@ -55,7 +56,7 @@ public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -64,16 +65,16 @@ public short getVersion()
     public int defineWayBits( int index, int shift )
     {
         shift = super.defineWayBits(index, shift);
-        reverseSpeed = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, 
-                                               getHighwaySpeed("cycleway"), maxPossibleSpeed);
-        shift += reverseSpeed.getBits();
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                getHighwaySpeed("cycleway"), maxPossibleSpeed);
+        shift += reverseSpeedEncoder.getBits();
         return shift;
     }
 
     @Override
     public double getReverseSpeed( long flags )
     {
-        return reverseSpeed.getDoubleValue(flags);
+        return reverseSpeedEncoder.getDoubleValue(flags);
     }
 
     @Override
@@ -82,37 +83,36 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
-        return reverseSpeed.setDoubleValue(flags, speed);
+        return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
     @Override
-    public long handleSpeed( OSMWay way, double speed, long encoded )
+    public long handleSpeed( OSMWay way, double speed, long flags )
     {
         // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
-                && !way.hasTag("oneway:bicycle", "no")
-                && !way.hasTag("cycleway", oppositeLanes))
-        {
+        flags = super.handleSpeed(way, speed, flags);
+        if (isBackward(flags))
+            flags = setReverseSpeed(flags, speed);
 
-            if (way.hasTag("oneway", "-1"))
-            {
-                encoded |= backwardBit;
-                encoded = setReverseSpeed(encoded, speed);
-            } else
-            {
-                encoded |= forwardBit;
-                encoded = setSpeed(encoded, speed);
-            }
-        } else
-        {
-            encoded |= directionBitMask;
-            encoded = setSpeed(encoded, speed);
-            encoded = setReverseSpeed(encoded, speed);
-        }
-        return encoded;
+        if (isForward(flags))
+            flags = setSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
     }
 
     @Override
@@ -120,7 +120,7 @@ public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = super.flagsDefault(forward, backward);
         if (backward)
-            return reverseSpeed.setDefaultValue(flags);
+            return reverseSpeedEncoder.setDefaultValue(flags);
 
         return flags;
     }
@@ -142,7 +142,7 @@ public long reverseFlags( long flags )
         flags = super.reverseFlags(flags);
 
         // swap speeds 
-        double otherValue = reverseSpeed.getDoubleValue(flags);
+        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
         flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
         return setSpeed(flags, otherValue);
     }
@@ -169,9 +169,17 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double decEleSum = 0, decDist2DSum = 0;
             // double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
             double prevEle = pl.getElevation(0);
-            double fullDist2D = 0;
+            double fullDist2D = edge.getDistance();
+
+            if (Double.isInfinite(fullDist2D))
+            {
+                System.err.println("infinity distance? for way:" + way.getId());
+                return;
+            }
+            // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
+            if (fullDist2D < 1)
+                return;
 
-            fullDist2D = edge.getDistance();
             double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
             if (eleDelta > 0.1)
             {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 4e452e5033..af99b1f01e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
@@ -47,16 +49,22 @@
     protected final Set<String> preferHighwayTags = new HashSet<String>();
     protected final Set<String> avoidHighwayTags = new HashSet<String>();
     protected final Set<String> unpavedSurfaceTags = new HashSet<String>();
-    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
-    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> trackTypeSpeeds = new HashMap<String, Integer>();
+    private final Map<String, Integer> surfaceSpeeds = new HashMap<String, Integer>();
     private final Set<String> roadValues = new HashSet<String>();
-    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> highwaySpeeds = new HashMap<String, Integer>();
     // convert network tag of bicycle routes into a way route code
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
     protected EncodedValue relationCodeEncoder;
     private EncodedValue wayTypeEncoder;
     private EncodedValue preferWayEncoder;
 
+    // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
+    private int avoidSpeedLimit;
+
+    // This is the specific bicycle class
+    private String specificBicycleClass;
+
     protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
@@ -81,7 +89,6 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         // potentialBarriers.add("lift_gate");
         potentialBarriers.add("swing_gate");
 
-        absoluteBarriers.add("kissing_gate");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
@@ -116,7 +123,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         roadValues.add("secondary_link");
         roadValues.add("tertiary");
         roadValues.add("tertiary_link");
-        
+
         maxPossibleSpeed = 30;
 
         setTrackTypeSpeed("grade1", 18); // paved
@@ -155,8 +162,8 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setHighwaySpeed("living_street", 6);
         setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
 
-        setHighwaySpeed("cycleway", 25);
-        setHighwaySpeed("path", 18);
+        setHighwaySpeed("cycleway", 18);
+        setHighwaySpeed("path", 12);
         setHighwaySpeed("footway", 6);
         setHighwaySpeed("pedestrian", 6);
         setHighwaySpeed("track", 12);
@@ -189,10 +196,12 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
 
         setCyclingNetworkPreference("deprecated", PriorityCode.AVOID_AT_ALL_COSTS.getValue());
+
+        setAvoidSpeedLimit(71);
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -202,8 +211,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"),
-                                              maxPossibleSpeed);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeeds.get("cycleway"),
+                maxPossibleSpeed);
         shift += speedEncoder.getBits();
 
         unpavedBit = 1L << shift++;
@@ -245,7 +254,7 @@ public long acceptWay( OSMWay way )
             return 0;
         }
 
-        if (!highwaySpeed.containsKey(highwayValue))
+        if (!highwaySpeeds.containsKey(highwayValue))
             return 0;
 
         // use the way if it is tagged for bikes
@@ -339,9 +348,9 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
         } else
         {
             encoded = handleFerryTags(way,
-                    highwaySpeed.get("living_street"),
-                    highwaySpeed.get("track"),
-                    highwaySpeed.get("primary"));
+                    highwaySpeeds.get("living_street"),
+                    highwaySpeeds.get("track"),
+                    highwaySpeeds.get("primary"));
             encoded |= directionBitMask;
         }
         return encoded;
@@ -350,38 +359,47 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     int getSpeed( OSMWay way )
     {
         int speed = PUSHING_SECTION_SPEED;
+        String highwayTag = way.getTag("highway");
+        Integer highwaySpeed = highwaySpeeds.get(highwayTag);
+
         String s = way.getTag("surface");
         if (!Helper.isEmpty(s))
         {
-            Integer sInt = surfaceSpeed.get(s);
-            if (sInt != null)
-                speed = sInt;
+            Integer surfaceSpeed = surfaceSpeeds.get(s);
+            if (surfaceSpeed != null)
+            {
+                speed = surfaceSpeed;
+                // Boost handling for good surfaces
+                if (highwaySpeed != null && surfaceSpeed > highwaySpeed)
+                {
+                    // Avoid boosting if pushing section
+                    if (pushingSections.contains(highwayTag))
+                        speed = highwaySpeed;
+                    else
+                        speed = surfaceSpeed;
+                }
+            }
         } else
         {
             String tt = way.getTag("tracktype");
             if (!Helper.isEmpty(tt))
             {
-                Integer tInt = trackTypeSpeed.get(tt);
+                Integer tInt = trackTypeSpeeds.get(tt);
                 if (tInt != null)
                     speed = tInt;
             } else
             {
-                String highway = way.getTag("highway");
-                if (!Helper.isEmpty(highway))
+                if (highwaySpeed != null)
                 {
-                    Integer hwInt = highwaySpeed.get(highway);
-                    if (hwInt != null)
-                    {
-                        if (way.getTag("service") == null)
-                            speed = hwInt;
-                        else
-                            speed = highwaySpeed.get("living_street");
-                    }
+                    if (!way.hasTag("service"))
+                        speed = highwaySpeed;
+                    else
+                        speed = highwaySpeeds.get("living_street");
                 }
             }
         }
 
-        // Until now we assumed that the way is no pusing section
+        // Until now we assumed that the way is no pushing section
         // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
         if ((speed > PUSHING_SECTION_SPEED)
                 && (!way.hasTag("bicycle", intendedValues) && way.hasTag("highway", pushingSections)))
@@ -447,7 +465,7 @@ String getWayName( int pavementType, int wayType, Translation tr )
     /**
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
-     * <p>
+     * <p/>
      * @return new priority based on priorityFromRelation and on the tags in OSMWay.
      */
     protected int handlePriority( OSMWay way, int priorityFromRelation )
@@ -464,6 +482,39 @@ protected int handlePriority( OSMWay way, int priorityFromRelation )
         return weightToPrioMap.lastEntry().getValue();
     }
 
+    // Conversion of class value to priority. See http://wiki.openstreetmap.org/wiki/Class:bicycle
+    private PriorityCode convertCallValueToPriority( String tagvalue )
+    {
+        int classvalue;
+        try
+        {
+            classvalue = Integer.parseInt(tagvalue);
+        } catch (NumberFormatException e)
+        {
+            return PriorityCode.UNCHANGED;
+        }
+
+        switch (classvalue)
+        {
+            case 3:
+                return PriorityCode.BEST;
+            case 2:
+                return PriorityCode.VERY_NICE;
+            case 1:
+                return PriorityCode.PREFER;
+            case 0:
+                return PriorityCode.UNCHANGED;
+            case -1:
+                return PriorityCode.AVOID_IF_POSSIBLE;
+            case -2:
+                return PriorityCode.REACH_DEST;
+            case -3:
+                return PriorityCode.AVOID_AT_ALL_COSTS;
+            default:
+                return PriorityCode.UNCHANGED;
+        }
+    }
+
     /**
      * @param weightToPrioMap associate a weight with every priority. This sorted map allows
      * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
@@ -480,27 +531,49 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
         double maxSpeed = getMaxSpeed(way);
         if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
         {
-            weightToPrioMap.put(40d, PREFER.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(40d, UNCHANGED.getValue());
+            if (maxSpeed < avoidSpeedLimit)
+            {
+                weightToPrioMap.put(40d, PREFER.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+            }
+        } else
+        {
+            if (avoidHighwayTags.contains(highway) || ((maxSpeed >= avoidSpeedLimit) && (highway != "track")))
+            {
+                weightToPrioMap.put(50d, REACH_DEST.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            }
         }
 
         if (pushingSections.contains(highway)
                 || way.hasTag("bicycle", "use_sidepath")
                 || "parking_aisle".equals(service))
         {
-            weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+            if (way.hasTag("bicycle", "yes"))
+                weightToPrioMap.put(100d, UNCHANGED.getValue());
+            else
+                weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
         }
 
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
+        if (way.hasTag("railway", "tram"))
+            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+
+        String classBicycleSpecific = way.getTag(specificBicycleClass);
+        if (classBicycleSpecific != null)
+        {
+            // We assume that humans are better in classifying preferences compared to our algorithm above -> weight = 100
+            weightToPrioMap.put(100d, convertCallValueToPriority(classBicycleSpecific).getValue());
+        } else
         {
-            weightToPrioMap.put(50d, REACH_DEST.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            String classBicycle = way.getTag("class:bicycle");
+            if (classBicycle != null)
+            {
+                weightToPrioMap.put(100d, convertCallValueToPriority(classBicycle).getValue());
+            }
         }
 
-        if (way.hasTag("railway", "tram"))
-            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
     }
 
     /**
@@ -614,8 +687,10 @@ protected long handleSpeed( OSMWay way, double speed, long encoded )
 
         // handle oneways        
         boolean isOneway = way.hasTag("oneway", oneways)
+                || way.hasTag("oneway:bicycle", oneways)
                 || way.hasTag("vehicle:backward")
-                || way.hasTag("vehicle:forward");
+                || way.hasTag("vehicle:forward")
+                || way.hasTag("bicycle:forward");
 
         if ((isOneway || way.hasTag("junction", "roundabout"))
                 && !way.hasTag("oneway:bicycle", "no")
@@ -623,7 +698,9 @@ protected long handleSpeed( OSMWay way, double speed, long encoded )
                 && !way.hasTag("cycleway", oppositeLanes))
         {
             boolean isBackward = way.hasTag("oneway", "-1")
-                    || way.hasTag("vehicle:forward", "no");
+                    || way.hasTag("oneway:bicycle", "-1")
+                    || way.hasTag("vehicle:forward", "no")
+                    || way.hasTag("bicycle:forward", "no");
             if (isBackward)
                 encoded |= backwardBit;
             else
@@ -658,22 +735,22 @@ public int getValue()
 
     protected void setHighwaySpeed( String highway, int speed )
     {
-        highwaySpeed.put(highway, speed);
+        highwaySpeeds.put(highway, speed);
     }
 
     protected int getHighwaySpeed( String key )
     {
-        return highwaySpeed.get(key);
+        return highwaySpeeds.get(key);
     }
 
     void setTrackTypeSpeed( String tracktype, int speed )
     {
-        trackTypeSpeed.put(tracktype, speed);
+        trackTypeSpeeds.put(tracktype, speed);
     }
 
     void setSurfaceSpeed( String surface, int speed )
     {
-        surfaceSpeed.put(surface, speed);
+        surfaceSpeeds.put(surface, speed);
     }
 
     void setCyclingNetworkPreference( String network, int code )
@@ -694,4 +771,15 @@ public boolean supports( Class<?> feature )
 
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
+
+    public void setAvoidSpeedLimit( int limit )
+    {
+        avoidSpeedLimit = limit;
+    }
+
+    public void setSpecificBicycleClass( String subkey )
+    {
+        specificBicycleClass = "class:bicycle:" + subkey.toString();
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 0c1a2fedf9..3b635f04bb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -33,12 +33,12 @@ public BikeFlagEncoder()
         this(4, 2, 0);
     }
 
-    public BikeFlagEncoder(String propertiesString)
+    public BikeFlagEncoder( String propertiesString )
     {
         this(new PMap(propertiesString));
     }
 
-    public BikeFlagEncoder(PMap properties)
+    public BikeFlagEncoder( PMap properties )
     {
         this((int) properties.getLong("speedBits", 4),
                 properties.getLong("speedFactor", 2),
@@ -68,10 +68,13 @@ public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        absoluteBarriers.add("kissing_gate");
+        setSpecificBicycleClass("touring");
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 7b1889031d..39ae7d9d6c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -31,7 +31,7 @@
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  */
@@ -54,17 +54,16 @@ public CarFlagEncoder()
         this(5, 5, 0);
     }
 
-    public CarFlagEncoder(PMap properties) {
-        this(
-                (int)properties.getLong("speedBits", 5),
+    public CarFlagEncoder( PMap properties )
+    {
+        this((int) properties.getLong("speedBits", 5),
                 properties.getDouble("speedFactor", 5),
-                properties.getBool("turnCosts", false) ? 3 : 0
-        );
+                properties.getBool("turnCosts", false) ? 3 : 0);
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
     }
 
-    public CarFlagEncoder(String propertiesStr )
+    public CarFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -111,8 +110,8 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         badSurfaceSpeedMap.add("ground");
         badSurfaceSpeedMap.add("grass");
 
-        maxPossibleSpeed = 100;
-        
+        maxPossibleSpeed = 140;
+
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
@@ -141,7 +140,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -154,8 +153,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), 
-                                              maxPossibleSpeed);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"),
+                maxPossibleSpeed);
         return shift + speedEncoder.getBits();
     }
 
@@ -211,13 +210,18 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
index c7b67e7c68..483e4f837a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -1,7 +1,5 @@
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.NodeAccess;
-
 /**
  * Turns an unidirectional weight Approximation into a bidirectional consistent one.
  * <p/>
@@ -9,34 +7,35 @@
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
  * pages 291â296.
  * <p/>
- *
  * @author jansoe
  */
-public class ConsistentWeightApproximator {
-
-    private NodeAccess nodeAccess;
-    private Weighting weighting;
-    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+public class ConsistentWeightApproximator
+{
+    private final WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
 
-    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+    public ConsistentWeightApproximator( WeightApproximator weightApprox )
+    {
         uniDirApproximatorForward = weightApprox;
         uniDirApproximatorReverse = weightApprox.duplicate();
     }
 
-    public void setSourceNode(int sourceNode){
+    public void setSourceNode( int sourceNode )
+    {
         uniDirApproximatorReverse.setGoalNode(sourceNode);
     }
 
-    public void setGoalNode(int goalNode){
+    public void setGoalNode( int goalNode )
+    {
         uniDirApproximatorForward.setGoalNode(goalNode);
     }
 
-    public double approximate(int fromNode, boolean reverse)    {
-        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
-                                          - uniDirApproximatorReverse.approximate(fromNode));
-        if (reverse) {
+    public double approximate( int fromNode, boolean reverse )
+    {
+        double weightApproximation = 0.5
+                * (uniDirApproximatorForward.approximate(fromNode) - uniDirApproximatorReverse.approximate(fromNode));
+
+        if (reverse)
             weightApproximation *= -1;
-        }
 
         return weightApproximation;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index f00dc17928..e5233e75f0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -55,7 +55,10 @@ public long setDefaultValue( long flags )
 
     public long setDoubleValue( long flags, double value )
     {
-        // scale value        
+        if (Double.isNaN(value))
+            throw new IllegalStateException("Value cannot be NaN");
+
+        // scale value
         long tmpValue = Math.round(value / factor);
         checkValue(Math.round(tmpValue * factor));
         tmpValue <<= shift;
@@ -71,13 +74,13 @@ public double getDoubleValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return flags * factor;
     }
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedDoubleValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index d2c961bf15..d96090e13f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -92,7 +92,7 @@ public long getValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return Math.round(flags * factor);
     }
 
@@ -113,7 +113,7 @@ public long getMaxValue()
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index f1e3b2d090..573d1b4a99 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -26,7 +26,6 @@
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
-import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
@@ -163,8 +162,10 @@ else if (entry.equals(MOTORCYCLE))
             else
                 throw new IllegalArgumentException("entry in encoder list not supported " + entry);
 
-            if (configuration.has("version")) {
-                if (fe.getVersion() != configuration.getLong("version", -1)) {
+            if (configuration.has("version"))
+            {
+                if (fe.getVersion() != configuration.getInt("version", -1))
+                {
                     throw new IllegalArgumentException("Encoder " + entry + " was used in version "
                             + configuration.getLong("version", -1) + ", but current version is " + fe.getVersion());
                 }
@@ -176,7 +177,7 @@ else if (entry.equals(MOTORCYCLE))
     }
 
     private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via osmreader.bytesForFlags=8";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytesForFlags=8";
 
     private void registerEncoder( AbstractFlagEncoder encoder )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 3a5a7f1632..2850ef17bb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -18,11 +18,13 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
  * in seconds.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class FastestWeighting implements Weighting
@@ -32,15 +34,23 @@
      * costs or traffic light costs etc)
      */
     protected final static double SPEED_CONV = 3.6;
+    final static double DEFAULT_HEADING_PENALTY = 300; //[s]
+    private final double heading_penalty;
     protected final FlagEncoder encoder;
     private final double maxSpeed;
 
-    public FastestWeighting( FlagEncoder encoder )
+    public FastestWeighting( FlagEncoder encoder, PMap pMap )
     {
         this.encoder = encoder;
+        heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
         maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
+    public FastestWeighting( FlagEncoder encoder )
+    {
+        this(encoder, new PMap(0));
+    }
+
     @Override
     public double getMinWeight( double distance )
     {
@@ -49,11 +59,19 @@ public double getMinWeight( double distance )
 
     @Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {        
+    {
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / speed * SPEED_CONV;
+
+        double time = edge.getDistance() / speed * SPEED_CONV;
+
+        // add direction penalties at start/stop/via points
+        boolean penalizeEdge = edge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, reverse, false);
+        if (penalizeEdge)
+            time += heading_penalty;
+
+        return time;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 43d6bfa75b..cb024b32d9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -29,9 +29,9 @@
 public interface FlagEncoder extends TurnCostEncoder
 {
     /**
-     * @return short
+     * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are introduced
      */
-    short getVersion();
+    int getVersion();
 
     /**
      * @return the maximum speed in km/h
@@ -45,7 +45,7 @@
 
     /**
      * Sets the speed in km/h.
-     * <p>
+     * <p/>
      * @return modified setProperties
      */
     long setSpeed( long flags, double speed );
@@ -62,14 +62,14 @@
 
     /**
      * Sets the access of the edge.
-     * <p>
+     * <p/>
      * @return modified flags
      */
     long setAccess( long flags, boolean forward, boolean backward );
 
     /**
      * Sets speed and access properties.
-     * <p>
+     * <p/>
      * @return created flags
      */
     long setProperties( double speed, boolean forward, boolean backward );
@@ -110,7 +110,7 @@
     long setLong( long flags, int key, long value );
 
     /**
-     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * Returns arbitrary double value identified by the specified key. E.g. can be used to return the
      * maximum width or height allowed for an edge.
      */
     double getDouble( long flags, int key );
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 19f7ad277d..2412ce41a8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -25,11 +25,12 @@
 import com.graphhopper.util.PMap;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.*;
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  * @author Karl HÃ¼bner
@@ -56,16 +57,17 @@ public FootFlagEncoder()
         this(4, 1);
     }
 
-    public FootFlagEncoder(PMap properties) {
+    public FootFlagEncoder( PMap properties )
+    {
         this(
-                (int)properties.getLong("speedBits", 4),
+                (int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 1)
         );
         this.properties = properties;
         this.setBlockFords(properties.getBool("blockFords", true));
     }
 
-    public FootFlagEncoder(String propertiesStr )
+    public FootFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -126,12 +128,12 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         hikingNetworkToCode.put("nwn", BEST.getValue());
         hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
         hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
-        
+
         maxPossibleSpeed = FERRY_SPEED;
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -168,7 +170,7 @@ public int defineTurnBits( int index, int shift )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return <code>false</code>
      */
     @Override
@@ -179,7 +181,7 @@ public boolean isTurnRestricted( long flag )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return 0
      */
     @Override
@@ -197,7 +199,6 @@ public long getTurnFlags( boolean restricted, double costs )
     /**
      * Some ways are okay but not separate for pedestrians.
      * <p/>
-     * @param way
      */
     @Override
     public long acceptWay( OSMWay way )
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index 917ef86a7b..34d1da2056 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -22,11 +22,12 @@
 import com.graphhopper.util.PMap;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.HashSet;
 
 /**
  * Defines bit layout for motorbikes
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoder extends CarFlagEncoder
@@ -36,9 +37,10 @@
     private final HashSet<String> avoidSet = new HashSet<String>();
     private final HashSet<String> preferSet = new HashSet<String>();
 
-    public MotorcycleFlagEncoder(PMap properties) {
+    public MotorcycleFlagEncoder( PMap properties )
+    {
         this(
-                (int)properties.getLong("speedBits", 5),
+                (int) properties.getLong("speedBits", 5),
                 properties.getDouble("speedFactor", 5),
                 properties.getBool("turnCosts", false) ? 3 : 0
         );
@@ -46,7 +48,7 @@ public MotorcycleFlagEncoder(PMap properties) {
         this.setBlockFords(properties.getBool("blockFords", true));
     }
 
-    public MotorcycleFlagEncoder(String propertiesStr )
+    public MotorcycleFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -72,8 +74,8 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         avoidSet.add("motorroad");
         preferSet.add("primary");
         preferSet.add("secondary");
-        
-        maxPossibleSpeed = 100;
+
+        maxPossibleSpeed = 120;
 
         // autobahn
         defaultSpeedMap.put("motorway", 100);
@@ -103,7 +105,7 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -116,8 +118,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, 
-                                                     defaultSpeedMap.get("secondary"), maxPossibleSpeed);
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                defaultSpeedMap.get("secondary"), maxPossibleSpeed);
         shift += reverseSpeedEncoder.getBits();
 
         preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
@@ -157,13 +159,17 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -239,12 +245,24 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
         return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
+    }
+
     @Override
     public long flagsDefault( boolean forward, boolean backward )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index 97c9aa2574..5f5c36b335 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -41,9 +41,10 @@ public MountainBikeFlagEncoder()
         this(4, 2, 0);
     }
 
-    public MountainBikeFlagEncoder(PMap properties) {
+    public MountainBikeFlagEncoder( PMap properties )
+    {
         this(
-                (int)properties.getLong("speedBits", 4),
+                (int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 2),
                 properties.getBool("turnCosts", false) ? 3 : 0
         );
@@ -51,7 +52,7 @@ public MountainBikeFlagEncoder(PMap properties) {
         this.setBlockFords(properties.getBool("blockFords", true));
     }
 
-    public MountainBikeFlagEncoder(String propertiesStr )
+    public MountainBikeFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -141,10 +142,13 @@ public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCo
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        potentialBarriers.add("kissing_gate");
+        setSpecificBicycleClass("mtb");
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
@@ -191,7 +195,7 @@ boolean allowedSacScale( String sacScale )
 
     @Override
     public String toString()
-    {        
+    {
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index a02bf36a83..f061e27043 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -21,6 +21,7 @@
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.*;
+
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -77,7 +78,7 @@ public void doWork()
         keepLargeNetworks(map);
 
         int unvisitedDeadEnds = -1;
-        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+        if (minOneWayNetworkSize > 0 && singleEncoder != null)
             unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
@@ -148,11 +149,12 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
      */
     void keepLargeNetworks( Map<Integer, Integer> map )
     {
-        if (map.size() < 2)
+        if (map.size() <= 1)
             return;
 
         int biggestStart = -1;
         int maxCount = -1;
+        int allRemoved = 0;
         GHBitSetImpl bs = new GHBitSetImpl(g.getNodes());
         for (Entry<Integer, Integer> e : map.entrySet())
         {
@@ -163,32 +165,42 @@ void keepLargeNetworks( Map<Integer, Integer> map )
                 continue;
             }
 
+            int removed;
             if (maxCount < e.getValue())
             {
                 // new biggest area found. remove old
-                removeNetwork(biggestStart, maxCount, bs);
+                removed = removeNetwork(biggestStart, maxCount, bs);
 
                 biggestStart = e.getKey();
                 maxCount = e.getValue();
             } else
             {
-                removeNetwork(e.getKey(), e.getValue(), bs);
+                removed = removeNetwork(e.getKey(), e.getValue(), bs);
             }
+
+            allRemoved += removed;
+            if (removed > g.getNodes() / 3)
+                throw new IllegalStateException("Too many nodes were removed: " + removed + ", all nodes:" + g.getNodes() + ", all removed:" + allRemoved);
         }
+
+        if (allRemoved > g.getNodes() / 2)
+            throw new IllegalStateException("Too many total nodes were removed: " + allRemoved + ", all nodes:" + g.getNodes());
     }
 
     /**
      * Deletes the complete subnetwork reachable through start
      */
-    void removeNetwork( int start, int entries, final GHBitSet bs )
+    int removeNetwork( int start, int entries, final GHBitSet bs )
     {
         if (entries >= minNetworkSize)
         {
             // logger.info("did not remove large network (" + entries + ")");
-            return;
+            return 0;
         }
+
+        final AtomicInteger removed = new AtomicInteger(0);
         EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new DepthFirstSearch()
+        new BreadthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -200,9 +212,33 @@ protected GHBitSet createBitSet()
             protected boolean goFurther( int nodeId )
             {
                 g.markNodeRemoved(nodeId);
+                removed.incrementAndGet();
                 return super.goFurther(nodeId);
             }
         }.start(explorer, start);
+
+        if (entries != removed.get())
+            throw new IllegalStateException("Did not expect " + removed.get() + " removed nodes; "
+                    + " Expected:" + entries + ", all nodes:" + g.getNodes() + "; "
+                    + " Neighbours:" + toString(explorer.setBaseNode(start)) + "; "
+                    + " Start:" + start + "  (" + g.getNodeAccess().getLat(start) + "," + g.getNodeAccess().getLon(start) + ")");
+
+        return removed.get();
+    }
+
+    String toString( EdgeIterator iter )
+    {
+        String str = "";
+        while (iter.next())
+        {
+            int adjNode = iter.getAdjNode();
+            str += adjNode + " (" + g.getNodeAccess().getLat(adjNode) + "," + g.getNodeAccess().getLon(adjNode) + "), ";
+            str += "speed  (fwd:" + singleEncoder.getSpeed(iter.getFlags()) + ", rev:" + singleEncoder.getReverseSpeed(iter.getFlags()) + "), ";
+            str += "access (fwd:" + singleEncoder.isForward(iter.getFlags()) + ", rev:" + singleEncoder.isBackward(iter.getFlags()) + "), ";
+            str += "distance:" + iter.getDistance();
+            str += ";\n ";
+        }
+        return str;
     }
 
     /**
@@ -228,21 +264,21 @@ int removeZeroDegreeNodes()
     }
 
     /**
-     * Clean small networks that will be never be visited by this explorer See #86 For example,
+     * Clean small networks that will be never be visited by this explorer See #86 for example,
      * small areas like parking lots are sometimes connected to the whole network through a one-way
-     * road. This is clearly an error - but is causes the routing to fail when point get connected
-     * to this small area. This routines removed all these points from the graph.
+     * road. This is clearly an error - but is causes the routing to fail when a point gets
+     * connected to this small area. This routine removes all these points from the graph.
      * <p/>
-     * @return number of removed nodes;
+     * @return number of removed nodes
      */
     public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
     {
-        // Partition g into strongly connected components using Tarjan's Algorithm.
+        // Partition g into strongly connected components using Tarjan's algorithm.
         final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
         List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
 
         // remove components less than minimum size
-        int removed = 0;
+        int removedNodes = 0;
         for (TIntArrayList component : components)
         {
             if (component.size() < minOneWayNetworkSize)
@@ -250,10 +286,10 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
                 for (int i = 0; i < component.size(); i++)
                 {
                     g.markNodeRemoved(component.get(i));
-                    removed++;
+                    removedNodes++;
                 }
             }
         }
-        return removed;
+        return removedNodes;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index e21eab1310..4d1b653244 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -20,7 +20,7 @@
 /**
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum PriorityCode
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
index 1b20c872a4..fa0bae4eef 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -19,10 +19,11 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Special weighting for (motor)bike
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PriorityWeighting extends FastestWeighting
@@ -32,9 +33,14 @@
      */
     public static final int KEY = 101;
 
+    public PriorityWeighting( FlagEncoder encoder, PMap pMap )
+    {
+        super(encoder, pMap);
+    }
+
     public PriorityWeighting( FlagEncoder encoder )
     {
-        super(encoder);
+        this(encoder, new PMap(0));
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index 530e7bde62..2d72a23410 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -21,6 +21,7 @@
 import com.graphhopper.util.PMap;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.TreeMap;
 
 /**
@@ -36,9 +37,10 @@ public RacingBikeFlagEncoder()
         this(4, 2, 0);
     }
 
-    public RacingBikeFlagEncoder(PMap properties) {
+    public RacingBikeFlagEncoder( PMap properties )
+    {
         this(
-                (int)properties.getLong("speedBits", 4),
+                (int) properties.getLong("speedBits", 4),
                 properties.getDouble("speedFactor", 2),
                 properties.getBool("turnCosts", false) ? 3 : 0
         );
@@ -46,7 +48,7 @@ public RacingBikeFlagEncoder(PMap properties) {
         this.setBlockFords(properties.getBool("blockFords", true));
     }
 
-    public RacingBikeFlagEncoder(String propertiesStr )
+    public RacingBikeFlagEncoder( String propertiesStr )
     {
         this(new PMap(propertiesStr));
     }
@@ -125,10 +127,16 @@ public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
         setCyclingNetworkPreference("lcn", PriorityCode.UNCHANGED.getValue());
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+
+        absoluteBarriers.add("kissing_gate");
+
+        setAvoidSpeedLimit(81);
+        setSpecificBicycleClass("roadcycling");
+
     }
 
     @Override
-    public short getVersion()
+    public int getVersion()
     {
         return 1;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index 418caed170..3309065849 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -34,7 +34,7 @@ public double getMinWeight( double currDistToGoal )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         return edgeState.getDistance();
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
index 1eff527304..4d028882a8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -13,12 +13,13 @@
 /**
  * Implementation of Tarjan's algorithm using an explicit stack.
  * (The traditional recursive approach runs into stack overflow pretty quickly.)
- *
+ * <p/>
  * Used for finding strongly connected components to detect dead-ends.
- *
+ * <p/>
  * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
  */
-public class TarjansStronglyConnectedComponentsAlgorithm {
+public class TarjansStronglyConnectedComponentsAlgorithm
+{
 
     private final GraphStorage g;
     private final TIntArrayStack nodeStack;
@@ -30,7 +31,8 @@
     private int index = 1;
     private final EdgeFilter edgeFilter;
 
-    public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final EdgeFilter edgeFilter) {
+    public TarjansStronglyConnectedComponentsAlgorithm( final GraphStorage g, final EdgeFilter edgeFilter )
+    {
         this.g = g;
         this.nodeStack = new TIntArrayStack();
         this.onStack = new GHBitSetImpl(g.getNodes());
@@ -42,11 +44,14 @@ public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final E
     /**
      * Find and return list of all strongly connected components in g.
      */
-    public List<TIntArrayList> findComponents() {
+    public List<TIntArrayList> findComponents()
+    {
 
         int nodes = g.getNodes();
-        for (int start = 0; start < nodes; start++) {
-            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start)) {
+        for (int start = 0; start < nodes; start++)
+        {
+            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start))
+            {
                 strongConnect(start);
             }
         }
@@ -55,29 +60,33 @@ public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final E
     }
 
     // Find all components reachable from firstNode, add them to 'components'
-    private void strongConnect(int firstNode) {
+    private void strongConnect( int firstNode )
+    {
         final Stack<TarjanState> stateStack = new Stack<TarjanState>();
         stateStack.push(TarjanState.startState(firstNode));
 
         // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
         nextState:
 
-        while (!stateStack.empty()) {
+        while (!stateStack.empty())
+        {
             TarjanState state = stateStack.pop();
             final int start = state.start;
             final EdgeIterator iter;
 
-            if (state.isStart()) {
+            if (state.isStart())
+            {
                 // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
                 nodeIndex[start] = index;
                 nodeLowLink[start] = index;
-                index ++;
+                index++;
                 nodeStack.push(start);
                 onStack.set(start);
 
                 iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
 
-            } else { // if (state.isResume()) {
+            } else
+            { // if (state.isResume()) {
 
                 // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
                 iter = state.iter;
@@ -91,23 +100,27 @@ private void strongConnect(int firstNode) {
             while (iter.next())
             {
                 int connectedId = iter.getAdjNode();
-                if (nodeIndex[connectedId] == 0) {
+                if (nodeIndex[connectedId] == 0)
+                {
                     // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
                     // Ideally we'd just call strongConnectIterative(connectedId);
                     stateStack.push(TarjanState.resumeState(start, iter));
                     stateStack.push(TarjanState.startState(connectedId));
                     continue nextState;
-                } else if (onStack.contains(connectedId)) {
+                } else if (onStack.contains(connectedId))
+                {
                     nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
                 }
             }
 
             // If nodeLowLink == nodeIndex, then we are the first element in a component.
             // Add all nodes higher up on nodeStack to this component.
-            if (nodeIndex[start] == nodeLowLink[start]) {
+            if (nodeIndex[start] == nodeLowLink[start])
+            {
                 TIntArrayList component = new TIntArrayList();
                 int node;
-                while ((node = nodeStack.pop()) != start) {
+                while ((node = nodeStack.pop()) != start)
+                {
                     component.add(node);
                     onStack.clear(node);
                 }
@@ -121,23 +134,30 @@ private void strongConnect(int firstNode) {
 
     // Internal stack state of algorithm, used to avoid recursive function calls and hitting stack overflow exceptions.
     // State is either 'start' for new nodes or 'resume' for partially traversed nodes.
-    private static class TarjanState {
+    private static class TarjanState
+    {
         final int start;
         final EdgeIterator iter;
 
         // Iterator only present in 'resume' state.
-        boolean isStart() { return iter == null; }
+        boolean isStart()
+        {
+            return iter == null;
+        }
 
-        private TarjanState(final int start, final EdgeIterator iter) {
+        private TarjanState( final int start, final EdgeIterator iter )
+        {
             this.start = start;
             this.iter = iter;
         }
 
-        public static TarjanState startState(int start) {
+        public static TarjanState startState( int start )
+        {
             return new TarjanState(start, null);
         }
 
-        public static TarjanState resumeState(int start, EdgeIterator iter) {
+        public static TarjanState resumeState( int start, EdgeIterator iter )
+        {
             return new TarjanState(start, iter);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 66d437d1ac..9638077bd0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -25,6 +25,7 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -45,7 +46,7 @@ public TestAlgoCollector( String name )
     }
 
     public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
-            OneRun oneRun )
+                                             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
         QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index 20738fd6a9..97016e72c9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
+
 import java.util.Arrays;
 
 /**
@@ -27,7 +28,7 @@
  * Different options define how precise turn restrictions and costs are taken into account, but
  * still all are without via-way support. BTW: this would not be done at runtime, this would be a
  * pre-processing step to avoid performance penalities.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum TraversalMode
@@ -73,7 +74,7 @@
      * Returns the identifier to access the map of the shortest path tree according to the traversal
      * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
      * in edge-based behavior
-     * <p>
+     * <p/>
      * @param iterState the current {@link EdgeIteratorState}
      * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
      * backward searches in bidirectional algorithms.
@@ -86,12 +87,35 @@ public final int createTraversalId( EdgeIteratorState iterState, boolean reverse
             if (noOfStates == 1)
                 return iterState.getEdge();
 
-            return GHUtility.createEdgeKey(iterState.getAdjNode(), iterState.getBaseNode(), iterState.getEdge(), reverse);
+            return GHUtility.createEdgeKey(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
         }
 
         return iterState.getAdjNode();
     }
 
+    /**
+     * If you have an EdgeIteratorState the other createTraversalId is preferred!
+     */
+    public final int createTraversalId( int baseNode, int adjNode, int edgeId, boolean reverse )
+    {
+        if (edgeBased)
+        {
+            if (noOfStates == 1)
+                return edgeId;
+
+            return GHUtility.createEdgeKey(baseNode, adjNode, edgeId, reverse);
+        }
+
+        return adjNode;
+    }
+
+    public int reverseEdgeKey( int edgeKey )
+    {
+        if (edgeBased && noOfStates > 1)
+            return GHUtility.reverseEdgeKey(edgeKey);
+        return edgeKey;
+    }
+
     public int getNoOfStates()
     {
         return noOfStates;
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index ca8ce6cb7c..fa769794f9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -19,7 +19,7 @@
 
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
- * <p>
+ * <p/>
  * @author Karl HÃ¼bner
  */
 public interface TurnCostEncoder
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index bde1c79da6..9372701727 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -23,7 +23,7 @@
 
 /**
  * Provides methods to retrieve turn costs for a specific turn.
- * <p>
+ * <p/>
  * @author Karl HÃ¼bner
  * @author Peter Karich
  */
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
index f471be0d07..9941a97067 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -11,9 +11,9 @@
     /**
      * @return minimal weight fromNode to the goalNode
      */
-    double approximate(int fromNode);
+    double approximate( int fromNode );
 
-    void setGoalNode(int to);
+    void setGoalNode( int to );
 
     /**
      * makes a deep copy of itself
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index b69f61d8f7..3caa6064ff 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -20,7 +20,6 @@
 import com.graphhopper.util.PMap;
 
 /**
- *
  * @author Peter Karich
  */
 public class WeightingMap extends PMap
@@ -31,8 +30,7 @@ public WeightingMap()
 
     /**
      * Convenient constructor if only one parameter is provided
-     * <p>
-     * @param weighting
+     * <p/>
      */
     public WeightingMap( String weighting )
     {
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index 06239cf252..f1db4c9024 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index 71c10990cc..ec619f6c6f 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -56,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(4));
             return true;
         }
 
@@ -87,10 +87,6 @@ public long put( String name )
         bytePointer++;
         names.setBytes(bytePointer, bytes, bytes.length);
         bytePointer += bytes.length;
-        if (bytePointer < 0)
-        {
-            throw new IllegalStateException("Way index is too large. Cannot contain more than 2GB");
-        }
         lastName = name;
         lastIndex = oldPointer;
         return oldPointer;
@@ -123,13 +119,12 @@ public long put( String name )
     public String get( long pointer )
     {
         if (pointer < 0)
-        {
-            throw new IllegalStateException("pointer cannot be negative:" + pointer);
-        }
+            throw new IllegalStateException("Pointer to access NameIndex cannot be negative:" + pointer);
+
+        // default
         if (pointer == 0)
-        {
             return "";
-        }
+
         byte[] sizeBytes = new byte[1];
         names.getBytes(pointer, sizeBytes, 1);
         int size = sizeBytes[0] & 0xFF;
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 164da777d0..1332f2b5a8 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 1839ce1f43..846cb2ecde 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -76,7 +77,7 @@ public void close()
     public boolean isClosed()
     {
         return closed;
-    }        
+    }
 
     @Override
     public void setHeader( int bytePos, int value )
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 21fbf67926..e551b2f593 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -21,10 +21,7 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterator;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 
 /**
@@ -175,6 +172,12 @@ public EdgeIteratorState setName( String name )
                 return tmpIter.setName(name);
             }
 
+            @Override
+            public boolean getBoolean(int key, boolean reverse, boolean _default)
+            {
+                return tmpIter.getBoolean(key, reverse, _default);
+            }
+
             @Override
             public int getAdditionalField()
             {
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index a1d337c3d8..13117929fd 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -61,7 +61,9 @@
     {
         HEAP, MMAP, UNSAFE /*, DIRECT */
 
-    };
+    }
+
+    ;
     private final MemRef memRef;
     private final boolean storing;
     private final boolean integ;
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index b22c593851..0810cfe126 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -94,11 +94,11 @@
     /**
      * Ensures that the capacity of this object is at least the specified bytes. The first time you
      * have to call 'create' instead.
-     * <p>
-     * @see #create(long)
+     * <p/>
      * @return true if size was increased
+     * @see #create(long)
      */
-    boolean ensureCapacity(long bytes);
+    boolean ensureCapacity( long bytes );
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 822f967a9f..43c1f7d36a 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -51,6 +51,7 @@
      * Renames the specified DataAccess object into one.
      */
     // DataAccess rename( DataAccess da, String newName );
+
     /**
      * Removes the specified object from the directory.
      */
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 8309be2a94..4b01333f0f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
 import java.util.Collection;
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index b075f3864f..3aa1a0a5f5 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -22,7 +22,7 @@
 
 /**
  * A helper class for GraphHopperStorage for its node access.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 class GHNodeAccess implements NodeAccess
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 65e9c63b26..7bdd3ce8ac 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -102,7 +102,7 @@
 
     /**
      * Copy this Graph into the specified Graph g.
-     * <p>
+     * <p/>
      * @return the specified GraphStorage g
      */
     Graph copyTo( Graph g );
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index ca0dddb46c..fc47fe77d2 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -24,16 +24,11 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 
 import static com.graphhopper.util.Helper.nf;
+
 import java.io.UnsupportedEncodingException;
 
 /**
@@ -47,9 +42,9 @@
  * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
  * loadExisting, (4) usage, (5) flush, (6) close
  * <p/>
+ * @author Peter Karich
  * @see GraphBuilder Use the GraphBuilder class to create a (Level)GraphStorage easier.
  * @see LevelGraphStorage
- * @author Peter Karich
  */
 public class GraphHopperStorage implements GraphStorage
 {
@@ -105,7 +100,7 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
     }
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
-            GraphExtension extendedStorage )
+                               GraphExtension extendedStorage )
     {
         if (encodingManager == null)
             throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
@@ -320,7 +315,7 @@ public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirect
 
     /**
      * Create edge between nodes a and b
-     * <p>
+     * <p/>
      * @return EdgeIteratorState of newly created edge
      */
     @Override
@@ -369,7 +364,7 @@ void setEdgeCount( int cnt )
 
     /**
      * Determine next free edgeId and ensure byte capacity to store edge
-     * <p>
+     * <p/>
      * @return next free edgeId
      */
     private int nextEdge()
@@ -411,6 +406,10 @@ private long writeEdge( int edge, int nodeThis, int nodeOther, int nextEdge, int
             nextEdgeOther = tmp;
         }
 
+        if (edge < 0 || edge == EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("Cannot write edge with illegal ID:" + edge
+                    + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
+
         long edgePointer = (long) edge * edgeEntryBytes;
         edges.setInt(edgePointer + E_NODEA, nodeThis);
         edges.setInt(edgePointer + E_NODEB, nodeOther);
@@ -621,14 +620,17 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            long nameIndexRef = nameIndex.put(name);
-            if (nameIndexRef < 0)
-                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
-
-            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
+            GraphHopperStorage.this.setName(edgePointer, name);
             return this;
         }
 
+        @Override
+        public boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
         @Override
         public EdgeIteratorState detach( boolean reverseArg )
         {
@@ -893,13 +895,16 @@ public String getName()
         }
 
         @Override
-        public EdgeIteratorState setName( String name )
+        public boolean getBoolean( int key, boolean reverse, boolean _default )
         {
-            long nameIndexRef = nameIndex.put(name);
-            if (nameIndexRef < 0)
-                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+            // for non-existent keys return default
+            return _default;
+        }
 
-            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
+        @Override
+        public EdgeIteratorState setName( String name )
+        {
+            GraphHopperStorage.this.setName(edgePointer, name);
             return this;
         }
 
@@ -1059,6 +1064,15 @@ private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode,
         return pillarNodes;
     }
 
+    private void setName( long edgePointer, String name )
+    {
+        long nameIndexRef = nameIndex.put(name);
+        if (nameIndexRef < 0)
+            throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+        edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
+    }
+
     @Override
     public Graph copyTo( Graph g )
     {
@@ -1200,7 +1214,7 @@ private void invalidateEdge( long edgePointer )
     private void inPlaceNodeRemove( int removeNodeCount )
     {
         // Prepare edge-update of nodes which are connected to deleted nodes        
-        int toMoveNode = getNodes();
+        int toMoveNodes = getNodes();
         int itemsToMove = 0;
 
         // sorted map when we access it via keyAt and valueAt - see below!
@@ -1220,15 +1234,15 @@ private void inPlaceNodeRemove( int removeNodeCount )
                 toRemoveSet.add(delEdgesIter.getAdjNode());
             }
 
-            toMoveNode--;
-            for (; toMoveNode >= 0; toMoveNode--)
+            toMoveNodes--;
+            for (; toMoveNodes >= 0; toMoveNodes--)
             {
-                if (!removedNodes.contains(toMoveNode))
+                if (!removedNodes.contains(toMoveNodes))
                     break;
             }
 
-            if (toMoveNode >= removeNode)
-                oldToNewMap.put(toMoveNode, removeNode);
+            if (toMoveNodes >= removeNode)
+                oldToNewMap.put(toMoveNodes, removeNode);
 
             itemsToMove++;
         }
@@ -1326,6 +1340,9 @@ private void inPlaceNodeRemove( int removeNodeCount )
                 setWayGeometry(fetchWayGeometry(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
 
+        if (removeNodeCount >= nodeCount)
+            throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
+
         // we do not remove the invalid edges => edgeCount stays the same!
         nodeCount -= removeNodeCount;
 
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index a4f7477a90..571efa3eb2 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -27,8 +27,8 @@
  * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
  * storage to hold the level of a node and a shortcut edge per edge.
  * <p/>
- * @see GraphBuilder
  * @author Peter Karich
+ * @see GraphBuilder
  */
 public class LevelGraphStorage extends GraphHopperStorage implements LevelGraph
 {
@@ -275,7 +275,7 @@ long reverseFlags( long edgePointer, long flags )
     /**
      * Disconnects the edges (higher->lower node) via the specified edgeState pointing from lower to
      * higher node.
-     * <p>
+     * <p/>
      * @param edgeState the edge from lower to higher
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
@@ -417,7 +417,7 @@ final double getWeight( EdgeSkipIterState edge )
         if (!edge.isShortcut())
             throw new IllegalStateException("getWeight is only available for shortcuts");
 
-        double weight = (edge.getFlags() >> 2) / WEIGHT_FACTOR;
+        double weight = (edge.getFlags() >>> 2) / WEIGHT_FACTOR;
         if (weight >= MAX_WEIGHT)
             return Double.POSITIVE_INFINITY;
 
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
index ca9c118e67..471b1277ac 100644
--- a/core/src/main/java/com/graphhopper/storage/Lock.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -20,7 +20,7 @@
 
 /**
  * A write lock. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface Lock
@@ -32,6 +32,6 @@
     boolean isLocked();
 
     void release();
-    
+
     Exception getObtainFailedReason();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 324168122c..989abf6218 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -32,7 +33,7 @@
 
 /**
  * This is a data structure which uses the operating system to synchronize between disc and memory.
- * Use SynchDAWrapper if you intent to use this from multiple threads!
+ * Use {@link SynchedDAWrapper} if you intent to use this from multiple threads!
  * <p/>
  * @author Peter Karich
  */
@@ -171,7 +172,7 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         ByteBuffer buf = null;
         IOException ioex = null;
         // One retry if it fails. It could fail e.g. if previously buffer wasn't yet unmapped from the jvm
-        for (int trial = 0; trial < 1;)
+        for (int trial = 0; trial < 1; )
         {
             try
             {
@@ -299,7 +300,7 @@ void close( boolean forceClean )
     @Override
     public final void setInt( long bytePos, int value )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         segments.get(bufferIndex).putInt(index, value);
     }
@@ -307,7 +308,7 @@ public final void setInt( long bytePos, int value )
     @Override
     public final int getInt( long bytePos )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         return segments.get(bufferIndex).getInt(index);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
index 5561bfaab3..4b31a627b3 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
@@ -20,8 +20,8 @@
 /**
  * Manages memory mapped DataAccess objects.
  * <p/>
- * @see MMapDataAccess
  * @author Peter Karich
+ * @see MMapDataAccess
  */
 public class MMapDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index 11f6615ac2..d794fa76fc 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -19,6 +19,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -27,7 +28,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class NativeFSLockFactory implements LockFactory
@@ -240,7 +241,7 @@ public static void main( String[] args ) throws IOException
 
         file.createNewFile();
         FileChannel channel = new RandomAccessFile(file, "r").getChannel();
-        
+
         boolean shared = true;
         FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
 
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
index 5221b1fb6b..0c0aaf1580 100644
--- a/core/src/main/java/com/graphhopper/storage/NodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -24,7 +24,7 @@
  * This interface specifies how to access properties of the nodes in the graph. Similar to
  * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
  * for an additional iterator.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface NodeAccess extends PointAccess
@@ -38,7 +38,7 @@
 
     /**
      * Sets the additional value at the specified node index
-     * <p>
+     * <p/>
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
      * node field
      */
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 3fe15fffc0..edad71b985 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -22,6 +22,7 @@
 import java.io.RandomAccessFile;
 import java.nio.ByteOrder;
 import java.util.Arrays;
+
 import org.slf4j.LoggerFactory;
 
 /**
@@ -92,7 +93,7 @@ public RAMDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
index 8bc65dde68..0288e5523d 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
@@ -20,9 +20,9 @@
 /**
  * Manages in-memory DataAccess objects.
  * <p/>
+ * @author Peter Karich
  * @see RAMDataAccess
  * @see RAMIntDataAccess
- * @author Peter Karich
  */
 public class RAMDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index 7d8f66631c..b2598102a5 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -95,7 +95,7 @@ public RAMIntDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -266,8 +266,8 @@ public final short getShort( long bytePos )
         if (bytePos % 4 != 0 && bytePos % 4 != 2)
             throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
 
-        long tmpIndex = bytePos >>> 1;
-        int bufferIndex = (int) (tmpIndex >>> segmentSizeIntsPower);
+        long tmpIndex = bytePos >> 1;
+        int bufferIndex = (int) (tmpIndex >> segmentSizeIntsPower);
         int index = (int) (tmpIndex & indexDivisor);
         if (tmpIndex * 2 == bytePos)
             return (short) segments[bufferIndex][index];
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 54182e6f99..e17d8838b4 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -23,7 +23,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SimpleFSLockFactory implements LockFactory
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index fc00b78bf5..c432160712 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -113,7 +114,7 @@ public void close()
     public boolean isClosed()
     {
         return da.isClosed();
-    }        
+    }
 
     @Override
     public StorableProperties create( long size )
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 841974263f..c157818730 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -100,7 +100,7 @@ public synchronized DataAccess create( long bytes )
     }
 
     @Override
-    public synchronized boolean ensureCapacity(long bytes)
+    public synchronized boolean ensureCapacity( long bytes )
     {
         return inner.ensureCapacity(bytes);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index 84f77a6513..f8de969dc4 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -23,7 +23,7 @@
  * Holds turn cost tables for each node. The additional field of a node will be used to point
  * towards the first entry within a node cost table to identify turn restrictions, or later, turn
  * getCosts.
- * <p>
+ * <p/>
  * @author Karl HÃ¼bner
  * @author Peter Karich
  */
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index 20d112c42b..b0481339a6 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -28,11 +29,11 @@
  * This is a data structure which uses an unsafe access to native memory. The speed up compared to
  * RAMDataAccess is roughly 10% due to index calculations and BitUtil overhead in RAMDataAccess.
  * Notes:
- * <p>
+ * <p/>
  * 1. Highly experimental. Still some bugs and access through file/MMAP should work at some point
- * <p>
+ * <p/>
  * 2. Compared to MMAP no syncDAWrapper is need to make it read and write safe from multiple threads
- * <p>
+ * <p/>
  * 3. Cannot be used on Android as no memory allocation methods are available there
  * <p/>
  * @author Peter Karich
@@ -60,7 +61,7 @@
     }
 
     private long address;
-    private long capacity;    
+    private long capacity;
 
     UnsafeDataAccess( String name, String location, ByteOrder order )
     {
@@ -78,7 +79,7 @@ public UnsafeDataAccess create( long bytes )
     }
 
     @Override
-    public final boolean ensureCapacity(long bytes)
+    public final boolean ensureCapacity( long bytes )
     {
         return ensureCapacity(bytes, true);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index c609eca201..8595d5b49b 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -76,7 +76,7 @@ void writeByte( byte b )
     /**
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
-     * <p>
+     * <p/>
      * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
@@ -95,7 +95,7 @@ public final void writeVLong( long i )
     /**
      * Reads a long stored in variable-length format. Reads between one and nine bytes. Smaller
      * values take fewer bytes. Negative numbers are not supported.
-     * <p>
+     * <p/>
      * The format is described further in DataOutput writeVInt(int) -> Lucene.
      */
     public long readVLong()
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index ec3a4b9011..39550e04c6 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -21,7 +21,7 @@
  * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
  * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
  * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
- * <p>
+ * <p/>
  * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
  * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
  * http://stackoverflow.com/q/24679963/194609
@@ -31,13 +31,13 @@
 public class BresenhamLine
 {
     public static void calcPoints( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                   PointEmitter emitter )
     {
         bresenham(y1, x1, y2, x2, emitter);
     }
 
     public static void voxelTraversal( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                       PointEmitter emitter )
     {
         // edge case
         x1 = fix(x1);
@@ -115,7 +115,7 @@ static final double frac( double val )
     }
 
     public static void bresenham( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
@@ -145,7 +145,7 @@ public static void bresenham( int y1, int x1, int y2, int x2,
     }
 
     public static void xiaolinWu( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         double dx = x2 - x1;
         double dy = y2 - y1;
@@ -238,10 +238,10 @@ public static void xiaolinWu( double y1, double x1, double y2, double x2,
     }
 
     public static void calcPoints( final double lat1, final double lon1,
-            final double lat2, final double lon2,
-            final PointEmitter emitter,
-            final double offsetLat, final double offsetLon,
-            final double deltaLat, final double deltaLon )
+                                   final double lat2, final double lon2,
+                                   final PointEmitter emitter,
+                                   final double offsetLat, final double offsetLon,
+                                   final double deltaLat, final double deltaLon )
     {
 //        double y1 = (lat1 - offsetLat) / deltaLat;
 //        double x1 = (lon1 - offsetLon) / deltaLon;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 513e17fa7d..879fbf2a01 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -27,7 +27,9 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,10 +38,10 @@
  * implementation is the a very memory efficient representation for areas with lots of node and
  * edges, but lacks precision. No edge distances are measured.
  * <p/>
+ * @author Peter Karich
  * @see LocationIndexTree which is more precise but more complicated and also slightly slower
  * implementation of LocationIndex.
  * <p/>
- * @author Peter Karich
  */
 class Location2IDQuadtree implements LocationIndex
 {
@@ -316,7 +318,7 @@ public int findID( final double lat, final double lon )
 
     @Override
     public QueryResult findClosest( final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter )
+                                    final EdgeFilter edgeFilter )
     {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index b75690f26f..7d4cf03a60 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -50,12 +50,12 @@
      * This method returns the closest QueryResult for the specified location (lat, lon) and only if
      * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
      * search)
-     * <p>
+     * <p/>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
      *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
-     * <p>
+     * <p/>
      * @return An object containing the closest node and edge for the specfied location. The node id
      * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
      * the method QueryResult.isValid will return false.
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index eee2f2f80c..b5aff65a8c 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -33,7 +33,9 @@
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -76,7 +78,6 @@
 
     /**
      * @param g the graph for which this index should do the lookup based on latitude,longitude.
-     * @param dir
      */
     public LocationIndexTree( Graph g, Directory dir )
     {
@@ -281,10 +282,10 @@ public boolean loadExisting()
             return false;
 
         if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
+            throw new IllegalStateException("incorrect location index version, expected:" + MAGIC_INT);
 
         if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph: "
+            throw new IllegalStateException("location index was opened with incorrect graph: "
                     + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
 
         setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
@@ -296,7 +297,7 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        dataAccess.setHeader(0, MAGIC_INT);        
+        dataAccess.setHeader(0, MAGIC_INT);
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
 
@@ -416,8 +417,8 @@ void prepare()
         }
 
         void addNode( final int nodeA, final int nodeB,
-                final double lat1, final double lon1,
-                final double lat2, final double lon2 )
+                      final double lat1, final double lon1,
+                      final double lat2, final double lon2 )
         {
             PointEmitter pointEmitter = new PointEmitter()
             {
@@ -628,7 +629,7 @@ final long createReverseKey( long key )
     /**
      * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
      * context of a spatial key tile.
-     * <p>
+     * <p/>
      */
     final double calculateRMin( double lat, double lon )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index c371733f82..ac6619af5e 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -31,7 +31,7 @@
  * |
  * T--S----N
  * </pre>
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class QueryResult
@@ -49,7 +49,7 @@
      * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
      * "on-edge" even if it could be 90Â°. To prefer "on-node" you could use e.g. GHPoint.equals with
      * a default precision of 1e-6.
-     * <p>
+     * <p/>
      * @see DistanceCalc#validEdgeDistance
      */
     public static enum Position
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 800bc7c14d..d995c2ee30 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,19 +17,21 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.PI;
 import static java.lang.Math.cos;
 import static java.lang.Math.toRadians;
 
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
- * <p>
+ * <p/>
  * @author Johannes Pelzer
  * @author Peter Karich
  */
 public class AngleCalc
 {
     private final static double PI_4 = Math.PI / 4.0;
+    private final static double PI_2 = Math.PI / 2.0;
     private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
     static final double atan2( double y, double x )
@@ -56,7 +58,7 @@ static final double atan2( double y, double x )
 
     /**
      * Return orientation of line relative to east.
-     * <p>
+     * <p/>
      * @return Orientation in interval -pi to +pi where 0 is east
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
@@ -65,6 +67,21 @@ public double calcOrientation( double lat1, double lon1, double lat2, double lon
         return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
 
+    /**
+     * convert north based clockwise azimuth (0, 360) into x-axis/east based angle (-Pi, Pi)
+     */
+    public double convertAzimuth2xaxisAngle(double azimuth)
+    {
+        if (Double.compare(azimuth, 360)>0 || Double.compare(azimuth, 0)<0)
+        {
+            throw new IllegalArgumentException("Azimuth " + azimuth + " must be in (0, 360)");
+        }
+        double angleXY = PI_2 - azimuth/180.*Math.PI;
+        if (angleXY<-Math.PI) angleXY += 2*Math.PI;
+        if (angleXY>Math.PI) angleXY -= 2*Math.PI;
+        return angleXY;
+    }
+
     /**
      * Change the representation of an orientation, so the difference to the given baseOrientation
      * will be smaller or equal to PI (180 degree). This is achieved by adding or substracting a
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 11957181dd..ef52addc82 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -21,17 +21,17 @@
 
 /**
  * Examples for BIG endianess (default for Java and computer network).
- * <p>
+ * <p/>
  * byte array: 0=>0100 0001 , 1=>1110 1011, 2=>...
- * <p>
+ * <p/>
  * long: highest=>0100 0001 , 1110 1011, ..., lowest=> ...
- * <p>
+ * <p/>
  * bits to string 0100 0001 , 1110 1011, ...
- * <p>
+ * <p/>
  * LITTLE endianess (default for GraphHopper and most microprocessors)
- * <p>
+ * <p/>
  * byte array ..., 6=>1110 1011, 7=>0100 0001
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public abstract class BitUtil
@@ -221,7 +221,7 @@ public String toLastBitString( long value, int bits )
 
     /**
      * Higher order bits comes first in the returned string.
-     * <p>
+     * <p/>
      * @param bits how many bits should be returned.
      */
     public String toBitString( long value, int bits )
@@ -254,7 +254,7 @@ public String toBitString( long value, int bits )
     public final long reverse( long value, int maxBits )
     {
         long res = 0;
-        for (; maxBits > 0; value >>= 1)
+        for (; maxBits > 0; value >>>= 1)
         {
             res <<= 1;
             res |= value & 1;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index e4ac8415d9..55a815cde7 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -44,16 +44,16 @@ public final int toInt( byte[] b, int offset )
     @Override
     public void fromShort( byte[] bytes, short value, int offset )
     {
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
     @Override
     public final void fromInt( byte[] bytes, int value, int offset )
     {
-        bytes[offset + 3] = (byte) (value >> 24);
-        bytes[offset + 2] = (byte) (value >> 16);
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 3] = (byte) (value >>> 24);
+        bytes[offset + 2] = (byte) (value >>> 16);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 6c4801f816..9109b37719 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -115,7 +115,7 @@ public static CmdArgs read( String[] args )
 
     /**
      * Command line configuration overwrites the ones in the config file.
-     * <p>
+     * <p/>
      * @return a new CmdArgs object if necessary.
      */
     public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 2da8f5e766..af5af167e5 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -15,6 +15,7 @@
 package com.graphhopper.util;
 
 import static com.graphhopper.util.Helper.readFile;
+
 import java.io.InputStreamReader;
 import java.util.List;
 
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index d0ea52f8a4..79c6fd89bf 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -69,12 +69,12 @@
      *  .
      *    a-------b
      * </pre>
-     * <p>
+     * <p/>
      * @return true for case 1 which is "on edge" or the special case of 90Â° to the edge
      */
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                               double a_lat_deg, double a_lon_deg,
+                               double b_lat_deg, double b_lon_deg );
 
     /**
      * This method calculates the distance from r to edge (a, b) where the crossing point is c
@@ -82,13 +82,13 @@ boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
      * @return the distance in normalized meter
      */
     double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                       double a_lat_deg, double a_lon_deg,
+                                       double b_lat_deg, double b_lon_deg );
 
     /**
      * @return the crossing point c of the vertical line from r to line (a, b)
      */
     GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                     double a_lat_deg, double a_lon_deg,
+                                     double b_lat_deg, double b_lon_deg );
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
index d4a2cb35e2..5261e89702 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
@@ -32,7 +32,7 @@
      * @param toHeight in meters above 0
      */
     public double calcDist( double fromLat, double fromLon, double fromHeight,
-            double toLat, double toLon, double toHeight )
+                            double toLat, double toLon, double toHeight )
     {
         double len = super.calcDist(fromLat, fromLon, toLat, toLon);
         double delta = Math.abs(toHeight - fromHeight);
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 3502bb7a85..fbcab38d95 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static java.lang.Math.*;
 
 /**
@@ -88,12 +89,6 @@ public double calcCircumference( double lat )
         return 2 * PI * R * cos(toRadians(lat));
     }
 
-    public double calcSpatialKeyMaxDist( int bit )
-    {
-        bit = bit / 2 + 1;
-        return (int) C >> bit;
-    }
-
     public boolean isDateLineCrossOver( double lon1, double lon2 )
     {
         return abs(lon1 - lon2) > 180.0;
@@ -117,21 +112,21 @@ public BBox createBBox( double lat, double lon, double radiusInMeter )
 
     @Override
     public double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                              double a_lat_deg, double a_lon_deg,
+                                              double b_lat_deg, double b_lon_deg )
     {
         return calcNormalizedEdgeDistanceNew(r_lat_deg, r_lon_deg, a_lat_deg, a_lon_deg, b_lat_deg, b_lon_deg, false);
     }
 
     /**
      * New edge distance calculation where no validEdgeDistance check would be necessary
-     * <p>
+     * <p/>
      * @return the normalized distance of the query point "r" to the project point "c" onto the line
      * segment a-b
      */
     public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
+                                                 double a_lat_deg, double a_lon_deg,
+                                                 double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
 
@@ -174,8 +169,8 @@ else if (factor < 0)
 
     @Override
     public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                            double a_lat_deg, double a_lon_deg,
+                                            double b_lat_deg, double b_lon_deg )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
@@ -217,8 +212,8 @@ else if (factor < 0)
 
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                      double a_lat_deg, double a_lon_deg,
+                                      double b_lat_deg, double b_lon_deg )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index db35c29f03..5612ac61e8 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -172,5 +172,5 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         return counter;
     }
 
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 297a917ccb..40ba9e0911 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -41,6 +41,7 @@ public void update( long val )
                     }
                 });
     }
+
     private String referrer = "http://graphhopper.com";
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
@@ -63,25 +64,35 @@ public Downloader setReferrer( String referrer )
         return this;
     }
 
-    public InputStream fetch( HttpURLConnection conn ) throws IOException
+    public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
     {
-        // create connection but before reading get the correct inputstream based on the compression
+        // create connection but before reading get the correct inputstream based on the compression and if error
         conn.connect();
-        String encoding = conn.getContentEncoding();
+
         InputStream is;
-        if (encoding != null && encoding.equalsIgnoreCase("gzip"))
-            is = new GZIPInputStream(conn.getInputStream());
-        else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
-            is = new InflaterInputStream(conn.getInputStream(), new Inflater(true));
+        if (readErrorStreamNoException && conn.getResponseCode() >= 400 && conn.getErrorStream() != null)
+            is = conn.getErrorStream();
         else
             is = conn.getInputStream();
 
+        // wrap
+        try
+        {
+            String encoding = conn.getContentEncoding();
+            if (encoding != null && encoding.equalsIgnoreCase("gzip"))
+                is = new GZIPInputStream(is);
+            else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
+                is = new InflaterInputStream(is, new Inflater(true));
+        } catch (IOException ex)
+        {
+        }
+
         return is;
     }
 
     public InputStream fetch( String url ) throws IOException
     {
-        return fetch((HttpURLConnection) createConnection(url));
+        return fetch((HttpURLConnection) createConnection(url), false);
     }
 
     public HttpURLConnection createConnection( String urlStr ) throws IOException
@@ -104,7 +115,7 @@ public HttpURLConnection createConnection( String urlStr ) throws IOException
     public void downloadFile( String url, String toFile ) throws IOException
     {
         HttpURLConnection conn = createConnection(url);
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
         int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
@@ -127,7 +138,7 @@ public void downloadAndUnzip( String url, String toFolder, final ProgressListene
     {
         HttpURLConnection conn = createConnection(url);
         final int length = conn.getContentLength();
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
 
         new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
         {
@@ -136,11 +147,11 @@ public void update( long sumBytes )
             {
                 progressListener.update((int) (100 * sumBytes / length));
             }
-        });
+        });    
     }
 
-    public String downloadAsString( String url ) throws IOException
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
     {
-        return Helper.isToString(fetch(url));
+        return Helper.isToString(fetch((HttpURLConnection) createConnection(url), readErrorStreamNoException));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
index 3d6cebd4c2..5cf1a23893 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
@@ -20,9 +20,9 @@
 /**
  * Class to get EdgeIterator create it via graph.createEdgeExplorer(). Use one instance per thread.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeIteratorState
- * @author Peter Karich
  */
 public interface EdgeExplorer
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index a3f2107628..b28b715223 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -33,16 +33,15 @@
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
  *   ...
  * }
- *
+ * @author Peter Karich
  * @see EdgeIteratorState
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIterator extends EdgeIteratorState
 {
     /**
      * To be called to go to the next edge state.
-     * <p>
+     * <p/>
      * @return true if an edge state is available
      */
     boolean next();
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index e790ec8afb..c5a78bbf55 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -20,12 +20,14 @@
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIteratorState
 {
+    final static int K_UNFAVORED_EDGE = -1;
+    
     /**
      * @return the edge id of the current edge. Do not make any assumptions about the concrete
      * values, except that for an implemention it is recommended that they'll be contiguous.
@@ -83,6 +85,13 @@
      */
     int getAdditionalField();
 
+    /**
+     * get additional boolean edge information
+     * @param reverse  if property of reverse edge direction should be returned
+     * @param _default default value if key is not found
+     */
+    boolean getBoolean( int key, boolean reverse, boolean _default);
+    
     /**
      * Updates the additional field value for this edge
      */
@@ -94,7 +103,7 @@
 
     /**
      * Clones this EdgeIteratorState.
-     * <p>
+     * <p/>
      * @param reverse if true a detached edgeState with reversed properties is created where base
      * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
      * about why we need the new reverse parameter.
@@ -103,7 +112,7 @@
 
     /**
      * Copies the properties of this edge into the specified edge. Does not change nodes!
-     * <p>
+     * <p/>
      * @return the specified edge e
      */
     EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
index c351f01757..a7709a6c3c 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
@@ -22,8 +22,8 @@
 /**
  * Support for skipped edge
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see LevelGraph
  */
 public interface EdgeSkipExplorer extends EdgeExplorer
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java b/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
index 26a5dfb725..11273da312 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
@@ -22,8 +22,8 @@
 /**
  * Support for skipped edge
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see LevelGraph
  */
 public interface EdgeSkipIterator extends EdgeIterator, EdgeSkipIterState
 {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index dbe2737226..d0dfd27057 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -19,14 +19,15 @@
 
 import com.graphhopper.routing.PathBidir;
 import gnu.trove.map.hash.TIntIntHashMap;
+
 import java.util.Arrays;
 
 /**
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
  * <p/>
- * @see PathBidir
  * @author Peter Karich
+ * @see PathBidir
  */
 @NotThreadSafe
 public class EdgeWrapper
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index a3623be0a3..5332a4e3fc 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -27,6 +27,7 @@
 import com.graphhopper.storage.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -109,7 +110,8 @@ public static int count( EdgeIterator iter )
 
     public static Set<Integer> getNeighbors( EdgeIterator iter )
     {
-        Set<Integer> list = new HashSet<Integer>();
+        // make iteration order over set static => linked
+        Set<Integer> list = new LinkedHashSet<Integer>();
         while (iter.next())
         {
             list.add(iter.getAdjNode());
@@ -454,6 +456,12 @@ public EdgeIteratorState setName( String name )
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
+        @Override
+        public boolean getBoolean(int key, boolean reverse, boolean _default )
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+        
         @Override
         public int getAdditionalField()
         {
@@ -520,4 +528,12 @@ public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
     {
         return edgeKey1 / 2 == edgeKey2 / 2;
     }
+
+    /**
+     * Returns the edgeKey of the opposite direction
+     */
+    public static int reverseEdgeKey( int edgeKey )
+    {
+        return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index 7b31ecb262..cad353c103 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -64,7 +64,7 @@ public void setTime( long time )
 
     /**
      * The time relative to the start time in milli seconds.
-     * <p>
+     * <p/>
      * @deprecated use getTime instead
      */
     public long getMillis()
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 5ce25f57c4..b47030cc07 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.io.*;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
@@ -31,14 +32,15 @@
 import java.text.NumberFormat;
 import java.util.*;
 import java.util.Map.Entry;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Several utility classes which are compatible with Java6 on Android.
  * <p/>
- * @see Helper7 for none-Android compatible methods.
  * @author Peter Karich
+ * @see Helper7 for none-Android compatible methods.
  */
 public class Helper
 {
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index feef36b489..c0f1cd4c48 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -156,11 +156,11 @@ public PointList getPoints()
     /**
      * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     * <p>
+     * <p/>
      * @return the time offset to add for the next instruction
      */
     long fillGPXList( List<GPXEntry> list, long time,
-            Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
+                      Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
     {
         checkOne();
         int len = points.size();
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 23a2bf3146..d4512f0436 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -132,7 +132,7 @@ public String toString()
     /**
      * @return This method returns a list of gpx entries where the time (in millis) is relative to
      * the first which is 0.
-     * <p>
+     * <p/>
      */
     public List<GPXEntry> createGPXList()
     {
@@ -271,7 +271,7 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
-     * <p>
+     * <p/>
      * @param maxDistance the maximum acceptable distance to the instruction (in meter)
      * @return the next Instruction or null if too far away.
      */
@@ -313,6 +313,8 @@ public Instruction find( double lat, double lon, double maxDistance )
                         } else
                         {
                             distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                            if (pointIndex > 0)
+                                index++;
                         }
 
                         if (distance < foundMinDistance)
@@ -321,7 +323,6 @@ public Instruction find( double lat, double lon, double maxDistance )
                             foundInstruction = index;
                         }
                     }
-
                     prevLat = currLat;
                     prevLon = currLon;
                 }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 590c89b2fa..132c98c109 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import java.text.DecimalFormat;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
index ebf515905e..5b4b7ed146 100644
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -22,7 +22,7 @@
 
 /**
  * A properties map with convenient accessors
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PMap
@@ -44,7 +44,7 @@ public PMap( Map<String, String> map )
         this.map = map;
     }
 
-    public PMap(String propertiesString)
+    public PMap( String propertiesString )
     {
         // five chosen as arbitrary initial capacity
         this.map = new HashMap<String, String>(5);
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 3dcd61bda7..a33097d65b 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -20,11 +20,12 @@
 
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.Path;
+
 import java.util.List;
 
 /**
  * This class merges a list of points into one point recognizing the specified places.
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author ratrun
  */
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index 5d3068a599..ee93ad219b 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -42,7 +42,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon );
@@ -50,7 +50,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon, double ele );
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index d3ecbf0087..6cca560fee 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -303,14 +304,15 @@ public String toString()
         {
             if (includeElevation)
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)), Helper.round2(getElevation(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)),
+                                Helper.round2(getElevation(i))
+                        });
             else
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
+                        });
         }
         return points;
     }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index 78b759471a..185d7b480b 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -69,7 +69,7 @@ public int getExitNumber()
 
     /**
      * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
-     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     * values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
      */
     public double getRadian()
     {
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 41b3adff06..f50f46f3a7 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -22,19 +22,18 @@
 import java.util.Map.Entry;
 
 /**
- * A class which manages the translations in-memory. Translations are managed here:
- * https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0
+ * A class which manages the translations in-memory. See here for more information:
+ * ./docs/core/translations.md
  * <p/>
- * See here for more information: ./docs/core/translations.md
- * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "cz", "de_DE", "el", "en_US", "es",
-            "fa", "fil", "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "lt_LT", "ne", "nl", "pl_PL",
-            "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
+    private static final List<String> LOCALES = Arrays.asList("ar", "bg", "ca", "cz", "de_DE", "el",
+            "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hsb", "hu_HU", "it", "ja",
+            "lt_LT", "ne", "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk",
+            "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index 028a21541a..070aaed5a8 100644
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -16,7 +16,6 @@
 package com.graphhopper.util;
 
 /**
- *
  * @author Peter Karich
  */
 public class ViaInstruction extends Instruction
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index d0eb1ebb46..9b6eb95f22 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+
 import java.util.ArrayList;
 import java.util.List;
 
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 5ca18aa337..277a552a77 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -84,9 +84,9 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat
-        };
+                {
+                        lon, lat
+                };
     }
 
     public static GHPoint parse( String str )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
index cab721686c..6db1d59c78 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -77,8 +77,8 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat, ele
-        };
+                {
+                        lon, lat, ele
+                };
     }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
new file mode 100644
index 0000000000..561fee2dc3
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=Ø§Ø³ØªÙØ±
+continue_onto=%1$s Ø§Ø³ØªÙØ± ÙÙ 
+turn_left=Ø§ØªØ¬Ù ÙØ³Ø§Ø±Ø§Ù
+turn_right=Ø§ØªØ¬Ù ÙÙÙÙØ§Ù
+turn_slight_left=Ø¥Ø³ØªØ¯Ø± ÙÙÙØ³Ø§Ø± ÙÙÙÙØ§
+turn_slight_right=Ø¥Ø³ØªØ¯Ø± ÙÙÙÙÙÙ ÙÙÙÙØ§
+turn_sharp_left=Ø§ØªØ¬Ù ÙÙÙÙØ§Ù ÙÙÙØ³Ø§Ø±
+turn_sharp_right=Ø§ØªØ¬Ù ÙÙÙÙØ§Ù ÙÙÙÙÙÙ
+turn_onto=%1$s Ø®ÙØ§Ù %1$s
+web.searchButton=Ø§Ø¨Ø­Ø«
+web.fromHint=ÙÙ
+web.viaHint=Ø®ÙØ§Ù
+web.toHint=Ø¥ÙÙ
+web.moreButton=Ø§ÙÙØ²ÙØ¯
+web.gpxExportButton=GPX Ø§ÙØªØµØ¯ÙØ±
+web.routeInfo=%1$s Ø³ØªØ§Ø®Ø° %2$s
+web.locationsNotFound=ÙØ§ ÙÙØ¬Ø¯ Ø·Ø±ÙÙ ÙÙ ÙØ°Ù Ø§ÙÙÙØ·ÙØ©
+web.bike=Ø¯Ø±Ø§Ø¬Ø©
+web.racingbike=Ø¯Ø±Ø§Ø¬Ø© Ø³Ø¨Ø§Ù
+web.mtb=Ø¯Ø±Ø§Ø¬Ø© Ø¬Ø¨ÙÙØ©
+web.car=Ø³ÙØ§Ø±Ø©
+web.foot=ÙØ´ÙØ§Ù
+web.staticlink=Ø±Ø§Ø¨Ø· Ø«Ø§Ø¨Øª
+web.motorcycle=Ø¯Ø±Ø§Ø¬Ø© ÙØ§Ø±ÙØ©
+via=ÙÙ Ø®ÙØ§Ù
+finish=Ø§ÙÙÙØ§ÙØ©
+hourAbbr=Ø³Ø§Ø¹Ø©
+dayAbbr=ÙÙÙ
+minAbbr=Ø¯ÙÙÙØ©
+kmAbbr=ÙÙÙÙÙØªØ±
+mAbbr=ÙØªØ±
+miAbbr=ÙÙÙ
+ftAbbr=ÙØ¯Ù
+road=Ø·Ø±ÙÙ
+off_bike=Ø§ÙØ²Ù Ø§ÙØ¯Ø±Ø§Ø¬Ø©
+cycleway=Ø·Ø±ÙÙ Ø¯Ø§Ø¦Ø±Ù
+way=Ø·Ø±ÙÙ
+paved=ÙØ±ØµÙÙ
+unpaved=ØºÙØ± ÙØ±ØµÙÙ
+stopover=ØªÙÙÙ %1$s
+roundaboutEnter=Ø£Ø¯Ø®Ù Ø§ÙØ¯ÙØ±Ø§Ù
+roundaboutExit=ÙÙ Ø§ÙØ¯ÙØ±Ø§Ù Ø Ø£ØªØ®Ø° ÙØ®Ø±Ø¬   %1$s
+roundaboutExitOnto=ÙÙ Ø§ÙØ¯ÙØ±Ø§Ù Ø Ø£ØªØ®Ø° ÙØ®Ø±Ø¬   %1$s ÙÙ Ø®ÙØ§Ù %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index 487ae279b0..1ce8dc33b2 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -41,5 +41,5 @@ paved=pavimentado
 unpaved=no pavimentado
 stopover=pasando por %1$s
 roundaboutEnter=Entre en la rotonda
-roundaboutExit=En la rotonda, tome la salida %1$s
-roundaboutExitOnto=En la rotonda, tome la salida %1$s hacia %2$s
+roundaboutExit=En la rotonda, tome la %1$sÂª salida
+roundaboutExitOnto=En la rotonda, tome la %1$sÂª salida hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/hsb.txt b/core/src/main/resources/com/graphhopper/util/hsb.txt
new file mode 100644
index 0000000000..eb762719a5
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/hsb.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=runjewon
+continue_onto=runjewon na %1$s
+turn_left=nalÄwo wotboÄiÄ
+turn_right=naprawo wotboÄiÄ
+turn_slight_left=zlochka nalÄwo wotboÄiÄ
+turn_slight_right=zlochka naprawo wotboÄiÄ
+turn_sharp_left=wÃ³trje nalÄwo wotboÄiÄ
+turn_sharp_right=wÃ³trje naprawo wotboÄiÄ
+turn_onto=%1$s na %2$s
+web.searchButton=pytaj
+web.fromHint=wot
+web.viaHint=pÅez
+web.toHint=do
+web.moreButton=wjac
+web.gpxExportButton=eksport do GPX
+web.routeInfo=za %1$s so trjeba %2$s
+web.locationsNotFound=Äara njeje mÃ³Å¾na. MÄstno so w tutej kÃ³nÄinje njenamaka.
+web.bike=koleso
+web.racingbike=wubÄdÅºowanske koleso
+web.mtb=mountainbike
+web.car=awto
+web.foot=pÄÅ¡i
+web.staticlink=link
+web.motorcycle=motorske
+via=via
+finish=dojÄÅ
+hourAbbr=hodÅº.
+dayAbbr=dny
+minAbbr=mjeÅ
+kmAbbr=km
+mAbbr=m
+miAbbr=mile
+ftAbbr=ft
+road=drÃ³ha
+off_bike=ÄiÅ¡ÄeÄ
+cycleway=kolesowarski puÄ
+way=puÄ
+paved=pÅitwjerdÅºeny
+unpaved=njepÅitwjerdÅºeny
+stopover=mjezycil %1$s
+roundaboutEnter=do kruÅ¾neho wobchada zajÄÄ
+roundaboutExit=we kruÅ¾nym wobchadÅºe %1$s. wujÄzd wzaÄ
+roundaboutExitOnto=we kruÅ¾nym wobchadÅºe %1$s. wujÄzd na %2$s wzaÄ
diff --git a/core/src/main/resources/com/graphhopper/util/pl_PL.txt b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
index 17b6169d9a..47b3b4aace 100644
--- a/core/src/main/resources/com/graphhopper/util/pl_PL.txt
+++ b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
@@ -38,8 +38,8 @@ off_bike=zejdÅº z roweru
 cycleway=trasa rowerowa
 way=trasa
 paved=utwierdzona
-unpaved=nieutwierdzona
+unpaved=nieutwardzona
 stopover=przystanek %1$s
 roundaboutEnter=WjedÅº na rondo
-roundaboutExit=ZjedÅº z ronda %1$s zjadem
-roundaboutExitOnto=ZjedÅº z ronda %1$s zjadem na %2$s
+roundaboutExit=ZjedÅº z ronda %1$s zjazdem
+roundaboutExitOnto=ZjedÅº z ronda %1$s zjazdem na %2$s
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index e679159dc2..97b761ae88 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -18,11 +18,16 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHRequestTest
@@ -36,4 +41,71 @@ public void testGetHint()
         // #173 - will throw an error: Integer cannot be cast to Double
         assertEquals(1, instance.getHints().getDouble("something", 2d), 1e1);
     }
+
+    @Test
+    public void testCorrectInit()
+    {
+        double lat0 = 51, lon0 = 1, lat1 = 52, lon1 = 2, lat2 = 53, lon2 = 3;
+
+        ArrayList<GHPoint> points = new ArrayList<GHPoint>(3);
+        points.add(new GHPoint(lat0, lon0));
+        points.add(new GHPoint(lat1, lon1));
+        points.add(new GHPoint(lat2, lon2));
+        List<Double> favoredHeadings = Arrays.asList(3.14, 4.15, Double.NaN);
+        List<Double> emptyHeadings = Arrays.asList(Double.NaN, Double.NaN, Double.NaN);
+
+        GHRequest instance;
+
+        instance = new GHRequest(points, favoredHeadings);
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest(points.get(0), points.get(1), favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1, favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(3).addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest().addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, favoredHeadings);
+
+        // check init without favoredHeadings
+        instance = new GHRequest(points);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+
+        instance = new GHRequest(points.get(0), points.get(1));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1);
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest().addPoint(points.get(0)).addPoint(points.get(1)).addPoint(points.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+    }
+
+    private void compareFavoredHeadings( GHRequest request, List<Double> expected )
+    {
+        for (int ind = 0; ind < expected.size(); ind++)
+        {
+            double favoredHeading = request.getFavoredHeading(ind);
+            assertEquals(ind + " favored Heading does not match" + expected.get(ind) + " vs ." + favoredHeading,
+                    expected.get(ind), favoredHeading, 0.01);
+        }
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/GHResponseTest.java b/core/src/test/java/com/graphhopper/GHResponseTest.java
new file mode 100644
index 0000000000..d303593cd6
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GHResponseTest.java
@@ -0,0 +1,11 @@
+package com.graphhopper;
+
+import junit.framework.TestCase;
+
+public class GHResponseTest extends TestCase
+{
+    public void testToString() throws Exception
+    {
+        assertEquals("nodes:0; ", new GHResponse().toString());
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index fd7d4a3721..86df0df099 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -22,10 +22,10 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.NodeAccess;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperAPITest
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index 55db22a928..9c26d7f776 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -20,14 +20,15 @@
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.*;
 
 import java.io.File;
 import java.util.List;
 import java.util.Map;
-import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
@@ -189,6 +190,36 @@ public void testMonacoVia()
         assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
     }
 
+    @Test
+    public void testMonacoEnforcedDirection()
+    {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854), 0.).
+                addPoint(new GHPoint(43.744445, 7.429483), 190.).
+                setVehicle(vehicle).setWeighting("fastest");
+        req.getHints().put("heading_penalty", "300");
+        GHResponse rsp = hopper.route(req);
+
+        assertEquals(873., rsp.getDistance(), 10.);
+        assertEquals(33, rsp.getPoints().getSize());
+    }
+
+    @Test
+    public void testMonacoStraightVia()
+    {
+        GHRequest rq = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.740371, 7.426946)).
+                addPoint(new GHPoint(43.740794, 7.427294)).
+                setVehicle(vehicle).setWeighting("fastest");
+        rq.getHints().put("pass_through", true);
+        GHResponse rsp = hopper.route(rq);
+
+        assertEquals(297, rsp.getDistance(), 5.);
+        assertEquals(27, rsp.getPoints().getSize());
+    }
+
+
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
@@ -215,17 +246,17 @@ public void testSRTMWithInstructions() throws Exception
 
         String str = rsp.getPoints().toString();
         assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
-                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
-                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
-                + "(43.73125457162979,7.421274090288746,52.0), "
-                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
-                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
-                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
-                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
+                        + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
+                        + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
+                        + "(43.73125457162979,7.421274090288746,52.0), "
+                        + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
+                        + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
+                        + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
+                        + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
                 str.substring(0, 662));
 
         assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
-                + "(43.727680946587874,7.419198768422206,11.0)",
+                        + "(43.727680946587874,7.419198768422206,11.0)",
                 str.substring(str.length() - 132));
 
         List<GPXEntry> list = rsp.getInstructions().createGPXList();
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index fe5e04f20c..62b1d02bed 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -19,25 +19,31 @@
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 import java.io.File;
 import java.io.IOException;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import org.junit.After;
-import org.junit.Test;
+
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperTest
@@ -529,4 +535,229 @@ public void testVia()
         assertEquals(5, rsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
     }
+
+    @Test
+    public void testGetPathsDirectionEnforcement1()
+    {
+        // Test enforce start direction
+        // Note: This Test does not pass for CH enabled    
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction; expected nodes (9)-5-8-3-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 3, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement2()
+    {
+        // Test enforce start & end direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction and east end direction ; expected nodes (9)-5-8-1-2-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end, 90.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+
+        // Test uni-directional case
+        req.setAlgorithm(AlgorithmOptions.DIJKSTRA);
+        response = new GHResponse();
+        paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement3()
+    {
+        // Test enforce via direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-7
+        GHPoint via = new GHPoint(0.0005, 0.001);
+
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via, 0.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 5, 6, 7, 11
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement4()
+    {
+        // Test straight via routing
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-3
+        GHPoint via = new GHPoint(0.0015, 0.001);
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 11
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            11, 8, 1, 2, 9
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement5()
+    {
+        // Test independence of previous enforcement for subsequent pathes
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // First go south and than come from west to via-point at 7-6. Then go back over previously punished (11)-4 edge
+        GHPoint via = new GHPoint(0.000, 0.0015);
+        GHRequest req = new GHRequest().addPoint(start, 0.).addPoint(via, 3.14 / 2).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 8, 7, 9
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            9, 6, 5, 10, 4, 3, 11
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement6()
+    {
+        // Test if query results at tower nodes are ignored
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // QueryPoints directly on TowerNodes 
+        GHPoint start = new GHPoint(0, 0);
+        GHPoint via = new GHPoint(0.002, 0.000);
+        GHPoint end = new GHPoint(0.002, 0.002);
+
+        GHRequest req = new GHRequest().addPoint(start, 90.).addPoint(via, 270.).addPoint(end, 270.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            0, 1, 2
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            2, 3, 4
+        }, paths.get(1).calcNodes().toArray());
+
+    }
+
+    private GraphHopper initSquareGraphInstance( boolean withCH )
+    {
+        EncodingManager encodingManager = new EncodingManager("car");
+
+        GraphStorage g;
+        if (withCH)
+        {
+            g = new LevelGraphStorage(new RAMDirectory(), encodingManager, false).create(20);
+        } else
+        {
+            g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(20);
+        }
+
+        //   2---3---4
+        //  /    |    \
+        //  1----8----5
+        //  /    |    /
+        //  0----7---6
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0.000, 0.000);
+        na.setNode(1, 0.001, 0.000);
+        na.setNode(2, 0.002, 0.000);
+        na.setNode(3, 0.002, 0.001);
+        na.setNode(4, 0.002, 0.002);
+        na.setNode(5, 0.001, 0.002);
+        na.setNode(6, 0.000, 0.002);
+        na.setNode(7, 0.000, 0.001);
+        na.setNode(8, 0.001, 0.001);
+
+        g.edge(0, 1, 100, true);
+        g.edge(1, 2, 100, true);
+        g.edge(2, 3, 100, true);
+        g.edge(3, 4, 100, true);
+        g.edge(4, 5, 100, true);
+        g.edge(5, 6, 100, true);
+        g.edge(6, 7, 100, true);
+        g.edge(7, 0, 100, true);
+
+        g.edge(1, 8, 110, true);
+        g.edge(3, 8, 110, true);
+        g.edge(5, 8, 110, true);
+        g.edge(7, 8, 110, true);
+
+        instance = new GraphHopper().
+                setCHEnable(withCH).
+                setCHWeighting("fastest").
+                setEncodingManager(encodingManager);
+        instance.setGraph(g);
+        instance.postProcessing();        
+
+        return instance;
+    }
+
+    @Test
+    public void testCustomFactoryForNoneCH()
+    {
+        GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        RoutingAlgorithmFactory af = new RoutingAlgorithmFactorySimple();
+        closableInstance.setAlgorithmFactory(af);
+        closableInstance.importOrLoad();
+
+        assertTrue(af == closableInstance.getAlgorithmFactory());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 4e9b580902..5cc1e82fa4 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.PriorityQueue;
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
index 7a319c30c9..f923f29e0a 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
index cf047c82b4..d5904de16f 100644
--- a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BigLongIntMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
index c88cd05eaf..51471ab1e6 100644
--- a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitSetImplTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 359acc5890..4f13821970 100644
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CompressedArrayTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
index 14c923e0e6..33f2582f5f 100644
--- a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
@@ -20,11 +20,12 @@
 import java.util.LinkedHashSet;
 import java.util.Random;
 import java.util.Set;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHLongIntBTreeTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
index c5d9692d1a..890b0253fb 100644
--- a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHSortedCollectionTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
index 3af8c5672e..9a3c8bc4e6 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
@@ -20,7 +20,6 @@
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTBitSetTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index edf15886b1..f5ea5511d4 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTreeMapComposedTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
index c63edcfbf5..6f7109aee5 100644
--- a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntDoubleBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
index 21ec8aae4e..a755752b45 100644
--- a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntIntBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
index bf62ab9c80..1acc36741b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
index cdb07c9544..fec5f54f3b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDSegmentedMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
index 9643af641b..cb11ee8218 100644
--- a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -29,17 +30,17 @@
     public void testBinarySearch()
     {
         long a[] = new long[]
-        {
-            9, 53, 100
-        };
+                {
+                        9, 53, 100
+                };
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 3, 50));
         assertEquals(~2, SparseLongLongArray.binarySearch(a, 0, 3, 55));
         assertEquals(~3, SparseLongLongArray.binarySearch(a, 0, 3, 155));
 
         a = new long[]
-        {
-            9
-        };
+                {
+                        9
+                };
         assertEquals(~0, SparseLongLongArray.binarySearch(a, 0, 1, 5));
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 1, 50));
     }
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index 36dfb74cd2..54ec767ac4 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -68,20 +70,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+
     /*
     * Test if different constructors yield same results
      */
     @Test
     public void testInstantiation()
     {
-        double minLon = 0; 
+        double minLon = 0;
         double minLat = 2;
         double maxLat = 6;
         double maxLon = 5;
-        
-        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
-        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
-        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+
+        BBox bounds = new BBox(minLon, maxLon, minLat, maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4, 4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4, 4).setBounds(minLon, maxLon, minLat, maxLat);
         assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
         assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
     }
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index ca681b6bcd..ff4b3eb0b9 100644
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SpatialKeyAlgoTest
@@ -233,9 +233,10 @@ public void testDifferentInitialBounds()
         algo.decode(1, coord);
         assertEquals(1, algo.encode(coord));
     }
-    
+
     @Test
-    public void testEdgeCases() {
+    public void testEdgeCases()
+    {
         double minLon = -1, maxLon = 1.6;
         double minLat = -1, maxLat = 0.5;
         int parts = 4;
diff --git a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
index ec6753870c..f1b7e610e0 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
@@ -19,11 +19,12 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMElementTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
index ff3610c9ae..4218bafe13 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.reader;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMNodeTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 7cdfdf5867..dd643722af 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static org.junit.Assert.*;
+
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -45,6 +46,7 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.*;
 
 /**
@@ -722,7 +724,7 @@ public void testTurnFlagCombination()
         {
             @Override
             public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
-                    OSMTurnRelation turnRelation )
+                                                                                       OSMTurnRelation turnRelation )
             {
                 // simulate by returning one turn cost entry directly
                 if (encoder.toString().equalsIgnoreCase("car"))
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index 7c3629cd9e..ad83ce8f40 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -25,15 +25,17 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -44,11 +46,11 @@ public void testGetRestrictionAsEntries()
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
-                
+
         osmNodeToInternal.put(3L, 3);
         // edge ids are only stored if they occured before in an OSMRelation
-        internalToOSMEdge.put(3, 3L);        
-        internalToOSMEdge.put(4, 4L);        
+        internalToOSMEdge.put(3, 3L);
+        internalToOSMEdge.put(4, 4L);
 
         GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
@@ -65,7 +67,7 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
             public long getOsmIdOfInternalEdge( int edgeId )
             {
                 Long l = internalToOSMEdge.get(edgeId);
-                if(l == null)
+                if (l == null)
                     return -1;
                 return l;
             }
@@ -84,13 +86,13 @@ public long getOsmIdOfInternalEdge( int edgeId )
         assertEquals(4, entry.edgeFrom);
         assertEquals(6, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
-        
+
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(2, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
-        
-        
+
+
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
         result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
@@ -100,7 +102,7 @@ public long getOsmIdOfInternalEdge( int edgeId )
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(3, entry.edgeTo);
-        assertEquals(3, entry.nodeVia);       
+        assertEquals(3, entry.nodeVia);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
index 24ebc4126e..d829052a6b 100644
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
@@ -21,16 +21,20 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
+
 import static com.graphhopper.util.GHUtility.*;
+
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.io.IOException;
 import java.util.zip.GZIPInputStream;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrinctonReaderTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
index e07c32fe02..8a5825bb84 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -18,11 +18,12 @@
  */
 package com.graphhopper.reader.dem;
 
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CGIARProviderTest
@@ -57,4 +58,22 @@ public void testFileName()
         assertEquals("srtm_34_08", instance.getFileName(20, -15));
         assertEquals("srtm_37_02", instance.getFileName(52.1943832, 0.1363176));
     }
+
+    @Test
+    public void testFileNotFound()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
+        File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".zip");
+        file.delete();
+        zipFile.delete();
+        
+        assertEquals(0, instance.getEle(46, -20), 1);
+
+        // file not found => small!
+        assertTrue(file.exists());
+        assertEquals(228, file.length());        
+        file.delete();
+        zipFile.delete();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index f9adbc5ae3..d56495704f 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class HeightTileTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 79631a5a02..30f2439d3a 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -19,15 +19,18 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 import java.io.IOException;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class SRTMProviderTest
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index ea30e4233c..87c5790246 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.ShortestWeighting;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -27,8 +29,13 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
 
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +48,20 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {
+                                TraversalMode.NODE_BASED
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_1DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR_UTURN
+                        }
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -68,4 +83,40 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             }
         };
     }
+
+    @Test
+    public void testInitFromAndTo()
+    {
+        Graph g = createGraph(false);
+        g.edge(0, 1, 1, true);
+        updateDistancesFor(g, 0, 0.00, 0.00);
+        updateDistancesFor(g, 1, 0.01, 0.01);
+
+        final AtomicReference<AStar.AStarEdge> fromRef = new AtomicReference<AStar.AStarEdge>();
+        final AtomicReference<AStar.AStarEdge> toRef = new AtomicReference<AStar.AStarEdge>();
+        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(), traversalMode)
+        {
+            @Override
+            public void initFrom( int from, double weight )
+            {
+                super.initFrom(from, weight);
+                fromRef.set(currFrom);
+            }
+
+            @Override
+            public void initTo( int to, double weight )
+            {
+                super.initTo(to, weight);
+                toRef.set(currTo);
+            }
+        };
+        astar.initFrom(0, 1);
+        astar.initTo(1, 0.5);
+
+        assertEquals(1, fromRef.get().weightOfVisitedPath, .1);
+        assertEquals(787.3, fromRef.get().weight, .1);
+
+        assertEquals(0.5, toRef.get().weightOfVisitedPath, .1);
+        assertEquals(786.8, toRef.get().weight, .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 92c5a2b0a7..492024905e 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -40,12 +41,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 54edf7b16f..31fd0bda81 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -24,13 +24,15 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
+
 import java.util.Random;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithmTester
@@ -119,9 +121,10 @@ public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
-        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
+        Path p1 = createAlgo(graphShortest, defaultOpts).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
         Graph graphFastest = createGraph(false);
@@ -130,8 +133,8 @@ public void testCalcFastestPath()
                 AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
                 calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
-        assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
-        assertEquals(p2.toString(), 111437, p2.getTime());
+        assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
+        assertEquals(p2.toString(), 111442, p2.getMillis());
     }
 
     // 0-1-2-3
@@ -353,10 +356,7 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next())
         {
-            int adj = iter.getAdjNode();
-            double adjLat = na.getLatitude(adj);
-            double adjLon = na.getLongitude(adj);
-            iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
             // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
@@ -371,12 +371,12 @@ public void testBidirectional()
         Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
-        assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
         p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 10007.7, p.getDistance(), .1);
     }
 
     // 1-2-3-4-5
@@ -489,35 +489,36 @@ public void testDirectedGraphBug2()
     public void testWithCoordinates()
     {
         Graph graph = createGraph(false);
-        NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 0, 2);
-        na.setNode(1, 0, 3.5);
-        na.setNode(2, 1, 1);
-        na.setNode(3, 1.5, 2.5);
-        na.setNode(4, 0.5, 4.5);
 
-        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
-        graph.edge(2, 3, 2, true);
-        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(1, 3.5));
+        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(1.5, 1));
+        graph.edge(2, 3, 2, true).setWayGeometry(Helper.createPointList(0, 1.5));
+        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(0, 2));
 
-        graph.edge(0, 2, 0.8, true).setWayGeometry(Helper.createPointList(0, 1.6, 0, 0, 1, 0));
+        // duplicate but one is longer
         graph.edge(0, 2, 1.2, true);
-        graph.edge(1, 3, 1.3, true);
+        graph.edge(0, 2, 1.5, true).setWayGeometry(Helper.createPointList(0.5, 0));
+
+        graph.edge(1, 3, 1.3, true).setWayGeometry(Helper.createPointList(0.5, 1.5));
         graph.edge(1, 4, 1, true);
 
+        updateDistancesFor(graph, 0, 1, 0.6);
+        updateDistancesFor(graph, 1, 1, 1.5);
+        updateDistancesFor(graph, 2, 0, 0);
+        updateDistancesFor(graph, 3, 0, 1);
+        updateDistancesFor(graph, 4, 0, 2);
+
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
         Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
-        assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
-        assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
+        assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         p = prepare.createAlgo(graph, opts).calcPath(2, 1);
-        // System.out.println(p.toDetailsString());
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
-        assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
-        assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
+        assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
 
     @Test
@@ -694,7 +695,6 @@ public void testTwoWeightsPerEdge()
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
         Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
-//        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(85124371, p.getTime());
         assertEquals(425622, p.getDistance(), 1);
         assertEquals(85124.4, p.getWeight(), 1);
@@ -733,7 +733,7 @@ public void testTwoWeightsPerEdge2()
             @Override
             public double getMinWeight( double distance )
             {
-                return distance;
+                return 0.8 * distance;
             }
 
             @Override
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 0f67d59627..bd859f314e 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -28,7 +29,6 @@
 import com.graphhopper.storage.Graph;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +41,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -66,6 +66,6 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
                 return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        };    
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 4092c96b44..c1c99dd41b 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -22,16 +22,18 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -44,14 +46,14 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            {
-                TraversalMode.NODE_BASED
-            },
+                {
+                        {
+                                TraversalMode.NODE_BASED
+                        },
 //            TODO { TraversalMode.EDGE_BASED_1DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                });
     }
 
     private final TraversalMode traversalMode;
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index fb8c479901..9b51ac6fe5 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -28,7 +29,6 @@
 import com.graphhopper.storage.Graph;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +41,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 1bbc864885..81e75cc3c3 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -25,10 +25,13 @@
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
 import static com.graphhopper.util.GHUtility.*;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -56,13 +59,13 @@ EncodingManager createEncodingManager( boolean restrictedOnly )
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { AlgorithmOptions.DIJKSTRA },
-            { AlgorithmOptions.DIJKSTRA_BI },
-            { AlgorithmOptions.ASTAR },
-            { AlgorithmOptions.ASTAR_BI }
-        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
-        });
+                {
+                        {AlgorithmOptions.DIJKSTRA},
+                        {AlgorithmOptions.DIJKSTRA_BI},
+                        {AlgorithmOptions.ASTAR},
+                        {AlgorithmOptions.ASTAR_BI}
+                        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+                });
     }
 
     private final String algoStr;
@@ -186,7 +189,7 @@ public void testUTurns()
                 flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 50)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
-        Path p = createAlgo(g, opts).calcPath(7, 5);        
+        Path p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 6f0ffc7d6c..caa7680d98 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -24,7 +24,9 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 6b684c5120..0048b97018 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -20,19 +20,22 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
+
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
+
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
+
 import java.util.*;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PathTest
@@ -40,7 +43,7 @@
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
     private final EncodingManager mixedEncoders = new EncodingManager(
-            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
+            new CarFlagEncoder(), new FootFlagEncoder(), new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final AngleCalc ac = new AngleCalc();
@@ -196,7 +199,7 @@ public void testFindInstruction()
         InstructionList il = path.calcInstructions(tr);
         Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
         assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
-        
+
         Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
 
@@ -237,18 +240,18 @@ private RoundaboutGraph()
 
             na.setNode(1, 52.514, 13.348);
             na.setNode(2, 52.514, 13.349);
-            na.setNode(3, 52.5135,13.35);
+            na.setNode(3, 52.5135, 13.35);
             na.setNode(4, 52.514, 13.351);
-            na.setNode(5, 52.5145,13.351);
+            na.setNode(5, 52.5145, 13.351);
             na.setNode(6, 52.513, 13.35);
             na.setNode(7, 52.514, 13.352);
             na.setNode(8, 52.515, 13.351);
             na.setNode(9, 52.513, 13.351);
-          
-           
+
+
             EdgeIteratorState tmpEdge;
             tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-            
+
             // roundabout
             tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
             roundaboutEdges.add(tmpEdge.detach(false));
@@ -267,28 +270,28 @@ private RoundaboutGraph()
 
             tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
             edge3to9 = tmpEdge.detach(false);
-            
+
             setRoundabout(clockwise);
             inverse3to9();
-            
+
         }
-        
-        public void setRoundabout(boolean clockwise)
+
+        public void setRoundabout( boolean clockwise )
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 for (EdgeIteratorState edge : roundaboutEdges)
                 {
                     edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
                     edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
                 }
-            }    
+            }
             this.clockwise = clockwise;
         }
-        
+
         public void inverse3to9()
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to9.getFlags();
                 edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
@@ -297,21 +300,21 @@ public void inverse3to9()
 
         public void inverse3to6()
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to6.getFlags();
                 edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
             }
         }
-        
 
-        private double getAngle(int n1, int n2, int n3, int n4)
+
+        private double getAngle( int n1, int n2, int n3, int n4 )
         {
             double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
             double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
             outOrientation = ac.alignOrientation(inOrientation, outOrientation);
             double delta = (inOrientation - outOrientation);
-            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            delta = clockwise ? (Math.PI + delta) : -1 * (Math.PI - delta);
             return delta;
         }
     }
@@ -322,7 +325,7 @@ private double getAngle(int n1, int n2, int n3, int n4)
     @Test
     public void testCalcInstructionsRoundabout()
     {
-        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
         {
             Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
                     .calcPath(1, 8);
@@ -363,13 +366,13 @@ public void testCalcInstructionsRoundaboutBegin()
                 .calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
-                                    "Finish!"),
+        assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
                 tmpList);
     }
 
     /**
-     * case with one node being containig already exit 
+     * case with one node being containig already exit
      */
     @Test
     public void testCalcInstructionsRoundaboutDirectExit()
@@ -433,9 +436,9 @@ public void testCalcInstructionsRoundaboutIssue353()
 
         na.setNode(1, 52.514, 13.348);
         na.setNode(2, 52.514, 13.349);
-        na.setNode(3, 52.5135,13.35);
+        na.setNode(3, 52.5135, 13.35);
         na.setNode(4, 52.514, 13.351);
-        na.setNode(5, 52.5145,13.351);
+        na.setNode(5, 52.5145, 13.351);
         na.setNode(6, 52.513, 13.35);
         na.setNode(7, 52.514, 13.352);
         na.setNode(8, 52.515, 13.351);
@@ -451,7 +454,7 @@ public void testCalcInstructionsRoundaboutIssue353()
         tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
 
 
-         // roundabout
+        // roundabout
         tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
         tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
@@ -474,14 +477,12 @@ public void testCalcInstructionsRoundaboutIssue353()
         tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
 
 
-        
-        
         Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
                 .calcPath(6, 11);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
-                                    "Finish!"),
+                        "Finish!"),
                 tmpList);
     }
 
@@ -497,7 +498,7 @@ public void testCalcInstructionsRoundaboutClockwise()
                 .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "Continue onto MainStreet",
+        assertEquals(Arrays.asList("Continue onto MainStreet",
                         "At roundabout, take exit 1 onto 5-8",
                         "Finish!"),
                 tmpList);
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index bf667e82dd..c45f2cc45f 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -20,18 +20,23 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
+
 import static com.graphhopper.storage.index.QueryResult.Position.*;
+
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TIntObjectMap;
+
 import java.util.Arrays;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryGraphTest
@@ -428,7 +433,7 @@ PointList getPoints( Graph g, int base, int adj )
     }
 
     public QueryResult createLocationResult( double lat, double lon,
-            EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
+                                             EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
     {
         if (edge == null)
             throw new IllegalStateException("Specify edge != null");
@@ -541,4 +546,147 @@ public void testTurnCostsProperlyPropagated_Issue282()
 
         graphWithTurnCosts.close();
     }
+
+    private void initHorseshoeGraph( Graph g )
+    {
+        // setup graph
+        //   ____
+        //  |    |
+        //  |    |
+        //  0    1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 2);
+        g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(2, 0, 2, 2));
+    }
+
+    private QueryResult fakeEdgeQueryResult( EdgeIteratorState edge, double lat, double lon, int wayIndex )
+    {
+        QueryResult qr = new QueryResult(lat, lon);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(wayIndex);
+        qr.setSnappedPosition(EDGE);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+        return qr;
+    }
+
+    private boolean getEdgePreference( QueryGraph queryGraph, int virtualEdgeTypeId, boolean reverse, boolean _default )
+    {
+        boolean edgeUnfavored = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBoolean(
+                EdgeIteratorState.K_UNFAVORED_EDGE, reverse, _default);
+        return edgeUnfavored;
+    }
+
+    @Test
+    public void testEnforceHeading()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going out north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        boolean expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // test cleared edges south
+        expect = false;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, false, !expect));
+
+        // query result on second vertical part of way (downward)
+        qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, false, !expect));
+    }
+
+    @Test
+    public void testEnforceHeadingByEdgeId()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce coming in north
+        queryGraph.enforceHeadingByEdgeId(2, 1, false);
+        // test penalized south
+        boolean expect = true;
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, 2);
+
+        VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeProps(1, incomingEdge.getBaseNode());
+        // expect incoming edge in reverse direction to be unfavored
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        expect = false;
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+    }
+
+    @Test
+    public void testInternalAPIOriginalTraversalKey()
+    {
+        initGraph(g);
+
+        EdgeExplorer explorer = g.createEdgeExplorer();
+        QueryGraph queryGraph = new QueryGraph(g);
+        EdgeIterator iter = explorer.setBaseNode(1);
+        assertTrue(iter.next());
+        int origEdgeId = iter.getEdge();
+        QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
+        queryGraph.lookup(Arrays.asList(res));
+
+        assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
+        assertEquals(3, res.getClosestNode());
+
+        EdgeExplorer qGraphExplorer = queryGraph.createEdgeExplorer();
+        iter = qGraphExplorer.setBaseNode(3);
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(1, 0, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 0)).getOriginalTraversalKey());
+
+        assertTrue(iter.next());
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(0, 1, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeProps(iter.getEdge(), 1)).getOriginalTraversalKey());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 6252757154..addcbcddfc 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -33,12 +33,15 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -94,6 +97,35 @@ public void testMonaco()
         assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
+    @Test
+    public void testMonacoMotorcycle()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2697, 117));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3749, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 3164, 165));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2423, 141));
+        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2253, 120));
+        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.419333, 0, 1));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-mc-gh",
+                list, "motorcycle", true, "motorcycle", "fastest", true);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testBike2_issue432()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(52.349969, 8.013813, 52.349713, 8.013293, 56, 7));
+        // reverse route avoids the location
+        list.add(new OneRun(52.349713, 8.013293, 52.349969, 8.013813, 293, 21));
+        runAlgo(testCollector, "files/map-bug432.osm.gz", "target/map-bug432-gh",
+                list, "bike2", true, "bike2", "fastest", true);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoAllAlgorithmsWithBaseGraph()
     {
@@ -490,8 +522,8 @@ public void testNeudrossenfeld()
      * takes a bit longer
      */
     Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
-            String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
+                   String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
+                   boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
         AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
@@ -661,8 +693,8 @@ public void run()
     }
 
     static List<AlgoHelperEntry> createAlgos( Graph g,
-            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
-            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+                                              LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+                                              final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
     {
         List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
         prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
@@ -679,7 +711,7 @@ public void run()
         {
             final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
                     set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
                     graphCH, encoder, weighting, tMode);
             prepareCH.doWork();
             LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 44779975c4..a7ad66405e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -23,7 +23,9 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.EdgeSkipIterState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -114,7 +116,7 @@ public void testPathRecursiveUnpacking()
 
         ShortestWeighting weighting = new ShortestWeighting();
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
-        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
+        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
                 g2, encoder, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
@@ -159,7 +161,7 @@ public void testBaseGraph()
         // use base graph for solving normal Dijkstra
         Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 402.29, p1.getDistance(), 1e-2);
         assertEquals(p1.toString(), 144823, p1.getTime());
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index fbba76c1a0..23dd327820 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -22,9 +22,12 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.Collection;
 import java.util.Iterator;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -63,9 +66,10 @@ LevelGraph createExampleGraph()
         g.edge(5, 1, 2, true);
         return g;
     }
-    
+
     @Before
-    public void setUp() {
+    public void setUp()
+    {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
@@ -538,7 +542,7 @@ public static LevelGraph initShortcutsGraph( LevelGraph g )
         return g;
     }
 
-//    public static void printEdges(LevelGraph g) {
+    //    public static void printEdges(LevelGraph g) {
 //        RawEdgeIterator iter = g.getAllEdges();
 //        while (iter.next()) {
 //            EdgeSkipIterator single = g.getEdgeProps(iter.edge(), iter.nodeB());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
index 27e3d9415e..190f66bd43 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.routing.ch;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrepareEncoderTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 30475dd3f9..a67b0f1f62 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -19,11 +19,17 @@
 
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Translation;
+
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
+
 import java.util.Locale;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -353,17 +359,12 @@ public void testReduceToMaxSpeed()
     }
 
     @Test
-    public void testMaxAndMinSpeed()
+    public void testPreferenceForSlowSpeed()
     {
         OSMWay osmWay = new OSMWay(1);
         osmWay.setTag("highway", "tertiary");
         assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49, false))), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
-
-        osmWay.setTag("highway", "tertiary");
-        osmWay.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
-        assertPriority(REACH_DEST.getValue(), osmWay);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index 33d838e9c8..40cb881ac7 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class AbstractFlagEncoderTest
@@ -29,15 +29,22 @@
     @Test
     public void testAcceptsCar()
     {
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40 km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40kmh"), 1e-3);
-        assertEquals(64.374, AbstractFlagEncoder.parseSpeed("40mph"), 1e-3);
-        assertEquals(48.28, AbstractFlagEncoder.parseSpeed("30 mph"), 1e-3);
-        assertEquals(-1, AbstractFlagEncoder.parseSpeed(null), 1e-3);
-        assertEquals(18.52, AbstractFlagEncoder.parseSpeed("10 knots"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19 kph"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19kph"), 1e-3);
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 0);
+        assertEquals(40, encoder.parseSpeed("40 km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40kmh"), 1e-3);
+        assertEquals(64.374, encoder.parseSpeed("40mph"), 1e-3);
+        assertEquals(48.28, encoder.parseSpeed("30 mph"), 1e-3);
+        assertEquals(-1, encoder.parseSpeed(null), 1e-3);
+        assertEquals(18.52, encoder.parseSpeed("10 knots"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19 kph"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19kph"), 1e-3);
+
+        assertEquals(50, encoder.parseSpeed("RO:urban"), 1e-3);
+
+        assertEquals(80, encoder.parseSpeed("RU:rural"), 1e-3);
+
+        assertEquals(6, encoder.parseSpeed("walk"), 1e-3);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index 51894b72b3..f559373833 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -24,17 +24,24 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
 {
-    private Graph initExampleGraph( FlagEncoder instance )
+    private final EncodingManager em = new EncodingManager("bike,bike2");
+
+    @Override
+    protected BikeCommonFlagEncoder createBikeEncoder()
+    {
+        return (BikeCommonFlagEncoder) em.getEncoder("bike2");
+    }
+
+    private Graph initExampleGraph()
     {
-        EncodingManager em = new EncodingManager(instance);
         GraphStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
@@ -44,37 +51,47 @@ private Graph initExampleGraph( FlagEncoder instance )
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
         edge.setDistance(100);
 
-        edge.setFlags(instance.setReverseSpeed(instance.setProperties(10, true, true), 15));
+        edge.setFlags(encoder.setReverseSpeed(encoder.setProperties(10, true, true), 15));
         return gs;
     }
 
     @Test
     public void testApplyWayTags()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         OSMWay way = new OSMWay(1);
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         long flags = edge.getFlags();
         // decrease speed
-        assertEquals(2, instance.getSpeed(flags), 1e-1);
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
         // increase speed but use maximum speed (calculated was 24)
-        assertEquals(18, instance.getReverseSpeed(flags), 1e-1);
+        assertEquals(18, encoder.getReverseSpeed(flags), 1e-1);
     }
-        
+
     @Test
     public void testUnchangedForStepsBridgeAndTunnel()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         long oldFlags = edge.getFlags();
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "steps");
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         assertEquals(oldFlags, edge.getFlags());
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 1e8b6c5acf..7636e6ac76 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -17,9 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -46,10 +50,52 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
         assertPriority(REACH_DEST.getValue(), way);
 
+        // Pushing section !! This is fine as we obey the law!
+        way.clearTags();
+        way.setTag("highway", "footway");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        // Pushing section irrespective of the pavement
+        way.setTag("surface", "paved");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "yes");
+
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("bicycle", "yes");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        // Pushing section Ok !!
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "paved");
         assertEquals(4, encoder.getSpeed(way));
         assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "designated");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "track");
         assertEquals(12, encoder.getSpeed(way));
         assertPriority(UNCHANGED.getValue(), way);
@@ -91,7 +137,21 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
 
         way.setTag("surface", "unknown_surface");
-        assertEquals(4, encoder.getSpeed(way));
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "fine_gravel");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(18, encoder.getSpeed(way));
 
         way.clearTags();
         way.setTag("highway", "residential");
@@ -162,6 +222,12 @@ public void testOneway()
         assertTrue(encoder.isForward(flags));
         assertFalse(encoder.isBackward(flags));
         way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway:bicycle", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
 
         way.setTag("highway", "tertiary");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -176,6 +242,13 @@ public void testOneway()
         assertTrue(encoder.isBackward(flags));
         way.clearTags();
 
+        way.setTag("highway", "tertiary");
+        way.setTag("bicycle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:backward", "no");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -197,15 +270,22 @@ public void testOneway()
         way.setTag("bicycle:backward", "no");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));        
+        assertTrue(encoder.isBackward(flags));
 
         way.setTag("bicycle:backward", "yes");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertTrue(encoder.isForward(flags));
         assertTrue(encoder.isBackward(flags));
+
         way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("cycleway", "opposite");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
     }
-    
+
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
@@ -293,7 +373,7 @@ public void testSacScale()
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // allow
-        assertEquals(1, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
 
         way.setTag("highway", "path");
         way.setTag("sac_scale", "mountain_hiking");
@@ -339,6 +419,18 @@ public void testMaxSpeed()
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
         assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
     }
 
     @Test
@@ -399,4 +491,50 @@ public void testTurnFlagEncoding_withCosts()
         assertTrue(encoder.isTurnRestricted(flags_r220));
         assertFalse(encoder.isTurnRestricted(flags_126));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle", "3");
+        assertPriority(BEST.getValue(), way);
+        way.setTag("class:bicycle", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+        way.setTag("class:bicycle", "1");
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("class:bicycle", "0");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "invalidvalue");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "-1");
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+        way.setTag("class:bicycle", "-2");
+        assertPriority(REACH_DEST.getValue(), way);
+        way.setTag("class:bicycle", "-3");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), way);
+
+        // Now we test overriding by a specific class subtype
+        way.setTag("class:bicycle:touring", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 2dadef1d67..3368bc9805 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CarFlagEncoderTest
@@ -56,12 +56,6 @@ public void testAccess()
         way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        way.clearTags();
-        way.setTag("highway", "service");
-        way.setTag("access", "no");
-        way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
-
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "delivery");
@@ -86,6 +80,54 @@ public void testAccess()
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
         assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        try
+        {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally
+        {
+            encoder.setBlockFords(true);
+        }
     }
 
     @Test
@@ -123,15 +165,6 @@ public void testOneway()
         way.clearTags();
     }
 
-    @Test
-    public void testMilitaryAccess()
-    {
-        OSMWay way = new OSMWay(1);
-        way.setTag("highway", "track");
-        way.setTag("access", "military");
-        assertFalse(encoder.acceptWay(way) > 0);
-    }
-
     @Test
     public void testSetAccess()
     {
@@ -164,7 +197,7 @@ public void testMaxSpeed()
         way.setTag("maxspeed", "500");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        assertEquals(140, encoder.getSpeed(encoded), 1e-1);
 
         way = new OSMWay(1);
         way.setTag("highway", "primary");
@@ -184,6 +217,12 @@ public void testMaxSpeed()
         way.setTag("maxspeed:backward", "20");
         encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", "none");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(125, encoder.getSpeed(encoded), .1);
     }
 
     @Test
@@ -232,6 +271,18 @@ public void testSetSpeed()
         assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
     }
 
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, encoder.speedFactor * 0.49);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(0, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+    }
+
     @Test
     public void testRoundabout()
     {
@@ -419,7 +470,7 @@ public void testTurnFlagEncoding_withCosts()
     @Test
     public void testMaxValue()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -431,19 +482,19 @@ public void testMaxValue()
         assertEquals(86.9, instance.getSpeed(flags), 1e-1);
         flags = instance.reverseFlags(flags);
         assertEquals(86.9, instance.getSpeed(flags), 1e-1);
-        
+
         // test that maxPossibleValue  is not exceeded
         way = new OSMWay(2);
         way.setTag("highway", "motorway_link");
         way.setTag("maxspeed", "70 mph");
         flags = instance.handleWayTags(way, 1, 0);
-        assertEquals(100, instance.getSpeed(flags), 1e-1);
+        assertEquals(101.5, instance.getSpeed(flags), .1);
     }
 
     @Test
     public void testRegisterOnlyOnceAllowed()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         try
         {
@@ -462,39 +513,12 @@ public void testSetToMaxSpeed()
         assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
     }
 
-    @Test
-    public void testFordAccess()
-    {
-        OSMNode node = new OSMNode(0, 0.0, 0.0);
-        node.setTag("ford", "yes");
-
-        OSMWay way = new OSMWay(1);
-        way.setTag("highway", "unclassified");
-        way.setTag("ford", "yes");
-
-        // Node and way are initially blocking
-        assertTrue(encoder.isBlockFords());
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.handleNodeTags(node) > 0);
-
-        try
-        {
-            // Now they are passable
-            encoder.setBlockFords(false);
-            assertTrue(encoder.acceptWay(way) > 0);
-            assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally
-        {
-            encoder.setBlockFords(true);
-        }
-    }
-
     @Test
     public void testCombination()
     {
         OSMWay way = new OSMWay(123);
         way.setTag("highway", "cycleway");
-        way.setTag("sac_scale", "hiking");        
+        way.setTag("sac_scale", "hiking");
 
         long flags = em.acceptWay(way);
         long edgeFlags = em.handleWayTags(way, flags, 0);
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
index 220a204e0f..f69318a049 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -20,10 +20,10 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedDoubleValueTest
@@ -53,7 +53,7 @@ public void testMaxValueAndSwap()
         long swappedFlags = instance1.swap(flags, instance2);
         assertEquals(expectedFlags, swappedFlags);
 
-        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
         new EncodingManager(carEncoder);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -62,6 +62,14 @@ public void testMaxValueAndSwap()
 
         // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
         flags = carEncoder.reverseFlags(flags);
-        assertEquals(100, carEncoder.getSpeed(flags), 1e-1);
+        assertEquals(101.5, carEncoder.getSpeed(flags), 1e-1);
+    }
+
+    @Test
+    public void testUnsignedRightShift_issue417()
+    {
+        EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);
+        Long flags = -72057594037927936L;
+        assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
index 9fcb71771d..6ceb80be0c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedValueTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 0ae178541d..90904a99fe 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -31,13 +31,12 @@
 import org.junit.rules.ExpectedException;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodingManagerTest
 {
     @Rule
-    public ExpectedException thrown= ExpectedException.none();
+    public ExpectedException thrown = ExpectedException.none();
 
     @Test
     public void testCompatibility()
@@ -101,11 +100,12 @@ public void testWrongEncoders()
     }
 
     @Test
-    public void testToDetailsStringIncludesEncoderVersionNumber() {
-        FlagEncoder encoder = new AbstractFlagEncoder(1,2.0,3)
+    public void testToDetailsStringIncludesEncoderVersionNumber()
+    {
+        FlagEncoder encoder = new AbstractFlagEncoder(1, 2.0, 3)
         {
             @Override
-            public short getVersion()
+            public int getVersion()
             {
                 return 10;
             }
@@ -123,19 +123,19 @@ protected String getPropertiesString()
             }
 
             @Override
-            public long handleRelationTags(OSMRelation relation, long oldRelationFlags)
+            public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
             {
                 return 0;
             }
 
             @Override
-            public long acceptWay(OSMWay way)
+            public long acceptWay( OSMWay way )
             {
                 return 0;
             }
 
             @Override
-            public long handleWayTags(OSMWay way, long allowed, long relationFlags)
+            public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             {
                 return 0;
             }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index 816310c551..11464b6731 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -37,6 +41,32 @@ public void testMinWeightHasSameUnitAs_getWeight()
         assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
+    @Test
+    public void testWeightWrongHeading()
+    {
+        FastestWeighting instance = new FastestWeighting(encoder, new PMap().put("heading_penalty", "100"));
+
+        VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
+                encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
+        double time = instance.calcWeight(virtEdge, false, 0);
+
+        virtEdge.setVirtualEdgePreference(true, false);
+        // heading penalty on edge
+        assertEquals(time + 100, instance.calcWeight(virtEdge, false, 0), 1e-8);
+        // but not in reverse heading
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // only after setting it
+        virtEdge.setVirtualEdgePreference(true, true);
+        assertEquals(time + 100, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // but not after releasing it
+        virtEdge.setVirtualEdgePreference(false, true);
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+
+        // test default penalty
+        instance = new FastestWeighting(encoder);
+        assertEquals(time + FastestWeighting.DEFAULT_HEADING_PENALTY, instance.calcWeight(virtEdge, false, 0), 1e-8);
+    }
+
     @Test
     public void testSpeed0()
     {
@@ -63,6 +93,12 @@ public long getFlags()
             {
                 return flags;
             }
+
+            @Override
+            public boolean getBoolean( int key, boolean reverse, boolean _default )
+            {
+                return _default;
+            }
         };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 8e36afe2c8..bf68dea26c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -25,10 +25,10 @@
 import com.graphhopper.util.GHUtility;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class FootFlagEncoderTest
@@ -133,6 +133,14 @@ public void testAccess()
         assertTrue(footEncoder.acceptWay(way) > 0);
         way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
+        way.setTag("access", "yes");
+        assertFalse(footEncoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("foot", "yes");
+        way.setTag("access", "no");
+        assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "track");
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 92f737654c..725da43dd8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoderTest
@@ -41,4 +41,16 @@ public void testHandleWayTags()
         assertEquals(20, encoder.getSpeed(result), .1);
         assertEquals(20, encoder.getReverseSpeed(result), .1);
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index 6fcd32a6f8..cd76e482a1 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -201,4 +205,30 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("", getWayTypeFromFlags(osmWay));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag = no
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "no");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 61a2936111..81d5862083 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -23,14 +23,16 @@
 import com.graphhopper.util.GHUtility;
 
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
@@ -54,6 +56,7 @@ GraphStorage createSubnetworkTestGraph()
         g.edge(8, 11, 1, true);
         g.edge(12, 11, 1, true);
         g.edge(9, 12, 1, false);
+        g.edge(9, 15, 1, true);
 
         // large network
         g.edge(0, 13, 1, true);
@@ -80,7 +83,7 @@ public void testFindSubnetworks()
         // start is at 0 => large network
         assertEquals(5, (int) map.get(0));
         // next smallest and unvisited node is 1 => big network
-        assertEquals(7, (int) map.get(1));
+        assertEquals(8, (int) map.get(1));
         assertEquals(3, (int) map.get(6));
     }
 
@@ -93,11 +96,11 @@ public void testKeepLargestNetworks()
         instance.keepLargeNetworks(map);
         g.optimize();
 
-        assertEquals(7, g.getNodes());
+        assertEquals(8, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         map = instance.findSubnetworks();
         assertEquals(1, map.size());
-        assertEquals(7, (int) map.get(0));
+        assertEquals(8, (int) map.get(0));
     }
 
     GraphStorage createSubnetworkTestGraph2( EncodingManager em )
@@ -108,6 +111,8 @@ GraphStorage createSubnetworkTestGraph2( EncodingManager em )
         g.edge(1, 3, 1, true);
         g.edge(0, 2, 1, true);
         g.edge(2, 3, 1, true);
+        g.edge(3, 7, 1, true);
+        g.edge(7, 8, 1, true);
 
         // connecting both but do not allow CAR!
         g.edge(3, 4).setDistance(1);
@@ -127,10 +132,10 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(4);
         instance.doWork();
         g.optimize();
-        assertEquals(4, g.getNodes());
+        assertEquals(6, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         EdgeExplorer explorer = g.createEdgeExplorer();
-        assertEquals(GHUtility.asSet(2, 1), GHUtility.getNeighbors(explorer.setBaseNode(3)));
+        assertEquals(GHUtility.asSet(2, 1, 5), GHUtility.getNeighbors(explorer.setBaseNode(3)));
 
         // do not remove because small network is big enough
         g = createSubnetworkTestGraph2(em);
@@ -138,7 +143,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
 
         // do not remove because two two vehicles
         EncodingManager em2 = new EncodingManager("CAR,BIKE");
@@ -147,7 +152,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
     }
 
     GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
@@ -236,7 +241,7 @@ public void testTarjan()
         }), components.get(2));
         assertEquals(new TIntArrayList(new int[]
         {
-            9
+            15, 9
         }), components.get(3));
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index 6012124c1a..ff59093c34 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author ratrun
  */
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -77,12 +79,12 @@ public void testSacScale()
         way.setTag("sac_scale", "mountain_hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
-        
+
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
-        
+
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
         // but allow this as there is no reason for not allowing it
@@ -113,6 +115,21 @@ public void testGetSpeed()
         way.clearTags();
         way.setTag("highway", "steps");
         assertEquals(2, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "unknownpavement");
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
+
     }
 
     @Test
@@ -186,4 +203,79 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
     }
+
+    @Test
+    public void testAvoidanceOfHighMaxSpeed()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "tertiary");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "60");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "motorway");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(REACH_DEST.getValue(), osmWay);
+
+        osmWay.setTag("tunnel", "yes");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle:roadcycling", "3");
+        assertPriority(BEST.getValue(), way);
+
+        way.setTag("class:bicycle", "-2");
+        assertPriority(BEST.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index 746d286993..cdc35ad737 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -18,11 +18,13 @@
 package com.graphhopper.search;
 
 import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.Helper;
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NameIndexTest
@@ -90,4 +92,26 @@ public void testTooLongNameNoError()
         index.put(str);
         index.close();
     }
+
+    @Test
+    public void testFlush()
+    {
+        String location = "./target/nameindex-store";
+        Helper.removeDir(new File(location));
+
+        NameIndex index = new NameIndex(new RAMDirectory(location, true)).create(1000);
+        long pointer = index.put("test");
+        index.flush();
+        index.close();
+
+        index = new NameIndex(new RAMDirectory(location, true));
+        assertTrue(index.loadExisting());
+        assertEquals("test", index.get(pointer));
+        // make sure bytePointer is correctly set after loadExisting
+        long newPointer = index.put("testing");
+        assertEquals(newPointer + ">" + pointer, pointer + "test".getBytes().length + 1, newPointer);
+        index.close();
+
+        Helper.removeDir(new File(location));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index 8850b1c893..5f293ad0b1 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -18,10 +18,13 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
index 6e73952da5..ad50056f67 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -20,10 +20,14 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -84,7 +88,7 @@ public void testForceDelete()
         // on windows we cannot forcefully remove an unreleased lock
         if (Constants.WINDOWS)
             lock.release();
-        
+
         instance.forceRemove(lock.getName(), true);
         assertFalse(lock.isLocked());
     }
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index f5ae8eb1d9..6beee78b72 100644
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -19,15 +19,18 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/EdgeTest.java b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
index 6d840af599..cdc47c664f 100644
--- a/core/src/test/java/com/graphhopper/storage/EdgeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.util.EdgeIterator;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeTest
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index ff4bdbacc0..31c0a284b3 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -19,12 +19,14 @@
 
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperStorageTest extends AbstractGraphStorageTester
@@ -106,7 +108,7 @@ protected void checkGraph( Graph g )
         NodeAccess na = g.getNodeAccess();
         assertTrue(na.is3D());
         assertTrue(g.getBounds().isValid());
-        
+
         assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index e624d5ce83..5865ca16ac 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -28,7 +28,6 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- *
  * @author Karl HÃ¼bner
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index b7c216b4fb..e2b10885a4 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -26,7 +26,9 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -225,7 +227,7 @@ public void testQueryGraph()
         EdgeIteratorState edge1 = levelGraph.edge(0, 1);
         EdgeIteratorState edge2 = levelGraph.edge(1, 2);
         levelGraph.shortcut(0, 1);
-        
+
         QueryGraph qGraph = new QueryGraph(levelGraph);
         QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
         QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index 941d81b485..261a254183 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
index 722025ebe0..738e019cc0 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class MMapDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
index ddeaa9e012..a853da7b02 100644
--- a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -19,11 +19,12 @@
 package com.graphhopper.storage;
 
 import java.nio.channels.OverlappingFileLockException;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
index 61430209fd..51ce1226b9 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
index 542d875c42..92cba0d9be 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
index fae20891f4..41c28047fc 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMIntDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index 1f9badefe4..ef6bb7eef9 100644
--- a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -19,7 +19,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
index d758826e03..922a87db3d 100644
--- a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
+++ b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class StorablePropertiesTest
diff --git a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
index cebaee0c5b..76ec1c41e3 100644
--- a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SynchedDAWrapperTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
index 824f6a881f..db70ee4313 100644
--- a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.BitUtil;
+
 import java.nio.ByteOrder;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class UnsafeDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
index 7cb369e6e1..1719234f99 100644
--- a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index e447b1c058..fa925c1504 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -31,11 +31,15 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import java.io.Closeable;
 import java.io.File;
 import java.util.Random;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -193,8 +197,8 @@ public void testGrid()
             }
 
             assertTrue(i + " orig:" + (float) lat + "," + (float) lon
-                    + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
-                    + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
+                            + " full:" + fullLat + "," + fullLon + " fullDist:" + fullDist
+                            + " found:" + newLat + "," + newLon + " foundDist:" + newDist,
                     Math.abs(fullDist - newDist) < 50000);
         }
         fullIndex.close();
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 50d76f5d68..36b61b1892 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -21,14 +21,17 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+
 import java.util.ArrayList;
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class BresenhamLineTest
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
index 5d6ef736fb..918c9c00a0 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
index dfb41251ce..65478c3cff 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullWithEdgesIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index bb43cef11b..e192f7c8ee 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -21,11 +21,12 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.MMapDirectory;
 import com.graphhopper.storage.RAMDirectory;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDQuadtreeTest extends AbstractLocationIndexTester
@@ -33,7 +34,7 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        if(resolution < 0)
+        if (resolution < 0)
             resolution = 120;
         return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
                 setResolution(resolution).prepareIndex();
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 0f3c93d92b..9df6bf1504 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -31,10 +31,13 @@
 import gnu.trove.list.TIntList;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index f4a24cfc41..cd4b223136 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -26,12 +26,14 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class LocationIndexTreeTest extends AbstractLocationIndexTester
@@ -43,7 +45,7 @@
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
         if (resolution < 0)
-            resolution = 500000;        
+            resolution = 500000;
         return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
diff --git a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
index 48a9fc00ac..945b3fee3c 100644
--- a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
+++ b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index f41b24ae4b..e5257f79c7 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -91,4 +92,30 @@ public void testAtan2()
         assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
         assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
     }
+    
+    @Test
+    public void testConvertAzimuth2xaxisAngle()
+    {
+        assertEquals(Math.PI/2, ac.convertAzimuth2xaxisAngle(0), 1E-6);
+        assertEquals(Math.PI/2, Math.abs(ac.convertAzimuth2xaxisAngle(360)), 1E-6);
+        assertEquals(0, ac.convertAzimuth2xaxisAngle(90), 1E-6);
+        assertEquals(-Math.PI/2, ac.convertAzimuth2xaxisAngle(180), 1E-6);
+        assertEquals(Math.PI, Math.abs(ac.convertAzimuth2xaxisAngle(270)), 1E-6);
+        assertEquals(-3*Math.PI/4, ac.convertAzimuth2xaxisAngle(225), 1E-6);
+        assertEquals(3*Math.PI/4, ac.convertAzimuth2xaxisAngle(315), 1E-6);
+    }
+    
+    @Test
+    public void checkAzimuthConsitency()
+    {
+        double azimuthDegree =  ac.calcAzimuth(0, 0, 1, 1);
+        double radianXY = ac.calcOrientation(0, 0, 1, 1);
+        double radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+
+        azimuthDegree =  ac.calcAzimuth(0, 4, 1, 3);
+        radianXY = ac.calcOrientation(0, 4, 1, 3);
+        radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
index be026ba6e6..893a59a548 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilBigTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
index cf314ac516..d4e2d51ecf 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilLittleTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index 80d48d7f28..bf5ae074d0 100644
--- a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -25,10 +25,10 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BreadthFirstSearchTest
@@ -79,7 +79,7 @@ public boolean goFurther( int v )
         assertEquals(g.getNodes(), counter);
         assertEquals("{0, 5, 3, 2, 1, 10, 8, 7, 6, 9, 4}", list.toString());
     }
-    
+
     @Test
     public void testBFS2()
     {
@@ -110,5 +110,5 @@ public boolean goFurther( int v )
         assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
     }
 
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index 9aa311807b..fce6e2d53f 100644
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -25,14 +25,15 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author jan
  */
-public class DepthFirstSearchTest {
-    
+public class DepthFirstSearchTest
+{
+
     int counter;
     TIntHashSet set = new TIntHashSet();
     TIntList list = new TIntArrayList();
@@ -42,7 +43,7 @@ public void setup()
     {
         counter = 0;
     }
-    
+
     @Test
     public void testDFS1()
     {
@@ -58,13 +59,13 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
         g.edge(1, 2, 1, false);
         g.edge(1, 5, 1, false);
-        g.edge(1, 4, 1, false);       
+        g.edge(1, 4, 1, false);
         g.edge(2, 3, 1, false);
         g.edge(3, 4, 1, false);
         g.edge(5, 6, 1, false);
@@ -75,7 +76,7 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4, 5, 6}", list.toString());
     }
-    
+
     @Test
     public void testDFS2()
     {
@@ -91,7 +92,7 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
@@ -106,5 +107,5 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4}", list.toString());
     }
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 4c8f3b0928..8d1d9c4985 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class DistanceCalcEarthTest
@@ -35,18 +36,6 @@ public void testCalcCircumference()
         assertEquals(DistanceCalcEarth.C, dc.calcCircumference(0), 1e-7);
     }
 
-    @Test
-    public void testGeohashMaxDist()
-    {
-        DistanceCalcEarth dce = new DistanceCalcEarth();
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(0), 1);
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(1), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(2), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(3), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(4), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(5), 1);
-    }
-
     @Test
     public void testDistance()
     {
diff --git a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
index c13e850f06..f8d7bd9a2a 100644
--- a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
+++ b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class DouglasPeuckerTest
@@ -69,6 +69,7 @@ public void testSimplifyCheckPointCount()
         assertEquals(20, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
     }
+
     String points2 = "[[9.961074440801317,50.203764443183644],[9.96106605889796,50.20365789987872],[9.960999562464645,50.20318963087774],[9.96094144793469,50.202952888673984],[9.96223002587773,50.20267889356641],[9.962200968612752,50.20262022024289],"
             + "[9.961859918278305,50.201853928011374],[9.961668810881722,50.20138565901039],[9.96216874485095,50.20128507617008],[9.961953795595925,50.20088553877664],[9.961899033827313,50.200686794534775],[9.961716680863127,50.20014066696481],[9.961588158344957,50.199798499043254]]";
 
@@ -82,7 +83,7 @@ public void testSimplifyCheckPointOrder()
         assertEquals(11, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
         assertEquals("(50.203764443183644,9.961074440801317), (50.20318963087774,9.960999562464645), (50.202952888673984,9.96094144793469), (50.20267889356641,9.96223002587773), (50.201853928011374,9.961859918278305), "
-                + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
+                        + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
                 pointList.toString());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java b/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
index a9cd7acf44..2f5f731492 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
@@ -23,11 +23,12 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.LevelGraph;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeSkipIteratorTest
diff --git a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
index 0bf9821c66..3a1f77790e 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeWrapperTest
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index a9a8e09991..6a0def1aef 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -22,11 +22,12 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHUtilityTest
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 6d74020038..84ff8d2cae 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -19,13 +19,15 @@
 
 import java.io.File;
 import java.util.Locale;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class HelperTest
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index ab8763aeae..1b163e036b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -27,6 +27,7 @@
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
+
 import java.io.*;
 import java.util.*;
 import javax.xml.XMLConstants;
@@ -38,12 +39,13 @@
 
 import org.json.JSONObject;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
- *
  * @author Peter Karich
  */
 public class InstructionListTest
@@ -53,9 +55,10 @@
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private EncodingManager carManager;
     private FlagEncoder carEncoder;
-    
+
     @Before
-    public void setUp() {
+    public void setUp()
+    {
         carEncoder = new CarFlagEncoder();
         carManager = new EncodingManager(carEncoder);
     }
@@ -63,7 +66,7 @@ public void setUp() {
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {                
+    {
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -113,13 +116,13 @@ public void testWayList()
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
-                "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
+                        "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
-                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
+                        "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
@@ -136,7 +139,7 @@ public void testWayList()
         assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.1d, 1.1), asL(1.0, 1.1),
-                asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
+                        asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
@@ -462,7 +465,7 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {        
+    {
         Graph g = new GraphBuilder(carManager).create();
         Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
@@ -493,4 +496,45 @@ public void verifyGPX( String gpx )
             throw new RuntimeException(e);
         }
     }
+    
+    @Test
+    public void testFind()
+    {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        //   3-2
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        PointList waypoint = new PointList();
+        waypoint.add(15.2, 9.9);
+        na.setNode(4, 15.2, 10);
+        na.setNode(5, 15.2, 10.1);
+
+        g.edge(1, 2, 10000, true).setName("1-2");
+        g.edge(2, 3, 10000, true).setName("2-3");
+        g.edge(3, 4, 10000, true).setName("3-4").setWayGeometry(waypoint);
+        g.edge(4, 5, 10000, true).setName("4-5");
+
+
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(usTR);
+        
+        // query on first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10, 1000).getName());
+        
+        // query east of first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10.001, 1000).getName());
+
+        // query south-west of node 3, get instruction for third edge
+        assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
+
+        // query north-west of pillar node n , get instruction for fourth edge
+        assertEquals("4-5", wayList.find(15.21, 9.85, 100000).getName());
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 70d8a5f83a..522a3f0a96 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Johannes Pelzer
  */
 public class InstructionTest
@@ -32,7 +32,7 @@ public void testCalcAzimuthAndGetDirection()
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
-        
+
         PointList nextPl = new PointList();
         nextPl.add(49.942, 11.582);
         Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
diff --git a/core/src/test/java/com/graphhopper/util/PMapTest.java b/core/src/test/java/com/graphhopper/util/PMapTest.java
index a9043a9114..b9ae820355 100644
--- a/core/src/test/java/com/graphhopper/util/PMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/PMapTest.java
@@ -38,21 +38,24 @@ public void keyCanHaveAnyCasing()
     }
 
     @Test
-    public void numericPropertyCanBeRetrievedAsLong() {
+    public void numericPropertyCanBeRetrievedAsLong()
+    {
         PMap subject = new PMap("foo=1234|bar=5678");
 
         assertEquals(1234L, subject.getLong("foo", 0));
     }
 
     @Test
-    public void numericPropertyCanBeRetrievedAsDouble() {
+    public void numericPropertyCanBeRetrievedAsDouble()
+    {
         PMap subject = new PMap("foo=123.45|bar=56.78");
 
         assertEquals(123.45, subject.getDouble("foo", 0), 1e-4);
     }
 
     @Test
-    public void hasReturnsCorrectResult() {
+    public void hasReturnsCorrectResult()
+    {
         PMap subject = new PMap("foo=123.45|bar=56.78");
 
         assertTrue(subject.has("foo"));
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index f517e9c3fd..7bd901b9f0 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
index c228f76148..3bbd105f37 100644
--- a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
+++ b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleIntDequeTest
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 32efe3ae2d..0f149fe65d 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import java.util.Locale;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class TranslationMapTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index 95b0918947..e1e894dda6 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BBoxTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index f6140bbe84..c210c58af1 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CircleTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index e8847d47fd..4e2980bed7 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CoordTrigTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
index aa8c97562e..3ea1f41435 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPoint3DTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
index 6adac39794..eb324c71c5 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPointTest
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
index 2e455b0867..913bee91b9 100644
--- a/docs/android/android-studio-setup.md
+++ b/docs/android/android-studio-setup.md
@@ -4,7 +4,8 @@ Get the [GraphHopper sources and demo](./index.md) before you proceed.
 
 ## Setup
 
-[Download](http://developer.android.com/sdk/index.html) and start android studio
+[Download](http://developer.android.com/sdk/index.html) and start android studio. 
+Now you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar
 
 Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
 
diff --git a/docs/android/index.md b/docs/android/index.md
index db67b378d7..cf86b7f66a 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -25,7 +25,7 @@ Download the [Android SDK](http://developer.android.com/sdk/installing/index.htm
 go to the Android SDK Manager and install at least 2.3 (API 9).
 
 ### Maven or NetBeans
- 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
+ 1. Download [Maven Android SDK Deployer](https://github.com/simpligility/maven-android-sdk-deployer) and execute `mvn install -P 5.1` - it uses [Android Maven Plugin](http://simpligility.github.io/android-maven-plugin/) under the hood where you need to set up ANDROID_HOME
  2. Now do `./graphhopper.sh android`
 
 ### Gradle
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
index ff93ae5036..be932c422a 100644
--- a/docs/core/create-new-flagencoder.md
+++ b/docs/core/create-new-flagencoder.md
@@ -20,6 +20,7 @@ see Bike2WeightFlagEncoder for an example. You'll have to overwrite the followin
  * flagsDefault 
  * setProperties
  * reverseFlags
+ * setLowSpeed
 
 To incorporate or precalculate values based on the elevation data you can hook into applyWayTags
 and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index f6cab16714..bc70a7917b 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -5,7 +5,7 @@
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md). 
 
-Now, before you proceed install git and jdk6, 7 or 8. Then do:
+Now, before you proceed install git and jdk7 or 8, then do:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git
@@ -29,10 +29,16 @@ $ ./graphhopper.sh web north-america_us_new-york.pbf
 
 ## Start Development
 
-Open the project with NetBeans or enable Maven in your IDE. 
+Open the project with NetBeans, IntelliJ or enable Maven in your IDE. 
 [Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
 installed when executing graphhopper.sh.
 
+### NetBeans, IntelliJ, Eclipse
+
+ * For IntelliJ you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar. See the [special setup](../android/android-studio-setup.md) for Android if using Android studio.
+ * For Eclipse please refer to [this separate setup documentation](./eclipse-setup.md).
+ * Nothing special needs to be done for NetBeans.
+
 ### Java, Embedded Usage
 
 Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 42ebe461e3..166b68d6bc 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -1,8 +1,8 @@
 To do routing in your Java code you'll need just a few lines of code:
 
 ```java
+// create singleton
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.setInMemory(true);
 hopper.setOSMFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
@@ -15,7 +15,8 @@ hopper.importOrLoad();
 // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
 GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
     setWeighting("fastest").
-    setVehicle("car");
+    setVehicle("car").
+    setLocale(Locale.US);
 GHResponse rsp = hopper.route(req);
 
 // first check for errors
@@ -25,22 +26,20 @@ if(rsp.hasErrors()) {
    return;
 }
 
-// route was found? e.g. if disconnected areas (like island) 
-// no route can ever be found
-if(!rsp.isFound()) {
-   // handle properly
-   return;
-}
-
 // points, distance in meters and time in millis of the full path
 PointList pointList = rsp.getPoints();
 double distance = rsp.getDistance();
 long timeInMs = rsp.getTime();
 
-// get the turn instructions for the path
 InstructionList il = rsp.getInstructions();
-Translation tr = trMap.getWithFallBack(Locale.US);
-List<String> iList = il.createDescription(tr);
+// iterate over every turn instruction
+for(Instruction instruction : il) {
+   instruction.getDistance();
+   ...
+}
+
+// or get the json
+List<Map<String, Object>> iList = il.createJson();
 
 // or get the result as gpx entries:
 List<GPXEntry> list = il.createGPXList();
@@ -55,8 +54,7 @@ Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.disableCHShortcuts();
-hopper.setInMemory(true);
+hopper.setCHEnable(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
 hopper.setEncodingManager(new EncodingManager("car,bike"));
@@ -68,8 +66,18 @@ GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
 GHResponse res = hopper.route(req);
 ```
 
+In the flexibility mode it is also possible to add a desired heading (north based azimuth between 0 and 360 degree)
+to any point,
+```java
+GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
+```
+or to avoid u-turns at via points
+```java
+req.getHints().put("pass_through", true);
+```
+ 
 In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
- see the 'web' sub module.
+ see the 'web' sub module or [the Java client for the GraphHopper Directions API](https://github.com/graphhopper/directions-api-java-client).
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
@@ -79,4 +87,4 @@ gh.load("http://your-graphhopper-service.com");
 // gh.load("https://graphhopper.com/api/1/route");
 
 GHResponse rsp = gh.route(new GHRequest(...));
-```
\ No newline at end of file
+```
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index f8a190dc4e..4b0027bd75 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -14,7 +14,7 @@ All official parameters are shown in the following table
 
 Parameter   | Default | Description
 :-----------|:--------|:-----------
-point       | -       | Specifiy multiple points for which the route should be calculated. The order is important. Specify at least two points.
+point       | -       | Specify multiple points for which the route should be calculated. The order is important. Specify at least two points.
 locale      | en      | The locale of the result. E.g. `pt_PT` for Portuguese or `de` for German
 instructions| true    | If instruction should be calculated and returned
 vehicle     | car     | The vehicle for which the route should be calculated. Other vehicles are foot and bike
@@ -25,6 +25,9 @@ points_encoded     | true    | If `false` a GeoJson array in `point` is returned
 debug              | false   | If true, the output will be formated.
 calc_points        | true    | If the points for the route should be calculated at all. Sometimes only the distance and time is necessary.
 type               | json    | Specifies the resulting format of the route, for json the content type will be application/json. Other possible format options: <br> jsonp you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> gpx, the content type will be application/xml
+heading            | NaN     | Favored heading direction for points. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree, NaN indicates non specific heading. Does only give valid results in the flexibility mode.
+heading_penalty    | 120     | Penalty for omitting a specified heading. The penalty corresponds to the accepted time delay in seconds in comparison to the route without a heading.
+pass_through       | false   | If `true` u-turns are avoided at via-points with regard to the heading_penalty. Does only give valid results in the flexibility mode.
 
 ## Example output for the case type=json
 
@@ -49,7 +52,7 @@ paths[0].instructions[0].sign                 | A number which specifies the sig
 paths[0].instructions[0].annotation_text      | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
 paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
-paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Null if the direction of rotation is undefined.
 
 ```json
 {
@@ -147,13 +150,11 @@ import_date         | [optional] The date time at which the OSM import was done
 prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
 supported_vehicles  | [deprecated] An array of strings for all supported vehicles
 
-### Output if expected error(s) while routing:
+### Error Output
 ```json
 {
-  "info": {"errors": [{
-    "details": "java.lang.IllegalArgumentException",
-    "message": "Cannot find point 2: 2248.224673, 3.867187"
-  }]}
+  "message": "Cannot find point 2: 2248.224673, 3.867187",
+  "hints": [{"message": "something", ...}]
 }
 ```
 
@@ -162,9 +163,8 @@ indicate a bug in the routing engine and is expected to a certain degree if too
 
 JSON path/attribute    | Description
 :----------------------|:------------
-info.errors            | A list of error messages
-info.errors[0].details | E.g. to see the underlying exception, if any
-info.errors[0].message | Not intended to be displayed to the user as it is currently not translated
+message                | Not intended to be displayed to the user as it is not translated
+hints                  | An optional list of details regarding the error message e.g. `[{"message": "first error message in hints"}]`
 
 
 ### HTTP Error codes
diff --git a/pom.xml b/pom.xml
index 0837ca65c5..dadb688542 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.10</slf4j.version>
+        <slf4j.version>1.7.12</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -44,6 +44,8 @@
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>2</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>*</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>        
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>        
     </properties>
     
     <scm>
@@ -91,7 +93,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.2</version>
+                <version>3.3</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -137,7 +139,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.10.1</version>
+                <version>2.10.3</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -147,12 +149,12 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.5.3</version>                    
+                <version>2.5.4</version>                    
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>2.5</version>
+                <version>2.6</version>
             </plugin>
             <plugin>
                 <artifactId>maven-war-plugin</artifactId>
@@ -185,7 +187,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.5</version>
+                        <version>1.6</version>
                         <executions>
                             <execution>
                                 <id>sign-artifacts</id>
diff --git a/tools/src/main/java/com/graphhopper/tools/Bzip2.java b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
index f47d748caf..a950b48f46 100644
--- a/tools/src/main/java/com/graphhopper/tools/Bzip2.java
+++ b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
@@ -18,9 +18,11 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.util.Helper;
+
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+
 import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
 
 /**
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 48fd784f85..29e85fd9f9 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -34,6 +34,7 @@
 import com.graphhopper.util.MiniPerfTest;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.SimpleDateFormat;
@@ -44,6 +45,7 @@
 import java.util.TreeMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -56,6 +58,7 @@ public static void main( String[] strs )
     {
         new Measurement().start(CmdArgs.read(strs));
     }
+
     private static final Logger logger = LoggerFactory.getLogger(Measurement.class);
     private final Map<String, String> properties = new TreeMap<String, String>();
     private long seed;
@@ -196,7 +199,7 @@ public int doCalc( boolean warmup, int run )
     }
 
     private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
-            final String vehicle, final boolean withInstructions )
+                                        final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index b5f0a20353..617ccf9b80 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -24,6 +24,7 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.*;
 import java.net.URLEncoder;
 import java.util.*;
@@ -31,6 +32,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -45,6 +47,7 @@ public static void main( String[] args )
     {
         new QueryTorture().start(CmdArgs.read(args));
     }
+
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private ExecutorService service;
     private BlockingQueue<Query> queryQueue;
@@ -176,7 +179,7 @@ void execute( int workerNo ) throws InterruptedException
         try
         {
             String url = baseUrl + query.createQueryString();
-            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
+            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url, false);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 94afcf8e3d..5895e43c5c 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index f7872e7bcf..46e8609e85 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index 0ee0376450..6288307fb7 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index 3b6e1264fa..5896045b7d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
index 42595d979f..d62fa20563 100644
--- a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
+++ b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
@@ -20,6 +20,7 @@
 import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.awt.image.RescaleOp;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,9 +37,9 @@
     // a bit transparent:
 //    private RescaleOp op = new RescaleOp(new float[]{1f, 1f, 1f, 0.5f}, new float[4], null);
     private RescaleOp op = new RescaleOp(new float[]
-    {
-        1f, 1f, 1f, 1f
-    }, new float[4], null);
+            {
+                    1f, 1f, 1f, 1f
+            }, new float[4], null);
 
     protected abstract void paintComponent( Graphics2D createGraphics );
 
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index edb05aefbb..0c853caa50 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -20,9 +20,11 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.shapes.BBox;
+
 import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Graphics2D;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -126,6 +128,7 @@ public void plot( Graphics2D g2, double lat, double lon, int width )
         double y = getY(lat);
         g2.fillOval((int) x, (int) y, width, width);
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
 
     void scale( int x, int y, boolean zoomIn )
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 3ac7aa2074..30587d2d51 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -29,10 +29,12 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
+
 import java.awt.*;
 import java.awt.event.*;
 import java.util.Random;
 import javax.swing.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -54,6 +56,7 @@ public static void main( String[] strs ) throws Exception
         boolean debug = args.getBool("minigraphui.debug", false);
         new MiniGraphUI(hopper, debug).visualize();
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
     private RoutingAlgorithmFactory algoFactory;
@@ -349,6 +352,7 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
         logger.info("dist:" + tmpPath.getDistance() + ", path points(" + list.getSize() + "):" + list + ", nodes:" + nodes);
         return tmpPath;
     }
+
     private QueryResult fromRes;
     private QueryResult toRes;
 
@@ -429,6 +433,7 @@ public void mouseClicked( MouseEvent e )
 
                             fromDone = !fromDone;
                         }
+
                         boolean dragging = false;
 
                         @Override
@@ -499,6 +504,7 @@ public void mousePressed( MouseEvent e )
             throw new RuntimeException(ex);
         }
     }
+
     // for moving
     int currentPosX;
     int currentPosY;
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index fa5d018259..0fb4b7ccd2 100644
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryTortureTest
diff --git a/web/pom.xml b/web/pom.xml
index 8600391382..9c8651a013 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -35,14 +35,14 @@
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
         
         <!-- necessary to use guice ('@Inject') in servlets -->
         <dependency>
             <groupId>com.google.inject.extensions</groupId>
             <artifactId>guice-servlet</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
                 
         <dependency>
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index c29d7c55f9..983887d767 100644
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -23,6 +23,7 @@
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.servlets.UserAgentFilter;
 
 /**
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index 7829d78286..61e8f52dc0 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -77,6 +77,8 @@ protected void configure()
                 logger.info("jsonp disabled");
 
             bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
+
+            bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraph().getBounds()));
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 07fe5d9f38..20597cafad 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -17,24 +17,30 @@
  */
 package com.graphhopper.http;
 
-import java.io.IOException;
-import javax.inject.Named;
-import javax.inject.Inject;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import org.json.JSONException;
 import org.json.JSONObject;
-import static javax.servlet.http.HttpServletResponse.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_OK;
+
 /**
  * @author Peter Karich
  */
 public class GHBaseServlet extends HttpServlet
 {
-    protected Logger logger = LoggerFactory.getLogger(getClass());
+    protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonpAllowed")
     private boolean jsonpAllowed;
@@ -49,54 +55,67 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             res.setContentType("application/javascript");
             if (!jsonpAllowed)
             {
-                res.sendError(SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+                writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
             if (callbackName == null)
             {
-                res.sendError(SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
+                writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
 
             if (debug)
-            {
                 writeResponse(res, callbackName + "(" + json.toString(2) + ")");
-            } else
-            {
+            else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
-            }
+
         } else
         {
             res.setContentType("application/json");
             if (debug)
-            {
                 writeResponse(res, json.toString(2));
-            } else
-            {
+            else
                 writeResponse(res, json.toString());
-            }
         }
     }
 
-    void returnError( HttpServletResponse res, String errorMessage ) throws IOException
+    protected void writeError( HttpServletResponse res, int code, String message )
     {
-        res.sendError(SC_BAD_REQUEST, errorMessage);
+        JSONObject json = new JSONObject();
+        json.put("message", message);
+        writeJsonError(res, code, json);
+    }
+
+    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
+    {
+        try
+        {
+            // no type parameter check here as jsonp does not work if an error
+            // also no debug parameter yet
+            res.setContentType("application/json");
+            res.setCharacterEncoding("UTF-8");
+            res.setStatus(code);
+            res.getWriter().append(json.toString(2));
+        } catch (IOException ex)
+        {
+            logger.error("Cannot write error " + ex.getMessage());
+        }
     }
 
-    protected String getParam( HttpServletRequest req, String string, String _default )
+    protected String getParam( HttpServletRequest req, String key, String _default )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
             return l[0];
 
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String string )
+    protected String[] getParams( HttpServletRequest req, String key )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
         {
             return l;
@@ -104,47 +123,51 @@ protected String getParam( HttpServletRequest req, String string, String _defaul
         return new String[0];
     }
 
-    protected long getLongParam( HttpServletRequest req, String string, long _default )
+    protected List<Double> getDoubleParamList( HttpServletRequest req, String key )
     {
-        try
-        {
-            return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex)
+        String[] l = req.getParameterMap().get(key);
+        if (l != null && l.length > 0)
         {
-            return _default;
+            ArrayList<Double> doubleList = new ArrayList<Double>(l.length);
+            for (String s : l)
+            {
+                doubleList.add(Double.valueOf(s));
+            }
+            return doubleList;
         }
+        return Collections.emptyList();
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
+    protected long getLongParam( HttpServletRequest req, String key, long _default )
     {
         try
         {
-            return Boolean.parseBoolean(getParam(req, string, "" + _default));
+            return Long.parseLong(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String string, double _default )
+    protected boolean getBooleanParam( HttpServletRequest req, String key, boolean _default )
     {
         try
         {
-            return Double.parseDouble(getParam(req, string, "" + _default));
+            return Boolean.parseBoolean(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    public void writeError( HttpServletResponse res, int code, String str )
+    protected double getDoubleParam( HttpServletRequest req, String key, double _default )
     {
         try
         {
-            res.sendError(code, str);
-        } catch (IOException ex)
+            return Double.parseDouble(getParam(req, key, "" + _default));
+        } catch (Exception ex)
         {
-            logger.error("Cannot write error " + code + " message:" + str, ex);
+            return _default;
         }
     }
 
diff --git a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
new file mode 100644
index 0000000000..4af5465de5
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import java.io.IOException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.ErrorHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * @author Peter Karich
+ */
+public class GHErrorHandler extends ErrorHandler
+{
+    private static final long serialVersionUID = 1L;
+    private final Logger logger = LoggerFactory.getLogger(GHErrorHandler.class);
+
+    @Override
+    public void handle( String str, Request req, HttpServletRequest httpReq, HttpServletResponse httpRes ) throws IOException
+    {
+        Throwable throwable = (Throwable) httpReq.getAttribute("javax.servlet.error.exception");
+        if (throwable != null)
+        {
+            String message = throwable.getMessage();
+            logger.error(message + ", via:" + httpReq.getRequestURL(), throwable);
+        } else
+        {
+            String message = (String) httpReq.getAttribute("javax.servlet.error.message");
+            if (message != null)
+            {
+                logger.error("Internal error " + message + "! Via:" + httpReq.getRequestURL());
+            } else
+            {
+                logger.error("Internal error " + str + ", throwable not known! Via:" + httpReq.getRequestURL());
+            }
+        }
+
+        // you can't call sendError( 500, "Server Error" ) without triggering Jetty's DefaultErrorHandler
+        httpRes.setStatus(SC_INTERNAL_SERVER_ERROR);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
index 828684f0d1..2f8e9250da 100644
--- a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
+++ b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
@@ -22,6 +22,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
+
 import org.eclipse.jetty.servlets.GzipFilter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 4a749c50ad..c3ceda83aa 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -23,12 +23,14 @@
 import com.google.inject.Module;
 import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
-import java.net.InetSocketAddress;
+
+
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.servlet.ServletHolder;
 
 import java.util.EnumSet;
 import javax.servlet.DispatcherType;
+
 import org.eclipse.jetty.server.Handler;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
@@ -76,6 +78,7 @@ public void start( Injector injector ) throws Exception
         server = new Server();
         // getSessionHandler and getSecurityHandler should always return null
         ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
+        servHandler.setErrorHandler(new GHErrorHandler());
         servHandler.setContextPath("/");
 
         servHandler.addServlet(new ServletHolder(new InvalidRequestServlet()), "/*");
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index cde8b94134..ce66e0ec7a 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -19,6 +19,7 @@
 
 import com.google.inject.servlet.ServletModule;
 import com.graphhopper.util.CmdArgs;
+
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Singleton;
@@ -64,7 +65,7 @@ protected void configureServlets()
 
         serve("/route*").with(GraphHopperServlet.class);
         bind(GraphHopperServlet.class).in(Singleton.class);
-        
+
         serve("/nearest*").with(NearestServlet.class);
         bind(NearestServlet.class).in(Singleton.class);
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 3c30178ff5..f8733bf554 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -18,64 +18,53 @@
 package com.graphhopper.http;
 
 import com.graphhopper.GHRequest;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.util.*;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-import java.util.Map.Entry;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.*;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
-import org.json.JSONObject;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.*;
+import java.util.Map.Entry;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 
 /**
- * Servlet to use GraphHopper in a remote application (mobile or browser). Attention: If type is
- * json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
- * used otherwise.
+ * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
+ * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
+ * used otherwise. See the full API response format in docs/web/api-doc.md
  * <p/>
+ *
  * @author Peter Karich
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
     @Inject
     private GraphHopper hopper;
+    @Inject
+    private RouteSerializer routeSerializer;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
-        try
-        {
-            writePath(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
-
-    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
     {
         List<GHPoint> infoPoints = getPoints(httpReq, "point");
+        GHResponse ghRsp = new GHResponse();
 
         // we can reduce the path length based on the maximum differences to the original coordinates
         double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
@@ -89,19 +78,49 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         String weighting = getParam(httpReq, "weighting", "fastest");
         String algoStr = getParam(httpReq, "algorithm", "");
         String localeStr = getParam(httpReq, "locale", "en");
+        List<Double> favoredHeadings = Collections.EMPTY_LIST;
+        try
+        {
+            favoredHeadings = getDoubleParamList(httpReq, "heading");
+
+        } catch (java.lang.NumberFormatException e)
+        {
+            throw new RuntimeException(e);
+        }
 
         StopWatch sw = new StopWatch().start();
-        GHResponse ghRsp;
         if (!hopper.getEncodingManager().supports(vehicleStr))
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+            ghRsp.addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
         } else if (enableElevation && !hopper.hasElevation())
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
-        } else
+            ghRsp.addError(new IllegalArgumentException("Elevation not supported!"));
+        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != infoPoints.size())
+        {
+            ghRsp.addError(new IllegalArgumentException("number of headings must be <= 1 or equal number of points"));
+        }
+        if (!ghRsp.hasErrors())
         {
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-            GHRequest request = new GHRequest(infoPoints);
+
+            GHRequest request;
+            if (favoredHeadings.size() > 0)
+            {
+                // if only one favored heading is specified take as start heading
+                if (favoredHeadings.size() == 1)
+                {
+                    List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(infoPoints.size(),
+                            Double.NaN));
+                    paddedHeadings.set(0, favoredHeadings.get(0));
+                    request = new GHRequest(infoPoints, paddedHeadings);
+                } else
+                {
+                    request = new GHRequest(infoPoints, favoredHeadings);
+                }
+            } else
+            {
+                request = new GHRequest(infoPoints);
+            }
 
             initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
@@ -120,6 +139,7 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
         String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
                 + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+        httpRes.setHeader("X-GH-Took", "" + Math.round(took * 1000));
 
         if (ghRsp.hasErrors())
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
@@ -130,21 +150,33 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
 
         if (writeGPX)
         {
-            writeResponse(res, createGPXString(httpReq, res, ghRsp));
+            String xml = createGPXString(httpReq, httpRes, ghRsp);
+            if (ghRsp.hasErrors())
+            {
+                httpRes.setStatus(SC_BAD_REQUEST);
+                httpRes.getWriter().append(xml);
+            } else
+            {
+                writeResponse(httpRes, xml);
+            }
         } else
         {
-            Map<String, Object> map = createJson(ghRsp,
-                    calcPoints, pointsEncoded, enableElevation, enableInstructions);
+            Map<String, Object> map = routeSerializer.toJSON(ghRsp, calcPoints, pointsEncoded,
+                    enableElevation, enableInstructions);
+
+            // deprecated - remove in 0.5
             Object infoMap = map.get("info");
             if (infoMap != null)
                 ((Map) infoMap).put("took", Math.round(took * 1000));
 
-            writeJson(httpReq, res, new JSONObject(map));
+            if (ghRsp.hasErrors())
+                writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+            else
+                writeJson(httpReq, httpRes, new JSONObject(map));
         }
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
-            throws Exception
     {
         boolean includeElevation = getBooleanParam(req, "elevation", false);
         res.setCharacterEncoding("UTF-8");
@@ -158,99 +190,47 @@ protected String createGPXString( HttpServletRequest req, HttpServletResponse re
             return rsp.getInstructions().createGPX(trackName, time, includeElevation);
     }
 
-    String errorsToXML( List<Throwable> list ) throws Exception
+    String errorsToXML( List<Throwable> list )
     {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        DocumentBuilder builder = factory.newDocumentBuilder();
-        Document doc = builder.newDocument();
-        Element gpxElement = doc.createElement("gpx");
-        gpxElement.setAttribute("creator", "GraphHopper");
-        gpxElement.setAttribute("version", "1.1");
-        doc.appendChild(gpxElement);
+        try
+        {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
 
-        Element mdElement = doc.createElement("metadata");
-        gpxElement.appendChild(mdElement);
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
 
-        Element errorsElement = doc.createElement("extensions");
-        mdElement.appendChild(errorsElement);
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
 
-        for (Throwable t : list)
-        {
-            Element error = doc.createElement("error");
-            errorsElement.appendChild(error);
-            error.setAttribute("message", t.getMessage());
-            error.setAttribute("details", t.getClass().getName());
-        }
-        TransformerFactory transformerFactory = TransformerFactory.newInstance();
-        Transformer transformer = transformerFactory.newTransformer();
-        StringWriter writer = new StringWriter();
-        transformer.transform(new DOMSource(doc), new StreamResult(writer));
-        return writer.toString();
-    }
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(list.get(0).getMessage());
 
-    protected Map<String, Object> createJson( GHResponse rsp,
-            boolean calcPoints,
-            boolean pointsEncoded,
-            boolean includeElevation,
-            boolean enableInstructions )
-    {
-        Map<String, Object> json = new HashMap<String, Object>();
-        Map<String, Object> jsonInfo = new HashMap<String, Object>();
-        json.put("info", jsonInfo);
-        jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
 
-        if (rsp.hasErrors())
-        {
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
+            for (Throwable t : list)
             {
-                Map<String, String> map = new HashMap<String, String>();
-                map.put("message", t.getMessage());
-                map.put("details", t.getClass().getName());
-                list.add(map);
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                error.setAttribute("details", t.getClass().getName());
             }
-            jsonInfo.put("errors", list);
-        } else
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            StringWriter writer = new StringWriter();
+            transformer.transform(new DOMSource(doc), new StreamResult(writer));
+            return writer.toString();
+        } catch (Exception ex)
         {
-            Map<String, Object> jsonPath = new HashMap<String, Object>();
-            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getTime());
-
-            if (calcPoints)
-            {
-                jsonPath.put("points_encoded", pointsEncoded);
-
-                PointList points = rsp.getPoints();
-                if (points.getSize() >= 2)
-                {
-                    BBox maxBounds = hopper.getGraph().getBounds();
-                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
-                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
-                }
-
-                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-                if (enableInstructions)
-                {
-                    InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson());
-                }
-            }
-            json.put("paths", Collections.singletonList(jsonPath));
+            throw new RuntimeException(ex);
         }
-        return json;
-    }
-
-    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
-        if (pointsEncoded)
-            return WebHelper.encodePolyline(points, includeElevation);
-
-        Map<String, Object> jsonPoints = new HashMap<String, Object>();
-        jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-        return jsonPoints;
     }
 
     protected List<GHPoint> getPoints( HttpServletRequest req, String key )
@@ -264,9 +244,7 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
             {
                 GHPoint point = GHPoint.parse(str);
                 if (point != null)
-                {
                     infoPoints.add(point);
-                }
             }
         }
 
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 5d0e60d8e0..f75bdfee4a 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,7 +22,9 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -89,8 +91,7 @@ public GraphHopperWeb setElevation( boolean withElevation )
     @Override
     public GHResponse route( GHRequest request )
     {
-        StopWatch sw = new StopWatch().start();
-        double took = 0;
+        StopWatch sw = new StopWatch().start();        
         try
         {
             String places = "";
@@ -126,41 +127,29 @@ public GHResponse route( GHRequest request )
             if (!tmpKey.isEmpty())
                 url += "&key=" + tmpKey;
 
-            String str = downloader.downloadAsString(url);
+            String str = downloader.downloadAsString(url, true);
             JSONObject json = new JSONObject(str);
 
-            if (json.has("message"))
-                throw new RuntimeException(json.getString("message") + ", code:" + json.getInt("code"));
-
             GHResponse res = new GHResponse();
-
-            if (json.getJSONObject("info").has("errors"))
-            {
-                JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
-                readErrors(res.getErrors(), errors);
+            readErrors(res.getErrors(), json);
+            if (res.hasErrors())
                 return res;
+            
+            JSONArray paths = json.getJSONArray("paths");
+            JSONObject firstPath = paths.getJSONObject(0);
+            readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
+            return res;
 
-            } else
-            {
-                took = json.getJSONObject("info").getDouble("took");
-                JSONArray paths = json.getJSONArray("paths");
-                JSONObject firstPath = paths.getJSONObject(0);
-                readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
-                return res;
-            }
         } catch (Exception ex)
         {
             throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
-        } finally
-        {
-            logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
         }
     }
 
     public static void readPath( GHResponse res, JSONObject firstPath,
-            boolean tmpCalcPoints,
-            boolean tmpInstructions,
-            boolean tmpElevation )
+                                 boolean tmpCalcPoints,
+                                 boolean tmpInstructions,
+                                 boolean tmpElevation )
     {
         double distance = firstPath.getDouble("distance");
         long time = firstPath.getLong("time");
@@ -229,37 +218,57 @@ public static void readPath( GHResponse res, JSONObject firstPath,
         res.setDistance(distance).setTime(time);
     }
 
-    public static void readErrors( List<Throwable> errors, JSONArray errorJson )
+    public static void readErrors( List<Throwable> errors, JSONObject json )
     {
+        JSONArray errorJson;
+
+        if (json.has("message"))
+        {
+            if (json.has("hints"))
+            {
+                errorJson = json.getJSONArray("hints");
+            } else
+            {
+                // should not happen
+                errors.add(new RuntimeException(json.getString("message")));
+                return;
+            }
+        } else if (json.has("info"))
+        {
+            // deprecated JSON format for errors, remove in 0.5 release
+            JSONObject jsonInfo = json.getJSONObject("info");
+            if (jsonInfo.has("errors"))
+                errorJson = jsonInfo.getJSONArray("errors");
+            else
+                return;
+
+        } else
+            return;
+
         for (int i = 0; i < errorJson.length(); i++)
         {
             JSONObject error = errorJson.getJSONObject(i);
             String exClass = "";
             if (error.has("details"))
-            {
                 exClass = error.getString("details");
-            }
+
             String exMessage = error.getString("message");
 
             if (exClass.equals(UnsupportedOperationException.class.getName()))
-            {
                 errors.add(new UnsupportedOperationException(exMessage));
-            } else if (exClass.equals(IllegalStateException.class.getName()))
-            {
+            else if (exClass.equals(IllegalStateException.class.getName()))
                 errors.add(new IllegalStateException(exMessage));
-            } else if (exClass.equals(RuntimeException.class.getName()))
-            {
+            else if (exClass.equals(RuntimeException.class.getName()))
                 errors.add(new RuntimeException(exMessage));
-            } else if (exClass.equals(IllegalArgumentException.class.getName()))
-            {
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
                 errors.add(new IllegalArgumentException(exMessage));
-            } else if (exClass.isEmpty())
-            {
-                errors.add(new Exception(exMessage));
-            } else
-            {
-                errors.add(new Exception(exClass + " " + exMessage));
-            }
+            else if (exClass.isEmpty())
+                errors.add(new RuntimeException(exMessage));
+            else
+                errors.add(new RuntimeException(exClass + " " + exMessage));
         }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.getString("message")));
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 833246508a..8b92431524 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -20,13 +20,16 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.Translation;
+
 import java.io.IOException;
 import java.util.Locale;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import static javax.servlet.http.HttpServletResponse.*;
+
 import org.json.JSONObject;
 
 /**
@@ -40,33 +43,26 @@
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        try
-        {
-            String locale = "";
-            String path = req.getPathInfo();
-            if (!Helper.isEmpty(path) && path.startsWith("/"))
-                locale = path.substring(1);
+        String locale = "";
+        String path = req.getPathInfo();
+        if (!Helper.isEmpty(path) && path.startsWith("/"))
+            locale = path.substring(1);
 
-            if (Helper.isEmpty(locale))
-            {
-                // fall back to language specified in header e.g. via browser settings
-                String acceptLang = req.getHeader("Accept-Language");
-                if (!Helper.isEmpty(acceptLang))
-                    locale = acceptLang.split(",")[0];
-            }
-
-            Translation tr = map.get(locale);
-            JSONObject json = new JSONObject();
-            if (tr != null && !Locale.US.equals(tr.getLocale()))
-                json.put("default", tr.asMap());
-
-            json.put("locale", locale.toString());
-            json.put("en", map.get("en").asMap());
-            writeJson(req, res, json);
-        } catch (Exception ex)
+        if (Helper.isEmpty(locale))
         {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+            // fall back to language specified in header e.g. via browser settings
+            String acceptLang = req.getHeader("Accept-Language");
+            if (!Helper.isEmpty(acceptLang))
+                locale = acceptLang.split(",")[0];
         }
+
+        Translation tr = map.get(locale);
+        JSONObject json = new JSONObject();
+        if (tr != null && !Locale.US.equals(tr.getLocale()))
+            json.put("default", tr.asMap());
+
+        json.put("locale", locale.toString());
+        json.put("en", map.get("en").asMap());
+        writeJson(req, res, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
index 9b40dd4c02..b6076883a4 100644
--- a/web/src/main/java/com/graphhopper/http/IPFilter.java
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -5,16 +5,17 @@
 import java.util.Set;
 import javax.servlet.*;
 import javax.servlet.http.HttpServletResponse;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
- * <p>
+ * <p/>
  * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
- * <p>
+ * <p/>
  * The internal ip filter from jetty did not work (NP exceptions)
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class IPFilter implements Filter
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 824d5c3ee1..626ba5f6d8 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -22,6 +22,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -29,8 +30,10 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+
 import org.json.JSONObject;
 
 /**
@@ -43,21 +46,6 @@
 
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
-        try
-        {
-            writeInfos(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
-
-    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
     {
         BBox bb = hopper.getGraph().getBounds();
         List<Double> list = new ArrayList<Double>(4);
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index b320b38854..8de227530b 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -15,22 +15,20 @@
  */
 package com.graphhopper.http;
 
+import org.json.JSONObject;
+
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import org.json.JSONObject;
 
 public class InvalidRequestServlet extends GHBaseServlet
 {
     @Override
     protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        res.setStatus(HttpServletResponse.SC_NOT_FOUND);
-        res.setContentType("text/plain");
-        res.setContentType("UTF-8");
         JSONObject json = new JSONObject();
-        json.put("error_code", "404");
-        writeJson(req, res, json);
+        json.put("message", "Not found");
+        writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
index 0fcb4eaa3a..5696fce229 100644
--- a/web/src/main/java/com/graphhopper/http/NearestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -21,18 +21,18 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-import java.io.IOException;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
-import org.json.JSONArray;
-import org.json.JSONObject;
+import java.io.IOException;
 
 /**
  * @author svantulden
@@ -41,65 +41,46 @@
 {
     @Inject
     private GraphHopper hopper;
+    private final DistanceCalc calc = Helper.DIST_EARTH;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
     {
-        try
-        {
-            writeNearest(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
+        String pointStr = getParam(httpReq, "point", null);
+        boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
 
-    void writeNearest( HttpServletRequest req, HttpServletResponse res ) throws Exception
-    {
-        String pointStr = getParam(req, "point", null);
-        boolean enableElevation = getBooleanParam(req, "elevation", false);
-        
         JSONObject result = new JSONObject();
-        if (pointStr != null && !pointStr.equalsIgnoreCase("")) {
+        if (pointStr != null && !pointStr.equalsIgnoreCase(""))
+        {
             GHPoint place = GHPoint.parse(pointStr);
-            
             LocationIndex index = hopper.getLocationIndex();
-            QueryResult qr = index.findClosest( place.lat, place.lon, EdgeFilter.ALL_EDGES );
-            
-            GHPoint3D snappedPoint = null;
-            try {
-                snappedPoint = qr.getSnappedPoint();
-            } catch (IllegalStateException ex) {
+            QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
+
+            if (!qr.isValid())
+            {
                 result.put("error", "Nearest point cannot be found!");
-            }
-            
-            if (snappedPoint != null) {
+            } else
+            {
+                GHPoint3D snappedPoint = qr.getSnappedPoint();
                 result.put("type", "Point");
-                
+
                 JSONArray coord = new JSONArray();
                 coord.put(snappedPoint.lon);
                 coord.put(snappedPoint.lat);
-                
-                if (hopper.hasElevation() && enableElevation) {
+
+                if (hopper.hasElevation() && enabledElevation)
                     coord.put(snappedPoint.ele);
-                }
 
                 result.put("coordinates", coord);
-                
-                DistanceCalcEarth calc = new DistanceCalcEarth();
-                double distance = calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon);
-                
+
                 // Distance from input to snapped point in meters
-                result.put("distance", distance);
+                result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
             }
-        } else {
+        } else
+        {
             result.put("error", "No lat/lon specified!");
-        }  
-        
-        writeJson(req, res, result);
+        }
+
+        writeJson(httpReq, httpRes, result);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index f9cc20ae9a..1890d9628b 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -21,11 +21,13 @@
 import com.graphhopper.search.ReverseGeocoding;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -45,6 +47,7 @@ public static void main( String[] args )
         System.out.println("reverse " + new NominatimGeocoder().places2names(new GHPlace(49.9027606, 11.577197),
                 new GHPlace(52.5198535, 13.4385964)));
     }
+
     private String nominatimUrl;
     private String nominatimReverseUrl;
     private BBox bounds;
@@ -157,7 +160,8 @@ public NominatimGeocoder setBounds( BBox bounds )
 
     HttpURLConnection openConnection( String url ) throws IOException
     {
-        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();;
+        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();
+        ;
         hConn.setRequestProperty("User-Agent", userAgent);
         hConn.setRequestProperty("content-charset", "UTF-8");
         hConn.setConnectTimeout(timeoutInMillis);
diff --git a/web/src/main/java/com/graphhopper/http/RouteSerializer.java b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
new file mode 100644
index 0000000000..31af004887
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
@@ -0,0 +1,43 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.PointList;
+import java.util.Map;
+
+/**
+ * This interface speficies how the route should be transformed into JSON.
+ * <p>
+ * @author Peter Karich
+ */
+public interface RouteSerializer
+{
+    /**
+     * This method transforms the specified response into a JSON.
+     */
+    Map<String, Object> toJSON( GHResponse response,
+                                boolean calcPoints, boolean pointsEncoded,
+                                boolean includeElevation, boolean enableInstructions );
+
+    /**
+     * This method returns either a Map containing the GeoJSON of the specified points OR the string
+     * encoded polyline of it.
+     */
+    Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation );
+}
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
new file mode 100644
index 0000000000..06cbe5cfe1
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -0,0 +1,92 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+import java.util.*;
+
+/**
+ *
+ * @author peterk
+ */
+public class SimpleRouteSerializer implements RouteSerializer
+{
+    private final BBox maxBounds;
+
+    public SimpleRouteSerializer( BBox maxBounds )
+    {
+        this.maxBounds = maxBounds;
+    }
+
+    @Override
+    public Map<String, Object> toJSON( GHResponse rsp,
+                                          boolean calcPoints, boolean pointsEncoded,
+                                          boolean includeElevation, boolean enableInstructions )
+    {
+        Map<String, Object> json = new HashMap<String, Object>();
+
+        if (rsp.hasErrors())
+        {
+            json.put("message", rsp.getErrors().get(0).getMessage());
+            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
+            for (Throwable t : rsp.getErrors())
+            {
+                Map<String, String> map = new HashMap<String, String>();
+                map.put("message", t.getMessage());
+                map.put("details", t.getClass().getName());
+                list.add(map);
+            }
+            json.put("hints", list);
+        } else
+        {
+            Map<String, Object> jsonInfo = new HashMap<String, Object>();
+            json.put("info", jsonInfo);
+            jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+            jsonPath.put("time", rsp.getTime());
+
+            if (calcPoints)
+            {
+                jsonPath.put("points_encoded", pointsEncoded);
+
+                PointList points = rsp.getPoints();
+                if (points.getSize() >= 2)
+                {
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
+
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+                if (enableInstructions)
+                {
+                    InstructionList instructions = rsp.getInstructions();
+                    jsonPath.put("instructions", instructions.createJson());
+                }
+            }
+            json.put("paths", Collections.singletonList(jsonPath));
+        }
+        return json;
+    }
+
+    @Override
+    public Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+    {
+        if (pointsEncoded)
+            return WebHelper.encodePolyline(points, includeElevation);
+
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
+        jsonPoints.put("type", "LineString");
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+        return jsonPoints;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 02e515b8e9..8a5aaeba92 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -18,6 +18,7 @@
 package com.graphhopper.http;
 
 import com.graphhopper.util.PointList;
+
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -26,11 +27,11 @@
 
 /**
  * Code which handles polyline encoding and other web stuff.
- * <p>
+ * <p/>
  * The necessary information for polyline encoding is in this answer:
  * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
  * good explanation.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class WebHelper
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 982e30473a..5dec96119a 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -312,16 +312,16 @@ GHRequest.prototype.init = function (params) {
             val = false;
         else if (val === "true")
             val = true;
-        else {
-            if (parseFloat(val) != NaN)
-                val = parseFloat(val)
-        }
 
         // todo
         // this[key] = val;
 
         if (key.indexOf('api.') === 0) {
-            this.api_params[key.substring(4)] = val;
+            key = key.substring(4);
+            if (GHroute.isArray(val))
+                this.api_params[key] = val;
+            else
+                this.api_params[key] = [val];
         }
     }
 
@@ -459,7 +459,12 @@ GHRequest.prototype.createPath = function (url) {
         url += "&debug=true";
 
     for (var key in this.api_params) {
-        url += "&" + key + "=" + this.api_params[key];
+        // entries in api_params are all arrays
+        var arr = this.api_params[key];
+        if (GHroute.isArray(arr))
+            for (var keyIndex in arr) {
+                url += "&" + key + "=" + arr[keyIndex];
+            }
     }
     return url;
 };
@@ -541,22 +546,20 @@ GHRequest.prototype.doRequest = function (url, callback) {
             // problematic: this callback is not invoked when using JSONP!
             // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
+            var json;
+
             if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
-                var jsonError = JSON.parse(err.responseText);
-                msg += jsonError.message;
-            } else if (err && err.statusText && err.statusText !== "OK")
+                json = JSON.parse(err.responseText);
+            } else if (err && err.statusText && err.statusText !== "OK") {
                 msg += err.statusText;
-
+                var details = "Error for " + url;
+                json = {
+                    message: msg,
+                    hints: [{"message": msg, "details": details}]
+                };
+            }
             log(msg + " " + JSON.stringify(err));
-            var details = "Error for " + url;
-            var json = {
-                "info": {
-                    "errors": [{
-                            "message": msg,
-                            "details": details
-                        }]
-                }
-            };
+
             callback(json);
         },
         type: "GET",
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index f483ad51d3..8c6086c96a 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -318,12 +318,12 @@ function initMap(selectLayer) {
         attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
         subdomains: ['a', 'b', 'c']
     });
-        
+
     var omniscale = L.tileLayer.wms('https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile', {
-            layers: 'osm',
+        layers: 'osm',
         attribution: osmAttr + ', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'
     });
-            
+
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
@@ -385,7 +385,7 @@ function initMap(selectLayer) {
 
     var baseMaps = {
         "Lyrk": lyrk,
-        "Omniscale" : omniscale,
+        "Omniscale": omniscale,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
         "Esri Aerial": esriAerial,
@@ -977,11 +977,15 @@ function routeLatLng(request, doQuery) {
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
     request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
-        if (json.info.errors) {
-            var tmpErrors = json.info.errors;
+        if (json.message) {
+            var tmpErrors = json.message;
             log(tmpErrors);
-            for (var m = 0; m < tmpErrors.length; m++) {
-                descriptionDiv.append("<div class='error'>" + tmpErrors[m].message + "</div>");
+            if (json.hints) {
+                for (var m = 0; m < json.hints.length; m++) {
+                    descriptionDiv.append("<div class='error'>" + json.hints[m].message + "</div>");
+                }
+            } else {
+                descriptionDiv.append("<div class='error'>" + tmpErrors + "</div>");
             }
             return;
         }
@@ -1076,8 +1080,7 @@ function routeLatLng(request, doQuery) {
                 hiddenDiv.toggle();
             });
             $("#info").append(toggly);
-            var infoStr = "took: " + round(json.info.took / 1000, 1000) + "s"
-                    + ", points: " + path.points.coordinates.length;
+            var infoStr = "points: " + path.points.coordinates.length;
 
             hiddenDiv.append("<span>" + infoStr + "</span>");
 
@@ -1248,25 +1251,24 @@ function parseUrl(query) {
         if (value === "")
             continue;
 
-        if (key === "point" && !res[key]) {
-            res[key] = [value];
-        } else if (typeof res[key] === "string") {
-            var arr = [res[key], value];
-            res[key] = arr;
-        } else if (typeof res[key] === "undefined") {
-            if (value === 'true') {
-                res[key] = true;
-            } else if (value === 'false') {
-                res[key] = false;
+        // force array for heading and point
+        if (typeof res[key] === "undefined"
+                && key !== "heading" && key !== "point") {
+            if (value === 'true')
+                value = true;
+            else if (value === 'false')
+                value = false;
+
+            res[key] = value;
+        } else {
+            var tmpVal = res[key];
+            if (GHroute.isArray(tmpVal)) {
+                tmpVal.push(value);
+            } else if (tmpVal) {
+                res[key] = [tmpVal, value];
             } else {
-                var tmp = Number(value);
-                if (isNaN(tmp))
-                    res[key] = value;
-                else
-                    res[key] = Number(value);
+                res[key] = [value];
             }
-        } else {
-            res[key].push(value);
         }
     }
     return res;
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index 2669c2e3e9..924d19d696 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -22,10 +22,15 @@
 import com.google.inject.Module;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.HttpURLConnection;
+
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
@@ -100,14 +105,14 @@ protected String getTestRouteAPIUrl()
         String host = "localhost";
         return "http://" + host + ":" + port + "/route";
     }
-    
+
     protected String getTestNearestAPIUrl()
     {
         String host = "localhost";
         return "http://" + host + ":" + port + "/nearest";
     }
-    
-    protected JSONObject query( String query ) throws Exception
+
+    protected String queryString( String query, int code ) throws Exception
     {
         String resQuery = "";
         for (String q : query.split("\\&"))
@@ -121,10 +126,18 @@ protected JSONObject query( String query ) throws Exception
             resQuery += "&";
         }
         String url = getTestRouteAPIUrl() + "?" + resQuery;
-        Downloader downloader = new Downloader("web integration tester");
-        return new JSONObject(downloader.downloadAsString(url));
-    } 
-    
+        Downloader downloader = new Downloader("web integration tester").setTimeout(1000);
+        HttpURLConnection conn = downloader.createConnection(url);
+        conn.connect();
+        assertEquals(code, conn.getResponseCode());
+        return Helper.isToString(downloader.fetch(conn, true));
+    }
+
+    protected JSONObject query( String query, int code ) throws Exception
+    {
+        return new JSONObject(queryString(query, code));
+    }
+
     protected JSONObject nearestQuery( String query ) throws Exception
     {
         String resQuery = "";
@@ -140,6 +153,6 @@ protected JSONObject nearestQuery( String query ) throws Exception
         }
         String url = getTestNearestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
-        return new JSONObject(downloader.downloadAsString(url));
-    } 
+        return new JSONObject(downloader.downloadAsString(url, true));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 140ef8bc42..fef0887478 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -23,13 +23,15 @@
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.File;
-import java.util.List;
-import java.util.Map;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
 import static org.junit.Assert.*;
 
 /**
@@ -59,7 +61,7 @@ public void setUp()
     @Test
     public void testBasicQuery() throws Exception
     {
-        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128");
+        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -68,10 +70,38 @@ public void testBasicQuery() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testQuerywithDirections() throws Exception
+    {
+        // Note, in general specifying directions does not work with CH, but this is an example where it works
+        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 960);
+        assertTrue("distance wasn't correct:" + distance, distance < 970);
+    }
+
+    @Test
+    public void testQuerywithStraightVia() throws Exception
+    {
+        // Note, in general specifying straightvia does not work with CH, but this is an example where it works
+        JSONObject json = query(
+                "point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 320);
+        assertTrue("distance wasn't correct:" + distance, distance < 325);
+    }
+
+
     @Test
     public void testJsonRounding() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
         assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
@@ -79,10 +109,10 @@ public void testJsonRounding() throws Exception
     @Test
     public void testFailIfElevationRequestedButNotIncluded() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true");
-        JSONObject infoJson = json.getJSONObject("info");
-        assertTrue(infoJson.has("errors"));
-        assertEquals("Elevation not supported!", infoJson.getJSONArray("errors").getJSONObject(0).getString("message"));
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
+        assertTrue(json.has("message"));
+        assertEquals("Elevation not supported!", json.get("message"));
+        assertEquals("Elevation not supported!", json.getJSONArray("hints").getJSONObject(0).getString("message"));
     }
 
     @Test
@@ -112,17 +142,14 @@ public void testGraphHopperWeb() throws Exception
     @Test
     public void testGraphHopperWebRealExceptions()
     {
-        GHResponse rsp;
-        Throwable ex;
-
         GraphHopperAPI hopper = new GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
 
         // IllegalStateException (Wrong Request)
-        rsp = hopper.route(new GHRequest());
+        GHResponse rsp = hopper.route(new GHRequest());
         assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
 
-        ex = rsp.getErrors().get(0);
+        Throwable ex = rsp.getErrors().get(0);
         assertTrue("Wrong Exception found: " + ex.getClass().getName()
                 + ", IllegalStateException expected.", ex instanceof IllegalStateException);
 
@@ -146,4 +173,22 @@ public void testGraphHopperWebRealExceptions()
         // RuntimeException
         // Exception
     }
+
+    @Test
+    public void testGPX() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx", 200);
+        assertTrue(str.contains("<gh:distance>115.1</gh:distance>"));
+        assertTrue(str.contains("<trkpt lat=\"42.554839\" lon=\"1.536374\"><time>"));
+    }
+
+    @Test
+    public void testGPXWithError() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&type=gpx", 400);
+        assertFalse(str, str.contains("<html>"));
+        assertFalse(str, str.contains("{"));
+        assertTrue("Expected error but was: " + str, str.contains("<message>At least 2 points has to be specified, but was:1</message>"));
+        assertTrue("Expected error but was: " + str, str.contains("<hints><error details=\"java"));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index 7e5aa6af65..248b1cdee9 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -19,11 +19,14 @@
 
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -56,7 +59,7 @@ public void setUp()
     @Test
     public void testElevation() throws Exception
     {
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -76,7 +79,7 @@ public void testElevation() throws Exception
     public void testNoElevation() throws Exception
     {
         // default is elevation=false
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -87,7 +90,7 @@ public void testNoElevation() throws Exception
         assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
 
         // disable elevation
-        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
+        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false", 200);
         infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         path = json.getJSONArray("paths").getJSONObject(0);
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index c7c6de2be3..7a804e5ca0 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -20,13 +20,16 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.util.Downloader;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.HttpURLConnection;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperWebTest
@@ -39,7 +42,7 @@ public void testReadEncoded() throws Exception
         Downloader downloader = new Downloader("GraphHopper Test")
         {
             @Override
-            public InputStream fetch( String url ) throws IOException
+            public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
             {
                 return getClass().getResourceAsStream("test_encoded.json");
             }
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
index dc2470b6f2..2b6b24ca23 100644
--- a/web/src/test/java/com/graphhopper/http/IPFilterTest.java
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -1,10 +1,10 @@
 package com.graphhopper.http;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class IPFilterTest
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
index 74956eb9f6..3cb2a78760 100644
--- a/web/src/test/java/com/graphhopper/http/NearestServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -18,14 +18,18 @@
 package com.graphhopper.http;
 
 import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
index d271db8457..cb8f5c2692 100644
--- a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -18,14 +18,18 @@
 package com.graphhopper.http;
 
 import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -67,7 +71,7 @@ public void testWithEleQuery() throws Exception
         double ele = point.getDouble(2);
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon + ", ele=" + ele, lat == 43.73070006215647 && lon == 7.421392181993846 && ele == 66.0);
     }
-    
+
     @Test
     public void testWithoutEleQuery() throws Exception
     {
@@ -78,7 +82,7 @@ public void testWithoutEleQuery() throws Exception
         double lon = point.getDouble(0);
         double lat = point.getDouble(1);
         assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
-        
+
         // Default elevation is false        
         json = nearestQuery("point=43.730864,7.420771");
         assertFalse(json.has("error"));
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
index 4276ca4ed5..1f75fbbb52 100644
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class WebHelperTest
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index 5babc0a48f..ac1dcc44f0 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -1,8 +1,8 @@
 /*
  * This software stands under the Apache 2 License
  */
-describe("utils", function() {
-    it("should format time string correctly", function() {
+describe("utils", function () {
+    it("should format time string correctly", function () {
         defaultTranslationMap = {};
         defaultTranslationMap["minabbr"] = 'min';
         defaultTranslationMap["hourabbr"] = 'h';
@@ -16,7 +16,7 @@ describe("utils", function() {
         expect(createTimeString(12000)).toBe("0min");
     });
 
-    it("should format translation string correctly", function() {
+    it("should format translation string correctly", function () {
         // toBe, toBeTruthy, toBeFalsy
         defaultTranslationMap = {};
         defaultTranslationMap["web.somekey1"] = "%s wow %s";
@@ -32,7 +32,7 @@ describe("utils", function() {
         expect(tr("key", [200, "km", "2min"])).toBe("200km werden 2min brauchen");
     });
 
-    it("should format location entry correctly", function() {
+    it("should format location entry correctly", function () {
         var res = formatLocationEntry({
             "state": "Berlin",
             "country": "Deutschland",
@@ -53,7 +53,7 @@ describe("utils", function() {
         expect(res).toEqual({postcode: undefined, city: "Rixdorf, NeukÃ¶lln", country: "Deutschland", more: "Berlin, EuropÃ¤ischen Union"});
     });
 
-    it("should decode the polyline", function() {
+    it("should decode the polyline", function () {
         var list = decodePath("_p~iF~ps|U", false);
         expect(list).toEqual([[-120.2, 38.5]]);
 
@@ -61,7 +61,7 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5], [-120.95, 40.7], [-126.45300000000002, 43.252]]);
     });
 
-    it("should decode the 3D polyline", function() {
+    it("should decode the 3D polyline", function () {
         var list = decodePath("_p~iF~ps|Uo}@", true);
         expect(list).toEqual([[-120.2, 38.5, 10]]);
 
@@ -69,52 +69,54 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5, 10], [-120.95, 40.7, 1234], [-126.45300000000002, 43.252, 1234]]);
     });
 
-    it("should parse URL correctly", function() {
-        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1");
+    it("should parse URL correctly", function () {
+        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1&test5=2.7");
         expect("pest").toEqual(params.test);
         expect(true).toEqual(params.test2);
         expect(false).toEqual(params.test3);
-        expect(2).toEqual(params.test4);
-        expect(1.1).toEqual(params.test5);
-        
-        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");        
-        expect(params.point).toEqual("49.946505,11.571232");        
-        
+        expect("2").toEqual(params.test4);
+        expect(["1.1", "2.7"]).toEqual(params.test5);
+
+        // force array for point
+        // URLs with one point only should work: https://graphhopper.com/maps/?point=50.413331%2C11.699066
+        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
+
         params = parseUrl("blup?point=&point=49.946505%2C11.571232");
-        expect(params.point).toEqual("49.946505,11.571232");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
     });
 
-    it("features should work", function() {
+    it("features should work", function () {
         var ghRequest = new GHRequest("http://test.de?vehicle=car");
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{}};
+        ghRequest.features = {"car": {}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
-        ghRequest.features = {"car":{ elevation: true}};
+
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
         params.elevation = false;
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
+
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{ elevation: false}};
+        ghRequest.features = {"car": {elevation: false}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
     });
-    
-    it("ghrequest should init correctly from params", function() {
+
+    it("ghrequest should init correctly from params", function () {
         var ghRequest = new GHRequest("http://test.de");
         var params = {};
         params.do_zoom = true;
@@ -126,7 +128,7 @@ describe("utils", function() {
         expect(ghRequest.do_zoom).toEqual(params.do_zoom);
     });
 
-    it("input should accept 0 and no addresses", function() {
+    it("input should accept 0 and no addresses", function () {
         var input = new GHInput("12,0");
         expect(input.toString()).toEqual("12,0");
         var input = new GHInput("bluo,0");
@@ -138,19 +140,19 @@ describe("utils", function() {
         var input = new GHInput("");
         expect(input.toString()).toEqual(undefined);
     });
-    
-    it("GHInput should set to unresolved if new input string", function() {
+
+    it("GHInput should set to unresolved if new input string", function () {
         var input = new GHInput("12.44, 68.44");
         expect(input.isResolved()).toEqual(true);
         input.set("blup");
         expect(input.isResolved()).toEqual(false);
     });
 
-    it("point should be parsable", function() {
+    it("point should be parsable", function () {
         expect(new GHInput("12.44, 68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44, 68.44").lng).toEqual(68.44);
         expect(new GHInput("12.44,68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44,68.44").lng).toEqual(68.44);
         expect(new GHInput("london").lon).toEqual(undefined);
-    });    
+    });
 });
\ No newline at end of file
