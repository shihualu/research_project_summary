diff --git a/core/pom.xml b/core/pom.xml
index 574cd0d1cd..d578eb29bb 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -83,6 +83,13 @@
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <version>20140107</version>
+        </dependency>
+        
     </dependencies>
         
     <build>
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index ae76e32ae9..c316c92766 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -34,6 +35,7 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
@@ -384,22 +386,28 @@ public InstructionList calcInstructions( final Translation tr )
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
                 long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -408,86 +416,161 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                    updatePointsAndInstruction(edge, wayGeo);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                     ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                    if ((!name.equals(tmpName))
-                            || (!annotation.equals(tmpAnnotation)))
+                    if (isRoundabout)
+                        // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                                                annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
+
+                        // Add passed exits to instruction. There is an exit if there are
+                        // at least 2 out-going edges (one continuing in the roundabout)
+                        // This could lead to problems if there are non-complete roundabouts!
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        edgeIter.next();
+                        if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNr();}
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
+                    {
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                            .setRadian(deltaInOut)
+                            .setContinuedStreet(!Helper.isEmpty(name) && (prevName.equals(name)))
+                            .setDirOfRotation(deltaOut)
+                            .setFinished();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        annotation = tmpAnnotation;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11°
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, annotation, points);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()) );
                         ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                }
                 else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong =  wayGeo.getLongitude(beforeLast);
                 }
+                prevInRoundabout = isRoundabout;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
                     ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -496,7 +579,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index b5792db8c4..747cd829c8 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,11 +17,16 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -31,18 +36,21 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double radian;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
         this.sign = sign;
         this.name = name;
@@ -55,19 +63,34 @@ public InstructionAnnotation getAnnotation()
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName(String name)
+    {
+        this.name = name;
+    }
+
+    public Map<String,Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo(String key, Object value)
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -223,7 +246,7 @@ void checkOne()
     public String getTurnDescription( Translation tr )
     {
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
         if (indi == Instruction.FINISH)
         {
@@ -233,7 +256,7 @@ public String getTurnDescription( Translation tr )
             str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
         } else if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
@@ -261,7 +284,7 @@ public String getTurnDescription( Translation tr )
             if (dir == null)
                 throw new IllegalStateException("Indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 59b8beb890..5d36783569 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -85,6 +85,7 @@ public int size()
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..d5b9d2b882
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,152 @@
+package com.graphhopper.util;
+
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by jan on 02.02.15.
+ *
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+
+    private int exitNr = 0;
+    private boolean continuedStreet = false;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean finished = false;
+    private double radian = Double.NaN; 
+
+    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl)
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public boolean istContinuedStreet()
+    {
+        return continuedStreet;
+    }
+
+    /**
+    * indicates whether one continues on the same street as before after roundabout
+    **/
+    public RoundaboutInstruction setContinuedStreet(boolean continued)
+    {
+        this.continuedStreet = continued;
+        return this;
+    }
+
+    public RoundaboutInstruction increaseExitNr()
+    {
+        this.exitNr += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNr(int exitNr)
+    {
+        this.exitNr = exitNr;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation(double deltaIn)
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        }
+        else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setFinished()
+    {
+        finished = true;
+        return this;
+    }
+
+    private int getExitNr()
+    {
+        if (finished && exitNr == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNr>0");
+        }
+        return exitNr;
+    }
+
+    /**
+     * @return radian of angle  -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        }
+        else
+        {
+            double tmpRadian = Math.PI - clockwise*radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian(double radian)
+    {
+        this.radian = radian;
+        return this;
+    }
+
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_nr", getExitNr());
+        double radian = getRadian();
+        if (Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", JSONObject.NULL);
+        } else {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+        return tmpMap;
+        
+    }
+    
+    @Override
+    public String getTurnDescription(Translation tr)
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!finished)
+            {
+                //str = tr.tr("roundaboutEntering");
+                str = tr.tr("roundaboutInstruction", 0);
+            } else if (continuedStreet)
+            {
+                //str = tr.tr("roundaboutInstructionContinue", getExitNr());
+                str = tr.tr("roundaboutInstructionWithDir", getExitNr(), streetName);
+            } else {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutInstruction", getExitNr()) :
+                        tr.tr("roundaboutInstructionWithDir", getExitNr(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 4e6b9e423f..212b08d828 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -40,10 +37,11 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testFound()
@@ -213,4 +211,165 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
+    private class RoundaboutGraph
+    {
+        public EdgeIteratorState edge2change;
+        boolean clockwise;
+        final public Graph g = new GraphBuilder(carManager).create();
+        final public NodeAccess na = g.getNodeAccess();
+
+        private RoundaboutGraph(boolean clockwise)
+        {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        |
+            //        6
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.351);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge2change = tmpEdge.detach(false);
+            this.clockwise = clockwise;
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "Enter roundabout and use exit 3 in direction 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "Enter roundabout and use exit 2 in direction MainStreet",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        delta = rg.getAngle(1, 2, 4, 7);
+        instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Enter roundabout and use exit 3 in direction 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "Enter roundabout and use exit 2 in direction 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        RoundaboutGraph rg = new RoundaboutGraph(true);
+        System.out.println(rg.clockwise);
+
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "Enter roundabout and use exit 1 in direction 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index d2a841bce0..aa939a54c6 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -35,6 +35,8 @@
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
 import org.xml.sax.SAXException;
@@ -337,6 +339,56 @@ public void testInstructionsWithTimeAndPlace()
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                                                                 new InstructionAnnotation(0, ""), pl)
+                                          .setDirOfRotation(-0.1)
+                                          .setRadian(-Math.PI+1)
+                                          .setExitNr(2)  
+                                          .setFinished();  
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);        
+        // assert that all information is present in map for JSON
+        assertEquals("Enter roundabout and use exit 2 in direction streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_nr").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNr(2)
+                .setFinished();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("Enter roundabout and use exit 2 in direction streetname", json.get("text").toString());
+        assertEquals("null", json.get("turn_angle").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+    
     @Test
     public void testCreateGPXWithEle()
     {
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..62c9e06352 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -116,14 +116,16 @@ paths[0].instructions[0].text                 | A description what the user has
 paths[0].instructions[0].distance             | The distance for this instruction, in meter
 paths[0].instructions[0].time                 | The duration for this instruction, in ms
 paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
 paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_nr              | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
 
 
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -171,6 +173,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 8c504286f4..e22faecc66 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -366,9 +366,9 @@ function initMap(selectLayer) {
     var mapLink = '<a href="http://www.esri.com/">Esri</a>';
     var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
     var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
-                attribution: '&copy; ' + mapLink + ', ' + wholink,
-                maxZoom: 18
-            });
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
+    });
 
     var baseMaps = {
         "Lyrk": lyrk,
@@ -1146,6 +1146,8 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "marker-icon-red";
     else if (sign === 5)
         sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
@@ -1414,10 +1416,11 @@ function setAutoCompleteList(index) {
         },
         transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
         onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
