diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 754c979655..ae1285c12a 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -25,11 +25,10 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
@@ -43,32 +42,26 @@
  */
 public class AStar extends AbstractRoutingAlgorithm
 {
-    private DistanceCalc dist;
+    private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEdge> fromMap;
     private PriorityQueue<AStarEdge> prioQueueOpenSet;
     private AStarEdge currEdge;
     private int to1 = -1;
-    private double toLat;
-    private double toLon;
 
     public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
         super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(true);
+        setApproximation(new BeelineWeightApproximator(nodeAccess, weighting));
     }
 
     /**
-     * @param approx if true it enables an approximative distance calculation from lat,lon values
+     * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( boolean approx )
+    public AStar setApproximation( WeightApproximator approx )
     {
-        if (approx)
-            dist = new DistancePlaneProjection();
-        else
-            dist = new DistanceCalcEarth();
-
+        weightApprox = approx;
         return this;
     }
 
@@ -82,8 +75,6 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        toLat = nodeAccess.getLatitude(to);
-        toLon = nodeAccess.getLongitude(to);
         to1 = to;
         currEdge = createEdgeEntry(from, 0);
         if (!traversalMode.isEdgeBased())
@@ -95,7 +86,7 @@ public Path calcPath( int from, int to )
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation, tmpLat, tmpLon;
+        double currWeightToGoal, distEstimation;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
@@ -112,17 +103,14 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightToCompare;
+                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
                 AStarEdge ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightToCompare > alreadyVisitedWeight)
+                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    tmpLat = nodeAccess.getLatitude(neighborNode);
-                    tmpLon = nodeAccess.getLongitude(neighborNode);
-                    currWeightToGoal = dist.calcDist(toLat, toLon, tmpLat, tmpLon);
-                    currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                    currWeightToGoal = weightApprox.approximate(neighborNode, to1);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
                     if (ase == null)
                     {
@@ -133,7 +121,7 @@ private Path runAlgo()
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
-                        ase.weightToCompare = alreadyVisitedWeight;
+                        ase.weightOfVisitedPath = alreadyVisitedWeight;
                     } else
                         continue;
 
@@ -183,13 +171,13 @@ public int getVisitedNodes()
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
         // but to compare distance we need it only from start:
-        double weightToCompare;
+        double weightOfVisitedPath;
 
-        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightToCompare )
+        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
             super(edgeId, adjNode, weightForHeap);
             // round makes distance smaller => heuristic should underestimate the distance!
-            this.weightToCompare = (float) weightToCompare;
+            this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 07c2983055..148e3afc08 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,15 +17,13 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
 
 import com.graphhopper.routing.AStar.AStarEdge;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -33,17 +31,15 @@
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
- * for a bidirectional A* as the finish condition can not be so strict which leads to either
- * suboptimal paths or suboptimal node exploration (too many nodes). Still very good approximations
- * with a rougly twice times faster running time than the normal A* can be reached.
+ * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * Computing the Shortest Path: A∗ Search Meets Graph Theory ->
+ * See
  * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
  * <p/>
- * better stop condition
+ * and
  * <p/>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
@@ -60,6 +56,7 @@
 public class AStarBidirection extends AbstractBidirAlgo
 {
     private DistanceCalc dist;
+    private ConsitentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -67,9 +64,6 @@
     private TIntObjectMap<AStarEdge> bestWeightMapOther;
     protected AStarEdge currFrom;
     protected AStarEdge currTo;
-    protected double approximationFactor;
-    private GHPoint fromCoord;
-    private GHPoint toCoord;
     protected PathBidirRef bestPath;
 
     public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
@@ -77,9 +71,8 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
+        setApproximation(new BeelineWeightApproximator(nodeAccess, weighting));
 
-        // different default value for approximation than AStar
-        setApproximation(false);
     }
 
     protected void initCollections( int size )
@@ -94,26 +87,9 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( boolean approx )
+    public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        if (approx)
-        {
-            dist = new DistancePlaneProjection();
-            approximationFactor = 0.5;
-        } else
-        {
-            dist = new DistanceCalcEarth();
-            approximationFactor = 1.2;
-        }
-        return this;
-    }
-
-    /**
-     * Specify a low value like 0.5 for worse but faster results. Or over 1.1 for more precise.
-     */
-    public AStarBidirection setApproximationFactor( double approxFactor )
-    {
-        this.approximationFactor = approxFactor;
+        weightApprox = new ConsitentWeightApproximator(approx);
         return this;
     }
 
@@ -127,7 +103,7 @@ protected AStarEdge createEdgeEntry( int node, double dist )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        fromCoord = new GHPoint(nodeAccess.getLatitude(from), nodeAccess.getLongitude(from));
+        weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -154,7 +130,7 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        toCoord = new GHPoint(nodeAccess.getLatitude(to), nodeAccess.getLongitude(to));
+        weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -197,17 +173,14 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
             throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
     }
 
-    // Problem is the correct finish condition! if the bounds are too wide too many nodes are visited :/   
-    // d_f (v) + (v, w) + d_r (w) < μ + p_r(t)
-    // where pi_r_of_t = p_r(t) = 1/2(pi_r(t) - pi_f(t) + pi_f(s)), and pi_f(t)=0
     @Override
     protected boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight() * approximationFactor;
-        return currFrom.weightToCompare + currTo.weightToCompare >= tmp;
+        double tmp = bestPath.getWeight();
+        return currFrom.weight + currTo.weight >= tmp;
     }
 
     @Override
@@ -218,7 +191,7 @@ boolean fillEdgesFrom()
 
         currFrom = prioQueueOpenSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, toCoord, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        fillEdges(currFrom, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
         visitedCountFrom++;
         return true;
     }
@@ -231,14 +204,13 @@ boolean fillEdgesTo()
 
         currTo = prioQueueOpenSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, fromCoord, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        fillEdges(currTo, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
         visitedCountTo++;
         return true;
     }
 
-    private void fillEdges( AStarEdge currEdge, GHPoint goal,
-            PriorityQueue<AStarEdge> prioQueueOpenSet,
-            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+    private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
+                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -252,34 +224,31 @@ private void fillEdges( AStarEdge currEdge, GHPoint goal,
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weightToCompare;
+            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weightOfVisitedPath;
             if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
             
-            AStarEdge aee = shortestWeightMap.get(traversalId);
-            if (aee == null || aee.weightToCompare > alreadyVisitedWeight)
+            AStarEdge ase = shortestWeightMap.get(traversalId);
+            if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
-                double tmpLat = nodeAccess.getLatitude(neighborNode);
-                double tmpLon = nodeAccess.getLongitude(neighborNode);
-                double currWeightToGoal = dist.calcDist(goal.lat, goal.lon, tmpLat, tmpLon);
-                currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
-                if (aee == null)
+                if (ase == null)
                 {
-                    aee = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(traversalId, aee);
-                } else if (aee.weight > estimationFullDist)
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
+                    shortestWeightMap.put(traversalId, ase);
+                } else //if (ase.weight > estimationFullDist)
                 {
-                    prioQueueOpenSet.remove(aee);
-                    aee.edge = iter.getEdge();
-                    aee.weight = estimationFullDist;
-                    aee.weightToCompare = alreadyVisitedWeight;
-                } else
-                    continue;
+                    //assert (ase.weight > estimationFullDist): "weight: " + ase.weight + "full" + estimationFullDist;
+                    prioQueueOpenSet.remove(ase);
+                    ase.edge = iter.getEdge();
+                    ase.weight = estimationFullDist;
+                    ase.weightOfVisitedPath = alreadyVisitedWeight;
+                } //else  continue;
 
-                aee.parent = currEdge;
-                prioQueueOpenSet.add(aee);
-                updateBestPath(iter, aee, traversalId);
+                ase.parent = currEdge;
+                prioQueueOpenSet.add(ase);
+                updateBestPath(iter, ase, traversalId);
             }
         }
     }
@@ -293,7 +262,7 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent,
 
         boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update μ
-        double newWeight = entryCurrent.weightToCompare + entryOther.weightToCompare;
+        double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
         if (traversalMode.isEdgeBased())
         {
             if (entryOther.edge != entryCurrent.edge)
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index 012879a1e5..6189066622 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -39,9 +39,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
         } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
         {
-            return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode()).
-                    setApproximation(opts.getHints().getBool(AlgorithmOptions.ASTAR_BI + ".approximation", false)).
-                    setApproximationFactor(opts.getHints().getDouble(AlgorithmOptions.ASTAR_BI + ".approximation_factor", 1.2));
+            return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
 
         } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
         {
@@ -53,5 +51,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
         {
             throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
         }
+
+        return algo;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 041381918e..5c97aa8cd0 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -792,7 +792,7 @@ protected boolean finished()
                         return true;
 
                     // changed finish condition for CH
-                    double tmpWeight = bestPath.getWeight() * approximationFactor;
+                    double tmpWeight = bestPath.getWeight();
                     return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
                 }
 
@@ -815,8 +815,6 @@ public String toString()
                     return getName() + "|" + prepareWeighting;
                 }
             };
-            astarBi.setApproximation(opts.getHints().getBool(AlgorithmOptions.ASTAR_BI + ".approximation", false));
-            astarBi.setApproximationFactor(opts.getHints().getDouble(AlgorithmOptions.ASTAR_BI + ".approximation_factor", 1));
             algo = astarBi;
         } else if (AlgorithmOptions.DIJKSTRA_BI.equals(opts.getAlgorithm()))
         {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
new file mode 100644
index 0000000000..3a13802206
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -0,0 +1,41 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistancePlaneProjection;
+
+/**
+ * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * @author Jan Soe
+ */
+public class BeelineWeightApproximator implements WeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private DistanceCalc distanceCalc;
+
+    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+        this.nodeAccess = nodeAccess;
+        this.weighting = weighting;
+        setDistanceCalc(new DistanceCalcEarth());
+    }
+
+    @Override
+    public double approximate(int fromNode, int toNode) {
+
+        double fromLat, fromLon, toLat, toLon, dist2goal, weight2goal;
+        fromLat  = nodeAccess.getLatitude(fromNode);
+        fromLon = nodeAccess.getLongitude(fromNode);
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        weight2goal = weighting.getMinWeight(dist2goal);
+
+        return weight2goal;
+    }
+
+    public void setDistanceCalc(DistanceCalc distanceCalc) {
+        this.distanceCalc = distanceCalc;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java
new file mode 100644
index 0000000000..163420d7c3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsitentWeightApproximator.java
@@ -0,0 +1,43 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+
+/**
+ * Turns an unidirectional weight Approximation into a bidirectional consistent one.
+ * <p/>
+ * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
+ * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
+ * pages 291–296.
+ * <p/>
+ *
+ * @author Jan Soe
+ */
+public class ConsitentWeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private WeightApproximator uniDirectionalApproximator;
+    int goalNode, sourceNode;
+
+    public ConsitentWeightApproximator(WeightApproximator weightApprox){
+        this.uniDirectionalApproximator = weightApprox;
+    }
+
+    public void setSourceNode(int sourceNode){
+        this.sourceNode = sourceNode;
+    }
+
+    public void setGoalNode(int goalNode){
+        this.goalNode = goalNode;
+    }
+
+    public double approximate(int fromNode, boolean reverse)    {
+        double weightApproximation = 0.5*(uniDirectionalApproximator.approximate(fromNode, goalNode)
+                                          - uniDirectionalApproximator.approximate(fromNode, sourceNode));
+        if (reverse) {
+            weightApproximation *= -1;
+        }
+
+        return weightApproximation;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
new file mode 100644
index 0000000000..e4a6a24dfb
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -0,0 +1,16 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * <p/>
+ * @author Jan Soe
+ */
+public interface WeightApproximator
+{
+
+    /**
+     * @return minimal weight fromNode to the toNode
+     */
+    double approximate(int fromNode, int toNode);
+
+}
