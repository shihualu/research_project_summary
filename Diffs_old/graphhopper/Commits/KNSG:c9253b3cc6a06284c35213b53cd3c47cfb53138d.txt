diff --git a/.gitignore b/.gitignore
index 8d1f0f0a6e..f8fcaf5a78 100644
--- a/.gitignore
+++ b/.gitignore
@@ -45,6 +45,5 @@ local.properties
 /core/nbproject/
 /reader-overlay-data/nbproject/
 !malta-latest.osm.pbf
-/reader-json/nbproject/
 /graph-cache
 package-lock.json
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index a6a8dcb343..5554530cbe 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,5 +1,5 @@
 language: java
-sudo: false
+sudo: true
 dist: trusty
 
 env:
@@ -11,16 +11,18 @@ env:
 
 matrix:
   include:
-    - jdk: oraclejdk8
     - jdk: openjdk8
-    - env: JDK='OpenJDK 10'
-      install: . ./install-jdk.sh -F 10 -C
+    # spotbugs is not jdk 12 ready yet
+#    - env: JDK='OpenJDK 12'
+#      install: . ./install-jdk.sh -F 12 -C
+    - env: JDK='OpenJDK 11'
+      install: . ./install-jdk.sh -F 11 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
 install: true
 
 # store them into travis via https://dracoblue.net/dev/uploading-snapshots-and-releases-to-maven-central-with-travis/
-# gpg -a --export-secret-keys your@email.org | base64 -w 0
+# gpg --export-secret-keys <keyID> | base64 -w 0
 # gpg --export-ownertrust | base64 -w 0
 before_install:
   - if [ ! -z "$GPG_SECRET_KEYS" ]; then echo $GPG_SECRET_KEYS | base64 --decode | $GPG_EXECUTABLE --import; fi
@@ -37,23 +39,23 @@ before_script:
   - "mvn --version"
   - "if [ -z \"$API_KEY\" ]; then API_KEY=78da6e9a-273e-43d1-bdda-8f24e007a1fa; fi" # change in GraphHopperWebIT too
 script:
-  - "mvn -Dkey=$API_KEY clean test verify checkstyle:check findbugs:check forbiddenapis:check -B"
+  - "mvn -Dkey=$API_KEY clean test verify checkstyle:check spotbugs:check forbiddenapis:check -B"
 
 after_success:
-  # deploy snapshot artifacts to sonatype and if tagged deploy then release to maven central
-  - if [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
-        mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
-    elif [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_TAG" != "" ]; then
+  # if tagged deploy then release to maven central or deploy snapshot artifacts to sonatype 
+  - if [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_TAG" != "" ]; then
         echo "release to maven central";
         mvn versions:set -DnewVersion=$TRAVIS_TAG -DgenerateBackupPoms=false;
         mvn deploy -P release --settings core/files/settings.xml -DskipTests=true -B;
+    elif [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
+        mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
     else
         echo "Not deploying artifacts for $TRAVIS_BRANCH";
     fi
 
 notifications:
   email:
-    - secure: l7/fjqL0c/9UcULXdhaKxsroZMg07nfNDiOHRBf7YKf8wrKdH52Z5kP7E10+a8iD/ieLD+ZaZPlom1bE7HymE1bVkp3d17Ezha47W5sdyOOb3NBDpg8olS4TkehOKo3AQhLXSfF6QGtipxY8Iy9QknXHngQOrcoGYiOlzCZ3BTQ=
+    - $EMAIL
 
 cache:
   directories:
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 3f26531b71..39b9c68ffc 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -7,11 +7,13 @@ state this as a comment via a separate, signed commit.
 
 Here is an overview:
 
- * ammagamma, improvements like #700, #703
+ * ammagamma, several improvements on core algorithms
  * AnahitaS, docs for Android, Android, Tomcat
  * andreaswolf, flag encoder versioning and more
+ * andreylh, polygon for blocked area #1306
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
+ * baumboi, path detail and landmark improvements
  * boldtrn, one of the core developers with motorcycle knowledge :)
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * ChristianSeitzer, motorcycle improvements
diff --git a/Dockerfile b/Dockerfile
index 19d70fc819..dcb3a11aac 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,6 @@
 FROM openjdk:8-jdk
 
-ENV JETTY_PORT 11111
-ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=8989"
 
 RUN mkdir -p /data && \
     mkdir -p /graphhopper
@@ -10,11 +9,11 @@ COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
-RUN ./graphhopper.sh buildweb
+RUN ./graphhopper.sh build
 
 VOLUME [ "/data" ]
 
-EXPOSE 11111
+EXPOSE 8989
 
 ENTRYPOINT [ "./graphhopper.sh", "web" ]
 
diff --git a/NOTICE.md b/NOTICE.md
index aa7adc7dcd..d834568aab 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -15,7 +15,7 @@ The core module includes the following software:
  * Apache Commons Collections - we copied parts of the BinaryHeap (Apache License)
  * java-string-similarity - we copied the implementation of JaroWinkler (MIT license)
  * com.fasterxml.jackson.core:jackson-annotations (Apache License)
- * com.vividsolutions:jts (LGPL), see #1039
+ * org.locationtech:jts (EDL), see #1039
 
 reader-osm:
 
@@ -25,14 +25,9 @@ reader-osm:
 
 reader-gtfs:
  
- * com.conveyal:gtfs-lib (BSD 2-clause license)
+ * some files from com.conveyal:gtfs-lib (BSD 2-clause license)
  * com.google.transit:gtfs-realtime-bindings (Apache license)
 
-reader-json:
-
- * com.bedatadriven:jackson-datatype-jts (Apache license)
- * com.fasterxml.jackson.core:jackson-databind (Apache license)
-
 reader-shp:
  
  * org.geotools:gt-shapefile (LGPL)
diff --git a/README.md b/README.md
index b344fcdd9c..8f2c808077 100644
--- a/README.md
+++ b/README.md
@@ -13,11 +13,12 @@ We have a prospering community and welcome everyone. Let us know your problems,
 
 To get started, read through our documentation and install the GraphHopper Web Service locally:
 
- * unstable: [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.11-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.11-SNAPSHOT/)
- * 0.10.0 latest stable: [announcement](https://www.graphhopper.com/blog/2018/03/08/graphhopper-routing-engine-0-10-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.10/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.10.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.10.0.apk)
- * 0.9.0: [announcement](https://www.graphhopper.com/blog/2017/05/31/graphhopper-routing-engine-0-9-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.9/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.9.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.9.0.apk)
- * 0.8.2: [announcement](https://www.graphhopper.com/blog/2016/10/18/graphhopper-routing-engine-0-8-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.8/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.8.2-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk)
- * 0.7.0: [announcement](https://www.graphhopper.com/blog/2016/06/15/graphhopper-routing-engine-0-7-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.7/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.7.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.7.0.apk)
+ * unstable: [documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [web service jar](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.12-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.12-SNAPSHOT/)
+ * 0.11.0 latest stable: [announcement](https://www.graphhopper.com/blog/2018/09/17/graphhopper-routing-engine-0-11-release-open-sourcing-the-isochrone-module/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.11/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.11.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.11.0.apk)
+ * 0.10.0: [announcement](https://www.graphhopper.com/blog/2018/03/08/graphhopper-routing-engine-0-10-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.10/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.10.3-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.10.3.apk)
+ * 0.9.0: [announcement](https://www.graphhopper.com/blog/2017/05/31/graphhopper-routing-engine-0-9-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.9/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.9.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.9.0.apk)
+ * 0.8.2: [announcement](https://www.graphhopper.com/blog/2016/10/18/graphhopper-routing-engine-0-8-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.8/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.8.2-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk)
+ * 0.7.0: [announcement](https://www.graphhopper.com/blog/2016/06/15/graphhopper-routing-engine-0-7-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.7/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.7.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.7.0.apk)
 
 ## Questions
 
@@ -39,13 +40,31 @@ a Routing API via GraphHopper, a Route Optimization API via [jsprit](http://jspr
 and an address search via [Photon](https://github.com/komoot/photon). Additionally, map tiles from various providers are used 
 where the default is [Omniscale](http://omniscale.com/). All of these are available for free, via encrypted connections and from German servers for a nice and private route planning experience!
 
+## For Public Transit
+
+[Get started](./reader-gtfs/README.md#quick-start)
+
+[![Realtime Demo](https://www.graphhopper.com/wp-content/uploads/2018/05/Screen-Shot-2018-05-16-at-21.23.25-600x538.png)](./reader-gtfs/README.md#quick-start)
 
 ## For Mobile Apps
 
 There are subprojects to make GraphHopper working offline
-on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+on [Android](./android/README.md)
 and [iOS](http://github.com/graphhopper/graphhopper-ios)
 
+[![simple routing](https://www.graphhopper.com/wp-content/uploads/2016/10/android-demo-screenshot-2.png)](./android/README.md)
+
+## For Analysis
+
+There is the isochrone subproject to calculate and visualize the reachable area for a certain travel mode
+
+**[Isochrone Web API](./docs/web/api-doc.md#isochrone)**
+
+[![Isochrone API image](./docs/isochrone/images/isochrone.png)](./docs/web/api-doc.md#isochrone)
+
+**[Isochrone Experiments](//www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)**
+
+[![high precision reachability image](https://www.graphhopper.com/wp-content/uploads/2018/06/berlin-reachability-768x401.png)](https://www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)
 
 # Technical Overview
 
@@ -79,7 +98,7 @@ but of course this is not necessary.
 OpenStreetMap is directly supported from GraphHopper. Without the amazing data from
 OpenStreetMap, GraphHopper wouldn't be possible at all.
 Other map data will need a custom import procedure, see e.g. <a href="https://github.com/graphhopper/graphhopper/issues/277">Ordnance Survey</a>,
-<a href="https://github.com/graphhopper/graphhopper/tree/master/reader-shp">Shapefile like ESRI</a> or <a href="https://github.com/knowname/morituri">Navteq</a>.
+<a href="https://github.com/graphhopper/graphhopper-reader-shp">Shapefile like ESRI</a> or <a href="https://github.com/knowname/morituri">Navteq</a>.
 
 ## Written in Java
 
@@ -94,7 +113,7 @@ Embed GraphHopper with OpenStreetMap support into your Java application via the
 <dependency>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>[LATEST-VERSION]/version>
+    <version>[LATEST-VERSION]</version>
 </dependency>
 ```
 
@@ -148,6 +167,13 @@ cd core/files/
 docker-compose up -d
 ```
 
+If you don't want to use docker-compose you can do the following:
+```bash
+docker build -t graphhopper:master .
+docker run -d --name graphhopper -v <path_data_directory>/data:/data -p 8989:8989 graphhopper:master
+```
+
+
 # Features
 
 Here is a list of the more detailed features including a link to the documentation:
@@ -174,3 +200,4 @@ Here is a list of the more detailed features including a link to the documentati
  * Scales from small indoor-sized to world-wide-sized graphs
  * Find nearest point on street e.g. to get elevation or 'snapp to road'
  * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
+ * Calculate [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 8604ec2c31..2addb80a54 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,26 +1,26 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 27
-    buildToolsVersion "27.0.3"
+    compileSdkVersion 28
+    buildToolsVersion "28.0.3"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
         minSdkVersion 10
+        //noinspection ExpiredTargetSdkVersion
         targetSdkVersion 22
     }
 
-    buildTypes {
+    /*buildTypes {
         all {
             minifyEnabled true
             useProguard false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
-    }
+    }*/
 
     lintOptions {
         /* CGIARProvider refers to java.awt
-         * Helper7 refers to java.lang.management
          * HeightTile refers to javax.imageio and java.awt
          * OSMElement refers to javax.xml.stream
          */
@@ -36,24 +36,21 @@ configurations.all {
  **/
 
 dependencies {
-    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.11-SNAPSHOT') {
+    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.12-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.9.2'
-    implementation 'org.mapsforge:vtm-android:0.9.2'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86_64'
-    implementation('org.mapsforge:vtm-jts:0.9.2') {
-      exclude group: 'com.vividsolutions', module: 'jts'
-    }
-    implementation 'org.mapsforge:vtm-themes:0.9.2'
-    implementation 'com.caverock:androidsvg:1.2.2-beta-1'
+    implementation 'org.mapsforge:vtm:0.10.0'
+    implementation 'org.mapsforge:vtm-android:0.10.0'
+    implementation 'org.mapsforge:vtm-android:0.10.0:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.10.0:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.10.0:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.10.0:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.10.0'
+    implementation 'org.mapsforge:vtm-themes:0.10.0'
+    implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
     implementation 'org.slf4j:slf4j-android:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index af79e68c23..c5c65bedc6 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -16,10 +16,10 @@
         <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.9.2</vtm.version>
+        <vtm.version>0.10.0</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -55,12 +55,6 @@
             <version>${vtm.version}</version>
         </dependency>
         
-        <dependency>
-            <groupId>org.mapsforge</groupId>            
-            <artifactId>vtm-android</artifactId>
-            <version>${vtm.version}</version>
-            <classifier>natives-armeabi</classifier>
-        </dependency>  
          <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-android</artifactId>
@@ -90,12 +84,6 @@
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-jts</artifactId>
             <version>${vtm.version}</version>
-            <exclusions>
-              <exclusion>
-                <groupId>com.vividsolutions</groupId>
-                <artifactId>jts</artifactId>
-              </exclusion>
-            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.mapsforge</groupId>            
@@ -105,7 +93,7 @@
         <dependency>
             <groupId>com.caverock</groupId>            
             <artifactId>androidsvg</artifactId>
-            <version>1.2.2-beta-1</version>
+            <version>1.3</version>
         </dependency> 
         
         <dependency>
diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index c407c842d2..32f48265cc 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -10,10 +10,6 @@
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
-    <uses-sdk
-        android:minSdkVersion="10"
-        android:targetSdkVersion="22" />
-
     <application
         android:allowBackup="true"
         android:icon="@drawable/logo"
diff --git a/android/build.gradle b/android/build.gradle
index 7105f5a2dd..a743a5ba45 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.1'
+        classpath 'com.android.tools.build:gradle:3.2.1'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
index 13372aef5e..f6b961fd5a 100644
Binary files a/android/gradle/wrapper/gradle-wrapper.jar and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index cd201a3dc2..9a4163a4f5 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Thu Oct 26 11:57:58 EEST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/android/gradlew b/android/gradlew
index 9d82f78915..cccdd3d517 100755
--- a/android/gradlew
+++ b/android/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -150,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
index 8a0b282aa6..f9553162f1 100644
--- a/android/gradlew.bat
+++ b/android/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/api/pom.xml b/api/pom.xml
new file mode 100644
index 0000000000..1d7b2d684f
--- /dev/null
+++ b/api/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-api</artifactId>
+    <packaging>jar</packaging>
+    <version>0.12-SNAPSHOT</version>
+    <name>GraphHopper API</name>
+    <description>Use the GraphHopper routing engine as a web-service</description>
+
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.12-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.locationtech.jts</groupId>
+            <artifactId>jts-core</artifactId>
+            <version>1.15.1</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
+
+
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/api/src/main/java/com/graphhopper/GHRequest.java
similarity index 99%
rename from core/src/main/java/com/graphhopper/GHRequest.java
rename to api/src/main/java/com/graphhopper/GHRequest.java
index 326ea176e3..38b40c2529 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/api/src/main/java/com/graphhopper/GHRequest.java
@@ -251,7 +251,7 @@ public GHRequest setPointHints(List<String> pointHints) {
     }
 
     public boolean hasPointHints() {
-        return pointHints.size() == points.size();
+        return pointHints.size() == points.size() && !points.isEmpty();
     }
 
     public GHRequest setPathDetails(List<String> pathDetails) {
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/api/src/main/java/com/graphhopper/GHResponse.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/GHResponse.java
rename to api/src/main/java/com/graphhopper/GHResponse.java
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/api/src/main/java/com/graphhopper/GraphHopperAPI.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/GraphHopperAPI.java
rename to api/src/main/java/com/graphhopper/GraphHopperAPI.java
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/api/src/main/java/com/graphhopper/PathWrapper.java
similarity index 91%
rename from core/src/main/java/com/graphhopper/PathWrapper.java
rename to api/src/main/java/com/graphhopper/PathWrapper.java
index 59306ff90d..d74dbb3e7a 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/api/src/main/java/com/graphhopper/PathWrapper.java
@@ -18,7 +18,6 @@
 package com.graphhopper;
 
 import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.PathMerger;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.shapes.BBox;
@@ -246,13 +245,32 @@ public void addPathDetails(Map<String, List<PathDetail>> details) {
         for (Map.Entry<String, List<PathDetail>> detailEntry : details.entrySet()) {
             if (this.pathDetails.containsKey(detailEntry.getKey())) {
                 List<PathDetail> pd = this.pathDetails.get(detailEntry.getKey());
-                PathMerger.merge(pd, detailEntry.getValue());
+                merge(pd, detailEntry.getValue());
             } else {
                 this.pathDetails.put(detailEntry.getKey(), detailEntry.getValue());
             }
         }
     }
 
+    /**
+     * Merges <code>otherDetails</code> into the <code>pathDetails</code>.
+     * <p>
+     * This method makes sure that Entry list around via points are merged correctly.
+     * See #1091 and the misplaced PathDetail after waypoints.
+     */
+    public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDetails) {
+        // Make sure that the PathDetail list is merged correctly at via points
+        if (!pathDetails.isEmpty() && !otherDetails.isEmpty()) {
+            PathDetail lastDetail = pathDetails.get(pathDetails.size() - 1);
+            if (lastDetail.getValue().equals(otherDetails.get(0).getValue())) {
+                lastDetail.setLast(otherDetails.get(0).getLast());
+                otherDetails.remove(0);
+            }
+        }
+
+        pathDetails.addAll(otherDetails);
+    }
+
     public Map<String, List<PathDetail>> getPathDetails() {
         return this.pathDetails;
     }
diff --git a/core/src/main/java/com/graphhopper/Trip.java b/api/src/main/java/com/graphhopper/Trip.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/Trip.java
rename to api/src/main/java/com/graphhopper/Trip.java
index 7c6866d6a0..fdd6ef4d75 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/api/src/main/java/com/graphhopper/Trip.java
@@ -1,9 +1,8 @@
 package com.graphhopper;
 
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.InstructionList;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.Point;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.Point;
 
 import java.util.Date;
 import java.util.List;
@@ -12,14 +11,12 @@
     public static abstract class Leg {
         public final String type;
         public final String departureLocation;
-        public final List<EdgeIteratorState> edges;
         public final Geometry geometry;
         public final double distance;
 
-        public Leg(String type, String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance) {
+        public Leg(String type, String departureLocation, Geometry geometry, double distance) {
             this.type = type;
             this.departureLocation = departureLocation;
-            this.edges = edges;
             this.geometry = geometry;
             this.distance = distance;
         }
@@ -75,8 +72,8 @@ public String toString() {
         private final Date departureTime;
         private final Date arrivalTime;
 
-        public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
-            super("walk", departureLocation, edges, geometry, distance);
+        public WalkLeg(String departureLocation, Date departureTime, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
+            super("walk", departureLocation, geometry, distance);
             this.instructions = instructions;
             this.departureTime = departureTime;
             this.arrivalTime = arrivalTime;
@@ -102,13 +99,13 @@ public Date getArrivalTime() {
         public final String trip_id;
         public final String route_id;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
-            super("pt", stops.get(0).stop_name, edges, geometry, distance);
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, String headsign, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
+            super("pt", stops.get(0).stop_name, geometry, distance);
             this.feed_id = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
             this.trip_id = tripId;
             this.route_id = routeId;
-            this.trip_headsign = edges.get(0).getName();
+            this.trip_headsign = headsign;
             this.travelTime = travelTime;
             this.stops = stops;
         }
diff --git a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java b/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
similarity index 73%
rename from core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
rename to api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
index 6ebed646ef..9ce4c4790b 100644
--- a/core/src/main/java/com/graphhopper/json/geo/JsonFeature.java
+++ b/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
@@ -17,10 +17,8 @@
  */
 package com.graphhopper.json.geo;
 
-import com.fasterxml.jackson.annotation.JsonCreator;
-import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.util.shapes.BBox;
-import com.vividsolutions.jts.geom.Geometry;
+import org.locationtech.jts.geom.Geometry;
 
 import java.util.Map;
 
@@ -30,14 +28,16 @@
  * @author Peter Karich
  */
 public class JsonFeature {
-    final String id;
-    final String type;
-    final BBox bbox;
-    final Geometry geometry;
-    final Map<String, Object> properties;
-
-    @JsonCreator
-    public JsonFeature(@JsonProperty("id") String id, @JsonProperty("type") String type, @JsonProperty("bbox") BBox bbox, @JsonProperty("geometry") Geometry geometry, @JsonProperty("properties") Map<String, Object> properties) {
+    private String id;
+    private String type = "Feature";
+    private BBox bbox;
+    private Geometry geometry;
+    private Map<String, Object> properties;
+
+    public JsonFeature() {
+    }
+
+    public JsonFeature(String id, String type, BBox bbox, Geometry geometry, Map<String, Object> properties) {
         this.id = id;
         this.type = type;
         this.bbox = bbox;
@@ -77,6 +77,22 @@ public Object getProperty(String key) {
         return properties.get(key);
     }
 
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public void setBbox(BBox bbox) {
+        this.bbox = bbox;
+    }
+
+    public void setGeometry(Geometry geometry) {
+        this.geometry = geometry;
+    }
+
+    public void setProperties(Map<String, Object> properties) {
+        this.properties = properties;
+    }
+
     @Override
     public String toString() {
         return "id:" + getId();
diff --git a/core/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java b/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
similarity index 89%
rename from core/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
rename to api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
index 39541f09b4..55d8a42187 100644
--- a/core/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
+++ b/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
@@ -17,14 +17,15 @@
  */
 package com.graphhopper.json.geo;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Peter Karich
  */
 public class JsonFeatureCollection {
-    String type;
-    List<JsonFeature> features;
+    String type = "FeatureCollection";
+    List<JsonFeature> features = new ArrayList<>();
 
     public String getType() {
         return type;
diff --git a/core/src/main/java/com/graphhopper/routing/util/HintsMap.java b/api/src/main/java/com/graphhopper/routing/util/HintsMap.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/routing/util/HintsMap.java
rename to api/src/main/java/com/graphhopper/routing/util/HintsMap.java
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/api/src/main/java/com/graphhopper/util/AngleCalc.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/AngleCalc.java
rename to api/src/main/java/com/graphhopper/util/AngleCalc.java
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/api/src/main/java/com/graphhopper/util/CmdArgs.java
similarity index 91%
rename from core/src/main/java/com/graphhopper/util/CmdArgs.java
rename to api/src/main/java/com/graphhopper/util/CmdArgs.java
index e270ec3f30..ebebfdecd2 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/api/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -17,18 +17,11 @@
  */
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.annotation.JsonCreator;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Properties;
 
-import static com.graphhopper.util.Helper.*;
+import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
@@ -41,7 +34,6 @@
     public CmdArgs() {
     }
 
-    @JsonCreator
     public CmdArgs(Map<String, String> map) {
         super(map);
     }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/api/src/main/java/com/graphhopper/util/DistanceCalc.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/DistanceCalc.java
rename to api/src/main/java/com/graphhopper/util/DistanceCalc.java
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/api/src/main/java/com/graphhopper/util/DistanceCalc3D.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
rename to api/src/main/java/com/graphhopper/util/DistanceCalc3D.java
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
similarity index 99%
rename from core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
rename to api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 6e0ebe8354..4c7bdbac5a 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.*;
+
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 
-import static java.lang.Math.*;
-
 /**
  * @author Peter Karich
  */
@@ -155,7 +155,7 @@ else if (factor < 0)
         return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
-    private double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
+    double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
         return cos(toRadians((a_lat_deg + b_lat_deg) / 2));
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java b/api/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
rename to api/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/api/src/main/java/com/graphhopper/util/FinishInstruction.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/FinishInstruction.java
rename to api/src/main/java/com/graphhopper/util/FinishInstruction.java
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/api/src/main/java/com/graphhopper/util/GPXEntry.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/GPXEntry.java
rename to api/src/main/java/com/graphhopper/util/GPXEntry.java
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/api/src/main/java/com/graphhopper/util/Helper.java
similarity index 69%
rename from core/src/main/java/com/graphhopper/util/Helper.java
rename to api/src/main/java/com/graphhopper/util/Helper.java
index 9caf49225b..de08e73101 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/api/src/main/java/com/graphhopper/util/Helper.java
@@ -17,25 +17,12 @@
  */
 package com.graphhopper.util;
 
-import com.carrotsearch.hppc.IntArrayList;
-import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.util.shapes.BBox;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.*;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.charset.Charset;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.text.DateFormat;
 import java.text.NumberFormat;
 import java.text.SimpleDateFormat;
@@ -43,11 +30,8 @@
 import java.util.Map.Entry;
 
 /**
- * Several utility classes which are compatible with Java6 on Android.
- * <p>
  *
  * @author Peter Karich
- * @see Helper7 for none-Android compatible methods.
  */
 public class Helper {
     public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
@@ -57,7 +41,6 @@
     public static final Charset UTF_CS = Charset.forName("UTF-8");
     public static final TimeZone UTC = TimeZone.getTimeZone("UTC");
     public static final long MB = 1L << 20;
-    private static final Logger LOGGER = LoggerFactory.getLogger(Helper.class);
     // +- 180 and +-90 => let use use 400
     private static final float DEGREE_FACTOR = Integer.MAX_VALUE / 400f;
     // milli meter is a bit extreme but we have integers
@@ -66,15 +49,6 @@
     private Helper() {
     }
 
-    public static ArrayList<Integer> intListToArrayList(IntIndexedContainer from) {
-        int len = from.size();
-        ArrayList<Integer> list = new ArrayList<>(len);
-        for (int i = 0; i < len; i++) {
-            list.add(from.get(i));
-        }
-        return list;
-    }
-
     public static Locale getLocale(String param) {
         int pointIndex = param.indexOf('.');
         if (pointIndex > 0)
@@ -112,34 +86,6 @@ public static int countBitValue(int maxTurnCosts) {
         return counter++;
     }
 
-    public static void loadProperties(Map<String, String> map, Reader tmpReader) throws IOException {
-        BufferedReader reader = new BufferedReader(tmpReader);
-        String line;
-        try {
-            while ((line = reader.readLine()) != null) {
-                if (line.startsWith("//") || line.startsWith("#")) {
-                    continue;
-                }
-
-                if (Helper.isEmpty(line)) {
-                    continue;
-                }
-
-                int index = line.indexOf("=");
-                if (index < 0) {
-                    LOGGER.warn("Skipping configuration at line:" + line);
-                    continue;
-                }
-
-                String field = line.substring(0, index);
-                String value = line.substring(index + 1);
-                map.put(field.trim(), value.trim());
-            }
-        } finally {
-            reader.close();
-        }
-    }
-
     public static void saveProperties(Map<String, String> map, Writer tmpWriter) throws IOException {
         BufferedWriter writer = new BufferedWriter(tmpWriter);
         try {
@@ -296,10 +242,6 @@ public static String pruneFileEnd(String file) {
         return list;
     }
 
-    public static IntArrayList createTList(int... list) {
-        return IntArrayList.from(list);
-    }
-
     public static PointList createPointList(double... list) {
         if (list.length % 2 != 0)
             throw new IllegalArgumentException("list should consist of lat,lon pairs!");
@@ -373,79 +315,6 @@ public static final double intToEle(int integEle) {
         return integEle / ELE_FACTOR;
     }
 
-    public static void cleanMappedByteBuffer(final ByteBuffer buffer) {
-        // TODO avoid reflection on every call
-        try {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
-                @Override
-                public Object run() throws Exception {
-                    if (Constants.JRE_IS_MINIMUM_JAVA9) {
-                        // >=JDK9 class sun.misc.Unsafe { void invokeCleaner(ByteBuffer buf) }
-                        final Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
-                        // fetch the unsafe instance and bind it to the virtual MethodHandle
-                        final Field f = unsafeClass.getDeclaredField("theUnsafe");
-                        f.setAccessible(true);
-                        final Object theUnsafe = f.get(null);
-                        final Method method = unsafeClass.getDeclaredMethod("invokeCleaner", ByteBuffer.class);
-                        try {
-                            method.invoke(theUnsafe, buffer);
-                            return null;
-                        } catch (Throwable t) {
-                            throw new RuntimeException(t);
-                        }
-                    }
-
-                    if (buffer.getClass().getSimpleName().equals("MappedByteBufferAdapter")) {
-                        if (!Constants.ANDROID)
-                            throw new RuntimeException("MappedByteBufferAdapter only supported for Android at the moment");
-
-                        // For Android 4.1 call ((MappedByteBufferAdapter)buffer).free() see #914
-                        Class<?> directByteBufferClass = Class.forName("java.nio.MappedByteBufferAdapter");
-                        callBufferFree(buffer, directByteBufferClass);
-                    } else {
-                        // <=JDK8 class DirectByteBuffer { sun.misc.Cleaner cleaner(Buffer buf) }
-                        //        then call sun.misc.Cleaner.clean
-                        final Class<?> directByteBufferClass = Class.forName("java.nio.DirectByteBuffer");
-                        try {
-                            final Method dbbCleanerMethod = directByteBufferClass.getMethod("cleaner");
-                            dbbCleanerMethod.setAccessible(true);
-                            // call: cleaner = ((DirectByteBuffer)buffer).cleaner()
-                            final Object cleaner = dbbCleanerMethod.invoke(buffer);
-                            if (cleaner != null) {
-                                final Class<?> cleanerMethodReturnType = dbbCleanerMethod.getReturnType();
-                                final Method cleanMethod = cleanerMethodReturnType.getDeclaredMethod("clean");
-                                cleanMethod.setAccessible(true);
-                                // call: ((sun.misc.Cleaner)cleaner).clean()
-                                cleanMethod.invoke(cleaner);
-                            }
-                        } catch (NoSuchMethodException ex2) {
-                            if (Constants.ANDROID)
-                                // For Android 5.1.1 call ((DirectByteBuffer)buffer).free() see #933
-                                callBufferFree(buffer, directByteBufferClass);
-                            else
-                                // ignore if method cleaner or clean is not available
-                                LOGGER.warn("NoSuchMethodException | " + Constants.JAVA_VERSION, ex2);
-                        }
-                    }
-
-                    return null;
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw new RuntimeException("Unable to unmap the mapped buffer", e);
-        }
-    }
-
-    private static void callBufferFree(ByteBuffer buffer, Class<?> directByteBufferClass)
-            throws InvocationTargetException, IllegalAccessException {
-        try {
-            final Method dbbFreeMethod = directByteBufferClass.getMethod("free");
-            dbbFreeMethod.setAccessible(true);
-            dbbFreeMethod.invoke(buffer);
-        } catch (NoSuchMethodException ex2) {
-            LOGGER.warn("NoSuchMethodException | " + Constants.JAVA_VERSION, ex2);
-        }
-    }
 
     /**
      * Trying to force the release of the mapped ByteBuffer. See
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/api/src/main/java/com/graphhopper/util/Instruction.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/Instruction.java
rename to api/src/main/java/com/graphhopper/util/Instruction.java
diff --git a/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java b/api/src/main/java/com/graphhopper/util/InstructionAnnotation.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
rename to api/src/main/java/com/graphhopper/util/InstructionAnnotation.java
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/api/src/main/java/com/graphhopper/util/InstructionList.java
similarity index 97%
rename from core/src/main/java/com/graphhopper/util/InstructionList.java
rename to api/src/main/java/com/graphhopper/util/InstructionList.java
index 70eab2ee1b..5d9192e6be 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/api/src/main/java/com/graphhopper/util/InstructionList.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.annotation.JsonValue;
-
 import java.text.DateFormat;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
@@ -80,7 +78,6 @@ public void replaceLast(Instruction instr) {
         instructions.set(instructions.size() - 1, instr);
     }
 
-    @JsonValue
     public List<Map<String, Object>> createJson() {
         List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
         int pointsIndex = 0;
@@ -148,13 +145,13 @@ public void replaceLast(Instruction instr) {
      *
      * @return string to be stored as gpx file
      */
-    public String createGPX() {
-        return createGPX("GraphHopper", new Date().getTime());
+    public String createGPX(String version) {
+        return createGPX("GraphHopper", new Date().getTime(), version);
     }
 
-    public String createGPX(String trackName, long startTimeMillis) {
+    public String createGPX(String trackName, long startTimeMillis, String version) {
         boolean includeElevation = size() > 0 && get(0).getPoints().is3D();
-        return createGPX(trackName, startTimeMillis, includeElevation, true, true, true);
+        return createGPX(trackName, startTimeMillis, includeElevation, true, true, true, version);
     }
 
     private void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat) {
@@ -171,7 +168,7 @@ private void createWayPointBlock(StringBuilder output, Instruction instruction,
         output.append("</wpt>");
     }
 
-    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
+    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
         DateFormat formatter = Helper.createFormatter();
 
         DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
@@ -181,7 +178,7 @@ public String createGPX(String trackName, long startTimeMillis, boolean includeE
 
         String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
                 + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
-                + " creator=\"Graphhopper version " + Constants.VERSION + "\" version=\"1.1\""
+                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
                 // This xmlns:gh acts only as ID, no valid URL necessary.
                 // Use a separate namespace for custom extensions to make basecamp happy.
                 + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
diff --git a/core/src/main/java/com/graphhopper/util/NumHelper.java b/api/src/main/java/com/graphhopper/util/NumHelper.java
similarity index 85%
rename from core/src/main/java/com/graphhopper/util/NumHelper.java
rename to api/src/main/java/com/graphhopper/util/NumHelper.java
index 8ee33be99f..7f16dd2033 100644
--- a/core/src/main/java/com/graphhopper/util/NumHelper.java
+++ b/api/src/main/java/com/graphhopper/util/NumHelper.java
@@ -39,11 +39,4 @@ public static int compare(double d1, double d2) {
         return Double.compare(d1, d2);
     }
 
-    public static boolean equalsEps(float d1, float d2) {
-        return equalsEps(d1, d2, DEFAULT_PRECISION);
-    }
-
-    public static boolean equalsEps(float d1, float d2, float epsilon) {
-        return Math.abs(d1 - d2) < epsilon;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/api/src/main/java/com/graphhopper/util/PMap.java
similarity index 93%
rename from core/src/main/java/com/graphhopper/util/PMap.java
rename to api/src/main/java/com/graphhopper/util/PMap.java
index 2590258393..c40ce658cb 100644
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/api/src/main/java/com/graphhopper/util/PMap.java
@@ -34,7 +34,7 @@ public PMap() {
     }
 
     public PMap(int capacity) {
-        this(new HashMap<String, String>(capacity));
+        this(new HashMap<>(capacity));
     }
 
     public PMap(Map<String, String> map) {
@@ -128,6 +128,17 @@ public double getDouble(String key, double _default) {
         return _default;
     }
 
+    public float getFloat(String key, float _default) {
+        String str = get(key);
+        if (!Helper.isEmpty(str)) {
+            try {
+                return Float.parseFloat(str);
+            } catch (Exception ex) {
+            }
+        }
+        return _default;
+    }
+
     public String get(String key, String _default) {
         String str = get(key);
         if (Helper.isEmpty(str))
diff --git a/core/src/main/java/com/graphhopper/util/Parameters.java b/api/src/main/java/com/graphhopper/util/Parameters.java
similarity index 98%
rename from core/src/main/java/com/graphhopper/util/Parameters.java
rename to api/src/main/java/com/graphhopper/util/Parameters.java
index bec582c3f3..0ec9de5fc3 100644
--- a/core/src/main/java/com/graphhopper/util/Parameters.java
+++ b/api/src/main/java/com/graphhopper/util/Parameters.java
@@ -207,8 +207,7 @@
         public static final String IGNORE_TRANSFERS = "pt.ignore_transfers";
         public static final String WALK_SPEED = "pt.walk_speed";
         public static final String MAX_WALK_DISTANCE_PER_LEG = "pt.max_walk_distance_per_leg";
-        public static final String MAX_TRANSFER_DISTANCE_PER_LEG = "pt.max_transfer_distance_per_leg";
         public static final String LIMIT_SOLUTIONS = "pt.limit_solutions";
-
+        public static final String BLOCKED_ROUTE_TYPES = "pt.blocked_route_types";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/api/src/main/java/com/graphhopper/util/PointAccess.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/PointAccess.java
rename to api/src/main/java/com/graphhopper/util/PointAccess.java
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
similarity index 86%
rename from core/src/main/java/com/graphhopper/util/PointList.java
rename to api/src/main/java/com/graphhopper/util/PointList.java
index d30ce6f8af..11ae6f155e 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -19,9 +19,9 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.GeometryFactory;
-import com.vividsolutions.jts.geom.LineString;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
 
 import java.util.Arrays;
 import java.util.Iterator;
@@ -29,9 +29,7 @@
 
 /**
  * Slim list to store several points (without the need for a point object). Be aware that the PointList is closely
- * coupled with the {@link ShallowImmutablePointList} if you change it or extend it, you should make sure that your
- * changes play well with the ShallowImmutablePointList to avoid unexpected issues.
- * <p>
+ * coupled with the {@link ShallowImmutablePointList} both are not designed for inheritance (but final is not possible if we keep it simple).
  *
  * @author Peter Karich
  */
@@ -122,11 +120,6 @@ public double getEle(int index) {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
-        @Override
-        public LineString toLineString(boolean includeElevation) {
-            throw new UnsupportedOperationException("cannot access EMPTY PointList");
-        }
-
         @Override
         public void reverse() {
             throw new UnsupportedOperationException("cannot change EMPTY PointList");
@@ -152,7 +145,8 @@ public boolean is3D() {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
     };
-    private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
+
+    private final static DistanceCalc3D distCalc3D = new DistanceCalc3D();
     final static String ERR_MSG = "Tried to access PointList with too big index!";
     protected int size = 0;
     protected boolean is3D;
@@ -406,20 +400,32 @@ public static PointList fromLineString(LineString lineString) {
 
     public LineString toLineString(boolean includeElevation) {
         GeometryFactory gf = new GeometryFactory();
-        Coordinate[] coordinates = new Coordinate[getSize()];
+        Coordinate[] coordinates = new Coordinate[getSize() == 1 ? 2 : getSize()];
         for (int i = 0; i < getSize(); i++) {
             coordinates[i] = includeElevation ?
                     new Coordinate(
-                            Helper.round6(getLongitude(i)),
-                            Helper.round6(getLatitude(i)),
-                            Helper.round2(getElevation(i))) :
+                            round6(getLongitude(i)),
+                            round6(getLatitude(i)),
+                            round2(getElevation(i))) :
                     new Coordinate(
-                            Helper.round6(getLongitude(i)),
-                            Helper.round6(getLatitude(i)));
+                            round6(getLongitude(i)),
+                            round6(getLatitude(i)));
         }
+
+        // special case as just 1 point is not supported in the specification #1412
+        if (getSize() == 1)
+            coordinates[1] = coordinates[0];
         return gf.createLineString(coordinates);
     }
 
+    public static final double round6(double value) {
+        return Math.round(value * 1e6) / 1e6;
+    }
+
+    public static final double round2(double value) {
+        return Math.round(value * 100) / 100d;
+    }
+
     @Override
     public boolean equals(Object obj) {
         if (obj == null)
@@ -433,18 +439,28 @@ public boolean equals(Object obj) {
             return false;
 
         for (int i = 0; i < size(); i++) {
-            if (!NumHelper.equalsEps(getLatitude(i), other.getLatitude(i)))
+            if (!equalsEps(getLatitude(i), other.getLatitude(i)))
                 return false;
 
-            if (!NumHelper.equalsEps(getLongitude(i), other.getLongitude(i)))
+            if (!equalsEps(getLongitude(i), other.getLongitude(i)))
                 return false;
 
-            if (this.is3D() && !NumHelper.equalsEps(getElevation(i), other.getElevation(i)))
+            if (this.is3D() && !equalsEps(getElevation(i), other.getElevation(i)))
                 return false;
         }
         return true;
     }
 
+    private final static double DEFAULT_PRECISION = 1e-6;
+
+    public static boolean equalsEps(double d1, double d2) {
+        return equalsEps(d1, d2, DEFAULT_PRECISION);
+    }
+
+    public static boolean equalsEps(double d1, double d2, double epsilon) {
+        return Math.abs(d1 - d2) < epsilon;
+    }
+
     /**
      * Clones this PointList. If this PointList was immutable, the cloned will be mutable. If this PointList was a
      * ShallowImmutablePointList, the cloned PointList will be a regular PointList.
@@ -476,28 +492,34 @@ public PointList copy(int from, int end) {
         if (from < 0 || end > getSize())
             throw new IllegalArgumentException("Illegal interval: " + from + ", " + end + ", size:" + getSize());
 
-        PointList copyPL = new PointList(end - from, is3D());
-        if (is3D())
-            for (int i = from; i < end; i++) {
-                copyPL.add(getLatitude(i), getLongitude(i), getElevation(i));
-            }
-        else
-            for (int i = from; i < end; i++) {
-                copyPL.add(getLatitude(i), getLongitude(i), Double.NaN);
-            }
 
+        PointList thisPL = this;
+        if (this instanceof ShallowImmutablePointList) {
+            ShallowImmutablePointList spl = (ShallowImmutablePointList) this;
+            thisPL = spl.wrappedPointList;
+            from = spl.fromOffset + from;
+            end = spl.fromOffset + end;
+        }
+
+        int len = end - from;
+        PointList copyPL = new PointList(len, is3D());
+        copyPL.size = len;
+        copyPL.isImmutable = isImmutable();
+        System.arraycopy(thisPL.latitudes, from, copyPL.latitudes, 0, len);
+        System.arraycopy(thisPL.longitudes, from, copyPL.longitudes, 0, len);
+        if (is3D())
+            System.arraycopy(thisPL.elevations, from, copyPL.elevations, 0, len);
         return copyPL;
     }
 
     /**
      * Create a shallow copy of this Pointlist from from to end, excluding end.
-     * <p>
-     * The <code>ensureConsistency</code> parameter makes this PointList immutable, so the shallow copy will stay
-     * consistent with this object. If you don't ensure the consistency it might happen that due to changes of this
-     * object, the shallow copy might contain incorrect or corrupt data.
+     *
+     * @param makeImmutable makes this PointList immutable. If you don't ensure the consistency it might happen that due to changes of this
+     *                      object, the shallow copy might contain incorrect or corrupt data.
      */
-    public PointList shallowCopy(final int from, final int end, boolean ensureConsistency) {
-        if (ensureConsistency)
+    public PointList shallowCopy(final int from, final int end, boolean makeImmutable) {
+        if (makeImmutable)
             this.makeImmutable();
         return new ShallowImmutablePointList(from, end, this);
     }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/api/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
rename to api/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
diff --git a/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java b/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
similarity index 97%
rename from core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
rename to api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
index f729b49bb2..648f88c888 100644
--- a/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
+++ b/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.util;
 
-import java.util.List;
-
 /**
  * This is a shallow copy of a PointList. This class can be used to create a memory efficient copy of a PointList.
  * You have to be aware, that if the wrapped PointList changes, the shallow copy will change as well. This can lead to
@@ -30,9 +28,9 @@
 
     private final static String IMMUTABLE_ERR = "This class is immutable, you are not allowed to change it";
 
-    private final int fromOffset;
-    private final int toOffset;
-    private final PointList wrappedPointList;
+    final int fromOffset;
+    final int toOffset;
+    final PointList wrappedPointList;
 
     public ShallowImmutablePointList(int fromOffset, int toOffset, PointList wrappedPointList) {
         if (fromOffset > toOffset)
diff --git a/core/src/main/java/com/graphhopper/util/Translation.java b/api/src/main/java/com/graphhopper/util/Translation.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/Translation.java
rename to api/src/main/java/com/graphhopper/util/Translation.java
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/api/src/main/java/com/graphhopper/util/ViaInstruction.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/ViaInstruction.java
rename to api/src/main/java/com/graphhopper/util/ViaInstruction.java
diff --git a/core/src/main/java/com/graphhopper/util/details/PathDetail.java b/api/src/main/java/com/graphhopper/util/details/PathDetail.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/details/PathDetail.java
rename to api/src/main/java/com/graphhopper/util/details/PathDetail.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java b/api/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/ConnectionNotFoundException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java b/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java b/api/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/DetailedRuntimeException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/GHException.java b/api/src/main/java/com/graphhopper/util/exceptions/GHException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/GHException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/GHException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/PointDistanceExceededException.java b/api/src/main/java/com/graphhopper/util/exceptions/PointDistanceExceededException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/PointDistanceExceededException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/PointDistanceExceededException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java b/api/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/PointNotFoundException.java
diff --git a/core/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java b/api/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java
rename to api/src/main/java/com/graphhopper/util/exceptions/PointOutOfBoundsException.java
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
similarity index 98%
rename from core/src/main/java/com/graphhopper/util/shapes/BBox.java
rename to api/src/main/java/com/graphhopper/util/shapes/BBox.java
index 03b2709cad..ed716f56d1 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.util.shapes;
 
-import com.fasterxml.jackson.annotation.JsonCreator;
-import com.fasterxml.jackson.annotation.JsonValue;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
 
@@ -47,7 +45,6 @@
     public double minEle;
     public double maxEle;
 
-    @JsonCreator
     public BBox(double[] coords) {
         this(coords[0],coords[2],coords[1],coords[3]);
     }
@@ -259,7 +256,6 @@ public boolean isValid() {
      * @return array containing this bounding box. Attention: GeoJson is lon,lat! If 3D is gets even
      * worse: lon,lat,ele
      */
-    @JsonValue
     public List<Double> toGeoJson() {
         List<Double> list = new ArrayList<>(4);
         list.add(Helper.round6(minLon));
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/shapes/Circle.java
rename to api/src/main/java/com/graphhopper/util/shapes/Circle.java
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java b/api/src/main/java/com/graphhopper/util/shapes/GHPlace.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
rename to api/src/main/java/com/graphhopper/util/shapes/GHPlace.java
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
similarity index 85%
rename from core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
rename to api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 8533bddebb..37f85e1004 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -18,7 +18,7 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.NumHelper;
-import com.vividsolutions.jts.geom.Point;
+import org.locationtech.jts.geom.Point;
 
 /**
  * @author Peter Karich
@@ -47,9 +47,16 @@ public static GHPoint fromStringLonLat(String str) {
         return fromString(str, true);
     }
 
+    public static GHPoint fromJson(double[] xy) {
+        return new GHPoint(xy[1], xy[0]);
+    }
+
     private static GHPoint fromString(String str, boolean lonLatOrder) {
         String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2) {
+        if (fromStrs.length != 2)
+            throw new IllegalArgumentException("Cannot parse point '" + str + "'");
+
+        try {
             double fromLat = Double.parseDouble(fromStrs[0]);
             double fromLon = Double.parseDouble(fromStrs[1]);
             if (lonLatOrder) {
@@ -57,8 +64,8 @@ private static GHPoint fromString(String str, boolean lonLatOrder) {
             } else {
                 return new GHPoint(fromLat, fromLon);
             }
-        } else {
-            throw new IllegalArgumentException(str);
+        } catch (NumberFormatException ex) {
+            throw new IllegalArgumentException("Cannot parse point '" + str + "'");
         }
     }
 
@@ -87,8 +94,7 @@ public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
-        @SuppressWarnings("unchecked")
-        final GHPoint other = (GHPoint) obj;
+        @SuppressWarnings("unchecked") final GHPoint other = (GHPoint) obj;
         return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/api/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
rename to api/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
similarity index 99%
rename from core/src/main/java/com/graphhopper/util/shapes/Polygon.java
rename to api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index e3c8e256bb..52d94115e0 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -82,7 +82,7 @@ public Polygon(double[] lat, double[] lon) {
     /**
      * Lossy conversion to a GraphHopper Polygon.
      */
-    public static Polygon create(com.vividsolutions.jts.geom.Polygon polygon) {
+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {
         double[] lats = new double[polygon.getNumPoints()];
         double[] lons = new double[polygon.getNumPoints()];
         for (int i = 0; i < polygon.getNumPoints(); i++) {
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Shape.java b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
similarity index 100%
rename from core/src/main/java/com/graphhopper/util/shapes/Shape.java
rename to api/src/main/java/com/graphhopper/util/shapes/Shape.java
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/api/src/test/java/com/graphhopper/util/AngleCalcTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/AngleCalcTest.java
rename to api/src/test/java/com/graphhopper/util/AngleCalcTest.java
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/api/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
rename to api/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
diff --git a/core/src/test/java/com/graphhopper/util/FinishInstructionTest.java b/api/src/test/java/com/graphhopper/util/FinishInstructionTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/FinishInstructionTest.java
rename to api/src/test/java/com/graphhopper/util/FinishInstructionTest.java
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/api/src/test/java/com/graphhopper/util/GHRequestTest.java
similarity index 98%
rename from core/src/test/java/com/graphhopper/GHRequestTest.java
rename to api/src/test/java/com/graphhopper/util/GHRequestTest.java
index 60a5fd9049..882ac84091 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/api/src/test/java/com/graphhopper/util/GHRequestTest.java
@@ -15,8 +15,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper;
+package com.graphhopper.util;
 
+import com.graphhopper.GHRequest;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
diff --git a/core/src/test/java/com/graphhopper/GHResponseTest.java b/api/src/test/java/com/graphhopper/util/GHResponseTest.java
similarity index 86%
rename from core/src/test/java/com/graphhopper/GHResponseTest.java
rename to api/src/test/java/com/graphhopper/util/GHResponseTest.java
index c0fe4ef3ae..b9b19108d8 100644
--- a/core/src/test/java/com/graphhopper/GHResponseTest.java
+++ b/api/src/test/java/com/graphhopper/util/GHResponseTest.java
@@ -15,8 +15,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper;
+package com.graphhopper.util;
 
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+import org.junit.Assert;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -25,7 +28,7 @@
 public class GHResponseTest {
     @Test
     public void testToString() throws Exception {
-        assertEquals("no paths", new GHResponse().toString());
+        Assert.assertEquals("no paths", new GHResponse().toString());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/api/src/test/java/com/graphhopper/util/HelperTest.java
similarity index 76%
rename from core/src/test/java/com/graphhopper/util/HelperTest.java
rename to api/src/test/java/com/graphhopper/util/HelperTest.java
index fbf08d37a4..833427f738 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/api/src/test/java/com/graphhopper/util/HelperTest.java
@@ -17,16 +17,9 @@
  */
 package com.graphhopper.util;
 
-import org.junit.After;
-import org.junit.Before;
 import org.junit.Test;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.HashMap;
 import java.util.Locale;
-import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -35,15 +28,6 @@
  * @author Peter Karich
  */
 public class HelperTest {
-    @Before
-    public void setUp() {
-        Helper.removeDir(new File("test"));
-    }
-
-    @After
-    public void tearDown() {
-        Helper.removeDir(new File("test"));
-    }
 
     @Test
     public void testCountBitValue() throws Exception {
@@ -56,17 +40,6 @@ public void testCountBitValue() throws Exception {
         assertEquals(5, Helper.countBitValue(20));
     }
 
-    @Test
-    public void testUnzip() throws Exception {
-        String to = "./target/tmp/test";
-        Helper.removeDir(new File(to));
-        new Unzipper().unzip("./src/test/resources/com/graphhopper/util/test.zip", to, false);
-        assertTrue(new File("./target/tmp/test/file2 bh").exists());
-        assertTrue(new File("./target/tmp/test/folder1").isDirectory());
-        assertTrue(new File("./target/tmp/test/folder1/folder 3").isDirectory());
-        Helper.removeDir(new File(to));
-    }
-
     @Test
     public void testGetLocale() throws Exception {
         assertEquals(Locale.GERMAN, Helper.getLocale("de"));
@@ -91,14 +64,6 @@ public void testKeepIn() {
         assertEquals(3, Helper.keepIn(-2, 3, 4), 1e-2);
     }
 
-    @Test
-    public void testLoadProperties() throws IOException {
-        Map<String, String> map = new HashMap<>();
-        Helper.loadProperties(map, new StringReader("blup=test\n blup2 = xy"));
-        assertEquals("test", map.get("blup"));
-        assertEquals("xy", map.get("blup2"));
-    }
-
     @Test
     public void testUnsignedConversions() {
         long l = Helper.toUnsignedLong(-1);
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/api/src/test/java/com/graphhopper/util/InstructionTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/InstructionTest.java
rename to api/src/test/java/com/graphhopper/util/InstructionTest.java
diff --git a/core/src/test/java/com/graphhopper/util/PMapTest.java b/api/src/test/java/com/graphhopper/util/PMapTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/PMapTest.java
rename to api/src/test/java/com/graphhopper/util/PMapTest.java
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/api/src/test/java/com/graphhopper/util/PointListTest.java
similarity index 96%
rename from core/src/test/java/com/graphhopper/util/PointListTest.java
rename to api/src/test/java/com/graphhopper/util/PointListTest.java
index 4df09a0a4b..3991cda12a 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/api/src/test/java/com/graphhopper/util/PointListTest.java
@@ -237,7 +237,11 @@ public void testToGeoJson() {
 
         assertEquals(3, pl.toLineString(true).getNumPoints());
         assertEquals(2, pl.shallowCopy(1, 3, false).toLineString(true).getNumPoints());
-    }
 
+        assertEquals(0, PointList.EMPTY.toLineString(false).getNumPoints());
 
+        PointList oneLength = new PointList(3, true);
+        oneLength.add(0, 0, 0);
+        assertEquals(2, oneLength.toLineString(false).getNumPoints());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
rename to api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
rename to api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/api/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
rename to api/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/api/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
rename to api/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
diff --git a/core/src/test/java/com/graphhopper/util/shapes/PolygonTest.java b/api/src/test/java/com/graphhopper/util/shapes/PolygonTest.java
similarity index 100%
rename from core/src/test/java/com/graphhopper/util/shapes/PolygonTest.java
rename to api/src/test/java/com/graphhopper/util/shapes/PolygonTest.java
diff --git a/appveyor.yml b/appveyor.yml
index a55cd20df4..0348495fdc 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -24,7 +24,7 @@ install:
 build_script:
   - mvn clean install -DskipTests=true -B
 test_script:
-  - mvn test verify -B && mvn checkstyle:check findbugs:check forbiddenapis:check -B
+  - mvn test verify -B && mvn checkstyle:check spotbugs:check forbiddenapis:check -B
 cache:
   - C:\maven\
   - C:\Users\appveyor\.m2
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index 2817017b23..f0dc1a8816 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -23,50 +23,21 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>directions-api-client-hc</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Directions API hand-crafted Java Client.</name>
      
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>  
     
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
+            <artifactId>graphhopper-web-api</artifactId>
             <version>${project.parent.version}</version>
-            <exclusions>
-                <!-- We cannot yet exclude this as e.g. Helper class uses trove classes
-                     and Helper is used e.g. in PointList
-                <exclusion>
-                    <groupId>net.sf.trove4j</groupId>
-                    <artifactId>trove4j</artifactId>
-                </exclusion>
-                -->
-                <exclusion>
-                    <groupId>org.apache.xmlgraphics</groupId>
-                    <artifactId>xmlgraphics-commons</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-
-        <dependency>
-            <groupId>com.fasterxml.jackson.core</groupId>
-            <artifactId>jackson-databind</artifactId>
-            <version>${jackson.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>javax.xml.ws</groupId>
-            <artifactId>jaxws-api</artifactId>
-            <version>2.3.0</version>
-        </dependency>
-        <dependency>
-            <groupId>javax.activation</groupId>
-            <artifactId>activation</artifactId>
-            <version>1.1.1</version>
         </dependency>
         <dependency>
             <groupId>com.squareup.okhttp3</groupId>
@@ -103,7 +74,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.3</version>
                 <configuration>
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
@@ -112,19 +82,6 @@
                 </configuration>
             </plugin>
             
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.19.1</version>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>integration-test</goal>
-                            <goal>verify</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
         </plugins>        
     </build>
         
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
index e12881b346..469e460722 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
@@ -15,6 +15,8 @@
 
     private List<GHPoint> fromPoints;
     private List<GHPoint> toPoints;
+    private List<String> fromPointHints;
+    private List<String> toPointHints;
     boolean identicalLists = true;
     private final Set<String> outArrays = new HashSet<>(5);
 
@@ -26,6 +28,8 @@ public GHMRequest(int size) {
         super(0);
         fromPoints = new ArrayList<>(size);
         toPoints = new ArrayList<>(size);
+        fromPointHints = new ArrayList<>(size);
+        toPointHints = new ArrayList<>(size);
     }
 
     /**
@@ -51,7 +55,7 @@ public GHMRequest addAllPoints(List<GHPoint> points) {
 
     @Override
     public List<GHPoint> getPoints() {
-        throw new IllegalStateException("use getFromPlaces or getToPlaces");
+        throw new IllegalStateException("use getFromPoints or getToPoints");
     }
 
     public List<GHPoint> getFromPoints() {
@@ -63,7 +67,7 @@ public GHMRequest addAllPoints(List<GHPoint> points) {
     }
 
     /**
-     * This methods adds the places as 'from' and 'to' place to the request.
+     * This methods adds the coordinate as 'from' and 'to' to the request.
      */
     @Override
     public GHMRequest addPoint(GHPoint point) {
@@ -78,21 +82,68 @@ public GHMRequest addFromPoint(GHPoint point) {
         return this;
     }
 
-    public GHMRequest addFromPoints(List<GHPoint> points) {
+    public GHMRequest setFromPoints(List<GHPoint> points) {
         fromPoints = points;
         identicalLists = false;
         return this;
     }
 
+    public GHRequest addFromPointHint(String pointHint) {
+        this.fromPointHints.add(pointHint);
+        return this;
+    }
+
+    public GHRequest setFromPointHints(List<String> pointHints) {
+        this.fromPointHints = pointHints;
+        return this;
+    }
+
+    public List<String> getFromPointHints() {
+        return fromPointHints;
+    }
+
     public GHMRequest addToPoint(GHPoint point) {
         toPoints.add(point);
         identicalLists = false;
         return this;
     }
 
-    public GHMRequest addToPoints(List<GHPoint> points) {
+    public GHMRequest setToPoints(List<GHPoint> points) {
         toPoints = points;
         identicalLists = false;
         return this;
     }
+
+    public GHRequest addToPointHint(String pointHint) {
+        this.toPointHints.add(pointHint);
+        return this;
+    }
+
+    public GHRequest setToPointHints(List<String> pointHints) {
+        this.toPointHints = pointHints;
+        return this;
+    }
+
+    public List<String> getToPointHints() {
+        return toPointHints;
+    }
+
+    @Override
+    public GHRequest setPointHints(List<String> pointHints) {
+        super.setPointHints(pointHints);
+        this.fromPointHints = pointHints;
+        this.toPointHints = pointHints;
+        return this;
+    }
+
+    @Override
+    public List<String> getPointHints() {
+        throw new IllegalStateException("Use getFromPointHints or getToPointHints");
+    }
+
+    @Override
+    public boolean hasPointHints() {
+        return this.fromPointHints.size() == this.fromPoints.size() && !fromPoints.isEmpty() &&
+                this.toPointHints.size() == this.toPoints.size() && !toPoints.isEmpty();
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java b/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java
deleted file mode 100644
index b60c21a2c2..0000000000
--- a/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.graphhopper.api;
-
-import com.graphhopper.GHResponse;
-
-/**
- * @author Peter Karich
- */
-public class GHMResponse extends GHResponse {
-
-    private final int fromIndex;
-    private final int toIndex;
-    private final boolean identicalStartAndEnd;
-
-    public GHMResponse(int fromIndex, int toIndex, boolean identicalStartAndEnd) {
-        this.fromIndex = fromIndex;
-        this.toIndex = toIndex;
-        this.identicalStartAndEnd = identicalStartAndEnd;
-    }
-
-    public boolean isIdenticalStartAndEnd() {
-        return identicalStartAndEnd;
-    }
-
-    public int getFromIndex() {
-        return fromIndex;
-    }
-
-    public int getToIndex() {
-        return toIndex;
-    }
-}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index 070a32eac2..e88385a674 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -61,18 +61,24 @@ public OkHttpClient getDownloader() {
 
     protected String getJson(String url) throws IOException {
         Request okRequest = new Request.Builder().url(url).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected String postJson(String url, JsonNode data) throws IOException {
         Request okRequest = new Request.Builder().url(url).post(RequestBody.create(MT_JSON, data.toString())).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected JsonNode toJSON(String url, String str) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 9a39b7cc31..43a219b736 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -55,22 +55,30 @@ public GHMatrixBatchRequester setSleepAfterGET(long sleepAfterGETMillis) {
     @Override
     public MatrixResponse route(GHMRequest ghRequest) {
         ObjectNode requestJson = factory.objectNode();
-        ArrayNode fromPointList = createPointList(ghRequest.getFromPoints());
-        ArrayNode toPointList = createPointList(ghRequest.getToPoints());
 
         List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
         if (outArraysList.isEmpty()) {
             outArraysList.add("weights");
         }
 
-        ArrayNode outArrayListJson = factory.arrayNode(outArraysList.size());
+        ArrayNode outArrayListJson = factory.arrayNode();
         for (String str : outArraysList) {
             outArrayListJson.add(str);
         }
 
         boolean hasElevation = false;
-        requestJson.putArray("from_points").addAll(fromPointList);
-        requestJson.putArray("to_points").addAll(toPointList);
+        if (ghRequest.identicalLists) {
+            requestJson.putArray("points").addAll(createPointList(ghRequest.getFromPoints()));
+            requestJson.putArray("point_hints").addAll(createStringList(ghRequest.getFromPointHints()));
+        } else {
+            ArrayNode fromPointList = createPointList(ghRequest.getFromPoints());
+            ArrayNode toPointList = createPointList(ghRequest.getToPoints());
+            requestJson.putArray("from_points").addAll(fromPointList);
+            requestJson.putArray("from_point_hints").addAll(createStringList(ghRequest.getFromPointHints()));
+            requestJson.putArray("to_points").addAll(toPointList);
+            requestJson.putArray("to_point_hints").addAll(createStringList(ghRequest.getToPointHints()));
+        }
+
         requestJson.putArray("out_arrays").addAll(outArrayListJson);
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
@@ -102,7 +110,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
 
             JsonNode responseJson = toJSON(postUrl, postResponseStr);
             if (responseJson.has("message")) {
-                matrixResponse.addError(new RuntimeException(responseJson.get("message").asText()));
+                matrixResponse.addErrors(readErrors(responseJson));
                 return matrixResponse;
             }
             if (!responseJson.has("job_id")) {
@@ -167,10 +175,18 @@ public MatrixResponse route(GHMRequest ghRequest) {
         return matrixResponse;
     }
 
+    private final ArrayNode createStringList(List<String> list) {
+        ArrayNode outList = factory.arrayNode();
+        for (String str : list) {
+            outList.add(str);
+        }
+        return outList;
+    }
+
     protected final ArrayNode createPointList(List<GHPoint> list) {
-        ArrayNode outList = factory.arrayNode(list.size()); // new ArrayList<>(list.size())
+        ArrayNode outList = factory.arrayNode();
         for (GHPoint p : list) {
-            ArrayNode entry = factory.arrayNode(2);
+            ArrayNode entry = factory.arrayNode();
             entry.add(p.lon);
             entry.add(p.lat);
             outList.add(entry);
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index f535934f84..1761f05c59 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -36,18 +36,39 @@ private void initIgnore() {
         ignoreSet.add("vehicle");
         ignoreSet.add("point");
         ignoreSet.add("from_point");
+        ignoreSet.add("from_point_hint");
         ignoreSet.add("to_point");
+        ignoreSet.add("to_point_hint");
         ignoreSet.add("add_array");
     }
 
     @Override
     public MatrixResponse route(GHMRequest ghRequest) {
+        StringBuilder pointHintsStr = new StringBuilder();
+
         String pointsStr;
         if (ghRequest.identicalLists) {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "point");
+
+            for (String hint : ghRequest.getFromPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("point_hint=").append(encode(hint));
+            }
         } else {
             pointsStr = createPointQuery(ghRequest.getFromPoints(), "from_point");
             pointsStr += "&" + createPointQuery(ghRequest.getToPoints(), "to_point");
+
+            for (String hint : ghRequest.getFromPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("from_point_hint=").append(encode(hint));
+            }
+            for (String hint : ghRequest.getToPointHints()) {
+                if (pointHintsStr.length() > 0)
+                    pointHintsStr.append("&");
+                pointHintsStr.append("to_point_hint=").append(encode(hint));
+            }
         }
 
         String outArrayStr = "";
@@ -65,7 +86,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
         }
 
         String url = buildURL("", ghRequest);
-        url += "&" + pointsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
+        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
 
         boolean withTimes = outArraysList.contains("times");
         boolean withDistances = outArraysList.contains("distances");
@@ -94,14 +115,13 @@ public MatrixResponse route(GHMRequest ghRequest) {
     }
 
     private String createPointQuery(List<GHPoint> list, String pointName) {
-        String pointsStr = "";
+        StringBuilder pointsStr = new StringBuilder();
         for (GHPoint p : list) {
-            if (!pointsStr.isEmpty()) {
-                pointsStr += "&";
-            }
+            if (pointsStr.length() > 0)
+                pointsStr.append("&");
 
-            pointsStr += pointName + "=" + encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon));
+            pointsStr.append(pointName).append('=').append(encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon)));
         }
-        return pointsStr;
+        return pointsStr.toString();
     }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
index 59a9684da6..9291593b89 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
@@ -13,11 +13,6 @@
  */
 public class GoogleMatrixSyncRequester extends GHMatrixAbstractRequester {
 
-    public GoogleMatrixSyncRequester() {
-        super();
-        initIgnore();
-    }
-
     public GoogleMatrixSyncRequester(String serviceUrl) {
         super(serviceUrl);
         initIgnore();
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
index c351156485..e0d27a3e7a 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperGeocoding.java
@@ -20,6 +20,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.api.model.GHGeocodingRequest;
 import com.graphhopper.api.model.GHGeocodingResponse;
+import com.graphhopper.http.WebHelper;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index f1bab6ba5e..485da03c52 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -24,6 +24,8 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.jackson.Jackson;
 import com.graphhopper.util.*;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.*;
@@ -31,13 +33,12 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 
-import static com.graphhopper.util.Helper.*;
+import static com.graphhopper.util.Helper.round6;
+import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
  * Main wrapper of the GraphHopper Directions API for a simple and efficient
@@ -54,7 +55,6 @@
     private boolean instructions = true;
     private boolean calcPoints = true;
     private boolean elevation = false;
-    private boolean turnDescription = true;
     private String optimize = "false";
     private final Set<String> ignoreSet;
 
@@ -91,7 +91,7 @@ public GraphHopperWeb(String serviceUrl) {
         ignoreSet.add("points_encoded");
         ignoreSet.add("pointsencoded");
         ignoreSet.add("type");
-        objectMapper = new ObjectMapper();
+        objectMapper = Jackson.newObjectMapper();
     }
 
     public GraphHopperWeb setDownloader(OkHttpClient downloader) {
@@ -103,10 +103,7 @@ public OkHttpClient getDownloader() {
         return downloader;
     }
 
-    PathWrapper createPathWrapper(JsonNode path,
-                                  boolean tmpCalcPoints, boolean tmpInstructions,
-                                  boolean tmpElevation, boolean turnDescription,
-                                  boolean tmpCalcDetails) {
+    PathWrapper createPathWrapper(JsonNode path, boolean tmpElevation, boolean turnDescription) {
         PathWrapper pathWrapper = new PathWrapper();
         pathWrapper.addErrors(readErrors(path));
         if (pathWrapper.hasErrors())
@@ -131,7 +128,7 @@ PathWrapper createPathWrapper(JsonNode path,
             JsonNode descriptionNode = path.get("description");
             if (descriptionNode.isArray()) {
                 List<String> description = new ArrayList<>(descriptionNode.size());
-                for (JsonNode descNode: descriptionNode) {
+                for (JsonNode descNode : descriptionNode) {
                     description.add(descNode.asText());
                 }
                 pathWrapper.setDescription(description);
@@ -140,12 +137,12 @@ PathWrapper createPathWrapper(JsonNode path,
             }
         }
 
-        if (tmpCalcPoints) {
+        if (path.has("points")) {
             String pointStr = path.get("points").asText();
             PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
             pathWrapper.setPoints(pointList);
 
-            if (tmpInstructions) {
+            if (path.has("instructions")) {
                 JsonNode instrArr = path.get("instructions");
 
                 InstructionList il = new InstructionList(null);
@@ -218,40 +215,15 @@ PathWrapper createPathWrapper(JsonNode path,
                 pathWrapper.setInstructions(il);
             }
 
-            if (tmpCalcDetails) {
+            if (path.has("details")) {
                 JsonNode details = path.get("details");
                 Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
                 Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
                 while (detailIterator.hasNext()) {
                     Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
                     List<PathDetail> pathDetailList = new ArrayList<>();
-
-                    // TODO duplicate deserialization code for PathDetail, @see GraphHopperServletModule.PathDetailDeserializer
-                    // see issue #1137
                     for (JsonNode pathDetail : detailEntry.getValue()) {
-                        if (pathDetail.size() != 3)
-                            throw new IllegalStateException("PathDetail must have exactly 3 entries but was " + pathDetail.size());
-
-                        JsonNode from = pathDetail.get(0);
-                        JsonNode to = pathDetail.get(1);
-                        JsonNode val = pathDetail.get(2);
-
-                        PathDetail pd;
-                        if (val.isBoolean())
-                            pd = new PathDetail(val.asBoolean());
-                        else if (val.isLong())
-                            pd = new PathDetail(val.asLong());
-                        else if (val.isInt())
-                            pd = new PathDetail(val.asInt());
-                        else if (val.isDouble())
-                            pd = new PathDetail(val.asDouble());
-                        else if (val.isTextual())
-                            pd = new PathDetail(val.asText());
-                        else
-                            throw new IllegalStateException("Unsupported type of PathDetail value for key " + detailEntry.getKey() + " and value " + val.toString() + "of class " + val.getClass());
-
-                        pd.setFirst(from.asInt());
-                        pd.setLast(to.asInt());
+                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
                         pathDetailList.add(pd);
                     }
                     pathDetails.put(detailEntry.getKey(), pathDetailList);
@@ -379,11 +351,11 @@ public GraphHopperWeb setOptimize(String optimize) {
 
     @Override
     public GHResponse route(GHRequest request) {
+        ResponseBody rspBody = null;
         try {
             Request okRequest = createRequest(request);
-            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
             JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
-            rspBody.close();
 
             GHResponse res = new GHResponse();
             res.addErrors(readErrors(json));
@@ -392,13 +364,11 @@ public GHResponse route(GHRequest request) {
 
             JsonNode paths = json.get("paths");
 
-            boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
-            boolean tmpCalcPoints = request.getHints().getBool("calc_points", calcPoints);
             boolean tmpElevation = request.getHints().getBool("elevation", elevation);
-            boolean tmpTurnDescription = request.getHints().getBool("turn_description", turnDescription);
+            boolean tmpTurnDescription = request.getHints().getBool("turn_description", true);
 
             for (JsonNode path : paths) {
-                PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation, tmpTurnDescription, !request.getPathDetails().isEmpty());
+                PathWrapper altRsp = createPathWrapper(path, tmpElevation, tmpTurnDescription);
                 res.add(altRsp);
             }
 
@@ -406,6 +376,8 @@ public GHResponse route(GHRequest request) {
 
         } catch (Exception ex) {
             throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        } finally {
+            Helper.close(rspBody);
         }
     }
 
@@ -461,6 +433,10 @@ private Request createRequest(GHRequest request) {
             url += "&" + Parameters.DETAILS.PATH_DETAILS + "=" + details;
         }
 
+        for (String hint : request.getPointHints()) {
+            url += "&point_hint=" + WebHelper.encodeURL(hint);
+        }
+
         if (!key.isEmpty()) {
             url += "&key=" + WebHelper.encodeURL(key);
         }
diff --git a/client-hc/src/main/java/com/graphhopper/api/WebHelper.java b/client-hc/src/main/java/com/graphhopper/api/WebHelper.java
deleted file mode 100644
index a7df96be34..0000000000
--- a/client-hc/src/main/java/com/graphhopper/api/WebHelper.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.api;
-
-import com.graphhopper.util.PointList;
-
-import java.net.URLEncoder;
-
-/**
- * Code which handles polyline encoding and other web stuff.
- * <p>
- *
- * @author Peter Karich
- */
-public class WebHelper {
-
-    public static String encodeURL(String str) {
-        try {
-            return URLEncoder.encode(str, "UTF-8");
-        } catch (Exception _ignore) {
-            return str;
-        }
-    }
-
-    public static PointList decodePolyline(String encoded, int initCap, boolean is3D) {
-        PointList poly = new PointList(initCap, is3D);
-        int index = 0;
-        int len = encoded.length();
-        int lat = 0, lng = 0, ele = 0;
-        while (index < len) {
-            // latitude
-            int b, shift = 0, result = 0;
-            do {
-                b = encoded.charAt(index++) - 63;
-                result |= (b & 0x1f) << shift;
-                shift += 5;
-            } while (b >= 0x20);
-            int deltaLatitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
-            lat += deltaLatitude;
-
-            // longitute
-            shift = 0;
-            result = 0;
-            do {
-                b = encoded.charAt(index++) - 63;
-                result |= (b & 0x1f) << shift;
-                shift += 5;
-            } while (b >= 0x20);
-            int deltaLongitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
-            lng += deltaLongitude;
-
-            if (is3D) {
-                // elevation
-                shift = 0;
-                result = 0;
-                do {
-                    b = encoded.charAt(index++) - 63;
-                    result |= (b & 0x1f) << shift;
-                    shift += 5;
-                } while (b >= 0x20);
-                int deltaElevation = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
-                ele += deltaElevation;
-                poly.add((double) lat / 1e5, (double) lng / 1e5, (double) ele / 100);
-            } else {
-                poly.add((double) lat / 1e5, (double) lng / 1e5);
-            }
-        }
-        return poly;
-    }
-}
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 8d175d5090..3f8de6f3ea 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -6,6 +6,7 @@
 
 import java.util.Arrays;
 
+import static com.graphhopper.api.GraphHopperMatrixWeb.SERVICE_URL;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -56,7 +57,7 @@ public void testBikeMatrix() {
         req.addOutArray("times");
 
         MatrixResponse res = ghMatrix.route(req);
-        assertEquals(2450, res.getTime(1, 2) / 1000, 110);
+        assertEquals(2200, res.getTime(1, 2) / 1000, 200);
     }
 
     @Test
@@ -65,10 +66,42 @@ public void testNxM_issue45() {
         ghmRequest.addOutArray("distances");
         ghmRequest.addOutArray("times");
         ghmRequest.setVehicle("car");
-        ghmRequest.addFromPoints(Arrays.asList(new GHPoint(52.557151, 13.515244)))
-                .addToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
+        ghmRequest.setFromPoints(Arrays.asList(new GHPoint(52.557151, 13.515244)))
+                .setToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
 
         MatrixResponse res = ghMatrix.route(ghmRequest);
         assertEquals(2437, res.getTime(0, 1) / 1000, 30);
     }
+
+    @Test
+    public void testPOSTMatrixQueryWithPointHints() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        req.addOutArray("distances");
+        MatrixResponse res = ghMatrix.route(req);
+        assertEquals(4833, res.getDistance(1, 2), 30);
+        assertEquals(5162, res.getDistance(2, 1), 30);
+
+        req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        req.addOutArray("distances");
+        req.setPointHints(Arrays.asList("", "", "ifflandstr"));
+        res = ghMatrix.route(req);
+        assertEquals(4953, res.getDistance(1, 2), 30);
+        assertEquals(4927, res.getDistance(2, 1), 30);
+
+        req = new GHMRequest();
+        req.addPoint(new GHPoint(52.517004, 13.389416));
+        req.addPoint(new GHPoint(52.485707, 13.435249));
+        req.addPoint(new GHPoint(52.516848, 13.424606));
+        // wrong count
+        req.setPointHints(Arrays.asList("", "ifflandstr"));
+        res = ghMatrix.route(req);
+        assertTrue(res.hasErrors());
+        assertEquals("Array length of point_hints must match length of points (or from/to equivalent)", res.getErrors().get(0).getMessage());
+    }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
index 1a9dc33afd..f613318a24 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
@@ -47,7 +47,7 @@ public void testExtent() {
     @Test
     public void testForwardGeocodingNominatim() {
         GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "nominatim", 5000));
-        assertEquals(5, response.getHits().size());
+        assertEquals(4, response.getHits().size());
         assertTrue(response.getHits().get(0).getName().contains("Berlin"));
     }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
index f205cd9d51..0b664d271a 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
@@ -32,4 +32,9 @@ public void testMatrix() {
         assertEquals(11000, res.getDistance(1, 2), 2000);
         assertEquals(2500, res.getTime(1, 2) / 1000, 1000);
     }
+
+    @Test
+    public void testPOSTMatrixQueryWithPointHints() {
+        // for now ignore
+    }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 9ab276be71..82a9261c05 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -34,9 +34,8 @@
 
     @Before
     public void setUp() {
-        String key = System.getProperty("graphhopper.key", KEY);
-        gh.setKey(key);
-        ghMatrix.setKey(key);
+        gh.setKey(KEY);
+        ghMatrix.setKey(KEY);
     }
 
     @Test
@@ -57,7 +56,6 @@ public void testSimpleRoute() {
         isBetween(180, 200, alt.getDescend());
         isBetween(1000, 1500, alt.getRouteWeight());
 
-
         // change vehicle
         res = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180).
                 setVehicle("bike"));
@@ -169,7 +167,6 @@ public void testCannotFindPointException() {
         assertTrue(res.getErrors().get(0) instanceof PointNotFoundException);
     }
 
-
     @Test
     public void testOutOfBoundsException() {
         GHRequest req = new GHRequest().
@@ -247,7 +244,7 @@ public void testCreateGPXFromInstructionList() {
         req.getHints().put("instructions", true);
         req.getHints().put("calc_points", true);
         GHResponse ghResponse = gh.route(req);
-        String gpx = ghResponse.getBest().getInstructions().createGPX();
+        String gpx = ghResponse.getBest().getInstructions().createGPX("wurst");
         assertTrue(gpx.contains("<gpx"));
         assertTrue(gpx.contains("<rtept lat="));
         assertTrue(gpx.contains("<trk><name>"));
@@ -311,7 +308,7 @@ public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
         // Modified the sign though
         JsonNode json = new ObjectMapper().readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
-        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true, true, true, false);
+        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true);
 
         assertEquals(741, wrapper.getInstructions().get(0).getSign());
         assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
@@ -332,4 +329,15 @@ public void testPathDetails() {
         assertTrue((Double) details.get(0).getValue() > 20);
         assertTrue((Double) details.get(0).getValue() < 70);
     }
+
+    @Test
+    public void testPointHints() {
+        GHRequest ghRequest = new GHRequest();
+        ghRequest.addPoint(new GHPoint(52.50977, 13.371971));
+        ghRequest.addPoint(new GHPoint(52.509842, 13.369761));
+
+        ghRequest.setPointHints(Arrays.asList("Ben-Gurion", ""));
+        GHResponse response = gh.route(ghRequest);
+        assertTrue(response.getBest().getDistance() + "m", response.getBest().getDistance() < 500);
+    }
 }
diff --git a/config-example.yml b/config-example.yml
index 67841f998f..ebebcccd84 100644
--- a/config-example.yml
+++ b/config-example.yml
@@ -91,15 +91,6 @@ graphhopper:
   routing.non_ch.max_waypoint_distance: 1000000
 
 
-
-  ##### Web #####
-
-
-  # if you want to support jsonp response type you need to add it explicitly here. By default it is disabled for stronger security.
-  # web.jsonp_allowed: true
-
-
-
   ##### Storage #####
 
 
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 9f1c60c386..8949589013 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,7 +1,12 @@
+0.12
+    moved shp-reader into separate repository: https://github.com/graphhopper/graphhopper-reader-shp    
+    
 0.11
     web resources for dropwizard web framework (no servlets anymore)
     prefix -Dgraphhopper. for command line arguments necessary, see docs/web/quickstart.md or docs/core/quickstart-from-source.md#running--debbuging-with-intellij for details
     delegated reading properties to dropwizard, i.e. the new format yml is not read again in GraphHopper.init
+    changed file format for landmarks #1376
+
 0.9
     remove war bundling support #297
     rename of DefaultModule to GraphHopperModule and GHServletModule to GraphHopperServletModule
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
index ff9d1f7c7c..0a88726ecb 100644
--- a/core/files/docker-compose.yml
+++ b/core/files/docker-compose.yml
@@ -6,8 +6,7 @@ services:
         volumes:
             - ../../data:/data
         environment:
-            JETTY_PORT: 11111
-            JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+            JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=11111"
         ports:
             - "11111:11111"
         command: /data/europe_germany_berlin.pbf
diff --git a/core/files/findbugs-exclude.xml b/core/files/spotbugs-exclude.xml
similarity index 87%
rename from core/files/findbugs-exclude.xml
rename to core/files/spotbugs-exclude.xml
index 7c021c200f..aaea34ce60 100644
--- a/core/files/findbugs-exclude.xml
+++ b/core/files/spotbugs-exclude.xml
@@ -2,4 +2,5 @@
 <FindBugsFilter>
     <!-- documentation about findbug's rule match clauses can be found here:
          http://findbugs.sourceforge.net/manual/filter.html -->
+         
 </FindBugsFilter>
\ No newline at end of file
diff --git a/core/pom.xml b/core/pom.xml
index 991336863f..c4b2c1f694 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-core</artifactId>
     <name>GraphHopper Core</name>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>jar</packaging>
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
 
     <properties>
@@ -36,10 +36,15 @@
         </license>
     </licenses>
     <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>com.carrotsearch</groupId>
             <artifactId>hppc</artifactId>
-            <version>0.7.2</version>
+            <version>0.8.1</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -51,7 +56,7 @@
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
-            <version>2.1</version>
+            <version>2.3</version>
             <exclusions>
                 <exclusion>
                     <groupId>commons-logging</groupId>
@@ -60,25 +65,6 @@
             </exclusions>
         </dependency>
 
-        <dependency>
-            <groupId>com.fasterxml.jackson.core</groupId>
-            <artifactId>jackson-annotations</artifactId>
-            <version>${jackson.version}</version>
-        </dependency>
-        
-        <dependency>
-            <groupId>com.vividsolutions</groupId>
-            <artifactId>jts-core</artifactId>
-            <version>1.14.0</version>
-        </dependency>
-
-        <dependency>
-            <groupId>com.fasterxml.jackson.core</groupId>
-            <artifactId>jackson-databind</artifactId>
-            <version>${jackson.version}</version>
-            <scope>test</scope>
-        </dependency>
-
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
@@ -97,28 +83,22 @@
             <version>4.12</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-web-api</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 
     <build>
         <pluginManagement>
             <plugins>
-                <plugin>
-                    <groupId>org.apache.maven.plugins</groupId>
-                    <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.6</version>
-                    <configuration>
-                        <!-- for usage on android -->
-                        <descriptors>
-                            <descriptor>src/main/assembly/android.xml</descriptor>
-                        </descriptors>
-                    </configuration>
-                </plugin>
-
                 <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>3.0.2</version>
+                    <version>3.1.0</version>
                     <executions>
                         <execution>
                             <goals>
diff --git a/core/src/main/assembly/android.xml b/core/src/main/assembly/android.xml
deleted file mode 100644
index 1e663f25c3..0000000000
--- a/core/src/main/assembly/android.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
-    <id>android</id>
-    <formats>
-        <format>jar</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <dependencySets>
-        <dependencySet>            
-            <outputDirectory>/</outputDirectory>
-            <useProjectArtifact>true</useProjectArtifact>
-            <unpack>true</unpack>
-            <scope>runtime</scope>
-            <excludes>
-                <exclude>org.apache.xmlgraphics:xmlgraphics-commons</exclude>
-            </excludes>
-        </dependencySet>
-    </dependencySets>
-</assembly>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 5f1259d258..3ed6365439 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -514,9 +514,8 @@ public FlagEncoderFactory getFlagEncoderFactory() {
     }
 
     /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
-     * args) ala CmdArgs.read(args) or via configuration file ala
-     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+     * Reads the configuration from a CmdArgs object which can be manually filled, or via 
+     * CmdArgs.read(String[] args)
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
@@ -932,7 +931,7 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
             GraphEdgeIdFinder.BlockArea blockArea = new GraphEdgeIdFinder(graph, locationIndex).
-                    parseBlockArea(blockAreaStr, new DefaultEdgeFilter(encoder), hintsMap.getDouble("block_area.edge_id_max_area", 1000 * 1000));
+                    parseBlockArea(blockAreaStr, DefaultEdgeFilter.allEdges(encoder), hintsMap.getDouble("block_area.edge_id_max_area", 1000 * 1000));
             return new BlockAreaWeighting(weighting, blockArea);
         }
 
@@ -977,8 +976,7 @@ public GHResponse route(GHRequest request) {
         readLock.lock();
         try {
             if (!encodingManager.supports(vehicle))
-                throw new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                        + "Supported are: " + getEncodingManager());
+                throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
 
             HintsMap hints = request.getHints();
             String tModeStr = hints.get("traversal_mode", traversalMode.toString());
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index fbc5fe19bf..dda4d93f6a 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -19,11 +19,12 @@
 
 import com.graphhopper.util.BitUtil;
 
+import java.util.Comparator;
 import java.util.TreeMap;
 
 /**
- * A priority queue implemented by a TreeMap. As the tree map does not allow duplicated we compose
- * the key via priority | nodeId.
+ * A priority queue for integer-float key-value pairs implemented by a TreeMap. As the tree map does not allow multiple
+ * values for the same key we store the value inside the key which is composed as value | key.
  * <p>
  *
  * @author Peter Karich
@@ -34,39 +35,60 @@
     private final TreeMap<Long, Integer> map;
 
     public GHTreeMapComposed() {
-        map = new TreeMap<>();
+        map = new TreeMap<>(new Comparator<Long>() {
+            //  we cannot just use the long sorting because the values are floats
+            @Override
+            public int compare(Long o1, Long o2) {
+                // for two entries to be equal both value and key must be equal
+                if (o1.equals(o2)) return 0;
+                int value1 = bitUtil.getIntHigh(o1);
+                int value2 = bitUtil.getIntHigh(o2);
+                if (value1 == value2) {
+                    // we enforce a deterministic order by looking at the size of the key (although there is no real
+                    // reason to prefer one entry over the other)
+                    int key1 = bitUtil.getIntLow(o1);
+                    int key2 = bitUtil.getIntLow(o2);
+                    if (key1 == key2) return 0;
+                    return key1 < key2 ? -1 : 1;
+                }
+                float f1 = Float.intBitsToFloat(value1);
+                float f2 = Float.intBitsToFloat(value2);
+                return Float.compare(f1, f2);
+            }
+        });
     }
 
     public void clear() {
         map.clear();
     }
 
-    void remove(int key, int value) {
-        long v = bitUtil.toLong(value, key);
-        if (!map.remove(v).equals(NOT_EMPTY)) {
+    void remove(int key, float value) {
+        long v = bitUtil.toLong(Float.floatToRawIntBits(value), key);
+        Integer prev = map.remove(v);
+        if (prev == null) {
             throw new IllegalStateException("cannot remove key " + key + " with value " + value
-                    + " - did you insert " + key + "," + value + " before?");
+                    + " - did you insert this key with this value before ?");
         }
     }
 
-    public void update(int key, int oldValue, int value) {
+    public void update(int key, float oldValue, float value) {
         remove(key, oldValue);
         insert(key, value);
     }
 
-    public void insert(int key, int value) {
-        long v = bitUtil.toLong(value, key);
+    public void insert(int key, float value) {
+        long v = bitUtil.toLong(Float.floatToRawIntBits(value), key);
         map.put(v, NOT_EMPTY);
     }
 
-    public int peekValue() {
+    public float peekValue() {
         long key = map.firstEntry().getKey();
-        return (int) (key >> 32);
+        return Float.intBitsToFloat(bitUtil.getIntHigh(key));
     }
 
     public int peekKey() {
         long key = map.firstEntry().getKey();
-        return (int) (key & 0xFFFFFFFFL);
+        return bitUtil.getIntLow(key);
     }
 
     /**
@@ -77,7 +99,7 @@ public int pollKey() {
             throw new IllegalStateException("Cannot poll collection is empty!");
 
         long key = map.pollFirstEntry().getKey();
-        return (int) (key & 0xFFFFFFFFL);
+        return bitUtil.getIntLow(key);
     }
 
     public int getSize() {
diff --git a/core/src/main/java/com/graphhopper/json/GHJson.java b/core/src/main/java/com/graphhopper/json/GHJson.java
deleted file mode 100644
index f336aa762b..0000000000
--- a/core/src/main/java/com/graphhopper/json/GHJson.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import java.io.Reader;
-
-/**
- * A simple JSON (de)serialization facade. E.g. to be easily replaced with platform specific
- * implementations.
- *
- * @author Peter Karich
- */
-public interface GHJson {
-    /**
-     * This method reads JSON data from the provided source and creates an instance of the provided
-     * class.
-     */
-    <T> T fromJson(Reader source, Class<T> aClass);
-}
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 2de60fd4d6..25b7559996 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -24,7 +24,6 @@
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -57,8 +56,8 @@ public AbstractRoutingAlgorithm(Graph graph, Weighting weighting, TraversalMode
         this.traversalMode = traversalMode;
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, false, true));
-        inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
+        outEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder));
+        inEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder));
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index bab9f4d521..94ca342dc7 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -88,8 +88,8 @@ public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, Flag
         prevNode = -1;
         prevInRoundabout = false;
         prevName = null;
-        outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(this.encoder, false, true));
-        crossingExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, true, true));
+        outEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+        crossingExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.allEdges(encoder));
     }
 
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
new file mode 100644
index 0000000000..9ce66debd0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.CHEdgeExplorer;
+
+abstract class AbstractNodeContractor implements NodeContractor {
+    private final GraphHopperStorage ghStorage;
+    final CHGraph prepareGraph;
+    final FlagEncoder encoder;
+    CHEdgeExplorer inEdgeExplorer;
+    CHEdgeExplorer outEdgeExplorer;
+    private final DataAccess originalEdges;
+    int maxLevel;
+    private int maxEdgesCount;
+
+    public AbstractNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting) {
+        this.ghStorage = ghStorage;
+        this.prepareGraph = prepareGraph;
+        this.encoder = weighting.getFlagEncoder();
+        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
+        originalEdges.create(1000);
+    }
+
+    @Override
+    public void initFromGraph() {
+        inEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
+        outEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+        maxLevel = prepareGraph.getNodes();
+        maxEdgesCount = ghStorage.getAllEdges().length();
+    }
+
+    @Override
+    public void close() {
+        originalEdges.close();
+    }
+
+    boolean isContracted(int node) {
+        return prepareGraph.getLevel(node) != maxLevel;
+    }
+
+    void setOrigEdgeCount(int edgeId, int value) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0) {
+            // ignore setting as every normal edge has original edge count of 1
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
+                        prepareGraph.getAllEdges().length());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        originalEdges.setInt(tmp, value);
+    }
+
+    int getOrigEdgeCount(int edgeId) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        return originalEdges.getInt(tmp);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index 3c714bcc0c..191841cca0 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -22,12 +22,10 @@
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.routing.weighting.BlockAreaWeighting;
-import com.graphhopper.routing.weighting.GenericWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters.CH;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -56,11 +54,7 @@
     private boolean enabled = true;
     private int preparationThreads;
     private ExecutorService threadPool;
-    private int preparationPeriodicUpdates = -1;
-    private int preparationLazyUpdates = -1;
-    private int preparationNeighborUpdates = -1;
-    private int preparationContractedNodes = -1;
-    private double preparationLogMessages = -1;
+    private PMap pMap = new PMap();
 
     public CHAlgoFactoryDecorator() {
         setPreparationThreads(1);
@@ -81,7 +75,7 @@ public void init(CmdArgs args) {
         String chWeightingsStr = args.get(CH.PREPARE + "weightings", "");
 
         if ("no".equals(chWeightingsStr) || "false".equals(chWeightingsStr)) {
-            // default is fastest and we need to clear this explicitely
+            // default is fastest and we need to clear this explicitly
             weightingsAsStrings.clear();
         } else if (!chWeightingsStr.isEmpty()) {
             List<String> tmpCHWeightingList = Arrays.asList(chWeightingsStr.split(","));
@@ -93,56 +87,7 @@ public void init(CmdArgs args) {
         if (enableThis)
             setDisablingAllowed(args.getBool(CH.INIT_DISABLING_ALLOWED, isDisablingAllowed()));
 
-        setPreparationPeriodicUpdates(args.getInt(CH.PREPARE + "updates.periodic", getPreparationPeriodicUpdates()));
-        setPreparationLazyUpdates(args.getInt(CH.PREPARE + "updates.lazy", getPreparationLazyUpdates()));
-        setPreparationNeighborUpdates(args.getInt(CH.PREPARE + "updates.neighbor", getPreparationNeighborUpdates()));
-        setPreparationContractedNodes(args.getInt(CH.PREPARE + "contracted_nodes", getPreparationContractedNodes()));
-        setPreparationLogMessages(args.getDouble(CH.PREPARE + "log_messages", getPreparationLogMessages()));
-    }
-
-    public int getPreparationPeriodicUpdates() {
-        return preparationPeriodicUpdates;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationPeriodicUpdates(int preparePeriodicUpdates) {
-        this.preparationPeriodicUpdates = preparePeriodicUpdates;
-        return this;
-    }
-
-    public int getPreparationContractedNodes() {
-        return preparationContractedNodes;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationContractedNodes(int prepareContractedNodes) {
-        this.preparationContractedNodes = prepareContractedNodes;
-        return this;
-    }
-
-    public int getPreparationLazyUpdates() {
-        return preparationLazyUpdates;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationLazyUpdates(int prepareLazyUpdates) {
-        this.preparationLazyUpdates = prepareLazyUpdates;
-        return this;
-    }
-
-    public double getPreparationLogMessages() {
-        return preparationLogMessages;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationLogMessages(double prepareLogMessages) {
-        this.preparationLogMessages = prepareLogMessages;
-        return this;
-    }
-
-    public int getPreparationNeighborUpdates() {
-        return preparationNeighborUpdates;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationNeighborUpdates(int prepareNeighborUpdates) {
-        this.preparationNeighborUpdates = prepareNeighborUpdates;
-        return this;
+        pMap = args;
     }
 
     @Override
@@ -319,13 +264,8 @@ public void createPreparations(GraphHopperStorage ghStorage, TraversalMode trave
 
         for (Weighting weighting : getWeightings()) {
             PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
-                    new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class, weighting),
-                    weighting, traversalMode);
-            tmpPrepareCH.setPeriodicUpdates(preparationPeriodicUpdates).
-                    setLazyUpdates(preparationLazyUpdates).
-                    setNeighborUpdates(preparationNeighborUpdates).
-                    setLogMessages(preparationLogMessages);
-
+                    new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class, weighting), traversalMode);
+            tmpPrepareCH.setParams(pMap);
             addPreparation(tmpPrepareCH);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java b/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java
new file mode 100644
index 0000000000..0d8ae21a6b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java
@@ -0,0 +1,17 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.util.Parameters;
+
+public final class CHParameters {
+    static final String PERIODIC_UPDATES = Parameters.CH.PREPARE + "updates.periodic";
+    static final String LAST_LAZY_NODES_UPDATES = Parameters.CH.PREPARE + "updates.lazy";
+    static final String NEIGHBOR_UPDATES = Parameters.CH.PREPARE + "updates.neighbor";
+    static final String CONTRACTED_NODES = Parameters.CH.PREPARE + "contracted_nodes";
+    static final String LOG_MESSAGES = Parameters.CH.PREPARE + "log_messages";
+    static final String EDGE_DIFFERENCE_WEIGHT = Parameters.CH.PREPARE + "node.edge_difference_weight";
+    static final String ORIGINAL_EDGE_COUNT_WEIGHT = Parameters.CH.PREPARE + "node.original_edge_count_weight";
+    static final String CONTRACTED_NEIGHBORS_WEIGHT = Parameters.CH.PREPARE + "node.contracted_neighbors_weight";
+
+    private CHParameters() {
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
new file mode 100644
index 0000000000..c37e144a02
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -0,0 +1,458 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.util.Helper.nf;
+
+class NodeBasedNodeContractor extends AbstractNodeContractor {
+    private final PreparationWeighting prepareWeighting;
+    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
+    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
+    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
+    private final Params params = new Params();
+    private CHEdgeExplorer remainingEdgeExplorer;
+    private IgnoreNodeFilter ignoreNodeFilter;
+    private DijkstraOneToMany prepareAlgo;
+    private int addedShortcutsCount;
+    private long dijkstraCount;
+    private StopWatch dijkstraSW = new StopWatch();
+    // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
+    // each edge can exist in both directions
+    private double meanDegree;
+
+    NodeBasedNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting, PMap pMap) {
+        super(dir, ghStorage, prepareGraph, weighting);
+        this.prepareWeighting = new PreparationWeighting(weighting);
+        extractParams(pMap);
+    }
+
+    private void extractParams(PMap pMap) {
+        params.edgeDifferenceWeight = pMap.getFloat(EDGE_DIFFERENCE_WEIGHT, params.edgeDifferenceWeight);
+        params.originalEdgesCountWeight = pMap.getFloat(ORIGINAL_EDGE_COUNT_WEIGHT, params.originalEdgesCountWeight);
+        params.contractedNeighborsWeight = pMap.getFloat(CONTRACTED_NEIGHBORS_WEIGHT, params.contractedNeighborsWeight);
+    }
+
+    @Override
+    public void initFromGraph() {
+        super.initFromGraph();
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        final EdgeFilter allFilter = DefaultEdgeFilter.allEdges(encoder);
+        final EdgeFilter remainingNodesFilter = new LevelEdgeFilter(prepareGraph) {
+            @Override
+            public final boolean accept(EdgeIteratorState edgeState) {
+                return super.accept(edgeState) && allFilter.accept(edgeState);
+            }
+        };
+        remainingEdgeExplorer = prepareGraph.createEdgeExplorer(remainingNodesFilter);
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, TraversalMode.NODE_BASED);
+    }
+
+    @Override
+    public void prepareContraction() {
+        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
+        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
+        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
+        // graph contraction parameters, because it affects the node contraction order.
+        // when this is done there should be no need for this method any longer.
+        meanDegree = prepareGraph.getAllEdges().length() / prepareGraph.getNodes();
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        prepareAlgo.close();
+    }
+
+    /**
+     * Warning: the calculated priority must NOT depend on priority(v) and therefore findShortcuts should also not
+     * depend on the priority(v). Otherwise updating the priority before contracting in contractNodes() could lead to
+     * a slowish or even endless loop.
+     */
+    @Override
+    public float calculatePriority(int node) {
+        CalcShortcutsResult calcShortcutsResult = calcShortcutCount(node);
+
+        // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
+        //
+        // every adjNode has an 'original edge' number associated. initially it is r=1
+        // when a new shortcut is introduced then r of the associated edges is summed up:
+        // r(u,w)=r(u,v)+r(v,w) now we can define
+        // originalEdgesCount = (v) := sum_{ (u,w)  shortcuts(v) } of r(u, w)
+        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
+
+        // # lowest influence on preparation speed or shortcut creation count
+        // (but according to paper should speed up queries)
+        //
+        // number of already contracted neighbors of v
+        int contractedNeighbors = 0;
+        int degree = 0;
+        CHEdgeIterator iter = remainingEdgeExplorer.setBaseNode(node);
+        while (iter.next()) {
+            degree++;
+            if (iter.isShortcut())
+                contractedNeighbors++;
+        }
+
+        // from shortcuts we can compute the edgeDifference
+        // # low influence: with it the shortcut creation is slightly faster
+        //
+        // |shortcuts(v)|  |{(u, v) | v uncontracted}|  |{(v, w) | v uncontracted}|
+        // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
+        // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
+        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
+
+        // according to the paper do a simple linear combination of the properties to get the priority.
+        return params.edgeDifferenceWeight * edgeDifference +
+                params.originalEdgesCountWeight * originalEdgesCount +
+                params.contractedNeighborsWeight * contractedNeighbors;
+    }
+
+    @Override
+    public void contractNode(int node) {
+        shortcuts.clear();
+        long degree = findShortcuts(addScHandler.setNode(node));
+        addedShortcutsCount += addShortcuts(shortcuts.keySet());
+        // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
+        meanDegree = (meanDegree * 2 + degree) / 3;
+    }
+
+    @Override
+    public String getStatisticsString() {
+        return String.format(Locale.ROOT, "meanDegree: %.2f, dijkstras: %10s, mem: %10s",
+                meanDegree, nf(dijkstraCount), prepareAlgo.getMemoryUsageAsString());
+    }
+
+    /**
+     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
+     * changed by this method.
+     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that
+     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     */
+    private long findShortcuts(ShortcutHandler sch) {
+        int maxVisitedNodes = getMaxVisitedNodesEstimate();
+        long degree = 0;
+        EdgeIterator incomingEdges = inEdgeExplorer.setBaseNode(sch.getNode());
+        // collect outgoing nodes (goal-nodes) only once
+        while (incomingEdges.next()) {
+            int fromNode = incomingEdges.getAdjNode();
+            // accept only uncontracted nodes
+            if (isContracted(fromNode))
+                continue;
+
+            final double incomingEdgeDistance = incomingEdges.getDistance();
+            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            int incomingEdge = incomingEdges.getEdge();
+            int inOrigEdgeCount = getOrigEdgeCount(incomingEdge);
+            // collect outgoing nodes (goal-nodes) only once
+            EdgeIterator outgoingEdges = outEdgeExplorer.setBaseNode(sch.getNode());
+            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
+            prepareAlgo.clear();
+            degree++;
+            while (outgoingEdges.next()) {
+                int toNode = outgoingEdges.getAdjNode();
+                // add only uncontracted nodes
+                if (isContracted(toNode) || fromNode == toNode)
+                    continue;
+
+                // Limit weight as ferries or forbidden edges can increase local search too much.
+                // If we decrease the correct weight we only explore less and introduce more shortcuts.
+                // I.e. no change to accuracy is made.
+                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
+                if (Double.isNaN(existingDirectWeight))
+                    throw new IllegalStateException("Weighting should never return NaN values"
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
+                            + ", dist:" + outgoingEdges.getDistance());
+
+                if (Double.isInfinite(existingDirectWeight))
+                    continue;
+
+                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
+                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
+
+                dijkstraSW.start();
+                dijkstraCount++;
+                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
+                dijkstraSW.stop();
+
+                // compare end node as the limit could force dijkstra to finish earlier
+                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
+                    // FOUND witness path, so do not add shortcut
+                    continue;
+
+                sch.foundShortcut(fromNode, toNode,
+                        existingDirectWeight, existingDistSum,
+                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
+                        incomingEdge, inOrigEdgeCount);
+            }
+        }
+        return degree;
+    }
+
+    /**
+     * Adds the given shortcuts to the graph.
+     *
+     * @return the actual number of shortcuts that were added to the graph
+     */
+    private int addShortcuts(Collection<Shortcut> shortcuts) {
+        int tmpNewShortcuts = 0;
+        NEXT_SC:
+        for (Shortcut sc : shortcuts) {
+            boolean updatedInGraph = false;
+            // check if we need to update some existing shortcut in the graph
+            CHEdgeIterator iter = outEdgeExplorer.setBaseNode(sc.from);
+            while (iter.next()) {
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
+                    int status = iter.getMergeStatus(sc.flags);
+                    if (status == 0)
+                        continue;
+
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
+                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
+                        // see testShortcutMergeBug
+                        if (status == 2)
+                            break;
+
+                        continue NEXT_SC;
+                    }
+
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
+                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
+                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
+                                + ", sc:" + sc
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", neighbors:" + GHUtility.getNeighbors(iter));
+                    }
+
+                    // note: flags overwrite weight => call first
+                    iter.setFlags(sc.flags);
+                    iter.setWeight(sc.weight);
+                    iter.setDistance(sc.dist);
+                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
+                    updatedInGraph = true;
+                    break;
+                }
+            }
+
+            if (!updatedInGraph) {
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                // note: flags overwrite weight => call first
+                edgeState.setFlags(sc.flags);
+                edgeState.setWeight(sc.weight);
+                edgeState.setDistance(sc.dist);
+                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
+                tmpNewShortcuts++;
+            }
+        }
+        return tmpNewShortcuts;
+    }
+
+    private CalcShortcutsResult calcShortcutCount(int node) {
+        findShortcuts(calcScHandler.setNode(node));
+        return calcScHandler.calcShortcutsResult;
+    }
+
+    private String getCoords(EdgeIteratorState edge, Graph graph) {
+        NodeAccess na = graph.getNodeAccess();
+        int base = edge.getBaseNode();
+        int adj = edge.getAdjNode();
+        return base + "->" + adj + " (" + edge.getEdge() + "); "
+                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
+    }
+
+    @Override
+    public long getAddedShortcutsCount() {
+        return addedShortcutsCount;
+    }
+
+    @Override
+    public long getDijkstraCount() {
+        return dijkstraCount;
+    }
+
+    @Override
+    public float getDijkstraSeconds() {
+        return dijkstraSW.getCurrentSeconds();
+    }
+
+    private int getMaxVisitedNodesEstimate() {
+        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
+        // the node contraction order and requires re-optimizing the parameters of the graph contraction
+        return (int) meanDegree * 100;
+    }
+
+    private static class Shortcut {
+        int from;
+        int to;
+        int skippedEdge1;
+        int skippedEdge2;
+        double dist;
+        double weight;
+        int originalEdges;
+        long flags = PrepareEncoder.getScFwdDir();
+
+        public Shortcut(int from, int to, double weight, double dist) {
+            this.from = from;
+            this.to = to;
+            this.weight = weight;
+            this.dist = dist;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 5;
+            hash = 23 * hash + from;
+            hash = 23 * hash + to;
+            return 23 * hash
+                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == null || getClass() != obj.getClass())
+                return false;
+
+            final Shortcut other = (Shortcut) obj;
+            return this.from == other.from && this.to == other.to &&
+                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
+
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            if (flags == PrepareEncoder.getScDirMask())
+                str = from + "<->";
+            else
+                str = from + "->";
+
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+        }
+    }
+
+    private interface ShortcutHandler {
+        void foundShortcut(int fromNode, int toNode,
+                           double existingDirectWeight, double distance,
+                           int outgoingEdge, int outOrigEdgeCount,
+                           int incomingEdge, int inOrigEdgeCount);
+
+        int getNode();
+    }
+
+    private class CalcShortcutHandler implements ShortcutHandler {
+        int node;
+        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public CalcShortcutHandler setNode(int node) {
+            this.node = node;
+            calcShortcutsResult.originalEdgesCount = 0;
+            calcShortcutsResult.shortcutsCount = 0;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double distance,
+                                  int outgoingEdge, int outOrigEdgeCount,
+                                  int incomingEdge, int inOrigEdgeCount) {
+            calcShortcutsResult.shortcutsCount++;
+            calcShortcutsResult.originalEdgesCount += inOrigEdgeCount + outOrigEdgeCount;
+        }
+    }
+
+    private class AddShortcutHandler implements ShortcutHandler {
+        int node;
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public AddShortcutHandler setNode(int node) {
+            shortcuts.clear();
+            this.node = node;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double existingDistSum,
+                                  int outgoingEdge, int outOrigEdgeCount,
+                                  int incomingEdge, int inOrigEdgeCount) {
+            // FOUND shortcut
+            // but be sure that it is the only shortcut in the collection
+            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
+            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
+            // know yet the levels so we need to determine the correct direction or if both directions
+            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
+            if (shortcuts.containsKey(sc))
+                return;
+
+            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            // overwrite flags only if skipped edges are identical
+            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
+                tmpRetSc.flags = PrepareEncoder.getScDirMask();
+                return;
+            }
+
+            Shortcut old = shortcuts.put(sc, sc);
+            if (old != null)
+                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+
+            sc.skippedEdge1 = incomingEdge;
+            sc.skippedEdge2 = outgoingEdge;
+            sc.originalEdges = inOrigEdgeCount + outOrigEdgeCount;
+        }
+    }
+
+    private static class CalcShortcutsResult {
+        int originalEdgesCount;
+        int shortcutsCount;
+    }
+
+    public static class Params {
+        // default values were optimized for Unterfranken
+        private float edgeDifferenceWeight = 10;
+        private float originalEdgesCountWeight = 1;
+        private float contractedNeighborsWeight = 1;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
index 817ae8f9f2..5f329b0c85 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
@@ -15,428 +15,31 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.ch;
-
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-class NodeContractor {
-    private final GraphHopperStorage ghStorage;
-    private final CHGraph prepareGraph;
-    private final PreparationWeighting prepareWeighting;
-    // todo: so far node contraction can only be done for node-based graph traversal
-    private final TraversalMode traversalMode;
-    private final DataAccess originalEdges;
-    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
-    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
-    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
-    private CHEdgeExplorer vehicleInExplorer;
-    private CHEdgeExplorer vehicleOutExplorer;
-    private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany prepareAlgo;
-    private int addedShortcutsCount;
-    private long dijkstraCount;
-    private int maxVisitedNodes = Integer.MAX_VALUE;
-    private StopWatch dijkstraSW = new StopWatch();
-    private int maxEdgesCount;
-    private int maxLevel;
-
-    NodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting,
-                   TraversalMode traversalMode) {
-        if (traversalMode.isEdgeBased()) {
-            throw new IllegalArgumentException("Contraction Hierarchies only support node based traversal so far, given: " + traversalMode);
-        }
-        // todo: it would be nice to check if ghStorage is frozen here
-        this.ghStorage = ghStorage;
-        this.prepareGraph = prepareGraph;
-        this.prepareWeighting = new PreparationWeighting(weighting);
-        this.traversalMode = traversalMode;
-        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
-        originalEdges.create(1000);
-    }
-
-    void initFromGraph() {
-        // todo: do we really need this method ? the problem is that ghStorage/prepareGraph can potentially be modified
-        // between the constructor call and contractNode,calcShortcutCount etc. ...
-        maxLevel = prepareGraph.getNodes();
-        maxEdgesCount = ghStorage.getAllEdges().length();
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
-        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
-        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
-    }
-
-    void close() {
-        prepareAlgo.close();
-        originalEdges.close();
-    }
 
-    void setMaxVisitedNodes(int maxVisitedNodes) {
-        this.maxVisitedNodes = maxVisitedNodes;
-    }
+package com.graphhopper.routing.ch;
 
-    long contractNode(int node) {
-        shortcuts.clear();
-        long degree = findShortcuts(addScHandler.setNode(node));
-        addedShortcutsCount += addShortcuts(shortcuts.keySet());
-        return degree;
-    }
+public interface NodeContractor {
+    void initFromGraph();
 
-    CalcShortcutsResult calcShortcutCount(int node) {
-        findShortcuts(calcScHandler.setNode(node));
-        return calcScHandler.calcShortcutsResult;
-    }
+    void close();
 
     /**
-     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
-     * changed by this method.
-     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that 
-     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     * Calculates the priority of a node without changing the graph. Lower (!!) priority nodes are contracted first.
      */
-    private long findShortcuts(ShortcutHandler sch) {
-        long degree = 0;
-        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
-        // collect outgoing nodes (goal-nodes) only once
-        while (incomingEdges.next()) {
-            int fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (prepareGraph.getLevel(fromNode) != maxLevel)
-                continue;
-
-            final double incomingEdgeDistance = incomingEdges.getDistance();
-            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
-            int incomingEdge = incomingEdges.getEdge();
-            int incomingEdgeOrigCount = getOrigEdgeCount(incomingEdge);
-            // collect outgoing nodes (goal-nodes) only once
-            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
-            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            prepareAlgo.clear();
-            degree++;
-            while (outgoingEdges.next()) {
-                int toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (prepareGraph.getLevel(toNode) != maxLevel || fromNode == toNode)
-                    continue;
-
-                // Limit weight as ferries or forbidden edges can increase local search too much.
-                // If we decrease the correct weight we only explore less and introduce more shortcuts.
-                // I.e. no change to accuracy is made.
-                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
-                if (Double.isNaN(existingDirectWeight))
-                    throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
-                            + ", dist:" + outgoingEdges.getDistance());
-
-                if (Double.isInfinite(existingDirectWeight))
-                    continue;
-
-                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
-                prepareAlgo.setWeightLimit(existingDirectWeight);
-                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
-                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
-
-                dijkstraSW.start();
-                dijkstraCount++;
-                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
-                dijkstraSW.stop();
-
-                // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
-                    // FOUND witness path, so do not add shortcut
-                    continue;
-
-                sch.foundShortcut(fromNode, toNode,
-                        existingDirectWeight, existingDistSum,
-                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
-                        incomingEdge, incomingEdgeOrigCount);
-            }
-        }
-        return degree;
-    }
+    float calculatePriority(int node);
 
     /**
-     * Adds the given shortcuts to the graph.
-     *
-     * @return the actual number of shortcuts that were added to the graph
+     * Adds the required shortcuts for the given node.
      */
-    private int addShortcuts(Collection<Shortcut> shortcuts) {
-        int tmpNewShortcuts = 0;
-        NEXT_SC:
-        for (Shortcut sc : shortcuts) {
-            boolean updatedInGraph = false;
-            // check if we need to update some existing shortcut in the graph
-            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
-            while (iter.next()) {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
-                    int status = iter.getMergeStatus(sc.flags);
-                    if (status == 0)
-                        continue;
-
-                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
-                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
-                        // see testShortcutMergeBug
-                        if (status == 2)
-                            break;
-
-                        continue NEXT_SC;
-                    }
-
-                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
-                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
-                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
-                                + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
-                                + ", neighbors:" + GHUtility.getNeighbors(iter));
-                    }
-
-                    // note: flags overwrite weight => call first
-                    iter.setFlags(sc.flags);
-                    iter.setWeight(sc.weight);
-                    iter.setDistance(sc.dist);
-                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
-                    updatedInGraph = true;
-                    break;
-                }
-            }
-
-            if (!updatedInGraph) {
-                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
-                // note: flags overwrite weight => call first
-                edgeState.setFlags(sc.flags);
-                edgeState.setWeight(sc.weight);
-                edgeState.setDistance(sc.dist);
-                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
-                tmpNewShortcuts++;
-            }
-        }
-        return tmpNewShortcuts;
-    }
-
-    private String getCoords(EdgeIteratorState edge, Graph graph) {
-        NodeAccess na = graph.getNodeAccess();
-        int base = edge.getBaseNode();
-        int adj = edge.getAdjNode();
-        return base + "->" + adj + " (" + edge.getEdge() + "); "
-                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
-    }
-
-    int getAddedShortcutsCount() {
-        return addedShortcutsCount;
-    }
-
-    private void setOrigEdgeCount(int edgeId, int value) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0) {
-            // ignore setting as every normal edge has original edge count of 1
-            if (value != 1)
-                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
-                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
-                        prepareGraph.getAllEdges().length());
-            return;
-        }
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        originalEdges.setInt(tmp, value);
-    }
-
-    private int getOrigEdgeCount(int edgeId) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0)
-            return 1;
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        return originalEdges.getInt(tmp);
-    }
-
-    String getPrepareAlgoMemoryUsage() {
-        return prepareAlgo.getMemoryUsageAsString();
-    }
-
-    long getDijkstraCount() {
-        return dijkstraCount;
-    }
-
-    void resetDijkstraTime() {
-        dijkstraSW = new StopWatch();
-    }
-
-    float getDijkstraSeconds() {
-        return dijkstraSW.getSeconds();
-    }
-
-    static class IgnoreNodeFilter implements EdgeFilter {
-        int avoidNode;
-        int maxLevel;
-        CHGraph graph;
-
-        IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
-            this.graph = chGraph;
-            this.maxLevel = maxLevel;
-        }
-
-        IgnoreNodeFilter setAvoidNode(int node) {
-            this.avoidNode = node;
-            return this;
-        }
-
-        @Override
-        public final boolean accept(EdgeIteratorState iter) {
-            // ignore if it is skipNode or adjNode is already contracted
-            int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == maxLevel;
-        }
-    }
-
-    static class Shortcut {
-        int from;
-        int to;
-        int skippedEdge1;
-        int skippedEdge2;
-        double dist;
-        double weight;
-        int originalEdges;
-        long flags = PrepareEncoder.getScFwdDir();
-
-        public Shortcut(int from, int to, double weight, double dist) {
-            this.from = from;
-            this.to = to;
-            this.weight = weight;
-            this.dist = dist;
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 5;
-            hash = 23 * hash + from;
-            hash = 23 * hash + to;
-            return 23 * hash
-                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || getClass() != obj.getClass())
-                return false;
-
-            final Shortcut other = (Shortcut) obj;
-            return this.from == other.from && this.to == other.to &&
-                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
-
-        }
-
-        @Override
-        public String toString() {
-            String str;
-            if (flags == PrepareEncoder.getScDirMask())
-                str = from + "<->";
-            else
-                str = from + "->";
-
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
-        }
-    }
-
-    interface ShortcutHandler {
-        void foundShortcut(int fromNode, int toNode,
-                           double existingDirectWeight, double distance,
-                           int outgoingEdge, int outgoingEdgeOrigCount,
-                           int incomingEdge, int incomingEdgeOrigCount);
-
-        int getNode();
-    }
-
-    class CalcShortcutHandler implements ShortcutHandler {
-        int node;
-        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public CalcShortcutHandler setNode(int node) {
-            this.node = node;
-            calcShortcutsResult.originalEdgesCount = 0;
-            calcShortcutsResult.shortcutsCount = 0;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double distance,
-                                  int outgoingEdge, int outgoingEdgeOrigCount,
-                                  int incomingEdge, int incomingEdgeOrigCount) {
-            calcShortcutsResult.shortcutsCount++;
-            calcShortcutsResult.originalEdgesCount += incomingEdgeOrigCount + outgoingEdgeOrigCount;
-        }
-    }
-
-    class AddShortcutHandler implements ShortcutHandler {
-        int node;
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public AddShortcutHandler setNode(int node) {
-            shortcuts.clear();
-            this.node = node;
-            return this;
-        }
+    void contractNode(int node);
 
-        @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double existingDistSum,
-                                  int outgoingEdge, int outgoingEdgeOrigCount,
-                                  int incomingEdge, int incomingEdgeOrigCount) {
-            // FOUND shortcut
-            // but be sure that it is the only shortcut in the collection
-            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
-            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
-            // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
-            if (shortcuts.containsKey(sc))
-                return;
+    long getAddedShortcutsCount();
 
-            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
-            Shortcut tmpRetSc = shortcuts.get(tmpSc);
-            // overwrite flags only if skipped edges are identical
-            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
-                tmpRetSc.flags = PrepareEncoder.getScDirMask();
-                return;
-            }
+    String getStatisticsString();
 
-            Shortcut old = shortcuts.put(sc, sc);
-            if (old != null)
-                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+    long getDijkstraCount();
 
-            sc.skippedEdge1 = incomingEdge;
-            sc.skippedEdge2 = outgoingEdge;
-            sc.originalEdges = incomingEdgeOrigCount + outgoingEdgeOrigCount;
-        }
-    }
+    float getDijkstraSeconds();
 
-    static class CalcShortcutsResult {
-        int originalEdgesCount;
-        int shortcutsCount;
-    }
+    void prepareContraction();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 8988b4fdde..e00171d7c2 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.PathBidirRef;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.CHEdgeIteratorState;
@@ -40,60 +39,42 @@ public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
     }
 
     @Override
-    protected final void processEdge(int tmpEdge, int endNode, int prevEdgeId) {
+    protected final void processEdge(int edgeId, int endNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
+        expandEdge(getEdge(edgeId, endNode), false);
     }
 
-    private void expandEdge(CHEdgeIteratorState mainEdgeState, boolean reverse) {
-        if (!mainEdgeState.isShortcut()) {
-            distance += mainEdgeState.getDistance();
-            time += weighting.calcMillis(mainEdgeState, reverse, EdgeIterator.NO_EDGE);
-            addEdge(mainEdgeState.getEdge());
+    private void expandEdge(CHEdgeIteratorState edge, boolean reverse) {
+        if (!edge.isShortcut()) {
+            distance += edge.getDistance();
+            time += weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
+            addEdge(edge.getEdge());
             return;
         }
+        expandSkippedEdges(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+    }
 
-        int skippedEdge1 = mainEdgeState.getSkippedEdge1();
-        int skippedEdge2 = mainEdgeState.getSkippedEdge2();
-        int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
-
+    private void expandSkippedEdges(int skippedEdge1, int skippedEdge2, int from, int to, boolean reverse) {
         // get properties like speed of the edge in the correct direction
-        if (reverse) {
+        if (reverseOrder == reverse) {
             int tmp = from;
             from = to;
             to = tmp;
         }
 
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
-        if (reverseOrder) {
-            CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            boolean empty = edgeState == null;
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
-
-            expandEdge(edgeState, false);
-
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            else
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(edgeState, true);
+        CHEdgeIteratorState sk2to = getEdge(skippedEdge2, to);
+        if (sk2to != null) {
+            expandEdge(sk2to, !reverseOrder);
+            expandEdge(getEdge(skippedEdge1, from), reverseOrder);
         } else {
-            CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            boolean empty = iter == null;
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(iter, true);
-
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            else
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
-
-            expandEdge(iter, false);
+            expandEdge(getEdge(skippedEdge1, to), !reverseOrder);
+            expandEdge(getEdge(skippedEdge2, from), reverseOrder);
         }
     }
+
+    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
+        return (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(edgeId, adjNode);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 0eb5cc7dcc..29226da005 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -26,8 +26,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.Locale;
+import java.util.Random;
 
+import static com.graphhopper.routing.ch.CHParameters.*;
 import static com.graphhopper.util.Helper.nf;
 import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
@@ -55,105 +57,39 @@
     private final CHGraphImpl prepareGraph;
     private final Random rand = new Random(123);
     private final StopWatch allSW = new StopWatch();
+    private final StopWatch periodicUpdateSW = new StopWatch();
+    private final StopWatch lazyUpdateSW = new StopWatch();
+    private final StopWatch neighborUpdateSW = new StopWatch();
+    private final StopWatch contractionSW = new StopWatch();
+    private final Params params;
     private NodeContractor nodeContractor;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
-    private CHEdgeExplorer calcPrioAllExplorer;
     private int maxLevel;
     // nodes with highest priority come last
     private GHTreeMapComposed sortedNodes;
-    private int oldPriorities[];
-    private double meanDegree;
-    private int periodicUpdatesPercentage = 20;
-    private int lastNodesLazyUpdatePercentage = 10;
-    private int neighborUpdatePercentage = 20;
-    private double nodesContractedPercentage = 100;
-    private double logMessagesPercentage = 20;
-    private double dijkstraTime;
-    private double periodTime;
-    private double lazyTime;
-    private double neighborTime;
+    private float oldPriorities[];
+    private PMap pMap = new PMap();
     private int initSize;
+    private int checkCounter;
 
-    public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
-                                         Weighting weighting, TraversalMode traversalMode) {
+    public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph, TraversalMode traversalMode) {
         this.dir = dir;
         this.ghStorage = ghStorage;
         this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
-        this.weighting = weighting;
+        this.weighting = ((CHGraphImpl) chGraph).getWeighting();
         prepareWeighting = new PreparationWeighting(weighting);
+        this.params = Params.forTraversalMode(traversalMode);
     }
 
-    /**
-     * The higher the values are the longer the preparation takes but the less shortcuts are
-     * produced.
-     * <p>
-     *
-     * @param periodicUpdates specifies how often periodic updates will happen. Use something less
-     *                        than 10.
-     */
-    public PrepareContractionHierarchies setPeriodicUpdates(int periodicUpdates) {
-        if (periodicUpdates < 0)
-            return this;
-        if (periodicUpdates > 100)
-            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100], to disable it use 0");
-
-        this.periodicUpdatesPercentage = periodicUpdates;
-        return this;
-    }
-
-    /**
-     * @param lazyUpdates specifies when lazy updates will happen, measured relative to all existing
-     *                    nodes. 100 means always.
-     */
-    public PrepareContractionHierarchies setLazyUpdates(int lazyUpdates) {
-        if (lazyUpdates < 0)
-            return this;
-
-        if (lazyUpdates > 100)
-            throw new IllegalArgumentException("lazyUpdates has to be in [0, 100], to disable it use 0");
-
-        this.lastNodesLazyUpdatePercentage = lazyUpdates;
-        return this;
-    }
-
-    /**
-     * @param neighborUpdates specifies how often neighbor updates will happen. 100 means always.
-     */
-    public PrepareContractionHierarchies setNeighborUpdates(int neighborUpdates) {
-        if (neighborUpdates < 0)
-            return this;
-
-        if (neighborUpdates > 100)
-            throw new IllegalArgumentException("neighborUpdates has to be in [0, 100], to disable it use 0");
-
-        this.neighborUpdatePercentage = neighborUpdates;
-        return this;
-    }
-
-    /**
-     * Specifies how often a log message should be printed. Specify something around 20 (20% of the
-     * start nodes).
-     */
-    public PrepareContractionHierarchies setLogMessages(double logMessages) {
-        if (logMessages >= 0)
-            this.logMessagesPercentage = logMessages;
-        return this;
-    }
-
-    /**
-     * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
-     * faster contraction duration.
-     */
-    public PrepareContractionHierarchies setContractedNodes(double nodesContracted) {
-        if (nodesContracted < 0)
-            return this;
-
-        if (nodesContracted > 100)
-            throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
-
-        this.nodesContractedPercentage = nodesContracted;
+    public PrepareContractionHierarchies setParams(PMap pMap) {
+        this.pMap = pMap;
+        params.setPeriodicUpdatesPercentage(pMap.getInt(PERIODIC_UPDATES, params.getPeriodicUpdatesPercentage()));
+        params.setLastNodesLazyUpdatePercentage(pMap.getInt(LAST_LAZY_NODES_UPDATES, params.getLastNodesLazyUpdatePercentage()));
+        params.setNeighborUpdatePercentage(pMap.getInt(NEIGHBOR_UPDATES, params.getNeighborUpdatePercentage()));
+        params.setNodesContractedPercentage(pMap.getInt(CONTRACTED_NODES, params.getNodesContractedPercentage()));
+        params.setLogMessagesPercentage(pMap.getInt(LOG_MESSAGES, params.getLogMessagesPercentage()));
         return this;
     }
 
@@ -165,14 +101,13 @@ public void doSpecificWork() {
 
         logger.info("took:" + (int) allSW.stop().getSeconds() + "s "
                 + ", new shortcuts: " + nf(nodeContractor.getAddedShortcutsCount())
+                + ", initSize:" + nf(initSize)
                 + ", " + prepareWeighting
-                + ", dijkstras:" + nf(nodeContractor.getDijkstraCount())
+                + ", periodic:" + params.getPeriodicUpdatesPercentage()
+                + ", lazy:" + params.getLastNodesLazyUpdatePercentage()
+                + ", neighbor:" + params.getNeighborUpdatePercentage()
                 + ", " + getTimesAsString()
-                + ", meanDegree:" + (long) meanDegree
-                + ", initSize:" + nf(initSize)
-                + ", periodic:" + periodicUpdatesPercentage
-                + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage
+                + ", lazy-overhead: " + (int) (100 * ((checkCounter / (double) initSize) - 1)) + "%"
                 + ", " + Helper.getMemInfo());
 
         int edgeCount = ghStorage.getAllEdges().length();
@@ -188,42 +123,34 @@ protected void runGraphContraction() {
 
     @Override
     public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
-        AbstractBidirAlgo algo;
+        AbstractBidirAlgo algo = doCreateAlgo(graph, opts);
+        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
+        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
+        return algo;
+    }
+
+    private AbstractBidirAlgo doCreateAlgo(Graph graph, AlgorithmOptions opts) {
         if (ASTAR_BI.equals(opts.getAlgorithm())) {
-            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
-            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
-            algo = tmpAlgo;
+            return new AStarBidirectionCH(graph, prepareWeighting, traversalMode)
+                    .setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
         } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
             if (opts.getHints().getBool("stall_on_demand", true)) {
-                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
             } else {
-                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
             }
         } else {
             throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
         }
-
-        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
-        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
-        return algo;
     }
 
     private void initFromGraph() {
         ghStorage.freeze();
         FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
-        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
-        // filter by vehicle and level number
-        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
-            @Override
-            public final boolean accept(EdgeIteratorState edgeState) {
-                return super.accept(edgeState) && allFilter.accept(edgeState);
-            }
-        };
-
+        final EdgeFilter allFilter = DefaultEdgeFilter.allEdges(prepareFlagEncoder);
         maxLevel = prepareGraph.getNodes();
         vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
         vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
 
         // Use an alternative to PriorityQueue as it has some advantages:
         //   1. Gets automatically smaller if less entries are stored => less total RAM used.
@@ -231,8 +158,8 @@ public final boolean accept(EdgeIteratorState edgeState) {
         //   2. is slightly faster
         //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[prepareGraph.getNodes()];
-        nodeContractor = new NodeContractor(dir, ghStorage, prepareGraph, weighting, traversalMode);
+        oldPriorities = new float[prepareGraph.getNodes()];
+        nodeContractor = new NodeBasedNodeContractor(dir, ghStorage, prepareGraph, weighting, pMap);
         nodeContractor.initFromGraph();
     }
 
@@ -241,111 +168,91 @@ private boolean prepareNodes() {
         for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
         }
-
+        periodicUpdateSW.start();
         for (int node = 0; node < nodes; node++) {
-            int priority = oldPriorities[node] = calculatePriority(node);
+            float priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
         }
+        periodicUpdateSW.stop();
 
         return !sortedNodes.isEmpty();
     }
 
     private void contractNodes() {
-        // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
-        // each edge can exist in both directions
-        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
-        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
-        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
-        // graph contraction parameters, because it affects the node contraction order.
-        meanDegree = prepareGraph.getAllEdges().length() / prepareGraph.getNodes();
+        nodeContractor.prepareContraction();
         initSize = sortedNodes.getSize();
         int level = 0;
-        long counter = 0;
-        long logSize = Math.round(Math.max(10, initSize / 100d * logMessagesPercentage));
-        if (logMessagesPercentage == 0)
+        checkCounter = 0;
+        long logSize = Math.round(Math.max(10, initSize / 100d * params.getLogMessagesPercentage()));
+        if (params.getLogMessagesPercentage() == 0)
             logSize = Integer.MAX_VALUE;
 
         // preparation takes longer but queries are slightly faster with preparation
         // => enable it but call not so often
         boolean periodicUpdate = true;
-        StopWatch periodSW = new StopWatch();
         int updateCounter = 0;
-        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * periodicUpdatesPercentage));
-        if (periodicUpdatesPercentage == 0)
+        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * params.getPeriodicUpdatesPercentage()));
+        if (params.getPeriodicUpdatesPercentage() == 0)
             periodicUpdate = false;
 
         // disable lazy updates for last x percentage of nodes as preparation is then a lot slower
         // and query time does not really benefit
-        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * params.getLastNodesLazyUpdatePercentage());
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
-        long nodesToAvoidContract = Math.round((100 - nodesContractedPercentage) / 100d * sortedNodes.getSize());
-        StopWatch lazySW = new StopWatch();
+        long nodesToAvoidContract = Math.round((100 - params.getNodesContractedPercentage()) / 100d * sortedNodes.getSize());
 
         // Recompute priority of uncontracted neighbors.
         // Without neighbor updates preparation is faster but we need them
         // to slightly improve query time. Also if not applied too often it decreases the shortcut number.
         boolean neighborUpdate = true;
-        if (neighborUpdatePercentage == 0)
+        if (params.getNeighborUpdatePercentage() == 0)
             neighborUpdate = false;
 
-        StopWatch neighborSW = new StopWatch();
         while (!sortedNodes.isEmpty()) {
             // periodically update priorities of ALL nodes
-            if (periodicUpdate && counter > 0 && counter % periodicUpdatesCount == 0) {
-                periodSW.start();
+            if (periodicUpdate && checkCounter > 0 && checkCounter % periodicUpdatesCount == 0) {
+                periodicUpdateSW.start();
                 sortedNodes.clear();
-                int len = prepareGraph.getNodes();
-                for (int node = 0; node < len; node++) {
+                for (int node = 0; node < prepareGraph.getNodes(); node++) {
                     if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
-                    int priority = oldPriorities[node] = calculatePriority(node);
+                    float priority = oldPriorities[node] = calculatePriority(node);
                     sortedNodes.insert(node, priority);
                 }
-                periodSW.stop();
+                periodicUpdateSW.stop();
                 updateCounter++;
                 if (sortedNodes.isEmpty())
                     throw new IllegalStateException("Cannot prepare as no unprepared nodes where found. Called preparation twice?");
             }
 
-            if (counter % logSize == 0) {
-                dijkstraTime += nodeContractor.getDijkstraSeconds();
-                periodTime += periodSW.getSeconds();
-                lazyTime += lazySW.getSeconds();
-                neighborTime += neighborSW.getSeconds();
-
-                logStats(counter, updateCounter);
-
-                nodeContractor.resetDijkstraTime();
-                periodSW = new StopWatch();
-                lazySW = new StopWatch();
-                neighborSW = new StopWatch();
+            if (checkCounter % logSize == 0) {
+                logStats(updateCounter);
             }
 
-            counter++;
+            checkCounter++;
             int polledNode = sortedNodes.pollKey();
 
             if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates) {
-                lazySW.start();
-                int priority = oldPriorities[polledNode] = calculatePriority(polledNode);
+                lazyUpdateSW.start();
+                float priority = oldPriorities[polledNode] = calculatePriority(polledNode);
                 if (priority > sortedNodes.peekValue()) {
                     // current node got more important => insert as new value and contract it later
                     sortedNodes.insert(polledNode, priority);
-                    lazySW.stop();
+                    lazyUpdateSW.stop();
                     continue;
                 }
-                lazySW.stop();
+                lazyUpdateSW.stop();
             }
 
             // contract node v!
-            nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
-            long degree = nodeContractor.contractNode(polledNode);
-            // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
-            meanDegree = (meanDegree * 2 + degree) / 3;
+            contractionSW.start();
+            nodeContractor.contractNode(polledNode);
             prepareGraph.setLevel(polledNode, level);
             level++;
+            contractionSW.stop();
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
                 // skipped nodes are already set to maxLevel
@@ -362,25 +269,21 @@ private void contractNodes() {
                 if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
-                if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage) {
-                    neighborSW.start();
-                    int oldPrio = oldPriorities[nn];
-                    int priority = oldPriorities[nn] = calculatePriority(nn);
+                if (neighborUpdate && rand.nextInt(100) < params.getNeighborUpdatePercentage()) {
+                    neighborUpdateSW.start();
+                    float oldPrio = oldPriorities[nn];
+                    float priority = oldPriorities[nn] = calculatePriority(nn);
                     if (priority != oldPrio)
                         sortedNodes.update(nn, oldPrio, priority);
 
-                    neighborSW.stop();
+                    neighborUpdateSW.stop();
                 }
 
                 prepareGraph.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
-        dijkstraTime += nodeContractor.getDijkstraSeconds();
-        periodTime += periodSW.getSeconds();
-        lazyTime += lazySW.getSeconds();
-        neighborTime += neighborSW.getSeconds();
-        logStats(counter, updateCounter);
+        logStats(updateCounter);
 
         // Preparation works only once so we can release temporary data.
         // The preparation object itself has to be intact to create the algorithm.
@@ -397,24 +300,20 @@ public long getDijkstraCount() {
         return nodeContractor.getDijkstraCount();
     }
 
-    public int getShortcuts() {
+    public long getShortcuts() {
         return nodeContractor.getAddedShortcutsCount();
     }
 
     public double getLazyTime() {
-        return lazyTime;
+        return lazyUpdateSW.getCurrentSeconds();
     }
 
     public double getPeriodTime() {
-        return periodTime;
-    }
-
-    public double getDijkstraTime() {
-        return dijkstraTime;
+        return periodicUpdateSW.getCurrentSeconds();
     }
 
     public double getNeighborTime() {
-        return neighborTime;
+        return neighborUpdateSW.getCurrentSeconds();
     }
 
     public Weighting getWeighting() {
@@ -422,59 +321,21 @@ public Weighting getWeighting() {
     }
 
     private String getTimesAsString() {
+        float totalTime = allSW.getCurrentSeconds();
+        float periodicUpdateTime = periodicUpdateSW.getCurrentSeconds();
+        float lazyUpdateTime = lazyUpdateSW.getCurrentSeconds();
+        float neighborUpdateTime = neighborUpdateSW.getCurrentSeconds();
+        float contractionTime = contractionSW.getCurrentSeconds();
+        float otherTime = totalTime - (periodicUpdateTime + lazyUpdateTime + neighborUpdateTime + contractionTime);
+        // dijkstra time is included in the others
+        float dijkstraTime = nodeContractor.getDijkstraSeconds();
         return String.format(Locale.ROOT,
-                "t(dijk): %6.2f, t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f",
-                dijkstraTime, periodTime, lazyTime, neighborTime);
-    }
-
-    /**
-     * Calculates the priority of a node v without changing the graph. Warning: the calculated
-     * priority must NOT depend on priority(v) and therefore findShortcuts should also not depend on
-     * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
-     * lead to a slowish or even endless loop.
-     */
-    private int calculatePriority(int node) {
-        nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
-        NodeContractor.CalcShortcutsResult calcShortcutsResult = nodeContractor.calcShortcutCount(node);
-
-        // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
-        //
-        // every adjNode has an 'original edge' number associated. initially it is r=1
-        // when a new shortcut is introduced then r of the associated edges is summed up:
-        // r(u,w)=r(u,v)+r(v,w) now we can define
-        // originalEdgesCount = (v) := sum_{ (u,w)  shortcuts(v) } of r(u, w)
-        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
-
-        // # lowest influence on preparation speed or shortcut creation count
-        // (but according to paper should speed up queries)
-        //
-        // number of already contracted neighbors of v
-        int contractedNeighbors = 0;
-        int degree = 0;
-        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(node);
-        while (iter.next()) {
-            degree++;
-            if (iter.isShortcut())
-                contractedNeighbors++;
-        }
-
-        // from shortcuts we can compute the edgeDifference
-        // # low influence: with it the shortcut creation is slightly faster
-        //
-        // |shortcuts(v)|  |{(u, v) | v uncontracted}|  |{(v, w) | v uncontracted}|
-        // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
-        // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
-        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
-
-        // according to the paper do a simple linear combination of the properties to get the priority.
-        // this is the current optimum for unterfranken:
-        return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
+                "t(total): %6.2f,  t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f, t(contr): %6.2f, t(other) : %6.2f, t(dijk): %6.2f",
+                totalTime, periodicUpdateTime, lazyUpdateTime, neighborUpdateTime, contractionTime, otherTime, dijkstraTime);
     }
 
-    private int getMaxVisitedNodesEstimate() {
-        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
-        // the node contraction order and requires re-optimizing the parameters of the graph contraction
-        return (int) meanDegree * 100;
+    private float calculatePriority(int node) {
+        return nodeContractor.calculatePriority(node);
     }
 
     @Override
@@ -482,12 +343,109 @@ public String toString() {
         return "prepare|dijkstrabi|ch";
     }
 
-    private void logStats(long counter, int updateCounter) {
+    private void logStats(int updateCounter) {
         logger.info(String.format(Locale.ROOT,
-                "%10s, updates: %2d, nodes: %10s, shortcuts: %10s, dijkstras: %10s, %s, meanDegree: %2d, %s, %s",
-                nf(counter), updateCounter, nf(sortedNodes.getSize()),
-                nf(nodeContractor.getAddedShortcutsCount()), nf(nodeContractor.getDijkstraCount()),
-                getTimesAsString(), (long) meanDegree, nodeContractor.getPrepareAlgoMemoryUsage(),
+                "nodes: %10s, shortcuts: %10s, updates: %2d, checked-nodes: %10s, %s, %s, %s",
+                nf(sortedNodes.getSize()),
+                nf(nodeContractor.getAddedShortcutsCount()),
+                updateCounter,
+                nf(checkCounter),
+                getTimesAsString(),
+                nodeContractor.getStatisticsString(),
                 Helper.getMemInfo()));
     }
+
+    private static class Params {
+        /**
+         * Specifies how often periodic updates will happen. The higher the value the longer the preparation takes
+         * but the less shortcuts are produced.
+         */
+        private int periodicUpdatesPercentage;
+        /**
+         * Specifies when lazy updates will happen, measured relative to all existing nodes. 100 means always.
+         */
+        private int lastNodesLazyUpdatePercentage;
+        /**
+         * Specifies how often neighbor updates will happen. 100 means always.
+         */
+        private int neighborUpdatePercentage;
+        /**
+         * Defines how many nodes (percentage) should be contracted. Less nodes means slower query but
+         * faster contraction.
+         */
+        private int nodesContractedPercentage;
+        /**
+         * Specifies how often a log message should be printed. Specify something around 20 (20% of the
+         * start nodes).
+         */
+        private int logMessagesPercentage;
+
+        static Params forTraversalMode(TraversalMode traversalMode) {
+            if (traversalMode.isEdgeBased()) {
+                throw new IllegalArgumentException("Contraction Hierarchies are not supported for edge-based traversal yet");
+            } else {
+                return new Params(20, 10, 20, 100, 20);
+            }
+        }
+
+        private Params(int periodicUpdatesPercentage, int lastNodesLazyUpdatePercentage, int neighborUpdatePercentage,
+                       int nodesContractedPercentage, int logMessagesPercentage) {
+            setPeriodicUpdatesPercentage(periodicUpdatesPercentage);
+            setLastNodesLazyUpdatePercentage(lastNodesLazyUpdatePercentage);
+            setNeighborUpdatePercentage(neighborUpdatePercentage);
+            setNodesContractedPercentage(nodesContractedPercentage);
+            setLogMessagesPercentage(logMessagesPercentage);
+        }
+
+        int getPeriodicUpdatesPercentage() {
+            return periodicUpdatesPercentage;
+        }
+
+        void setPeriodicUpdatesPercentage(int periodicUpdatesPercentage) {
+            checkPercentage(PERIODIC_UPDATES, periodicUpdatesPercentage);
+            this.periodicUpdatesPercentage = periodicUpdatesPercentage;
+        }
+
+        int getLastNodesLazyUpdatePercentage() {
+            return lastNodesLazyUpdatePercentage;
+        }
+
+        void setLastNodesLazyUpdatePercentage(int lastNodesLazyUpdatePercentage) {
+            checkPercentage(LAST_LAZY_NODES_UPDATES, lastNodesLazyUpdatePercentage);
+            this.lastNodesLazyUpdatePercentage = lastNodesLazyUpdatePercentage;
+        }
+
+        int getNeighborUpdatePercentage() {
+            return neighborUpdatePercentage;
+        }
+
+        void setNeighborUpdatePercentage(int neighborUpdatePercentage) {
+            checkPercentage(NEIGHBOR_UPDATES, neighborUpdatePercentage);
+            this.neighborUpdatePercentage = neighborUpdatePercentage;
+        }
+
+        int getNodesContractedPercentage() {
+            return nodesContractedPercentage;
+        }
+
+        void setNodesContractedPercentage(int nodesContractedPercentage) {
+            checkPercentage(CONTRACTED_NODES, nodesContractedPercentage);
+            this.nodesContractedPercentage = nodesContractedPercentage;
+        }
+
+        int getLogMessagesPercentage() {
+            return logMessagesPercentage;
+        }
+
+        void setLogMessagesPercentage(int logMessagesPercentage) {
+            checkPercentage(LOG_MESSAGES, logMessagesPercentage);
+            this.logMessagesPercentage = logMessagesPercentage;
+        }
+
+        private void checkPercentage(String name, int value) {
+            if (value < 0 || value > 100) {
+                throw new IllegalArgumentException(name + " has to be in [0, 100], to disable it use 0");
+            }
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
index 73357047a2..bf42c1f9a4 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
@@ -61,8 +61,6 @@
     // one node has an associated landmark information ('one landmark row'): the forward and backward weight
     private long LM_ROW_LENGTH;
     private int landmarks;
-    private final int FROM_OFFSET;
-    private final int TO_OFFSET;
     private final DataAccess landmarkWeightDA;
     /* every subnetwork has its own landmark mapping but the count of landmarks is always the same */
     private final List<int[]> landmarkIDs;
@@ -74,15 +72,11 @@
     private Weighting lmSelectionWeighting;
     private final TraversalMode traversalMode;
     private boolean initialized;
-    private int minimumNodes = 500_000;
+    private int minimumNodes;
     private final SubnetworkStorage subnetworkStorage;
     private List<LandmarkSuggestion> landmarkSuggestions = Collections.emptyList();
     private SpatialRuleLookup ruleLookup;
     private boolean logDetails = false;
-    /**
-     * 'to' and 'from' fit into 32 bit => 16 bit for each of them => 65536
-     */
-    static final long PRECISION = 1 << 16;
 
     public LandmarkStorage(GraphHopperStorage graph, Directory dir, final Weighting weighting, int landmarks) {
         this.graph = graph;
@@ -117,12 +111,14 @@ public String toString() {
         this.landmarks = landmarks;
         // one short per landmark and two directions => 2*2 byte
         this.LM_ROW_LENGTH = landmarks * 4;
-        this.FROM_OFFSET = 0;
-        this.TO_OFFSET = 2;
         this.landmarkIDs = new ArrayList<>();
         this.subnetworkStorage = new SubnetworkStorage(dir, "landmarks_" + name);
     }
 
+    public int getVersion() {
+        return 1;
+    }
+
     /**
      * Specify the maximum possible value for your used area. With this maximum weight value you can influence the storage
      * precision for your weights that help A* finding its way to the goal. The same value is used for all subnetworks.
@@ -214,8 +210,8 @@ public void createLandmarks() {
         this.landmarkWeightDA.create(2000);
         this.landmarkWeightDA.ensureCapacity(maxBytes);
 
-        for (long pointer = 0; pointer < maxBytes; pointer += 2) {
-            landmarkWeightDA.setShort(pointer, (short) SHORT_INFINITY);
+        for (long pointer = 0; pointer < maxBytes; pointer += 4) {
+            landmarkWeightDA.setInt(pointer, (DELTA_INF << FROM_WEIGHT_BITS) | FROM_WEIGHT_INF);
         }
 
         String additionalInfo = "";
@@ -246,14 +242,14 @@ public void createLandmarks() {
 
         byte[] subnetworks = new byte[graph.getNodes()];
         Arrays.fill(subnetworks, (byte) UNSET_SUBNETWORK);
-        EdgeFilter tarjanFilter = new DefaultEdgeFilter(encoder, false, true);
+        EdgeFilter tarjanFilter = DefaultEdgeFilter.outEdges(encoder);
         IntHashSet blockedEdges = new IntHashSet();
 
         // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
         if (ruleLookup != null && ruleLookup.size() > 0) {
             StopWatch sw = new StopWatch().start();
             blockedEdges = findBorderEdgeIds(ruleLookup);
-            tarjanFilter = new BlockedEdgesFilter(encoder, false, true, blockedEdges);
+            tarjanFilter = new BlockedEdgesFilter(encoder, true, false, blockedEdges);
             if (logDetails)
                 LOGGER.info("Made " + blockedEdges.size() + " edges inaccessible. Calculated country cut in " + sw.stop().getSeconds() + "s, " + Helper.getMemInfo());
         }
@@ -308,12 +304,14 @@ public void createLandmarks() {
             }
         }
 
-        landmarkWeightDA.setHeader(0 * 4, graph.getNodes());
+        // make backward incompatible to force rebuilt (pre 0.11 releases had nodes count at 0)
+        landmarkWeightDA.setHeader(0 * 4, getVersion());
         landmarkWeightDA.setHeader(1 * 4, landmarks);
         landmarkWeightDA.setHeader(2 * 4, subnetworkCount);
         if (factor * DOUBLE_MLTPL > Integer.MAX_VALUE)
             throw new UnsupportedOperationException("landmark weight factor cannot be bigger than Integer.MAX_VALUE " + factor * DOUBLE_MLTPL);
         landmarkWeightDA.setHeader(3 * 4, (int) Math.round(factor * DOUBLE_MLTPL));
+        landmarkWeightDA.setHeader(4 * 4, graph.getNodes());
 
         // serialize fast byte[] into DataAccess
         subnetworkStorage.create(graph.getNodes());
@@ -407,9 +405,9 @@ private boolean createLandmarksForSubnetwork(final int startNode, final byte[] s
             int lmNodeId = tmpLandmarkNodeIds[lmIdx];
             LandmarkExplorer explorer = new LandmarkExplorer(graph, this, weighting, traversalMode, true);
             explorer.setStartNode(lmNodeId);
-            explorer.setFilter(blockedEdges, false, true);
+            explorer.setFilter(blockedEdges, true, false);
             explorer.runAlgo();
-            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH, FROM_OFFSET);
+            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH);
 
             // set subnetwork id to all explored nodes, but do this only for the first landmark
             if (lmIdx == 0) {
@@ -419,9 +417,9 @@ private boolean createLandmarksForSubnetwork(final int startNode, final byte[] s
 
             explorer = new LandmarkExplorer(graph, this, weighting, traversalMode, false);
             explorer.setStartNode(lmNodeId);
-            explorer.setFilter(blockedEdges, true, false);
+            explorer.setFilter(blockedEdges, false, true);
             explorer.runAlgo();
-            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH, TO_OFFSET);
+            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH);
 
             if (lmIdx == 0) {
                 if (explorer.setSubnetworks(subnetworks, subnetworkId))
@@ -479,17 +477,14 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {
      * a node ID but the internal index of the landmark array.
      */
     int getFromWeight(int landmarkIndex, int node) {
-        int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + FROM_OFFSET)
-                & 0x0000FFFF;
-        assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
-        if (res == SHORT_INFINITY)
-            // TODO can happen if endstanding oneway
-            // we should set a 'from' value to SHORT_MAX if the 'to' value was already set to find real bugs
-            // and what to return? Integer.MAX_VALUE i.e. convert to Double.pos_infinity upstream?
-            return SHORT_MAX;
+        //only the right bits of this integer store the backward value
+        int res = landmarkWeightDA.getInt((long) node * LM_ROW_LENGTH + landmarkIndex * 4) & FROM_WEIGHT_INF;
+
+        if (res == FROM_WEIGHT_INF)
+            return Integer.MAX_VALUE;
         // throw new IllegalStateException("Do not call getFromWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
-        // TODO if(res == MAX) fallback to beeline approximation!?
 
+        assert res >= 0 : "Negative backward weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
         return res;
     }
 
@@ -497,40 +492,87 @@ int getFromWeight(int landmarkIndex, int node) {
      * @return the weight from the specified node to the landmark (specified *as index*)
      */
     int getToWeight(int landmarkIndex, int node) {
-        int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + TO_OFFSET)
-                & 0x0000FFFF;
-        assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
-        if (res == SHORT_INFINITY)
-            return SHORT_MAX;
-//            throw new IllegalStateException("Do not call getToWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
+        int res = landmarkWeightDA.getInt((long) node * LM_ROW_LENGTH + landmarkIndex * 4);
+
+        //the left bits of "res" store the difference between forward and backward value
+        int delta = res >> FROM_WEIGHT_BITS;
 
+        if (delta == DELTA_INF)
+            return Integer.MAX_VALUE;
+        // throw new IllegalStateException("Do not call getToWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
+
+        //the right bits of "res" store the backward value
+        int from = res & FROM_WEIGHT_INF;
+
+        if (from == FROM_WEIGHT_INF) {
+            from = DELTA_INF + 1;
+        }
+
+        //to get the forward value you have to add the backward to the delta value
+        res = from + delta;
+
+        assert res >= 0 : "Negative forward weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
         return res;
     }
 
-    // Short.MAX_VALUE = 2^15-1 but we have unsigned short so we need 2^16-1
-    private static final int SHORT_INFINITY = Short.MAX_VALUE * 2 + 1;
-    // We have large values that do not fit into a short, use a specific maximum value
-    private static final int SHORT_MAX = SHORT_INFINITY - 1;
+    // 'to' and 'from' fit into 32 bit => 16 bit for each of them => 65536
+    static final long PRECISION = 1 << 16;
+    /* This value sets the amount of bits used to store the backward weight.
+    The rest of overall 32 bits stores the difference between forward and backward weight*/
+    private static final int FROM_WEIGHT_BITS = 18;
+    // The backward weight is unsigned --> 2^x - 1
+    private static final int FROM_WEIGHT_INF = (int) Math.pow(2, FROM_WEIGHT_BITS) - 1;
+    // This value will be used if the backward weight is too large
+    private static final int FROM_WEIGHT_MAX = FROM_WEIGHT_INF - 1;
+    /* The difference between forward and backward weight is signed
+    --> 2^(31-x) - 1 instead of 2^(32-x) - 1*/
+    private static final int DELTA_INF = (int) Math.pow(2, 31 - FROM_WEIGHT_BITS) - 1;
+    // This value will be used if the difference between these weights is too large and forward > backward
+    private static final int DELTA_MAX = DELTA_INF - 1;
+    // This value will be used if the difference between these weights is too large and forward < backward
+    private static final int DELTA_MIN = -DELTA_INF - 1;
 
     /**
-     * @return false if the value capacity was reached and instead of the real value the SHORT_MAX was stored.
+     * @return false if the value capacity was reached and instead of the real value the MAX was stored.
      */
-    final boolean setWeight(long pointer, double value) {
+    final boolean setWeight(int lmIdx, int nodeId, long rowSize, double value, boolean from) {
         double tmpVal = value / factor;
         if (tmpVal > Integer.MAX_VALUE)
-            throw new UnsupportedOperationException("Cannot store infinity explicitely, pointer=" + pointer + ", value: " + value);
+            throw new UnsupportedOperationException("Cannot store infinity explicitly, landmark: " + lmIdx + ", node: " + nodeId + ", value: " + value);
 
-        if (tmpVal >= SHORT_MAX) {
-            landmarkWeightDA.setShort(pointer, (short) SHORT_MAX);
-            return false;
+        if (from) {
+            if (tmpVal >= FROM_WEIGHT_MAX) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_INF << FROM_WEIGHT_BITS) | FROM_WEIGHT_MAX);
+                return false;
+            } else {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_INF << FROM_WEIGHT_BITS) | (int) tmpVal);
+                return true;
+            }
         } else {
-            landmarkWeightDA.setShort(pointer, (short) tmpVal);
-            return true;
+            int fromWeight = getFromWeight(lmIdx, nodeId);
+            int delta;
+            if (fromWeight == Integer.MAX_VALUE) {
+                fromWeight = FROM_WEIGHT_INF;
+                delta = (int) tmpVal - DELTA_INF + 1;
+            } else {
+                delta = (int) tmpVal - fromWeight;
+            }
+
+            if (delta >= DELTA_MAX) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_MAX << FROM_WEIGHT_BITS) | fromWeight);
+                return false;
+            } else if (delta <= DELTA_MIN) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_MIN << FROM_WEIGHT_BITS) | fromWeight);
+                return false;
+            } else {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (delta << FROM_WEIGHT_BITS) | fromWeight);
+                return true;
+            }
         }
     }
 
     boolean isInfinity(long pointer) {
-        return ((int) landmarkWeightDA.getShort(pointer) & 0x0000FFFF) == SHORT_INFINITY;
+        return (landmarkWeightDA.getInt(pointer) & FROM_WEIGHT_INF) == FROM_WEIGHT_INF;
     }
 
     int calcWeight(EdgeIteratorState edge, boolean reverse) {
@@ -661,9 +703,13 @@ public boolean loadExisting() {
             if (!subnetworkStorage.loadExisting())
                 throw new IllegalStateException("landmark weights loaded but not the subnetworks!?");
 
-            int nodes = landmarkWeightDA.getHeader(0 * 4);
+            int version = landmarkWeightDA.getHeader(0 * 4);
+            if (version != getVersion())
+                throw new IllegalArgumentException("Cannot load landmark data due to incompatible version. Storage used version: " + version + ", expected: " + getVersion());
+            int nodes = landmarkWeightDA.getHeader(4 * 4);
             if (nodes != graph.getNodes())
                 throw new IllegalArgumentException("Cannot load landmark data as written for different graph storage with " + nodes + " nodes, not " + graph.getNodes());
+
             landmarks = landmarkWeightDA.getHeader(1 * 4);
             int subnetworks = landmarkWeightDA.getHeader(2 * 4);
             factor = landmarkWeightDA.getHeader(3 * 4) / DOUBLE_MLTPL;
@@ -728,7 +774,7 @@ public LandmarkExplorer(Graph g, LandmarkStorage lms, Weighting weighting, Trave
             super(g, weighting, tMode);
             this.lms = lms;
             this.from = from;
-            // set one of the bi directions as already finished            
+            // set one of the bi directions as already finished
             if (from)
                 finishedTo = true;
             else
@@ -737,8 +783,15 @@ public LandmarkExplorer(Graph g, LandmarkStorage lms, Weighting weighting, Trave
             setUpdateBestPath(false);
         }
 
-        public void setFilter(IntHashSet set, boolean bwd, boolean fwd) {
-            EdgeFilter ef = new BlockedEdgesFilter(flagEncoder, bwd, fwd, set);
+        public void setStartNode(int startNode) {
+            if (from)
+                initFrom(startNode, 0);
+            else
+                initTo(startNode, 0);
+        }
+
+        void setFilter(IntHashSet set, boolean fwd, boolean bwd) {
+            EdgeFilter ef = new BlockedEdgesFilter(flagEncoder, fwd, bwd, set);
             outEdgeExplorer = graph.createEdgeExplorer(ef);
             inEdgeExplorer = graph.createEdgeExplorer(ef);
         }
@@ -755,13 +808,6 @@ public int getLastNode() {
             return lastNode;
         }
 
-        public void setStartNode(int startNode) {
-            if (from)
-                initFrom(startNode, 0);
-            else
-                initTo(startNode, 0);
-        }
-
         public void runAlgo() {
             super.runAlgo();
         }
@@ -777,7 +823,7 @@ public boolean finished() {
             }
         }
 
-        public boolean setSubnetworks(final byte[] subnetworks, final int subnetworkId) {
+        boolean setSubnetworks(final byte[] subnetworks, final int subnetworkId) {
             if (subnetworkId > 127)
                 throw new IllegalStateException("Too many subnetworks " + subnetworkId);
 
@@ -805,7 +851,7 @@ public boolean apply(int nodeId, SPTEntry value) {
             return failed.get();
         }
 
-        public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSize, final int offset) {
+        public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSize) {
             IntObjectMap<SPTEntry> map = from ? bestWeightMapFrom : bestWeightMapTo;
             final AtomicInteger maxedout = new AtomicInteger(0);
             final Map.Entry<Double, Double> finalMaxWeight = new MapEntry<>(0d, 0d);
@@ -813,7 +859,7 @@ public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSiz
             map.forEach(new IntObjectProcedure<SPTEntry>() {
                 @Override
                 public void apply(int nodeId, SPTEntry b) {
-                    if (!lms.setWeight(nodeId * rowSize + lmIdx * 4 + offset, b.weight)) {
+                    if (!lms.setWeight(lmIdx, nodeId, rowSize, b.weight, from)) {
                         maxedout.incrementAndGet();
                         finalMaxWeight.setValue(Math.max(b.weight, finalMaxWeight.getValue()));
                     }
@@ -822,8 +868,8 @@ public void apply(int nodeId, SPTEntry b) {
 
             if ((double) maxedout.get() / map.size() > 0.1) {
                 LOGGER.warn("landmark " + lmIdx + " (" + nodeAccess.getLatitude(lmNodeId) + "," + nodeAccess.getLongitude(lmNodeId) + "): " +
-                        "too many weights were maxed out (" + maxedout.get() + "/" + map.size() + "). Use a bigger factor than " + lms.factor
-                        + ". For example use the following in the config.properties: weighting=" + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
+                        "too many " + (from ? "backward" : "delta") + " weights were maxed out (" + maxedout.get() + "/" + map.size() + "). Factor is too small " + lms.factor
+                        + ". To fix this increase maximum in config.yml: prepare.lm.weighting: " + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
             }
         }
     }
@@ -838,7 +884,7 @@ public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o
         }
     };
 
-    static GHPoint createPoint(Graph graph, int nodeId) {
+    private static GHPoint createPoint(Graph graph, int nodeId) {
         return new GHPoint(graph.getNodeAccess().getLatitude(nodeId), graph.getNodeAccess().getLongitude(nodeId));
     }
 
@@ -862,7 +908,7 @@ public boolean accept(EdgeIteratorState edgeState) {
         private final boolean fwd;
         private final boolean bwd;
 
-        public BlockedEdgesFilter(FlagEncoder encoder, boolean bwd, boolean fwd, IntHashSet blockedEdges) {
+        public BlockedEdgesFilter(FlagEncoder encoder, boolean fwd, boolean bwd, IntHashSet blockedEdges) {
             this.encoder = encoder;
             this.bwd = bwd;
             this.fwd = fwd;
@@ -888,4 +934,4 @@ public String toString() {
             return encoder.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java b/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
index afec484f93..785bd91fbe 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
@@ -130,7 +130,7 @@ public void doSpecificWork() {
         lms.createLandmarks();
         lms.flush();
 
-        LOGGER.info("Calculating landmarks for " + (lms.getSubnetworksWithLandmarks() - 1) + " subnetworks took:" + sw.stop().getSeconds() + " => "
+        LOGGER.info("Calculated landmarks for " + (lms.getSubnetworksWithLandmarks() - 1) + " subnetworks, took:" + sw.stop().getSeconds() + " => "
                 + lms.getLandmarksAsGeoJSON() + ", stored weights:" + lms.getLandmarkCount()
                 + ", nodes:" + graph.getNodes() + ", " + Helper.getMemInfo());
     }
diff --git a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
index 9189113f73..61abc73a61 100644
--- a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
@@ -205,7 +205,7 @@ String toString(FlagEncoder encoder, EdgeIterator iter) {
      */
     int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
         StopWatch sw = new StopWatch(bothFilter.getEncoder() + " findComponents").start();
-        final EdgeFilter outFilter = new DefaultEdgeFilter(bothFilter.getEncoder(), false, true);
+        final EdgeFilter outFilter = DefaultEdgeFilter.outEdges(bothFilter.getEncoder());
 
         // partition graph into strongly connected components using Tarjan's algorithm        
         TarjansSCCAlgorithm tarjan = new TarjansSCCAlgorithm(ghStorage, outFilter, true);
@@ -288,7 +288,7 @@ boolean detectNodeRemovedForAllEncoders(EdgeExplorer edgeExplorerAllEdges, int n
         FlagEncoder encoder;
 
         public PrepEdgeFilter(FlagEncoder encoder) {
-            super(encoder);
+            super(encoder, true, true);
             this.encoder = encoder;
         }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index 792ec42aa4..d3ca91b2ed 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -77,7 +77,7 @@ public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationInd
 
         TourStrategy strategy = new MultiPointTour(new Random(seed), distanceInMeter, roundTripPointCount, initialHeading);
         queryResults = new ArrayList<>(2 + strategy.getNumberOfGeneratedPoints());
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
         QueryResult startQR = locationIndex.findClosest(start.lat, start.lon, edgeFilter);
         if (!startQR.isValid())
             throw new PointNotFoundException("Cannot find point 0: " + start, 0);
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index ea9651f65c..9df3034e10 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -59,23 +59,19 @@ public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex l
         if (points.size() < 2)
             throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
 
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
         queryResults = new ArrayList<>(points.size());
         for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
             GHPoint point = points.get(placeIndex);
-            QueryResult res;
-            if (ghRequest.hasPointHints()) {
-                res = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
-                if (!res.isValid()) {
-                    res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-                }
-            } else {
-                res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            }
-            if (!res.isValid())
+            QueryResult qr = null;
+            if (ghRequest.hasPointHints())
+                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
+            if (qr == null || !qr.isValid())
+                qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!qr.isValid())
                 ghResponse.addError(new PointNotFoundException("Cannot find point " + placeIndex + ": " + point, placeIndex));
 
-            queryResults.add(res);
+            queryResults.add(qr);
         }
 
         return queryResults;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 9fb185cbb4..cdaac8d6b0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -70,9 +70,6 @@
     // This value determines the maximal possible speed of any road regardless the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
-    /* processing properties (to be initialized lazy when needed) */
-    protected EdgeExplorer edgeOutExplorer;
-    protected EdgeExplorer edgeInExplorer;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
@@ -224,8 +221,10 @@ public int defineRelationBits(int index, int shift) {
 
     /**
      * Parse tags on nodes. Node tags can add to speed (like traffic_signals) where the value is
-     * strict negative or blocks access (like a barrier), then the value is strict positive.This
+     * strict negative or blocks access (like a barrier), then the value is strictly positive. This
      * method is called in the second parsing step.
+     *
+     * @return encoded values or 0 if not blocking or no value stored
      */
     public long handleNodeTags(ReaderNode node) {
         // absolute barriers always block
@@ -487,7 +486,7 @@ protected double getFerrySpeed(ReaderWay way) {
             }
 
         if (durationInHours == 0) {
-            if(estimatedLength != null && estimatedLength.doubleValue() <= 300)
+            if (estimatedLength != null && estimatedLength.doubleValue() <= 300)
                 return speedEncoder.factor / 2;
             // unknown speed -> put penalty on ferry transport
             return UNKNOWN_DURATION_FERRY_SPEED;
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 9e57a52aed..639c3167f2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -87,7 +87,9 @@ protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCo
         potentialBarriers.add("gate");
         // potentialBarriers.add("lift_gate");
         potentialBarriers.add("swing_gate");
+        potentialBarriers.add("cattle_grid");
 
+        absoluteBarriers.add("fence");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index afa6634888..33c41d4283 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -83,7 +83,9 @@ public CarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         potentialBarriers.add("lift_gate");
         potentialBarriers.add("kissing_gate");
         potentialBarriers.add("swing_gate");
+        potentialBarriers.add("cattle_grid");
 
+        absoluteBarriers.add("fence");
         absoluteBarriers.add("bollard");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index f4d1572fd1..29f598fd3c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -27,19 +27,29 @@
     private final boolean fwd;
     private FlagEncoder encoder;
 
-    /**
-     * Creates an edges filter which accepts both direction of the specified vehicle.
-     */
-    public DefaultEdgeFilter(FlagEncoder encoder) {
-        this(encoder, true, true);
-    }
-
-    public DefaultEdgeFilter(FlagEncoder encoder, boolean bwd, boolean fwd) {
+    protected DefaultEdgeFilter(FlagEncoder encoder, boolean fwd, boolean bwd) {
         this.encoder = encoder;
         this.bwd = bwd;
         this.fwd = fwd;
     }
 
+    public static DefaultEdgeFilter outEdges(FlagEncoder flagEncoder) {
+        return new DefaultEdgeFilter(flagEncoder, true, false);
+    }
+
+    public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
+        return new DefaultEdgeFilter(flagEncoder, false, true);
+    }
+
+    /**
+     * Accepts all edges that are either forward or backward for the given flag encoder.
+     * Edges where neither one of the flags is enabled will still not be accepted. If you need to retrieve all edges
+     * regardless of their encoding use {@link EdgeFilter#ALL_EDGES} instead.
+     */
+    public static DefaultEdgeFilter allEdges(FlagEncoder flagEncoder) {
+        return new DefaultEdgeFilter(flagEncoder, true, true);
+    }
+
     @Override
     public final boolean accept(EdgeIteratorState iter) {
         return fwd && iter.isForward(encoder) || bwd && iter.isBackward(encoder);
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index f95e5a108a..90b64a75c7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -44,7 +44,7 @@
  */
 public class EncodingManager {
     private static final String ERR = "Encoders are requesting %s bits, more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags=8";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags: 8";
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<>();
     private final int bitsForEdgeFlags;
     private final int bitsForTurnFlags = 8 * 4;
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index a6162ea6c2..1ee6af1314 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -93,7 +93,9 @@ public FootFlagEncoder(int speedBits, double speedFactor) {
         sidewalkValues.add("right");
 
         setBlockByDefault(false);
+        absoluteBarriers.add("fence");
         potentialBarriers.add("gate");
+        potentialBarriers.add("cattle_grid");
 
         safeHighwayTags.add("footway");
         safeHighwayTags.add("path");
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java b/core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
similarity index 56%
rename from reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java
rename to core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
index a90263c55b..9e1bf9fd9d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EverythingButPt.java
+++ b/core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
@@ -15,22 +15,30 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
+package com.graphhopper.routing.util;
 
-package com.graphhopper.reader.gtfs;
-
-import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.util.EdgeIteratorState;
 
-class EverythingButPt implements EdgeFilter {
+public class IgnoreNodeFilter implements EdgeFilter {
+    private int avoidNode;
+    private CHGraph graph;
+    private int maxLevel;
 
-    PtFlagEncoder encoder;
+    public IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
+        this.graph = chGraph;
+        this.maxLevel = maxLevel;
+    }
 
-    EverythingButPt(PtFlagEncoder encoder) {
-        this.encoder = encoder;
+    public IgnoreNodeFilter setAvoidNode(int node) {
+        this.avoidNode = node;
+        return this;
     }
 
     @Override
-    public boolean accept(EdgeIteratorState edgeState) {
-        return encoder.getEdgeType(edgeState.getFlags()) == GtfsStorage.EdgeType.HIGHWAY;
+    public final boolean accept(EdgeIteratorState iter) {
+        // ignore if it is skipNode or adjNode is already contracted
+        int node = iter.getAdjNode();
+        return avoidNode != node && graph.getLevel(node) == maxLevel;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
index 6550054f93..2e8d59375f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
@@ -21,8 +21,7 @@
 import com.graphhopper.debatty.java.stringsimilarity.JaroWinkler;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 import java.util.regex.Pattern;
 
 import static com.graphhopper.util.Helper.toLowerCase;
@@ -46,34 +45,64 @@
  */
 public class NameSimilarityEdgeFilter implements EdgeFilter {
 
-    private static final Pattern NON_WORD_CHAR = Pattern.compile("[^\\p{L}]+");
-    private final double JARO_WINKLER_ACCEPT_FACTOR = .79;
-    private final JaroWinkler jaroWinkler = new JaroWinkler();
 
+    private static final Map<String, String> DEFAULT_REWRITE_MAP = new HashMap<String, String>() {{
+        // two char words will be ignored but ignore certain longer phrases (or rename them)
+        for (String remove : Arrays.asList(
+                "ally", "alley",
+                "arc", "arcade",
+                "bvd", "bvd.", "boulevard",
+                "av.", "avenue", "avenida",
+                "calle",
+                "cl.", "close",
+                "crescend", "cres", "cres.",
+                "rd.", "road",
+                "ln.", "lane",
+                "pde.", "pde", "parade",
+                "pl.", "place", "plaza",
+                "str.", "str", "strae", "strasse", "st.", "street", "strada",
+                "sq.", "square",
+                "tr.", "track",
+                "via")) {
+            put(remove, "");
+        }
+    }};
+    private static final Pattern NON_WORD_CHAR = Pattern.compile("[^\\p{L}]+");
+    private static final JaroWinkler jaroWinkler = new JaroWinkler();
+    private static final double JARO_WINKLER_ACCEPT_FACTOR = .9;
     private final EdgeFilter edgeFilter;
     private final String pointHint;
+    private final Map<String, String> rewriteMap;
 
     public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint) {
+        this(edgeFilter, pointHint, DEFAULT_REWRITE_MAP);
+    }
+
+    /**
+     * @param rewriteMap maps abreviations to its longer form
+     */
+    public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint, Map<String, String> rewriteMap) {
         this.edgeFilter = edgeFilter;
-        this.pointHint = prepareName(pointHint == null ? "" : pointHint);
+        this.rewriteMap = rewriteMap;
+        this.pointHint = prepareName(removeRelation(pointHint == null ? "" : pointHint));
     }
 
     /**
      * Removes any characters in the String that we don't care about in the matching procedure
-     * TODO: Remove common street names like: street, road, avenue?
+     * TODO Currently limited to certain 'western' languages
      */
     private String prepareName(String name) {
-        // TODO make this better, also split at ',' and others?
-        // TODO This limits the approach to certain 'western' languages
         // \s = A whitespace character: [ \t\n\x0B\f\r]
         String[] arr = name.split("\\s");
-        String tmp;
         List<String> list = new ArrayList<>(arr.length);
         for (int i = 0; i < arr.length; i++) {
-            tmp = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
-            // Ignore matching short frases like, de, rue, st, etc.
-            if (!tmp.isEmpty() && tmp.length() > 3) {
-                list.add(tmp);
+            String rewrite = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
+            String tmp = rewriteMap.get(rewrite);
+            if (tmp != null)
+                rewrite = tmp;
+            // Ignore matching short frases like de, la, ...
+            if (!rewrite.isEmpty() && rewrite.length() > 2) {
+                list.add(rewrite);
             }
         }
         return listToString(list);
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
index 3cd31c3e89..07dcbb99a0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
@@ -4,7 +4,7 @@
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Polygon;
-import com.vividsolutions.jts.geom.Geometry;
+import org.locationtech.jts.geom.Geometry;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -51,8 +51,8 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
             List<Polygon> borders = new ArrayList<>();
             for (int i = 0; i < jsonFeature.getGeometry().getNumGeometries(); i++) {
                 Geometry poly = jsonFeature.getGeometry().getGeometryN(i);
-                if (poly instanceof com.vividsolutions.jts.geom.Polygon)
-                    borders.add(Polygon.create((com.vividsolutions.jts.geom.Polygon) poly));
+                if (poly instanceof org.locationtech.jts.geom.Polygon)
+                    borders.add(Polygon.create((org.locationtech.jts.geom.Polygon) poly));
                 else
                     throw new IllegalArgumentException("Geometry for " + id + " (" + i + ") not supported " + poly.getClass().getSimpleName());
             }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java
new file mode 100644
index 0000000000..f6f07184f0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java
@@ -0,0 +1,38 @@
+package com.graphhopper.routing.util.spatialrules;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FlagEncoderFactory;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.shapes.BBox;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Helper class to build the spatial rule index
+ *
+ * @author Robin Boldt
+ */
+public class SpatialRuleLookupHelper {
+
+    private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupHelper.class);
+
+    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, BBox maxBounds, JsonFeatureCollection jsonFeatureCollection) {
+        final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
+        logger.info("Set spatial rule lookup with " + index.size() + " rules");
+        final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
+        graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
+            @Override
+            public FlagEncoder createFlagEncoder(String name, PMap configuration) {
+                if (name.equals(GENERIC)) {
+                    return new DataFlagEncoder(configuration).setSpatialRuleLookup(index);
+                }
+
+                return oldFEF.createFlagEncoder(name, configuration);
+            }
+        });
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
deleted file mode 100644
index cbfce2c9a6..0000000000
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.search;
-
-import com.graphhopper.util.shapes.GHPlace;
-
-import java.util.List;
-
-/**
- * Interface to convert from place names to points.
- * <p>
- *
- * @author Peter Karich
- */
-public interface Geocoding {
-    /**
-     * Returns a list of matching points for the specified place query string.
-     */
-    List<GHPlace> names2places(GHPlace... place);
-}
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 34e4d5e827..e5b7cdf08e 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -40,9 +40,9 @@
     protected int header[] = new int[(HEADER_OFFSET - 20) / 4];
     protected String name;
     protected int segmentSizeInBytes = SEGMENT_SIZE_DEFAULT;
-    protected transient int segmentSizePower;
-    protected transient int indexDivisor;
-    protected transient boolean closed = false;
+    protected int segmentSizePower;
+    protected int indexDivisor;
+    protected boolean closed = false;
 
     public AbstractDataAccess(String name, String location, ByteOrder order) {
         byteOrder = order;
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 7b129a6e20..de5ea92815 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -27,12 +27,13 @@
 import com.graphhopper.search.NameIndex;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
-
-import static com.graphhopper.util.Helper.nf;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Locale;
+
+import static com.graphhopper.util.Helper.nf;
+
 /**
  * The base graph handles nodes and edges file format. It can be used with different Directory
  * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
@@ -93,8 +94,8 @@ public BaseGraph(Directory dir, final EncodingManager encodingManager, boolean w
         this.bitUtil = BitUtil.get(dir.getByteOrder());
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
-        this.nodes = dir.find("nodes");
-        this.edges = dir.find("edges");
+        this.nodes = dir.find("nodes", DAType.getPreferredInt(dir.getDefaultType()));
+        this.edges = dir.find("edges", DAType.getPreferredInt(dir.getDefaultType()));
         this.listener = listener;
         this.edgeAccess = new EdgeAccess(edges, bitUtil) {
             @Override
@@ -376,6 +377,35 @@ String toDetailsString() {
                 + "bounds:" + bounds;
     }
 
+    public void debugPrint() {
+        final int printMax = 100;
+        System.out.println("nodes:");
+        String formatNodes = "%12s | %12s | %12s | %12s \n";
+        System.out.format(Locale.ROOT, formatNodes, "#", "N_EDGE_REF", "N_LAT", "N_LON");
+        NodeAccess nodeAccess = getNodeAccess();
+        for (int i = 0; i < Math.min(nodeCount, printMax); ++i) {
+            System.out.format(Locale.ROOT, formatNodes, i, edgeAccess.getEdgeRef(i), nodeAccess.getLat(i), nodeAccess.getLon(i));
+        }
+        if (nodeCount > printMax) {
+            System.out.format(Locale.ROOT, " ... %d more nodes\n", nodeCount - printMax);
+        }
+        System.out.println("edges:");
+        String formatEdges = "%12s | %12s | %12s | %12s | %12s | %12s | %12s \n";
+        System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS");
+        for (int i = 0; i < Math.min(edgeCount, printMax); ++i) {
+            System.out.format(Locale.ROOT, formatEdges, i,
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEA),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEB),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKA),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKB),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_DIST),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_FLAGS));
+        }
+        if (edgeCount > printMax) {
+            System.out.printf(Locale.ROOT, " ... %d more edges", edgeCount - printMax);
+        }
+    }
+
     void flush() {
         setNodesHeader();
         setEdgesHeader();
@@ -703,12 +733,12 @@ void inPlaceNodeRemove(int removeNodeCount) {
                 setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
 
-        // clear N_EDGE_REF
-        initNodeRefs((nodeCount - removeNodeCount) * nodeEntryBytes, nodeCount * nodeEntryBytes);
-
         if (removeNodeCount >= nodeCount)
             throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
 
+        // clear N_EDGE_REF
+        initNodeRefs(((long) nodeCount - removeNodeCount) * nodeEntryBytes, (long) nodeCount * nodeEntryBytes);
+
         // we do not remove the invalid edges => edgeCount stays the same!
         nodeCount -= removeNodeCount;
 
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index aef56b34ab..e83cdb3524 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -69,8 +69,8 @@
         this.weighting = w;
         this.baseGraph = baseGraph;
         final String name = AbstractWeighting.weightingToFileName(w);
-        this.nodesCH = dir.find("nodes_ch_" + name);
-        this.shortcuts = dir.find("shortcuts_" + name);
+        this.nodesCH = dir.find("nodes_ch_" + name, DAType.getPreferredInt(dir.getDefaultType()));
+        this.shortcuts = dir.find("shortcuts_" + name, DAType.getPreferredInt(dir.getDefaultType()));
         this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil) {
             @Override
             final EdgeIterable createSingleEdge(EdgeFilter edgeFilter) {
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index 000e00741d..10f7e79e3b 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -89,6 +89,15 @@ else if (dataAccess.contains("RAM_STORE"))
         return type;
     }
 
+    /**
+     * This method returns RAM_INT if the specified type is in-memory.
+     */
+    public static DAType getPreferredInt(DAType type) {
+        if (type.isInMemory())
+            return type.isStoring() ? RAM_INT_STORE : RAM_INT;
+        return type;
+    }
+
     /**
      * Memory mapped or purely in memory? default is HEAP
      */
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 7b7f720a8e..4aeb1879fe 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.util.Helper;
-
 import java.io.File;
 import java.nio.ByteOrder;
 import java.util.Collection;
@@ -52,20 +50,6 @@ public GHDirectory(String _location, DAType defaultType) {
         File dir = new File(location);
         if (dir.exists() && !dir.isDirectory())
             throw new RuntimeException("file '" + dir + "' exists but is not a directory");
-
-        // set default access to integer based
-        // improves performance on server side, 10% faster for queries and preparation
-        if (this.defaultType.isInMemory()) {
-            if (isStoring()) {
-                put("location_index", DAType.RAM_INT_STORE);
-                put("edges", DAType.RAM_INT_STORE);
-                put("nodes", DAType.RAM_INT_STORE);
-            } else {
-                put("location_index", DAType.RAM_INT);
-                put("edges", DAType.RAM_INT);
-                put("nodes", DAType.RAM_INT);
-            }
-        }
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index fea30d5225..c79a854572 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -29,7 +29,7 @@
 import com.graphhopper.util.shapes.Circle;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Shape;
-import com.vividsolutions.jts.geom.*;
+import org.locationtech.jts.geom.*;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 78f6620161..c80ddf64c9 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -25,10 +25,7 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.shapes.BBox;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
+import java.util.*;
 
 /**
  * This class manages all storage related methods and delegates the calls to the associated graphs.
@@ -248,10 +245,7 @@ public boolean loadExisting() {
             String dim = properties.get("graph.dimension");
             baseGraph.loadExisting(dim);
 
-            String loadedCHWeightings = properties.get("graph.ch.weightings");
-            String configuredCHWeightings = getCHWeightings().toString();
-            if (!loadedCHWeightings.equals(configuredCHWeightings))
-                throw new IllegalStateException("Configured graph.ch.weightings: " + configuredCHWeightings + " is not equal to loaded " + loadedCHWeightings);
+            checkIfConfiguredAndLoadedWeightingsCompatible();
 
             for (CHGraphImpl cg : chGraphs) {
                 if (!cg.loadExisting())
@@ -263,6 +257,37 @@ public boolean loadExisting() {
         return false;
     }
 
+    private void checkIfConfiguredAndLoadedWeightingsCompatible() {
+        String loadedStr = properties.get("graph.ch.weightings");
+        List<String> loaded = parseList(loadedStr);
+        List<Weighting> configured = getCHWeightings();
+        if (configured.isEmpty() && !loaded.isEmpty()) {
+            throw new IllegalStateException("You loaded a CH graph, but you did not specify graph.ch.weightings");
+        }
+        for (Weighting w : configured) {
+            if (!loaded.contains(w.toString())) {
+                throw new IllegalStateException("Configured weighting: " + w.toString() + " is not contained in loaded weightings " + loadedStr + ".\n" +
+                        "You configured graph.ch.weightings: " + configured);
+            }
+        }
+    }
+
+    /**
+     * parses a string like [a,b,c]
+     */
+    private List<String> parseList(String listStr) {
+        String trimmed = listStr.trim();
+        String[] items = trimmed.substring(1, trimmed.length() - 1).split(",");
+        List<String> result = new ArrayList<>();
+        for (String item : items) {
+            String s = item.trim();
+            if (!s.isEmpty()) {
+                result.add(s);
+            }
+        }
+        return result;
+    }
+
     @Override
     public void flush() {
         for (CHGraphImpl cg : chGraphs) {
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index e3c1c47da8..ec52bcf005 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -19,16 +19,25 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.MappedByteBuffer;
 import java.nio.channels.FileChannel;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.StringTokenizer;
 
 /**
  * A DataAccess implementation using a memory-mapped file, i.e. a facility of the
@@ -49,6 +58,9 @@
  * @author Michael Zilske
  */
 public final class MMapDataAccess extends AbstractDataAccess {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(MMapDataAccess.class);
+
     private final boolean allowWrites;
     private RandomAccessFile raFile;
     private List<ByteBuffer> segments = new ArrayList<>();
@@ -58,6 +70,92 @@
         this.allowWrites = allowWrites;
     }
 
+    public static boolean jreIsMinimumJava9() {
+        final StringTokenizer st = new StringTokenizer(System.getProperty("java.specification.version"), ".");
+        int JVM_MAJOR_VERSION = Integer.parseInt(st.nextToken());
+        int JVM_MINOR_VERSION;
+        if (st.hasMoreTokens()) {
+            JVM_MINOR_VERSION = Integer.parseInt(st.nextToken());
+        } else {
+            JVM_MINOR_VERSION = 0;
+        }
+        return JVM_MAJOR_VERSION > 1 || (JVM_MAJOR_VERSION == 1 && JVM_MINOR_VERSION >= 9);
+    }
+
+    public static void cleanMappedByteBuffer(final ByteBuffer buffer) {
+        // TODO avoid reflection on every call
+        try {
+            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                @Override
+                public Object run() throws Exception {
+                    if (jreIsMinimumJava9()) {
+                        // >=JDK9 class sun.misc.Unsafe { void invokeCleaner(ByteBuffer buf) }
+                        final Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
+                        // fetch the unsafe instance and bind it to the virtual MethodHandle
+                        final Field f = unsafeClass.getDeclaredField("theUnsafe");
+                        f.setAccessible(true);
+                        final Object theUnsafe = f.get(null);
+                        final Method method = unsafeClass.getDeclaredMethod("invokeCleaner", ByteBuffer.class);
+                        try {
+                            method.invoke(theUnsafe, buffer);
+                            return null;
+                        } catch (Throwable t) {
+                            throw new RuntimeException(t);
+                        }
+                    }
+
+                    if (buffer.getClass().getSimpleName().equals("MappedByteBufferAdapter")) {
+                        if (!Constants.ANDROID)
+                            throw new RuntimeException("MappedByteBufferAdapter only supported for Android at the moment");
+
+                        // For Android 4.1 call ((MappedByteBufferAdapter)buffer).free() see #914
+                        Class<?> directByteBufferClass = Class.forName("java.nio.MappedByteBufferAdapter");
+                        callBufferFree(buffer, directByteBufferClass);
+                    } else {
+                        // <=JDK8 class DirectByteBuffer { sun.misc.Cleaner cleaner(Buffer buf) }
+                        //        then call sun.misc.Cleaner.clean
+                        final Class<?> directByteBufferClass = Class.forName("java.nio.DirectByteBuffer");
+                        try {
+                            final Method dbbCleanerMethod = directByteBufferClass.getMethod("cleaner");
+                            dbbCleanerMethod.setAccessible(true);
+                            // call: cleaner = ((DirectByteBuffer)buffer).cleaner()
+                            final Object cleaner = dbbCleanerMethod.invoke(buffer);
+                            if (cleaner != null) {
+                                final Class<?> cleanerMethodReturnType = dbbCleanerMethod.getReturnType();
+                                final Method cleanMethod = cleanerMethodReturnType.getDeclaredMethod("clean");
+                                cleanMethod.setAccessible(true);
+                                // call: ((sun.misc.Cleaner)cleaner).clean()
+                                cleanMethod.invoke(cleaner);
+                            }
+                        } catch (NoSuchMethodException ex2) {
+                            if (Constants.ANDROID)
+                                // For Android 5.1.1 call ((DirectByteBuffer)buffer).free() see #933
+                                callBufferFree(buffer, directByteBufferClass);
+                            else
+                                // ignore if method cleaner or clean is not available
+                                LOGGER.warn("NoSuchMethodException | " + System.getProperty("java.version"), ex2);
+                        }
+                    }
+
+                    return null;
+                }
+            });
+        } catch (PrivilegedActionException e) {
+            throw new RuntimeException("Unable to unmap the mapped buffer", e);
+        }
+    }
+
+    private static void callBufferFree(ByteBuffer buffer, Class<?> directByteBufferClass)
+            throws InvocationTargetException, IllegalAccessException {
+        try {
+            final Method dbbFreeMethod = directByteBufferClass.getMethod("free");
+            dbbFreeMethod.setAccessible(true);
+            dbbFreeMethod.invoke(buffer);
+        } catch (NoSuchMethodException ex2) {
+            LOGGER.warn("NoSuchMethodException | " + System.getProperty("java.version"), ex2);
+        }
+    }
+
     private void initRandomAccessFile() {
         if (raFile != null) {
             return;
@@ -362,7 +460,7 @@ public int getSegments() {
     private void clean(int from, int to) {
         for (int i = from; i < to; i++) {
             ByteBuffer bb = segments.get(i);
-            Helper.cleanMappedByteBuffer(bb);
+            cleanMappedByteBuffer(bb);
             segments.set(i, null);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index 067bf08da4..c9b69f8e88 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -107,7 +107,7 @@ public synchronized boolean tryLock() {
             // on-the-fly: make sure directory exists
             if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
-                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot be created to place lock file there: " + lockFile);
             }
 
             if (!lockDir.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 1fbdf7b734..a6e0fc93ce 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -77,8 +77,7 @@ public DataAccess copyTo(DataAccess da) {
     public RAMDataAccess create(long bytes) {
         if (segments.length > 0)
             throw new IllegalThreadStateException("already created");
-
-        // initialize transient values
+        
         setSegmentSize(segmentSizeInBytes);
         ensureCapacity(Math.max(10 * 4, bytes));
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index f7a186970d..6079d4053e 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -34,7 +34,7 @@
     private int[][] segments = new int[0][];
     private boolean closed = false;
     private boolean store;
-    private transient int segmentSizeIntsPower;
+    private int segmentSizeIntsPower;
 
     RAMIntDataAccess(String name, String location, boolean store, ByteOrder order) {
         super(name, location, order);
@@ -78,7 +78,6 @@ public RAMIntDataAccess create(long bytes) {
         if (segments.length > 0)
             throw new IllegalThreadStateException("already created");
 
-        // initialize transient values
         setSegmentSize(segmentSizeInBytes);
         ensureCapacity(Math.max(10 * 4, bytes));
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 1e18b1eece..a337175edc 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -76,7 +76,7 @@ public synchronized boolean tryLock() {
             // make sure directory exists, do it on-the-fly (not possible when setLockDir is called)
             if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
-                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot be created to place lock file there: " + lockFile);
             }
 
             // this test can only be performed after the dir has created!
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 9167d29a63..fc825aa082 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
+import java.io.*;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -34,6 +34,9 @@
  * @author Peter Karich
  */
 public class StorableProperties implements Storable<StorableProperties> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(StorableProperties.class);
+
     private final Map<String, String> map = new LinkedHashMap<>();
     private final DataAccess da;
 
@@ -189,4 +192,32 @@ boolean check(String key, int vers, boolean silent) {
     public synchronized String toString() {
         return da.toString();
     }
+
+    static void loadProperties(Map<String, String> map, Reader tmpReader) throws IOException {
+        BufferedReader reader = new BufferedReader(tmpReader);
+        String line;
+        try {
+            while ((line = reader.readLine()) != null) {
+                if (line.startsWith("//") || line.startsWith("#")) {
+                    continue;
+                }
+
+                if (Helper.isEmpty(line)) {
+                    continue;
+                }
+
+                int index = line.indexOf("=");
+                if (index < 0) {
+                    LOGGER.warn("Skipping configuration at line:" + line);
+                    continue;
+                }
+
+                String field = line.substring(0, index);
+                String value = line.substring(index + 1);
+                map.put(field.trim(), value.trim());
+            }
+        } finally {
+            reader.close();
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
index 02fb3cfcb3..7a8c04940b 100644
--- a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
+++ b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
@@ -91,7 +91,7 @@ public long applyChanges(EncodingManager em, Collection<JsonFeature> features) {
 
     private long applyChange(JsonFeature jsonFeature, FlagEncoder encoder) {
         long updates = 0;
-        EdgeFilter filter = new DefaultEdgeFilter(encoder);
+        EdgeFilter filter = DefaultEdgeFilter.allEdges(encoder);
         GHIntHashSet edges = new GHIntHashSet();
         if (jsonFeature.hasGeometry()) {
             graphBrowser.fillEdgeIDs(edges, jsonFeature.getGeometry(), filter);
diff --git a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphResponse.java b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphResponse.java
index d714be89dc..29fef8401f 100644
--- a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphResponse.java
+++ b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphResponse.java
@@ -17,22 +17,19 @@
  */
 package com.graphhopper.storage.change;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
-
 /**
  * This class describes the changes that were applied to the graph, currently only used in GraphHopper.changeGraph
  *
  * @author Peter Karich
  */
 public class ChangeGraphResponse {
-    private final long updateCount;
+    private final long updates;
 
-    public ChangeGraphResponse(long updateCount) {
-        this.updateCount = updateCount;
+    public ChangeGraphResponse(long updates) {
+        this.updates = updates;
     }
 
-    @JsonProperty("updates")
-    public long getUpdateCount() {
-        return updateCount;
+    public long getUpdates() {
+        return updates;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index 43fa8b4d86..a95d49f0d7 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -49,7 +49,7 @@
      *
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      *                   node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:
-     *                   <pre>new DefaultEdgeFilter(footFlagEncoder);</pre>
+     *                   <pre>DefaultEdgeFilter.allEdges(footFlagEncoder);</pre>
      * @return An object containing the closest node and edge for the specified location. The node id
      * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
      * the method QueryResult.isValid will return false.
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index ad948ec8c5..7b0f3e4171 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -29,18 +29,10 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
-
-import java.util.ArrayList;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
+import java.util.*;
 
 /**
  * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
@@ -95,7 +87,7 @@ public LocationIndexTree(Graph g, Directory dir) {
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("location_index");
+        dataAccess = dir.find("location_index", DAType.getPreferredInt(dir.getDefaultType()));
     }
 
     public int getMinResolutionInMeter() {
@@ -571,13 +563,13 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
 
         return closestMatch;
     }
-    
+
     /**
      * Returns all edges that are within the specified radius around the queried position.
      * Searches at most 9 cells to avoid performance problems. Hence, if the radius is larger than
      * the cell width then not all edges might be returned.
-     * 
-     * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or 
+     * <p>
+     * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or
      * refactor so it can handle a radius larger than 9 tiles. Also remove reference to 'NClosest',
      * which is misleading, and don't always return at least one value. See map-matching #65.
      * TODO: tidy up logic - see comments in graphhopper #994.
@@ -585,7 +577,7 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
      * @param radius in meters
      */
     public List<QueryResult> findNClosest(final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter, double radius) {
+                                          final EdgeFilter edgeFilter, double radius) {
         // Return ALL results which are very close and e.g. within the GPS signal accuracy.
         // Also important to get all edges if GPS point is close to a junction.
         final double returnAllResultsWithin = distCalc.calcNormalizedDist(radius);
@@ -684,7 +676,7 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
 
         return queryResults;
     }
-    
+
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     interface InMemEntry {
         boolean isLeaf();
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
index a8562aaf12..c34596ee5a 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
@@ -19,6 +19,9 @@
 
 import static java.lang.Math.sqrt;
 
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+
 /**
  * Calculates the distance of two points or one point and an edge in euclidean space.
  * <p>
@@ -44,6 +47,10 @@ public double calcNormalizedDist(double dist) {
         return dist * dist;
     }
 
+    double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
+        return 1.;
+    }
+
     /**
      * Calculates in normalized meter
      */
@@ -58,4 +65,30 @@ public double calcNormalizedDist(double fromY, double fromX, double toY, double
     public String toString() {
         return "2D";
     }
+
+    @Override
+    public double calcCircumference(double lat) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public boolean isDateLineCrossOver(double lon1, double lon2) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public BBox createBBox(double lat, double lon, double radiusInMeter) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public GHPoint projectCoordinate(double latInDeg, double lonInDeg, double distanceInMeter,
+            double headingClockwiseFromNorth) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public boolean isCrossBoundary(double lon1, double lon2) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Helper7.java b/core/src/main/java/com/graphhopper/util/Helper7.java
deleted file mode 100644
index 1e94f55fb2..0000000000
--- a/core/src/main/java/com/graphhopper/util/Helper7.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util;
-
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
-/**
- * Put the usage of proprietary "sun" classes and after jdk6 classes into this class. To use Helper
- * class under Android as well.
- * <p>
- *
- * @author Peter Karich
- */
-public class Helper7 {
-
-    /**
-     * <code>true</code>, if this platform supports unmapping mmapped files.
-     */
-    public static final boolean UNMAP_SUPPORTED;
-
-    static {
-        boolean v;
-        try {
-            Class.forName("sun.misc.Cleaner");
-            Class.forName("java.nio.DirectByteBuffer")
-                    .getMethod("cleaner");
-            v = true;
-        } catch (Exception e) {
-            v = false;
-        }
-        UNMAP_SUPPORTED = v;
-    }
-
-    public static String getBeanMemInfo() {
-        java.lang.management.OperatingSystemMXBean mxbean = java.lang.management.ManagementFactory.getOperatingSystemMXBean();
-        com.sun.management.OperatingSystemMXBean sunmxbean = (com.sun.management.OperatingSystemMXBean) mxbean;
-        long freeMemory = sunmxbean.getFreePhysicalMemorySize();
-        long availableMemory = sunmxbean.getTotalPhysicalMemorySize();
-        return "free:" + freeMemory / Helper.MB + ", available:" + availableMemory / Helper.MB
-                + ", rfree:" + Runtime.getRuntime().freeMemory() / Helper.MB;
-    }
-
-    public static void close(XMLStreamReader r) {
-        try {
-            if (r != null) {
-                r.close();
-            }
-        } catch (XMLStreamException ex) {
-            throw new RuntimeException("Couldn't close xml reader", ex);
-        }
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 7ae523a2d7..6cc31fb525 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -157,25 +157,6 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         }
     }
 
-    /**
-     * Merges <code>otherDetails</code> into the <code>pathDetails</code>.
-     * <p>
-     * This method makes sure that Entry list around via points are merged correctly.
-     * See #1091 and the misplaced PathDetail after waypoints.
-     */
-    public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDetails) {
-        // Make sure that the PathDetail list is merged correctly at via points
-        if (!pathDetails.isEmpty() && !otherDetails.isEmpty()) {
-            PathDetail lastDetail = pathDetails.get(pathDetails.size() - 1);
-            if (lastDetail.getValue().equals(otherDetails.get(0).getValue())) {
-                lastDetail.setLast(otherDetails.get(0).getLast());
-                otherDetails.remove(0);
-            }
-        }
-
-        pathDetails.addAll(otherDetails);
-    }
-
     /**
      * This method iterates over all instructions and uses the available context to improve the instructions.
      * If the requests contains a heading, this method can transform the first continue to a u-turn if the heading
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index a597a096d1..8d7007cada 100644
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -25,7 +25,7 @@
  */
 public class StopWatch {
     private long lastTime;
-    private long nanoTime;
+    private long elapsedNanos;
     private String name = "";
 
     public StopWatch(String name) {
@@ -49,20 +49,32 @@ public StopWatch stop() {
         if (lastTime < 0)
             return this;
 
-        nanoTime += System.nanoTime() - lastTime;
+        elapsedNanos += System.nanoTime() - lastTime;
         lastTime = -1;
         return this;
     }
 
+    public float getSeconds() {
+        return elapsedNanos / 1e9f;
+    }
+
     /**
-     * @return the time delta in milliseconds
+     * returns the total elapsed time on this stopwatch without the need of stopping it
      */
-    public long getTime() {
-        return nanoTime / 1_000_000;
+    public float getCurrentSeconds() {
+        if (notStarted()) {
+            return 0;
+        }
+        long lastNanos = lastTime < 0 ? 0 : System.nanoTime() - lastTime;
+        return (elapsedNanos + lastNanos) / 1e9f;
+    }
+
+    public long getMillis() {
+        return elapsedNanos / 1_000_000;
     }
 
     public long getNanos() {
-        return nanoTime;
+        return elapsedNanos;
     }
 
     @Override
@@ -75,7 +87,7 @@ public String toString() {
         return str + "time:" + getSeconds();
     }
 
-    public float getSeconds() {
-        return nanoTime / 1e9f;
+    private boolean notStarted() {
+        return lastTime == 0 && elapsedNanos == 0;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java b/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
index a59ff7b26d..eeee952086 100644
--- a/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
@@ -17,7 +17,9 @@
  */
 package com.graphhopper.util.details;
 
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 
 import static com.graphhopper.util.Parameters.DETAILS.EDGE_ID;
 
@@ -36,13 +38,22 @@ public EdgeIdDetails() {
 
     @Override
     public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
-        if (edge.getEdge() != edgeId) {
-            edgeId = edge.getEdge();
+        int thisEdgeId = edgeId(edge);
+        if (thisEdgeId != edgeId) {
+            edgeId = thisEdgeId;
             return true;
         }
         return false;
     }
 
+    private int edgeId(EdgeIteratorState edge) {
+        if (edge instanceof VirtualEdgeIteratorState) {
+            return GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalTraversalKey());
+        } else {
+            return edge.getEdge();
+        }
+    }
+
     @Override
     public Object getCurrentValue() {
         return this.edgeId;
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
index 9f7213dff4..2001ff7a2e 100644
--- a/core/src/main/resources/com/graphhopper/util/ar.txt
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=
-continue_onto=%1$s   
+continue_onto=  %1$s 
 turn_left= 
 turn_right= 
 turn_slight_left=  
@@ -10,7 +10,7 @@ turn_sharp_left=  
 turn_sharp_right=  
 keep_left= 
 keep_right= 
-turn_onto=%1$s  %1$s
+turn_onto=%1$s  %2$s
 u_turn=  
 unknown=    '%1$s' 
 web.search_button=
@@ -20,7 +20,7 @@ web.to_hint=
 web.more_button=
 web.gpx_export_button=GPX 
 web.route_info=%1$s  %2$s
-web.pt_route_info=  %1$s   %2$s  (%3$s)
+web.pt_route_info=  %1$s  %2$s  (%3$s)
 web.pt_route_info_walking=  %1$s  (%2$s)
 web.locations_not_found=     
 web.bike=
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index 210a9028e7..14d2f3ac4a 100644
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -11,21 +11,21 @@ turn_sharp_right=gira just a la dreta
 keep_left=estigues a l'esquerra
 keep_right=estigues a la dreta
 turn_onto=%1$s per %2$s
-u_turn=dona la volta
+u_turn=fes la volta
 unknown=instrucci desconeguda %1$s
-web.search_button=Buscar
+web.search_button=Cerca
 web.from_hint=Des de
-web.via_hint=passant per
+web.via_hint=Passant per
 web.to_hint=Cap a
 web.more_button=ms
-web.gpx_export_button=Exportar GPX
+web.gpx_export_button=Exporta a GPX
 web.route_info=%1$s trigars %2$s
 web.pt_route_info=arriba a les %1$s amb %2$s transbordaments (%3$s)
 web.pt_route_info_walking=arriba caminant a les %1$s (%2$s)
 web.locations_not_found=No hi ha cap ruta. El dest no es troba dins l'rea.
 web.bike=Bicicleta
-web.racingbike=Bicicleta de carrera
-web.mtb=Bicicleta de montanya
+web.racingbike=Bicicleta de curses
+web.mtb=Bicicleta de muntanya
 web.car=Cotxe
 web.foot=A peu
 web.hike=Senderisme
@@ -35,7 +35,7 @@ web.truck=Cami
 web.staticlink=Enlla
 web.motorcycle=Motocicleta
 via=passant per
-finish=Has arribat !!
+finish=Has arribat!
 hour_abbr=h
 day_abbr=d
 min_abbr=min
@@ -52,10 +52,10 @@ paved=pavimentat
 unpaved=sense pavimentar
 stopover=passant per %1$s
 roundabout_enter=Entra a la rotonda
-roundabout_exit=A la rotonda, agafa la %1$s sortida
-roundabout_exit_onto=A la rotonda, agafa la sortida %1$s cap a %2$s
-total_ascend=%1$s pujada total
-total_descend=%1$s baixada total
+roundabout_exit=A la rotonda, agafa la %1$sa sortida
+roundabout_exit_onto=A la rotonda, agafa la %1$sa sortida cap a %2$s
+total_ascend=%1$s de pujada total
+total_descend=%1$s de baixada total
 way_contains_ford=hi ha un gual en el cam
 pt_start_trip=entra a %1$s
 pt_end_trip=surt de %1$s
@@ -63,17 +63,17 @@ pt_transfer_to=canvia a %1$s
 web.start_label=Punt d'inici
 web.intermediate_label=Punt intermig
 web.end_label=Punt final
-web.set_start=Definir com a punt d'inici
-web.set_intermediate=Definir com a punt intermig
-web.set_end=Definir com a punt final
-web.center_map=Centrar el mapa
-web.show_coords=Mostrar coordenades
+web.set_start=Defineix com a punt d'inici
+web.set_intermediate=Defineix com a punt intermig
+web.set_end=Defineix com a punt final
+web.center_map=Centra el mapa
+web.show_coords=Mostra les coordenades
 web.route=Ruta
-web.delete_from_route=Eliminar punt de la ruta
+web.delete_from_route=Suprimeix el punt de la ruta
 web.marker=Marcador
-web.gh_offline_info=API GraphHopper sense connexi ?
-web.refresh_button=Refrescar la plana
+web.gh_offline_info=L'API GraphHopper no t connexi ?
+web.refresh_button=Actualitza la pgina
 web.server_status=Estat
-web.zoom_in=Apropar
-web.zoom_out=Allunyar
+web.zoom_in=Apropa
+web.zoom_out=Allunya
 web.drag_to_reorder=Arrossega per canviar l'ordre
diff --git a/core/src/main/resources/com/graphhopper/util/eo.txt b/core/src/main/resources/com/graphhopper/util/eo.txt
index f18e6d98ce..f58d542327 100644
--- a/core/src/main/resources/com/graphhopper/util/eo.txt
+++ b/core/src/main/resources/com/graphhopper/util/eo.txt
@@ -11,8 +11,8 @@ turn_sharp_right=turniegu dekstren
 keep_left=veturu e maldekstra flanko
 keep_right=veturu e dekstra fllanko
 turn_onto=%1$s al %2$s
-u_turn=faru iradon U-forma
-unknown=nekonata instrukcio %1$s
+u_turn=turniu malantaen
+unknown=nekonata instrukcio %1$s
 web.search_button=Seri
 web.from_hint=El
 web.via_hint=Tra
diff --git a/core/src/main/resources/com/graphhopper/util/fa.txt b/core/src/main/resources/com/graphhopper/util/fa.txt
index 059df616f9..0dcbb3fb64 100644
--- a/core/src/main/resources/com/graphhopper/util/fa.txt
+++ b/core/src/main/resources/com/graphhopper/util/fa.txt
@@ -1,41 +1,41 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue=  
-continue_onto= %1$s  
+continue= 
+continue_onto= %1$s  
 turn_left=  
 turn_right=  
 turn_slight_left=   
 turn_slight_right=   
-turn_sharp_left=   
-turn_sharp_right=   
-keep_left=    
-keep_right=    
-turn_onto=  %1$s  %2$s  
-u_turn=   
-unknown=   '%1$s'
-web.search_button=
+turn_sharp_left=     
+turn_sharp_right=     
+keep_left=  
+keep_right=  
+turn_onto=%1$s   %2$s  
+u_turn= 
+unknown=  : '%1$s'
+web.search_button=
 web.from_hint=
-web.via_hint= 
+web.via_hint=  
 web.to_hint=
 web.more_button=
-web.gpx_export_button=   GPX
-web.route_info= %1$s   %2$s   
-web.pt_route_info=%2$s    %1$s   (%3$s)
-web.pt_route_info_walking=       %1$s   (%3$s)
-web.locations_not_found=  .     .
+web.gpx_export_button=   GPX
+web.route_info=%1$s %2$s  
+web.pt_route_info= %2$s    %1$s  (%3$s)
+web.pt_route_info_walking= %1$s    (%2$s)
+web.locations_not_found=  . ()     .
 web.bike=
 web.racingbike= 
 web.mtb= 
 web.car=
-web.foot=
-web.hike=
+web.foot=
+web.hike=
 web.small_truck=
 web.bus=
 web.truck=
-web.staticlink= 
+web.staticlink= 
 web.motorcycle=
-via= 
-finish=!
+via=  
+finish=  
 hour_abbr=
 day_abbr=
 min_abbr=
@@ -48,32 +48,32 @@ off_bike=   
 cycleway= 
 way=
 small_way= 
-paved=  
-unpaved=  
-stopover=  %1$s
-roundabout_enter=  
-roundabout_exit=   %1$s   
-roundabout_exit_onto=    %1$s  "%2$s"  
+paved=
+unpaved=
+stopover=  %1$s
+roundabout_enter=  
+roundabout_exit=    %1$s 
+roundabout_exit_onto=    %1$s  %2$s 
 total_ascend=  %1$s
 total_descend=  %1$s
-way_contains_ford=   
+way_contains_ford=     
 pt_start_trip= %1$s 
 pt_end_trip= %1$s  
 pt_transfer_to=   %1$s  
-web.start_label=
-web.intermediate_label= 
+web.start_label=
+web.intermediate_label= 
 web.end_label=
-web.set_start=   
-web.set_intermediate=    
-web.set_end=   
-web.center_map=     
-web.show_coords= 
+web.set_start=  
+web.set_intermediate=  
+web.set_end=  
+web.center_map=   
+web.show_coords= 
 web.route=
-web.delete_from_route=  
-web.marker=
+web.delete_from_route=   
+web.marker=
 web.gh_offline_info=   
-web.refresh_button= 
+web.refresh_button= 
 web.server_status=
-web.zoom_in=
+web.zoom_in=
 web.zoom_out=
-web.drag_to_reorder=  
+web.drag_to_reorder=   
diff --git a/core/src/main/resources/com/graphhopper/util/hu_HU.txt b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
index 0cde07e4b0..3dbd457649 100644
--- a/core/src/main/resources/com/graphhopper/util/hu_HU.txt
+++ b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
@@ -1,79 +1,79 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue=Haladjon tovbb
-continue_onto=%1$s haladjon tovbb
-turn_left=Forduljon balra
-turn_right=Forduljon jobbra
-turn_slight_left=Forduljon enyhn balra
-turn_slight_right=Forduljon enyhn jobbra
-turn_sharp_left=Forduljon lesen balra
-turn_sharp_right=Forduljon lesen jobbra
-keep_left=
-keep_right=
-turn_onto=%1$s forduljon be %2$s
-u_turn=
-unknown=
+continue=haladjon tovbb
+continue_onto=haladjon tovbb erre: %1$s
+turn_left=forduljon balra
+turn_right=forduljon jobbra
+turn_slight_left=forduljon enyhn balra
+turn_slight_right=forduljon enyhn jobbra
+turn_sharp_left=forduljon lesen balra
+turn_sharp_right=forduljon lesen jobbra
+keep_left=tartson balra
+keep_right=tartson jobbra
+turn_onto=%1$s erre: %2$s
+u_turn=forduljon meg
+unknown=ismeretlen jelztbla: %1$s
 web.search_button=Keress
-web.from_hint=Honnan
-web.via_hint=Keresztl
-web.to_hint=Hova
-web.more_button=Tbb
+web.from_hint=Innen
+web.via_hint=Ezen keresztl
+web.to_hint=Ide
+web.more_button=tovbb
 web.gpx_export_button=GPX export
-web.route_info=%1$s tart %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
-web.locations_not_found=tvonaltervezs nem lehetsges.A megadott hely(ek) nem tallhat(ak).
-web.bike=Bicikli
-web.racingbike=Verseny bicikli
-web.mtb=Terep bicikli
+web.route_info=%1$s ennyi ideig tart: %2$s
+web.pt_route_info=rkezs %1$s rakor, %2$s tszllssal (%3$s)
+web.pt_route_info_walking=rkezs %1$s rakor, csak gyalog (%2$s)
+web.locations_not_found=tvonaltervezs nem lehetsges. A megadott hely(ek) nem tallhat(k) meg a terleten.
+web.bike=Kerkpr
+web.racingbike=Versenykerkpr
+web.mtb=Hegyi kerkpr
 web.car=Aut
-web.foot=Gyalog
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
+web.foot=Gyalogos
+web.hike=Trzs
+web.small_truck=Kisteheraut
+web.bus=Busz
+web.truck=Teheraut
 web.staticlink=Statikus hivatkozs
-web.motorcycle=Motor
-via=t
-finish=Megrekezett!
+web.motorcycle=Motorkerkpr
+via=ezen t:
+finish=rkezs a clponthoz
 hour_abbr=ra
 day_abbr=nap
 min_abbr=perc
-km_abbr=kilomter
-m_abbr=mter
+km_abbr=km
+m_abbr=m
 mi_abbr=mrfld
-ft_abbr=lps
-road=Orszgt
-off_bike=Tolva folytathatja
-cycleway=Kerkpr t
-way=t
-small_way=
-paved=Kvezett t
-unpaved=Fldes t
-stopover=Meg kell llni %1$s
+ft_abbr=lb
+road=t
+off_bike=szlljon le a kerkprrl
+cycleway=kerkprt
+way=t
+small_way=gyalogt
+paved=burkolt t
+unpaved=burkolatlan t
+stopover=%1$s. tpont
 roundabout_enter=Hajtson be a krforgalomba
-roundabout_exit=Hagyja el a krfrgalmat, kihajt %1$s
-roundabout_exit_onto=Hagyja el a krfrgalmat, kihajt %1$s, aztn hajtson r %2$s
-total_ascend=
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
-web.drag_to_reorder=
+roundabout_exit=Hajtson ki a krforgalombl itt: %1$s. kijrat
+roundabout_exit_onto=Hajtson ki a krforgalombl itt: %1$s. kijrat, majd hajtson r erre: %2$s
+total_ascend=sszes szintemelkeds: %1$s
+total_descend=sszes szintcskkens: %1$s
+way_contains_ford=gzl van az tvonalon
+pt_start_trip=szlljon fel erre: %1$s
+pt_end_trip=szlljon le errl: %1$s
+pt_transfer_to=szlljon t erre: %1$s
+web.start_label=Induls
+web.intermediate_label=Kztes clpont
+web.end_label=Clpont
+web.set_start=Bellts kiindulsi pontnak
+web.set_intermediate=Bellts kztes clpontnak
+web.set_end=Bellts clpontnak
+web.center_map=Bellts a trkp kzppontjnak
+web.show_coords=Pozci megjelentse
+web.route=tvonal
+web.delete_from_route=Eltvolts az tvonalrl
+web.marker=Jell
+web.gh_offline_info=Lehet, hogy a GraphHopper API nem rhet el?
+web.refresh_button=Oldal frisstse
+web.server_status=llapot
+web.zoom_in=Nagyts
+web.zoom_out=Kicsinyts
+web.drag_to_reorder=Hzza el az trendezshez
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index b298978fc9..45593d315b 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -8,11 +8,11 @@ turn_slight_left=gira leggermente a sinistra
 turn_slight_right=gira leggermente a destra
 turn_sharp_left=gira nettamente a sinistra
 turn_sharp_right=gira nettamente a destra
-keep_left=
-keep_right=
+keep_left=tieni la sinistra
+keep_right=tieni la destra
 turn_onto=%1$s su %2$s
-u_turn=
-unknown=
+u_turn=fai una inversione a U
+unknown=sconosciuto %1$s
 web.search_button=Ricerca
 web.from_hint=Da
 web.via_hint=attraverso
@@ -20,8 +20,8 @@ web.to_hint=A
 web.more_button=altro
 web.gpx_export_button=Esporta GPX
 web.route_info=%1$s in %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=arrivato alle %1$s con %2$s trasferimenti (%3$s)
+web.pt_route_info_walking=arrivato alle %1$s solocamminando (%2$s)
 web.locations_not_found=Percorso non calcolabile. Localit non trovata(e) nell'area.
 web.bike=Bicicletta
 web.racingbike=Bici da corsa
@@ -56,10 +56,10 @@ roundabout_exit=Nella rotatoria, prendere l'uscita %1$s
 roundabout_exit_onto=Nella rotatoria, prendere l'uscita %1$s su %2$s
 total_ascend=%1$s di dislivello positivo
 total_descend=%1$s di dislivello negativo
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=c' un guado sulla strada
+pt_start_trip=prendi %1$s
+pt_end_trip=lascia %1$s
+pt_transfer_to=cambia con %1$s
 web.start_label=Partenza
 web.intermediate_label=Punto intermedio
 web.end_label=Arrivo
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index e2263fe924..b8ff9ff6b6 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -4,31 +4,31 @@ continue=continuar
 continue_onto=continue na %1$s
 turn_left=vire  esquerda
 turn_right=vire  direita
-turn_slight_left=vire  curva suave  esquerda
-turn_slight_right=vire  curva suave  direita
-turn_sharp_left=vire  curva acentuada  esquerda
-turn_sharp_right=vire  curva acentuada  direita
-keep_left=
-keep_right=
+turn_slight_left=curva suave  esquerda
+turn_slight_right=curva suave  direita
+turn_sharp_left=curva acentuada  esquerda
+turn_sharp_right=curva acentuada  direita
+keep_left=mantenha-se  esquerda
+keep_right=mantenha-se  direita
 turn_onto=%1$s na %2$s
-u_turn=
-unknown=
+u_turn=faa um retorno
+unknown=sinalizao desconhecida '%1$s'
 web.search_button=Pesquisar
 web.from_hint=De
 web.via_hint=Via
 web.to_hint=Para
 web.more_button=mais
 web.gpx_export_button=Exportar GPX
-web.route_info=%1$s ir levar %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
-web.locations_not_found=Rota impossvel. Localizao(es) no encontrada(s) na rea.
+web.route_info=%1$s levar %2$s
+web.pt_route_info=chega s %1$s com %2$s trocas (%3$s)
+web.pt_route_info_walking=chega s %1$s caminhando (%2$s)
+web.locations_not_found=Rota invivel. Localizao(es) no encontrada(s) na rea.
 web.bike=Bicicleta
 web.racingbike=Bicicleta de corrida
 web.mtb=Mountainbike
 web.car=Carro
 web.foot=A p
-web.hike=Caminhata
+web.hike=Caminhada
 web.small_truck=Caminho pequeno
 web.bus=nibus
 web.truck=Caminho
@@ -47,7 +47,7 @@ road=estrada
 off_bike=descer da bicicleta
 cycleway=ciclovia
 way=caminho
-small_way=caminho pequeno
+small_way=caminho curto
 paved=pavimentada
 unpaved=no pavimentada
 stopover=parada %1$s
@@ -57,16 +57,16 @@ roundabout_exit_onto=Na rotatria, saia na %1$s saida em direo a %2$s
 total_ascend=subida de %1$s
 total_descend=descida de %1$s
 way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=Inicio
+pt_start_trip=embarque %1$s
+pt_end_trip=desembarque %1$s
+pt_transfer_to=mude para %1$s
+web.start_label=Incio
 web.intermediate_label=Intermedirio
 web.end_label=Fim
-web.set_start=Definir como inicio
+web.set_start=Definir como incio
 web.set_intermediate=Definir como intermedirio
 web.set_end=Definir como fim
-web.center_map=Centralizar mapa aqui
+web.center_map=Centralizar o mapa aqui
 web.show_coords=Mostrar coordenadas
 web.route=Rota
 web.delete_from_route=Remover da rota
@@ -76,4 +76,4 @@ web.refresh_button=Recarregar pgina
 web.server_status=Status
 web.zoom_in=Ampliar
 web.zoom_out=Reduzir zoom
-web.drag_to_reorder=Arrastre para reordenar
+web.drag_to_reorder=Arraste para reordenar
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index f07afe968a..3a7cbe6891 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue= 
-continue_onto=  %1$s
+continue_onto=  %1$s
 turn_left= 
 turn_right= 
 turn_slight_left= 
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index a263e96c82..c1450f93b1 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -21,7 +21,7 @@ web.more_button=viac
 web.gpx_export_button=Export do GPX
 web.route_info=%1$s zaberie %2$s
 web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info_walking=prchod o %1$s iba chdzou (%2$s)
 web.locations_not_found=Navigovanie nie je mon. Umiestnenie nebolo njden v oblasti.
 web.bike=Bicykel
 web.racingbike=Cestn bicykel
@@ -56,10 +56,10 @@ roundabout_exit=Na kruhovom objazde, ho opustite cez %1$s. vjazd
 roundabout_exit_onto=Na kruhovom objazde, ho opustite cez %1$s. vjazd na %2$s
 total_ascend=%1$s celkov stpanie
 total_descend=%1$s celkov klesanie
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=popri ceste sa nachdza brod
+pt_start_trip=nastpte na linku %1$s
+pt_end_trip=vystpte z linky %1$s
+pt_transfer_to=prestpte na linku %1$s
 web.start_label=Zaiatok
 web.intermediate_label=Bod trasy
 web.end_label=Koniec
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
index 2aa3bb1187..e7930d5115 100644
--- a/core/src/main/resources/com/graphhopper/util/zh_CN.txt
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -30,7 +30,7 @@ web.car=
 web.foot=
 web.hike=
 web.small_truck=
-web.bus=
+web.bus=
 web.truck=
 web.staticlink=
 web.motorcycle=
@@ -47,7 +47,7 @@ road=
 off_bike=
 cycleway=
 way=
-small_way=
+small_way=
 paved=
 unpaved=
 stopover= %1$s
@@ -60,7 +60,7 @@ way_contains_ford=
 pt_start_trip=
 pt_end_trip=
 pt_transfer_to=
-web.start_label=
+web.start_label=
 web.intermediate_label=
 web.end_label=
 web.set_start=
@@ -68,12 +68,12 @@ web.set_intermediate=
 web.set_end=
 web.center_map=
 web.show_coords=
-web.route=
+web.route=
 web.delete_from_route=
-web.marker=
+web.marker=
 web.gh_offline_info=
 web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
+web.server_status=
+web.zoom_in=
+web.zoom_out=
 web.drag_to_reorder=
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index 6b4da6c7d6..3af796d31c 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -25,18 +25,64 @@
  * @author Peter Karich
  */
 public class GHTreeMapComposedTest {
+
+    private GHTreeMapComposed instance = new GHTreeMapComposed();
+
     @Test
     public void testInsert() {
-        GHTreeMapComposed instance = new GHTreeMapComposed();
-        instance.insert(1, 100);
+        instance.insert(1, 100.001f);
         assertEquals(1, instance.peekKey());
-        assertEquals(100, instance.peekValue());
+        assertEquals(100.001, instance.peekValue(), 1.e-4);
 
-        instance.insert(2, 99);
-        instance.insert(3, 101);
+        instance.insert(2, 99.7f);
+        instance.insert(3, 101.4f);
         assertEquals(2, instance.peekKey());
-        assertEquals(99, instance.peekValue());
+        assertEquals(99.7, instance.peekValue(), 1.e-4);
 
         assertEquals(2, instance.pollKey());
     }
+
+    @Test
+    public void testDifferentValuesSameKey() {
+        instance.insert(0, -4.0f);
+        instance.insert(0, -24.0f);
+        assertEquals(2, instance.getSize());
+        assertEquals(0, instance.peekKey());
+        assertEquals(-24.0f, instance.peekValue(), 1.e-4);
+
+        assertEquals(0, instance.pollKey());
+        assertEquals(0, instance.pollKey());
+    }
+
+    @Test
+    public void testDifferentKeysSameValue() {
+        instance.insert(0, -4.0f);
+        instance.insert(1, -4.0f);
+        assertEquals(2, instance.getSize());
+    }
+
+    @Test
+    public void testUpdate() {
+        instance.insert(34302, 26.25f);
+        instance.update(34302, 26.25f, 5.6f);
+        assertEquals(5.6f, instance.peekValue(), 1.e-4);
+        assertEquals(34302, instance.pollKey());
+    }
+
+    @Test
+    public void testUpdateDuplicateValues() {
+        instance.insert(34302, 26.25f);
+        instance.insert(160654, 26.25f);
+        instance.insert(34302, 26.25f);
+        instance.insert(160654, 26.25f);
+        assertEquals(2, instance.getSize());
+        instance.remove(34302, 26.25f);
+        assertEquals(1, instance.getSize());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testRemovingNonExistentKeyThrows() {
+        instance.insert(5, 1.1f);
+        instance.remove(5, 2.2f);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
index 2341a0b4b4..58c71daad2 100644
--- a/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
@@ -38,7 +38,7 @@
  */
 public class PrincetonReaderTest {
     private EncodingManager encodingManager = new EncodingManager("car");
-    private EdgeFilter carOutEdges = new DefaultEdgeFilter(encodingManager.getEncoder("car"), false, true);
+    private EdgeFilter carOutEdges = DefaultEdgeFilter.outEdges(encodingManager.getEncoder("car"));
 
     @Test
     public void testRead() {
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 608ff250df..3c3af34e5b 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
@@ -182,7 +183,7 @@ public void testCalcShortestPath() {
         GraphHopperStorage ghStorage = createTestStorage();
         RoutingAlgorithm algo = createAlgo(ghStorage);
         Path p = algo.calcPath(0, 7);
-        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
     }
 
@@ -194,7 +195,7 @@ public void testCalcShortestPath_sourceEqualsTarget() {
 
         RoutingAlgorithm algo = createAlgo(graph);
         Path p = algo.calcPath(0, 0);
-        assertEquals(p.toString(), Helper.createTList(0), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{0}), p.calcNodes());
         assertEquals(p.toString(), 0, p.getDistance(), 1.e-6);
     }
 
@@ -211,7 +212,7 @@ public void testSimpleAlternative() {
         graph.edge(4, 1, 9, true);
         Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
-        assertEquals(Helper.createTList(0, 2, 1, 4), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 2, 1, 4}), p.calcNodes());
     }
 
     @Test
@@ -224,7 +225,7 @@ public void testBidirectionalLinear() {
         graph.edge(4, 1, 9, true);
         Path p = createAlgo(graph).calcPath(3, 5);
         assertEquals(p.toString(), 28, p.getDistance(), 1e-4);
-        assertEquals(Helper.createTList(3, 2, 1, 4, 5), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{3, 2, 1, 4, 5}), p.calcNodes());
     }
 
     // see calc-fastest-graph.svg
@@ -234,7 +235,7 @@ public void testCalcFastestPath() {
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
         Path p1 = createAlgo(graphShortest, defaultOpts).
                 calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 5, 2, 3}), p1.calcNodes());
         assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
@@ -244,7 +245,7 @@ public void testCalcFastestPath() {
         initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest, opts).
                 calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4, 6, 7, 5, 3}), p2.calcNodes());
         assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
         assertEquals(p2.toString(), 111442, p2.getTime());
     }
@@ -299,7 +300,7 @@ public void testCalcFootPath() {
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
-        assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p1.calcNodes());
     }
 
     protected void initFootVsCar(Graph graph) {
@@ -394,14 +395,14 @@ public void testNoPathFound() {
     public void testWikipediaShortestPath() {
         GraphHopperStorage ghStorage = createWikipediaTestGraph();
         Path p = createAlgo(ghStorage).calcPath(0, 4);
-        assertEquals(p.toString(), Helper.createTList(0, 2, 5, 4), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 2, 5, 4}), p.calcNodes());
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
     }
 
     @Test
     public void testCalcIf1EdgeAway() {
         Path p = createAlgo(createTestStorage()).calcPath(1, 2);
-        assertEquals(Helper.createTList(1, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{1, 2}), p.calcNodes());
         assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
@@ -428,12 +429,12 @@ public void testBidirectional() {
         // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
-        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 7, 6, 8, 3, 4}), p.calcNodes());
         assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
         p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
-        assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{1, 2}), p.calcNodes());
         assertEquals(p.toString(), 10007.7, p.getDistance(), .1);
     }
 
@@ -497,7 +498,7 @@ public void testBidirectional2() {
         Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
-        assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 7, 6, 5, 4}), p.calcNodes());
     }
 
     @Test
@@ -508,8 +509,8 @@ public void testRekeyBugOfIntBinHeap() {
         assertEquals(12, p.calcNodes().size());
 
         IntIndexedContainer list = p.calcNodes();
-        if (!Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91).equals(list)
-                && !Helper.createTList(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list)) {
+        if (!IntArrayList.from(new int[]{36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91}).equals(list)
+                && !IntArrayList.from(new int[]{36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91}).equals(list)) {
             assertTrue("wrong locations: " + list.toString(), false);
         }
         assertEquals(66f, p.getDistance(), 1e-3);
@@ -520,14 +521,14 @@ public void testRekeyBugOfIntBinHeap() {
 
     public void testBug1(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(34, 36);
-        assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{34, 35, 36}), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
     }
 
     public void testCorrectWeight(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(45, 72);
-        assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{45, 44, 54, 64, 74, 73, 72}), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
 
@@ -552,7 +553,7 @@ public void testDirectedGraphBug1() {
         graph.edge(4, 2, 1, false);
 
         Path p = createAlgo(graph).calcPath(0, 2);
-        assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
@@ -567,7 +568,7 @@ public void testDirectedGraphBug2() {
         graph.edge(3, 1, 4, true);
 
         Path p = createAlgo(graph).calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 2, 3}), p.calcNodes());
     }
 
     // a-b-0-c-1
@@ -599,12 +600,12 @@ public void testWithCoordinates() {
         AlgorithmOptions opts = new AlgorithmOptions(DIJKSTRA_BI, weighting);
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
         Path p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(4, 0);
-        assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{4, 1, 0}), p.calcNodes());
         assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
         assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(2, 1);
-        assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{2, 0, 1}), p.calcNodes());
         assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
         assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
@@ -622,20 +623,20 @@ public void testViaEdges_FromEqualsTo() {
         // identical tower nodes
         Path p = calcPathViaQuery(ghStorage, 0.001, 0.000, 0.001, 0.000);
         assertTrue(p.isFound());
-        assertEquals(Helper.createTList(0), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0}), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // identical query points on edge
         p = calcPath(ghStorage, 0, 1, 0, 1);
         assertTrue(p.isFound());
-        assertEquals(Helper.createTList(8), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{8}), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // very close
         p = calcPathViaQuery(ghStorage, 0.00092, 0, 0.00091, 0);
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{8, 9}), p.calcNodes());
         assertEquals(p.toString(), 1.11, p.getDistance(), .1);
     }
 
@@ -646,12 +647,12 @@ public void testViaEdges_BiGraph() {
 
         // 0-7 to 4-3
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
-        assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{10, 7, 6, 8, 3, 9}), p.calcNodes());
         assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 7, 6, 8, 3, 9}), p.calcNodes());
         assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
@@ -659,7 +660,7 @@ public void testViaEdges_BiGraph() {
     public void testViaEdges_WithCoordinates() {
         GraphHopperStorage ghStorage = createTestStorage();
         Path p = calcPath(ghStorage, 0, 1, 2, 3);
-        assertEquals(Helper.createTList(8, 1, 2, 9), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{8, 1, 2, 9}), p.calcNodes());
         assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
@@ -683,17 +684,17 @@ public void testViaEdges_SpecialCases() {
 
         // 0-1 to 3-4
         Path p = calcPathViaQuery(graph, 0.00010, 0.00001, 0, 0.00009);
-        assertEquals(Helper.createTList(5, 1, 2, 3, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 1, 2, 3, 6}), p.calcNodes());
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
         p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
-        assertEquals(Helper.createTList(5, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6}), p.calcNodes());
         assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
-        assertEquals(p.toString(), Helper.createTList(6, 2, 5), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(new int[]{6, 2, 5}), p.calcNodes());
         assertEquals(p.toString(), 12.57, p.getDistance(), .1);
     }
 
@@ -703,7 +704,7 @@ public void testQueryGraphAndFastest() {
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
         initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery(weighting, graph, 0.002, 0.0005, 0.0017, 0.0031);
-        assertEquals(Helper.createTList(8, 1, 5, 3, 9), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{8, 1, 5, 3, 9}), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
     }
 
@@ -853,7 +854,7 @@ public String getName() {
         initEleGraph(graph);
         Path p = createAlgo(graph, opts).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
-        assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4, 6, 10}), p.calcNodes());
 
         AlgorithmOptions fakeOpts = AlgorithmOptions.start().weighting(fakeWeighting).build();
         graph = createGHStorage(encodingManager, Arrays.asList(fakeOpts.getWeighting()), true);
@@ -864,7 +865,7 @@ public String getName() {
         RoutingAlgorithmFactory factory = createFactory(graph, fakeOpts);
         QueryGraph qGraph = new QueryGraph(getGraph(graph, fakeWeighting)).lookup(from, to);
         p = factory.createAlgo(qGraph, fakeOpts).calcPath(from.getClosestNode(), to.getClosestNode());
-        assertEquals(Helper.createTList(12, 0, 1, 2, 11, 7, 10, 13), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{12, 0, 1, 2, 11, 7, 10, 13}), p.calcNodes());
         assertEquals(37009621, p.getTime());
         assertEquals(616827, p.getDistance(), 1);
         assertEquals(493462, p.getWeight(), 1);
@@ -893,7 +894,7 @@ public void testMultipleVehicles_issue548() {
         RoutingAlgorithm algoCar = createFactory(ghStorage, carOptions).
                 createAlgo(getGraph(ghStorage, carWeighting), carOptions);
         Path p1 = algoCar.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 1, 5, 6, 7), p1.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 5, 6, 7}), p1.calcNodes());
         assertEquals(p1.toString(), 26000, p1.getDistance(), 1e-6);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
index 4922512723..c80f0eefad 100644
--- a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.routing.AlternativeRoute.AlternativeBidirSearch;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -28,7 +29,6 @@
 import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.Helper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -123,12 +123,12 @@ public void testCalcAlternatives() throws Exception {
         assertEquals(bestPath.calcNodes(), bestAlt.calcNodes());
         assertEquals(bestPath.getWeight(), bestAlt.getWeight(), 1e-3);
 
-        assertEquals(Helper.createTList(5, 6, 3, 4), bestAlt.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), bestAlt.calcNodes());
 
         // Note: here plateau is longer, even longer than optimum, but path is longer
         // so which alternative is better? longer plateau.weight with bigger path.weight or smaller path.weight with smaller plateau.weight
         // assertEquals(Helper.createTList(5, 1, 9, 2, 3, 4), secondAlt.calcNodes());
-        assertEquals(Helper.createTList(5, 6, 7, 8, 4), secondAlt.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 8, 4}), secondAlt.calcNodes());
         assertEquals(1667.9, secondAlt.getWeight(), .1);
     }
 
@@ -149,9 +149,9 @@ public void testCalcAlternatives2() throws Exception {
         assertEquals(3, pathInfos.size());
 
         // result is sorted based on the plateau to full weight ratio
-        assertEquals(Helper.createTList(5, 6, 3, 4), pathInfos.get(0).getPath().calcNodes());
-        assertEquals(Helper.createTList(5, 6, 7, 8, 4), pathInfos.get(1).getPath().calcNodes());
-        assertEquals(Helper.createTList(5, 1, 9, 2, 3, 4), pathInfos.get(2).getPath().calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), pathInfos.get(0).getPath().calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 8, 4}), pathInfos.get(1).getPath().calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 1, 9, 2, 3, 4}), pathInfos.get(2).getPath().calcNodes());
         assertEquals(2416.0, pathInfos.get(2).getPath().getWeight(), .1);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
index a1a23ab1a0..d8bd400fee 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
@@ -26,7 +26,6 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import org.junit.Test;
 
@@ -59,8 +58,7 @@ protected GraphHopperStorage createGHStorage(EncodingManager em,
     @Override
     public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                ghStorage, getGraph(ghStorage, opts.getWeighting()),
-                opts.getWeighting(), TraversalMode.NODE_BASED);
+                ghStorage, getGraph(ghStorage, opts.getWeighting()), TraversalMode.NODE_BASED);
         ch.doWork();
         return ch;
     }
@@ -107,10 +105,10 @@ public void testPathRecursiveUnpacking() {
 
         AlgorithmOptions opts = new AlgorithmOptions(Parameters.Algorithms.DIJKSTRA_BI, weighting);
         Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                ghStorage, g2, weighting, TraversalMode.NODE_BASED).
+                ghStorage, g2, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
-        assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 2, 5, 7), p.calcNodes());
         assertEquals(1064, p.getTime());
         assertEquals(4.2, p.getDistance(), 1e-5);
     }
@@ -131,7 +129,7 @@ public void testBaseGraph() {
 
         // use base graph for solving normal Dijkstra
         Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(ghStorage, defaultOpts).calcPath(0, 3);
-        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.29, p1.getDistance(), 1e-2);
         assertEquals(p1.toString(), 144823, p1.getTime());
     }
@@ -152,12 +150,12 @@ public void testBaseGraphMultipleVehicles() {
 
         // use contracted graph
         Path p1 = contractedFactory.createAlgo(getGraph(g, carOptions.getWeighting()), carOptions).calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 6, 7), p1.calcNodes());
         assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
 
         // use base graph for solving normal Dijkstra via car
         Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g, carOptions).calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 6, 7), p2.calcNodes());
         assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
         assertEquals(p2.toString(), 2700 * 1000, p2.getTime());
 
@@ -165,7 +163,7 @@ public void testBaseGraphMultipleVehicles() {
         Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g, footOptions).calcPath(0, 7);
         assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
         assertEquals(p3.toString(), 12240 * 1000, p3.getTime());
-        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 5, 7), p3.calcNodes());
     }
 
     // 7------8------.---9----0
@@ -206,14 +204,14 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
         // note that node 9 will be visited by both forward and backward searches
         assertEquals(7, algo.getVisitedNodes());
         assertEquals(102, p.getDistance(), 1.e-3);
-        assertEquals(p.toString(), Helper.createTList(1, 8, 9, 0), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(1, 8, 9, 0), p.calcNodes());
 
         // without stalling we visit 11 nodes
         RoutingAlgorithm algoNoSod = createCHAlgo(graph, chGraph, false, defaultOpts);
         Path pNoSod = algoNoSod.calcPath(1, 0);
         assertEquals(11, algoNoSod.getVisitedNodes());
         assertEquals(102, pNoSod.getDistance(), 1.e-3);
-        assertEquals(pNoSod.toString(), Helper.createTList(1, 8, 9, 0), pNoSod.calcNodes());
+        assertEquals(pNoSod.toString(), IntArrayList.from(1, 8, 9, 0), pNoSod.calcNodes());
     }
 
     // t(0)--slow->1--s(2)
@@ -222,8 +220,8 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
     //      \--<---|
     @Test
     public void testDirectionDependentSpeedFwdSearch() {
-        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, Helper.createTList(0, 1, 2), new MotorcycleFlagEncoder());
-        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, Helper.createTList(0, 1, 2), new Bike2WeightFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, IntArrayList.from(0, 1, 2), new MotorcycleFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, IntArrayList.from(0, 1, 2), new Bike2WeightFlagEncoder());
     }
 
     // s(0)--fast->1--t(2)
@@ -232,8 +230,8 @@ public void testDirectionDependentSpeedFwdSearch() {
     //      \--<---|
     @Test
     public void testDirectionDependentSpeedBwdSearch() {
-        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, Helper.createTList(2, 1, 0), new MotorcycleFlagEncoder());
-        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, Helper.createTList(2, 1, 0), new Bike2WeightFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, IntArrayList.from(2, 1, 0), new MotorcycleFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, IntArrayList.from(2, 1, 0), new Bike2WeightFlagEncoder());
     }
 
     private void runTestWithDirectionDependentEdgeSpeed(
@@ -263,7 +261,7 @@ private void runTestWithDirectionDependentEdgeSpeed(
 
     private RoutingAlgorithm createCHAlgo(GraphHopperStorage graph, CHGraph chGraph, boolean withSOD, AlgorithmOptions algorithmOptions) {
         PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                graph, chGraph, algorithmOptions.getWeighting(), TraversalMode.NODE_BASED);
+                graph, chGraph, TraversalMode.NODE_BASED);
         if (!withSOD) {
             algorithmOptions.getHints().put("stall_on_demand", false);
         }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 76f8ca1e98..5450a50d85 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
@@ -24,7 +25,6 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -130,11 +130,11 @@ public void testIssue182() {
         initGraph(storage);
         RoutingAlgorithm algo = createAlgo(storage);
         Path p = algo.calcPath(0, 8);
-        assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 7, 8}), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 10);
-        assertEquals(Helper.createTList(0, 1, 2, 3, 4, 10), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 2, 3, 4, 10}), p.calcNodes());
     }
 
     @Test
@@ -160,15 +160,15 @@ public void testIssue239_and362() {
     public void testUseCache() {
         RoutingAlgorithm algo = createAlgo(createTestStorage());
         Path p = algo.calcPath(0, 4);
-        assertEquals(Helper.createTList(0, 4), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4}), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
-        assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
     }
 
     @Test
@@ -188,7 +188,7 @@ public boolean accept(EdgeIteratorState iter) {
             }
         });
         Path p = algo.calcPath(4, 6);
-        assertEquals(Helper.createTList(4, 3, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{4, 3, 6}), p.calcNodes());
 
         // important call!
         algo.clear();
@@ -199,7 +199,7 @@ public boolean accept(EdgeIteratorState iter) {
             }
         });
         p = algo.calcPath(4, 6);
-        assertEquals(Helper.createTList(4, 5, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{4, 5, 6}), p.calcNodes());
     }
 
     private Graph initGraph(Graph g) {
@@ -244,15 +244,15 @@ public void testUseCacheZeroPath_issue707() {
         assertEquals(0, p.distance, 0.00000);
 
         p = algo.calcPath(0, 4);
-        assertEquals(Helper.createTList(0, 4), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4}), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
-        assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 86e938f655..e934b652d9 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
@@ -27,7 +28,6 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -140,20 +140,20 @@ public void testBasicTurnRestriction() {
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
-        assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 4, 7, 6, 3, 1}), p.calcNodes());
 
         // test 7-6-5 and reverse
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 7);
-        assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 7}), p.calcNodes());
 
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(7, 5);
-        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
     }
 
 
@@ -214,7 +214,7 @@ public void testUTurns() {
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         Path p = createAlgo(g, opts).calcPath(7, 5);
 
-        assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 6, 5}), p.calcNodes());
 
         // no u-turn for 6-3
         opts = AlgorithmOptions.start().
@@ -223,7 +223,7 @@ public void testUTurns() {
         tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
         p = createAlgo(g, opts).calcPath(7, 5);
 
-        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
     }
 
     @Test
@@ -239,7 +239,7 @@ public void testBasicTurnCosts() {
         // no restriction and costs
         EdgeIteratorState e3_6 = getEdge(g, 5, 6);
         e3_6.setDistance(2);
-        assertEquals(Helper.createTList(5, 2, 3, 1), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 1}), p.calcNodes());
 
         // now introduce some turn costs
         long tflags = carEncoder.getTurnFlags(false, 2);
@@ -249,7 +249,7 @@ public void testBasicTurnCosts() {
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
-        assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 1}), p.calcNodes());
     }
 
     @Test
@@ -279,7 +279,7 @@ public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
                 }.setDefaultUTurnCost(40)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
-        assertEquals(Helper.createTList(5, 6, 7, 4, 3, 1), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 4, 3, 1}), p.calcNodes());
         assertEquals(301, p.getTime(), .1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 2fbb6ca6ed..53350d752f 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -27,7 +28,6 @@
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.Helper;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -38,7 +38,7 @@
 public class PathBidirRefTest {
     private final EncodingManager encodingManager = new EncodingManager("car");
     private FlagEncoder carEncoder = encodingManager.getEncoder("car");
-    private EdgeFilter carOutEdges = new DefaultEdgeFilter(carEncoder, false, true);
+    private EdgeFilter carOutEdges = DefaultEdgeFilter.outEdges(carEncoder);
 
     Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
@@ -56,7 +56,7 @@ public void testExtract() {
         pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
         pw.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
         Path p = pw.extract();
-        assertEquals(Helper.createTList(1, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{1, 2}), p.calcNodes());
         assertEquals(10, p.getDistance(), 1e-4);
     }
 
@@ -72,13 +72,13 @@ public void testExtract2() {
         pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 10);
         pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
 
-        explorer = g.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, false));
+        explorer = g.createEdgeExplorer(DefaultEdgeFilter.inEdges(carEncoder));
         iter = explorer.setBaseNode(3);
         iter.next();
         pw.edgeTo = new SPTEntry(iter.getEdge(), 2, 20);
         pw.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
         Path p = pw.extract();
-        assertEquals(Helper.createTList(1, 2, 3), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{1, 2, 3}), p.calcNodes());
         assertEquals(30, p.getDistance(), 1e-4);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index 55cda26137..c3f61249b7 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -428,8 +428,8 @@ public QueryResult createLocationResult(double lat, double lon,
 
     @Test
     public void testIteration_Issue163() {
-        EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("car"), false, true);
-        EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("car"), true, false);
+        EdgeFilter outEdgeFilter = DefaultEdgeFilter.outEdges(encodingManager.getEncoder("car"));
+        EdgeFilter inEdgeFilter = DefaultEdgeFilter.inEdges(encodingManager.getEncoder("car"));
         EdgeExplorer inExplorer = g.createEdgeExplorer(inEdgeFilter);
         EdgeExplorer outExplorer = g.createEdgeExplorer(outEdgeFilter);
 
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
similarity index 95%
rename from core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
rename to core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 27bfbd79f9..6f67fbd5be 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -19,16 +19,14 @@
 
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.util.AllCHEdgesIterator;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -39,7 +37,7 @@
 
 import static org.junit.Assert.*;
 
-public class NodeContractorTest {
+public class NodeBasedNodeContractorTest {
     private final CarFlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = new EncodingManager(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
@@ -54,8 +52,9 @@ public void setUp() {
     }
 
     private NodeContractor createNodeContractor() {
-        NodeContractor nodeContractor = new NodeContractor(dir, graph, lg, weighting, traversalMode);
+        NodeContractor nodeContractor = new NodeBasedNodeContractor(dir, graph, lg, weighting, new PMap());
         nodeContractor.initFromGraph();
+        nodeContractor.prepareContraction();
         return nodeContractor;
     }
 
@@ -85,7 +84,7 @@ public void testShortestPathSkipNode() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(3));
+        algo.setEdgeFilter(createIgnoreNodeFilter(3));
         algo.setWeightLimit(100);
         int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
@@ -105,7 +104,7 @@ public void testShortestPathSkipNode2() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(3));
+        algo.setEdgeFilter(createIgnoreNodeFilter(3));
         algo.setWeightLimit(10);
         int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
@@ -121,7 +120,7 @@ public void testShortestPathLimit() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(0));
+        algo.setEdgeFilter(createIgnoreNodeFilter(0));
         algo.setWeightLimit(2);
         int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
@@ -337,6 +336,10 @@ private void setMaxLevelOnAllNodes() {
         }
     }
 
+    private IgnoreNodeFilter createIgnoreNodeFilter(int node) {
+        return new IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(node);
+    }
+
     private static class Shortcut {
         int baseNode;
         int adjNode;
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index d825565187..4fe487a03a 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.ch;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.BikeFlagEncoder;
@@ -149,12 +150,20 @@ public void setUp() {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
+    @Test
+    public void testReturnsCorrectWeighting() {
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
+        assertSame(weighting, prepare.getWeighting());
+    }
+    
     @Test
     public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
         CHGraph lg = g.getGraph(CHGraph.class);
         int old = lg.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(old + 2, lg.getAllEdges().length());
     }
@@ -165,7 +174,7 @@ public void testMoreComplexGraph() {
         CHGraph lg = g.getGraph(CHGraph.class);
         initShortcutsGraph(lg);
         int oldCount = g.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(oldCount, g.getAllEdges().length());
         assertEquals(oldCount + 7, lg.getAllEdges().length());
@@ -184,14 +193,14 @@ public void testDirectedGraph() {
         g.freeze();
         int oldCount = GHUtility.count(lg.getAllEdges());
         assertEquals(6, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
         assertEquals(oldCount + 2, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
-        assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 3, 5, 2), p.calcNodes());
     }
 
     @Test
@@ -201,20 +210,20 @@ public void testDirectedGraph2() {
         initDirected2(g);
         int oldCount = GHUtility.count(g.getAllEdges());
         assertEquals(19, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(oldCount, g.getAllEdges().length());
         assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
 
-        int numShortcuts = 9;
+        long numShortcuts = 9;
         assertEquals(numShortcuts, prepare.getShortcuts());
         assertEquals(oldCount + numShortcuts, lg.getAllEdges().length());
         assertEquals(oldCount + numShortcuts, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
-        assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
     }
 
     void initRoundaboutGraph(Graph g) {
@@ -274,13 +283,13 @@ public void testRoundaboutUnpacking() {
         CHGraph lg = g.getGraph(CHGraph.class);
         initRoundaboutGraph(g);
         int oldCount = g.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(oldCount, g.getAllEdges().length());
         assertEquals(oldCount + 23, lg.getAllEdges().length());
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 7);
-        assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 5, 6, 7), p.calcNodes());
     }
 
     void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
@@ -333,11 +342,11 @@ public void testUnpackingOrder() {
         GraphHopperStorage ghStorage = createGHStorage();
         CHGraph lg = ghStorage.getGraph(CHGraph.class);
         initUnpackingGraph(ghStorage, lg, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, tMode);
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
-        assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
     }
 
     @Test
@@ -347,11 +356,11 @@ public void testUnpackingOrder_Fastest() {
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(ghStorage, lg, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, tMode);
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
-        assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
+        assertEquals(IntArrayList.from(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
     }
 
     @Test
@@ -365,7 +374,7 @@ public void testCircleBug() {
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -389,7 +398,7 @@ public void testBug178() {
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -451,7 +460,7 @@ public void testMultiplePreparationsIdenticalView() {
         ghStorage.freeze();
 
         for (Weighting w : chWeightings) {
-            checkPath(ghStorage, w, 7, 5, Helper.createTList(3, 9, 14, 16, 13, 12));
+            checkPath(ghStorage, w, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         }
     }
 
@@ -472,14 +481,14 @@ public void testMultiplePreparationsDifferentView() {
 
         ghStorage.freeze();
 
-        checkPath(ghStorage, carWeighting, 7, 5, Helper.createTList(3, 9, 14, 16, 13, 12));
+        checkPath(ghStorage, carWeighting, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         // detour around blocked 9,14
-        checkPath(ghStorage, bikeWeighting, 9, 5, Helper.createTList(3, 10, 14, 16, 13, 12));
+        checkPath(ghStorage, bikeWeighting, 9, 5, IntArrayList.from(3, 10, 14, 16, 13, 12));
     }
 
     void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, double expDistance, IntIndexedContainer expNodes) {
         CHGraph lg = ghStorage.getGraph(CHGraph.class, w);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, w, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, tMode);
         prepare.doWork();
         assertEquals(w.toString(), expShortcuts, prepare.getShortcuts());
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, w, tMode));
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
index f3fbe7060f..5049865d27 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
@@ -89,21 +89,33 @@ public void testSetGetWeight() {
 
         LandmarkStorage lms = new LandmarkStorage(ghStorage, dir, new FastestWeighting(encoder), 4).
                 setMaximumWeight(LandmarkStorage.PRECISION);
-        // 2^16=65536, use -1 for infinity and -2 for maximum
-        lms.setWeight(0, 65536);
-        // reached maximum value but do not reset to 0 instead use 2^16-2
-        assertEquals(65536 - 2, lms.getFromWeight(0, 0));
-        lms.setWeight(0, 65535);
-        assertEquals(65534, lms.getFromWeight(0, 0));
-        lms.setWeight(0, 79999);
-        assertEquals(65534, lms.getFromWeight(0, 0));
+        /* FROM_WEIGHT_BITS = 18
+        2^18 = 262144, use -1 for infinity and -2 for maximum
+        As the backward weight reaches a too high value it will use the maximum instead of 0 or infinity*/
+        lms.setWeight(0, 0, 16, Math.pow(2, 18), true);
+        assertEquals((int) Math.pow(2, 18) - 2, lms.getFromWeight(0, 0));
+        lms.setWeight(0, 0, 16, 999999, true);
+        assertEquals((int) Math.pow(2, 18) - 2, lms.getFromWeight(0, 0));
+
+        /* FROM_WEIGHT_BITS = 18 --> remaining bits: 32-18 = 14
+        The delta value is signed and will therefore go from -2^(14-1) to 2^(14-1).
+        Now 2^13-1 is used for infinity, 2^13-2 as maximum and -2^13 as minimum.
+        If the difference between forward and backward weight is too large it will use
+        the maximum (if positive) or the minimum (if negative) instead of 0 or infinity
+        The delta will then be added to the backward weight*/
+        lms.setWeight(0, 0, 16, 999999, false);
+        assertEquals((int) (Math.pow(2, 18) - 2 + Math.pow(2, 13) - 2), lms.getToWeight(0, 0));
+        //                 {backward weight}   {delta weight}
+        lms.setWeight(0, 0, 16, 1, false);
+        assertEquals((int) (Math.pow(2, 18) - 2 + -Math.pow(2, 13)), lms.getToWeight(0, 0));
+        //                 {backward weight}   {delta weight}
 
         da.setInt(0, Integer.MAX_VALUE);
         assertTrue(lms.isInfinity(0));
         // for infinity return much bigger value
         // assertEquals(Integer.MAX_VALUE, lms.getFromWeight(0, 0));
 
-        lms.setWeight(0, 79999);
+        lms.setWeight(0, 0, 16, 999999, true);
         assertFalse(lms.isInfinity(0));
     }
 
@@ -228,4 +240,75 @@ public BBox getBounds() {
         storage.createLandmarks();
         assertEquals(3, storage.getSubnetworksWithLandmarks());
     }
+
+    @Test
+    public void testDelta() {
+        int distance = 1000000;
+
+        ghStorage.edge(1, 2, distance, false);
+        ghStorage.edge(2, 3, distance, false);
+        ghStorage.edge(3, 1, distance, false);
+
+        ghStorage.edge(2, 4, distance, true);
+        ghStorage.edge(4, 5, distance, true);
+        ghStorage.edge(5, 6, distance, true);
+        ghStorage.edge(6, 7, distance, true);
+        ghStorage.edge(7, 8, distance, true);
+        ghStorage.edge(8, 9, distance, true);
+
+        ghStorage.edge(3, 10, distance, true);
+        ghStorage.edge(10, 11, distance, true);
+        ghStorage.edge(11, 12, distance, true);
+        ghStorage.edge(12, 13, distance, true);
+        ghStorage.edge(13, 14, distance, true);
+        ghStorage.edge(14, 15, distance, true);
+
+        LandmarkStorage storage = new LandmarkStorage(ghStorage, new RAMDirectory(), new FastestWeighting(encoder), 2);
+        storage.createLandmarks();
+
+        assertEquals(15, storage.getLandmarks(1)[0]);
+        assertEquals(9, storage.getLandmarks(1)[1]);
+
+        assertEquals(35680, storage.getFromWeight(0, 1));
+        assertEquals(40777, storage.getToWeight(0, 1));
+        assertEquals(71361, storage.getFromWeight(0, 9));
+        assertEquals(66264, storage.getToWeight(0, 9));
+        assertEquals(15291, storage.getFromWeight(0, 12));
+        assertEquals(15291, storage.getToWeight(0, 12));
+        assertEquals(40777, storage.getFromWeight(1, 1));
+        assertEquals(35680, storage.getToWeight(1, 1));
+        assertEquals(50972, storage.getFromWeight(1, 12));
+        assertEquals(56069, storage.getToWeight(1, 12));
+        assertEquals(66264, storage.getFromWeight(1, 15));
+        assertEquals(71361, storage.getToWeight(1, 15));
+    }
+
+    @Test
+    public void testDeltaWarning() {
+        int distance = 1000000;
+
+        ghStorage.edge(1, 2, distance, false);
+        ghStorage.edge(2, 3, distance, false);
+        ghStorage.edge(3, 4, distance, false);
+        ghStorage.edge(4, 5, distance, false);
+        ghStorage.edge(5, 6, distance, false);
+        ghStorage.edge(6, 1, distance, false);
+
+        ghStorage.edge(1, 7, distance, true);
+        ghStorage.edge(7, 8, distance, true);
+        ghStorage.edge(8, 9, distance, true);
+
+        ghStorage.edge(6, 10, distance, true);
+        ghStorage.edge(10, 11, distance, true);
+        ghStorage.edge(11, 12, distance, true);
+
+        LandmarkStorage storage = new LandmarkStorage(ghStorage, new RAMDirectory(), new FastestWeighting(encoder), 2);
+        storage.createLandmarks();
+
+        assertEquals(12, storage.getLandmarks(1)[0]);
+        assertEquals(9, storage.getLandmarks(1)[1]);
+
+        assertEquals((int) Math.pow(2, 13) - 2, storage.getToWeight(0, 9) - storage.getFromWeight(0, 9));
+        assertEquals((int) -Math.pow(2, 13), storage.getToWeight(1, 12) - storage.getFromWeight(1, 12));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
index 56cc0dd075..c4796c9910 100644
--- a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
@@ -26,7 +26,6 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -104,10 +103,10 @@ public void testFindSubnetworks() {
         assertEquals(3, components.size());
 
         // start is at 0 => large network
-        assertEquals(Helper.createTList(0, 7, 3, 13, 5), components.get(0));
+        assertEquals(IntArrayList.from(0, 7, 3, 13, 5), components.get(0));
         // next smallest and unvisited node is 1 => big network
-        assertEquals(Helper.createTList(1, 8, 4, 2, 11, 12, 9, 15), components.get(1));
-        assertEquals(Helper.createTList(6, 14, 10), components.get(2));
+        assertEquals(IntArrayList.from(1, 8, 4, 2, 11, 12, 9, 15), components.get(1));
+        assertEquals(IntArrayList.from(6, 14, 10), components.get(2));
     }
 
     @Test
@@ -190,9 +189,9 @@ public void testRemoveSubnetworkWhenMultipleVehicles() {
         // remove nothing because of two vehicles with different subnetworks
         assertEquals(9, g.getNodes());
 
-        EdgeExplorer carExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(carEncoder));
+        EdgeExplorer carExplorer = g.createEdgeExplorer(DefaultEdgeFilter.allEdges(carEncoder));
         assertEquals(GHUtility.asSet(7, 2, 1), GHUtility.getNeighbors(carExplorer.setBaseNode(3)));
-        EdgeExplorer bikeExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(bikeEncoder));
+        EdgeExplorer bikeExplorer = g.createEdgeExplorer(DefaultEdgeFilter.allEdges(bikeEncoder));
         assertEquals(GHUtility.asSet(7, 2, 1, 4), GHUtility.getNeighbors(bikeExplorer.setBaseNode(3)));
 
         GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false) | bikeEncoder.setProperties(5, false, false));
@@ -284,7 +283,7 @@ public void testTarjan() {
         GraphHopperStorage g = createSubnetworkTestStorage();
 
         // Requires a single vehicle type, otherwise we throw.
-        final EdgeFilter filter = new DefaultEdgeFilter(carFlagEncoder, false, true);
+        final EdgeFilter filter = DefaultEdgeFilter.outEdges(carFlagEncoder);
         TarjansSCCAlgorithm tarjan = new TarjansSCCAlgorithm(g, filter, false);
 
         List<IntArrayList> components = tarjan.findComponents();
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 598fa3be90..6f9fbaa5d6 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.template;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
@@ -27,7 +28,6 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
@@ -94,8 +94,8 @@ public void testLookupAndCalcPaths_simpleSquareGraph() {
                 queryGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         // make sure the resulting paths are connected and form a round trip starting and ending at the start node 0
         assertEquals(2, paths.size());
-        assertEquals(Helper.createTList(0, 7, 6, 5), paths.get(0).calcNodes());
-        assertEquals(Helper.createTList(5, 4, 3, 2, 1, 0), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{0, 7, 6, 5}), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 4, 3, 2, 1, 0}), paths.get(1).calcNodes());
     }
 
     @Test
@@ -120,8 +120,8 @@ public void testCalcRoundTrip() throws Exception {
         List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
                 new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
-        assertEquals(Helper.createTList(5, 6, 3, 4), paths.get(0).calcNodes());
-        assertEquals(Helper.createTList(4, 8, 7, 6, 5), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{4, 8, 7, 6, 5}), paths.get(1).calcNodes());
 
         qGraph = new QueryGraph(g);
         qGraph.lookup(qr4, qr6);
@@ -129,8 +129,8 @@ public void testCalcRoundTrip() throws Exception {
         paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
                 new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
-        assertEquals(Helper.createTList(6, 3, 4), paths.get(0).calcNodes());
-        assertEquals(Helper.createTList(4, 8, 7, 6), paths.get(1).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{6, 3, 4}), paths.get(0).calcNodes());
+        assertEquals(IntArrayList.from(new int[]{4, 8, 7, 6}), paths.get(1).calcNodes());
     }
 
     private Graph createTestGraph(boolean fullGraph) {
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 7d477f87cc..1d3de518f8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -645,6 +645,11 @@ public void testBarrierAccess() {
         node.setTag("bicycle", "yes");
         // barrier!
         assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // Test if cattle_grid is non blocking
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(encoder.handleNodeTags(node) == 0);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 3e18ee644b..29b4c2eec6 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -501,6 +501,13 @@ public void testBarrierAccess() {
         node.setTag("motorcar", "yes");
         // still barrier!
         assertTrue(encoder.handleNodeTags(node) > 0);
+
+        encoder.setBlockByDefault(false);
+
+        // Test if cattle_grid is not blocking
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(encoder.handleNodeTags(node) == 0);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 8f0ff12400..fea5fd56bf 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -75,7 +75,7 @@ public void testGraph() {
         g.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         g.edge(0, 2).setDistance(10).setFlags(footEncoder.setProperties(5, true, true));
         g.edge(1, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
-        EdgeExplorer out = g.createEdgeExplorer(new DefaultEdgeFilter(footEncoder, false, true));
+        EdgeExplorer out = g.createEdgeExplorer(DefaultEdgeFilter.outEdges(footEncoder));
         assertEquals(GHUtility.asSet(1, 2), GHUtility.getNeighbors(out.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0, 3), GHUtility.getNeighbors(out.setBaseNode(1)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(out.setBaseNode(2)));
@@ -377,6 +377,7 @@ public void handleWayTagsCircularJunction() {
         assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
+    @Test
     public void testFord() {
         // by default deny access through fords!
         ReaderNode node = new ReaderNode(1, -1, -1);
@@ -402,4 +403,45 @@ public void testFord() {
         node.setTag("ford", "yes");
         assertTrue(footEncoder.handleNodeTags(node) == 0);
     }
+
+    @Test
+    public void testBlockByDefault() {
+        FootFlagEncoder tmpFootEncoder = new FootFlagEncoder();
+        new EncodingManager(tmpFootEncoder);
+
+        ReaderNode node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // potential barriers are no barrier by default
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+        node.setTag("access", "no");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // absolute barriers always block
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "fence");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+        node.setTag("barrier", "fence");
+        node.setTag("access", "yes");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // Now let's block potential barriers per default (if no other access tag exists)
+        tmpFootEncoder.setBlockByDefault(true);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+        node.setTag("access", "yes");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "fence");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // Let's stop block potential barriers to test if barrier:cattle_grid is non blocking
+        tmpFootEncoder.setBlockByDefault(false);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
index 82b853902f..d2d30f41eb 100644
--- a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
@@ -32,7 +32,7 @@
 
     @Test
     public void testAccept() {
-        EdgeFilter edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Laufamholzstrae 154 Nrnberg");
+        EdgeFilter edgeFilter = createNameSimilarityEdgeFilter("Laufamholzstrae 154 Nrnberg");
         EdgeIteratorState edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
@@ -48,22 +48,22 @@ public void testAccept() {
         edge = createTestEdgeIterator(null);
         assertFalse(edgeFilter.accept(edge));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), null);
+        edgeFilter = createNameSimilarityEdgeFilter(null);
         edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "");
+        edgeFilter = createNameSimilarityEdgeFilter("");
         edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Johannesstrae, 99636, Rastenberg, Deutschland");
+        edgeFilter = createNameSimilarityEdgeFilter("Johannesstrae, 99636, Rastenberg, Deutschland");
         edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertFalse(edgeFilter.accept(edge));
 
         edge = createTestEdgeIterator("Johannesstrae");
         assertTrue(edgeFilter.accept(edge));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Hauptstrae, 39025, Naturns, Italien");
+        edgeFilter = createNameSimilarityEdgeFilter("Hauptstrae");
         edge = createTestEdgeIterator("Teststrae");
         assertFalse(edgeFilter.accept(edge));
 
@@ -75,7 +75,6 @@ public void testAccept() {
 
         edge = createTestEdgeIterator("Hauptstr.");
         assertTrue(edgeFilter.accept(edge));
-
     }
 
     /**
@@ -83,153 +82,100 @@ public void testAccept() {
      */
     @Test
     public void testAcceptFromNominatim() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Wentworth Street, Caringbah South");
-        edge = createTestEdgeIterator("Wentworth Street");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Zum Toffental, Altdorf bei Nrnnberg");
-        edge = createTestEdgeIterator("Zum Toffental");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Wentworth Street, Caringbah South").
+                accept(createTestEdgeIterator("Wentworth Street")));
+        assertTrue(createNameSimilarityEdgeFilter("Zum Toffental, Altdorf bei Nrnnberg").
+                accept(createTestEdgeIterator("Zum Toffental")));
     }
 
     @Test
     public void testAcceptFromGoogleMapsGeocoding() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Rue Notre-Dame O Montral");
-        edge = createTestEdgeIterator("Rue Dupr");
-        assertFalse(edgeFilter.accept(edge));
+        EdgeFilter edgeFilter = createNameSimilarityEdgeFilter("Rue Notre-Dame O Montral");
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Dupr")));
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue Notre-Dame Ouest")));
 
-        edge = createTestEdgeIterator("Rue Notre-Dame Ouest");
-        assertTrue(edgeFilter.accept(edge));
+        edgeFilter = createNameSimilarityEdgeFilter("Rue Saint-Antoine O, Montral");
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue Saint-Antoine O")));
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Saint-Jacques")));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "227 Rue Saint-Antoine O, Montral");
-        edge = createTestEdgeIterator("Rue Saint-Antoine O");
-        assertTrue(edgeFilter.accept(edge));
+        edgeFilter = createNameSimilarityEdgeFilter("Rue de Bleury");
+        assertTrue(edgeFilter.accept(createTestEdgeIterator("Rue de Bleury")));
+        assertFalse(edgeFilter.accept(createTestEdgeIterator("Rue Balmoral")));
 
-        edge = createTestEdgeIterator("Rue Saint-Jacques");
-        assertFalse(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Main Rd").accept(createTestEdgeIterator("Main Road")));
+        assertTrue(createNameSimilarityEdgeFilter("Main Road").accept(createTestEdgeIterator("Main Rd")));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "1025 Rue de Bleury, Montral, QC H2Z 1M7");
-        edge = createTestEdgeIterator("Rue de Bleury");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point")));
+        assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point Road")));
 
-        edge = createTestEdgeIterator("Rue Balmoral");
-        assertFalse(edgeFilter.accept(edge));
-
-        // Modified Test from Below
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "257 Main Road, Claremont, Cape Town, 7708, Afrique du Sud");
-        edge = createTestEdgeIterator("Main Road");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Cape Point Rd, Cape Peninsula, Cape Town, 8001, Afrique du Sud");
-        edge = createTestEdgeIterator("Cape Point / Cape of Good Hope");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Viale Puglie, 26, 20137 Milano, Italy");
-        edge = createTestEdgeIterator("Viale Puglie");
-        assertTrue(edgeFilter.accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Av. Juan Ramn Ramrez").accept(createTestEdgeIterator("Avenida Juan Ramn Ramrez")));
     }
 
     @Test
-    public void testAcceptMashup() {
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        edge = createTestEdgeIterator("Augustine Street");
-
-        // Google Maps
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Augustine St, Hunters Hill NSW 2110, Australia");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Opencagedata
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Augustine Street, Sydney Neusdwales 2110, Australien");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Nominatim
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Augustine Street, Sydney, Municipality of Hunters Hill, Neusdwales, 2111, Australien");
-        assertTrue(edgeFilter.accept(edge));
+    public void testAcceptStForStreet() {
+        EdgeIteratorState edge = createTestEdgeIterator("Augustine Street");
+        assertTrue(createNameSimilarityEdgeFilter("Augustine St").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Augustine Street").accept(edge));
+
+        edge = createTestEdgeIterator("Augustine St");
+        assertTrue(createNameSimilarityEdgeFilter("Augustine St").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Augustine Street").accept(edge));
+    }
 
+    @Test
+    public void testWithDash() {
+        EdgeIteratorState edge = createTestEdgeIterator("Ben-Gurion-Strae");
+        assertTrue(createNameSimilarityEdgeFilter("Ben-Gurion").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Ben Gurion").accept(edge));
+        assertTrue(createNameSimilarityEdgeFilter("Ben Gurion Strasse").accept(edge));
+        assertFalse(createNameSimilarityEdgeFilter("Potsdamer Str.").accept(edge));
     }
 
     @Ignore
-    public void testThatShouldSucceed(){
-        EdgeFilter edgeFilter;
-        EdgeIteratorState edge;
-
-        // The Problem is that Rd vs Road is abreviated, if we have Road, it works
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "257 Main Rd, Claremont, Cape Town, 7708, Afrique du Sud");
-        edge = createTestEdgeIterator("Main Road");
-        assertTrue(edgeFilter.accept(edge));
-
-        // Just too much difference Between Google Maps and OSM @ 32.121435,-110.857969
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "7202 S Wilmot Rd, Tucson, AZ 85701");
-        edge = createTestEdgeIterator("South Wilmot Road");
-        assertTrue(edgeFilter.accept(edge));
+    public void testThatShouldSucceed() {
+        // Google Maps vs OSM @ 32.121435,-110.857969
+        assertTrue(createNameSimilarityEdgeFilter("S Wilmot Rd").accept(createTestEdgeIterator("South Wilmot Road")));
 
         // @ 37.307774,13.581259
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Via Manzoni, 50/52, 92100 Agrigento AG, Italy");
-        edge = createTestEdgeIterator("Via Alessandro Manzoni");
-        assertTrue(edgeFilter.accept(edge));
-
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Av. Juan Ramn Ramrez, 12, 02630 La Roda, Albacete, Spain");
-        edge = createTestEdgeIterator("Avenida Juan Ramn Ramrez");
-        assertTrue(edgeFilter.accept(edge));
-
-
+        assertTrue(createNameSimilarityEdgeFilter("Via Manzoni").accept(createTestEdgeIterator("Via Alessandro Manzoni")));
     }
 
-
     /**
      * We ignore Typos for now, most GeoCoders return pretty good results, we might allow some typos
      */
-    @Ignore
+    @Test
     public void testAcceptWithTypos() {
-        EdgeFilter edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Laufamholzstrae 154 Nrnberg");
+        EdgeFilter edgeFilter = createNameSimilarityEdgeFilter("Laufamholzstrae 154 Nrnberg");
         EdgeIteratorState edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
         // Single Typo
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Kaufamholzstrae 154 Nrnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholzstrae");
         assertTrue(edgeFilter.accept(edge));
 
         // Two Typos
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Kaufamholystrae 154 Nrnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufamholystrae");
         assertTrue(edgeFilter.accept(edge));
 
         // Three Typos
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Kaufmholystrae 154 Nrnberg");
+        edgeFilter = createNameSimilarityEdgeFilter("Kaufmholystrae");
         assertFalse(edgeFilter.accept(edge));
 
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Hauptstrae");
+        edgeFilter = createNameSimilarityEdgeFilter("Hauptstrae");
         edge = createTestEdgeIterator("Hauptstrae");
         assertTrue(edgeFilter.accept(edge));
 
         // Single Typo
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Hauptstrase");
+        edgeFilter = createNameSimilarityEdgeFilter("Hauptstrase");
         assertTrue(edgeFilter.accept(edge));
 
         // Two Typos
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "Lauptstrase");
-        assertTrue(edgeFilter.accept(edge));
-
-        // We ignore too short Strings for now
-        /*
-        // Distance - PerfectDistance = 1
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "z");
-        assertFalse(edgeFilter.accept(edge));
-        // Distance - PerfectDistance = 1
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "az");
-        assertFalse(edgeFilter.accept(edge));
+        edgeFilter = createNameSimilarityEdgeFilter("Lauptstrase");
+//        assertTrue(edgeFilter.accept(edge));
+    }
 
-        // Distance - PerfectDistance = 2
-        edgeFilter = new NameSimilarityEdgeFilter(new DefaultEdgeFilter(new CarFlagEncoder()), "xy");
-        assertFalse(edgeFilter.accept(edge));
-        */
+    private NameSimilarityEdgeFilter createNameSimilarityEdgeFilter(String s) {
+        return new NameSimilarityEdgeFilter(DefaultEdgeFilter.allEdges(new CarFlagEncoder()), s);
     }
 
     private EdgeIteratorState createTestEdgeIterator(final String name) {
diff --git a/reader-json/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
similarity index 78%
rename from reader-json/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
rename to core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
index 207cd8061c..93b635d822 100644
--- a/reader-json/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -15,16 +15,16 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.spatialrules;
+package com.graphhopper.routing.util.spatialrules;
 
-import com.graphhopper.json.GHJsonFactory;
+import com.graphhopper.jackson.Jackson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.util.shapes.BBox;
 import org.junit.Assert;
 import org.junit.Test;
 
-import java.io.*;
+import java.io.FileReader;
+import java.io.IOException;
 
 import static junit.framework.TestCase.assertFalse;
 import static junit.framework.TestCase.assertTrue;
@@ -38,9 +38,9 @@
     private static final String COUNTRIES_FILE = "../core/files/spatialrules/countries.geo.json";
 
     @Test
-    public void testIndex() throws FileNotFoundException {
+    public void testIndex() throws IOException {
         final FileReader reader = new FileReader(COUNTRIES_FILE);
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
 
         // Berlin
         Assert.assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
@@ -57,9 +57,9 @@ public void testIndex() throws FileNotFoundException {
     }
 
     @Test
-    public void testBounds() throws FileNotFoundException {
+    public void testBounds() throws IOException {
         final FileReader reader = new FileReader(COUNTRIES_FILE);
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, 180, -90, 90));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, 180, -90, 90));
         BBox almostWorldWide = new BBox(-179, 179, -89, 89);
 
         // Might fail if a polygon is defined outside the above coordinates
@@ -67,20 +67,20 @@ public void testBounds() throws FileNotFoundException {
     }
 
     @Test
-    public void testIntersection() throws FileNotFoundException {
+    public void testIntersection() throws IOException {
         /*
          We are creating a BBox smaller than Germany. We have the German Spatial rule activated by default.
          So the BBox should not contain a Point lying somewhere close in Germany.
         */
         final FileReader reader = new FileReader(COUNTRIES_FILE);
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(9, 10, 51, 52));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(9, 10, 51, 52));
         assertFalse("BBox seems to be incorrectly contracted", spatialRuleLookup.getBounds().contains(49.9, 8.9));
     }
 
     @Test
-    public void testNoIntersection() throws FileNotFoundException {
+    public void testNoIntersection() throws IOException {
         final FileReader reader = new FileReader(COUNTRIES_FILE);
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, -179, -90, -89));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, -179, -90, -89));
         assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index af330f470c..77e2d906bb 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -49,8 +49,8 @@
     protected CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
     protected FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
     protected GraphHopperStorage graph;
-    EdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-    EdgeFilter carInFilter = new DefaultEdgeFilter(carEncoder, true, false);
+    EdgeFilter carOutFilter = DefaultEdgeFilter.outEdges(carEncoder);
+    EdgeFilter carInFilter = DefaultEdgeFilter.inEdges(carEncoder);
     EdgeExplorer carOutExplorer;
     EdgeExplorer carInExplorer;
     EdgeExplorer carAllExplorer;
@@ -881,7 +881,7 @@ public void testFootMix() {
         graph.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         graph.edge(0, 2).setDistance(10).setFlags(carEncoder.setProperties(10, true, true));
         graph.edge(0, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true) | carEncoder.setProperties(10, true, true));
-        EdgeExplorer footOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(footEncoder, false, true));
+        EdgeExplorer footOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(footEncoder));
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(footOutExplorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(3, 2), GHUtility.getNeighbors(carOutExplorer.setBaseNode(0)));
     }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
index 41b52316e1..7e175b1c98 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
@@ -62,7 +62,7 @@ public void testParseStringHints() {
                 .prepareIndex();
 
         GraphEdgeIdFinder graphFinder = new GraphEdgeIdFinder(graph, locationIndex);
-        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("0.01,0.005,1", new DefaultEdgeFilter(encoder), 1000 * 1000);
+        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("0.01,0.005,1", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         GHIntHashSet blockedEdges = new GHIntHashSet();
         blockedEdges.add(0);
@@ -72,7 +72,7 @@ public void testParseStringHints() {
 
         // big area converts into shapes
         graphFinder = new GraphEdgeIdFinder(graph, locationIndex);
-        blockArea = graphFinder.parseBlockArea("0,0,1000", new DefaultEdgeFilter(encoder), 1000 * 1000);
+        blockArea = graphFinder.parseBlockArea("0,0,1000", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
         blockedEdges.clear();
         assertEquals(blockedEdges, blockArea.blockedEdges);
         blockedShapes.add(new Circle(0, 0, 1000));
@@ -121,13 +121,13 @@ public void testBlockAreasWithPolygon() {
                 .prepareIndex();
 
         GraphEdgeIdFinder graphFinder = new GraphEdgeIdFinder(graph, locationIndex);
-        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("2,1, 0,2, 2,3", new DefaultEdgeFilter(encoder), 1000 * 1000);
+        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("2,1, 0,2, 2,3", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         GHIntHashSet blockedEdges = new GHIntHashSet();
         blockedEdges.addAll(new int[]{1, 2, 6, 7});
         assertEquals(blockedEdges, blockArea.blockedEdges);
 
-        blockArea = graphFinder.parseBlockArea("2,1, 1,3, 1,2, 0,1", new DefaultEdgeFilter(encoder), 1000 * 1000);
+        blockArea = graphFinder.parseBlockArea("2,1, 1,3, 1,2, 0,1", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         blockedEdges = new GHIntHashSet();
         blockedEdges.addAll(new int[]{4, 9, 6, 7});
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index a80d4f3ca9..717673d7eb 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
@@ -252,7 +253,7 @@ public void testQueryGraph() {
         EdgeExplorer explorer = baseGraph.createEdgeExplorer();
 
         assertTrue(chGraph.getNodes() < qGraph.getNodes());
-        assertTrue(baseGraph.getNodes() == qGraph.getNodes());
+        assertEquals(baseGraph.getNodes(), qGraph.getNodes());
 
         // traverse virtual edges and normal edges but no shortcuts!
         assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
@@ -338,7 +339,7 @@ public void testSimpleShortcutCreationAndTraversal() {
         CHGraph lg = graph.getGraph(CHGraph.class);
         lg.shortcut(1, 4).setWeight(3).setFlags(carEncoder.setProperties(10, true, true));
 
-        EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+        EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
         // iteration should result in same nodes even if reusing the iterator
         assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
@@ -414,7 +415,7 @@ public void testShortcutCreationAndAccessForManyVehicles() {
         // throw exception for wrong encoder
         try {
             assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpBike));
-            assertTrue(false);
+            fail();
         } catch (AssertionError ex) {
         }
 
@@ -425,8 +426,60 @@ public void testShortcutCreationAndAccessForManyVehicles() {
         // throw exception for wrong encoder
         try {
             assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpCar));
-            assertTrue(false);
+            fail();
         } catch (AssertionError ex) {
         }
     }
+
+    @Test(expected = IllegalStateException.class)
+    public void testLoadingWithWrongWeighting_throws() {
+        // we start with one weighting
+        GraphHopperStorage ghStorage = newGHStorage(new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), false);
+        ghStorage.create(defaultSize);
+        ghStorage.flush();
+
+        // but then configure another weighting and try to load the graph from disk -> error
+        GraphHopperStorage newGHStorage = createStorageWithWeightings(new ShortestWeighting(carEncoder));
+        newGHStorage.loadExisting();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testLoadingWithExtraWeighting_throws() {
+        // we start with one weighting
+        GraphHopperStorage ghStorage = newGHStorage(new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), false);
+        ghStorage.create(defaultSize);
+        ghStorage.flush();
+
+        // but then add an additional weighting and try to load the graph from disk -> error
+        GraphHopperStorage newGHStorage = createStorageWithWeightings(
+                new FastestWeighting(carEncoder), new ShortestWeighting(carEncoder));
+        newGHStorage.loadExisting();
+    }
+
+    @Test
+    public void testLoadingWithLessWeightings_works() {
+        // we start with a gh storage with two ch weightings and flush it to disk
+        FastestWeighting weighting1 = new FastestWeighting(carEncoder);
+        ShortestWeighting weighting2 = new ShortestWeighting(carEncoder);
+        GraphHopperStorage originalStorage = createStorageWithWeightings(weighting1, weighting2);
+        originalStorage.create(defaultSize);
+        originalStorage.flush();
+
+        // now we create a new storage but only use one of the weightings, which should be ok
+        GraphHopperStorage smallStorage = createStorageWithWeightings(weighting1);
+        smallStorage.loadExisting();
+        assertEquals(1, smallStorage.getCHWeightings().size());
+        smallStorage.flush();
+
+        // now we create yet another storage that uses both weightings again, which still works
+        GraphHopperStorage fullStorage = createStorageWithWeightings(weighting1, weighting2);
+        fullStorage.loadExisting();
+        assertEquals(2, fullStorage.getCHWeightings().size());
+        fullStorage.flush();
+    }
+
+    private GraphHopperStorage createStorageWithWeightings(Weighting... weightings) {
+        return new GraphHopperStorage(Arrays.asList(weightings), new GHDirectory(defaultGraphLoc, DAType.RAM_STORE),
+                encodingManager, false, new GraphExtension.NoOpExtension());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index c4dcd24210..f981d6697b 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -181,7 +181,7 @@ public void testEnsureSize() {
         Directory dir = new RAMDirectory();
         graph = newGHStorage(dir, false).create(defaultSize);
         int roughEdgeRowLength = 4 * 8;
-        int testIndex = dir.find("edges").getSegmentSize() * 3 / roughEdgeRowLength;
+        int testIndex = dir.find("edges", DAType.RAM_INT).getSegmentSize() * 3 / roughEdgeRowLength;
         // we need a big node index to trigger multiple segments, but low enough to avoid OOM
         graph.edge(0, testIndex, 10, true);
 
diff --git a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
index 0126046b01..7fc7826cb2 100644
--- a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
+++ b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
@@ -21,6 +21,10 @@
 import org.junit.Test;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.HashMap;
+import java.util.Map;
 
 import static org.junit.Assert.*;
 
@@ -80,4 +84,13 @@ public void testStore() {
 
         Helper.removeDir(new File(dir));
     }
+
+    @Test
+    public void testLoadProperties() throws IOException {
+        Map<String, String> map = new HashMap<>();
+        StorableProperties.loadProperties(map, new StringReader("blup=test\n blup2 = xy"));
+        assertEquals("test", map.get("blup"));
+        assertEquals("xy", map.get("blup2"));
+    }
+
 }
diff --git a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
similarity index 87%
rename from reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
rename to core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index a3d9bade0a..c6d1fe45b4 100644
--- a/reader-json/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -1,8 +1,6 @@
 package com.graphhopper.storage.change;
 
-import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonFactory;
-import com.graphhopper.json.JsonFeatureConverter;
+import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EncodingManager;
@@ -14,9 +12,11 @@
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
+import com.graphhopper.jackson.Jackson;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
 
@@ -28,17 +28,15 @@
 public class ChangeGraphHelperTest {
     private EncodingManager encodingManager;
     private GraphHopperStorage graph;
-    private GHJson ghson;
 
     @Before
     public void setUp() {
         encodingManager = new EncodingManager("car");
         graph = new GraphBuilder(encodingManager).create();
-        ghson = new GHJsonFactory().create();
     }
 
     @Test
-    public void testApplyChanges() {
+    public void testApplyChanges() throws IOException {
         // 0-1-2
         // | |
         // 3-4
@@ -65,8 +63,8 @@ public void testApplyChanges() {
 
         Reader reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata1.json"), Helper.UTF_CS);
         ChangeGraphHelper instance = new ChangeGraphHelper(graph, locationIndex);
-        JsonFeatureConverter converter = new JsonFeatureConverter(ghson, instance, encodingManager);
-        long updates = converter.applyChanges(reader);
+        JsonFeatureCollection collection = Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class);
+        long updates = instance.applyChanges(encodingManager, collection.getFeatures());
         assertEquals(2, updates);
 
         // assert changed speed and access
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index 9dde00792b..2e0e1dff51 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -341,7 +341,7 @@ public void testDifferentVehicles() {
 
         idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
-        assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
+        assertEquals(2, idx.findClosest(1, -1, DefaultEdgeFilter.allEdges(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 769432fdd6..34d68e3c94 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.storage.index;
 
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.coll.GHIntHashSet;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Directory;
@@ -108,7 +109,7 @@ public void testInMemIndex() {
         LocationIndexTree index = createIndexNoPrepare(graph, 50000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(Helper.createTList(4, 4), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{4, 4}), index.getEntries());
 
         assertEquals(4, inMemIndex.getEntriesOf(0).size());
         assertEquals(10, inMemIndex.getEntriesOf(1).size());
@@ -155,7 +156,7 @@ public void testInMemIndex2() {
         LocationIndexTree index = createIndexNoPrepare(graph, 500);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(Helper.createTList(4, 4), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{4, 4}), index.getEntries());
         assertEquals(3, inMemIndex.getEntriesOf(0).size());
         assertEquals(5, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
@@ -194,7 +195,7 @@ public void testInMemIndex3() {
         LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(Helper.createTList(64, 4), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{64, 4}), index.getEntries());
 
         assertEquals(33, inMemIndex.getEntriesOf(0).size());
         assertEquals(69, inMemIndex.getEntriesOf(1).size());
@@ -211,7 +212,7 @@ public void testInMemIndex3() {
     @Test
     public void testReverseSpatialKey() {
         LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
-        assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{64, 64, 64, 4}), index.getEntries());
 
         // 10111110111110101010
         String str44 = "00000000000000000000000000000000000000000000";
@@ -464,12 +465,12 @@ public void testSearchWithFilter_issue318() {
         index.prepareIndex();
         index.setMaxRegionSearch(8);
 
-        EdgeFilter carFilter = new DefaultEdgeFilter(carEncoder, true, true);
+        EdgeFilter carFilter = DefaultEdgeFilter.allEdges(carEncoder);
         QueryResult qr = index.findClosest(0.03, 0.03, carFilter);
         assertTrue(qr.isValid());
         assertEquals(33, qr.getClosestNode());
 
-        EdgeFilter bikeFilter = new DefaultEdgeFilter(bikeEncoder, true, true);
+        EdgeFilter bikeFilter = DefaultEdgeFilter.allEdges(bikeEncoder);
         qr = index.findClosest(0.03, 0.03, bikeFilter);
         assertTrue(qr.isValid());
         assertEquals(2, qr.getClosestNode());
diff --git a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index e91bc8c5a5..8180f64f7d 100644
--- a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -38,7 +38,7 @@ public void testUpdateFlags() {
         CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         EncodingManager encodingManager = new EncodingManager(carFlagEncoder);
         FastestWeighting weighting = new FastestWeighting(carFlagEncoder);
-        EdgeFilter carOutFilter = new DefaultEdgeFilter(carFlagEncoder, false, true);
+        EdgeFilter carOutFilter = DefaultEdgeFilter.outEdges(carFlagEncoder);
         GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
         CHGraph g = ghStorage.getGraph(CHGraph.class, weighting);
         g.edge(0, 1).setDistance(12).setFlags(carFlagEncoder.setProperties(10, true, true));
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index fa1ef51e6c..07b185f5b2 100644
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -68,7 +68,7 @@ public boolean goFurther(int v) {
         g.edge(5, 6, 1, false);
         g.edge(6, 4, 1, false);
 
-        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+        dfs.start(g.createEdgeExplorer(DefaultEdgeFilter.outEdges(fe)), 1);
 
         assertTrue(counter > 0);
         assertEquals("[1, 2, 3, 4, 5, 6]", list.toString());
@@ -96,7 +96,7 @@ public boolean goFurther(int v) {
         g.edge(2, 3, 1, false);
         g.edge(4, 3, 1, true);
 
-        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+        dfs.start(g.createEdgeExplorer(DefaultEdgeFilter.outEdges(fe)), 1);
 
         assertTrue(counter > 0);
         assertEquals("[1, 2, 3, 4]", list.toString());
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java
new file mode 100644
index 0000000000..6ce67951cd
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java
@@ -0,0 +1,51 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+public class DistanceCalc2DTest {
+
+    @Test
+    public void testCrossingPointToEdge() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        GHPoint point = distanceCalc.calcCrossingPointToEdge(0, 10, 0, 0, 10, 10);
+        Assert.assertEquals(5, point.getLat(), 0);
+        Assert.assertEquals(5, point.getLon(), 0);
+    }
+
+    @Test
+    public void testCalcNormalizedEdgeDistance() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        double distance = distanceCalc.calcNormalizedEdgeDistance(0, 10, 0, 0, 10, 10);
+        Assert.assertEquals(50, distance, 0);
+    }
+
+    @Test
+    public void testValidEdgeDistance() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        boolean validEdgeDistance = distanceCalc.validEdgeDistance(5, 15, 0, 0, 10, 10);
+        Assert.assertEquals(false, validEdgeDistance);
+        validEdgeDistance = distanceCalc.validEdgeDistance(15, 5, 0, 0, 10, 10);
+        Assert.assertEquals(false, validEdgeDistance);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 922aea4de4..3af1ce51dd 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -17,8 +17,7 @@
  */
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
@@ -138,7 +137,7 @@ public void testWayList() {
 
         p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
-        assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
+        assertEquals(IntArrayList.from(new int[]{6, 7, 8, 5, 2}), p.calcNodes());
 
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
@@ -315,7 +314,7 @@ public void testInstructionsWithTimeAndPlace() {
         assertEquals(15.1, wayList.get(2).getFirstLat(), 1e-3);
         assertEquals(9.9, wayList.get(2).getFirstLon(), 1e-3);
 
-        String gpxStr = wayList.createGPX("test", 0);
+        String gpxStr = wayList.createGPX("test", 0, Constants.VERSION);
         verifyGPX(gpxStr);
 
         assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
@@ -331,62 +330,6 @@ public void testInstructionsWithTimeAndPlace() {
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
-    @Test
-    public void testRoundaboutJsonIntegrity() {
-        InstructionList il = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(52.514, 13.349);
-        pl.add(52.5135, 13.35);
-        pl.add(52.514, 13.351);
-        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
-                new InstructionAnnotation(0, ""), pl)
-                .setDirOfRotation(-0.1)
-                .setRadian(-Math.PI + 1)
-                .setExitNumber(2)
-                .setExited();
-        il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        // assert that all information is present in map for JSON
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
-        assertEquals("2", json.get("exit_number").toString());
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
-    }
-
-    private String write(Map<String, Object> json) {
-        try {
-            return new ObjectMapper().writeValueAsString(json);
-        } catch (JsonProcessingException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    // Roundabout with unknown dir of rotation
-    @Test
-    public void testRoundaboutJsonNaN() {
-        InstructionList il = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(52.514, 13.349);
-        pl.add(52.5135, 13.35);
-        pl.add(52.514, 13.351);
-        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
-                new InstructionAnnotation(0, ""), pl)
-                .setRadian(-Math.PI + 1)
-                .setExitNumber(2)
-                .setExited();
-        il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertNull(json.get("turn_angle"));
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
-    }
-
     @Test
     public void testCreateGPXIncludesRoundaboutExitNumber() {
         InstructionList instructions = new InstructionList(usTR);
@@ -403,7 +346,7 @@ public void testCreateGPXIncludesRoundaboutExitNumber() {
         instructions.add(instr);
         instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
 
-        String gpxStr = instructions.createGPX("test", 0, true, true, false, false);
+        String gpxStr = instructions.createGPX("test", 0, true, true, false, false, Constants.VERSION);
 
         assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
         verifyGPX(gpxStr);
@@ -420,7 +363,7 @@ public void testCreateGPXCorrectFormattingSmallNumbers() {
         instructions.add(instruction);
         instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
 
-        String gpxStr = instructions.createGPX("test", 0, true, true, true, true);
+        String gpxStr = instructions.createGPX("test", 0, true, true, true, true, Constants.VERSION);
 
         assertFalse(gpxStr, gpxStr.contains("E-"));
         assertTrue(gpxStr, gpxStr.contains("0.000001"));
@@ -439,7 +382,7 @@ public void testCreateGPXWithEle() {
                 return fakeList;
             }
         };
-        String gpxStr = il.createGPX("test", 0);
+        String gpxStr = il.createGPX("test", 0, Constants.VERSION);
         verifyGPX(gpxStr);
         assertFalse(gpxStr, gpxStr.contains("NaN"));
         assertFalse(gpxStr, gpxStr.contains("<ele>"));
@@ -447,7 +390,7 @@ public void testCreateGPXWithEle() {
         fakeList.clear();
         fakeList.add(new GPXEntry(12, 13, 11, 0));
         fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
-        gpxStr = il.createGPX("test", 0, true, true, true, true);
+        gpxStr = il.createGPX("test", 0, true, true, true, true, Constants.VERSION);
 
         assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
         assertFalse(gpxStr, gpxStr.contains("NaN"));
@@ -480,7 +423,7 @@ public void testCreateGPX() {
         assertEquals(19000, result.get(3).getTime());
         assertEquals(22000, result.get(4).getTime());
 
-        verifyGPX(instructions.createGPX());
+        verifyGPX(instructions.createGPX(Constants.VERSION));
     }
 
     private long flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
diff --git a/core/src/test/java/com/graphhopper/util/UnzipperTest.java b/core/src/test/java/com/graphhopper/util/UnzipperTest.java
new file mode 100644
index 0000000000..67ec01f588
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/UnzipperTest.java
@@ -0,0 +1,23 @@
+package com.graphhopper.util;
+
+import org.junit.Test;
+
+import java.io.File;
+
+import static org.junit.Assert.assertTrue;
+
+public class UnzipperTest {
+
+    @Test
+    public void testUnzip() throws Exception {
+        String to = "./target/tmp/test";
+        Helper.removeDir(new File(to));
+        new Unzipper().unzip("./src/test/resources/com/graphhopper/util/test.zip", to, false);
+        assertTrue(new File("./target/tmp/test/file2 bh").exists());
+        assertTrue(new File("./target/tmp/test/folder1").isDirectory());
+        assertTrue(new File("./target/tmp/test/folder1/folder 3").isDirectory());
+        Helper.removeDir(new File(to));
+    }
+
+
+}
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
deleted file mode 100644
index 98467e463a..0000000000
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- * @author Peter Karich
- */
-public class CoordTrigTest {
-
-}
diff --git a/reader-json/src/test/resources/com/graphhopper/storage/change/overlaydata1.json b/core/src/test/resources/com/graphhopper/storage/change/overlaydata1.json
similarity index 100%
rename from reader-json/src/test/resources/com/graphhopper/storage/change/overlaydata1.json
rename to core/src/test/resources/com/graphhopper/storage/change/overlaydata1.json
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
index 349e816816..5d31ab1c2c 100644
--- a/docs/core/elevation.md
+++ b/docs/core/elevation.md
@@ -1,7 +1,7 @@
 # Elevation
 
 Per default elevation is disabled. But you can easily enable it e.g. via
-`graph.elevation.provider=cgiar`. Or use other possibilities `srtm`, `gmted`
+`graph.elevation.provider: cgiar`. Or use other possibilities `srtm`, `gmted`
 or `multi` (combined cgiar and gmted).
 
 Then GraphHopper will automatically download the necessary data for the area and include elevation 
@@ -9,7 +9,7 @@ for all vehicles - making also the distances a bit more precise.
 
 The default cache directory `/tmp/<provider name>` will be used. For large areas it is highly recommended to 
 use a SSD disc, thus you need to specify the cache directory:
-`graph.elevation.cache_dir=/myssd/ele_cache/`
+`graph.elevation.cache_dir: /myssd/ele_cache/`
 
 ## What to download and where to store it? 
 
@@ -23,7 +23,7 @@ where the last one is only accessibly if you specify the
 [full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
 
 If the geographical area is small and you need a faster import you can change the default MMAP setting to:
-`graph.elevation.dataaccess=RAM_STORE`
+`graph.elevation.dataaccess: RAM_STORE`
 
 ## CGIAR vs. SRTM
 
@@ -36,4 +36,4 @@ Using SRTM instead CGIAR has the minor advantage of a faster download, especiall
 
 Integrating your own elevation data is easy and just requires you to implement the
 ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
-Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 2352ddc1d7..4189c69686 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -30,6 +30,12 @@ $ ./graphhopper.sh -a web -i north-america_us_new-york.pbf -o new-york-gh
 # the format follows the link structure at http://download.geofabrik.de
 ```
 
+For larger maps you might need to allow the JVM to access more memory. For example for 2GB you can do this using:
+```bash
+$ export JAVA_OPTS="-Xmx2g -Xms2g"
+```
+before running `graphhopper.sh`.
+
 ## Start Development
 
 Open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
diff --git a/docs/index.md b/docs/index.md
index fbf43ffd10..27bf02ebe4 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -62,7 +62,9 @@ Various topics are explained in more detail separately:
  * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
  * [Spatial Rules](./core/spatial-rules.md): Instruction on how to use and create new SpatialRules. SpatialRules are used to enforce country-specific routing rules.
  * [Turn Restrictions](./core/turn-restrictions.md): Details on how to enable and use turn restrictions.
- * [Postgis query script](../core/files/postgis)
+ * [Isochrone generation in Java](./isochrone/java.md): Instruction on how to create isochrones using the low-level Java API.
+ * [Postgis query script](./core/files/postgis)
+
 
 #### Other links
 
diff --git a/docs/isochrone/images/isochrone.png b/docs/isochrone/images/isochrone.png
new file mode 100644
index 0000000000..0c35554113
Binary files /dev/null and b/docs/isochrone/images/isochrone.png differ
diff --git a/docs/isochrone/java.md b/docs/isochrone/java.md
new file mode 100644
index 0000000000..a115815283
--- /dev/null
+++ b/docs/isochrone/java.md
@@ -0,0 +1,35 @@
+# Isochrone via Java API
+
+To use the following examples you need to specify the dependency in
+your [Maven config](/README.md#maven) correctly.
+
+To create an isochrone in Java code:
+
+You'll first need to build off an existing Graphhopper instance for [routing](/../core/routing.md).
+
+Next, compute the isochrone itself.
+```java
+
+// get encoder from GraphHopper instance
+EncodingManager encodingManager = hopper.getEncodingManager();
+FlagEncoder encoder = encodingManager.getEncoder("car");
+
+// pick the closest point on the graph to the query point and generate a query graph
+QueryResult qr = hopper.getLocationIndex().findClosest(lat, lon, DefaultEdgeFilter.allEdges(encoder));
+
+Graph graph = hopper.getGraphHopperStorage();
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(Collections.singletonList(qr));
+
+// calculate isochrone from query graph
+PMap pMap = new PMap();
+Isochrone isochrone = new Isochrone(queryGraph, new FastestWeighting(carEncoder, pmap), false);
+isochrone.setTimeLimit(60);
+
+List<List<Double[]>> res = isochrone.searchGPS(qr.getClosestNode(), 1L);
+```
+
+The returned list will represent a point list. It can also be converted into a polygon.
+
+See [GraphHopper's servlet](https://github.com/graphhopper/graphhopper/blob/master/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java)
+for more comprehensive construction of an isochrone.
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 84d45222b7..8b06a1cbf9 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -6,9 +6,9 @@ server you need to understand how to use it. There is a separate [JavaScript](ht
 ### A simple example
 [http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959](http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959)
 
-The end point of the local instance is [http://localhost:8989](http://localhost:8989)
+The URL path of the local instance is [http://localhost:8989](http://localhost:8989)
 
-The URL path to obtain the route is `/route`
+The endpoint to obtain the route is `/route`
 
 ## Parameters
 
@@ -24,7 +24,7 @@ elevation   | false   | If `true` a third dimension - the elevation - is include
 points_encoded   | true    | If `false` the coordinates in `point` and `snapped_waypoints` are returned as array using the order [lon,lat,elevation] for every point. If `true` the coordinates will be encoded as string leading to less bandwith usage. You'll need a special handling for the decoding of this string on the client-side. We provide open source code in [Java](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/WebHelper.java#L43) and [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js#L139). It is especially important to use no 3rd party client if you set `elevation=true`!
 debug            | false   | If true, the output will be formated.
 calc_points      | true    | If the points for the route should be calculated at all printing out only distance and time.
-type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `jsonp` you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
+type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
 point_hint       | -       | Optional parameter. Specifies a hint for each `point` parameter to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
 details          | -       | Optional parameter. You can request additional details for the route: `average_speed`, `street_name`, `edge_id`, and `time`. The returned format for one details is `[fromRef, toRef, value]`. The `ref` references the points of the response.
 
@@ -220,3 +220,21 @@ HTTP error code | Reason
 500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
+
+## Isochrone
+
+In addition to routing, the end point to obtain an isochrone is `/isochrone`.
+
+[http://localhost:8989/isochrone](http://localhost:8989/isochrone)
+
+All parameters are shown in the following table.
+
+Parameter                   | Default | Description
+:---------------------------|:--------|:-----------
+vehicle                     | car     | The vehicle for which the route should be calculated. Other vehicles are foot, bike, motorcycle, hike, ...
+buckets                     | 1       | Number by which to divide the given `time_limit` to create `buckets` nested isochrones of time intervals `time_limit/buckets`, `time_limit/(buckets - 1)`, ... , `time_limit`. Applies analogously to `distance_limit`.
+reverse_flow                | false   | If false the flow goes from point to the polygon, if true the flow goes from the polygon inside to the point. Example usage for false: *How many potential customer can be reached within 30min travel time from your store* vs. true: *How many customers can reach your store within 30min travel time.* (optional, default to false)
+point                       |         | Specify the start coordinate (required). A string organized as `latitude,longitude`.
+result                      | polygon | Can be "pointlist" or "polygon".
+time_limit                  | 600     | Specify which time the vehicle should travel. In seconds. (optional, default to 600)
+distance_limit              | -1      | Specify which distance the vehicle should travel. In meter. (optional, default to -1)
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index 45acff304e..a28bd1fc1a 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -3,11 +3,15 @@
 If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
 The following steps are simpler and only need the JRE, a jar file and an OSM file.
 
- 1. Install the latest JRE and get the [GraphHopper Web Service](https://github.com/graphhopper/graphhopper/blob/master/README.md#get-started)
-as jar file
- 2. Copy an OSM file to the same directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
- 3. Start GraphHopper Maps via: `java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-example.yml`
- 4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
+ 1. Install the latest JRE 
+ 2. Get the [GraphHopper Web Service](https://github.com/graphhopper/graphhopper/blob/master/README.md#get-started)
+as jar file and download this [config-example.yml](https://raw.githubusercontent.com/graphhopper/graphhopper/master/config-example.yml)
+ 3. Copy an OSM file to the same directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
+ 4. Start GraphHopper Maps via: 
+    ```bash
+    java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-example.yml
+    ```
+ 5. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
 
 See [here](./../core/elevation.md) how to easily enable elevation data. To see how GraphHopper is configured for production usage, see the [deployment guide](./../core/deploy.md).
 
@@ -17,4 +21,6 @@ See [here](./../core/elevation.md) how to easily enable elevation data. To see h
  * Regarding step 2:
     * The folder where you execute the java command should contain the following files: berlin-latest.osm.pbf, config-example.yml and `graphhopper-web-[version].jar`
     * The first time you execute this it'll take ~30 seconds (for Berlin), further starts will only load the graph and should be nearly instantaneous. You should see log statements but no exceptions and the last entry should be something like: Started server at HTTP 8989
+ * Regarding step 3:
+    * Depending on the size of the map you might run into `java.lang.OutOfMemoryError`. In this case you need to increase the memory settings of the JVM by starting the above command with `java -Xmx2g -Xms2g ...` (example for 2GB memory)
  * Or [contact us](../index.md#contact)
diff --git a/graphhopper.sh b/graphhopper.sh
index 80b1d52e9c..4e76798c63 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -224,14 +224,14 @@ LINK=$(echo $NAME | tr '_' '/')
 if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.bz2"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
 elif [ ${FILE: -4} == ".ghz" ]; then
    LINK="https://graphhopper.com/public/maps/0.1/$FILE"
 elif [ ${FILE: -4} == ".pbf" ]; then
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.pbf"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 else
    # e.g. if directory ends on '-gh'
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.pbf"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
 : "${JAVA_OPTS:=-Xmx1000m -Xms1000m}"
diff --git a/isochrone/pom.xml b/isochrone/pom.xml
index 803a338902..3482995f05 100644
--- a/isochrone/pom.xml
+++ b/isochrone/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-isochrone</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <name>GraphHopper Isochrone</name>
     <description>Isochrone calculation with GraphHopper</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
 
 
@@ -24,6 +24,19 @@
             <version>${project.parent.version}</version>
         </dependency>
 
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>${log4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
index 593c24a68a..ae612cba4b 100644
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
@@ -13,10 +13,10 @@
 
 package com.graphhopper.isochrone.algorithm;
 
-import com.vividsolutions.jts.algorithm.CGAlgorithms;
-import com.vividsolutions.jts.geom.*;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdge;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.algorithm.CGAlgorithms;
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.triangulate.quadedge.QuadEdge;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
 
 import java.util.*;
 
@@ -40,7 +40,7 @@ public ContourBuilder(QuadEdgeSubdivision triangulation) {
         this.triangulation = triangulation;
     }
 
-    public Geometry computeIsoline(double z0) {
+    public MultiPolygon computeIsoline(double z0) {
         Set<QuadEdge> processed = new HashSet<>();
         List<LinearRing> rings = new ArrayList<>();
 
@@ -107,8 +107,8 @@ private Coordinate moveEpsilonTowards(Coordinate coordinate, Coordinate distantF
     }
 
     private int cut(double za, double zb, double z0) {
-        if (za < z0 && zb > z0) return 1;
-        if (za > z0 && zb < z0) return -1;
+        if (za <= z0 && zb > z0) return 1;
+        if (za > z0 && zb <= z0) return -1;
         return 0;
     }
 
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java
new file mode 100644
index 0000000000..75b66bcca4
--- /dev/null
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java
@@ -0,0 +1,87 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.isochrone.algorithm;
+
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
+import org.locationtech.jts.triangulate.ConstraintVertex;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.triangulate.quadedge.Vertex;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ * @author Michael Zilske
+ */
+public class DelaunayTriangulationIsolineBuilder {
+
+    /**
+     * @return a list of polygons wrapping the specified points
+     */
+    @SuppressWarnings("unchecked")
+    public List<Coordinate[]> calcList(List<List<Coordinate>> pointLists, int maxIsolines) {
+
+        if (maxIsolines > pointLists.size()) {
+            throw new IllegalStateException("maxIsolines can only be smaller or equals to pointsList");
+        }
+
+        Collection<ConstraintVertex> sites = new ArrayList<>();
+        for (int i = 0; i < pointLists.size(); i++) {
+            List<Coordinate> level = pointLists.get(i);
+            for (Coordinate coord : level) {
+                ConstraintVertex site = new ConstraintVertex(coord);
+                site.setZ((double) i);
+                sites.add(site);
+            }
+        }
+        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
+        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
+        conformingDelaunayTriangulator.formInitialDelaunay();
+        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
+        for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+            if (tin.isFrameVertex(vertex)) {
+                vertex.setZ(Double.MAX_VALUE);
+            }
+        }
+        ArrayList<Coordinate[]> polygonShells = new ArrayList<>();
+        ContourBuilder contourBuilder = new ContourBuilder(tin);
+        // ignore the last isoline as it forms just the convex hull
+        for (int i = 0; i < maxIsolines; i++) {
+            MultiPolygon multiPolygon = contourBuilder.computeIsoline((double) i + 0.5);
+            int maxPoints = 0;
+            Polygon maxPolygon = null;
+            for (int j = 0; j < multiPolygon.getNumGeometries(); j++) {
+                Polygon polygon = (Polygon) multiPolygon.getGeometryN(j);
+                if (polygon.getNumPoints() > maxPoints) {
+                    maxPoints = polygon.getNumPoints();
+                    maxPolygon = polygon;
+                }
+            }
+            if (maxPolygon == null) {
+                throw new IllegalStateException("no maximum polygon was found?");
+            } else {
+                polygonShells.add(maxPolygon.getExteriorRing().getCoordinates());
+            }
+        }
+        return polygonShells;
+    }
+
+}
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
index 771191ad39..abb378ba53 100644
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
@@ -29,6 +29,7 @@
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+import org.locationtech.jts.geom.Coordinate;
 
 import java.util.*;
 
@@ -102,14 +103,14 @@ public void setDistanceLimit(double limit) {
         this.finishLimit = limit + Math.max(limit * 0.14, 2_000);
     }
 
-    public List<List<Double[]>> searchGPS(int from, final int bucketCount) {
+    public List<List<Coordinate>> searchGPS(int from, final int bucketCount) {
         searchInternal(from);
 
         final double bucketSize = limit / bucketCount;
-        final List<List<Double[]>> buckets = new ArrayList<>(bucketCount);
+        final List<List<Coordinate>> buckets = new ArrayList<>(bucketCount);
 
         for (int i = 0; i < bucketCount + 1; i++) {
-            buckets.add(new ArrayList<Double[]>());
+            buckets.add(new ArrayList<Coordinate>());
         }
         final NodeAccess na = graph.getNodeAccess();
         fromMap.forEach(new IntObjectProcedure<IsoLabel>() {
@@ -125,14 +126,14 @@ public void apply(int nodeId, IsoLabel label) {
 
                 double lat = na.getLatitude(nodeId);
                 double lon = na.getLongitude(nodeId);
-                buckets.get(bucketIndex).add(new Double[]{lon, lat});
+                buckets.get(bucketIndex).add(new Coordinate(lon, lat));
 
                 // guess center of road to increase precision a bit for longer roads
                 if (label.parent != null) {
                     nodeId = label.parent.adjNode;
                     double lat2 = na.getLatitude(nodeId);
                     double lon2 = na.getLongitude(nodeId);
-                    buckets.get(bucketIndex).add(new Double[]{(lon + lon2) / 2, (lat + lat2) / 2});
+                    buckets.get(bucketIndex).add(new Coordinate((lon + lon2) / 2, (lat + lat2) / 2));
                 }
             }
         });
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java
deleted file mode 100644
index c54f0b7670..0000000000
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.isochrone.algorithm;
-
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.LineString;
-import com.vividsolutions.jts.geom.MultiPolygon;
-import com.vividsolutions.jts.geom.Point;
-import com.vividsolutions.jts.geom.Polygon;
-import com.vividsolutions.jts.triangulate.ConformingDelaunayTriangulator;
-import com.vividsolutions.jts.triangulate.ConstraintVertex;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
-import com.vividsolutions.jts.triangulate.quadedge.Vertex;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * @author Peter Karich
- * @author Michael Zilske
- */
-public class RasterHullBuilder {
-
-    /**
-     * @return a list of polygons wrapping the specified points
-     */
-    @SuppressWarnings("unchecked")
-    public List<List<Double[]>> calcList(List<List<Double[]>> pointsList, int maxIsolines) {
-
-        if (maxIsolines > pointsList.size()) {
-            throw new IllegalStateException("maxIsolines can only be smaller or equals to pointsList");
-        }
-
-        Collection<ConstraintVertex> sites = new ArrayList<>();
-        for (int i = 0; i < pointsList.size(); i++) {
-            List<Double[]> level = pointsList.get(i);
-            for (Double[] xy : level) {
-                ConstraintVertex site = new ConstraintVertex(new Coordinate(xy[0], xy[1]));
-                site.setZ((double) i);
-                sites.add(site);
-            }
-        }
-        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
-        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
-        conformingDelaunayTriangulator.formInitialDelaunay();
-        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
-        for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
-            if (tin.isFrameVertex(vertex)) {
-                vertex.setZ(Double.MAX_VALUE);
-            }
-        }
-        ArrayList<List<Double[]>> polygons = new ArrayList<>();
-        ContourBuilder contourBuilder = new ContourBuilder(tin);
-        // ignore the last polygon as it forms just the convex hull
-        for (int i = 0; i < maxIsolines; i++) {
-            Geometry geometry = contourBuilder.computeIsoline((double) i + 0.5);
-            List<Double[]> coords = new ArrayList<Double[]>();
-            if (geometry instanceof MultiPolygon) {
-                MultiPolygon mPoly = (MultiPolygon) geometry;
-                int maxPoints = 0;
-                Geometry maxGeo = null;
-                for (int j = 0; j < mPoly.getNumGeometries(); j++) {
-                    Geometry geo = mPoly.getGeometryN(j);
-                    if (geo.getNumPoints() > maxPoints) {
-                        maxPoints = geo.getNumPoints();
-                        maxGeo = geo;
-                    }
-                }
-
-                if (maxGeo == null) {
-                    throw new IllegalStateException("no maximum polygon was found?");
-                } else {
-                    fillExteriorRing(coords, maxGeo);
-                }
-            } else if (geometry instanceof Polygon) {
-                fillExteriorRing(coords, geometry);
-            } else {
-                throw new IllegalStateException("geometry no (multi)polygon");
-            }
-
-            polygons.add(coords);
-        }
-
-        return polygons;
-    }
-
-    private void fillExteriorRing(List<Double[]> coords, Geometry geo) {
-        if (geo instanceof Polygon) {
-            // normally this will be picked
-            Polygon poly = (Polygon) geo;
-            LineString ls = poly.getExteriorRing();
-            for (int j = 0; j < ls.getNumPoints(); j++) {
-                Point p = ls.getPointN(j);
-                coords.add(new Double[]{p.getX(), p.getY()});
-            }
-        } else {
-            int len = geo.getCoordinates().length;
-            Coordinate first = geo.getCoordinates()[0];
-            for (int j = 0; j < len; j++) {
-                Coordinate coord = geo.getCoordinates()[j];
-                // lon, lat
-                coords.add(new Double[]{coord.x, coord.y});
-
-                if (j > 10 && coord.x == first.x && coord.y == first.y) {
-                    break;
-                }
-            }
-        }
-    }
-
-}
diff --git a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java
new file mode 100644
index 0000000000..a03241a981
--- /dev/null
+++ b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java
@@ -0,0 +1,32 @@
+package com.graphhopper.isochrone.algorithm;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Assert;
+import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class DelaunayTriangulationIsolineBuilderTest {
+
+    @Test
+    public void testCalc() {
+        DelaunayTriangulationIsolineBuilder instance = new DelaunayTriangulationIsolineBuilder();
+        List<List<Coordinate>> listOfList = new ArrayList<>();
+        List<Coordinate> list = new ArrayList<>();
+        listOfList.add(list);
+        // lon,lat!
+        list.add(new Coordinate(0.000, 0.000));
+        list.add(new Coordinate(0.001, 0.000));
+        list.add(new Coordinate(0.001, 0.001));
+        list.add(new Coordinate(0.001, 0.002));
+        list.add(new Coordinate(0.000, 0.002));
+
+        List<Coordinate[]> res = instance.calcList(listOfList, listOfList.size());
+        Coordinate[] geometry = res.get(0);
+        Assert.assertEquals(9, geometry.length);
+    }
+}
diff --git a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java
deleted file mode 100644
index 98609c3b45..0000000000
--- a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.graphhopper.isochrone.algorithm;
-
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- *
- * @author Peter Karich
- */
-public class RasterHullBuilderTest {
-
-    @Test
-    public void testCalc() {
-        RasterHullBuilder instance = new RasterHullBuilder();
-        List<List<Double[]>> listOfList = new ArrayList<List<Double[]>>();
-        List<Double[]> list = new ArrayList<Double[]>();
-        listOfList.add(list);
-        // lon,lat!
-        list.add(new Double[]{0.000, 0.000});
-        list.add(new Double[]{0.001, 0.000});
-        list.add(new Double[]{0.001, 0.001});
-        list.add(new Double[]{0.001, 0.002});
-        list.add(new Double[]{0.000, 0.002});
-
-        List<List<Double[]>> res = instance.calcList(listOfList, listOfList.size());
-        List<Double[]> geometry = res.get(0);
-        Assert.assertEquals(9, geometry.size());
-    }
-}
diff --git a/pom.xml b/pom.xml
index d6da149d48..518205dc56 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>pom</packaging>
     <url>https://www.graphhopper.com</url>
     <inceptionYear>2012</inceptionYear>
@@ -17,8 +17,10 @@
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
         <slf4j.version>1.7.25</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
-        <commons-compress.version>1.12</commons-compress.version>
-        <jackson.version>2.9.1</jackson.version>
+        <commons-compress.version>1.15</commons-compress.version>
+        <jackson.version>2.9.6</jackson.version>
+        <dropwizard.version>1.3.5</dropwizard.version>
+        <directions-api-client.version>0.10.1-3</directions-api-client.version>
         <maven.compiler.target>1.8</maven.compiler.target>
 
         <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
@@ -76,8 +78,10 @@
         <module>reader-osm</module>
         <module>isochrone</module>
         <module>reader-gtfs</module>
-        <module>reader-json</module>
         <module>tools</module>
+        <module>web-bundle</module>
+        <module>api</module>
+        <module>web-api</module>
         <module>web</module>
         <module>client-hc</module>
     </modules>
@@ -86,7 +90,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
+                <version>3.8.0</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -105,7 +109,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.19.1</version>
+                <version>2.22.1</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -114,7 +118,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.19.1</version>
+                <version>2.22.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -128,12 +132,12 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>3.0.0</version>
+                <version>3.1.0</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>3.0.2</version>
+                <version>3.1.0</version>
             </plugin>
             <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml -->
             <plugin>
@@ -149,13 +153,21 @@
             </plugin>
 
             <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>findbugs-maven-plugin</artifactId>
-                <version>3.0.5</version>
+                <groupId>com.github.spotbugs</groupId>
+                <artifactId>spotbugs-maven-plugin</artifactId>
+                <version>3.1.6</version>
+                <!-- required as 3.1.7 is not yet released for the plugin but we hit problem spotbugs#711 -->
+                <dependencies>
+		    <dependency>
+		      <groupId>com.github.spotbugs</groupId>
+		      <artifactId>spotbugs</artifactId>
+		      <version>3.1.7</version>
+		    </dependency>
+		</dependencies>
                 <configuration>
                     <maxRank>4</maxRank>
                     <failOnError>true</failOnError>
-                    <excludeFilterFile>core/files/findbugs-exclude.xml</excludeFilterFile>
+                    <excludeFilterFile>core/files/spotbugs-exclude.xml</excludeFilterFile>
                 </configuration>
             </plugin>
             <plugin>
@@ -171,7 +183,7 @@
             <plugin>
                 <groupId>de.thetaphi</groupId>
                 <artifactId>forbiddenapis</artifactId>
-                <version>2.5</version>
+                <version>2.6</version>
                 <configuration>
                     <!--
                       if the used Java version is too new,
@@ -189,10 +201,6 @@
                         <bundledSignature>jdk-non-portable</bundledSignature>
                     </bundledSignatures>
                     <excludes>
-                        <!-- Excluded because of "Helper7#getBeanMemInfo" -->
-                        <exclude>
-                            com/graphhopper/util/Helper7.class
-                        </exclude>
                         <exclude>
                             com/graphhopper/storage/UnsafeDataAccess.class
                         </exclude>
@@ -220,12 +228,6 @@
             <activation>
                 <activeByDefault>false</activeByDefault>
             </activation>
-            <!-- this exception is valid for jdk8 profile below too -->
-            <modules>
-                <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
-                Currently works for jdk8 only -->
-                <module>reader-shp</module>
-            </modules>
             <build>
                 <plugins>
                     <plugin>
@@ -245,7 +247,7 @@
                     <plugin>
                         <groupId>org.sonatype.plugins</groupId>
                         <artifactId>nexus-staging-maven-plugin</artifactId>
-                        <version>1.6.7</version>
+                        <version>1.6.8</version>
                         <extensions>true</extensions>
                         <configuration>
                             <serverId>ossrh</serverId>
@@ -257,7 +259,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
-                        <version>2.10.4</version>
+                        <version>3.0.1</version>
                         <configuration>
                           <quiet>true</quiet>
                         </configuration>
@@ -295,17 +297,6 @@
                 <module>android/app</module>
             </modules>
         </profile>
-	<profile>
-            <id>jdk10</id>
-            <activation>
-                <activeByDefault>false</activeByDefault>
-                <jdk>10</jdk>
-            </activation>
-            <properties>
-              <maven.compiler.source>10</maven.compiler.source>
-              <maven.compiler.target>10</maven.compiler.target>
-            </properties>
-        </profile>
 
     </profiles>
 
diff --git a/reader-gtfs/files/sample-feed.zip b/reader-gtfs/files/sample-feed.zip
index 8047a41b77..ac51e28a03 100644
Binary files a/reader-gtfs/files/sample-feed.zip and b/reader-gtfs/files/sample-feed.zip differ
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index 2809f303fb..c8be32a98e 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-gtfs</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for Gtfs Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -27,23 +27,24 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.conveyal</groupId>
-            <artifactId>gtfs-lib</artifactId>
-            <version>2.1.0</version>
-            <exclusions>
-                <exclusion> 
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-simple</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.vividsolutions</groupId>
-                    <artifactId>jts</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.amazonaws</groupId>
-                    <artifactId>aws-java-sdk-s3</artifactId>
-                </exclusion>
-            </exclusions>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>24.0-jre</version>
+        </dependency>
+        <dependency>
+            <groupId>net.sourceforge.javacsv</groupId>
+            <artifactId>javacsv</artifactId>
+            <version>2.0</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+        <dependency>
+            <groupId>org.mapdb</groupId>
+            <artifactId>mapdb</artifactId>
+            <version>1.0.8</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -93,13 +94,18 @@
             <version>3.6.2</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <version>2.23.0</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -113,29 +119,12 @@
                     <target>1.8</target>
                 </configuration>
             </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>                
-                <configuration>
-                    <archive>
-                        <manifest>
-                            <mainClass>com.graphhopper.import.osm.Import</mainClass>
-                        </manifest>
-                    </archive>
-                        	                    
-                    <!-- for standalone usage -->
-                    <descriptorRefs>
-                        <descriptorRef>jar-with-dependencies</descriptorRef>
-                    </descriptorRefs>
-                </configuration>
-            </plugin>
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.19.1</version>
                 <!-- Currently we need a bit more memory than for other tests -->
                 <configuration>
-                    <argLine>-Xmx2000m -Xms2000m</argLine>
+                    <argLine>-Xmx1200m -Xms1200m</argLine>
                 </configuration>
             </plugin>
         </plugins>
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java
new file mode 100644
index 0000000000..dd27df96d1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java
@@ -0,0 +1,475 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs;
+
+import com.conveyal.gtfs.error.GTFSError;
+import com.conveyal.gtfs.model.*;
+import com.conveyal.gtfs.model.Calendar;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ExecutionError;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.CoordinateList;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+import org.mapdb.BTreeMap;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
+import org.mapdb.Fun;
+import org.mapdb.Fun.Tuple2;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOError;
+import java.io.IOException;
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.concurrent.ConcurrentNavigableMap;
+import java.util.concurrent.ExecutionException;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * All entities must be from a single feed namespace.
+ * Composed of several GTFSTables.
+ */
+public class GTFSFeed implements Cloneable, Closeable {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GTFSFeed.class);
+
+    private DB db;
+
+    public String feedId = null;
+
+    public final Map<String, Agency> agency;
+    public final Map<String, FeedInfo> feedInfo;
+    // This is how you do a multimap in mapdb: https://github.com/jankotek/MapDB/blob/release-1.0/src/test/java/examples/MultiMap.java
+    public final NavigableSet<Tuple2<String, Frequency>> frequencies;
+    public final Map<String, Route> routes;
+    public final Map<String, Stop> stops;
+    public final Map<String, Transfer> transfers;
+    public final BTreeMap<String, Trip> trips;
+
+    /** CRC32 of the GTFS file this was loaded from */
+    public long checksum;
+
+    /* Map from 2-tuples of (shape_id, shape_pt_sequence) to shape points */
+    public final ConcurrentNavigableMap<Tuple2<String, Integer>, ShapePoint> shape_points;
+
+    /* Map from 2-tuples of (trip_id, stop_sequence) to stoptimes. */
+    public final BTreeMap<Tuple2, StopTime> stop_times;
+
+    /* A fare is a fare_attribute and all fare_rules that reference that fare_attribute. */
+    public final Map<String, Fare> fares;
+
+    /* A service is a calendar entry and all calendar_dates that modify that calendar entry. */
+    public final BTreeMap<String, Service> services;
+
+    /* A place to accumulate errors while the feed is loaded. Tolerate as many errors as possible and keep on loading. */
+    public final NavigableSet<GTFSError> errors;
+
+    /* Create geometry factory to produce LineString geometries. */
+    private GeometryFactory gf = new GeometryFactory();
+
+    private boolean loaded = false;
+
+    /**
+     * The order in which we load the tables is important for two reasons.
+     * 1. We must load feed_info first so we know the feed ID before loading any other entities. This could be relaxed
+     * by having entities point to the feed object rather than its ID String.
+     * 2. Referenced entities must be loaded before any entities that reference them. This is because we check
+     * referential integrity while the files are being loaded. This is done on the fly during loading because it allows
+     * us to associate a line number with errors in objects that don't have any other clear identifier.
+     *
+     * Interestingly, all references are resolvable when tables are loaded in alphabetical order.
+     */
+    public void loadFromFile(ZipFile zip, String fid) throws Exception {
+        if (this.loaded) throw new UnsupportedOperationException("Attempt to load GTFS into existing database");
+
+        // NB we don't have a single CRC for the file, so we combine all the CRCs of the component files. NB we are not
+        // simply summing the CRCs because CRCs are (I assume) uniformly randomly distributed throughout the width of a
+        // long, so summing them is a convolution which moves towards a Gaussian with mean 0 (i.e. more concentrated
+        // probability in the center), degrading the quality of the hash. Instead we XOR. Assuming each bit is independent,
+        // this will yield a nice uniformly distributed result, because when combining two bits there is an equal
+        // probability of any input, which means an equal probability of any output. At least I think that's all correct.
+        // Repeated XOR is not commutative but zip.stream returns files in the order they are in the central directory
+        // of the zip file, so that's not a problem.
+        checksum = zip.stream().mapToLong(ZipEntry::getCrc).reduce((l1, l2) -> l1 ^ l2).getAsLong();
+
+        db.getAtomicLong("checksum").set(checksum);
+
+        new FeedInfo.Loader(this).loadTable(zip);
+        // maybe we should just point to the feed object itself instead of its ID, and null out its stoptimes map after loading
+        if (fid != null) {
+            feedId = fid;
+            LOG.info("Feed ID is undefined, pester maintainers to include a feed ID. Using file name {}.", feedId); // TODO log an error, ideally feeds should include a feedID
+        }
+        else if (feedId == null || feedId.isEmpty()) {
+            feedId = new File(zip.getName()).getName().replaceAll("\\.zip$", "");
+            LOG.info("Feed ID is undefined, pester maintainers to include a feed ID. Using file name {}.", feedId); // TODO log an error, ideally feeds should include a feedID
+        }
+        else {
+            LOG.info("Feed ID is '{}'.", feedId);
+        }
+
+        db.getAtomicString("feed_id").set(feedId);
+
+        new Agency.Loader(this).loadTable(zip);
+
+        // calendars and calendar dates are joined into services. This means a lot of manipulating service objects as
+        // they are loaded; since mapdb keys/values are immutable, load them in memory then copy them to MapDB once
+        // we're done loading them
+        Map<String, Service> serviceTable = new HashMap<>();
+        new Calendar.Loader(this, serviceTable).loadTable(zip);
+        new CalendarDate.Loader(this, serviceTable).loadTable(zip);
+        this.services.putAll(serviceTable);
+        serviceTable = null; // free memory
+
+        // Same deal
+        Map<String, Fare> fares = new HashMap<>();
+        new FareAttribute.Loader(this, fares).loadTable(zip);
+        new FareRule.Loader(this, fares).loadTable(zip);
+        this.fares.putAll(fares);
+        fares = null; // free memory
+
+        new Route.Loader(this).loadTable(zip);
+        new ShapePoint.Loader(this).loadTable(zip);
+        new Stop.Loader(this).loadTable(zip);
+        new Transfer.Loader(this).loadTable(zip);
+        new Trip.Loader(this).loadTable(zip);
+        new Frequency.Loader(this).loadTable(zip);
+        new StopTime.Loader(this).loadTable(zip); // comment out this line for quick testing using NL feed
+        loaded = true;
+    }
+
+    public void loadFromFile(ZipFile zip) throws Exception {
+        loadFromFile(zip, null);
+    }
+
+    public boolean hasFeedInfo () {
+        return !this.feedInfo.isEmpty();
+    }
+
+    public FeedInfo getFeedInfo () {
+        return this.hasFeedInfo() ? this.feedInfo.values().iterator().next() : null;
+    }
+
+    /**
+     * For the given trip ID, fetch all the stop times in order of increasing stop_sequence.
+     * This is an efficient iteration over a tree map.
+     */
+    public Iterable<StopTime> getOrderedStopTimesForTrip (String trip_id) {
+        Map<Fun.Tuple2, StopTime> tripStopTimes =
+                stop_times.subMap(
+                        Fun.t2(trip_id, null),
+                        Fun.t2(trip_id, Fun.HI)
+                );
+        return tripStopTimes.values();
+    }
+
+    /** Get the shape for the given shape ID */
+    public Shape getShape (String shape_id) {
+        Shape shape = new Shape(this, shape_id);
+        return shape.shape_dist_traveled.length > 0 ? shape : null;
+    }
+
+    /**
+     * For the given trip ID, fetch all the stop times in order, and interpolate stop-to-stop travel times.
+     */
+    public Iterable<StopTime> getInterpolatedStopTimesForTrip (String trip_id) throws FirstAndLastStopsDoNotHaveTimes {
+        // clone stop times so as not to modify base GTFS structures
+        StopTime[] stopTimes = StreamSupport.stream(getOrderedStopTimesForTrip(trip_id).spliterator(), false)
+                .map(st -> st.clone())
+                .toArray(i -> new StopTime[i]);
+
+        // avoid having to make sure that the array has length below.
+        if (stopTimes.length == 0) return Collections.emptyList();
+
+        // first pass: set all partially filled stop times
+        for (StopTime st : stopTimes) {
+            if (st.arrival_time != Entity.INT_MISSING && st.departure_time == Entity.INT_MISSING) {
+                st.departure_time = st.arrival_time;
+            }
+
+            if (st.arrival_time == Entity.INT_MISSING && st.departure_time != Entity.INT_MISSING) {
+                st.arrival_time = st.departure_time;
+            }
+        }
+
+        // quick check: ensure that first and last stops have times.
+        // technically GTFS requires that both arrival_time and departure_time be filled at both the first and last stop,
+        // but we are slightly more lenient and only insist that one of them be filled at both the first and last stop.
+        // The meaning of the first stop's arrival time is unclear, and same for the last stop's departure time (except
+        // in the case of interlining).
+
+        // it's fine to just check departure time, as the above pass ensures that all stop times have either both
+        // arrival and departure times, or neither
+        if (stopTimes[0].departure_time == Entity.INT_MISSING || stopTimes[stopTimes.length - 1].departure_time == Entity.INT_MISSING) {
+            throw new FirstAndLastStopsDoNotHaveTimes();
+        }
+
+        // second pass: fill complete stop times
+        int startOfInterpolatedBlock = -1;
+        for (int stopTime = 0; stopTime < stopTimes.length; stopTime++) {
+
+            if (stopTimes[stopTime].departure_time == Entity.INT_MISSING && startOfInterpolatedBlock == -1) {
+                startOfInterpolatedBlock = stopTime;
+            }
+            else if (stopTimes[stopTime].departure_time != Entity.INT_MISSING && startOfInterpolatedBlock != -1) {
+                throw new RuntimeException("Missing stop times not supported.");
+            }
+        }
+
+        return Arrays.asList(stopTimes);
+    }
+
+    public Collection<Frequency> getFrequencies (String trip_id) {
+        // IntelliJ tells me all these casts are unnecessary, and that's also my feeling, but the code won't compile
+        // without them
+        return (List<Frequency>) frequencies.subSet(new Fun.Tuple2(trip_id, null), new Fun.Tuple2(trip_id, Fun.HI)).stream()
+                .map(t2 -> ((Tuple2<String, Frequency>) t2).b)
+                .collect(Collectors.toList());
+    }
+
+    public LineString getStraightLineForStops(String trip_id) {
+        CoordinateList coordinates = new CoordinateList();
+        LineString ls = null;
+        Trip trip = trips.get(trip_id);
+
+        Iterable<StopTime> stopTimes;
+        stopTimes = getOrderedStopTimesForTrip(trip.trip_id);
+        if (Iterables.size(stopTimes) > 1) {
+            for (StopTime stopTime : stopTimes) {
+                Stop stop = stops.get(stopTime.stop_id);
+                Double lat = stop.stop_lat;
+                Double lon = stop.stop_lon;
+                coordinates.add(new Coordinate(lon, lat));
+            }
+            ls = gf.createLineString(coordinates.toCoordinateArray());
+        }
+        // set ls equal to null if there is only one stopTime to avoid an exception when creating linestring
+        else{
+            ls = null;
+        }
+        return ls;
+    }
+
+    /**
+     * Returns a trip geometry object (LineString) for a given trip id.
+     * If the trip has a shape reference, this will be used for the geometry.
+     * Otherwise, the ordered stoptimes will be used.
+     *
+     * @param   trip_id   trip id of desired trip geometry
+     * @return          the LineString representing the trip geometry.
+     * @see             LineString
+     */
+    public LineString getTripGeometry(String trip_id){
+
+        CoordinateList coordinates = new CoordinateList();
+        LineString ls = null;
+        Trip trip = trips.get(trip_id);
+
+        // If trip has shape_id, use it to generate geometry.
+        if (trip.shape_id != null) {
+            Shape shape = getShape(trip.shape_id);
+            if (shape != null) ls = shape.geometry;
+        }
+
+        // Use the ordered stoptimes.
+        if (ls == null) {
+            ls = getStraightLineForStops(trip_id);
+        }
+
+        return ls;
+    }
+
+    /**
+     * Cloning can be useful when you want to make only a few modifications to an existing feed.
+     * Keep in mind that this is a shallow copy, so you'll have to create new maps in the clone for tables you want
+     * to modify.
+     */
+    @Override
+    public GTFSFeed clone() {
+        try {
+            return (GTFSFeed) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void close () {
+        db.close();
+    }
+
+    /** Thrown when we cannot interpolate stop times because the first or last stops do not have times */
+    public class FirstAndLastStopsDoNotHaveTimes extends RuntimeException {
+        /** do nothing */
+    }
+
+    /** Create a GTFS feed in a temp file */
+    public GTFSFeed () {
+        // calls to this must be first operation in constructor - why, Java?
+        this(DBMaker.newTempFileDB()
+                .transactionDisable()
+                .mmapFileEnable()
+                .asyncWriteEnable()
+                .deleteFilesAfterClose()
+                .compressionEnable()
+                // .cacheSize(1024 * 1024) this bloats memory consumption
+                .make()); // TODO db.close();
+    }
+
+    /** Create a GTFS feed connected to a particular DB, which will be created if it does not exist. */
+    public GTFSFeed (String dbFile) throws IOException, ExecutionException {
+        this(constructDB(dbFile)); // TODO db.close();
+    }
+
+    private static DB constructDB(String dbFile) {
+        DB db;
+        try{
+            DBMaker dbMaker = DBMaker.newFileDB(new File(dbFile));
+            db = dbMaker
+                    .transactionDisable()
+                    .mmapFileEnable()
+                    .asyncWriteEnable()
+                    .compressionEnable()
+//                     .cacheSize(1024 * 1024) this bloats memory consumption
+                    .make();
+            return db;
+        } catch (ExecutionError | IOError | Exception e) {
+            LOG.error("Could not construct db from file.", e);
+            return null;
+        }
+    }
+
+    private GTFSFeed (DB db) {
+        this.db = db;
+
+        agency = db.getTreeMap("agency");
+        feedInfo = db.getTreeMap("feed_info");
+        routes = db.getTreeMap("routes");
+        trips = db.getTreeMap("trips");
+        stop_times = db.getTreeMap("stop_times");
+        frequencies = db.getTreeSet("frequencies");
+        transfers = db.getTreeMap("transfers");
+        stops = db.getTreeMap("stops");
+        fares = db.getTreeMap("fares");
+        services = db.getTreeMap("services");
+        shape_points = db.getTreeMap("shape_points");
+
+        feedId = db.getAtomicString("feed_id").get();
+        checksum = db.getAtomicLong("checksum").get();
+
+        errors = db.getTreeSet("errors");
+    }
+
+    public LocalDate getStartDate() {
+        LocalDate startDate = null;
+
+        if (hasFeedInfo()) startDate = getFeedInfo().feed_start_date;
+        if (startDate == null) startDate = getCalendarServiceRangeStart();
+        if (startDate == null) startDate = getCalendarDateStart();
+
+        return startDate;
+    }
+
+    public LocalDate getCalendarServiceRangeStart() {
+
+        int startDate = 0;
+        for (Service service : services.values()) {
+            if (service.calendar == null)
+                continue;
+            if (startDate == 0 || service.calendar.start_date < startDate) {
+                startDate = service.calendar.start_date;
+            }
+        }
+        if (startDate == 0)
+            return null;
+
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd", Locale.getDefault());
+        return LocalDate.parse(String.valueOf(startDate), formatter);
+    }
+
+
+    public LocalDate getCalendarDateStart() {
+        LocalDate startDate = null;
+        for (Service service : services.values()) {
+            for (LocalDate date : service.calendar_dates.keySet()) {
+                if (startDate == null
+                        || date.isBefore(startDate))
+                    startDate = date;
+            }
+        }
+        return startDate;
+    }
+
+    public LocalDate getCalendarServiceRangeEnd() {
+
+        int endDate = 0;
+
+        for (Service service : services.values()) {
+            if (service.calendar == null)
+                continue;
+
+            if (endDate == 0 || service.calendar.end_date > endDate) {
+                endDate = service.calendar.end_date;
+            }
+        }
+        if (endDate == 0)
+            return null;
+
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd", Locale.getDefault());
+        return LocalDate.parse(String.valueOf(endDate), formatter);
+    }
+
+    public LocalDate getEndDate() {
+        LocalDate endDate = null;
+
+        if (hasFeedInfo()) endDate = getFeedInfo().feed_end_date;
+        if (endDate == null) endDate = getCalendarServiceRangeEnd();
+        if (endDate == null) endDate = getCalendarDateEnd();
+
+        return endDate;
+    }
+
+    public LocalDate getCalendarDateEnd() {
+        LocalDate endDate = null;
+        for (Service service : services.values()) {
+            for (LocalDate date : service.calendar_dates.keySet()) {
+                if (endDate == null
+                        || date.isAfter(endDate))
+                    endDate = date;
+            }
+        }
+        return endDate;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java
new file mode 100644
index 0000000000..15ea8bec8d
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.conveyal.gtfs.model.StopTime;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used as a map key when grouping trips by stop pattern. Note that this includes the routeId, so the same sequence of
+ * stops on two different routes makes two different patterns.
+ * These objects are not intended for use outside the grouping process.
+ */
+public class TripPatternKey {
+
+    public String routeId;
+    public List<String> stops = new ArrayList<>();
+    public IntArrayList pickupTypes = new IntArrayList();
+    public IntArrayList dropoffTypes = new IntArrayList();
+
+    public TripPatternKey (String routeId) {
+        this.routeId = routeId;
+    }
+
+    public void addStopTime (StopTime st) {
+        stops.add(st.stop_id);
+        pickupTypes.add(st.pickup_type);
+        dropoffTypes.add(st.drop_off_type);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        TripPatternKey that = (TripPatternKey) o;
+
+        if (dropoffTypes != null ? !dropoffTypes.equals(that.dropoffTypes) : that.dropoffTypes != null) return false;
+        if (pickupTypes != null ? !pickupTypes.equals(that.pickupTypes) : that.pickupTypes != null) return false;
+        if (routeId != null ? !routeId.equals(that.routeId) : that.routeId != null) return false;
+        if (stops != null ? !stops.equals(that.stops) : that.stops != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = routeId != null ? routeId.hashCode() : 0;
+        result = 31 * result + (stops != null ? stops.hashCode() : 0);
+        result = 31 * result + (pickupTypes != null ? pickupTypes.hashCode() : 0);
+        result = 31 * result + (dropoffTypes != null ? dropoffTypes.hashCode() : 0);
+        return result;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java
new file mode 100644
index 0000000000..ef2da04e0e
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a date field from a GTFS feed. */
+public class DateParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public DateParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse date (format should be YYYYMMDD).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java
new file mode 100644
index 0000000000..4d79e1a542
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Indicates that a GTFS entity was not added to a table because another object already exists with the same primary key. */
+public class DuplicateKeyError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public DuplicateKeyError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Duplicate primary key.";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java
new file mode 100644
index 0000000000..24f56b9e06
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a field marked as required is not present in a GTFS feed on a particular line. */
+public class EmptyFieldError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public EmptyFieldError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "No value supplied for a required column.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java
new file mode 100644
index 0000000000..cc6fe4123a
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/**
+ * Represents an error encountered
+ */
+public abstract class GTFSError implements Comparable<GTFSError>, Serializable {
+
+    public final String file; // TODO GTFSTable enum? Or simply use class objects.
+    public final long   line;
+    public final String field;
+    public final String affectedEntityId;
+    public final String errorType;
+
+    public GTFSError(String file, long line, String field) {
+        this(file, line, field, null);
+    }
+
+    public GTFSError(String file, long line, String field, String affectedEntityId) {
+        this.file  = file;
+        this.line  = line;
+        this.field = field;
+        this.affectedEntityId = affectedEntityId;
+        this.errorType = this.getClass().getSimpleName();
+    }
+
+    public String getMessage() {
+        return "no message";
+    }
+
+    public String getMessageWithContext() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(file);
+        sb.append(' ');
+        if (line >= 0) {
+            sb.append("line ");
+            sb.append(line);
+        } else {
+            sb.append("(no line)");
+        }
+        if (field != null) {
+            sb.append(", field '");
+            sb.append(field);
+            sb.append('\'');
+        }
+        sb.append(": ");
+        sb.append(getMessage());
+        return sb.toString();
+    }
+
+    /** must be comparable to put into mapdb */
+    public int compareTo (GTFSError o) {
+        if (this.file == null && o.file != null) return -1;
+        else if (this.file != null && o.file == null) return 1;
+
+        int file = this.file == null && o.file == null ? 0 : String.CASE_INSENSITIVE_ORDER.compare(this.file, o.file);
+        if (file != 0) return file;
+        int errorType = String.CASE_INSENSITIVE_ORDER.compare(this.errorType, o.errorType);
+        if (errorType != 0) return errorType;
+        int affectedEntityId = this.affectedEntityId == null && o.affectedEntityId == null ? 0 : String.CASE_INSENSITIVE_ORDER.compare(this.affectedEntityId, o.affectedEntityId);
+        if (affectedEntityId != 0) return affectedEntityId;
+        else return Long.compare(this.line, o.line);
+    }
+
+    @Override
+    public String toString() {
+        return "GTFSError: " + getMessageWithContext();
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java
new file mode 100644
index 0000000000..9ba99c09ed
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents any GTFS loading problem that does not have its own class, with a free-text message. */
+public class GeneralError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    private String message;
+
+    public GeneralError(String file, long line, String field, String message) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return message;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java
new file mode 100644
index 0000000000..ca580373c2
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a column marked as required is entirely missing from a GTFS feed. */
+public class MissingColumnError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public MissingColumnError(String file, String field) {
+        super(file, 1, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Missing required column.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java
new file mode 100644
index 0000000000..851ffb13f8
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a table marked as required is not present in a GTFS feed. */
+public class MissingTableError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public MissingTableError(String file) {
+        super(file, 0, null);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "This table is required by the GTFS specification but is missing.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java
new file mode 100644
index 0000000000..d6d4e88e02
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Represents a problem parsing an integer field of GTFS feed. */
+public class NumberParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public NumberParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Error parsing a number from a string.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java
new file mode 100644
index 0000000000..9fdf2f49c6
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+public enum Priority {
+    /** 
+     * Something that is likely to break routing results,
+     * e.g. stop times out of sequence or high-speed travel
+     */
+    HIGH,
+    
+    /** 
+     * Something that is likely to break display, but still give accurate routing results,
+     * e.g. broken shapes or route long name containing route short name.
+     */
+    MEDIUM,
+    
+    /**
+     * Something that will not affect user experience but should be corrected as time permits,
+     * e.g. unused stops.
+     */
+    LOW,
+    
+    /**
+     * An error for which we do not have a priority
+     */
+    UNKNOWN
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java
new file mode 100644
index 0000000000..fcc99c9087
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a number is out of the acceptable range. */
+public class RangeError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    final double min, max, actual;
+
+    public RangeError(String file, long line, String field, double min, double max, double actual) {
+        super(file, line, field);
+        this.min = min;
+        this.max = max;
+        this.actual = actual;
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Number %s outside of acceptable range [%s,%s].", actual, min, max);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java
new file mode 100644
index 0000000000..85c22decb1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that an entity referenced another entity that does not exist. */
+public class ReferentialIntegrityError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    // TODO: maybe also store the entity ID of the entity which contained the bad reference, in addition to the row number
+    public final String badReference;
+
+    public ReferentialIntegrityError(String tableName, long row, String field, String badReference) {
+        super(tableName, row, field);
+        this.badReference = badReference;
+    }
+
+    /** must be comparable to put into mapdb */
+    @Override
+    public int compareTo (GTFSError o) {
+        int compare = super.compareTo(o);
+        if (compare != 0) return compare;
+        return this.badReference.compareTo((((ReferentialIntegrityError) o).badReference));
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), badReference);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java
new file mode 100644
index 0000000000..b225dbe7d9
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * Created by landon on 10/14/16.
+ */
+public class TableInSubdirectoryError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public final String directory;
+    public final Priority priority = Priority.HIGH;
+
+    public TableInSubdirectoryError(String file, String directory) {
+        super(file, 0, null);
+        this.directory = directory;
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "All GTFS files (including %s.txt) should be at root of zipfile, not nested in subdirectory (%s)", file, directory);
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java
new file mode 100644
index 0000000000..3c0d007a92
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a time of day field of GTFS feed. */
+public class TimeParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public TimeParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse time (format should be HH:MM:SS).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java
new file mode 100644
index 0000000000..d5b4df0da5
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a URL field from a GTFS feed. */
+public class URLParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public URLParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse URL (format should be <scheme>://<authority><path>?<query>#<fragment>).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java
new file mode 100644
index 0000000000..926cf3a643
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Agency extends Entity {
+
+    private static final long serialVersionUID = -2825890165823575940L;
+    public String agency_id;
+    public String agency_name;
+    public URL    agency_url;
+    public String agency_timezone;
+    public String agency_lang;
+    public String agency_phone;
+    public URL    agency_fare_url;
+    public URL    agency_branding_url;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Agency> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "agency");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Agency a = new Agency();
+            a.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            a.agency_id    = getStringField("agency_id", false); // can only be absent if there is a single agency -- requires a special validator.
+            a.agency_name  = getStringField("agency_name", true);
+            a.agency_url   = getUrlField("agency_url", true);
+            a.agency_lang  = getStringField("agency_lang", false);
+            a.agency_phone = getStringField("agency_phone", false);
+            a.agency_timezone = getStringField("agency_timezone", true);
+            a.agency_fare_url = getUrlField("agency_fare_url", false);
+            a.agency_branding_url = getUrlField("agency_branding_url", false);
+            a.feed = feed;
+            a.feed_id = feed.feedId;
+
+            // TODO clooge due to not being able to have null keys in mapdb
+            if (a.agency_id == null) a.agency_id = "NONE";
+
+            feed.agency.put(a.agency_id, a);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Agency> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "agency");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"agency_id", "agency_name", "agency_url", "agency_lang",
+                    "agency_phone", "agency_timezone", "agency_fare_url", "agency_branding_url"});
+        }
+
+        @Override
+        public void writeOneRow(Agency a) throws IOException {
+            writeStringField(a.agency_id);
+            writeStringField(a.agency_name);
+            writeUrlField(a.agency_url);
+            writeStringField(a.agency_lang);
+            writeStringField(a.agency_phone);
+            writeStringField(a.agency_timezone);
+            writeUrlField(a.agency_fare_url);
+            writeUrlField(a.agency_branding_url);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Agency> iterator() {
+            return this.feed.agency.values().iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java
new file mode 100644
index 0000000000..595a1c3d81
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterators;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Iterator;
+import java.util.Map;
+
+public class Calendar extends Entity implements Serializable {
+
+    private static final long serialVersionUID = 6634236680822635875L;
+    public int monday;
+    public int tuesday;
+    public int wednesday;
+    public int thursday;
+    public int friday;
+    public int saturday;
+    public int sunday;
+    public int start_date;
+    public int end_date;
+    public String feed_id;
+    public String service_id;
+
+    public static class Loader extends Entity.Loader<Calendar> {
+
+        private final Map<String, Service> services;
+
+        /**
+         * Create a loader. The map parameter should be an in-memory map that will be modified. We can't write directly
+         * to MapDB because we modify services as we load calendar dates, and this creates concurrentmodificationexceptions.
+         */
+        public Loader(GTFSFeed feed, Map<String, Service> services) {
+            super(feed, "calendar");
+            this.services = services;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String service_id = getStringField("service_id", true); // TODO service_id can reference either calendar or calendar_dates.
+            Service service = services.computeIfAbsent(service_id, Service::new);
+            if (service.calendar != null) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "service_id"));
+            } else {
+                Calendar c = new Calendar();
+                c.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                c.service_id = service.service_id;
+                c.monday = getIntField("monday", true, 0, 1);
+                c.tuesday = getIntField("tuesday", true, 0, 1);
+                c.wednesday = getIntField("wednesday", true, 0, 1);
+                c.thursday = getIntField("thursday", true, 0, 1);
+                c.friday = getIntField("friday", true, 0, 1);
+                c.saturday = getIntField("saturday", true, 0, 1);
+                c.sunday = getIntField("sunday", true, 0, 1);
+                // TODO check valid dates
+                c.start_date = getIntField("start_date", true, 18500101, 22001231);
+                c.end_date = getIntField("end_date", true, 18500101, 22001231);
+                c.feed = feed;
+                c.feed_id = feed.feedId;
+                service.calendar = c;
+            }
+
+        }    
+    }
+
+    public static class Writer extends Entity.Writer<Calendar> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "calendar");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"service_id", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "start_date", "end_date"});
+        }
+
+        @Override
+        protected void writeOneRow(Calendar c) throws IOException {
+            writeStringField(c.service_id);
+            writeIntField(c.monday);
+            writeIntField(c.tuesday);
+            writeIntField(c.wednesday);
+            writeIntField(c.thursday);
+            writeIntField(c.friday);
+            writeIntField(c.saturday);
+            writeIntField(c.sunday);
+            writeIntField(c.start_date);
+            writeIntField(c.end_date);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Calendar> iterator() {
+            // wrap an iterator over services
+            Iterator<Calendar> calIt = Iterators.transform(feed.services.values().iterator(), new Function<Service, Calendar> () {
+                @Override
+                public Calendar apply (Service s) {
+                    return s.calendar;
+                }
+            });
+            
+            // not every service has a calendar (e.g. TriMet has no calendars, just calendar dates).
+            // This is legal GTFS, so skip services with no calendar
+            return Iterators.filter(calIt, new Predicate<Calendar> () {
+                @Override
+                public boolean apply(Calendar c) {
+                    return c != null;
+                }
+            });
+            
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java
new file mode 100644
index 0000000000..af6acfcd82
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+import com.google.common.base.Function;
+import com.google.common.collect.Iterators;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.time.LocalDate;
+import java.util.Iterator;
+import java.util.Map;
+
+public class CalendarDate extends Entity implements Cloneable, Serializable {
+
+    private static final long serialVersionUID = 6936614582249119431L;
+    public String    service_id;
+    public LocalDate date;
+    public int       exception_type;
+
+    public CalendarDate clone () {
+        try {
+            return (CalendarDate) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static class Loader extends Entity.Loader<CalendarDate> {
+
+        private final Map<String, Service> services;
+
+        /**
+         * Create a loader. The map parameter should be an in-memory map that will be modified. We can't write directly
+         * to MapDB because we modify services as we load calendar dates, and this creates concurrentmodificationexceptions.
+         */
+        public Loader(GTFSFeed feed, Map<String, Service> services) {
+            super(feed, "calendar_dates");
+            this.services = services;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String service_id = getStringField("service_id", true);
+            Service service = services.computeIfAbsent(service_id, Service::new);
+            LocalDate date = getDateField("date", true);
+            if (service.calendar_dates.containsKey(date)) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "(service_id, date)"));
+            } else {
+                CalendarDate cd = new CalendarDate();
+                cd.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                cd.service_id = service_id;
+                cd.date = date;
+                cd.exception_type = getIntField("exception_type", true, 1, 2);
+                cd.feed = feed;
+                service.calendar_dates.put(date, cd);
+            }
+        }
+    }
+
+    public static class Writer extends Entity.Writer<CalendarDate> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "calendar_dates");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"service_id", "date", "exception_type"});
+        }
+
+        @Override
+        protected void writeOneRow(CalendarDate d) throws IOException {
+            writeStringField(d.service_id);
+            writeDateField(d.date);
+            writeIntField(d.exception_type);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<CalendarDate> iterator() {
+            Iterator<Service> serviceIterator = feed.services.values().iterator();
+            return Iterators.concat(Iterators.transform(serviceIterator, new Function<Service, Iterator<CalendarDate>> () {
+                @Override
+                public Iterator<CalendarDate> apply(Service service) {
+                    return service.calendar_dates.values().iterator();
+                }
+            }));
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java
new file mode 100644
index 0000000000..91552eb164
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java
@@ -0,0 +1,448 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.*;
+import com.csvreader.CsvReader;
+import com.csvreader.CsvWriter;
+import org.apache.commons.io.input.BOMInputStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * An abstract base class that represents a row in a GTFS table, e.g. a Stop, Trip, or Agency.
+ * One concrete subclass is defined for each table in a GTFS feed.
+ */
+// TODO K is the key type for this table
+public abstract class Entity implements Serializable {
+
+    private static final long serialVersionUID = -3576441868127607448L;
+    public static final int INT_MISSING = Integer.MIN_VALUE;
+    public long sourceFileLine;
+
+    /* The feed from which this entity was loaded. */
+    transient GTFSFeed feed;
+
+    /* A class that can produce Entities from CSV, and record errors that occur in the process. */
+    // This is almost a GTFSTable... rename?
+    public static abstract class Loader<E extends Entity> {
+
+        private static final Logger LOG = LoggerFactory.getLogger(Loader.class);
+
+        protected final GTFSFeed feed;    // the feed into which we are loading the entities
+        protected final String tableName; // name of corresponding table without .txt
+        protected final Set<String> missingRequiredColumns = new HashSet<>();
+
+        protected CsvReader reader;
+        protected long      row;
+        // TODO "String column" that is set before any calls to avoid passing around the column name
+
+        public Loader(GTFSFeed feed, String tableName) {
+            this.feed = feed;
+            this.tableName = tableName;
+        }
+
+        /** @return whether the number actual is in the range [min, max] */
+        protected boolean checkRangeInclusive(double min, double max, double actual) {
+            if (actual < min || actual > max) {
+                feed.errors.add(new RangeError(tableName, row, null, min, max, actual)); // TODO set column name in loader so it's available in methods
+                return false;
+            }
+            return true;
+        }
+
+        /**
+         * Fetch the value from the given column of the current row. Record an error the first time a column is
+         * seen to be missing, and whenever empty values are encountered.
+         * I was originally just calling getStringField from the other getXField functions as a first step to get
+         * the missing-field check. But we don't want deduplication performed on strings that aren't being retained.
+         * Therefore the missing-field behavior is this separate function.
+         * @return null if column was missing or field is empty
+         */
+        private String getFieldCheckRequired(String column, boolean required) throws IOException {
+            String str = reader.get(column);
+            if (str == null) {
+                if (!missingRequiredColumns.contains(column)) {
+                    feed.errors.add(new MissingColumnError(tableName, column));
+                    missingRequiredColumns.add(column);
+                }
+            } else if (str.isEmpty()) {
+                if (required) {
+                    feed.errors.add(new EmptyFieldError(tableName, row, column));
+                }
+                str = null;
+            }
+            return str;
+        }
+
+        /** @return the given column from the current row as a deduplicated String. */
+        protected String getStringField(String column, boolean required) throws IOException {
+            return getFieldCheckRequired(column, required);
+        }
+
+        protected int getIntField(String column, boolean required, int min, int max) throws IOException {
+            return getIntField(column, required, min, max, 0);
+        }
+
+        protected int getIntField(String column, boolean required, int min, int max, int defaultValue) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            int val = INT_MISSING;
+            if (str == null) {
+                val = defaultValue; // defaults to 0 per overloaded function, unless provided.
+            } else try {
+                val = Integer.parseInt(str);
+                checkRangeInclusive(min, max, val);
+            } catch (NumberFormatException nfe) {
+                feed.errors.add(new NumberParseError(tableName, row, column));
+            }
+            return val;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a time in the format HH:MM:SS.
+         * @return the time value in seconds since midnight
+         */
+        protected int getTimeField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            int val = INT_MISSING;
+            
+            if (str != null) {
+                String[] fields = str.split(":");
+                if (fields.length != 3) {
+                    feed.errors.add(new TimeParseError(tableName, row, column));
+                } else {
+                    try {
+                        int hours = Integer.parseInt(fields[0]);
+                        int minutes = Integer.parseInt(fields[1]);
+                        int seconds = Integer.parseInt(fields[2]);
+                        checkRangeInclusive(0, 72, hours); // GTFS hours can go past midnight. Some trains run for 3 days.
+                        checkRangeInclusive(0, 59, minutes);
+                        checkRangeInclusive(0, 59, seconds);
+                        val = (hours * 60 * 60) + minutes * 60 + seconds;
+                    } catch (NumberFormatException nfe) {
+                        feed.errors.add(new TimeParseError(tableName, row, column));
+                    }
+                }
+            }
+            
+            return val;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a date in the format YYYYMMDD.
+         * @return the date value as Java LocalDate, or null if it could not be parsed.
+         */
+        protected LocalDate getDateField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            LocalDate dateTime = null;
+            if (str != null) try {
+                dateTime = LocalDate.parse(str, DateTimeFormatter.BASIC_ISO_DATE);
+                checkRangeInclusive(2000, 2100, dateTime.getYear());
+            } catch (IllegalArgumentException iae) {
+                feed.errors.add(new DateParseError(tableName, row, column));
+            }
+            return dateTime;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a URL.
+         * @return the URL, or null if the field was missing or empty.
+         */
+        protected URL getUrlField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            URL url = null;
+            if (str != null) try {
+                url = new URL(str);
+            } catch (MalformedURLException mue) {
+                feed.errors.add(new URLParseError(tableName, row, column));
+            }
+            return url;
+        }
+
+        protected double getDoubleField(String column, boolean required, double min, double max) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            double val = Double.NaN;
+            if (str != null) try {
+                val = Double.parseDouble(str);
+                checkRangeInclusive(min, max, val);
+            } catch (NumberFormatException nfe) {
+                feed.errors.add(new NumberParseError(tableName, row, column));
+            }
+            return val;
+        }
+
+        /**
+         * Used to check referential integrity.
+         * Return value is not used, but could allow entities to point to each other directly rather than
+         * using indirection through string-keyed maps.
+         */
+        protected <K, V> V getRefField(String column, boolean required, Map<K, V> target) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            V val = null;
+            if (str != null) {
+                val = target.get(str);
+            }
+            return val;
+        }
+
+        protected abstract boolean isRequired();
+
+        /** Implemented by subclasses to read one row, produce one GTFS entity, and store that entity in a map. */
+        protected abstract void loadOneRow() throws IOException;
+
+        /**
+         * The main entry point into an Entity.Loader. Interprets each row of a CSV file within a zip file as a sinle
+         * GTFS entity, and loads them into a table.
+         *
+         * @param zip the zip file from which to read a table
+         */
+        public void loadTable(ZipFile zip) throws IOException {
+            ZipEntry entry = zip.getEntry(tableName + ".txt");
+            if (entry == null) {
+                Enumeration<? extends ZipEntry> entries = zip.entries();
+                // check if table is contained within sub-directory
+                while (entries.hasMoreElements()) {
+                    ZipEntry e = entries.nextElement();
+                    if (e.getName().endsWith(tableName + ".txt")) {
+                        entry = e;
+                        feed.errors.add(new TableInSubdirectoryError(tableName, entry.getName().replace(tableName + ".txt", "")));
+                    }
+                }
+                /* This GTFS table did not exist in the zip. */
+                if (this.isRequired()) {
+                    feed.errors.add(new MissingTableError(tableName));
+                } else {
+                    LOG.info("Table {} was missing but it is not required.", tableName);
+                }
+
+                if (entry == null) return;
+            }
+            LOG.info("Loading GTFS table {} from {}", tableName, entry);
+            InputStream zis = zip.getInputStream(entry);
+            // skip any byte order mark that may be present. Files must be UTF-8,
+            // but the GTFS spec says that "files that include the UTF byte order mark are acceptable"
+            InputStream bis = new BOMInputStream(zis);
+            CsvReader reader = new CsvReader(bis, ',', Charset.forName("UTF8"));
+            this.reader = reader;
+            reader.readHeaders();
+            while (reader.readRecord()) {
+                // reader.getCurrentRecord() is zero-based and does not include the header line, keep our own row count
+                if (++row % 500000 == 0) {
+                    LOG.info("Record number {}", human(row));
+                }
+                loadOneRow(); // Call subclass method to produce an entity from the current row.
+            }
+        }
+
+    }
+
+    /**
+     * An output stream that cannot be closed. CSVWriters try to close their output streams when they are garbage-collected,
+     * which breaks if another CSV writer is still writing to the ZIP file.
+     *
+     * Apache Commons has something similar but it seemed silly to import another large dependency. Eventually Guava will have this,
+     * see Guava issue 1367. At that point we should switch to using Guava.
+     */
+    private static class UncloseableOutputStream extends FilterOutputStream {
+        public UncloseableOutputStream(OutputStream out) {
+            super(out);
+        }
+
+        @Override
+        public void close () {
+            // no-op
+            return;
+        }
+    }
+
+    /**
+     * Write this entity to a CSV file. This should be subclassed in subclasses of Entity.
+     * The following (abstract) methods should be overridden in a subclass:
+     * 
+     * writeHeaders(): write the headers to the CsvWriter writer.
+     * writeRow(E): write the passed-in object to the CsvWriter writer, potentially using the write*Field methods.
+     * iterator(): return an iterator over objects of this class (note that the feed is available at this.feed
+     * public Writer (GTFSFeed feed): this should super to Writer(GTFSFeed feed, String tableName), with the table name
+     * defined. 
+     * 
+     * @author mattwigway
+     */
+    public static abstract class Writer<E extends Entity> {
+        private static final Logger LOG = LoggerFactory.getLogger(Writer.class);
+
+        protected final GTFSFeed feed;    // the feed into which we are loading the entities
+        protected final String tableName; // name of corresponding table without .txt
+
+        protected CsvWriter writer;
+
+        /**
+         * one-based to match reader.
+         */
+        protected long row;
+
+        protected Writer(GTFSFeed feed, String tableName) {
+            this.feed = feed;
+            this.tableName = tableName;
+        }
+
+        /**
+         * Write the CSV header.
+         */
+        protected abstract void writeHeaders() throws IOException;
+
+        /**
+         * Write one row of the CSV from the passed-in object.
+         */
+        protected abstract void writeOneRow(E obj) throws IOException;
+
+        /**
+         * Get an iterator over objects of this type.
+         */
+        protected abstract Iterator<E> iterator();
+
+        public void writeTable (ZipOutputStream zip) throws IOException {
+            LOG.info("Writing GTFS table {}", tableName);
+
+            ZipEntry zipEntry = new ZipEntry(tableName + ".txt");
+            zip.putNextEntry(zipEntry);
+
+            // don't let CSVWriter close the stream when it is garbage-collected
+            OutputStream protectedOut = new UncloseableOutputStream(zip);
+            this.writer = new CsvWriter(protectedOut, ',', Charset.forName("UTF8"));
+
+            this.writeHeaders();
+
+            // write rows until there are none left.
+            row = 0;        	
+            Iterator<E> iter = this.iterator();
+            while (iter.hasNext()) {
+                if (++row % 500000 == 0) {
+                    LOG.info("Record number {}", human(row));
+                }
+
+                writeOneRow(iter.next());
+            }
+
+            // closing the writer closes the underlying output stream, so we don't do that.
+            writer.flush();
+            zip.closeEntry();
+
+            LOG.info("Wrote {} rows", human(row));
+        }
+
+        protected void writeStringField(String str) throws IOException {
+            writer.write(str);
+        }
+
+        protected void writeUrlField(URL obj) throws IOException {
+            writeStringField(obj != null ? obj.toString() : "");
+        }
+
+        /**
+         * Writes date as YYYYMMDD
+         */
+        protected void writeDateField (LocalDate d) throws IOException {
+            writeStringField(d.format(DateTimeFormatter.BASIC_ISO_DATE));
+        }
+
+        /**
+         * Take a time expressed in seconds since noon - 12h (midnight, usually) and write it in HH:MM:SS format.
+         */
+        protected void writeTimeField (int secsSinceMidnight) throws IOException {
+            if (secsSinceMidnight == INT_MISSING) {
+                writeStringField("");
+                return;
+            }
+            
+            writeStringField(convertToGtfsTime(secsSinceMidnight));
+        }
+
+        public static String convertToGtfsTime (int secsSinceMidnight) {
+            int seconds = secsSinceMidnight % 60;
+            secsSinceMidnight -= seconds;
+            // note that the minute and hour values are still expressed in seconds until we write it out, to avoid unnecessary division.
+            int minutes = (secsSinceMidnight % 3600);
+            // secsSinceMidnight now represents hours
+            secsSinceMidnight -= minutes;
+
+            // integer divide is fine as we've subtracted off remainders
+            return String.format(Locale.getDefault(), "%02d:%02d:%02d", secsSinceMidnight / 3600, minutes / 60, seconds);
+        }
+
+        protected void writeIntField (Integer val) throws IOException {
+            if (val.equals(INT_MISSING))
+                writeStringField("");
+            else
+                writeStringField(val.toString());
+        }
+
+        /**
+         * Write a double value, with precision 10^-7. NaN is written as "".
+         */
+        protected void writeDoubleField (double val) throws IOException {
+            // NaN's represent missing values
+            if (Double.isNaN(val))
+                writeStringField("");
+            
+            // control file size: don't use unnecessary precision
+            // This is usually used for coordinates; one ten-millionth of a degree at the equator is 1.1cm,
+            // and smaller elsewhere on earth, plenty precise enough.
+            // On Jupiter, however, it's a different story.
+            // Use the US locale so that . is used as the decimal separator
+            else
+                writeStringField(String.format(Locale.US, "%.7f", val));
+        }
+
+        /**
+         * End a row.
+         * This is just a proxy to the writer, but could be used for hooks in the future.
+         */
+        public void endRecord () throws IOException {
+            writer.endRecord();
+        }
+    }
+
+
+    // shared code between reading and writing
+    private static final String human (long n) {
+        if (n >= 1000000) return String.format(Locale.getDefault(), "%.1fM", n/1000000.0);
+        if (n >= 1000) return String.format(Locale.getDefault(), "%.1fk", n/1000.0);
+        else return String.format(Locale.getDefault(), "%d", n);
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java
new file mode 100644
index 0000000000..3e76b70bbe
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.google.common.collect.Lists;
+
+import java.io.Serializable;
+import java.util.List;
+
+/**
+ * This table does not exist in GTFS. It is a join of fare_attributes and fare_rules on fare_id.
+ * There should only be one fare_attribute per fare_id, but there can be many fare_rules per fare_id.
+ */
+public class Fare implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public String         fare_id;
+    public FareAttribute  fare_attribute;
+    public List<FareRule> fare_rules = Lists.newArrayList();
+
+    public Fare(String fare_id) {
+        this.fare_id = fare_id;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java
new file mode 100644
index 0000000000..f033101548
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+
+public class FareAttribute extends Entity {
+
+    private static final long serialVersionUID = 2157859372072056891L;
+    public String fare_id;
+    public double price;
+    public String currency_type;
+    public int payment_method;
+    public int transfers;
+    public int transfer_duration;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<FareAttribute> {
+        private final Map<String, Fare> fares;
+
+        public Loader(GTFSFeed feed, Map<String, Fare> fares) {
+            super(feed, "fare_attributes");
+            this.fares = fares;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String fareId = getStringField("fare_id", true);
+            Fare fare = fares.computeIfAbsent(fareId, Fare::new);
+            if (fare.fare_attribute != null) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "fare_id"));
+            } else {
+                FareAttribute fa = new FareAttribute();
+                fa.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                fa.fare_id = fareId;
+                fa.price = getDoubleField("price", true, 0, Integer.MAX_VALUE);
+                fa.currency_type = getStringField("currency_type", true);
+                fa.payment_method = getIntField("payment_method", true, 0, 1);
+                fa.transfers = getIntField("transfers", false, 0, 10); // TODO missing means "unlimited" in this case (rather than 0), supply default value or just use the NULL to mean unlimited
+                fa.transfer_duration = getIntField("transfer_duration", false, 0, 24 * 60 * 60);
+                fa.feed = feed;
+                fa.feed_id = feed.feedId;
+                fare.fare_attribute = fa;
+            }
+
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<FareAttribute> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "fare_attributes");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"fare_id", "price", "currency_type", "payment_method",
+                    "transfers", "transfer_duration"});
+        }
+
+        @Override
+        public void writeOneRow(FareAttribute fa) throws IOException {
+            writeStringField(fa.fare_id);
+            writeDoubleField(fa.price);
+            writeStringField(fa.currency_type);
+            writeIntField(fa.payment_method);
+            writeIntField(fa.transfers);
+            writeIntField(fa.transfer_duration);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FareAttribute> iterator() {
+            return feed.fares.values().stream()
+                    .map(f -> f.fare_attribute)
+                    .iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java
new file mode 100644
index 0000000000..616fe295ec
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.ReferentialIntegrityError;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+
+public class FareRule extends Entity {
+
+    private static final long serialVersionUID = 3209660216692732272L;
+    public String fare_id;
+    public String route_id;
+    public String origin_id;
+    public String destination_id;
+    public String contains_id;
+
+    public static class Loader extends Entity.Loader<FareRule> {
+
+        private final Map<String, Fare> fares;
+
+        public Loader(GTFSFeed feed, Map<String, Fare> fares) {
+            super(feed, "fare_rules");
+            this.fares = fares;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String fareId = getStringField("fare_id", true);
+
+            /* Referential integrity check for fare id */
+            if (!fares.containsKey(fareId)) {
+                this.feed.errors.add(new ReferentialIntegrityError(tableName, row, "fare_id", fareId));
+            }
+
+            Fare fare = fares.computeIfAbsent(fareId, Fare::new);
+            FareRule fr = new FareRule();
+            fr.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            fr.fare_id = fare.fare_id;
+            fr.route_id = getStringField("route_id", false);
+            fr.origin_id = getStringField("origin_id", false);
+            fr.destination_id = getStringField("destination_id", false);
+            fr.contains_id = getStringField("contains_id", false);
+            fr.feed = feed;
+            fare.fare_rules.add(fr);
+
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<FareRule> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "fare_rules");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"fare_id", "route_id", "origin_id", "destination_id",
+                    "contains_id"});
+        }
+
+        @Override
+        public void writeOneRow(FareRule fr) throws IOException {
+            writeStringField(fr.fare_id);
+            writeStringField(fr.route_id);
+            writeStringField(fr.origin_id);
+            writeStringField(fr.destination_id);
+            writeStringField(fr.contains_id);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FareRule> iterator() {
+            return feed.fares.values().stream()
+                    .map(f -> f.fare_rules)
+                    .flatMap(fr -> fr.stream())
+                    .iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java
new file mode 100644
index 0000000000..18632e5054
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.GeneralError;
+
+import java.io.IOException;
+import java.net.URL;
+import java.time.LocalDate;
+import java.util.Iterator;
+
+public class FeedInfo extends Entity implements Cloneable {
+
+    private static final long serialVersionUID = 8718856987299076452L;
+    public String    feed_id = "NONE";
+    public String    feed_publisher_name;
+    public URL       feed_publisher_url;
+    public String    feed_lang;
+    public LocalDate feed_start_date;
+    public LocalDate feed_end_date;
+    public String    feed_version;
+
+    public FeedInfo clone () {
+        try {
+            return (FeedInfo) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static class Loader extends Entity.Loader<FeedInfo> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "feed_info");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            FeedInfo fi = new FeedInfo();
+            fi.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            fi.feed_id = getStringField("feed_id", false);
+            fi.feed_publisher_name = getStringField("feed_publisher_name", true);
+            fi.feed_publisher_url = getUrlField("feed_publisher_url", true);
+            fi.feed_lang = getStringField("feed_lang", true);
+            fi.feed_start_date = getDateField("feed_start_date", false);
+            fi.feed_end_date = getDateField("feed_end_date", false);
+            fi.feed_version = getStringField("feed_version", false);
+            fi.feed = feed;
+            if (feed.feedInfo.isEmpty()) {
+                feed.feedInfo.put("NONE", fi);
+                feed.feedId = fi.feed_id;
+            } else {
+                feed.errors.add(new GeneralError(tableName, row, null, "FeedInfo contains more than one record."));
+            }
+        }
+    }
+
+    public static class Writer extends Entity.Writer<FeedInfo> {
+
+        public Writer(GTFSFeed feed) {
+            super(feed, "feed_info");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"feed_id", "feed_publisher_name", "feed_publisher_url", "feed_lang",
+                    "feed_start_date", "feed_end_date", "feed_version"});
+        }
+
+        @Override
+        public void writeOneRow(FeedInfo i) throws IOException {
+            writeStringField(i.feed_id != null && i.feed_id.equals("NONE") ? "" : i.feed_id);
+            writeStringField(i.feed_publisher_name);
+            writeUrlField(i.feed_publisher_url);
+            writeStringField(i.feed_lang);
+
+            if (i.feed_start_date != null) writeDateField(i.feed_start_date);
+            else writeStringField("");
+
+            if (i.feed_end_date != null) writeDateField(i.feed_end_date);
+            else writeStringField("");
+
+            writeStringField(i.feed_version);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FeedInfo> iterator() {
+            return feed.feedInfo.values().iterator();
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java
new file mode 100644
index 0000000000..8d7bfd14c1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Locale;
+
+import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
+
+public class Frequency extends Entity implements Comparable<Frequency> {
+    /**
+     * Frequency entries have no ID in GTFS so we define one based on the fields in the frequency entry.
+     *
+     * It is possible to have two identical frequency entries in the GTFS, which under our understanding of the situation
+     * would mean that two sets of vehicles were randomly running the same trip at the same headway, but uncorrelated
+     * with each other, which is almost certain to be an error.
+     */
+     public String getId() {
+        StringBuilder sb = new StringBuilder();
+         sb.append(trip_id);
+         sb.append('_');
+         sb.append(convertToGtfsTime(start_time));
+         sb.append("_to_");
+         sb.append(convertToGtfsTime(end_time));
+         sb.append("_every_");
+         sb.append(String.format(Locale.getDefault(), "%dm%02ds", headway_secs / 60, headway_secs % 60));
+         if (exact_times == 1) sb.append("_exact");
+         return sb.toString();
+     }
+
+    private static final long serialVersionUID = -7182161664471704133L;
+    public String trip_id;
+    public int start_time;
+    public int end_time;
+    public int headway_secs;
+    public int exact_times;
+
+    /** must have a comparator since they go in a navigable set that is serialized */
+    @Override
+    public int compareTo(Frequency o) {
+        return this.start_time - o.start_time;
+    }
+
+    public static class Loader extends Entity.Loader<Frequency> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "frequencies");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Frequency f = new Frequency();
+            Trip trip = getRefField("trip_id", true, feed.trips);
+            f.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            f.trip_id = trip.trip_id;
+            f.start_time = getTimeField("start_time", true);
+            f.end_time = getTimeField("end_time", true);
+            f.headway_secs = getIntField("headway_secs", true, 1, 24 * 60 * 60);
+            f.exact_times = getIntField("exact_times", false, 0, 1);
+            f.feed = feed;
+            feed.frequencies.add(Fun.t2(f.trip_id, f));
+        }
+    }
+
+    public static class Writer extends Entity.Writer<Frequency> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "frequencies");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"trip_id", "start_time", "end_time", "headway_secs", "exact_times"});
+        }
+
+        @Override
+        public void writeOneRow(Frequency f) throws IOException {
+            writeStringField(f.trip_id);
+            writeTimeField(f.start_time);
+            writeTimeField(f.end_time);
+            writeIntField(f.headway_secs);
+            writeIntField(f.exact_times);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Frequency> iterator() {
+            return feed.frequencies.stream()
+                    .map(t2 -> t2.b)
+                    .iterator();
+        }
+
+
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java
new file mode 100644
index 0000000000..0ad6505cc2
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Route extends Entity { // implements Entity.Factory<Route>
+
+    private static final long serialVersionUID = -819444896818029068L;
+
+    public static final int TRAM = 0;
+    public static final int SUBWAY = 1;
+    public static final int RAIL = 2;
+    public static final int BUS = 3;
+    public static final int FERRY = 4;
+    public static final int CABLE_CAR = 4;
+    public static final int GONDOLA = 4;
+    public static final int FUNICULAR = 5;
+
+    public String route_id;
+    public String agency_id;
+    public String route_short_name;
+    public String route_long_name;
+    public String route_desc;
+    public int    route_type;
+    public URL    route_url;
+    public String route_color;
+    public String route_text_color;
+    public URL route_branding_url;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Route> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "routes");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Route r = new Route();
+            r.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            r.route_id = getStringField("route_id", true);
+            Agency agency = getRefField("agency_id", false, feed.agency);
+
+            // if there is only one agency, associate with it automatically
+            // TODO: what will this do if the agency and the route have agency_ids but they do not match?
+            if (agency == null && feed.agency.size() == 1)
+                agency = feed.agency.values().iterator().next();
+
+            r.agency_id = agency.agency_id;
+
+            r.route_short_name = getStringField("route_short_name", false); // one or the other required, needs a special validator
+            r.route_long_name = getStringField("route_long_name", false);
+            r.route_desc = getStringField("route_desc", false);
+            r.route_type = getIntField("route_type", true, 0, 7);
+            r.route_url = getUrlField("route_url", false);
+            r.route_color = getStringField("route_color", false);
+            r.route_text_color = getStringField("route_text_color", false);
+            r.route_branding_url = getUrlField("route_branding_url", false);
+            r.feed = feed;
+            r.feed_id = feed.feedId;
+            feed.routes.put(r.route_id, r);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Route> {    	
+        public Writer (GTFSFeed feed) {
+            super(feed, "routes");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writeStringField("agency_id");
+            writeStringField("route_id");
+            writeStringField("route_short_name");
+            writeStringField("route_long_name");
+            writeStringField("route_desc");
+            writeStringField("route_type");
+            writeStringField("route_url");
+            writeStringField("route_color");
+            writeStringField("route_text_color");
+            writeStringField("route_branding_url");
+            endRecord();
+        }
+
+        @Override
+        public void writeOneRow(Route r) throws IOException {
+            writeStringField(r.agency_id);
+            writeStringField(r.route_id);
+            writeStringField(r.route_short_name);
+            writeStringField(r.route_long_name);
+            writeStringField(r.route_desc);
+            writeIntField(r.route_type);
+            writeUrlField(r.route_url);
+            writeStringField(r.route_color);
+            writeStringField(r.route_text_color);
+            writeUrlField(r.route_branding_url);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Route> iterator() {
+            return feed.routes.values().iterator();
+        }   	
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java
new file mode 100644
index 0000000000..16039075a1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.google.common.collect.Maps;
+
+import java.io.Serializable;
+import java.time.DayOfWeek;
+import java.time.LocalDate;
+import java.util.EnumSet;
+import java.util.Map;
+
+import static java.time.DayOfWeek.*;
+
+/**
+ * This table does not exist in GTFS. It is a join of calendars and calendar_dates on service_id.
+ * There should only be one Calendar per service_id. There should only be one calendar_date per tuple of
+ * (service_id, date), which means there can be many calendar_dates per service_id.
+ */
+public class Service implements Serializable {
+
+    private static final long serialVersionUID = 7966238549509747091L;
+    public String   service_id;
+    public Calendar calendar;
+    public Map<LocalDate, CalendarDate> calendar_dates = Maps.newHashMap();
+
+    public Service(String service_id) {
+        this.service_id = service_id;
+    }
+
+    /**
+     * @param service_id the service_id to assign to the newly created copy.
+     * @param daysToRemove the days of the week on which to deactivate service in the copy.
+     * @return a copy of this Service with any service on the specified days of the week deactivated.
+     */
+    public Service removeDays(String service_id, EnumSet<DayOfWeek> daysToRemove) {
+        Service service = new Service(service_id);
+        // First, duplicate any Calendar in this Service, minus the specified days of the week.
+        if (this.calendar != null) {
+            Calendar calendar = new Calendar();
+            //  TODO calendar.getDaysOfWeek/setDaysOfWeek which allow simplifying this section and activeOn below.
+            calendar.monday    = daysToRemove.contains(MONDAY)    ? 0 : this.calendar.monday;
+            calendar.tuesday   = daysToRemove.contains(TUESDAY)   ? 0 : this.calendar.tuesday;
+            calendar.wednesday = daysToRemove.contains(WEDNESDAY) ? 0 : this.calendar.wednesday;
+            calendar.thursday  = daysToRemove.contains(THURSDAY)  ? 0 : this.calendar.thursday;
+            calendar.friday    = daysToRemove.contains(FRIDAY)    ? 0 : this.calendar.friday;
+            calendar.saturday  = daysToRemove.contains(SATURDAY)  ? 0 : this.calendar.saturday;
+            calendar.sunday    = daysToRemove.contains(SUNDAY)    ? 0 : this.calendar.sunday;
+            // The new calendar should cover exactly the same time range as the existing one.
+            calendar.start_date = this.calendar.start_date;
+            calendar.end_date   = this.calendar.end_date;
+            // Create the bidirectional reference between Calendar and Service.
+            service.calendar = calendar;
+        }
+        // Copy over all exceptions whose dates fall on days of the week that are retained.
+        this.calendar_dates.forEach((date, exception) -> {
+            DayOfWeek dow = date.getDayOfWeek();
+            if (!daysToRemove.contains(dow)) {
+                CalendarDate newException = exception.clone();
+                service.calendar_dates.put(date, newException);
+            }
+        });
+        return service;
+    }
+
+    /**
+     * @return whether this Service is ever active at all, either from calendar or calendar_dates.
+     */
+    public boolean hasAnyService() {
+
+        // Look for any service defined in calendar (on days of the week).
+        boolean hasAnyService = calendar != null && (
+                calendar.monday == 1 ||
+                calendar.tuesday == 1 ||
+                calendar.wednesday == 1 ||
+                calendar.thursday == 1 ||
+                calendar.friday == 1 ||
+                calendar.saturday == 1 ||
+                calendar.sunday == 1 );
+
+        // Also look for any exceptions of type 1 (added service).
+        hasAnyService |= calendar_dates.values().stream().anyMatch(cd -> cd.exception_type == 1);
+
+        return hasAnyService;
+    }
+
+    /**
+     * Is this service active on the specified date?
+     */
+    public boolean activeOn (LocalDate date) {
+        // first check for exceptions
+        CalendarDate exception = calendar_dates.get(date);
+
+        if (exception != null)
+            return exception.exception_type == 1;
+
+        else if (calendar == null)
+            return false;
+
+        else {
+            int gtfsDate = date.getYear() * 10000 + date.getMonthValue() * 100 + date.getDayOfMonth();
+            boolean withinValidityRange = calendar.end_date >= gtfsDate && calendar.start_date <= gtfsDate;
+
+            if (!withinValidityRange) return false;
+
+            switch (date.getDayOfWeek()) {
+                case MONDAY:
+                    return calendar.monday == 1;
+                case TUESDAY:
+                    return calendar.tuesday == 1;
+                case WEDNESDAY:
+                    return calendar.wednesday == 1;
+                case THURSDAY:
+                    return calendar.thursday == 1;
+                case FRIDAY:
+                    return calendar.friday == 1;
+                case SATURDAY:
+                    return calendar.saturday == 1;
+                case SUNDAY:
+                    return calendar.sunday == 1;
+                default:
+                    throw new IllegalArgumentException("unknown day of week constant!");
+            }
+        }
+    }
+
+    /**
+     * Checks for overlapping days of week between two service calendars
+     * @param s1
+     * @param s2
+     * @return true if both calendars simultaneously operate on at least one day of the week
+     */
+    public static boolean checkOverlap (Service s1, Service s2) {
+        if (s1.calendar == null || s2.calendar == null) {
+            return false;
+        }
+        // overlap exists if at least one day of week is shared by two calendars
+        boolean overlappingDays = s1.calendar.monday == 1 && s2.calendar.monday == 1 ||
+                s1.calendar.tuesday == 1 && s2.calendar.tuesday == 1 ||
+                s1.calendar.wednesday == 1 && s2.calendar.wednesday == 1 ||
+                s1.calendar.thursday == 1 && s2.calendar.thursday == 1 ||
+                s1.calendar.friday == 1 && s2.calendar.friday == 1 ||
+                s1.calendar.saturday == 1 && s2.calendar.saturday == 1 ||
+                s1.calendar.sunday == 1 && s2.calendar.sunday == 1;
+        return overlappingDays;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java
new file mode 100644
index 0000000000..44723c6bce
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+import org.mapdb.Fun;
+
+import java.util.Map;
+
+/**
+ * Represents a collection of GTFS shape points. Never saved in MapDB but constructed on the fly.
+ */
+public class Shape {
+    public static GeometryFactory geometryFactory = new GeometryFactory();
+    /** The shape itself */
+    public LineString geometry;
+
+    /** shape_dist_traveled for each point in the geometry. TODO how to handle shape dist traveled not specified, or not specified on all stops? */
+    public double[] shape_dist_traveled;
+
+    public Shape (GTFSFeed feed, String shape_id) {
+        Map<Fun.Tuple2<String, Integer>, ShapePoint> points =
+                feed.shape_points.subMap(new Fun.Tuple2(shape_id, null), new Fun.Tuple2(shape_id, Fun.HI));
+
+        Coordinate[] coords = points.values().stream()
+                .map(point -> new Coordinate(point.shape_pt_lon, point.shape_pt_lat))
+                .toArray(i -> new Coordinate[i]);
+        geometry = geometryFactory.createLineString(coords);
+        shape_dist_traveled = points.values().stream().mapToDouble(point -> point.shape_dist_traveled).toArray();
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java
new file mode 100644
index 0000000000..2691a2783f
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun.Tuple2;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class ShapePoint extends Entity {
+
+    private static final long serialVersionUID = 6751814959971086070L;
+    public final String shape_id;
+    public final double shape_pt_lat;
+    public final double shape_pt_lon;
+    public final int    shape_pt_sequence;
+    public final double shape_dist_traveled;
+
+    // Similar to stoptime, we have to have a constructor, because fields are final so as to be immutable for storage in MapDB.
+    public ShapePoint(String shape_id, double shape_pt_lat, double shape_pt_lon, int shape_pt_sequence, double shape_dist_traveled) {
+        this.shape_id = shape_id;
+        this.shape_pt_lat = shape_pt_lat;
+        this.shape_pt_lon = shape_pt_lon;
+        this.shape_pt_sequence = shape_pt_sequence;
+        this.shape_dist_traveled = shape_dist_traveled;
+    }
+
+    public static class Loader extends Entity.Loader<ShapePoint> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "shapes");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            String shape_id = getStringField("shape_id", true);
+            double shape_pt_lat = getDoubleField("shape_pt_lat", true, -90D, 90D);
+            double shape_pt_lon = getDoubleField("shape_pt_lon", true, -180D, 180D);
+            int shape_pt_sequence = getIntField("shape_pt_sequence", true, 0, Integer.MAX_VALUE);
+            double shape_dist_traveled = getDoubleField("shape_dist_traveled", false, 0D, Double.MAX_VALUE);
+
+            ShapePoint s = new ShapePoint(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence, shape_dist_traveled);
+            s.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            s.feed = null; // since we're putting this into MapDB, we don't want circular serialization
+            feed.shape_points.put(new Tuple2<String, Integer>(s.shape_id, s.shape_pt_sequence), s);
+        }
+    }
+
+    public static class Writer extends Entity.Writer<ShapePoint> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "shapes");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"shape_id", "shape_pt_lat", "shape_pt_lon", "shape_pt_sequence", "shape_dist_traveled"});
+        }
+
+        @Override
+        protected void writeOneRow(ShapePoint s) throws IOException {
+            writeStringField(s.shape_id);
+            writeDoubleField(s.shape_pt_lat);
+            writeDoubleField(s.shape_pt_lon);
+            writeIntField(s.shape_pt_sequence);
+            writeDoubleField(s.shape_dist_traveled);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<ShapePoint> iterator() {
+            return feed.shape_points.values().iterator();
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java
new file mode 100644
index 0000000000..f35303ee15
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Stop extends Entity {
+
+    private static final long serialVersionUID = 464065335273514677L;
+    public String stop_id;
+    public String stop_code;
+    public String stop_name;
+    public String stop_desc;
+    public double stop_lat;
+    public double stop_lon;
+    public String zone_id;
+    public URL    stop_url;
+    public int    location_type;
+    public String parent_station;
+    public String stop_timezone;
+    // TODO should be int
+    public String wheelchair_boarding;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Stop> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "stops");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Stop s = new Stop();
+            s.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            s.stop_id   = getStringField("stop_id", true);
+            s.stop_code = getStringField("stop_code", false);
+            s.stop_name = getStringField("stop_name", true);
+            s.stop_desc = getStringField("stop_desc", false);
+            s.stop_lat  = getDoubleField("stop_lat", true, -90D, 90D);
+            s.stop_lon  = getDoubleField("stop_lon", true, -180D, 180D);
+            s.zone_id   = getStringField("zone_id", false);
+            s.stop_url  = getUrlField("stop_url", false);
+            s.location_type  = getIntField("location_type", false, 0, 1);
+            s.parent_station = getStringField("parent_station", false);
+            s.stop_timezone  = getStringField("stop_timezone", false);
+            s.wheelchair_boarding = getStringField("wheelchair_boarding", false);
+            s.feed = feed;
+            s.feed_id = feed.feedId;
+            /* TODO check ref integrity later, this table self-references via parent_station */
+
+            feed.stops.put(s.stop_id, s);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Stop> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "stops");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"stop_id", "stop_code", "stop_name", "stop_desc", "stop_lat", "stop_lon", "zone_id",					
+                    "stop_url", "location_type", "parent_station", "stop_timezone", "wheelchair_boarding"});
+        }
+
+        @Override
+        public void writeOneRow(Stop s) throws IOException {
+            writeStringField(s.stop_id);
+            writeStringField(s.stop_code);
+            writeStringField(s.stop_name);
+            writeStringField(s.stop_desc);
+            writeDoubleField(s.stop_lat);
+            writeDoubleField(s.stop_lon);
+            writeStringField(s.zone_id);
+            writeUrlField(s.stop_url);
+            writeIntField(s.location_type);
+            writeStringField(s.parent_station);
+            writeStringField(s.stop_timezone);
+            writeStringField(s.wheelchair_boarding);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Stop> iterator() {
+            return feed.stops.values().iterator();
+        }   	
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java
new file mode 100644
index 0000000000..943a50641e
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Iterator;
+
+/**
+ * Represents a GTFS StopTime. Note that once created and saved in a feed, stop times are by convention immutable
+ * because they are in a MapDB.
+ */
+public class StopTime extends Entity implements Cloneable, Serializable {
+
+    private static final long serialVersionUID = -8883780047901081832L;
+    /* StopTime cannot directly reference Trips or Stops because they would be serialized into the MapDB. */
+    public String trip_id;
+    public int    arrival_time = INT_MISSING;
+    public int    departure_time = INT_MISSING;
+    public String stop_id;
+    public int    stop_sequence;
+    public String stop_headsign;
+    public int    pickup_type;
+    public int    drop_off_type;
+    public double shape_dist_traveled;
+    public int    timepoint = INT_MISSING;
+
+    public static class Loader extends Entity.Loader<StopTime> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "stop_times");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            StopTime st = new StopTime();
+            st.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            st.trip_id        = getStringField("trip_id", true);
+            // TODO: arrival_time and departure time are not required, but if one is present the other should be
+            // also, if this is the first or last stop, they are both required
+            st.arrival_time   = getTimeField("arrival_time", false);
+            st.departure_time = getTimeField("departure_time", false);
+            st.stop_id        = getStringField("stop_id", true);
+            st.stop_sequence  = getIntField("stop_sequence", true, 0, Integer.MAX_VALUE);
+            st.stop_headsign  = getStringField("stop_headsign", false);
+            st.pickup_type    = getIntField("pickup_type", false, 0, 3); // TODO add ranges as parameters
+            st.drop_off_type  = getIntField("drop_off_type", false, 0, 3);
+            st.shape_dist_traveled = getDoubleField("shape_dist_traveled", false, 0D, Double.MAX_VALUE); // FIXME using both 0 and NaN for "missing", define DOUBLE_MISSING
+            st.timepoint      = getIntField("timepoint", false, 0, 1, INT_MISSING);
+            st.feed           = null; // this could circular-serialize the whole feed
+            feed.stop_times.put(new Fun.Tuple2(st.trip_id, st.stop_sequence), st);
+
+            /*
+              Check referential integrity without storing references. StopTime cannot directly reference Trips or
+              Stops because they would be serialized into the MapDB.
+             */
+            getRefField("trip_id", true, feed.trips);
+            getRefField("stop_id", true, feed.stops);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<StopTime> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "stop_times");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"trip_id", "arrival_time", "departure_time", "stop_id", "stop_sequence", "stop_headsign",
+                    "pickup_type", "drop_off_type", "shape_dist_traveled", "timepoint"});
+        }
+
+        @Override
+        protected void writeOneRow(StopTime st) throws IOException {
+            writeStringField(st.trip_id);
+            writeTimeField(st.arrival_time);
+            writeTimeField(st.departure_time);
+            writeStringField(st.stop_id);
+            writeIntField(st.stop_sequence);
+            writeStringField(st.stop_headsign);
+            writeIntField(st.pickup_type);
+            writeIntField(st.drop_off_type);
+            writeDoubleField(st.shape_dist_traveled);
+            writeIntField(st.timepoint);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<StopTime> iterator() {
+            return feed.stop_times.values().iterator();
+        }
+
+
+    }
+
+    @Override
+    public StopTime clone () {
+        try {
+            return (StopTime) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java
new file mode 100644
index 0000000000..4fe43fb881
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class Transfer extends Entity {
+
+    private static final long serialVersionUID = -4944512120812641063L;
+    public String from_stop_id;
+    public String to_stop_id;
+    public int  transfer_type;
+    public int  min_transfer_time;
+    public String from_route_id;
+    public String to_route_id;
+    public String from_trip_id;
+    public String to_trip_id;
+
+    public static class Loader extends Entity.Loader<Transfer> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "transfers");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Transfer tr = new Transfer();
+            tr.sourceFileLine    = row + 1; // offset line number by 1 to account for 0-based row index
+            tr.from_stop_id      = getStringField("from_stop_id", true);
+            tr.to_stop_id        = getStringField("to_stop_id", true);
+            tr.transfer_type     = getIntField("transfer_type", true, 0, 3);
+            tr.min_transfer_time = getIntField("min_transfer_time", false, 0, Integer.MAX_VALUE);
+            tr.from_route_id     = getStringField("from_route_id", false);
+            tr.to_route_id       = getStringField("to_route_id", false);
+            tr.from_trip_id      = getStringField("from_trip_id", false);
+            tr.to_trip_id        = getStringField("to_trip_id", false);
+
+            getRefField("from_stop_id", true, feed.stops);
+            getRefField("to_stop_id", true, feed.stops);
+            getRefField("from_route_id", false, feed.routes);
+            getRefField("to_route_id", false, feed.routes);
+            getRefField("from_trip_id", false, feed.trips);
+            getRefField("to_trip_id", false, feed.trips);
+
+            tr.feed = feed;
+            feed.transfers.put(Long.toString(row), tr);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Transfer> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "transfers");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"from_stop_id", "to_stop_id", "transfer_type", "min_transfer_time"});
+        }
+
+        @Override
+        protected void writeOneRow(Transfer t) throws IOException {
+            writeStringField(t.from_stop_id);
+            writeStringField(t.to_stop_id);
+            writeIntField(t.transfer_type);
+            writeIntField(t.min_transfer_time);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Transfer> iterator() {
+            return feed.transfers.values().iterator();
+        }
+
+
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java
new file mode 100644
index 0000000000..b7c4b06e87
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class Trip extends Entity {
+
+    private static final long serialVersionUID = -4869384750974542712L;
+    public String route_id;
+    public String service_id;
+    public String trip_id;
+    public String trip_headsign;
+    public String trip_short_name;
+    public int    direction_id;
+    public String block_id;
+    public String shape_id;
+    public int    bikes_allowed;
+    public int    wheelchair_accessible;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Trip> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "trips");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Trip t = new Trip();
+
+            t.sourceFileLine  = row + 1; // offset line number by 1 to account for 0-based row index
+            t.route_id        = getStringField("route_id", true);
+            t.service_id      = getStringField("service_id", true);
+            t.trip_id         = getStringField("trip_id", true);
+            t.trip_headsign   = getStringField("trip_headsign", false);
+            t.trip_short_name = getStringField("trip_short_name", false);
+            t.direction_id    = getIntField("direction_id", false, 0, 1);
+            t.block_id        = getStringField("block_id", false); // make a blocks multimap
+            t.shape_id        = getStringField("shape_id", false);
+            t.bikes_allowed   = getIntField("bikes_allowed", false, 0, 2);
+            t.wheelchair_accessible = getIntField("wheelchair_accessible", false, 0, 2);
+            t.feed = feed;
+            t.feed_id = feed.feedId;
+            feed.trips.put(t.trip_id, t);
+
+            /*
+              Check referential integrity without storing references. Trip cannot directly reference Services or
+              Routes because they would be serialized into the MapDB.
+             */
+            // TODO confirm existence of shape ID
+            getRefField("service_id", true, feed.services);
+            getRefField("route_id", true, feed.routes);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Trip> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "trips");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            // TODO: export shapes
+            writer.writeRecord(new String[] {"route_id", "trip_id", "trip_headsign", "trip_short_name", "direction_id", "block_id",
+                    "shape_id", "bikes_allowed", "wheelchair_accessible", "service_id"});
+        }
+
+        @Override
+        protected void writeOneRow(Trip t) throws IOException {
+            writeStringField(t.route_id);
+            writeStringField(t.trip_id);
+            writeStringField(t.trip_headsign);
+            writeStringField(t.trip_short_name);
+            writeIntField(t.direction_id);
+            writeStringField(t.block_id);
+            writeStringField(t.shape_id);
+            writeIntField(t.bikes_allowed);
+            writeIntField(t.wheelchair_accessible);
+            writeStringField(t.service_id);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Trip> iterator() {
+            return feed.trips.values().iterator();
+        }
+
+
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java
new file mode 100644
index 0000000000..54defdb1a3
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.util;
+
+import com.google.common.collect.Maps;
+
+import java.io.Serializable;
+import java.util.Map;
+
+/**
+ * Does the same thing as String.intern, but for several different types.
+ * Java's String.intern uses perm gen space and is broken anyway.
+ */
+public class Deduplicator implements Serializable {
+    private static final long serialVersionUID = 20140524L;
+
+    private final Map<String, String> canonicalStrings = Maps.newHashMap();
+
+    /** Free up any memory used by the deduplicator. */
+    public void reset() {
+        canonicalStrings.clear();
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java
deleted file mode 100644
index 9be65b36ba..0000000000
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.graphhopper.reader.gtfs;
-
-import com.conveyal.gtfs.GTFSFeed;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.EdgeIteratorState;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.triangulate.ConformingDelaunayTriangulator;
-import com.vividsolutions.jts.triangulate.ConstraintVertex;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdge;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
-import com.vividsolutions.jts.triangulate.quadedge.Vertex;
-
-import java.util.*;
-
-class FakeWalkNetworkBuilder {
-
-    static void buildWalkNetwork(Collection<GTFSFeed> feeds, GraphHopperStorage graph, PtFlagEncoder encoder, DistanceCalc distCalc) {
-        Collection<ConstraintVertex> sites = new ArrayList<>();
-        Map<Vertex, Integer> vertex2nodeId = new HashMap<>();
-        feeds.stream().flatMap(feed -> feed.stops.values().stream()).forEach( stop -> {
-            int i = graph.getNodes();
-            graph.getNodeAccess().setNode(i++, stop.stop_lat, stop.stop_lon);
-            ConstraintVertex site = new ConstraintVertex(new Coordinate(stop.stop_lon,stop.stop_lat));
-            sites.add(site);
-            vertex2nodeId.put(site, i-1);
-        });
-        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
-        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
-        conformingDelaunayTriangulator.formInitialDelaunay();
-        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
-        List<QuadEdge> edges = tin.getPrimaryEdges(false);
-        for (QuadEdge edge : edges) {
-            EdgeIteratorState ghEdge = graph.edge(vertex2nodeId.get(edge.orig()), vertex2nodeId.get(edge.dest()));
-            double distance = distCalc.calcDist(
-                    edge.orig().getY(),
-                    edge.orig().getX(),
-                    edge.dest().getY(),
-                    edge.dest().getX());
-            ghEdge.setDistance(distance);
-            ghEdge.setFlags(encoder.setSpeed(ghEdge.getFlags(), 5.0));
-            ghEdge.setFlags(encoder.setAccess(ghEdge.getFlags(), true, true));
-        }
-    }
-
-
-}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index a9cef56421..4da8ccbd00 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -21,6 +21,8 @@
 import com.google.common.collect.ArrayListMultimap;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
@@ -30,34 +32,39 @@
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.temporal.ChronoUnit;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Spliterators;
+import java.util.*;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
-final class GraphExplorer {
+public final class GraphExplorer {
 
     private final EdgeExplorer edgeExplorer;
     private final PtFlagEncoder flagEncoder;
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
-    private final PtTravelTimeWeighting weighting;
     private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
     private final Graph graph;
+    private final Weighting accessEgressWeighting;
     private final boolean walkOnly;
+    private double walkSpeedKmH;
 
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
+    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
         this.graph = graph;
-        this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
+        this.accessEgressWeighting = accessEgressWeighting;
+        DefaultEdgeFilter accessEgressIn = DefaultEdgeFilter.inEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter accessEgressOut = DefaultEdgeFilter.outEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter ptIn = DefaultEdgeFilter.inEdges(flagEncoder);
+        DefaultEdgeFilter ptOut = DefaultEdgeFilter.outEdges(flagEncoder);
+        EdgeFilter in = edgeState -> accessEgressIn.accept(edgeState) || ptIn.accept(edgeState);
+        EdgeFilter out = edgeState -> accessEgressOut.accept(edgeState) || ptOut.accept(edgeState);
+        this.edgeExplorer = graph.createEdgeExplorer(reverse ? in : out);
         this.flagEncoder = flagEncoder;
-        this.weighting = weighting;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
@@ -70,6 +77,7 @@
             extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalTraversalKey(), extraEdge.getEdge(), extraEdge.getAdjNode(), extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3)));
         }
         this.walkOnly = walkOnly;
+        this.walkSpeedKmH = walkSpeedKmh;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
@@ -86,12 +94,33 @@
             @Override
             public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
                 if (edgeIterator.next()) {
+                    GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
+
+                    // Optimization (around 20% in Swiss network):
+                    // Only use the (single) least-wait-time edge to enter the
+                    // time expanded network. Later departures are reached via
+                    // WAIT edges. Algorithmically not necessary, and does not
+                    // reduce total number of relaxed nodes, but takes stress
+                    // off the priority queue.
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                        action.accept(findEnterEdge()); // fully consumes edgeIterator
+                        return true;
+                    }
+
                     action.accept(edgeIterator);
                     return true;
                 }
                 return false;
             }
 
+            private EdgeIteratorState findEnterEdge() {
+                ArrayList<EdgeIteratorState> allEnterEdges = new ArrayList<>();
+                allEnterEdges.add(edgeIterator.detach(false));
+                while (edgeIterator.next()) {
+                    allEnterEdges.add(edgeIterator.detach(false));
+                }
+                return allEnterEdges.stream().min(Comparator.comparingLong(e -> calcTravelTimeMillis(e, label.currentTime))).get();
+            }
 
         }, false);
     }
@@ -100,7 +129,7 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
         switch (edgeType) {
             case HIGHWAY:
-                return weighting.calcMillis(edge, false, -1);
+                return (long) (accessEgressWeighting.calcMillis(edge, reverse, -1) * (5.0 / walkSpeedKmH));
             case ENTER_TIME_EXPANDED_NETWORK:
                 if (reverse) {
                     return 0;
@@ -118,25 +147,26 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         }
     }
 
-    public boolean isBlocked(EdgeIteratorState edge) {
+    boolean isBlocked(EdgeIteratorState edge) {
         return realtimeFeed.isBlocked(edge.getEdge());
     }
 
-    public long getDelayFromBoardEdge(EdgeIteratorState edge, long currentTime) {
+    long getDelayFromBoardEdge(EdgeIteratorState edge, long currentTime) {
         return realtimeFeed.getDelayForBoardEdge(edge, Instant.ofEpochMilli(currentTime));
     }
 
-    public long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
+    long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
         return realtimeFeed.getDelayForAlightEdge(edge, Instant.ofEpochMilli(currentTime));
     }
 
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
-        return flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
-    }
-
-    private int secondsOnTrafficDay(EdgeIteratorState edge, long instant) {
-        final ZoneId zoneId = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(edge.getFlags())).zoneId;
-        return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toSecondOfDay();
+        long l = flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
+        if (!reverse) {
+            if (l < 0) l = l + 24*60*60*1000;
+        } else {
+            if (l > 0) l = l - 24*60*60*1000;
+        }
+        return l;
     }
 
     private long millisOnTravelDay(EdgeIteratorState edge, long instant) {
@@ -156,13 +186,27 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         }
     }
 
+    int calcNTransfers(EdgeIteratorState edge) {
+        return flagEncoder.getTransfers(edge.getFlags());
+    }
+
     EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
         if (edgeId == -1) {
             throw new RuntimeException();
         }
-        return extraEdges.stream()
-                .filter(edge -> edge.getEdge() == edgeId)
-                .findFirst().orElseGet(() -> graph.getEdgeIteratorState(edgeId, adjNode));
+        for (EdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge.getEdge() == edgeId) {
+                if (extraEdge.getAdjNode() != adjNode) {
+                    throw new IllegalStateException();
+                }
+                return extraEdge;
+            }
+        }
+        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
+        if (edge.getAdjNode() != adjNode) {
+            throw new IllegalStateException();
+        }
+        return edge;
     }
 
     NodeAccess getNodeAccess() {
@@ -185,7 +229,14 @@ public Graph getGraph() {
         @Override
         public boolean test(EdgeIteratorState edgeIterator) {
             final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-            if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
+            if (edgeType == GtfsStorage.EdgeType.HIGHWAY) {
+                if (reverse) {
+                    return accessEgressWeighting.getFlagEncoder().isBackward(edgeIterator.getFlags());
+                } else {
+                    return accessEgressWeighting.getFlagEncoder().isForward(edgeIterator.getFlags());
+                }
+            }
+            if (walkOnly && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
                 return false;
             }
             if (!isValidOn(edgeIterator, label.currentTime)) {
@@ -194,15 +245,6 @@ public boolean test(EdgeIteratorState edgeIterator) {
             if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
                 return false;
             }
-            if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
-                    return false;
-                }
-            } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
-                    return false;
-                }
-            }
             return true;
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 85d2d04e8e..2a2c2bf448 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -18,13 +18,19 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.Transfer;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.*;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
@@ -78,6 +84,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
 
     private final TranslationMap translationMap;
     private final PtFlagEncoder flagEncoder;
+    private final Weighting accessEgressWeighting;
     private final GraphHopperStorage graphHopperStorage;
     private final LocationIndex locationIndex;
     private final GtfsStorage gtfsStorage;
@@ -89,28 +96,30 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final int limitSolutions;
         private final Instant initialTime;
         private final boolean profileQuery;
-        private final boolean separateWalkQuery = true;
         private final boolean arriveBy;
         private final boolean ignoreTransfers;
+        private final double betaTransfers;
+        private final double betaWalkTime;
         private final double walkSpeedKmH;
         private final double maxWalkDistancePerLeg;
-        private final double maxTransferDistancePerLeg;
-        private final PtTravelTimeWeighting weighting;
+        private final int blockedRouteTypes;
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
-        private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
         private final Graph graphWithExtraEdges = new WrapperGraph(graphHopperStorage, extraEdges);
         private QueryGraph queryGraph = new QueryGraph(graphWithExtraEdges);
         private GraphExplorer graphExplorer;
+        private int visitedNodes;
 
         RequestHandler(GHRequest request) {
             maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, 1_000_000);
             profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
             ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
+            betaTransfers = request.getHints().getDouble("beta_transfers", 0.0);
+            betaWalkTime = request.getHints().getDouble("beta_walk_time", 1.0);
             limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
             final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
             try {
@@ -120,15 +129,14 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             }
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 1000.0);
-            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
-            weighting = createPtTravelTimeWeighting(flagEncoder, arriveBy, walkSpeedKmH);
+            blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
             }
             enter = request.getPoints().get(0);
             exit = request.getPoints().get(1);
+            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Integer.MAX_VALUE);
         }
 
         GHResponse route() {
@@ -145,11 +153,6 @@ GHResponse route() {
             PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
-            if (separateWalkQuery) {
-                substitutePointWithVirtualNode(0, false, enter, allQueryResults);
-                substitutePointWithVirtualNode(1, true, exit, allQueryResults);
-            }
-
             int startNode;
             int destNode;
             if (arriveBy) {
@@ -159,70 +162,29 @@ GHResponse route() {
                 startNode = allQueryResults.get(0).getClosestNode();
                 destNode = allQueryResults.get(1).getClosestNode();
             }
-            List<Label> solutions = findPaths(startNode, destNode);
+            List<List<Label.Transition>> solutions = findPaths(startNode, destNode);
             parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
             return response;
         }
 
-        private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, extraEdges, true);
-            int nextNodeId = graphWithExtraEdges.getNodes() + 2 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
-            int nextEdgeId = graphWithExtraEdges.getAllEdges().length() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
-
-            final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
-            for (Label stationNode : stationNodes) {
-                final PathWrapper pathWrapper = stationNode.parent.parent != null ?
-                        tripFromLabel.parseSolutionIntoPath(reverse, flagEncoder, translation, graphExplorer, weighting, stationNode.parent, new PointList()) :
-                        new PathWrapper();
-                final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        nextEdgeId++, reverse ? stationNode.adjNode : nextNodeId, reverse ? nextNodeId : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
-                final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        nextEdgeId++, reverse ? nextNodeId : stationNode.adjNode, reverse ? stationNode.adjNode : nextNodeId, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
-                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
-                final long time = pathWrapper.getTime() / 1000;
-                newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setTime(newEdge.getFlags(), time));
-                reverseNewEdge.setFlags(newEdge.getFlags());
-                newEdge.setReverseEdge(reverseNewEdge);
-                reverseNewEdge.setReverseEdge(newEdge);
-                newEdge.setDistance(pathWrapper.getDistance());
-                extraEdges.add(newEdge);
-                extraEdges.add(reverseNewEdge);
-                walkPaths.put(stationNode.adjNode, pathWrapper);
-            }
-
-            final QueryResult virtualNode = new QueryResult(ghPoint.getLat(), ghPoint.getLon());
-            virtualNode.setClosestNode(nextNodeId);
-            allQueryResults.set(index, virtualNode);
-        }
-
-        private List<Label> findStationNodes(GraphExplorer graphExplorer, int node, boolean reverse) {
-            GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, reverse, maxWalkDistancePerLeg, maxTransferDistancePerLeg, false, false, maxVisitedNodesForRequest);
-            final Stream<Label> labels = router.calcLabels(node, -1, initialTime);
-            return labels
-                    .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
-                    .collect(Collectors.toList());
-        }
-
         private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
-            QueryResult source = locationIndex.findClosest(point.lat, point.lon, new EverythingButPt(flagEncoder));
+            final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+            QueryResult source = locationIndex.findClosest(point.lat, point.lon, filter);
             if (!source.isValid()) {
                 throw new PointNotFoundException("Cannot find point: " + point, indexForErrorMessage);
             }
+            if (flagEncoder.getEdgeType(source.getClosestEdge().getFlags()) != GtfsStorage.EdgeType.HIGHWAY) {
+                throw new RuntimeException(flagEncoder.getEdgeType(source.getClosestEdge().getFlags()).name());
+            }
             return source;
         }
 
-        private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList waypoints) {
-            for (Label solution : solutions) {
-                final List<Trip.Leg> legs = tripFromLabel.getTrip(arriveBy, flagEncoder, translation, graphExplorer, weighting, solution);
-                if (separateWalkQuery) {
-                    legs.addAll(0, walkPaths.get(accessNode(solution)).getLegs());
-                    legs.addAll(walkPaths.get(egressNode(solution)).getLegs());
-                }
+        private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutions, PointList waypoints) {
+            for (List<Label.Transition> solution : solutions) {
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, graphExplorer, accessEgressWeighting, solution);
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
-                pathWrapper.setImpossible(isImpossible(solution));
-                // TODO: remove
-                pathWrapper.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+                pathWrapper.setImpossible(solution.stream().anyMatch(t -> t.label.impossible));
+                pathWrapper.setTime((solution.get(solution.size()-1).label.currentTime - solution.get(0).label.currentTime));
                 response.add(pathWrapper);
             }
             Comparator<PathWrapper> c = Comparator.comparingInt(p -> (p.isImpossible() ? 1 : 0));
@@ -230,61 +192,117 @@ private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList way
             response.getAll().sort(c.thenComparing(d));
         }
 
-        private boolean isImpossible(Label solution) {
-            for (Label i = solution; i != null; i = i.parent) {
-                if (i.impossible) {
-                    return true;
+        private List<List<Label.Transition>> findPaths(int startNode, int destNode) {
+            StopWatch stopWatch = new StopWatch().start();
+            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, extraEdges, true, walkSpeedKmH);
+            boolean reverse = !arriveBy;
+            GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
+            MultiCriteriaLabelSetting stationRouter = new MultiCriteriaLabelSetting(accessEgressGraphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, false, false, false, maxVisitedNodesForRequest, new ArrayList<>());
+            stationRouter.setBetaWalkTime(betaWalkTime);
+            Iterator<Label> stationIterator = stationRouter.calcLabels(destNode, startNode, initialTime, blockedRouteTypes).iterator();
+            List<Label> stationLabels = new ArrayList<>();
+            while (stationIterator.hasNext()) {
+                Label label = stationIterator.next();
+                if (label.adjNode == startNode) {
+                    stationLabels.add(label);
+                    break;
+                } else if (label.edge != -1 && flagEncoder.getEdgeType(accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).getFlags()) == edgeType) {
+                    stationLabels.add(label);
                 }
             }
-            return false;
-        }
+            visitedNodes += stationRouter.getVisitedNodes();
 
-        private int accessNode(Label solution) {
-            if (!arriveBy) {
-                while (solution.parent.parent != null) {
-                    solution = solution.parent;
-                }
-                return solution.adjNode;
-            } else {
-                return solution.parent.adjNode;
+            Map<Integer, Label> reverseSettledSet = new HashMap<>();
+            for (Label stationLabel : stationLabels) {
+                reverseSettledSet.put(stationLabel.adjNode, stationLabel);
             }
-        }
 
-        private int egressNode(Label solution) {
-            if (!arriveBy) {
-                return solution.parent.adjNode;
+            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            List<Label> discoveredSolutions = new ArrayList<>();
+            final long smallestStationLabelWeight;
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, true, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest, discoveredSolutions);
+            router.setBetaTransfers(betaTransfers);
+            router.setBetaWalkTime(betaWalkTime);
+            if (!stationLabels.isEmpty()) {
+                smallestStationLabelWeight = stationRouter.weight(stationLabels.get(0));
             } else {
-                while(solution.parent.parent != null) {
-                    solution = solution.parent;
+                smallestStationLabelWeight = Long.MAX_VALUE;
+            }
+            Iterator<Label> iterator = router.calcLabels(startNode, destNode, initialTime, blockedRouteTypes).iterator();
+            Map<Label, Label> originalSolutions = new HashMap<>();
+
+            long highestWeightForDominationTest = Long.MAX_VALUE;
+            while (iterator.hasNext()) {
+                Label label = iterator.next();
+                final long weight = router.weight(label);
+                if ( (!profileQuery || discoveredSolutions.size() >= limitSolutions) && weight + smallestStationLabelWeight > highestWeightForDominationTest) {
+                    break;
+                }
+                Label reverseLabel = reverseSettledSet.get(label.adjNode);
+                if (reverseLabel != null) {
+                    Label combinedSolution = new Label(label.currentTime - reverseLabel.currentTime + initialTime.toEpochMilli(), -1, label.adjNode, label.nTransfers + reverseLabel.nTransfers, label.nWalkDistanceConstraintViolations + reverseLabel.nWalkDistanceConstraintViolations, label.walkDistanceOnCurrentLeg + reverseLabel.walkDistanceOnCurrentLeg, label.departureTime, label.walkTime + reverseLabel.walkTime, 0, label.impossible, null);
+                    if (router.isNotDominatedByAnyOf(combinedSolution, discoveredSolutions)) {
+                        router.removeDominated(combinedSolution, discoveredSolutions);
+                        if (discoveredSolutions.size() < limitSolutions) {
+                            discoveredSolutions.add(combinedSolution);
+                            originalSolutions.put(combinedSolution, label);
+                            if (profileQuery) {
+                                highestWeightForDominationTest = router.weight(discoveredSolutions.get(discoveredSolutions.size()-1));
+                            } else {
+                                highestWeightForDominationTest = discoveredSolutions.stream().filter(s -> !s.impossible && (ignoreTransfers || s.nTransfers <= 1)).mapToLong(router::weight).min().orElse(Long.MAX_VALUE);
+                            }
+                        }
+                    }
                 }
-                return solution.adjNode;
             }
-        }
 
-        private List<Label> findPaths(int startNode, int destNode) {
-            StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false);
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, -1, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
-            final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime);
-            List<Label> solutions = labels
-                    .filter(current -> destNode == current.adjNode)
-                    .limit(limitSolutions)
-                    .collect(Collectors.toList());
+            List<List<Label.Transition>> pathsToStations = discoveredSolutions.stream()
+                    .map(originalSolutions::get)
+                    .map(l -> new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(arriveBy, flagEncoder, graphExplorer, l)).collect(Collectors.toList());
+
+            List<List<Label.Transition>> paths = pathsToStations.stream().map(p -> {
+                if (arriveBy) {
+                    List<Label.Transition> pp = new ArrayList<>(p.subList(1, p.size()));
+                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(0).label.adjNode));
+                    long diff = p.get(0).label.currentTime - pathFromStation.get(pathFromStation.size() - 1).label.currentTime;
+                    List<Label.Transition> patchedPathFromStation = pathFromStation.stream().map(t -> {
+                        return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
+                    }).collect(Collectors.toList());
+                    pp.addAll(0, patchedPathFromStation);
+                    return pp;
+                } else {
+                    List<Label.Transition> pp = new ArrayList<>(p);
+                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
+                    long diff = p.get(p.size() - 1).label.currentTime - pathFromStation.get(0).label.currentTime;
+                    List<Label.Transition> patchedPathFromStation = pathFromStation.subList(1, pathFromStation.size()).stream().map(t -> {
+                        return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
+                    }).collect(Collectors.toList());
+                    pp.addAll(patchedPathFromStation);
+                    return pp;
+                }
+            }).collect(Collectors.toList());
+
+            visitedNodes += router.getVisitedNodes();
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
-            if (solutions.isEmpty() && router.getVisitedNodes() >= maxVisitedNodesForRequest) {
+            if (discoveredSolutions.isEmpty() && router.getVisitedNodes() >= maxVisitedNodesForRequest) {
                 throw new IllegalArgumentException("No path found - maximum number of nodes exceeded: " + maxVisitedNodesForRequest);
             }
-            response.getHints().put("visited_nodes.sum", router.getVisitedNodes());
-            response.getHints().put("visited_nodes.average", router.getVisitedNodes());
-            if (solutions.isEmpty()) {
+            response.getHints().put("visited_nodes.sum", visitedNodes);
+            response.getHints().put("visited_nodes.average", visitedNodes);
+            if (discoveredSolutions.isEmpty()) {
                 response.addError(new RuntimeException("No route found"));
             }
-            return solutions;
+            return paths;
+        }
+
+        private List<Label.Transition> pathFromStation(GraphExplorer accessEgressGraphExplorer, Label l) {
+            return new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(!arriveBy, flagEncoder, accessEgressGraphExplorer, l);
         }
     }
 
     public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
         this.flagEncoder = flagEncoder;
+        this.accessEgressWeighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
         this.translationMap = translationMap;
         this.graphHopperStorage = graphHopperStorage;
         this.locationIndex = locationIndex;
@@ -305,7 +323,7 @@ public static TranslationMap createTranslationMap() {
         return new TranslationMap().doImport();
     }
 
-    public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingManager encodingManager, PtFlagEncoder ptFlagEncoder, GtfsStorage gtfsStorage, boolean createWalkNetwork, Collection<String> gtfsFiles, Collection<String> osmFiles) {
+    public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingManager encodingManager, PtFlagEncoder ptFlagEncoder, GtfsStorage gtfsStorage, Collection<String> gtfsFiles, Collection<String> osmFiles) {
         GraphHopperStorage graphHopperStorage = new GraphHopperStorage(directory, encodingManager, false, gtfsStorage);
         if (graphHopperStorage.loadExisting()) {
             return graphHopperStorage;
@@ -321,7 +339,7 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                     throw new RuntimeException(e);
                 }
             }
-            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(ptFlagEncoder)).doWork();
+            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(encodingManager.getEncoder("foot"))).doWork();
 
             int id = 0;
             for (String gtfsFile : gtfsFiles) {
@@ -331,17 +349,24 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                     throw new RuntimeException(e);
                 }
             }
-            if (createWalkNetwork) {
-                FakeWalkNetworkBuilder.buildWalkNetwork(((GtfsStorage) graphHopperStorage.getExtension()).getGtfsFeeds().values(), graphHopperStorage, ptFlagEncoder, Helper.DIST_EARTH);
-            }
             LocationIndex walkNetworkIndex;
             if (graphHopperStorage.getNodes() > 0) {
                 walkNetworkIndex = new LocationIndexTree(graphHopperStorage, new RAMDirectory()).prepareIndex();
             } else {
                 walkNetworkIndex = new EmptyLocationIndex();
             }
+            GraphHopperGtfs graphHopperGtfs = new GraphHopperGtfs(ptFlagEncoder, createTranslationMap(), graphHopperStorage, walkNetworkIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
             for (int i = 0; i < id; i++) {
-                new GtfsReader("gtfs_" + i, graphHopperStorage, gtfsStorage, ptFlagEncoder, walkNetworkIndex).readGraph();
+                GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get("gtfs_" + i);
+                GtfsReader gtfsReader = new GtfsReader("gtfs_" + i, graphHopperStorage, gtfsStorage, ptFlagEncoder, walkNetworkIndex);
+                gtfsReader.connectStopsToStreetNetwork();
+                graphHopperGtfs.getType0TransferWithTimes(gtfsFeed)
+                        .forEach(t -> {
+                            t.transfer.transfer_type = 2;
+                            t.transfer.min_transfer_time = (int) (t.time / 1000L);
+                            gtfsFeed.transfers.put(t.id, t.transfer);
+                        });
+                gtfsReader.buildPtNetwork();
             }
             graphHopperStorage.flush();
             return graphHopperStorage;
@@ -349,9 +374,9 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
     }
 
 
-    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage, PtFlagEncoder flagEncoder) {
-        final EverythingButPt everythingButPt = new EverythingButPt(flagEncoder);
-        Graph walkNetwork = GraphSupport.filteredView(graphHopperStorage, everythingButPt);
+    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage) {
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+        Graph walkNetwork = GraphSupport.filteredView(graphHopperStorage, filter);
         LocationIndex locationIndex = new LocationIndexTree(walkNetwork, directory);
         if (!locationIndex.loadExisting()) {
             locationIndex.prepareIndex();
@@ -368,12 +393,51 @@ public GHResponse route(GHRequest request) {
         return new RequestHandler(request).route();
     }
 
-    private static PtTravelTimeWeighting createPtTravelTimeWeighting(PtFlagEncoder encoder, boolean arriveBy, double walkSpeedKmH) {
-        PtTravelTimeWeighting weighting = new PtTravelTimeWeighting(encoder, walkSpeedKmH);
-        if (arriveBy) {
-            weighting = weighting.reverse();
-        }
-        return weighting;
+    private class TransferWithTime {
+        public String id;
+        Transfer transfer;
+        long time;
+    }
+
+    private Stream<TransferWithTime> getType0TransferWithTimes(GTFSFeed gtfsFeed) {
+        return gtfsFeed.transfers.entrySet()
+                .parallelStream()
+                .filter(e -> e.getValue().transfer_type == 0)
+                .map(e -> {
+                    PointList points = new PointList(2, false);
+                    final int fromnode = gtfsStorage.getStationNodes().get(e.getValue().from_stop_id);
+                    final QueryResult fromstation = new QueryResult(graphHopperStorage.getNodeAccess().getLat(fromnode), graphHopperStorage.getNodeAccess().getLon(fromnode));
+                    fromstation.setClosestNode(fromnode);
+                    points.add(graphHopperStorage.getNodeAccess().getLat(fromnode), graphHopperStorage.getNodeAccess().getLon(fromnode));
+
+                    final int tonode = gtfsStorage.getStationNodes().get(e.getValue().to_stop_id);
+                    final QueryResult tostation = new QueryResult(graphHopperStorage.getNodeAccess().getLat(tonode), graphHopperStorage.getNodeAccess().getLon(tonode));
+                    tostation.setClosestNode(tonode);
+                    points.add(graphHopperStorage.getNodeAccess().getLat(tonode), graphHopperStorage.getNodeAccess().getLon(tonode));
+
+                    QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+                    queryGraph.lookup(Collections.emptyList());
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+
+                    MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
+                    Iterator<Label> iterator = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0).iterator();
+                    Label solution = null;
+                    while (iterator.hasNext()) {
+                        Label label = iterator.next();
+                        if (tonode == label.adjNode) {
+                            solution = label;
+                            break;
+                        }
+                    }
+                    if (solution == null) {
+                        throw new RuntimeException("Can't find a transfer walk route.");
+                    }
+                    TransferWithTime transferWithTime = new TransferWithTime();
+                    transferWithTime.id = e.getKey();
+                    transferWithTime.transfer = e.getValue();
+                    transferWithTime.time = solution.currentTime;
+                    return transferWithTime;
+                });
     }
 
     private PointList pointListFrom(List<QueryResult> queryResults) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 7a32361513..8dc039f17b 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -20,19 +20,14 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.Frequency;
-import com.conveyal.gtfs.model.Route;
-import com.conveyal.gtfs.model.Service;
-import com.conveyal.gtfs.model.Stop;
-import com.conveyal.gtfs.model.StopTime;
-import com.conveyal.gtfs.model.Transfer;
-import com.conveyal.gtfs.model.Trip;
+import com.conveyal.gtfs.model.*;
 import com.google.common.collect.HashMultimap;
-import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -40,32 +35,14 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
-import gnu.trove.map.hash.TIntIntHashMap;
 import org.mapdb.Fun;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-import java.util.NavigableSet;
-import java.util.Optional;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.Spliterators;
-import java.util.TreeSet;
-import java.util.function.Consumer;
+import java.util.*;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 
 import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
@@ -76,7 +53,7 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay, Set<Integer> cancelledArrivals, Set<Integer> cancelledDepartures) {
+        TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay, Set<Integer> cancelledArrivals, Set<Integer> cancelledDepartures) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
@@ -91,18 +68,6 @@ public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay,
         Set<Integer> cancelledDeparture;
     }
 
-    private static class TimelineNodeIdWithTripId {
-        final String tripId;
-        final String routeId;
-        final int timelineNodeId;
-
-        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String routeId) {
-            this.tripId = tripId;
-            this.routeId = routeId;
-            this.timelineNodeId = timelineNodeId;
-        }
-    }
-
     private static final Logger LOGGER = LoggerFactory.getLogger(GtfsReader.class);
 
     private final Graph graph;
@@ -115,9 +80,8 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
     private final String id;
     private int i;
     private GTFSFeed feed;
-    private final TIntIntHashMap times = new TIntIntHashMap();
-    private final SetMultimap<String, TimelineNodeIdWithTripId> departureTimelineNodes = HashMultimap.create();
-    private final SetMultimap<String, TimelineNodeIdWithTripId> arrivalTimelineNodes = HashMultimap.create();
+    private final Map<String, Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>>> departureTimelinesByStop = new HashMap<>();
+    private final Map<String, Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>>> arrivalTimelinesByStop = new HashMap<>();
     private final PtFlagEncoder encoder;
 
     GtfsReader(String id, Graph graph, GtfsStorageI gtfsStorage, PtFlagEncoder encoder, LocationIndex walkNetworkIndex) {
@@ -130,35 +94,42 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
         this.feed = this.gtfsStorage.getGtfsFeeds().get(id);
         this.transfers = this.gtfsStorage.getTransfers().get(id);
         this.i = graph.getNodes();
-        this.startDate = feed.calculateStats().getStartDate();
-        this.endDate = feed.calculateStats().getEndDate();
+        this.startDate = feed.getStartDate();
+        this.endDate = feed.getEndDate();
     }
 
-    void readGraph() {
-        gtfsStorage.getFares().putAll(feed.fares);
-        transfers = new Transfers(feed);
-        gtfsStorage.getTransfers().put(id, transfers);
-        connectStopsToStreetNetwork();
-        buildPtNetwork();
-    }
-
-    private void connectStopsToStreetNetwork() {
-        EdgeFilter filter = new EverythingButPt(encoder);
+    void connectStopsToStreetNetwork() {
+        FlagEncoder footEncoder = ((GraphHopperStorage) graph).getEncodingManager().getEncoder("foot");
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(footEncoder);
         for (Stop stop : feed.stops.values()) {
-            QueryResult locationQueryResult = walkNetworkIndex.findClosest(stop.stop_lat, stop.stop_lon, filter);
-            int streetNode;
-            if (!locationQueryResult.isValid()) {
-                streetNode = i++;
-                nodeAccess.setNode(streetNode, stop.stop_lat, stop.stop_lon);
-                graph.edge(streetNode, streetNode, 0.0, false);
-            } else {
-                streetNode = locationQueryResult.getClosestNode();
+            if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
+                QueryResult locationQueryResult = walkNetworkIndex.findClosest(stop.stop_lat, stop.stop_lon, filter);
+                int streetNode;
+                if (!locationQueryResult.isValid()) {
+                    streetNode = i++;
+                    nodeAccess.setNode(streetNode, stop.stop_lat, stop.stop_lon);
+                    EdgeIteratorState edge = graph.edge(streetNode, streetNode);
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                    edge.setFlags(footEncoder.setAccess(edge.getFlags(), true, false));
+                    edge.setFlags(footEncoder.setSpeed(edge.getFlags(), 5.0));
+                } else {
+                    streetNode = locationQueryResult.getClosestNode();
+                }
+                gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
             }
-            gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
         }
     }
 
-    private void buildPtNetwork() {
+    void buildPtNetwork() {
+        gtfsStorage.getFares().putAll(feed.fares);
+        transfers = new Transfers(feed);
+        gtfsStorage.getTransfers().put(id, transfers);
+        createTrips();
+        wireUpStops();
+        insertTransfers();
+    }
+
+    private void createTrips() {
         HashMultimap<String, Trip> blockTrips = HashMultimap.create();
         for (Trip trip : feed.trips.values()) {
             if (trip.block_id != null) {
@@ -178,7 +149,7 @@ private void buildPtNetwork() {
                             }
                         }
                         ArrayList<StopTime> stopTimes = new ArrayList<>();
-                        getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
+                        feed.getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
                         return new TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
@@ -198,207 +169,51 @@ private void buildPtNetwork() {
                 }
             }
         });
-
-        wireUpStops();
     }
 
-    void wireUpStops() {
-        for (Stop stop : feed.stops.values()) {
-            if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
-                int streetNode = gtfsStorage.getStationNodes().get(stop.stop_id);
-
-                if (arrivalTimelineNodes.containsKey(stop.stop_id)) {
-                    final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-
-                    arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                        int stopExitNode = i-1;
-                        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-
-                        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode, 0.0, false);
-                        setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
-                        exitEdge.setName(stop.stop_name);
-                        gtfsStorage.getRoutes().put(exitEdge.getEdge(), routeId);
-
-                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                        wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                    });
-
-                }
-
-                if (departureTimelineNodes.containsKey(stop.stop_id)) {
-                    final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-
-                    departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                        int stopEnterNode = i-1;
-                        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-
-                        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode, 0.0, false);
-                        setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
-                        entryEdge.setName(stop.stop_name);
-                        gtfsStorage.getRoutes().put(entryEdge.getEdge(), routeId);
-
-                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                        wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                    });
-                }
-            }
-        }
-        insertTransfers();
-    }
-
-    void wireUpAdditionalDepartures(ZoneId zoneId) {
-        for (Stop stop : feed.stops.values()) {
-            int stationNode = gtfsStorage.getStationNodes().get(stop.stop_id);
-            final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                int platformNode = findPlatformEnterNode(stationNode, routeId);
-                if (platformNode != -1) {
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> staticTimelineNodesForRoute = findDepartureTimelineNodesForRoute(stationNode, routeId).collect(Collectors.toCollection(TreeSet::new));
-                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
-                        SortedSet<Fun.Tuple2<Integer, Integer>> headSet = staticTimelineNodesForRoute.headSet(timelineNode);
-                        if(!headSet.isEmpty()) {
-                            Fun.Tuple2<Integer, Integer> before = headSet.last();
-                            EdgeIteratorState edge = graph.edge(before.b, timelineNode.b,0.0, false);
-                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
-                            edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a-before.a));
-                        }
-                        SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = staticTimelineNodesForRoute.tailSet(timelineNode);
-                        if (!tailSet.isEmpty()) {
-                            Fun.Tuple2<Integer, Integer> after = tailSet.first();
-                            EdgeIteratorState edge = graph.edge(timelineNode.b, after.b, 0.0, false);
-                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
-                            edge.setFlags(encoder.setTime(edge.getFlags(), after.a-timelineNode.a));
-
-//                            System.out.println(" "+ after);
-//                            EdgeIterator ei = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false)).setBaseNode(after.b);
-//                            while(ei.next()) {
-//                                if (encoder.getEdgeType(ei.getFlags()) == GtfsStorage.EdgeType.TRANSFER) {
-//                                    System.out.println("   "+ei+"   @"+Long.toString(after.a-encoder.getTime(ei.getFlags())));
-//                                }
-//                            }
-
-                        }
-
-                        EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b, 0.0, false);
-                        setEdgeType(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
-                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
-                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-                    });
-                } else {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopEnterNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-                    EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode, 0.0, false);
-                    setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
-                    entryEdge.setName(stop.stop_name);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                    wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                }
-            });
-            final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                int platformNode = findPlatformExitNode(stationNode, routeId);
-                NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-
-                if (platformNode != -1) {
-                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
-                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
-                        EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode, 0.0, false);
-                        setEdgeType(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
-                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
-                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-                    });
-                } else {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopExitNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-                    EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode, 0.0, false);
-                    setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
-                    exitEdge.setName(stop.stop_name);
-                    wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                }
-                final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(stop.stop_id, routeId).stream().filter(t -> t.from_stop_id.equals(stop.stop_id)).findAny();
-                if (!withinStationTransfer.isPresent()) {
-                    insertOutboundTransfers(stop.stop_id, null, 0, timeNodes);
-                }
-                transfers.getTransfersFromStop(stop.stop_id, routeId).forEach(transfer -> {
-                    insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
-                });
-            });
-        }
+    private void wireUpStops() {
+        arrivalTimelinesByStop.forEach((stopId, arrivalTimelines) -> {
+            int streetNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            arrivalTimelines.forEach(((platformDescriptor, arrivalTimeline) ->
+                    wireUpArrivalTimeline(streetNode, stop, arrivalTimeline, routeType(platformDescriptor), platformDescriptor)));
+        });
+        departureTimelinesByStop.forEach((stopId, departureTimelines) -> {
+            int streetNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            departureTimelines.forEach(((platformDescriptor, departureTimeline) ->
+                    wireUpDepartureTimeline(streetNode, stop, departureTimeline, routeType(platformDescriptor), platformDescriptor)));
+        });
     }
 
-    private Stream<Fun.Tuple2<Integer, Integer>> findDepartureTimelineNodesForRoute(int stationNode, String routeId) {
-        int node = findPlatformEnterNode(stationNode, routeId);
-        if (node == -1) {
-            return Stream.empty();
-        }
-        return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
-            EdgeIterator edgeIterator = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true)).setBaseNode(node);
-            @Override
-            public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
-                if (edgeIterator.next()) {
-                    action.accept(edgeIterator);
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-        }, false)
-                .filter(edge -> encoder.getEdgeType(edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK)
-                .map(edge -> new Fun.Tuple2<>((int) encoder.getTime(edge.getFlags()), edge.getAdjNode()));
+    private void insertTransfers() {
+        departureTimelinesByStop.forEach((toStopId, departureTimelines) ->
+                departureTimelines.forEach(((platformDescriptor, departureTimeline) ->
+                        insertTransfers(toStopId, routeIdOrNull(platformDescriptor), departureTimeline))));
     }
 
-    private int findPlatformEnterNode(int stationNode, String routeId) {
-        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true)).setBaseNode(stationNode);
-        while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
-                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
-                    return i.getAdjNode();
-                }
-            }
-        }
-        return -1;
-    }
 
-    private int findPlatformExitNode(int stationNode, String routeId) {
-        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false)).setBaseNode(stationNode);
-        while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
-                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
-                    return i.getAdjNode();
-                }
-            }
+    private void insertTransfers(String toStopId, String toRouteId, NavigableMap<Integer, Integer> departureTimeline) {
+        final Optional<Transfer> withinStationTransfer = transfers.getTransfersToStop(toStopId, toRouteId).stream().filter(t -> t.from_stop_id.equals(toStopId)).findAny();
+        if (!withinStationTransfer.isPresent()) {
+            insertInboundTransfers(toStopId, null, 0, departureTimeline);
         }
-        return -1;
+        transfers.getTransfersToStop(toStopId, toRouteId).forEach(transfer ->
+                insertInboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, departureTimeline));
     }
 
-    private NavigableSet<Fun.Tuple2<Integer, Integer>> sorted(List<TimelineNodeIdWithTripId> timelineNodesWithTripId) {
-        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-        return timeNodes;
-    }
-
-    void insertTransfers() {
-        departureTimelineNodes.asMap().forEach((toStopId, timelineNodesWithTripId) -> {
-            final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(toStopId).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            departureTimelineNodesByRoute.forEach((toRouteId, timelineNodesByRoute) -> {
-                NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesByRoute);
-                final Optional<Transfer> withinStationTransfer = transfers.getTransfersToStop(toStopId, toRouteId).stream().filter(t -> t.from_stop_id.equals(toStopId)).findAny();
-                if (!withinStationTransfer.isPresent()) {
-                    insertInboundTransfers(toStopId, null, 0, timeNodes);
-                }
-                transfers.getTransfersToStop(toStopId, toRouteId).forEach(transfer -> {
-                    insertInboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
-                });
-            });
+    void wireUpAdditionalDeparturesAndArrivals(ZoneId zoneId) {
+        departureTimelinesByStop.forEach((stopId, departureTimelines) -> {
+            int stationNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            departureTimelines.forEach(((platformDescriptor, timeline) ->
+                    wireUpOrPatchDepartureTimeline(zoneId, stationNode, stop, timeline, platformDescriptor)));
+        });
+        arrivalTimelinesByStop.forEach((stopId, arrivalTimelines) -> {
+            int stationNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            arrivalTimelines.forEach(((platformDescriptor, timeline) ->
+                    wireUpOrPatchArrivalTimeline(zoneId, stationNode, stop, routeIdOrNull(platformDescriptor), timeline, platformDescriptor)));
         });
     }
 
@@ -418,6 +233,7 @@ private void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time, bo
     private static class TripWithStopTimeAndArrivalNode {
         TripWithStopTimes tripWithStopTimes;
         int arrivalNode;
+        int arrivalTime;
     }
 
     void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arrivalNodes, TripWithStopTimes trip, GtfsRealtime.TripDescriptor tripDescriptor, boolean frequencyBased) {
@@ -425,13 +241,14 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
         IntArrayList alightEdges = new IntArrayList();
         StopTime prev = null;
         int arrivalNode = -1;
+        int arrivalTime = -1;
         int departureNode = -1;
         for (StopTime stopTime : trip.stopTimes) {
             Stop stop = feed.stops.get(stopTime.stop_id);
             arrivalNode = i++;
             nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
             nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(arrivalNode, stopTime.arrival_time + time);
+            arrivalTime = stopTime.arrival_time + time;
             if (prev != null) {
                 Stop fromStop = feed.stops.get(prev.stop_id);
                 double distance = distCalc.calcDist(
@@ -439,30 +256,45 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                         fromStop.stop_lon,
                         stop.stop_lat,
                         stop.stop_lon);
-                EdgeIteratorState edge = graph.edge(
-                        departureNode,
-                        arrivalNode,
-                        distance,
-                        false);
+                EdgeIteratorState edge = graph.edge(departureNode, arrivalNode);
+                edge.setDistance(distance);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 edge.setName(stop.stop_name);
-                setEdgeType(edge, GtfsStorage.EdgeType.HOP);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.HOP);
                 edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
             }
-            final int departureTimelineNode = i++;
-            nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-            nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(departureTimelineNode, stopTime.departure_time + time);
-            departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip.trip_id, trip.trip.route_id));
-            final int arrivalTimelineNode = i++;
-            nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
-            nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(arrivalTimelineNode, stopTime.arrival_time + time);
-            arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+            Route route = feed.routes.get(trip.trip.route_id);
+            Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>> departureTimelines = departureTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+            NavigableMap<Integer, Integer> departureTimeline;
+            if (transfers.hasNoRouteSpecificDepartureTransferRules(stopTime.stop_id)) {
+                departureTimeline = departureTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.routeType(route.route_type), s -> new TreeMap<>());
+            } else {
+                departureTimeline = departureTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(route.route_id), s -> new TreeMap<>());
+            }
+            int departureTimelineNode = departureTimeline.computeIfAbsent((stopTime.departure_time + time) % (24 * 60 * 60), t -> {
+                final int _departureTimelineNode = i++;
+                nodeAccess.setNode(_departureTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(_departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                return _departureTimelineNode;
+            });
+
+            Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>>  arrivalTimelines = arrivalTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+            NavigableMap<Integer, Integer> arrivalTimeline;
+            if (transfers.hasNoRouteSpecificArrivalTransferRules(stopTime.stop_id)) {
+                arrivalTimeline = arrivalTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.routeType(route.route_type), s -> new TreeMap<>());
+            } else {
+                arrivalTimeline = arrivalTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(route.route_id), s -> new TreeMap<>());
+            }
+            int arrivalTimelineNode = arrivalTimeline.computeIfAbsent((stopTime.arrival_time + time) % (24 * 60 * 60), t -> {
+                final int _arrivalTimelineNode = i++;
+                nodeAccess.setNode(_arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(_arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                return _arrivalTimelineNode;
+            });
             departureNode = i++;
             nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
             nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(departureNode, stopTime.departure_time + time);
             int dayShift = stopTime.departure_time / (24 * 60 * 60);
             GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(trip.validOnDay, dayShift), zoneId, startDate);
             int validityId;
@@ -473,13 +305,10 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                 gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
             }
 
-            EdgeIteratorState boardEdge = graph.edge(
-                    departureTimelineNode,
-                    departureNode,
-                    0.0,
-                    false);
+            EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
+            boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
             boardEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+            setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
             while (boardEdges.size() < stopTime.stop_sequence) {
                 boardEdges.add(-1); // Padding, so that index == stop_sequence
             }
@@ -489,13 +318,10 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
             boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
 
-            EdgeIteratorState alightEdge = graph.edge(
-                    arrivalNode,
-                    arrivalTimelineNode,
-                    0.0,
-                    false);
+            EdgeIteratorState alightEdge = graph.edge(arrivalNode, arrivalTimelineNode);
+            alightEdge.setFlags(encoder.setAccess(alightEdge.getFlags(), true, false));
             alightEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
+            setEdgeTypeAndClearDistance(alightEdge, GtfsStorage.EdgeType.ALIGHT);
             while (alightEdges.size() < stopTime.stop_sequence) {
                 alightEdges.add(-1);
             }
@@ -503,19 +329,14 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
             gtfsStorage.getTripDescriptors().put(alightEdge.getEdge(), tripDescriptor.toByteArray());
             alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
-//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
-
 
-            EdgeIteratorState dwellEdge = graph.edge(
-                    arrivalNode,
-                    departureNode,
-                    0.0,
-                    false);
+            EdgeIteratorState dwellEdge = graph.edge(arrivalNode, departureNode);
+            dwellEdge.setFlags(encoder.setAccess(dwellEdge.getFlags(), true, false));
             dwellEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
+            setEdgeTypeAndClearDistance(dwellEdge, GtfsStorage.EdgeType.DWELL);
             dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
             if (prev == null) {
-                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validOn, zoneId);
+                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime.departure_time + time, stopTime, stop, validOn, zoneId);
             }
             prev = stopTime;
         }
@@ -524,18 +345,146 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
         TripWithStopTimeAndArrivalNode tripWithStopTimeAndArrivalNode = new TripWithStopTimeAndArrivalNode();
         tripWithStopTimeAndArrivalNode.tripWithStopTimes = trip;
         tripWithStopTimeAndArrivalNode.arrivalNode = arrivalNode;
+        tripWithStopTimeAndArrivalNode.arrivalTime = arrivalTime;
         arrivalNodes.add(tripWithStopTimeAndArrivalNode);
     }
 
+    private void wireUpDepartureTimeline(int streetNode, Stop stop, NavigableMap<Integer, Integer> departureTimeline, int route_type, GtfsStorageI.PlatformDescriptor platformDescriptorIfStatic) {
+        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+        int stopEnterNode = i - 1;
+        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
+        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode);
+        entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
+        setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
+        entryEdge.setFlags(encoder.setValidityId(entryEdge.getFlags(), route_type));
+        entryEdge.setName(stop.stop_name);
+        if (platformDescriptorIfStatic != null) {
+            gtfsStorage.getRoutes().put(entryEdge.getEdge(), platformDescriptorIfStatic);
+        }
+        wireUpAndConnectTimeline(stop, stopEnterNode, departureTimeline, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK, GtfsStorage.EdgeType.WAIT);
+    }
+
+    private void wireUpArrivalTimeline(int streetNode, Stop stop, NavigableMap<Integer, Integer> arrivalTimeline, int route_type, GtfsStorageI.PlatformDescriptor platformDescriptorIfStatic) {
+        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+        int stopExitNode = i - 1;
+        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
+        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode);
+        exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
+        setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
+        exitEdge.setFlags(encoder.setValidityId(exitEdge.getFlags(), route_type));
+        exitEdge.setName(stop.stop_name);
+        if (platformDescriptorIfStatic != null) {
+            gtfsStorage.getRoutes().put(exitEdge.getEdge(), platformDescriptorIfStatic);
+        }
+        wireUpAndConnectTimeline(stop, stopExitNode, arrivalTimeline, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK, GtfsStorage.EdgeType.WAIT_ARRIVAL);
+    }
+
+    private void wireUpOrPatchDepartureTimeline(ZoneId zoneId, int stationNode, Stop stop, NavigableMap<Integer, Integer> timeline, GtfsStorageI.PlatformDescriptor route) {
+        int platformEnterNode = findPlatformNode(stationNode, route, GtfsStorage.EdgeType.ENTER_PT);
+        if (platformEnterNode != -1) {
+            patchDepartureTimeline(zoneId, timeline, platformEnterNode);
+        } else {
+            wireUpDepartureTimeline(stationNode, stop, timeline, 0, null);
+        }
+    }
+
+    private void wireUpOrPatchArrivalTimeline(ZoneId zoneId, int stationNode, Stop stop, String routeId, NavigableMap<Integer, Integer> timeline, GtfsStorageI.PlatformDescriptor route) {
+        int platformExitNode = findPlatformNode(stationNode, route, GtfsStorage.EdgeType.EXIT_PT);
+        if (platformExitNode != -1) {
+            patchArrivalTimeline(zoneId, timeline, platformExitNode);
+        } else {
+            wireUpArrivalTimeline(stationNode, stop, timeline, 0, null);
+        }
+        final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(stop.stop_id, routeId).stream().filter(t -> t.from_stop_id.equals(stop.stop_id)).findAny();
+        if (!withinStationTransfer.isPresent()) {
+            insertOutboundTransfers(stop.stop_id, null, 0, timeline);
+        }
+        transfers.getTransfersFromStop(stop.stop_id, routeId).forEach(transfer ->
+                insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeline));
+    }
+
+    private void patchDepartureTimeline(ZoneId zoneId, NavigableMap<Integer, Integer> timeline, int platformNode) {
+        NavigableMap<Integer, Integer> staticDepartureTimelineForRoute = findDepartureTimelineForPlatform(platformNode);
+        timeline.forEach((time, node) -> {
+            SortedMap<Integer, Integer> headMap = staticDepartureTimelineForRoute.headMap(time);
+            if (!headMap.isEmpty()) {
+                EdgeIteratorState edge = graph.edge(headMap.get(headMap.lastKey()), node);
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
+                edge.setFlags(encoder.setTime(edge.getFlags(), time - headMap.lastKey()));
+            }
+            SortedMap<Integer, Integer> tailMap = staticDepartureTimelineForRoute.tailMap(time);
+            if (!tailMap.isEmpty()) {
+                EdgeIteratorState edge = graph.edge(node, tailMap.get(tailMap.firstKey()));
+                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
+                edge.setFlags(encoder.setTime(edge.getFlags(), tailMap.firstKey() - time));
+            }
+
+            EdgeIteratorState edge = graph.edge(platformNode, node);
+            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
+            edge.setFlags(encoder.setTime(edge.getFlags(), time));
+            setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        });
+    }
+
+    private void patchArrivalTimeline(ZoneId zoneId, NavigableMap<Integer, Integer> timeline, int platformExitNode) {
+        timeline.forEach((time, node) -> {
+            EdgeIteratorState edge = graph.edge(node, platformExitNode);
+            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
+            edge.setFlags(encoder.setTime(edge.getFlags(), time));
+            setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        });
+    }
+
+    private NavigableMap<Integer, Integer> findDepartureTimelineForPlatform(int platformEnterNode) {
+        TreeMap<Integer, Integer> result = new TreeMap<>();
+        if (platformEnterNode == -1) {
+            return result;
+        }
+        EdgeIterator edge = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder)).setBaseNode(platformEnterNode);
+        while (edge.next()) {
+            if (encoder.getEdgeType(edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                result.put((int) encoder.getTime(edge.getFlags()), edge.getAdjNode());
+            }
+        }
+        return result;
+    }
+
+    private int findPlatformNode(int stationNode, GtfsStorageI.PlatformDescriptor platformDescriptor, GtfsStorage.EdgeType edgeType) {
+        DefaultEdgeFilter filter;
+        if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
+            filter = DefaultEdgeFilter.outEdges(encoder);
+        } else if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
+            filter = DefaultEdgeFilter.inEdges(encoder);
+        } else {
+            throw new RuntimeException();
+        }
+        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(filter).setBaseNode(stationNode);
+        while (i.next()) {
+            if (encoder.getEdgeType(i.getFlags()) == edgeType) {
+                if (platformDescriptor.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
+                    return i.getAdjNode();
+                }
+            }
+        }
+        return -1;
+    }
+
     int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescriptor, int stopSequence, int departureTime, int departureNode, BitSet validOnDay) {
         Trip trip = feed.trips.get(tripDescriptor.getTripId());
-        final int departureTimelineNode = i++;
         StopTime stopTime = feed.stop_times.get(new Fun.Tuple2(tripDescriptor.getTripId(), stopSequence));
         Stop stop = feed.stops.get(stopTime.stop_id);
-        nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-        nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-        times.put(departureTimelineNode, departureTime);
-        departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, tripDescriptor.getTripId(), trip.route_id));
+        Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>> departureTimelineNodesByRoute = departureTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+        NavigableMap<Integer, Integer> departureTimelineNodes = departureTimelineNodesByRoute.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(trip.route_id), s -> new TreeMap<>());
+        int departureTimelineNode = departureTimelineNodes.computeIfAbsent(departureTime % (24 * 60 * 60), t -> {
+            final int _departureTimelineNode = i++;
+            nodeAccess.setNode(_departureTimelineNode, stop.stop_lat, stop.stop_lon);
+            nodeAccess.setAdditionalNodeField(_departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+            return _departureTimelineNode;
+        });
 
         int dayShift = departureTime / (24 * 60 * 60);
         GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
@@ -547,13 +496,10 @@ int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescripto
             gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
         }
 
-        EdgeIteratorState boardEdge = graph.edge(
-                departureTimelineNode,
-                departureNode,
-                0.0,
-                false);
+        EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
+        boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
         boardEdge.setName(getRouteName(feed, trip));
-        setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+        setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
         gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopSequence);
         gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
         boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
@@ -561,24 +507,41 @@ int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescripto
         return boardEdge.getEdge();
     }
 
-    private void wireUpAndAndConnectArrivalTimeline(Stop toStop, String routeId, int stopExitNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
-        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(routeId).agency_id).agency_timezone);
+    private void wireUpAndConnectTimeline(Stop toStop, int platformNode, NavigableMap<Integer, Integer> timeNodes, GtfsStorage.EdgeType timeExpandedNetworkEdgeType, GtfsStorage.EdgeType waitEdgeType) {
+        ZoneId zoneId = ZoneId.of(feed.agency.values().iterator().next().agency_timezone);
         int time = 0;
         int prev = -1;
-        for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode, 0.0, false);
-            setEdgeType(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
-            int arrivalTime = e.a;
-            leaveTimeExpandedNetworkEdge.setFlags(encoder.setTime(leaveTimeExpandedNetworkEdge.getFlags(), arrivalTime));
-            setFeedIdWithTimezone(leaveTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        for (Map.Entry<Integer, Integer> e : timeNodes.descendingMap().entrySet()) {
+            EdgeIteratorState timeExpandedNetworkEdge;
+            if (timeExpandedNetworkEdgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
+                timeExpandedNetworkEdge = graph.edge(e.getValue(), platformNode);
+            } else if (timeExpandedNetworkEdgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                timeExpandedNetworkEdge = graph.edge(platformNode, e.getValue());
+            } else {
+                throw new RuntimeException();
+            }
+            timeExpandedNetworkEdge.setFlags(encoder.setAccess(timeExpandedNetworkEdge.getFlags(), true, false));
+            timeExpandedNetworkEdge.setName(toStop.stop_name);
+            setEdgeTypeAndClearDistance(timeExpandedNetworkEdge, timeExpandedNetworkEdgeType);
+            timeExpandedNetworkEdge.setFlags(encoder.setTime(timeExpandedNetworkEdge.getFlags(), e.getKey()));
+            setFeedIdWithTimezone(timeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev, 0.0, false);
-                setEdgeType(edge, GtfsStorage.EdgeType.WAIT_ARRIVAL);
-                edge.setName(toStop.stop_name);
-                edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
+                EdgeIteratorState waitEdge = graph.edge(e.getValue(), prev);
+                waitEdge.setFlags(encoder.setAccess(waitEdge.getFlags(), true, false));
+                setEdgeTypeAndClearDistance(waitEdge, waitEdgeType);
+                waitEdge.setName(toStop.stop_name);
+                waitEdge.setFlags(encoder.setTime(waitEdge.getFlags(), time-e.getKey()));
             }
-            time = e.a;
-            prev = e.b;
+            time = e.getKey();
+            prev = e.getValue();
+        }
+        if (!timeNodes.isEmpty()) {
+            EdgeIteratorState edge = graph.edge(timeNodes.get(timeNodes.lastKey()), timeNodes.get(timeNodes.firstKey()));
+            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+            int rolloverTime = 24 * 60 * 60 - timeNodes.lastKey() + timeNodes.firstKey();
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.OVERNIGHT);
+            edge.setName(toStop.stop_name);
+            edge.setFlags(encoder.setTime(edge.getFlags(), rolloverTime));
         }
     }
 
@@ -593,42 +556,13 @@ private void setFeedIdWithTimezone(EdgeIteratorState leaveTimeExpandedNetworkEdg
         leaveTimeExpandedNetworkEdge.setFlags(encoder.setValidityId(leaveTimeExpandedNetworkEdge.getFlags(), validityId));
     }
 
-    private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId, int stopEnterNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
-        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(toRouteId).agency_id).agency_timezone);
-        int time = 0;
-        int prev = -1;
-        for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState enterTimeExpandedNetworkEdge = graph.edge(stopEnterNode, e.b, 0.0, false);
-            enterTimeExpandedNetworkEdge.setName(toStop.stop_name);
-            setEdgeType(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
-            enterTimeExpandedNetworkEdge.setFlags(encoder.setTime(enterTimeExpandedNetworkEdge.getFlags(), e.a));
-            setFeedIdWithTimezone(enterTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-            if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev, 0.0, false);
-                setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
-                edge.setName(toStop.stop_name);
-                edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
-            }
-            time = e.a;
-            prev = e.b;
-        }
-        if (!timeNodes.isEmpty()) {
-            EdgeIteratorState edge = graph.edge(timeNodes.last().b, timeNodes.first().b, 0.0, false);
-            int rolloverTime = 24 * 60 * 60 - timeNodes.last().a + timeNodes.first().a;
-            setEdgeType(edge, GtfsStorage.EdgeType.OVERNIGHT);
-            edge.setName(toStop.stop_name);
-            edge.setFlags(encoder.setTime(edge.getFlags(), rolloverTime));
-        }
-    }
-
-    private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
+    private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, int departureTime, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
         BitSet accumulatorValidity = new BitSet(validOn.validity.size());
         accumulatorValidity.or(validOn.validity);
-        EdgeIteratorState edge;
         ListIterator<TripWithStopTimeAndArrivalNode> li = arrivalNodes.listIterator(arrivalNodes.size());
         while(li.hasPrevious() && accumulatorValidity.cardinality() > 0) {
             TripWithStopTimeAndArrivalNode lastTrip = li.previous();
-            int dwellTime = times.get(departureNode) - times.get(lastTrip.arrivalNode);
+            int dwellTime = departureTime - lastTrip.arrivalTime;
             if (dwellTime >= 0 && accumulatorValidity.intersects(lastTrip.tripWithStopTimes.validOnDay)) {
                 BitSet blockTransferValidity = new BitSet(validOn.validity.size());
                 blockTransferValidity.or(validOn.validity);
@@ -643,54 +577,38 @@ private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> ar
                 }
                 nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
                 nodeAccess.setAdditionalNodeField(i-1, NodeType.INTERNAL_PT.ordinal());
-                edge = graph.edge(
-                        lastTrip.arrivalNode,
-                        i-1,
-                        0.0,
-                        false);
-                setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
-                edge.setFlags(encoder.setTime(edge.getFlags(), dwellTime));
-                edge = graph.edge(
-                        i-1,
-                        departureNode,
-                        0.0,
-                        false);
-                setEdgeType(edge, GtfsStorage.EdgeType.BOARD);
-                edge.setFlags(encoder.setValidityId(edge.getFlags(), blockTransferValidityId));
-                gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getTripDescriptors().put(edge.getEdge(), tripDescriptor.toByteArray());
+                EdgeIteratorState transferEdge = graph.edge(lastTrip.arrivalNode,i-1);
+                transferEdge.setFlags(encoder.setAccess(transferEdge.getFlags(), true, false));
+                setEdgeTypeAndClearDistance(transferEdge, GtfsStorage.EdgeType.TRANSFER);
+                transferEdge.setFlags(encoder.setTime(transferEdge.getFlags(), dwellTime));
+                EdgeIteratorState boardEdge = graph.edge(i-1, departureNode);
+                boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
+                setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
+                boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), blockTransferValidityId));
+                gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
+                gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
                 accumulatorValidity.andNot(lastTrip.tripWithStopTimes.validOnDay);
             }
         }
     }
 
-    private Iterable<StopTime> getInterpolatedStopTimesForTrip(String trip_id) {
-        try {
-            return feed.getInterpolatedStopTimesForTrip(trip_id);
-        } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> toStopTimelineNode) {
+    private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, NavigableMap<Integer, Integer> toStopTimelineNode) {
         int stationNode = gtfsStorage.getStationNodes().get(fromStopId);
         EdgeIterator i = graph.createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
-                String routeId = gtfsStorage.getRoutes().get(i.getEdge());
-                if (from_route_id == null || from_route_id.equals(routeId)) {
+            if (encoder.getEdgeType(i.getFlags()) == GtfsStorage.EdgeType.EXIT_PT) {
+                GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
+                if (from_route_id == null || GtfsStorageI.PlatformDescriptor.route(from_route_id).equals(routeId)) {
                     EdgeIterator j = graph.createEdgeExplorer().setBaseNode(i.getAdjNode());
                     while (j.next()) {
-                        GtfsStorage.EdgeType edgeType2 = encoder.getEdgeType(j.getFlags());
-                        if (edgeType2 == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
+                        if (encoder.getEdgeType(j.getFlags()) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
                             int arrivalTime = (int) encoder.getTime(j.getFlags());
-                            SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = toStopTimelineNode.tailSet(new Fun.Tuple2<>(arrivalTime + minimumTransferTime, -1));
+                            SortedMap<Integer, Integer> tailSet = toStopTimelineNode.tailMap(arrivalTime + minimumTransferTime);
                             if (!tailSet.isEmpty()) {
-                                Fun.Tuple2<Integer, Integer> e = tailSet.first();
-                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), e.b, 0.0, false);
-                                setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), e.a - arrivalTime));
+                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), tailSet.get(tailSet.firstKey()));
+                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
+                                edge.setFlags(encoder.setTime(edge.getFlags(), tailSet.firstKey() - arrivalTime));
                             }
                         }
                     }
@@ -699,26 +617,27 @@ private void insertInboundTransfers(String fromStopId, String from_route_id, int
         }
     }
 
-    private void insertOutboundTransfers(String toStopId, String toRouteId, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> fromStopTimelineNodes) {
+    private void insertOutboundTransfers(String toStopId, String toRouteId, int minimumTransferTime, NavigableMap<Integer, Integer> fromStopTimelineNodes) {
         int stationNode = gtfsStorage.getStationNodes().get(toStopId);
         EdgeIterator i = graph.getBaseGraph().createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
             GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
             if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
-                String routeId = gtfsStorage.getRoutes().get(i.getEdge());
-                if (toRouteId == null || toRouteId.equals(routeId)) {
-                    fromStopTimelineNodes.forEach(e -> {
+                GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
+                if (toRouteId == null || routeId instanceof GtfsStorageI.RouteTypePlatform || GtfsStorageI.PlatformDescriptor.route(toRouteId).equals(routeId)) {
+                    fromStopTimelineNodes.forEach((time, e) -> {
                         EdgeIterator j = graph.getBaseGraph().createEdgeExplorer().setBaseNode(i.getAdjNode());
                         while (j.next()) {
                             GtfsStorage.EdgeType edgeType2 = encoder.getEdgeType(j.getFlags());
                             if (edgeType2 == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
                                 int departureTime = (int) encoder.getTime(j.getFlags());
-                                if (departureTime < e.a + minimumTransferTime) {
+                                if (departureTime < time + minimumTransferTime) {
                                     continue;
                                 }
-                                EdgeIteratorState edge = graph.edge(e.b, j.getAdjNode(), 0.0, false);
-                                setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), departureTime - e.a));
+                                EdgeIteratorState edge = graph.edge(e, j.getAdjNode());
+                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
+                                edge.setFlags(encoder.setTime(edge.getFlags(), departureTime - time));
                                 break;
                             }
                         }
@@ -733,7 +652,8 @@ private String getRouteName(GTFSFeed feed, Trip trip) {
         return (route.route_long_name != null ? route.route_long_name : route.route_short_name) + " " + trip.trip_headsign;
     }
 
-    private void setEdgeType(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
+    private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
+        edge.setDistance(0.0);
         edge.setFlags(encoder.setEdgeType(edge.getFlags(), edgeType));
     }
 
@@ -751,4 +671,20 @@ private BitSet getValidOn(BitSet validOnDay, int dayShift) {
         }
     }
 
+    private int routeType(GtfsStorageI.PlatformDescriptor platformDescriptor) {
+        if (platformDescriptor instanceof GtfsStorageI.RouteTypePlatform) {
+            return ((GtfsStorageI.RouteTypePlatform) platformDescriptor).route_type;
+        } else {
+            return feed.routes.get(((GtfsStorageI.RoutePlatform) platformDescriptor).route_id).route_type;
+        }
+    }
+
+    private String routeIdOrNull(GtfsStorageI.PlatformDescriptor platformDescriptor) {
+        if (platformDescriptor instanceof GtfsStorageI.RouteTypePlatform) {
+            return null;
+        } else {
+            return ((GtfsStorageI.RoutePlatform) platformDescriptor).route_id;
+        }
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 8e94eaf6e3..cfbfcbe936 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -96,7 +96,7 @@ public int hashCode() {
 	private Map<Integer, byte[]> tripDescriptors;
 	private Map<Integer, Integer> stopSequences;
 
-	private Map<Integer, String> routes;
+	private Map<Integer, PlatformDescriptor> routes;
 
 	private Map<String, Fare> fares;
 	private Map<String, int[]> boardEdgesForTrip;
@@ -104,7 +104,7 @@ public int hashCode() {
 
 	private Map<String, Integer> stationNodes;
 
-	enum EdgeType {
+	public enum EdgeType {
 		HIGHWAY, ENTER_TIME_EXPANDED_NETWORK, LEAVE_TIME_EXPANDED_NETWORK, ENTER_PT, EXIT_PT, HOP, DWELL, BOARD, ALIGHT, OVERNIGHT, TRANSFER, WAIT, WAIT_ARRIVAL
     }
 
@@ -277,7 +277,7 @@ public long getCapacity() {
 	}
 
     @Override
-    public Map<Integer, String> getRoutes() {
+    public Map<Integer, PlatformDescriptor> getRoutes() {
         return routes;
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
index 3b03cb553c..5d8b0fb8ed 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
@@ -20,15 +20,69 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Fare;
+import com.conveyal.gtfs.model.Route;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.storage.StorableProperties;
 
+import java.io.Serializable;
 import java.util.Map;
+import java.util.Objects;
 
 // Used to mock GtfsStorage for GtfsReader, to reuse it for realtime updates.
 // GtfsReader basically emits things to be added as a stream of events.
 // TODO: Make that explicit
 public interface GtfsStorageI {
+
+    public abstract class PlatformDescriptor implements Serializable {
+
+        public static PlatformDescriptor route(String route_id) {
+            RoutePlatform routePlatform = new RoutePlatform();
+            routePlatform.route_id = route_id;
+            return routePlatform;
+        }
+
+        public static RouteTypePlatform routeType(int route_type) {
+            RouteTypePlatform routeTypePlatform = new RouteTypePlatform();
+            routeTypePlatform.route_type = route_type;
+            return routeTypePlatform;
+        }
+
+    }
+
+    class RoutePlatform extends PlatformDescriptor {
+        String route_id;
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            RoutePlatform that = (RoutePlatform) o;
+            return Objects.equals(route_id, that.route_id);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(route_id);
+        }
+    }
+
+    class RouteTypePlatform extends PlatformDescriptor {
+        int route_type;
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            RouteTypePlatform that = (RouteTypePlatform) o;
+            return route_type == that.route_type;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(route_type);
+        }
+    }
+
     Map<String, Fare> getFares();
 
     Map<GtfsStorage.Validity, Integer> getOperatingDayPatterns();
@@ -49,5 +103,5 @@
 
     Map<String, Integer> getStationNodes();
 
-    Map<Integer, String> getRoutes();
+    Map<Integer, PlatformDescriptor> getRoutes();
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 1d1bdfc816..e5a124ca7d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -23,7 +23,7 @@
 import java.time.Instant;
 import java.util.Iterator;
 
-class Label {
+public class Label {
 
     static class Transition {
         final Label label;
@@ -62,10 +62,10 @@ public String toString() {
         }
     }
 
-    final long currentTime;
+    public final long currentTime;
 
     final int edge;
-    final int adjNode;
+    public final int adjNode;
 
     final int nTransfers;
     final int nWalkDistanceConstraintViolations;
@@ -117,7 +117,14 @@ public Transition next() {
                             return new Transition(label, null);
                         } else {
                             EdgeIteratorState edgeIteratorState = label.parent == null ? null :
-                                    graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
+                                    graph.getEdgeIteratorState(label.edge, reverseEdgeFlags ? label.adjNode : label.parent.adjNode).detach(false);
+                            if (reverseEdgeFlags && edgeIteratorState != null && (edgeIteratorState.getBaseNode() != label.parent.adjNode || edgeIteratorState.getAdjNode() != label.adjNode)) {
+                                throw new IllegalStateException();
+                            }
+                            if (!reverseEdgeFlags && edgeIteratorState != null && (edgeIteratorState.getAdjNode() != label.parent.adjNode || edgeIteratorState.getBaseNode() != label.adjNode)) {
+                                throw new IllegalStateException();
+                            }
+
                             Transition transition;
                             if (reverseEdgeFlags) {
                                 transition = new Transition(label, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index b64bc94839..653fa1cf31 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -17,20 +17,14 @@
  */
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.Multimap;
-import com.graphhopper.routing.weighting.Weighting;
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.PriorityQueue;
-import java.util.Spliterators;
+import java.util.*;
 import java.util.function.Consumer;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
@@ -43,67 +37,107 @@
  * @author Peter Karich
  * @author Wesam Herbawi
  */
-class MultiCriteriaLabelSetting {
+public class MultiCriteriaLabelSetting {
+
+    public interface SPTVisitor {
+        void visit(Label label);
+    }
 
     private final Comparator<Label> queueComparator;
+    private final List<Label> targetLabels;
     private long startTime;
+    private int blockedRouteTypes;
     private final PtFlagEncoder flagEncoder;
-    private final PtTravelTimeWeighting weighting;
-    private final Multimap<Integer, Label> fromMap;
+    private final IntObjectMap<List<Label>> fromMap;
     private final PriorityQueue<Label> fromHeap;
     private final int maxVisitedNodes;
     private final boolean reverse;
     private final double maxWalkDistancePerLeg;
-    private final double maxTransferDistancePerLeg;
+    private final boolean ptOnly;
     private final boolean mindTransfers;
     private final boolean profileQuery;
     private int visitedNodes;
     private final GraphExplorer explorer;
+    private double betaTransfers;
+    private double betaWalkTime = 1.0;
 
-    MultiCriteriaLabelSetting(GraphExplorer explorer, Weighting weighting, boolean reverse, double maxWalkDistancePerLeg, double maxTransferDistancePerLeg, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes) {
-        this.weighting = (PtTravelTimeWeighting) weighting;
-        this.flagEncoder = (PtFlagEncoder) weighting.getFlagEncoder();
+    public MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, boolean ptOnly, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes, List<Label> solutions) {
+        this.flagEncoder = flagEncoder;
         this.maxVisitedNodes = maxVisitedNodes;
         this.explorer = explorer;
         this.reverse = reverse;
         this.maxWalkDistancePerLeg = maxWalkDistancePerLeg;
-        this.maxTransferDistancePerLeg = maxTransferDistancePerLeg;
+        this.ptOnly = ptOnly;
         this.mindTransfers = mindTransfers;
         this.profileQuery = profileQuery;
+        this.targetLabels = solutions;
 
-        queueComparator = Comparator.<Label>comparingLong(l2 -> l2.impossible ? 1 : 0)
-                .thenComparing(Comparator.comparingLong(l2 -> currentTimeCriterion(l2)))
-                .thenComparing(Comparator.comparingLong(l1 -> l1.nTransfers))
-                .thenComparing(Comparator.comparingLong(l1 -> l1.nWalkDistanceConstraintViolations))
-                .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0));
+        queueComparator = Comparator
+                .comparingLong(this::weight)
+                .thenComparingLong(l -> l.nTransfers)
+                .thenComparingLong(l -> l.walkTime)
+                .thenComparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0)
+                .thenComparingLong(l -> l.impossible ? 1 : 0);
         fromHeap = new PriorityQueue<>(queueComparator);
-        fromMap = ArrayListMultimap.create();
+        fromMap = new IntObjectHashMap<>();
     }
 
-    Stream<Label> calcLabels(int from, int to, Instant startTime) {
+    Stream<Label> calcLabels(int from, int to, Instant startTime, int blockedRouteTypes) {
         this.startTime = startTime.toEpochMilli();
+        this.blockedRouteTypes = blockedRouteTypes;
         return StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false)
                 .limit(maxVisitedNodes)
                 .peek(label -> visitedNodes++);
     }
 
+    public void calcLabels(int from, int to, Instant startTime, int blockedRouteTypes, SPTVisitor visitor, Predicate<Label> predicate) {
+        this.startTime = startTime.toEpochMilli();
+        this.blockedRouteTypes = blockedRouteTypes;
+        Iterator<Label> iterator = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false).iterator();
+        Label l;
+        while (iterator.hasNext() && predicate.test(l = iterator.next())) {
+            visitor.visit(l);
+        }
+    }
+
+
+    public void calcLabelsAndNeighbors(int from, int to, Instant startTime, int blockedRouteTypes, SPTVisitor visitor, Predicate<Label> predicate) {
+        this.startTime = startTime.toEpochMilli();
+        this.blockedRouteTypes = blockedRouteTypes;
+        Iterator<Label> iterator = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false).iterator();
+        Label l;
+        while (iterator.hasNext() && predicate.test(l = iterator.next())) {
+            visitor.visit(l);
+        }
+        for (Label label : fromHeap) {
+            visitor.visit(label);
+        }
+    }
+
+    // experimental
+    void setBetaTransfers(double betaTransfers) {
+        this.betaTransfers = betaTransfers;
+    }
+
+    // experimental
+    void setBetaWalkTime(double betaWalkTime) {
+        this.betaWalkTime = betaWalkTime;
+    }
+
     private class MultiCriteriaLabelSettingSpliterator extends Spliterators.AbstractSpliterator<Label> {
 
         private final int from;
         private final int to;
-        private final Collection<Label> targetLabels;
 
         MultiCriteriaLabelSettingSpliterator(int from, int to) {
             super(0, 0);
             this.from = from;
             this.to = to;
-            targetLabels = new ArrayList<>();
             Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, 0,false,null);
-            fromMap.put(from, label);
+            ArrayList<Label> labels = new ArrayList<>(1);
+            labels.add(label);
+            fromMap.put(from, labels);
             fromHeap.add(label);
-            if (to == from) {
-                targetLabels.add(label);
-            }
         }
 
         @Override
@@ -115,16 +149,16 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                 action.accept(label);
                 explorer.exploreEdgesAround(label).forEach(edge -> {
                     GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
-                    if (edgeType == GtfsStorage.EdgeType.HIGHWAY && maxTransferDistancePerLeg <= 0.0) return;
-                    if (edgeType == GtfsStorage.EdgeType.ENTER_PT && ((reverse?edge.getAdjNode():edge.getBaseNode()) != (reverse?to:from)) && maxTransferDistancePerLeg <= 0.0) return;
-                    if (edgeType == GtfsStorage.EdgeType.EXIT_PT && ((reverse?edge.getBaseNode():edge.getAdjNode()) != (reverse?from:to)) && maxTransferDistancePerLeg <= 0.0) return;
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_PT && reverse && ptOnly) return;
+                    if (edgeType == GtfsStorage.EdgeType.EXIT_PT && !reverse && ptOnly) return;
+                    if ((edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT) && (blockedRouteTypes & (1 << flagEncoder.getValidityId(edge.getFlags()))) != 0) return;
                     long nextTime;
                     if (reverse) {
                         nextTime = label.currentTime - explorer.calcTravelTimeMillis(edge, label.currentTime);
                     } else {
                         nextTime = label.currentTime + explorer.calcTravelTimeMillis(edge, label.currentTime);
                     }
-                    int nTransfers = label.nTransfers + weighting.calcNTransfers(edge);
+                    int nTransfers = label.nTransfers + explorer.calcNTransfers(edge);
                     Long firstPtDepartureTime = label.departureTime;
                     if (!reverse && (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK || edgeType == GtfsStorage.EdgeType.WAIT)) {
                         if (label.nTransfers == 0) {
@@ -135,12 +169,16 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                             firstPtDepartureTime = nextTime - label.walkTime;
                         }
                     }
-                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + weighting.getWalkDistance(edge));
-                    boolean isTryingToReEnterPtAfterTransferWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
-                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? nextTime - label.currentTime : 0);
+                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + edge.getDistance());
+                    boolean isTryingToReEnterPtAfterWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0;
+                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? ((reverse ? -1 : 1) * (nextTime - label.currentTime)) : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
-                            isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
-                    Collection<Label> sptEntries = fromMap.get(edge.getAdjNode());
+                            isTryingToReEnterPtAfterWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
+                    List<Label> sptEntries = fromMap.get(edge.getAdjNode());
+                    if (sptEntries == null) {
+                        sptEntries = new ArrayList<>(1);
+                        fromMap.put(edge.getAdjNode(), sptEntries);
+                    }
                     boolean impossible = label.impossible
                             || explorer.isBlocked(edge)
                             || (!reverse) && edgeType == GtfsStorage.EdgeType.BOARD && label.residualDelay > 0
@@ -165,36 +203,32 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     }
                     if (!reverse && edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && residualDelay > 0) {
                         Label newImpossibleLabelForDelayedTrip = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, true, label);
-                        insertIfNotDominated(edge, sptEntries, newImpossibleLabelForDelayedTrip);
+                        insertIfNotDominated(sptEntries, newImpossibleLabelForDelayedTrip);
                         nextTime += residualDelay;
                         residualDelay = 0;
                         Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
-                        insertIfNotDominated(edge, sptEntries, newLabel);
+                        insertIfNotDominated(sptEntries, newLabel);
                     } else {
                         Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
-                        insertIfNotDominated(edge, sptEntries, newLabel);
+                        insertIfNotDominated(sptEntries, newLabel);
                     }
                 });
                 return true;
             }
         }
 
-        private void insertIfNotDominated(EdgeIteratorState edge, Collection<Label> sptEntries, Label nEdge) {
-            if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
-                removeDominated(nEdge, sptEntries);
-                if (to == edge.getAdjNode()) {
-                    removeDominated(nEdge, targetLabels);
+        private void insertIfNotDominated(Collection<Label> sptEntries, Label label) {
+            if (isNotDominatedByAnyOf(label, sptEntries)) {
+                if (isNotDominatedByAnyOf(label, targetLabels)) {
+                    removeDominated(label, sptEntries);
+                    sptEntries.add(label);
+                    fromHeap.add(label);
                 }
-                fromMap.put(edge.getAdjNode(), nEdge);
-                if (to == edge.getAdjNode()) {
-                    targetLabels.add(nEdge);
-                }
-                fromHeap.add(nEdge);
             }
         }
     }
 
-    private boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
+    boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
         if (me.nWalkDistanceConstraintViolations > 0) {
             return false;
         }
@@ -207,7 +241,7 @@ private boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
     }
 
 
-    private void removeDominated(Label me, Collection<Label> sptEntries) {
+    void removeDominated(Label me, Collection<Label> sptEntries) {
         for (Iterator<Label> iterator = sptEntries.iterator(); iterator.hasNext();) {
             Label sptEntry = iterator.next();
             if (dominates(me, sptEntry)) {
@@ -218,19 +252,17 @@ private void removeDominated(Label me, Collection<Label> sptEntries) {
     }
 
     private boolean dominates(Label me, Label they) {
+        if (weight(me) > weight(they))
+            return false;
+
         if (profileQuery) {
             if (me.departureTime != null && they.departureTime != null) {
-                if (currentTimeCriterion(me) > currentTimeCriterion(they))
-                    return false;
                 if (departureTimeCriterion(me) > departureTimeCriterion(they))
                     return false;
             } else {
                 if (travelTimeCriterion(me) > travelTimeCriterion(they))
                     return false;
             }
-        } else {
-            if (currentTimeCriterion(me) > currentTimeCriterion(they))
-                return false;
         }
 
         if (mindTransfers && me.nTransfers > they.nTransfers)
@@ -240,19 +272,16 @@ private boolean dominates(Label me, Label they) {
         if (me.impossible && !they.impossible)
             return false;
 
+        if (weight(me) < weight(they))
+            return true;
         if (profileQuery) {
             if (me.departureTime != null && they.departureTime != null) {
-                if (currentTimeCriterion(me) < currentTimeCriterion(they))
-                    return true;
                 if (departureTimeCriterion(me) < departureTimeCriterion(they))
                     return true;
             } else {
                 if (travelTimeCriterion(me) < travelTimeCriterion(they))
                     return true;
             }
-        } else {
-            if (currentTimeCriterion(me) < currentTimeCriterion(they))
-                return true;
         }
         if (mindTransfers && me.nTransfers  < they.nTransfers)
             return true;
@@ -266,8 +295,8 @@ private Long departureTimeCriterion(Label label) {
         return label.departureTime == null ? null : reverse ? label.departureTime : -label.departureTime;
     }
 
-    private long currentTimeCriterion(Label label) {
-        return reverse ? -label.currentTime : label.currentTime;
+    long weight(Label label) {
+        return (reverse ? -1 : 1) * (label.currentTime - startTime) + (long) (label.nTransfers * betaTransfers) + (long) (label.walkTime * (betaWalkTime - 1.0));
     }
 
     private long travelTimeCriterion(Label label) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index 34daa5f3e6..f57d5b6877 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -23,11 +23,9 @@
 import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.EncodedDoubleValue;
 import com.graphhopper.routing.util.EncodedValue;
-import com.graphhopper.routing.util.FootFlagEncoder;
 
 public class PtFlagEncoder extends AbstractFlagEncoder {
 
-	private final FootFlagEncoder footFlagEncoder;
 	private EncodedValue time;
 	private EncodedValue transfers;
 	private EncodedValue validityId;
@@ -35,14 +33,6 @@
 
 	public PtFlagEncoder() {
 		super(0, 1, 0);
-
-		// I use the foot flag encoder only as a delegate to filter by OSM tags,
-		// not to encode flags.
-		footFlagEncoder = new FootFlagEncoder();
-		// Still, I have to do this. Otherwise 'acceptWay' returns 0 even though
-		// it wants to accept. Basically, I have to tell it what 'true' means.
-		footFlagEncoder.defineWayBits(1, 0);
-		footFlagEncoder.defineRelationBits(1, 0);
 	}
 
 	@Override
@@ -54,31 +44,31 @@ public int defineWayBits(int index, int shift) {
 		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, 0, 0);
 		shift += speedEncoder.getBits();
 
-		time = new EncodedValue("time", shift, 32, 1.0, 0, Integer.MAX_VALUE);
+		time = new EncodedValue("time", shift, 17, 1.0, 0, 24*60*60);
 		shift += time.getBits();
 		transfers = new EncodedValue("transfers", shift, 1, 1.0, 0, 1);
 		shift += transfers.getBits();
 		validityId = new EncodedValue("validityId", shift, 20, 1.0, 0, 1048575);
 		shift += validityId.getBits();
 		GtfsStorage.EdgeType[] edgeTypes = GtfsStorage.EdgeType.values();
-		type = new EncodedValue("type", shift, 6, 1.0, GtfsStorage.EdgeType.HIGHWAY.ordinal(), edgeTypes[edgeTypes.length-1].ordinal());
+		type = new EncodedValue("type", shift, 4, 1.0, GtfsStorage.EdgeType.HIGHWAY.ordinal(), edgeTypes[edgeTypes.length-1].ordinal());
 		shift += type.getBits();
 		return shift;
 	}
 
 	@Override
 	public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
-		return footFlagEncoder.handleRelationTags(relation, oldRelationFlags);
+		return oldRelationFlags;
 	}
 
 	@Override
 	public long acceptWay(ReaderWay way) {
-		return footFlagEncoder.acceptWay(way);
+		return 0;
 	}
 
 	@Override
 	public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-		return footFlagEncoder.handleWayTags(way, allowed, relationFlags);
+		return 0;
 	}
 
 	long getTime(long flags) {
@@ -105,7 +95,7 @@ long setValidityId(long flags, int validityId) {
 		return this.validityId.setValue(flags, validityId);
 	}
 
-	GtfsStorage.EdgeType getEdgeType(long flags) {
+	public GtfsStorage.EdgeType getEdgeType(long flags) {
 		return GtfsStorage.EdgeType.values()[(int) type.getValue(flags)];
 	}
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
deleted file mode 100644
index b119fc953a..0000000000
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtTravelTimeWeighting.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.graphhopper.reader.gtfs;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.util.EdgeIteratorState;
-
-import java.time.Instant;
-
-class PtTravelTimeWeighting extends AbstractWeighting {
-
-    private final boolean reverse;
-    private final double walkSpeedKmH;
-    private final int transferFactor;
-
-    PtTravelTimeWeighting(FlagEncoder encoder, double walkSpeedKmH) {
-		this(encoder, false, walkSpeedKmH, 1);
-    }
-
-    private PtTravelTimeWeighting(FlagEncoder encoder, boolean reverse, double walkSpeedKmH, int transferFactor) {
-        super(encoder);
-        this.reverse = reverse;
-        this.walkSpeedKmH = walkSpeedKmH;
-        this.transferFactor = transferFactor;
-    }
-
-    PtTravelTimeWeighting reverse() {
-        return new PtTravelTimeWeighting(flagEncoder, !reverse, walkSpeedKmH, transferFactor);
-    }
-
-    @Override
-	public double getMinWeight(double distance) {
-		return 0.0;
-	}
-
-	@Override
-	public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-		throw new RuntimeException("Not supported.");
-	}
-
-    @Override
-    public long calcMillis(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-        GtfsStorage.EdgeType edgeType = ((PtFlagEncoder) getFlagEncoder()).getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return (long) (getWalkDistance(edge) * 3.6 / walkSpeedKmH) * 1000;
-            case ENTER_TIME_EXPANDED_NETWORK:
-            case LEAVE_TIME_EXPANDED_NETWORK:
-                return 0;
-            default:
-                return ((PtFlagEncoder) getFlagEncoder()).getTime(edge.getFlags());
-        }
-    }
-
-	int calcNTransfers(EdgeIteratorState edge) {
-        return transferFactor * ((PtFlagEncoder) getFlagEncoder()).getTransfers(edge.getFlags());
-	}
-
-    double getWalkDistance(EdgeIteratorState edge) {
-        GtfsStorage.EdgeType edgeType = ((PtFlagEncoder) getFlagEncoder()).getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return edge.getDistance();
-            case ENTER_PT:
-            case EXIT_PT:
-                return 10.0;
-            default:
-                return 0.0;
-        }
-    }
-
-    @Override
-	public String getName() {
-		return "pttraveltime";
-	}
-
-}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 76dba608b7..29f8af24be 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -32,6 +32,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
@@ -60,6 +61,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
 
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA;
@@ -105,14 +107,13 @@ public static RealtimeFeed empty(GtfsStorage staticGtfs) {
         return new RealtimeFeed(staticGtfs, Collections.emptyMap(), new IntHashSet(), new IntLongHashMap(), new IntLongHashMap(), Collections.emptyList(), Collections.emptyMap(), Collections.emptyMap(), staticGtfs.getOperatingDayPatterns(), staticGtfs.getWritableTimeZones());
     }
 
-    public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, Map<String, GtfsRealtime.FeedMessage> feedMessages) {
+    public static RealtimeFeed fromProtobuf(GraphHopperStorage graphHopperStorage, GtfsStorage staticGtfs, PtFlagEncoder encoder, Map<String, GtfsRealtime.FeedMessage> feedMessages) {
         final IntHashSet blockedEdges = new IntHashSet();
         final IntLongHashMap delaysForBoardEdges = new IntLongHashMap();
         final IntLongHashMap delaysForAlightEdges = new IntLongHashMap();
         final LinkedList<VirtualEdgeIteratorState> additionalEdges = new LinkedList<>();
         final Graph overlayGraph = new Graph() {
-            int nNodes = 0;
-            int firstEdge = graph.getAllEdges().length();
+            int firstEdge = graphHopperStorage.getAllEdges().length();
             final NodeAccess nodeAccess = new NodeAccess() {
                 IntIntHashMap additionalNodeFields = new IntIntHashMap();
 
@@ -183,12 +184,15 @@ public double getEle(int nodeId) {
             };
             @Override
             public Graph getBaseGraph() {
-                return graph;
+                return graphHopperStorage;
             }
 
             @Override
             public int getNodes() {
-                return graph.getNodes() + nNodes;
+                return IntStream.concat(
+                        IntStream.of(graphHopperStorage.getNodes()-1),
+                        additionalEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
+                        .max().getAsInt()+1;
             }
 
             @Override
@@ -203,23 +207,22 @@ public BBox getBounds() {
 
             @Override
             public EdgeIteratorState edge(int a, int b) {
-                return null;
-            }
-
-            @Override
-            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
                 int edge = firstEdge++;
                 final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(-1,
-                        edge, a, b, distance,0, "", new PointList());
+                        edge, a, b, 0.0, 0, "", new PointList());
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(-1,
-                        edge, b, a, distance,0, "", new PointList());
-
+                        edge, b, a, 0.0, 0, "", new PointList());
                 newEdge.setReverseEdge(reverseNewEdge);
                 reverseNewEdge.setReverseEdge(newEdge);
                 additionalEdges.push(newEdge);
                 return newEdge;
             }
 
+            @Override
+            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+                return null;
+            }
+
             @Override
             public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
                 return null;
@@ -237,7 +240,7 @@ public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
 
             @Override
             public EdgeExplorer createEdgeExplorer() {
-                return graph.createEdgeExplorer();
+                return graphHopperStorage.createEdgeExplorer();
             }
 
             @Override
@@ -316,7 +319,7 @@ public GraphExtension getExtension() {
                 }
 
                 @Override
-                public Map<Integer, String> getRoutes() {
+                public Map<Integer, PlatformDescriptor> getRoutes() {
                     return staticGtfs.getRoutes();
                 }
             };
@@ -324,7 +327,7 @@ public GraphExtension getExtension() {
             Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
             LocalDate dateToChange = timestamp.atZone(timezone).toLocalDate(); //FIXME
             BitSet validOnDay = new BitSet();
-            LocalDate startDate = feed.calculateStats().getStartDate();
+            LocalDate startDate = feed.getStartDate();
             validOnDay.set((int) DAYS.between(startDate, dateToChange));
             feedMessage.getEntityList().stream()
                     .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -359,7 +362,7 @@ public GraphExtension getExtension() {
                             int departureDelay = stopTime.departure_time - originalStopTime.departure_time;
                             if (departureDelay > 0) {
                                 int boardEdge = boardEdges[stopTime.stop_sequence];
-                                int departureNode = graph.getEdgeIteratorState(boardEdge, Integer.MIN_VALUE).getAdjNode();
+                                int departureNode = graphHopperStorage.getEdgeIteratorState(boardEdge, Integer.MIN_VALUE).getAdjNode();
                                 int delayedBoardEdge = gtfsReader.addDelayedBoardEdge(timezone, tripUpdate.getTrip(), stopTime.stop_sequence, stopTime.departure_time + timeOffset, departureNode, validOnDay);
                                 delaysForBoardEdges.put(delayedBoardEdge, departureDelay * 1000);
                             }
@@ -389,7 +392,7 @@ public GraphExtension getExtension() {
                         GtfsReader.TripWithStopTimes tripWithStopTimes = new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                         gtfsReader.addTrip(timezone, 0, new ArrayList<>(), tripWithStopTimes, tripUpdate.getTrip(), false);
                     });
-            gtfsReader.wireUpAdditionalDepartures(timezone);
+            gtfsReader.wireUpAdditionalDeparturesAndArrivals(timezone);
         });
 
         return new RealtimeFeed(staticGtfs, feedMessages, blockedEdges, delaysForBoardEdges, delaysForAlightEdges, additionalEdges, tripDescriptors, stopSequences, operatingDayPatterns, writableTimeZones);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
index b819541b94..2de446bad3 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
@@ -108,4 +108,11 @@ private Transfer findMostSpecificRule(List<Transfer> transfers, String fromRoute
         return transfersBySpecificity.get(0);
     }
 
+    public boolean hasNoRouteSpecificDepartureTransferRules(String stop_id) {
+        return transfersToStop.getOrDefault(stop_id, Collections.emptyList()).stream().allMatch(transfer -> transfer.to_route_id == null);
+    }
+
+    public boolean hasNoRouteSpecificArrivalTransferRules(String stop_id) {
+        return transfersFromStop.getOrDefault(stop_id, Collections.emptyList()).stream().allMatch(transfer -> transfer.from_route_id == null);
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 9def351bc0..527c8ff864 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -29,9 +29,9 @@
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.*;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -59,7 +59,7 @@
         this.realtimeFeed = realtimeFeed;
     }
 
-    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution, PointList waypoints) {
         final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         return createPathWrapper(tr, waypoints, legs);
     }
@@ -68,12 +68,12 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
             legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).getDepartureTime().getTime() - (accessLeg.getArrivalTime().getTime() - accessLeg.getDepartureTime().getTime())),
-                    accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).getDepartureTime()));
+                    accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).getDepartureTime()));
         }
         if (legs.size() > 1 && legs.get(legs.size() - 1) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg egressLeg = (Trip.WalkLeg) legs.get(legs.size() - 1);
             legs.set(legs.size() - 1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size() - 2).getArrivalTime(),
-                    egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions,
+                    egressLeg.geometry, egressLeg.distance, egressLeg.instructions,
                     new Date(legs.get(legs.size() - 2).getArrivalTime().getTime() + (egressLeg.getArrivalTime().getTime() - egressLeg.getDepartureTime().getTime()))));
         }
 
@@ -119,7 +119,18 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return path;
     }
 
-    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution) {
+    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
+        List<Label.Transition> transitions = getTransitions(arriveBy, encoder, queryGraph, solution);
+        return getTrip(tr, queryGraph, weighting, transitions);
+    }
+
+    List<Trip.Leg> getTrip(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<Label.Transition> transitions) {
+        final List<List<Label.Transition>> partitions = getPartitions(transitions);
+        final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
+        return legs;
+    }
+
+    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, GraphExplorer queryGraph, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -129,11 +140,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
                     .forEach(transitions::add);
             Collections.reverse(transitions);
         }
-
-
-        final List<List<Label.Transition>> partitions = getPartitions(transitions);
-        final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
-        return legs;
+        return transitions;
     }
 
     private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
@@ -154,7 +161,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -360,7 +367,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
                             feedIdWithTimezone.feedId, partition.get(0).edge.nTransfers == 0,
                             tripDescriptor.getTripId(),
                             tripDescriptor.getRouteId(),
-                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()).get(0).getName(),
                             stops,
                             partition.stream().mapToDouble(t -> t.edge.distance).sum(),
                             path.get(i - 1).label.currentTime - boardTime,
@@ -375,6 +382,9 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
                     weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i = 1; i < path.size(); i++) {
+                if (path.get(i).edge.edgeType != GtfsStorage.EdgeType.HIGHWAY) {
+                    throw new IllegalStateException("Got a transit edge where I think I must be on a road.");
+                }
                 EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
                 instructionsFromEdges.next(edge, i, prevEdgeId);
                 prevEdgeId = edge.getEdge();
@@ -385,7 +395,6 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
             return Collections.singletonList(new Trip.WalkLeg(
                     "Walk",
                     Date.from(departureTime),
-                    edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
                     lineStringFromEdges(path),
                     edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
                     instructions,
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
index 3473ed84ae..cbc83b675a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -87,9 +87,9 @@ public AllEdgesIterator getAllEdges() {
             @Override
             public int length() {
                 return IntStream.concat(
-                        IntStream.of(baseGraph.getAllEdges().length()),
+                        IntStream.of(baseGraph.getAllEdges().length() - 1),
                         extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
-                        .max().getAsInt();
+                        .max().getAsInt()+1;
             }
 
             @Override
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index 379a762b44..686e1c46b2 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -22,27 +22,21 @@
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
-import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
-import java.math.BigDecimal;
 import java.time.LocalDateTime;
-import java.time.LocalTime;
 import java.time.ZoneId;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -61,11 +55,11 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 537633499c..3650581939 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -21,7 +21,9 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -29,7 +31,7 @@
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
-import org.junit.Assert;
+import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -47,6 +49,7 @@
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class GraphHopperGtfsIT {
 
@@ -61,11 +64,14 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(carFlagEncoder, footFlagEncoder, ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
@@ -119,6 +125,7 @@ public void testRoute1GoesAt744() {
         );
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,44).atZone(zoneId).toInstant());
         ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 1); // Blocking trams shouldn't matter, this is a bus.
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -126,7 +133,21 @@ public void testRoute1GoesAt744() {
         assertEquals("Expected travel time == scheduled arrival time", time(0, 5), response.getBest().getTime(), 0.1);
     }
 
+    @Test
+    public void testNoSolutionIfIDontLikeBusses() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 8);
+
+        GHResponse response = graphHopper.route(ghRequest);
 
+        assertTrue("When I block busses, there is no solution", response.getAll().isEmpty());
+    }
 
     @Test
     public void testRoute1ArriveBy() {
@@ -193,6 +214,31 @@ public void testRoute1ProfileEarliestArrival() {
         assertEquals(expectedDepartureTimes, actualDepartureTimes);
     }
 
+    @Test
+    public void testRoute1ProfileOvernight() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,23,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+
+        GHResponse response = graphHopper.route(ghRequest);
+        List<LocalTime> actualDepartureTimes = response.getAll().stream()
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
+                .collect(Collectors.toList());
+        List<LocalTime> expectedDepartureTimes = Stream.of(
+                "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
+                "10:04", "10:14", "10:24", "10:34", "10:44", "11:14", "11:44", "12:14", "12:44")
+                .map(LocalTime::parse)
+                .collect(Collectors.toList());
+        assertEquals(expectedDepartureTimes, actualDepartureTimes);
+    }
+
     @Test
     public void testRoute1ProfileLatestDeparture() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -400,15 +446,6 @@ public void testTransferRules() {
         );
         request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
 
-        response = graphHopper.route(request);
-        assertEquals("Ignoring transfer rules (free walking): Will be there at 8:10.", time(0, 40), response.getBest().getTime());
-
-        request = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO2_LAT, TO2_LON
-        );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
-
         response = graphHopper.route(request);
         assertEquals("Will still be there at 8:10 because there is a route-specific exception for this route.", time(0, 40), response.getBest().getTime());
 
@@ -446,7 +483,7 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse route = graphHopper.route(ghRequest);
-        Assert.assertTrue(route.getAll().isEmpty());
+        assertTrue(route.getAll().isEmpty());
     }
 
     @Test
@@ -469,6 +506,43 @@ public void testTransferByArrival() {
         assertEquals("Arrive at 7:20", LocalDateTime.parse("2007-01-01T07:20:00").atZone(zoneId).toInstant(), lastStop.plannedArrivalTime.toInstant());
     }
 
+    @Test
+    public void testCustomObjectiveFunction() {
+        GHRequest ghRequest = new GHRequest(
+                36.868446,-116.784582,  // BEATTY_AIRPORT stop
+                36.425288,-117.133162       // FUR_CREEK_RES stop
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,14,0,0).atZone(zoneId).toInstant());
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper solutionWithTransfer = response.getAll().get(0);
+        PathWrapper solutionWithoutTransfer = response.getAll().get(1);
+
+        Assume.assumeTrue("First solution has one transfer",solutionWithTransfer.getNumChanges() == 1);
+        Assume.assumeTrue("Second solution has no transfers", solutionWithoutTransfer.getNumChanges() == 0);
+        Assume.assumeTrue("With transfers is faster than without", solutionWithTransfer.getTime() < solutionWithoutTransfer.getTime());
+
+        // If one transfer is worth beta_transfers milliseconds of travel time savings
+        // to me, I will be indifferent when choosing between the two routes.
+        // Wiggle it by epsilon, and I should prefer one over the other.
+        double betaTransfers = solutionWithoutTransfer.getTime() - solutionWithTransfer.getTime();
+
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        // Well, not actually ignore them, but don't do multi-criteria search
 
+        ghRequest.getHints().put("beta_transfers", betaTransfers - 10);
+        response = graphHopper.route(ghRequest);
+
+        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Prefer solution with transfers when I give the smaller beta", solutionWithTransfer.getTime(), response.getBest().getTime());
+
+        ghRequest.getHints().put("beta_transfers", betaTransfers + 10);
+
+        response = graphHopper.route(ghRequest);
+
+        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Prefer solution without transfers when I give the higher beta", solutionWithoutTransfer.getTime(), response.getBest().getTime());
+    }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index f0200d359e..d375208ebf 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -22,22 +22,26 @@
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
+import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZoneId;
 import java.util.Arrays;
 import java.util.Collections;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 public class GraphHopperMultimodalIT {
 
@@ -51,11 +55,11 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
@@ -66,6 +70,27 @@ public static void close() {
         locationIndex.close();
     }
 
+    @Test
+    public void testDepartureTimeOfAccessLegInProfileQuery() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+
+        GHResponse response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(243);
+
+        PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
+        assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:04.834"));
+        assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
+        assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:52:02.728"));
+    }
+
     @Test
     public void testDepartureTimeOfAccessLeg() {
         GHRequest ghRequest = new GHRequest(
@@ -73,14 +98,117 @@ public void testDepartureTimeOfAccessLeg() {
                 36.91260259593356,-116.76149368286134
         );
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put("beta_walk_time", 2.0); // I somewhat dislike walking
+
+        GHResponse response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(129);
+
+        PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
+        assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:04.834"));
+        assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
+        assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:52:02.728"));
+
+        PathWrapper walkSolution = response.getAll().stream().filter(p -> p.getLegs().size() == 1).findFirst().get();
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        // In principle, this would dominate the transit solution, since it's faster, but
+        // by default, walking gets a slight penalty.
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:51:10.367"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+
+        // I like walking exactly as I like riding a bus (per travel time unit)
+        // Now, the walk solution dominates, and we get no transit solution.
+        ghRequest.getHints().put("beta_walk_time",1.0);
+        response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(138);
+        assertThat(response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst()).isEmpty();
+    }
+
+    @Test
+    public void testFastWalking() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper walkSolution = response.getAll().stream().filter(p -> p.getLegs().size() == 1).findFirst().get();
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:07.031"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+    }
+
+    @Test
+    public void testFastWalkingInProfileQuery() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper walkSolution = response.getAll().get(0);
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:07.031"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+    }
+
+    @Test
+    public void testProfileQueryDoesntEndPrematurely() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        // Provoke a situation where solutions which are later dominated will be found early.
+        // If everything is right, the n-th solution should be the same, no matter if I ask for n, or for n+m solutions.
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 1); // No, I cannot walk very fast, 1 km/h. Problem?
         ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
 
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 1);
+        GHResponse response1 = graphHopper.route(ghRequest);
+        assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(142);
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 3);
+        GHResponse response3 = graphHopper.route(ghRequest);
+        assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(230);
+        assertThat(response1.getAll().get(0).getTime()).isEqualTo(response3.getAll().get(0).getTime());
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 5);
+        GHResponse response5 = graphHopper.route(ghRequest);
+        assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(334);
+        assertThat(response3.getAll().get(2).getTime()).isEqualTo(response5.getAll().get(2).getTime());
+    }
+
+    @Test
+    public void testHighDisutilityOfWalking() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.getHints().put("beta_walk_time", 20); // But I dislike walking a lot.
+
         GHResponse response = graphHopper.route(ghRequest);
 
-        assertThat(response.getAll().get(0).getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo("06:41:06");
-        assertThat(response.getAll().get(0).getLegs().get(0).getArrivalTime().toInstant())
-                .isEqualTo(response.getAll().get(0).getLegs().get(1).getDepartureTime().toInstant());
+        PathWrapper transitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get();
+        assertThat(transitSolution.getLegs().size()).isEqualTo(3);
     }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index b90a872374..9b8988f323 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -22,7 +22,9 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
@@ -30,7 +32,6 @@
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -64,17 +65,17 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new FootFlagEncoder(), ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperStorage.close();
         locationIndex.close();
         // Re-load read only
         directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
 
@@ -112,16 +113,14 @@ public void testSkipDepartureStop() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
-        assertEquals(2, response.getAll().size());
 
-        PathWrapper possibleAlternative = response.getAll().get(0);
-        assertFalse(possibleAlternative.isImpossible());
-        assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
+        PathWrapper possibleAlternative = response.getAll().stream().filter(a -> !a.isImpossible()).findFirst().get();
+        assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
         assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), possibleAlternative.getTime(), 0.1);
 
-        PathWrapper impossibleAlternative = response.getAll().get(1);
+        PathWrapper impossibleAlternative = response.getAll().stream().filter(a -> a.isImpossible()).findFirst().get();
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
     }
 
     @Test
@@ -155,13 +154,13 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
         assertEquals(2, response.getAll().size());
 
         PathWrapper best = response.getBest();
-        Trip.PtLeg bestPtLeg = (Trip.PtLeg) best.getLegs().get(1);
+        Trip.PtLeg bestPtLeg = (Trip.PtLeg) best.getLegs().get(0);
         assertEquals("It's better to wait half an hour for the next one (and ride 5 minutes).", LocalDateTime.parse("2007-01-01T07:19:00").atZone(zoneId).toInstant(), bestPtLeg.stops.get(bestPtLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("There is no predicted arrival time.", null, bestPtLeg.stops.get(bestPtLeg.stops.size()-1).predictedArrivalTime);
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.PtLeg impossiblePtLeg = (Trip.PtLeg) impossibleAlternative.getLegs().get(1);
+        Trip.PtLeg impossiblePtLeg = (Trip.PtLeg) impossibleAlternative.getLegs().get(0);
         assertEquals("The impossible alternative is my planned 5-minute-trip", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), impossiblePtLeg.stops.get(impossiblePtLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("..which is very late today", LocalDateTime.parse("2007-01-01T07:49:00").atZone(zoneId).toInstant(), impossiblePtLeg.stops.get(impossiblePtLeg.stops.size()-1).predictedArrivalTime.toInstant());
     }
@@ -231,7 +230,7 @@ public void testSkipArrivalStop() {
 
         PathWrapper impossibleAlternative = response.getAll().get(2);
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(1).arrivalCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(1).arrivalCancelled);
     }
 
     @Test
@@ -267,7 +266,7 @@ public void testSkipTransferStop() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2).departureCancelled);
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2).departureCancelled);
     }
 
     @Test
@@ -299,8 +298,8 @@ public void testExtraTrip() {
                 .setStopSequence(5)
                 .setScheduleRelationship(SKIPPED);
 
-        // Add a few more trips (but we only need the first one)
-        for (int i=0; i<3; i++){
+        // Add a few more trips (but we only need the first one; add more because there used to be a bug with something like an index overflow)
+        for (int i=0; i<100; i++){
             final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
                     .setId("2")
                     .getTripUpdateBuilder()
@@ -309,14 +308,14 @@ public void testExtraTrip() {
                     .addStopTimeUpdateBuilder()
                     .setStopSequence(1)
                     .setStopId("NADAV")
-                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45+i).atZone(zoneId).toEpochSecond()))
-                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45+i).atZone(zoneId).toEpochSecond()));
+                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).plusMinutes(i).atZone(zoneId).toEpochSecond()))
+                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).plusMinutes(i).atZone(zoneId).toEpochSecond()));
             extraTripUpdate
                     .addStopTimeUpdateBuilder()
                     .setStopSequence(2)
                     .setStopId("BEATTY_AIRPORT")
-                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15+i).atZone(zoneId).toEpochSecond()))
-                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15+i).atZone(zoneId).toEpochSecond()));
+                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).plusMinutes(i).atZone(zoneId).toEpochSecond()))
+                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).plusMinutes(i).atZone(zoneId).toEpochSecond()));
 
         }
 
@@ -405,8 +404,8 @@ public void testZeroDelay() {
         GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
-        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(responseWithRealtimeUpdate.getBest().getLegs().size()-2);
-        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(responseWithoutRealtimeUpdate.getBest().getLegs().size()-2);
+        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(0);
+        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(0);
         assertEquals("My planned arrival time is correct.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("My expected arrival time is the same.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).predictedArrivalTime.toInstant());
         assertEquals("The trip without realtime update does not have an expected arrival time.", null, responseWithoutRealtimeUpdateBest.stops.get(responseWithoutRealtimeUpdateBest.stops.size()-1).predictedArrivalTime);
@@ -480,7 +479,7 @@ public void testDelayFromBeginningWithoutTransfer() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size() - 2));
+        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(0));
         assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), ptLeg.getArrivalTime().toInstant());
         assertEquals("It is still reporting its original, scheduled time.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
     }
@@ -543,7 +542,7 @@ public void testBlockTripSkipsStop() {
         // Note that my stop (BULLFROG), which is skipped, is a switch of "block legs", so even though it looks like I (impossibly) transfer there,
         // this is not a real transfer. The bus drives through BULLFROG without stopping.
         // Very untypical example, but seems correct.
-        Trip.PtLeg ptLeg = (Trip.PtLeg) route.getBest().getLegs().get(4);
+        Trip.PtLeg ptLeg = (Trip.PtLeg) route.getBest().getLegs().get(3);
         assertEquals("I have to continue on AB1 which skips my stop, go all the way to the end, and ride back.", LocalDateTime.parse("2007-01-01T12:00:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
         assertEquals("Using expected route", "BFC2", ptLeg.trip_id);
     }
@@ -580,7 +579,7 @@ public void testMissedTransferBecauseOfDelay() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2);
+        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2);
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
     }
 
@@ -716,7 +715,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
 
         PathWrapper impossibleAlternative = response.getAll().get(1);
         assertTrue(impossibleAlternative.isImpossible());
-        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2);
+        Trip.Stop delayedStop = ((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(2);
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
 
         // But when I ask about tomorrow, it works as planned
@@ -724,7 +723,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
         response = graphHopper.route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        Trip.Stop notDelayedStop = ((Trip.PtLeg) response.getBest().getLegs().get(1)).stops.get(2);
+        Trip.Stop notDelayedStop = ((Trip.PtLeg) response.getBest().getLegs().get(0)).stops.get(2);
         assertNull("Not late", notDelayedStop.predictedArrivalTime);
 
     }
@@ -756,9 +755,9 @@ public void testDelayAtEndForNonFrequencyBasedTrip() {
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Travel time == predicted travel time", time(8, 15), route.getBest().getTime(), 0.1);
-        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
-        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(2)).trip_id));
-        assertEquals("Delay at destination", LocalTime.parse("08:15"), LocalTime.from(((Trip.PtLeg) route.getBest().getLegs().get(2)).stops.get(1).predictedArrivalTime.toInstant().atZone(zoneId)));
+        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).trip_id));
+        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
+        assertEquals("Delay at destination", LocalTime.parse("08:15"), LocalTime.from(((Trip.PtLeg) route.getBest().getLegs().get(1)).stops.get(1).predictedArrivalTime.toInstant().atZone(zoneId)));
         assertEquals("Paid expected fare", 250, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue()); // Two legs, no transfers allowed. Need two 'p' tickets costing 125 cents each.
     }
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
new file mode 100644
index 0000000000..6a5a2edf28
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -0,0 +1,213 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc2D;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
+import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
+import static org.hamcrest.core.StringContains.containsString;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.mock;
+
+public class GraphExplorerTest {
+
+    private final PtFlagEncoder pt;
+    private final FootFlagEncoder foot;
+    private final EncodingManager encodingManager;
+
+    public GraphExplorerTest() {
+        pt = new PtFlagEncoder();
+        foot = new FootFlagEncoder();
+        encodingManager = new EncodingManager(Arrays.asList(pt, foot), 8);
+    }
+
+    @Test
+    public void testEverythingEmpty() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat((Iterable<EdgeIteratorState>) () -> testee.exploreEdgesAround(new Label(0, 0, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).iterator(),
+                emptyIterable());
+    }
+
+    @Test
+    public void testNonEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(d.toString()));
+    }
+
+    @Test
+    public void testExtraEdgesWithEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(0, 0, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(1, 1, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(2, 2, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+
+    }
+
+    @Test
+    public void testExtraEdgesWithNonEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+
+        int edgeId = graph.getAllEdges().length();
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
+        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        extraEdges.add(h);
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(d.toString(), h.toString()));
+    }
+
+    @Test
+    public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState c = graph.edge(4, 3);
+        c.setFlags(pt.setAccess(c.getFlags(), true, false));
+        c.setFlags(foot.setAccess(c.getFlags(), true, false));
+        PointList cp = new PointList();
+        c.setWayGeometry(cp);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+        PointList dp = new PointList();
+        d.setWayGeometry(dp);
+        graph.getNodeAccess().setNode(3, 3.0, 3.0);
+        graph.getNodeAccess().setNode(4, 4.0, 4.0);
+        graph.getNodeAccess().setNode(5, 5.0, 5.0);
+
+
+        int edgeId = graph.getAllEdges().length();
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
+        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        extraEdges.add(h);
+
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+
+        QueryResult point1 = new QueryResult(3.5, 3.5);
+        QueryResult point2 = new QueryResult(4.5, 4.5);
+        point1.setClosestEdge(c);
+        point1.setQueryDistance(0.0);
+        point1.setWayIndex(0);
+        point1.setSnappedPosition(QueryResult.Position.EDGE);
+        point1.calcSnappedPoint(new DistanceCalc2D());
+        point2.setClosestEdge(d);
+        point2.setQueryDistance(0.0);
+        point2.setWayIndex(0);
+        point2.setSnappedPosition(QueryResult.Position.EDGE);
+        point2.calcSnappedPoint(new DistanceCalc2D());
+        queryGraph.lookup(point1, point2);
+
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(containsString("4->8"), containsString("4->9"), containsString("4->7")));
+        assertThat((Iterable<String>) () -> testee.exploreEdgesAround(new Label(0, -1, 7, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                emptyIterable());
+
+    }
+
+
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
new file mode 100644
index 0000000000..28079a3ced
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertEquals;
+
+public class WrapperGraphTest {
+
+    private final PtFlagEncoder pt;
+    private final FootFlagEncoder foot;
+    private final EncodingManager encodingManager;
+
+    public WrapperGraphTest() {
+        pt = new PtFlagEncoder();
+        foot = new FootFlagEncoder();
+        encodingManager = new EncodingManager(Arrays.asList(pt, foot), 8);
+    }
+
+    @Test
+    public void testEternalOffByOneError() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        assertEquals(0, graph.getNodes());
+        assertEquals(0, graph.getAllEdges().length());
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, Collections.emptyList());
+        assertEquals(0, wrapperGraph.getNodes());
+        assertEquals(0, wrapperGraph.getAllEdges().length());
+    }
+
+}
diff --git a/reader-json/pom.xml b/reader-json/pom.xml
deleted file mode 100644
index 492576cba5..0000000000
--- a/reader-json/pom.xml
+++ /dev/null
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <groupId>com.graphhopper</groupId>
-    <artifactId>graphhopper-reader-json</artifactId>
-    <version>0.11-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>GraphHopper Reader JSON</name>
-
-    <parent>
-        <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
-    </parent>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>com.fasterxml.jackson.core</groupId>
-            <artifactId>jackson-databind</artifactId>
-            <version>${jackson.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>com.bedatadriven</groupId>
-            <artifactId>jackson-datatype-jts</artifactId>
-            <version>2.4</version>
-            <exclusions>
-                <exclusion>
-                    <groupId>com.vividsolutions</groupId>
-                    <artifactId>jts</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.12</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
-            <version>${project.parent.version}</version>
-            <type>test-jar</type>
-            <scope>test</scope>
-        </dependency>   
-
-    </dependencies>
-    
-</project>
diff --git a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java b/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
deleted file mode 100644
index e4e01c6d08..0000000000
--- a/reader-json/src/main/java/com/graphhopper/json/JsonFeatureConverter.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json;
-
-import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.change.ChangeGraphHelper;
-
-import java.io.*;
-
-import static com.graphhopper.util.Helper.UTF_CS;
-
-/**
- * Creates JsonFeature out of files and applies them to the graph.
- * Currently not used in GraphHopper itself.
- *
- * @author Peter Karich
- */
-public class JsonFeatureConverter {
-    private final ChangeGraphHelper changeGraphHelper;
-    private final GHJson ghson;
-    private final EncodingManager encodingManager;
-
-    public JsonFeatureConverter(GHJson ghson, ChangeGraphHelper changeGraphHelper, EncodingManager encodingManager) {
-        this.ghson = ghson;
-        this.changeGraphHelper = changeGraphHelper;
-        this.encodingManager = encodingManager;
-    }
-
-    /**
-     * Easily read GeoJSON files from disc and apply the specified changes to the graph.
-     */
-    public long applyChanges(String fileOrFolderStr) {
-        File fileOrFolder = new File(fileOrFolderStr);
-        try {
-            if (fileOrFolder.isFile()) {
-                return applyChanges(new InputStreamReader(new FileInputStream(fileOrFolder), UTF_CS));
-            }
-
-            long sum = 0;
-            File[] fList = new File(fileOrFolderStr).listFiles(new FilenameFilter() {
-                @Override
-                public boolean accept(File dir, String name) {
-                    return name.endsWith(".json");
-                }
-            });
-            for (File f : fList) {
-                sum += applyChanges(new InputStreamReader(new FileInputStream(f), UTF_CS));
-            }
-            return sum;
-
-        } catch (FileNotFoundException ex) {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    /**
-     * This method applies changes to the graph, specified by the reader.
-     *
-     * @return number of successfully applied edge changes
-     */
-    public long applyChanges(Reader reader) {
-        // read full file, later support one json feature or collection per line to avoid high mem consumption
-        JsonFeatureCollection data = ghson.fromJson(reader, JsonFeatureCollection.class);
-        return changeGraphHelper.applyChanges(encodingManager, data.getFeatures());
-    }
-}
diff --git a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
deleted file mode 100644
index 37c472f385..0000000000
--- a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.graphhopper.spatialrules;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.json.GHJsonFactory;
-import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.lm.LandmarkStorage;
-import com.graphhopper.routing.util.DataFlagEncoder;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.FlagEncoderFactory;
-import com.graphhopper.routing.util.spatialrules.CountriesSpatialRuleFactory;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.PMap;
-import com.graphhopper.util.shapes.BBox;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.Reader;
-
-import static com.graphhopper.util.Helper.UTF_CS;
-
-/**
- * Helper class to build the spatial rule index
- *
- * @author Robin Boldt
- */
-public class SpatialRuleLookupHelper {
-
-    private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupHelper.class);
-
-    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdArgs args) {
-        String spatialRuleLocation = args.get("spatial_rules.location", "");
-        if (!spatialRuleLocation.isEmpty()) {
-            try {
-                final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
-                final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS);
-                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
-                logger.info("Set spatial rule lookup with " + index.size() + " rules");
-                final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
-                graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
-                    @Override
-                    public FlagEncoder createFlagEncoder(String name, PMap configuration) {
-                        if (name.equals(GENERIC)) {
-                            return new DataFlagEncoder(configuration).setSpatialRuleLookup(index);
-                        }
-
-                        return oldFEF.createFlagEncoder(name, configuration);
-                    }
-                });
-            } catch (IOException ex) {
-                throw new RuntimeException(ex);
-            }
-        }
-    }
-
-    public static JsonFeatureCollection createLandmarkSplittingFeatureCollection(String location) {
-        try {
-            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(location), UTF_CS);
-            return new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
-        } catch (IOException e) {
-            logger.error("Problem while reading border map GeoJSON. Skipping this.", e);
-        }
-        return null;
-    }
-
-}
diff --git a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
deleted file mode 100644
index 36ffbf8bb9..0000000000
--- a/reader-json/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.json.geo;
-
-import com.graphhopper.json.GHJson;
-import com.graphhopper.json.GHJsonFactory;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.vividsolutions.jts.geom.LineString;
-import org.junit.Test;
-
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.Map;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Peter Karich
- */
-public class JsonFeatureCollectionTest {
-    private final GHJson ghson = new GHJsonFactory().create();
-
-    @Test
-    public void testDeserialization() {
-        JsonFeatureCollection data = getJson("geojson1.json");
-        assertEquals(3, data.getFeatures().size());
-
-        JsonFeature f1 = data.getFeatures().get(0);
-        assertEquals("1", f1.getId());
-        assertEquals("value0", f1.getProperty("prop0"));
-        assertEquals(0.5, f1.getGeometry().getCoordinate().y, .1);
-        assertEquals(102.0, f1.getGeometry().getCoordinate().x, .1);
-
-        JsonFeature f2 = data.getFeatures().get(1);
-        // read as string despite the 2 (not a string) in json
-        assertEquals("2", f2.getId());
-        assertEquals(4, f2.getGeometry().getNumPoints());
-        assertEquals(0.0, PointList.fromLineString((LineString) f2.getGeometry()).getLat(0), .1);
-        assertEquals(102.0, PointList.fromLineString((LineString) f2.getGeometry()).getLon(0), .1);
-        assertEquals(1.0, PointList.fromLineString((LineString) f2.getGeometry()).getLat(1), .1);
-        assertEquals(103.0, PointList.fromLineString((LineString) f2.getGeometry()).getLon(1), .1);
-
-        JsonFeature f3 = data.getFeatures().get(2);
-        assertEquals("0.0,102.0,1.0,103.0", f3.getBBox().toString());
-        assertEquals("a", ((Map) f3.getProperty("prop1")).get("test"));
-    }
-
-    JsonFeatureCollection getJson(String name) {
-        Reader reader = new InputStreamReader(getClass().getResourceAsStream(name), Helper.UTF_CS);
-        return ghson.fromJson(reader, JsonFeatureCollection.class);
-    }
-}
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index f7d2e4c0fe..f1466e1126 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for OpenStreetMap Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index d0e443ef72..52d49d695a 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -454,10 +454,10 @@ public void processRelation(ReaderRelation relation) throws XMLStreamException {
         EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
 
         if (edgeOutExplorer == null || edgeInExplorer == null) {
-            edgeOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            edgeOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
             outExplorerMap.put(encoder, edgeOutExplorer);
 
-            edgeInExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            edgeInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
             inExplorerMap.put(encoder, edgeInExplorer);
         }
         return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 1729b19b26..e19b2e9fef 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -83,7 +83,7 @@ public void tearDown() {
     }
 
     @Test
-    public void testMonacoWithInstructions() throws Exception {
+    public void testMonacoWithInstructions() {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
@@ -952,7 +952,7 @@ public void testFlexMode_631() {
                 setDisablingAllowed(true);
 
         tmpHopper.getLMFactoryDecorator().setEnabled(true).
-                setWeightingsAsStrings(Arrays.asList("fastest")).
+                setWeightingsAsStrings(Arrays.asList("fastest|maximum=2000")).
                 setDisablingAllowed(true);
 
         tmpHopper.importOrLoad();
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index f5c21baa0b..ef9655c33b 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -103,14 +103,14 @@ public void testLoadOSM() {
         closableInstance.close();
         try {
             rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("You need to create a new GraphHopper instance as it is already closed", ex.getMessage());
         }
 
         try {
             closableInstance.getLocationIndex().findClosest(51.2492152, 9.4317166, EdgeFilter.ALL_EDGES);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("You need to create a new LocationIndex instance as it is already closed", ex.getMessage());
         }
@@ -166,9 +166,9 @@ public void testLoadingWithDifferentCHConfig_issue471() {
                 setEncodingManager(new EncodingManager("car"));
         try {
             gh.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("You loaded a CH graph, but you did not specify graph.ch.weightings"));
         }
 
         Helper.removeDir(new File(ghLoc));
@@ -188,9 +188,9 @@ public void testLoadingWithDifferentCHConfig_issue471() {
                 setEncodingManager(new EncodingManager("car"));
         try {
             gh.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
+            assertTrue(ex.getMessage(), ex.getMessage().contains("is not contained in loaded weightings"));
         }
     }
 
@@ -257,7 +257,7 @@ public void run() {
             latch2.await(3, TimeUnit.SECONDS);
             // now importOrLoad should have create a lock which this load call does not like
             instance2.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (RuntimeException ex) {
             assertNotNull(ex);
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("To avoid reading partial data"));
@@ -384,7 +384,7 @@ public void testFailsForWrongConfig() throws IOException {
                             put(Parameters.CH.PREPARE + "weightings", "no")).
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
@@ -400,7 +400,7 @@ public void testFailsForWrongConfig() throws IOException {
                 setDataReaderFile(testOsm3);
         try {
             instance.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.bytes_for_flags (8) is not equal to loaded 4"));
         }
@@ -414,7 +414,7 @@ public void testFailsForWrongConfig() throws IOException {
                     put("graph.flag_encoders", "car,foot")).
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
@@ -430,7 +430,7 @@ public void testNoNPE_ifLoadNotSuccessful() {
             new File(ghLoc).mkdirs();
             assertFalse(instance.load(ghLoc));
             instance.route(new GHRequest(10, 40, 12, 32));
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Do a successful call to load or importOrLoad before routing", ex.getMessage());
         }
@@ -459,7 +459,7 @@ public DataReader importData() throws IOException {
         try {
             tmp.setDataReaderFile(testOsm);
             tmp.importData();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Load graph before importing OSM data", ex.getMessage());
         }
@@ -480,7 +480,7 @@ public DataReader importData() throws IOException {
                 setGraphHopperLocation(ghLoc);
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
@@ -505,7 +505,7 @@ public DataReader importData() throws IOException {
                 setGraphHopperLocation(ghLoc);
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
@@ -756,7 +756,7 @@ public boolean isEnabled() {
         });
         instance.importOrLoad();
 
-        assertTrue(af == instance.getAlgorithmFactory(null));
+        assertSame(af, instance.getAlgorithmFactory(null));
 
         // test that hints are passed to algorithm opts
         final AtomicInteger cnt = new AtomicInteger(0);
@@ -789,7 +789,7 @@ public boolean isEnabled() {
 
     @Test
     public void testMultipleCHPreparationsInParallel() {
-        HashMap<String, Integer> shortcutCountMap = new HashMap<>();
+        HashMap<String, Long> shortcutCountMap = new HashMap<>();
         // try all parallelization modes        
         for (int threadCount = 1; threadCount < 6; threadCount++) {
             EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
@@ -810,11 +810,11 @@ public void testMultipleCHPreparationsInParallel() {
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
                 String name = AbstractWeighting.weightingToFileName(pch.getWeighting());
-                Integer singleThreadShortcutCount = shortcutCountMap.get(name);
+                Long singleThreadShortcutCount = shortcutCountMap.get(name);
                 if (singleThreadShortcutCount == null)
                     shortcutCountMap.put(name, pch.getShortcuts());
                 else
-                    assertEquals((int) singleThreadShortcutCount, pch.getShortcuts());
+                    assertEquals((long) singleThreadShortcutCount, pch.getShortcuts());
 
                 String keyError = Parameters.CH.PREPARE + "error." + name;
                 String valueError = tmpGH.getGraphHopperStorage().getProperties().get(keyError);
@@ -886,8 +886,8 @@ public void testGetWeightingForCH() {
         GraphHopperStorage storage = new GraphHopperStorage(Arrays.asList(fwSimpleTruck, fwTruck), ramDir, em, false, new GraphExtension.NoOpExtension());
         decorator.addWeighting(fwSimpleTruck);
         decorator.addWeighting(fwTruck);
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwTruck), fwTruck, TraversalMode.NODE_BASED));
+        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), TraversalMode.NODE_BASED));
+        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwTruck), TraversalMode.NODE_BASED));
 
         HintsMap wMap = new HintsMap("fastest");
         wMap.put("vehicle", "truck");
@@ -899,8 +899,8 @@ public void testGetWeightingForCH() {
         decorator.addWeighting(fwTruck);
         decorator.addWeighting(fwSimpleTruck);
         try {
-            decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
-            assertTrue(false);
+            decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), TraversalMode.NODE_BASED));
+            fail();
         } catch (Exception ex) {
         }
     }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 0f8bb0ad44..4d5be3fa0b 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -325,7 +325,7 @@ public void testFoot() {
         assertEquals(GHUtility.asSet(n10, n30, n40), GHUtility.getNeighbors(carAllExplorer.setBaseNode(n20)));
         assertEquals(GHUtility.asSet(n30, n40), GHUtility.getNeighbors(carOutExplorer.setBaseNode(n20)));
 
-        EdgeExplorer footOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(footEncoder, false, true));
+        EdgeExplorer footOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(footEncoder));
         assertEquals(GHUtility.asSet(n20, n50), GHUtility.getNeighbors(footOutExplorer.setBaseNode(n10)));
         assertEquals(GHUtility.asSet(n20, n50), GHUtility.getNeighbors(footOutExplorer.setBaseNode(n30)));
         assertEquals(GHUtility.asSet(n10, n30), GHUtility.getNeighbors(footOutExplorer.setBaseNode(n20)));
@@ -847,8 +847,8 @@ protected DataReader importData() throws IOException {
                 throw new RuntimeException(e);
             }
             osmReader.readGraph();
-            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
-            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
+            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(DefaultEdgeFilter.allEdges(carEncoder));
             return osmReader;
         }
     }
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 82c8f89039..8db3858caa 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -527,8 +527,8 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
             // avoid that path.getDistance is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
-            // always enable landmarks
-            hopper.getLMFactoryDecorator().addWeighting(weightStr).
+            // always enable landmarks, add maximum information to reduce warnings
+            hopper.getLMFactoryDecorator().addWeighting(weightStr+"|maximum=60000").
                     setEnabled(true).setDisablingAllowed(true);
 
             if (withCH)
@@ -547,7 +547,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
 
             Collection<AlgoHelperEntry> prepares = RoutingAlgorithmIT.createAlgos(hopper, hints, tMode);
 
-            EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+            EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
             for (AlgoHelperEntry entry : prepares) {
                 algoEntry = entry;
                 LocationIndex idx = entry.getIdx();
@@ -595,7 +595,7 @@ public void testMonacoParallel() throws IOException {
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
         final Weighting weighting = new ShortestWeighting(encodingManager.getEncoder("car"));
-        final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(carEncoder);
         for (int no = 0; no < MAX; no++) {
             for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++) {
                 String[] algos = new String[]{
diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
deleted file mode 100644
index 9247e4a145..0000000000
--- a/reader-shp/pom.xml
+++ /dev/null
@@ -1,86 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <groupId>com.graphhopper</groupId>
-    <artifactId>graphhopper-reader-shp</artifactId>
-    <version>0.11-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>GraphHopper Reader for Shapefile Data</name>
-	
-    <properties>      
-        <geotools.version>19.0</geotools.version>
-    </properties>
-    	
-    <parent>
-        <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
-    </parent>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
-        
-        <dependency>
-            <groupId>org.geotools</groupId>
-            <artifactId>gt-shapefile</artifactId>
-            <version>${geotools.version}</version>
-        </dependency>
-		
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-api</artifactId>
-            <version>${slf4j.version}</version>
-        </dependency>   
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.12</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-osm</artifactId>
-            <version>${project.parent.version}</version>
-            <scope>test</scope>
-        </dependency>        
-    </dependencies>
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
-                <configuration>
-                    <source>1.8</source>
-                    <target>1.8</target>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-    <repositories>
-        <repository>
-            <id>osgeo</id>
-            <name>Open Source Geospatial Foundation Repository</name>
-            <url>http://download.osgeo.org/webdav/geotools/</url>
-        </repository>
-    </repositories>
-	
-</project>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
deleted file mode 100644
index 296923156e..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import java.util.HashSet;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.shp.OSMShapeFileReader.EdgeAddedListener;
-import com.graphhopper.storage.GraphHopperStorage;
-
-/**
- * This class is the main entry point to import from OpenStreetMap shape files similar to GraphHopperOSM which imports
- * OSM xml and pbf files.
- *
- * @author Phil
- */
-public class GraphHopperSHP extends GraphHopper {
-    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
-
-    @Override
-    protected DataReader createReader(GraphHopperStorage ghStorage) {
-        OSMShapeFileReader reader = new OSMShapeFileReader(ghStorage);
-        for (EdgeAddedListener l : edgeAddedListeners) {
-            reader.addListener(l);
-        }
-        return initDataReader(reader);
-    }
-
-    public void addListener(EdgeAddedListener l) {
-        edgeAddedListeners.add(l);
-    }
-
-}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
deleted file mode 100644
index 1228591d35..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import com.graphhopper.coll.GHObjectIntHashMap;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.LineString;
-import com.vividsolutions.jts.geom.MultiLineString;
-import org.geotools.data.DataStore;
-import org.geotools.feature.FeatureIterator;
-import org.opengis.feature.simple.SimpleFeature;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.List;
-
-import static com.graphhopper.util.Helper.*;
-
-/**
- * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
- * extracts the data as per the structure of shape files
- *
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public class OSMShapeFileReader extends ShapeFileReader {
-    private static final int COORD_STATE_UNKNOWN = 0;
-    private static final int COORD_STATE_PILLAR = -2;
-    private static final int FIRST_NODE_ID = 1;
-    private static final String[] DIRECT_COPY_TAGS = new String[]{"name"};
-    private File roadsFile;
-    private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
-    private final DistanceCalc distCalc = DIST_EARTH;
-    private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
-    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
-    private int nextNodeId = FIRST_NODE_ID;
-    private final String encoding = "utf8";
-
-    public OSMShapeFileReader(GraphHopperStorage ghStorage) {
-        super(ghStorage);
-    }
-
-    private List<Coordinate[]> getCoords(Object o) {
-        ArrayList<Coordinate[]> ret = new ArrayList<>();
-        if (o == null) {
-            return ret;
-        }
-
-        if (o instanceof LineString) {
-            ret.add(((LineString) o).getCoordinates());
-        } else if (o instanceof MultiLineString) {
-            MultiLineString mls = (MultiLineString) o;
-            int n = mls.getNumGeometries();
-            for (int i = 0; i < n; i++) {
-                ret.add(mls.getGeometryN(i).getCoordinates());
-            }
-        }
-
-        return ret;
-    }
-
-    @Override
-    void processJunctions() {
-        DataStore dataStore = null;
-        FeatureIterator<SimpleFeature> roads = null;
-
-        try {
-            dataStore = openShapefileDataStore(roadsFile, encoding);
-            roads = getFeatureIterator(dataStore);
-
-            HashSet<Coordinate> tmpSet = new HashSet<>();
-            while (roads.hasNext()) {
-                SimpleFeature road = roads.next();
-
-                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-                    tmpSet.clear();
-                    for (int i = 0; i < points.length; i++) {
-                        Coordinate c = points[i];
-
-                        // don't add the same coord twice for the same edge - happens with bad geometry, i.e.
-                        // duplicate coords or a road which forms a circle (e.g. roundabout)
-                        if (tmpSet.contains(c))
-                            continue;
-
-                        tmpSet.add(c);
-
-                        // skip if its already a node
-                        int state = coordState.get(c);
-                        if (state >= FIRST_NODE_ID) {
-                            continue;
-                        }
-
-                        if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
-                            // turn into a node if its the first or last
-                            // point, or already appeared in another edge
-                            int nodeId = nextNodeId++;
-                            coordState.put(c, nodeId);
-                            saveTowerPosition(nodeId, c);
-                        } else if (state == COORD_STATE_UNKNOWN) {
-                            // mark it as a pillar (which may get upgraded
-                            // to an edge later)
-                            coordState.put(c, COORD_STATE_PILLAR);
-                        }
-                    }
-                }
-
-            }
-        } finally {
-            if (roads != null) {
-                roads.close();
-            }
-            if (dataStore != null) {
-                dataStore.dispose();
-            }
-        }
-
-        if (nextNodeId == FIRST_NODE_ID)
-            throw new IllegalArgumentException("No data found for roads file " + roadsFile);
-
-        LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
-    }
-
-    @Override
-    void processRoads() {
-
-        DataStore dataStore = null;
-        FeatureIterator<SimpleFeature> roads = null;
-
-        try {
-            dataStore = openShapefileDataStore(roadsFile, encoding);
-            roads = getFeatureIterator(dataStore);
-
-            while (roads.hasNext()) {
-                SimpleFeature road = roads.next();
-
-                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-
-                    // Parse all points in the geometry, splitting into
-                    // individual graphhopper edges
-                    // whenever we find a node in the list of points
-                    Coordinate startTowerPnt = null;
-                    List<Coordinate> pillars = new ArrayList<Coordinate>();
-                    for (Coordinate point : points) {
-                        if (startTowerPnt == null) {
-                            startTowerPnt = point;
-                        } else {
-                            int state = coordState.get(point);
-                            if (state >= FIRST_NODE_ID) {
-                                int fromTowerNodeId = coordState.get(startTowerPnt);
-                                int toTowerNodeId = state;
-
-                                // get distance and estimated centres
-                                double distance = getWayLength(startTowerPnt, pillars, point);
-                                GHPoint estmCentre = new GHPoint(
-                                        0.5 * (lat(startTowerPnt) + lat(point)),
-                                        0.5 * (lng(startTowerPnt) + lng(point)));
-                                PointList pillarNodes = new PointList(pillars.size(), false);
-
-                                for (Coordinate pillar : pillars) {
-                                    pillarNodes.add(lat(pillar), lng(pillar));
-                                }
-
-                                addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre,
-                                        pillarNodes);
-                                startTowerPnt = point;
-                                pillars.clear();
-                            } else {
-                                pillars.add(point);
-                            }
-                        }
-                    }
-                }
-
-            }
-        } finally {
-            if (roads != null) {
-                roads.close();
-            }
-
-            if (dataStore != null) {
-                dataStore.dispose();
-            }
-        }
-    }
-
-    private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
-        double distance = 0;
-
-        Coordinate previous = start;
-        for (Coordinate point : pillars) {
-            distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
-            previous = point;
-        }
-        distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
-
-        return distance;
-    }
-
-    @Override
-    public DataReader setFile(File file) {
-        this.roadsFile = file;
-        return this;
-    }
-
-    @Override
-    public DataReader setElevationProvider(ElevationProvider ep) {
-        // Elevation not supported
-        return this;
-    }
-
-    @Override
-    public DataReader setWorkerThreads(int workerThreads) {
-        // Its only single-threaded
-        return this;
-    }
-
-    @Override
-    public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
-        // TODO Auto-generated method stub
-        return this;
-    }
-
-    @Override
-    public DataReader setSmoothElevation(boolean smoothElevation) {
-        // TODO implement elevation smoothing for shape files
-        return this;
-    }
-
-    @Override
-    public Date getDataDate() {
-        return null;
-    }
-
-    public static interface EdgeAddedListener {
-        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
-    }
-
-    private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,
-                         GHPoint estmCentre, PointList pillarNodes) {
-        EdgeIteratorState edge = graph.edge(fromTower, toTower);
-
-        // read the OSM id, should never be null
-        long id = getOSMId(road);
-
-        // Make a temporary ReaderWay object with the properties we need so we
-        // can use the enocding manager
-        // We (hopefully don't need the node structure on here as we're only
-        // calling the flag
-        // encoders, which don't use this...
-        ReaderWay way = new ReaderWay(id);
-
-        way.setTag("estimated_distance", distance);
-        way.setTag("estimated_center", estmCentre);
-
-        // read the highway type
-        Object type = road.getAttribute("fclass");
-        if (type != null) {
-            way.setTag("highway", type.toString());
-        }
-
-        // read maxspeed filtering for 0 which for Geofabrik shapefiles appears
-        // to correspond to no tag
-        Object maxSpeed = road.getAttribute("maxspeed");
-        if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
-            way.setTag("maxspeed", maxSpeed.toString());
-        }
-
-        for (String tag : DIRECT_COPY_TAGS) {
-            Object val = road.getAttribute(tag);
-            if (val != null) {
-                way.setTag(tag, val.toString());
-            }
-        }
-
-        // read oneway
-        Object oneway = road.getAttribute("oneway");
-        if (oneway != null) {
-            // Geofabrik is using an odd convention for oneway field in
-            // shapefile.
-            // We map back to the standard convention so that tag can be dealt
-            // with correctly by the flag encoder.
-            String val = toLowerCase(oneway.toString().trim());
-            if (val.equals("b")) {
-                // both ways
-                val = "no";
-            } else if (val.equals("t")) {
-                // one way against the direction of digitisation
-                val = "-1";
-            } else if (val.equals("f")) {
-                // one way Forward in the direction of digitisation
-                val = "yes";
-            } else {
-                throw new RuntimeException("Unrecognised value of oneway field \"" + val
-                        + "\" found in road with OSM id " + id);
-            }
-
-            way.setTag("oneway", val);
-        }
-
-        // Process the flags using the encoders
-        long includeWay = encodingManager.acceptWay(way);
-        if (includeWay == 0) {
-            return;
-        }
-
-        // TODO we're not using the relation flags
-        long relationFlags = 0;
-
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-        if (wayFlags == 0)
-            return;
-
-        edge.setDistance(distance);
-        edge.setFlags(wayFlags);
-        edge.setWayGeometry(pillarNodes);
-
-        if (edgeAddedListeners.size() > 0) {
-            // check size first so we only allocate the iterator if we have
-            // listeners
-            for (EdgeAddedListener l : edgeAddedListeners) {
-                l.edgeAdded(way, edge);
-            }
-        }
-    }
-
-    private long getOSMId(SimpleFeature road) {
-        long id = Long.parseLong(road.getAttribute("osm_id").toString());
-        return id;
-    }
-
-    public void addListener(EdgeAddedListener l) {
-        edgeAddedListeners.add(l);
-    }
-}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
deleted file mode 100644
index 27f7bfc343..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.geotools.data.DataStore;
-import org.geotools.data.DataStoreFinder;
-import org.geotools.data.FeatureSource;
-import org.geotools.feature.FeatureCollection;
-import org.geotools.feature.FeatureIterator;
-import org.opengis.feature.simple.SimpleFeature;
-import org.opengis.feature.simple.SimpleFeatureType;
-import org.opengis.filter.Filter;
-
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.vividsolutions.jts.geom.Coordinate;
-
-/**
- * ShapeFileReader takes care of reading a shape file and writing it to a road network graph
- *
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public abstract class ShapeFileReader implements DataReader {
-
-    private final GraphStorage graphStorage;
-    private final NodeAccess nodeAccess;
-    protected final Graph graph;
-    protected EncodingManager encodingManager;
-
-    public ShapeFileReader(GraphHopperStorage ghStorage) {
-        this.graphStorage = ghStorage;
-        this.graph = ghStorage;
-        this.nodeAccess = graph.getNodeAccess();
-        this.encodingManager = ghStorage.getEncodingManager();
-    }
-
-    @Override
-    public void readGraph() {
-        graphStorage.create(1000);
-        processJunctions();
-        processRoads();
-    }
-
-    abstract void processJunctions();
-
-    abstract void processRoads();
-
-    protected FeatureIterator<SimpleFeature> getFeatureIterator(DataStore dataStore) {
-        if (dataStore == null)
-            throw new IllegalArgumentException("DataStore cannot be null for getFeatureIterator");
-
-        try {
-            String typeName = dataStore.getTypeNames()[0];
-            FeatureSource<SimpleFeatureType, SimpleFeature> source = dataStore.getFeatureSource(typeName);
-            Filter filter = Filter.INCLUDE;
-            FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures(filter);
-
-            FeatureIterator<SimpleFeature> features = collection.features();
-            return features;
-
-        } catch (Exception e) {
-            throw Utils.asUnchecked(e);
-        }
-    }
-
-    protected DataStore openShapefileDataStore(File file, String encoding) {
-        try {
-            Map<String, Object> map = new HashMap<String, Object>();
-            map.put("url", file.toURI().toURL());
-            map.put("charset", encoding);
-            DataStore ds = DataStoreFinder.getDataStore(map);
-            if (ds == null)
-                throw new IllegalArgumentException("Cannot find DataStore at " + file);
-            return ds;
-
-        } catch (Exception e) {
-            throw Utils.asUnchecked(e);
-        }
-    }
-
-    /*
-     * Get longitude using the current long-lat order convention
-     */
-    protected double lng(Coordinate coordinate) {
-        return coordinate.getOrdinate(0);
-    }
-
-    /*
-	 * Get latitude using the current long-lat order convention
-     */
-    protected double lat(Coordinate coordinate) {
-        return coordinate.getOrdinate(1);
-    }
-
-    protected void saveTowerPosition(int nodeId, Coordinate point) {
-        nodeAccess.setNode(nodeId, lat(point), lng(point));
-    }
-}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
deleted file mode 100644
index e434b1e66e..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import com.graphhopper.util.PointList;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.GeometryFactory;
-
-/**
- * @author Phil
- */
-public class Utils {
-    public static String toWKT(PointList list) {
-        int n = list.size();
-        GeometryFactory factory = new GeometryFactory();
-        Coordinate[] coords = new Coordinate[n];
-        for (int i = 0; i < coords.length; i++) {
-            coords[i] = new Coordinate(list.getLon(i), list.getLat(i));
-        }
-        return factory.createLineString(coords).toText();
-    }
-
-    public static RuntimeException asUnchecked(Throwable e) {
-        if (RuntimeException.class.isInstance(e)) {
-            return (RuntimeException) e;
-        }
-        return new RuntimeException(e);
-    }
-
-}
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
deleted file mode 100644
index 8bddc0545c..0000000000
--- a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.DoubleSummaryStatistics;
-import java.util.Random;
-
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.reader.osm.GraphHopperOSM;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public class ShapeFileReaderTest {
-
-    private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
-    private static final String pbf = "/data/malta-latest.osm.pbf";
-    private static final String tempOutputDirFromShp = "target/test-db-shp";
-    private static final String tempOutputDirFromPbf = "target/test-db-pbf";
-    private static GraphHopper hopperShp;
-    private static GraphHopper hopperPbf;
-    private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private static Exception BEFORE_CLASS_EXCEPTION = null;
-
-    private static class FromToPair {
-        final GHPoint from;
-        final GHPoint to;
-
-        FromToPair(double fromLat, double fromLng, double toLat, double toLng) {
-            this(new GHPoint(fromLat, fromLng), new GHPoint(toLat, toLng));
-        }
-
-        FromToPair(GHPoint from, GHPoint to) {
-            this.from = from;
-            this.to = to;
-        }
-
-        PathWrapper getPath(GraphHopper hopper, boolean assertNoErrors) {
-            GHRequest request = new GHRequest(from, to).setVehicle("car");
-            GHResponse response = hopper.route(request);
-
-            if (assertNoErrors) {
-                assertFalse(response.hasErrors());
-            }
-
-            if (!response.hasErrors()) {
-                return response.getBest();
-            }
-            return null;
-        }
-
-    }
-
-    private static class ExpectedDuration extends FromToPair {
-        final double minSecs;
-        final double maxSecs;
-
-        private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng,
-                                 double minSecs, double maxSecs) {
-            super(fromLat, fromLng, toLat, toLng);
-            this.minSecs = minSecs;
-            this.maxSecs = maxSecs;
-        }
-    }
-
-    private static GraphHopper initHopper(GraphHopper gh, String inputFile, String outDir) {
-        URL resourceURL = ShapeFileReaderTest.class.getResource(inputFile);
-        try {
-            inputFile = new File(resourceURL.toURI()).getAbsolutePath();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-
-        // turn off geometry simplification so geometry should be the same
-        // between pbf and shapefile readers
-        gh.setWayPointMaxDistance(0);
-        return gh.setStoreOnFlush(false).setDataReaderFile(inputFile)
-                .setGraphHopperLocation(new File(outDir).getAbsolutePath())
-                .setEncodingManager(new EncodingManager(new CarFlagEncoder()))
-                .setCHEnabled(false).importOrLoad();
-
-    }
-
-    /**
-     * Build the graphs once only for the various tests
-     */
-    @BeforeClass
-    public static void setupBeforeClass() {
-        try {
-            new File(tempOutputDirFromShp).mkdirs();
-            new File(tempOutputDirFromPbf).mkdirs();
-
-            hopperShp = initHopper(new GraphHopperSHP(), shapefile, tempOutputDirFromShp);
-
-            hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
-
-        } catch (Exception e) {
-            // Junit silently fails if we get an exception in the setup before
-            // class,
-            // so we record it here and explicitly rethrow it
-            BEFORE_CLASS_EXCEPTION = e;
-        }
-
-    }
-
-    @AfterClass
-    public static void teardownAfterClass() {
-        try {
-            hopperShp.close();
-            hopperShp.clean();
-        } catch (Exception e) {
-        }
-
-        try {
-            hopperPbf.close();
-            hopperPbf.clean();
-        } catch (Exception e) {
-        }
-
-    }
-
-    @Before
-    public void beforeTest() throws Exception {
-        // Rethrow the exception from @BeforeClass here so it doesn't silently
-        // fail.
-        // (Junit silently fails on exceptions thrown in @BeforeClass but not
-        // for
-        // exceptions thrown in @Before)
-        if (BEFORE_CLASS_EXCEPTION != null) {
-            throw BEFORE_CLASS_EXCEPTION;
-        }
-    }
-
-    @Test
-    public void testOneWay() {
-        // We setup 2 points very close together on a one-way street.
-        // As its a one way street, the ordering of the start and end requires
-        // going around the block to serve them.
-        // As the scenario is simple, we should get the same results from both
-        // shapefile and pbf.
-        // We should also get route distance to be many times physical distance
-        FromToPair pair = new FromToPair(35.898324, 14.510729, 35.898328, 14.510681);
-        PathWrapper shp = pair.getPath(hopperShp, true);
-        PathWrapper pbf = pair.getPath(hopperPbf, true);
-        double metresShp = shp.getDistance();
-        double metresPbf = pbf.getDistance();
-
-        // should be many times the physical separation between the points (as
-        // we had to go round the block)
-        double straightLineDistMetres = distCalc.calcDist(pair.from.lat, pair.from.lon, pair.to.lat,
-                pair.to.lon);
-        assertTrue(metresShp > straightLineDistMetres * 25);
-
-        // should be the same to within 1 cm
-        assertEquals(metresShp, metresPbf, 0.01);
-
-    }
-
-    @Test
-    public void testGeometrySingleEdgePath() {
-        // We choose a path along a single edge with a couple of minor bends,
-        // which we expect to give identical results...
-        FromToPair pair = new FromToPair(35.911694, 14.492303, 35.911494, 14.490489);
-        PointList shp = pair.getPath(hopperShp, true).getPoints();
-        PointList pbf = pair.getPath(hopperPbf, true).getPoints();
-
-        assertTrue("The chosen edge had a couple of bends!", shp.getSize() >= 2);
-        assertSameGeometry(shp, pbf);
-    }
-
-    private void assertSameGeometry(PointList shp, PointList pbf) {
-        assertEquals(shp.getSize(), pbf.getSize());
-
-        for (int i = 0; i < shp.getSize(); i++) {
-            assertEquals(shp.getLat(i), pbf.getLat(i), 0.0000001);
-            assertEquals(shp.getLon(i), pbf.getLon(i), 0.0000001);
-        }
-    }
-
-    @Test
-    public void testTravelTimesBetweenRandomLocations() {
-        int nTests = 200;
-        final Random random = new Random(123);
-        final GHPoint min = new GHPoint(35.882931, 14.403076);
-        final GHPoint max = new GHPoint(35.913523, 14.448566);
-
-        class RandPointGenerator {
-            double rand(double min, double max) {
-                return min + random.nextDouble() * (max - min);
-            }
-
-            GHPoint randPoint() {
-                return new GHPoint(rand(min.lat, max.lat), rand(min.lon, max.lon));
-            }
-
-        }
-        RandPointGenerator pointGenerator = new RandPointGenerator();
-
-        int nbFails = 0;
-        DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
-        for (int i = 0; i < nTests; i++) {
-            FromToPair pair = new FromToPair(pointGenerator.randPoint(),
-                    pointGenerator.randPoint());
-
-            // paths from random points can fail to don't assert on failure
-            PathWrapper shpPath = pair.getPath(hopperShp, false);
-            PathWrapper pbfPath = pair.getPath(hopperPbf, false);
-
-            // paths between random points can fail to find a route (i.e. be off
-            // the road network)
-            if (shpPath == null || pbfPath == null) {
-                nbFails++;
-                continue;
-            }
-            double shpSecs = getSecondsTravel(shpPath);
-            double pbfSecs = getSecondsTravel(pbfPath);
-
-            double frac = shpSecs / pbfSecs;
-            double percentageDeviation = Math.abs(1.0 - frac) * 100;
-            stats.accept(percentageDeviation);
-        }
-
-        assertTrue("Number of fails should be small for the chosen box", nbFails < nTests / 3);
-
-        // Test mean fraction. There will be some deviation as not all tags are
-        // considered etc,
-        // but we expect it to be small for a large number of tests
-        double mean = stats.getAverage();
-        assertTrue("Should have a mean deviation in travel times of less than 1%", mean < 1.0);
-    }
-
-    @Test
-    public void testTravelTimesBetweenPredefinedLocations() throws URISyntaxException {
-
-        // try a couple of test points, with an expected time range that will
-        // only fail if something is really bad...
-        ExpectedDuration[] expected = new ExpectedDuration[]{
-                new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60,
-                        60 * 6),
-                new ExpectedDuration(35.899167, 14.515171, 35.877645, 14.398956, 8 * 60,
-                        25 * 60),
-                new ExpectedDuration(35.85817, 14.561348, 35.877645, 14.398956, 10 * 60,
-                        30 * 60),
-                new ExpectedDuration(35.812802, 14.528732, 35.979673, 14.335785, 20 * 60,
-                        50 * 60),};
-
-        // The chosen locations should have small deviations in travel times
-        double tolDiffFromPbf = 0.01;
-
-        for (ExpectedDuration ed : expected) {
-            double secsShp = getSecondsTravel(ed.getPath(hopperShp, true));
-            double secsPbf = getSecondsTravel(ed.getPath(hopperPbf, true));
-            double frac = secsShp / secsPbf;
-
-            String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs
-                    + " <= travelsecs <= " + ed.maxSecs + ", found " + secsShp
-                    + " secs, pbf was " + secsPbf + " secs, frac diff=" + frac;
-            assertTrue(message, secsShp >= ed.minSecs);
-            assertTrue(message, secsShp <= ed.maxSecs);
-
-            // we also use a tolerance difference with the pbf
-            assertTrue(frac > 1 - tolDiffFromPbf);
-            assertTrue(frac < 1 + tolDiffFromPbf);
-
-        }
-
-    }
-
-    private static double getSecondsTravel(PathWrapper pw) {
-        long millis = pw.getTime();
-        double secs = 0.001 * millis;
-        return secs;
-    }
-
-}
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
deleted file mode 100644
index 7edc66b06a..0000000000
--- a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
+++ /dev/null
@@ -1 +0,0 @@
-UTF-8
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf
deleted file mode 100644
index 116ff9c648..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
deleted file mode 100644
index 8f73f480ff..0000000000
--- a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
+++ /dev/null
@@ -1 +0,0 @@
-GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp
deleted file mode 100644
index 491be81e73..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx
deleted file mode 100644
index 25718abea1..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/malta-latest.osm.pbf b/reader-shp/src/test/resources/data/malta-latest.osm.pbf
deleted file mode 100644
index 6b84456772..0000000000
Binary files a/reader-shp/src/test/resources/data/malta-latest.osm.pbf and /dev/null differ
diff --git a/reader-shp/src/test/resources/log4j.xml b/reader-shp/src/test/resources/log4j.xml
deleted file mode 100644
index a9bb71c09f..0000000000
--- a/reader-shp/src/test/resources/log4j.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
-<log4j:configuration>
-    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
-        <layout class="org.apache.log4j.PatternLayout">
-            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
-        </layout>
-    </appender>
-    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
-        <param name="BufferSize" value="500"/>
-        <appender-ref ref="stdout"/>
-    </appender>    
-    <logger name="com.graphhopper" additivity="false">
-        <level value="warn" />
-        <appender-ref ref="ASYNC" />
-    </logger>
-    <root>
-        <priority value="warn"></priority>
-        <appender-ref ref="ASYNC"/>
-    </root>
-</log4j:configuration>
\ No newline at end of file
diff --git a/tools/pom.xml b/tools/pom.xml
index 49fe8d207d..71fc082799 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -21,11 +21,6 @@
             <artifactId>graphhopper-reader-osm</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-json</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 0a994cca6e..c6d7fbedd0 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -90,7 +90,7 @@ void start(CmdArgs args) {
             protected void prepareCH() {
                 StopWatch sw = new StopWatch().start();
                 super.prepareCH();
-                put(Parameters.CH.PREPARE + "time", sw.stop().getTime());
+                put(Parameters.CH.PREPARE + "time", sw.stop().getMillis());
                 int edges = getGraphHopperStorage().getAllEdges().length();
                 if (getCHFactoryDecorator().hasWeightings()) {
                     Weighting weighting = getCHFactoryDecorator().getWeightings().get(0);
@@ -99,6 +99,13 @@ protected void prepareCH() {
                 }
             }
 
+            @Override
+            protected void loadOrPrepareLM() {
+                StopWatch sw = new StopWatch().start();
+                super.loadOrPrepareLM();
+                put(Parameters.Landmark.PREPARE + "time", sw.stop().getMillis());
+            }
+
             @Override
             protected DataReader importData() throws IOException {
                 StopWatch sw = new StopWatch().start();
@@ -171,7 +178,7 @@ protected DataReader importData() throws IOException {
             put("measurement.gitinfo", gitCommit);
             put("measurement.count", count);
             put("measurement.seed", seed);
-            put("measurement.time", sw.stop().getTime());
+            put("measurement.time", sw.stop().getMillis());
             System.gc();
             put("measurement.totalMB", getTotalMB());
             put("measurement.usedMB", getUsedMB());
@@ -260,7 +267,7 @@ public int doCalc(boolean warmup, int run) {
             print("unit_testsCH.get_weight", miniPerf);
         }
 
-        EdgeFilter outFilter = new DefaultEdgeFilter(encoder, false, true);
+        EdgeFilter outFilter = DefaultEdgeFilter.outEdges(encoder);
         final EdgeExplorer outExplorer = graph.createEdgeExplorer(outFilter);
         MiniPerfTest miniPerf = new MiniPerfTest() {
             @Override
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index 0a507aa149..30db0529cc 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.ui;
 
-import com.graphhopper.routing.AStar;
 import com.graphhopper.routing.AStarBidirection;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 9e62ca3d76..dee0c9ee9a 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -370,7 +370,7 @@ private Path calcPath(RoutingAlgorithm algo) {
 //
 ////        System.out.println("path " + from + "->" + to);
 //        return algo.calcPath(from, to);
-        // System.out.println(GraphUtility.getNodeInfo(graph, 60139, new DefaultEdgeFilter(new CarFlagEncoder()).direction(false, true)));
+        // System.out.println(GraphUtility.getNodeInfo(graph, 60139, DefaultEdgeFilter.allEdges(new CarFlagEncoder()).direction(false, true)));
         // System.out.println(((GraphStorage) graph).debug(202947, 10));
 //        GraphUtility.printInfo(graph, 106511, 10);
         return algo.calcPath(162810, 35120);
diff --git a/web-api/pom.xml b/web-api/pom.xml
new file mode 100644
index 0000000000..ce0c0a9495
--- /dev/null
+++ b/web-api/pom.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-web-api</artifactId>
+    <packaging>jar</packaging>
+    <version>0.12-SNAPSHOT</version>
+    <name>GraphHopper Web API</name>
+    <description>JSON Representation of the API classes</description>
+
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.12-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-core</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.graphhopper.external</groupId>
+            <artifactId>jackson-datatype-jts</artifactId>
+            <version>0.10-2.5-2</version>
+        </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-testing</artifactId>
+            <version>${dropwizard.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
+
+
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/web-api/src/main/java/com/graphhopper/MultiException.java
similarity index 67%
rename from core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
rename to web-api/src/main/java/com/graphhopper/MultiException.java
index fb09949704..6b59ce982e 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/web-api/src/main/java/com/graphhopper/MultiException.java
@@ -15,21 +15,26 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.search;
 
-import com.graphhopper.util.shapes.GHPlace;
+package com.graphhopper;
 
+import java.util.Collections;
 import java.util.List;
 
-/**
- * Interface to convert from points to place names or node ids.
- * <p>
- *
- * @author Peter Karich
- */
-public interface ReverseGeocoding {
-    /**
-     * Tries to retrieve a locational string from the specified points (list of lat,lon).
-     */
-    List<GHPlace> places2names(GHPlace... points);
+public class MultiException extends RuntimeException {
+
+    private final List<Throwable> errors;
+
+    public MultiException(List<Throwable> errors) {
+        this.errors = errors;
+    }
+
+    public MultiException(Throwable e) {
+        this(Collections.singletonList(e));
+    }
+
+    public List<Throwable> getErrors() {
+        return errors;
+    }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
similarity index 62%
rename from web/src/main/java/com/graphhopper/http/WebHelper.java
rename to web-api/src/main/java/com/graphhopper/http/WebHelper.java
index 9baa6a9af5..4d2e4d179c 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
@@ -24,25 +24,12 @@
 import com.graphhopper.PathWrapper;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
-import com.graphhopper.util.exceptions.GHException;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
 
-import javax.ws.rs.WebApplicationException;
-import javax.ws.rs.core.Response;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.*;
+import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.text.NumberFormat;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
 import java.util.Locale;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-
 /**
  * Code which handles polyline encoding and other web stuff.
  * <p>
@@ -115,16 +102,20 @@ public static String encodePolyline(PointList poly) {
     }
 
     public static String encodePolyline(PointList poly, boolean includeElevation) {
+        return encodePolyline(poly, includeElevation, 1e5);
+    }
+
+    public static String encodePolyline(PointList poly, boolean includeElevation, double precision) {
         StringBuilder sb = new StringBuilder();
         int size = poly.getSize();
         int prevLat = 0;
         int prevLon = 0;
         int prevEle = 0;
         for (int i = 0; i < size; i++) {
-            int num = (int) Math.floor(poly.getLatitude(i) * 1e5);
+            int num = (int) Math.floor(poly.getLatitude(i) * precision);
             encodeNumber(sb, num - prevLat);
             prevLat = num;
-            num = (int) Math.floor(poly.getLongitude(i) * 1e5);
+            num = (int) Math.floor(poly.getLongitude(i) * precision);
             encodeNumber(sb, num - prevLon);
             prevLon = num;
             if (includeElevation) {
@@ -150,53 +141,6 @@ private static void encodeNumber(StringBuilder sb, int num) {
         sb.append((char) (num));
     }
 
-    public static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
-        if (ghRsp.getAll().size() > 1) {
-            throw new WebApplicationException("Alternatives are currently not yet supported for GPX");
-        }
-
-        long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
-        return Response.ok(ghRsp.getBest().getInstructions().createGPX(trackName, time, enableElevation, withRoute, withTrack, withWayPoints), "application/gpx+xml").
-                header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-    }
-
-    private static Response xmlErrorResponse(Collection<Throwable> list) {
-        if (list.isEmpty())
-            throw new RuntimeException("errorsToXML should not be called with an empty list");
-
-        try {
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-            DocumentBuilder builder = factory.newDocumentBuilder();
-            Document doc = builder.newDocument();
-            Element gpxElement = doc.createElement("gpx");
-            gpxElement.setAttribute("creator", "GraphHopper");
-            gpxElement.setAttribute("version", "1.1");
-            doc.appendChild(gpxElement);
-
-            Element mdElement = doc.createElement("metadata");
-            gpxElement.appendChild(mdElement);
-
-            Element extensionsElement = doc.createElement("extensions");
-            mdElement.appendChild(extensionsElement);
-
-            Element messageElement = doc.createElement("message");
-            extensionsElement.appendChild(messageElement);
-            messageElement.setTextContent(list.iterator().next().getMessage());
-
-            Element hintsElement = doc.createElement("hints");
-            extensionsElement.appendChild(hintsElement);
-
-            for (Throwable t : list) {
-                Element error = doc.createElement("error");
-                hintsElement.appendChild(error);
-                error.setAttribute("message", t.getMessage());
-                error.setAttribute("details", t.getClass().getName());
-            }
-            return Response.status(SC_BAD_REQUEST).entity(doc).build();
-        } catch (ParserConfigurationException e) {
-            throw new RuntimeException(e);
-        }
-    }
 
     public static ObjectNode jsonObject(GHResponse ghRsp, boolean enableInstructions, boolean calcPoints, boolean enableElevation, boolean pointsEncoded, float took) {
         ObjectNode json = JsonNodeFactory.instance.objectNode();
@@ -240,37 +184,4 @@ public static ObjectNode jsonObject(GHResponse ghRsp, boolean enableInstructions
         return json;
     }
 
-    public static Response errorResponse(List<Throwable> t, boolean writeGPX) {
-        if (writeGPX) {
-            return xmlErrorResponse(t);
-        } else {
-            return jsonErrorResponse(t);
-        }
-    }
-
-    public static Response errorResponse(Throwable t, boolean writeGPX) {
-        return errorResponse(Collections.singletonList(t), writeGPX);
-    }
-
-    private static Response jsonErrorResponse(List<Throwable> errors) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.put("message", getMessage(errors.get(0)));
-        ArrayNode errorHintList = json.putArray("hints");
-        for (Throwable t : errors) {
-            ObjectNode error = errorHintList.addObject();
-            error.put("message", getMessage(t));
-            error.put("details", t.getClass().getName());
-            if (t instanceof GHException) {
-                ((GHException) t).getDetails().forEach(error::putPOJO);
-            }
-        }
-        return Response.status(SC_BAD_REQUEST).entity(json).build();
-    }
-
-    private static String getMessage(Throwable t) {
-        if (t.getMessage() == null)
-            return t.getClass().getSimpleName();
-        else
-            return t.getMessage();
-    }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/BBoxDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/BBoxDeserializer.java
new file mode 100644
index 0000000000..36d7fbaf5c
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/BBoxDeserializer.java
@@ -0,0 +1,17 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.graphhopper.util.shapes.BBox;
+
+import java.io.IOException;
+
+class BBoxDeserializer extends JsonDeserializer<BBox> {
+    @Override
+    public BBox deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
+        double[] bounds = jsonParser.readValueAs(double[].class);
+        return new BBox(bounds);
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/BBoxSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/BBoxSerializer.java
new file mode 100644
index 0000000000..3a6e1a6046
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/BBoxSerializer.java
@@ -0,0 +1,20 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.shapes.BBox;
+
+import java.io.IOException;
+
+class BBoxSerializer extends JsonSerializer<BBox> {
+    @Override
+    public void serialize(BBox bBox, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
+        jsonGenerator.writeStartArray();
+        for (Double number : bBox.toGeoJson()) {
+            jsonGenerator.writeNumber(number);
+        }
+        jsonGenerator.writeEndArray();
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/CmdArgsDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/CmdArgsDeserializer.java
new file mode 100644
index 0000000000..4db81e5406
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/CmdArgsDeserializer.java
@@ -0,0 +1,24 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.util.CmdArgs;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class CmdArgsDeserializer extends JsonDeserializer<CmdArgs> {
+
+    private static final TypeReference<Map<String,String>> MAP_STRING_STRING
+            = new TypeReference<Map<String,String>>() {};
+
+    @Override
+    public CmdArgs deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
+        jsonParser.setCodec(new ObjectMapper());
+        Map<String, String> args = jsonParser.readValueAs(MAP_STRING_STRING);
+        return new CmdArgs(args);
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GHPointDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/GHPointDeserializer.java
new file mode 100644
index 0000000000..ce3f49fff1
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GHPointDeserializer.java
@@ -0,0 +1,17 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.io.IOException;
+
+class GHPointDeserializer extends JsonDeserializer<GHPoint> {
+    @Override
+    public GHPoint deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
+        double[] bounds = jsonParser.readValueAs(double[].class);
+        return GHPoint.fromJson(bounds);
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GHPointSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/GHPointSerializer.java
new file mode 100644
index 0000000000..57ecec6b4f
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GHPointSerializer.java
@@ -0,0 +1,20 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.io.IOException;
+
+class GHPointSerializer extends JsonSerializer<GHPoint> {
+    @Override
+    public void serialize(GHPoint ghPoint, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
+        jsonGenerator.writeStartArray();
+        for (Double number : ghPoint.toGeoJson()) {
+            jsonGenerator.writeNumber(number);
+        }
+        jsonGenerator.writeEndArray();
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
new file mode 100644
index 0000000000..c26a46e270
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
@@ -0,0 +1,25 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.graphhopper.MultiException;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.details.PathDetail;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+
+public class GraphHopperModule extends SimpleModule {
+
+    public GraphHopperModule() {
+        addDeserializer(BBox.class, new BBoxDeserializer());
+        addSerializer(BBox.class, new BBoxSerializer());
+        addDeserializer(GHPoint.class, new GHPointDeserializer());
+        addSerializer(GHPoint.class, new GHPointSerializer());
+        addDeserializer(PathDetail.class, new PathDetailDeserializer());
+        addSerializer(PathDetail.class, new PathDetailSerializer());
+        addSerializer(InstructionList.class, new InstructionListSerializer());
+        addDeserializer(CmdArgs.class, new CmdArgsDeserializer());
+        addSerializer(MultiException.class, new MultiExceptionSerializer());
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
new file mode 100644
index 0000000000..f584c82d15
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
@@ -0,0 +1,15 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.InstructionList;
+
+import java.io.IOException;
+
+public class InstructionListSerializer extends JsonSerializer<InstructionList> {
+    @Override
+    public void serialize(InstructionList instructions, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
+        jsonGenerator.writeObject(instructions.createJson());
+    }
+}
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
similarity index 72%
rename from reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
rename to web-api/src/main/java/com/graphhopper/jackson/Jackson.java
index b27ffa9004..15f8532eb5 100644
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonFactory.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
@@ -15,20 +15,18 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.json;
+package com.graphhopper.jackson;
 
 import com.bedatadriven.jackson.datatype.jts.JtsModule;
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.*;
 
-/**
- * This class wraps the creation of the specific GHJson implementation.
- *
- * @author Peter Karich
- */
-public class GHJsonFactory {
-    public GHJson create() {
+public class Jackson {
+    public static ObjectMapper newObjectMapper() {
         ObjectMapper objectMapper = new ObjectMapper();
+        objectMapper.registerModule(new GraphHopperModule());
         objectMapper.registerModule(new JtsModule());
-        return new GHJsonJackson(objectMapper);
+        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+        return objectMapper;
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java
new file mode 100644
index 0000000000..b7798eb9a8
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/MultiExceptionSerializer.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.MultiException;
+import com.graphhopper.util.exceptions.GHException;
+
+import java.io.IOException;
+import java.util.List;
+
+public class MultiExceptionSerializer extends JsonSerializer<MultiException> {
+
+    @Override
+    public void serialize(MultiException e, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
+        List<Throwable> errors = e.getErrors();
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.put("message", getMessage(errors.get(0)));
+        ArrayNode errorHintList = json.putArray("hints");
+        for (Throwable t : errors) {
+            ObjectNode error = errorHintList.addObject();
+            error.put("message", getMessage(t));
+            error.put("details", t.getClass().getName());
+            if (t instanceof GHException) {
+                ((GHException) t).getDetails().forEach(error::putPOJO);
+            }
+        }
+        jsonGenerator.writeObject(json);
+    }
+
+    private static String getMessage(Throwable t) {
+        if (t.getMessage() == null)
+            return t.getClass().getSimpleName();
+        else
+            return t.getMessage();
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathDetailDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathDetailDeserializer.java
new file mode 100644
index 0000000000..208edd1329
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathDetailDeserializer.java
@@ -0,0 +1,42 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParseException;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.util.details.PathDetail;
+
+import java.io.IOException;
+
+public class PathDetailDeserializer extends JsonDeserializer<PathDetail> {
+
+    @Override
+    public PathDetail deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
+        JsonNode pathDetail = jp.readValueAsTree();
+        if (pathDetail.size() != 3)
+            throw new JsonParseException(jp, "PathDetail array must have exactly 3 entries but was " + pathDetail.size());
+
+        JsonNode from = pathDetail.get(0);
+        JsonNode to = pathDetail.get(1);
+        JsonNode val = pathDetail.get(2);
+
+        PathDetail pd;
+        if (val.isBoolean())
+            pd = new PathDetail(val.asBoolean());
+        else if (val.isLong())
+            pd = new PathDetail(val.asLong());
+        else if (val.isInt())
+            pd = new PathDetail(val.asInt());
+        else if (val.isDouble())
+            pd = new PathDetail(val.asDouble());
+        else if (val.isTextual())
+            pd = new PathDetail(val.asText());
+        else
+            throw new JsonParseException(jp, "Unsupported type of PathDetail value " + pathDetail.getNodeType().name());
+
+        pd.setFirst(from.asInt());
+        pd.setLast(to.asInt());
+        return pd;
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java
new file mode 100644
index 0000000000..db718902a2
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java
@@ -0,0 +1,35 @@
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonGenerationException;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.details.PathDetail;
+
+import java.io.IOException;
+
+public class PathDetailSerializer extends JsonSerializer<PathDetail> {
+
+    @Override
+    public void serialize(PathDetail value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
+        gen.writeStartArray();
+
+        gen.writeNumber(value.getFirst());
+        gen.writeNumber(value.getLast());
+
+        if (value.getValue() instanceof Double)
+            gen.writeNumber((Double) value.getValue());
+        else if (value.getValue() instanceof Long)
+            gen.writeNumber((Long) value.getValue());
+        else if (value.getValue() instanceof Integer)
+            gen.writeNumber((Integer) value.getValue());
+        else if (value.getValue() instanceof Boolean)
+            gen.writeBoolean((Boolean) value.getValue());
+        else if (value.getValue() instanceof String)
+            gen.writeString((String) value.getValue());
+        else
+            throw new JsonGenerationException("Unsupported type for PathDetail.value" + value.getValue().getClass(), gen);
+
+        gen.writeEndArray();
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
similarity index 81%
rename from web/src/test/java/com/graphhopper/http/WebHelperTest.java
rename to web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
index e1758b08e1..e78c4c302f 100644
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+import org.junit.Assert;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -30,10 +31,10 @@
     @Test
     public void testDecode() throws Exception {
         PointList list = WebHelper.decodePolyline("_p~iF~ps|U", 1, false);
-        assertEquals(Helper.createPointList(38.5, -120.2), list);
+        Assert.assertEquals(Helper.createPointList(38.5, -120.2), list);
 
         list = WebHelper.decodePolyline("_p~iF~ps|U_ulLnnqC_mqNvxq`@", 3, false);
-        assertEquals(Helper.createPointList(38.5, -120.2, 40.7, -120.95, 43.252, -126.453), list);
+        Assert.assertEquals(Helper.createPointList(38.5, -120.2, 40.7, -120.95, 43.252, -126.453), list);
     }
 
     @Test
@@ -61,10 +62,10 @@ public void testBoth() throws Exception {
     @Test
     public void testDecode3D() throws Exception {
         PointList list = WebHelper.decodePolyline("_p~iF~ps|Uo}@", 1, true);
-        assertEquals(Helper.createPointList3D(38.5, -120.2, 10), list);
+        Assert.assertEquals(Helper.createPointList3D(38.5, -120.2, 10), list);
 
         list = WebHelper.decodePolyline("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", 3, true);
-        assertEquals(Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234), list);
+        Assert.assertEquals(Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234), list);
     }
 
     @Test
@@ -73,4 +74,9 @@ public void testEncode3D() throws Exception {
         assertEquals("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", WebHelper.encodePolyline(
                 Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234)));
     }
+
+    @Test
+    public void testEncode1e6() throws Exception {
+        assertEquals("ohdfzAgt}bVoEL", WebHelper.encodePolyline(Helper.createPointList(47.827608, 12.123476, 47.827712, 12.123469), false, 1e6));
+    }
 }
diff --git a/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
new file mode 100644
index 0000000000..b013019705
--- /dev/null
+++ b/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
@@ -0,0 +1,119 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.json.geo;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+import org.junit.Assert;
+import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import static io.dropwizard.testing.FixtureHelpers.fixture;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Peter Karich
+ */
+public class JsonFeatureCollectionTest {
+    private final ObjectMapper objectMapper = Jackson.newObjectMapper();
+
+    @Test
+    public void testSerialization() throws IOException {
+        GeometryFactory geometryFactory = new GeometryFactory();
+
+        JsonFeatureCollection jsonFeatureCollection = new JsonFeatureCollection();
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("1");
+            HashMap<String, Object> properties = new HashMap<>();
+            properties.put("prop0", "value0");
+            jsonFeature.setProperties(properties);
+            jsonFeature.setGeometry(geometryFactory.createPoint(new Coordinate(102.0,0.5)));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("2");
+            Map<String, Object> properties = new LinkedHashMap<>();
+            properties.put("prop0", "value1");
+            properties.put("prop1", 2);
+            jsonFeature.setProperties(properties);
+            jsonFeature.setGeometry(geometryFactory.createLineString(new Coordinate[]{
+                    new Coordinate(102.0, 0.0),
+                    new Coordinate(103.0, 1.0),
+                    new Coordinate(104.0, 0.0),
+                    new Coordinate(105.0, 1.0)}));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("3");
+            Map<String, Object> properties = new LinkedHashMap<>();
+            properties.put("prop0", "value0");
+            Map<String, String> prop1 = new LinkedHashMap<>();
+            prop1.put("test", "a");
+            properties.put("prop1", prop1);
+            jsonFeature.setProperties(properties);
+            jsonFeature.setBbox(new BBox(102.0, 103.0, 0.0, 1));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+
+        String expected = objectMapper.writeValueAsString(
+                objectMapper.readValue(fixture("fixtures/geojson1.json"), JsonFeatureCollection.class));
+        assertEquals(objectMapper.writeValueAsString(jsonFeatureCollection), expected);
+    }
+
+    @Test
+    public void testDeserialization() throws IOException {
+        JsonFeatureCollection data = objectMapper.readValue(fixture("fixtures/geojson1.json"), JsonFeatureCollection.class);
+        Assert.assertEquals(3, data.getFeatures().size());
+
+        JsonFeature f1 = data.getFeatures().get(0);
+        Assert.assertEquals("1", f1.getId());
+        Assert.assertEquals("value0", f1.getProperty("prop0"));
+        Assert.assertEquals(0.5, f1.getGeometry().getCoordinate().y, .1);
+        Assert.assertEquals(102.0, f1.getGeometry().getCoordinate().x, .1);
+
+        JsonFeature f2 = data.getFeatures().get(1);
+        // read as string despite the 2 (not a string) in json
+        Assert.assertEquals("2", f2.getId());
+        Assert.assertEquals(4, f2.getGeometry().getNumPoints());
+        assertEquals(0.0, PointList.fromLineString((LineString) f2.getGeometry()).getLat(0), .1);
+        assertEquals(102.0, PointList.fromLineString((LineString) f2.getGeometry()).getLon(0), .1);
+        assertEquals(1.0, PointList.fromLineString((LineString) f2.getGeometry()).getLat(1), .1);
+        assertEquals(103.0, PointList.fromLineString((LineString) f2.getGeometry()).getLon(1), .1);
+
+        JsonFeature f3 = data.getFeatures().get(2);
+        assertEquals(0.0, f3.getBBox().minLat, 0.0);
+        assertEquals(102.0, f3.getBBox().minLon, 0.0);
+        assertEquals(1.0, f3.getBBox().maxLat, 0.0);
+        assertEquals(103.0, f3.getBBox().maxLon, 0.0);
+
+        assertEquals("a", ((Map) f3.getProperty("prop1")).get("test"));
+    }
+
+}
diff --git a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
new file mode 100644
index 0000000000..e878add342
--- /dev/null
+++ b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
@@ -0,0 +1,94 @@
+package com.graphhopper.util;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.Test;
+
+import java.util.Collections;
+import java.util.Locale;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+public class InstructionListRepresentationTest {
+
+    @Test
+    public void testRoundaboutJsonIntegrity() {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(write(json));
+    }
+
+    private String write(Map<String, Object> json) {
+        try {
+            return new ObjectMapper().writeValueAsString(json);
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN() {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(write(json));
+    }
+
+    static Translation usTR = new Translation() {
+        @Override
+        public String tr(String key, Object... params) {
+            if (key.equals("roundabout_exit_onto"))
+                return "At roundabout, take exit 2 onto streetname";
+            return key;
+        }
+
+        @Override
+        public Map<String, String> asMap() {
+            return Collections.emptyMap();
+        }
+
+        @Override
+        public Locale getLocale() {
+            return Locale.US;
+        }
+
+        @Override
+        public String getLanguage() {
+            return "en";
+        }
+    };
+}
diff --git a/reader-json/src/test/resources/com/graphhopper/json/geo/geojson1.json b/web-api/src/test/resources/fixtures/geojson1.json
similarity index 95%
rename from reader-json/src/test/resources/com/graphhopper/json/geo/geojson1.json
rename to web-api/src/test/resources/fixtures/geojson1.json
index d951eddd08..492aaac9a1 100644
--- a/reader-json/src/test/resources/com/graphhopper/json/geo/geojson1.json
+++ b/web-api/src/test/resources/fixtures/geojson1.json
@@ -27,7 +27,7 @@
         {
             "id": 3,
             "type": "Feature",
-            "bbox": [0.0, 1, 102.0, 103.0],
+            "bbox": [102.0, 0.0, 103.0, 1],
             "properties": {
                 "prop0": "value0",
                 "prop1": {
diff --git a/web-bundle/pom.xml b/web-bundle/pom.xml
new file mode 100644
index 0000000000..6759685bdc
--- /dev/null
+++ b/web-bundle/pom.xml
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-web-bundle</artifactId>
+    <packaging>jar</packaging>
+    <version>0.12-SNAPSHOT</version>
+    <name>GraphHopper Dropwizard Bundle</name>
+    <description>Use the GraphHopper routing engine as a web-service</description>
+
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.12-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-web-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-reader-osm</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-reader-gtfs</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-isochrone</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+
+        <!-- required for JDK9 -->
+        <dependency>
+            <groupId>javax.xml.ws</groupId>
+            <artifactId>jaxws-api</artifactId>
+            <version>2.3.0</version>
+        </dependency>
+        <!-- required for dropwizard -->
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>24.0-jre</version>
+        </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-core</artifactId>
+            <version>${dropwizard.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-testing</artifactId>
+            <version>${dropwizard.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- for integration tests of service -->
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>directions-api-client-hc</artifactId>
+            <version>${project.parent.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>directions-api-client</artifactId>
+            <version>${directions-api-client.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
+
+
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java b/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java
new file mode 100644
index 0000000000..7ebca5dac4
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+import com.graphhopper.util.shapes.GHPoint;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ParamConverter;
+import javax.ws.rs.ext.ParamConverterProvider;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class GHPointConverterProvider implements ParamConverterProvider {
+
+    @Override
+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
+        if (rawType.equals(GHPoint.class)) {
+            return new ParamConverter<T>() {
+                @Override
+                public T fromString(String value) {
+                    try {
+                        return (T) GHPoint.fromString(value);
+                    } catch (IllegalArgumentException ex) {
+                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
+                                .entity(new MultiException(ex))
+                                .build());
+                    }
+                }
+
+                @Override
+                public String toString(T value) {
+                    return value.toString();
+                }
+            };
+        }
+        return null;
+    }
+}
+
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
similarity index 67%
rename from web/src/main/java/com/graphhopper/http/GraphHopperBundle.java
rename to web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index 1771a19ad0..8e8c08ec5d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -18,29 +18,35 @@
 
 package com.graphhopper.http;
 
-import com.fasterxml.jackson.core.JsonGenerationException;
+import com.bedatadriven.jackson.datatype.jts.JtsModule;
+import com.fasterxml.jackson.annotation.JsonInclude;
 import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonParseException;
-import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.BeanDescription;
+import com.fasterxml.jackson.databind.SerializationConfig;
+import com.fasterxml.jackson.databind.SerializerProvider;
 import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
+import com.fasterxml.jackson.databind.util.StdDateFormat;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.http.health.GraphHopperHealthCheck;
 import com.graphhopper.http.health.GraphHopperStorageHealthCheck;
-import com.graphhopper.http.resources.*;
-import com.graphhopper.isochrone.algorithm.RasterHullBuilder;
+import com.graphhopper.isochrone.algorithm.DelaunayTriangulationIsolineBuilder;
+import com.graphhopper.jackson.GraphHopperModule;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
 import com.graphhopper.reader.gtfs.RealtimeFeed;
+import com.graphhopper.resources.*;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.TranslationMap;
-import com.graphhopper.util.details.PathDetail;
 import io.dropwizard.ConfiguredBundle;
 import io.dropwizard.lifecycle.Managed;
 import io.dropwizard.setup.Bootstrap;
@@ -49,11 +55,11 @@
 import org.glassfish.hk2.utilities.binding.AbstractBinder;
 
 import javax.inject.Inject;
-import javax.servlet.DispatcherType;
-import java.io.IOException;
+import javax.ws.rs.ext.WriterInterceptor;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.EnumSet;
+import java.util.List;
+import java.util.stream.Collectors;
 
 public class GraphHopperBundle implements ConfiguredBundle<GraphHopperBundleConfiguration> {
 
@@ -137,52 +143,78 @@ public void dispose(Boolean instance) {
         }
     }
 
-    static class RasterHullBuilderFactory implements Factory<RasterHullBuilder> {
+    static class RasterHullBuilderFactory implements Factory<DelaunayTriangulationIsolineBuilder> {
 
-        RasterHullBuilder builder = new RasterHullBuilder();
+        DelaunayTriangulationIsolineBuilder builder = new DelaunayTriangulationIsolineBuilder();
 
         @Override
-        public RasterHullBuilder provide() {
+        public DelaunayTriangulationIsolineBuilder provide() {
             return builder;
         }
 
         @Override
-        public void dispose(RasterHullBuilder rasterHullBuilder) {
+        public void dispose(DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder) {
         }
     }
 
     @Override
     public void initialize(Bootstrap<?> bootstrap) {
-
+        bootstrap.getObjectMapper().setDateFormat(new StdDateFormat());
+        bootstrap.getObjectMapper().registerModule(new JtsModule());
+        bootstrap.getObjectMapper().registerModule(new GraphHopperModule());
+        bootstrap.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
+        // Because VirtualEdgeIteratorState has getters which throw Exceptions.
+        // http://stackoverflow.com/questions/35359430/how-to-make-jackson-ignore-properties-if-the-getters-throw-exceptions
+        bootstrap.getObjectMapper().registerModule(new SimpleModule().setSerializerModifier(new BeanSerializerModifier() {
+            @Override
+            public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
+                return beanProperties.stream().map(bpw -> new BeanPropertyWriter(bpw) {
+                    @Override
+                    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
+                        try {
+                            super.serializeAsField(bean, gen, prov);
+                        } catch (Exception e) {
+                            // Ignoring expected exception, see above.
+                        }
+                    }
+                }).collect(Collectors.toList());
+            }
+        }));
     }
 
     @Override
     public void run(GraphHopperBundleConfiguration configuration, Environment environment) {
         configuration.getGraphHopperConfiguration().merge(CmdArgs.readFromSystemProperties());
 
+        // If the "?type=gpx" parameter is present, sets a corresponding media type header
+        environment.jersey().register(new TypeGPXFilter());
+
+        // Together, these two take care that MultiExceptions thrown from RouteResource
+        // come out as JSON or GPX, depending on the media type
+        environment.jersey().register(new MultiExceptionMapper());
+        environment.jersey().register(new MultiExceptionGPXMessageBodyWriter());
+
+        environment.jersey().register(new IllegalArgumentExceptionMapper());
+        environment.jersey().register(new GHPointConverterProvider());
+
         if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
             // switch to different API implementation when using Pt
             runPtGraphHopper(configuration.getGraphHopperConfiguration(), environment);
         } else {
             runRegularGraphHopper(configuration.getGraphHopperConfiguration(), environment);
         }
-
-        environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
-        environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
-
     }
 
     private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.get("graph.location", "target/tmp"));
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
+        final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 8);
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
-                configuration.getBool("gtfs.createwalknetwork", false),
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
-        final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage, ptFlagEncoder);
+        final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage);
         final GraphHopperAPI graphHopper = new GraphHopperGtfs(ptFlagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
         environment.jersey().register(new AbstractBinder() {
             @Override
@@ -194,14 +226,25 @@ protected void configure() {
                 bind(translationMap).to(TranslationMap.class);
                 bind(encodingManager).to(EncodingManager.class);
                 bind(graphHopperStorage).to(GraphHopperStorage.class);
-                bindFactory(RasterHullBuilderFactory.class).to(RasterHullBuilder.class);
+                bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
         environment.jersey().register(NearestResource.class);
         environment.jersey().register(RouteResource.class);
-        environment.jersey().register(IsochroneResource.class);
+        environment.jersey().register(new PtIsochroneResource(gtfsStorage, encodingManager, graphHopperStorage, locationIndex));
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
+        // Say we only support pt, even though we now have several flag encoders. Yes, I know, we're almost there.
+        environment.jersey().register((WriterInterceptor) context -> {
+            if (context.getEntity() instanceof InfoResource.Info) {
+                InfoResource.Info info = (InfoResource.Info) context.getEntity();
+                info.supported_vehicles = new String[]{"pt"};
+                info.features.remove("car");
+                info.features.remove("foot");
+                context.setEntity(info);
+            }
+            context.proceed();
+        });
         environment.lifecycle().manage(new Managed() {
             @Override
             public void start() throws Exception {
@@ -217,7 +260,7 @@ public void stop() throws Exception {
     }
 
     private void runRegularGraphHopper(CmdArgs configuration, Environment environment) {
-        final GraphHopperManaged graphHopperManaged = new GraphHopperManaged(configuration);
+        final GraphHopperManaged graphHopperManaged = new GraphHopperManaged(configuration, environment.getObjectMapper());
         environment.lifecycle().manage(graphHopperManaged);
         environment.jersey().register(new AbstractBinder() {
             @Override
@@ -232,7 +275,7 @@ protected void configure() {
                 bindFactory(TranslationMapFactory.class).to(TranslationMap.class);
                 bindFactory(EncodingManagerFactory.class).to(EncodingManager.class);
                 bindFactory(GraphHopperStorageFactory.class).to(GraphHopperStorage.class);
-                bindFactory(RasterHullBuilderFactory.class).to(RasterHullBuilder.class);
+                bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
 
@@ -244,68 +287,7 @@ protected void configure() {
         environment.jersey().register(IsochroneResource.class);
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
-
-        SimpleModule pathDetailModule = new SimpleModule();
-        pathDetailModule.addSerializer(PathDetail.class, new PathDetailSerializer());
-        pathDetailModule.addDeserializer(PathDetail.class, new PathDetailDeserializer());
-        environment.getObjectMapper().registerModule(pathDetailModule);
         environment.healthChecks().register("graphhopper", new GraphHopperHealthCheck(graphHopperManaged.getGraphHopper()));
     }
 
-    public static class PathDetailSerializer extends JsonSerializer<PathDetail> {
-
-        @Override
-        public void serialize(PathDetail value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
-            gen.writeStartArray();
-
-            gen.writeNumber(value.getFirst());
-            gen.writeNumber(value.getLast());
-
-            if (value.getValue() instanceof Double)
-                gen.writeNumber((Double) value.getValue());
-            else if (value.getValue() instanceof Long)
-                gen.writeNumber((Long) value.getValue());
-            else if (value.getValue() instanceof Integer)
-                gen.writeNumber((Integer) value.getValue());
-            else if (value.getValue() instanceof Boolean)
-                gen.writeBoolean((Boolean) value.getValue());
-            else if (value.getValue() instanceof String)
-                gen.writeString((String) value.getValue());
-            else
-                throw new JsonGenerationException("Unsupported type for PathDetail.value" + value.getValue().getClass(), gen);
-
-            gen.writeEndArray();
-        }
-    }
-
-    public static class PathDetailDeserializer extends JsonDeserializer<PathDetail> {
-
-        @Override
-        public PathDetail deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
-            JsonNode pathDetail = jp.readValueAsTree();
-            if (pathDetail.size() != 3)
-                throw new JsonParseException(jp, "PathDetail array must have exactly 3 entries but was " + pathDetail.size());
-
-            JsonNode from = pathDetail.get(0);
-            JsonNode to = pathDetail.get(1);
-            JsonNode val = pathDetail.get(2);
-
-            PathDetail pd;
-            if (val.isBoolean())
-                pd = new PathDetail(val.asBoolean());
-            else if (val.isLong())
-                pd = new PathDetail(val.asLong());
-            else if (val.isDouble())
-                pd = new PathDetail(val.asDouble());
-            else if (val.isTextual())
-                pd = new PathDetail(val.asText());
-            else
-                throw new JsonParseException(jp, "Unsupported type of PathDetail value " + pathDetail.getNodeType().name());
-
-            pd.setFirst(from.asInt());
-            pd.setLast(to.asInt());
-            return pd;
-        }
-    }
-
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperBundleConfiguration.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundleConfiguration.java
similarity index 100%
rename from web/src/main/java/com/graphhopper/http/GraphHopperBundleConfiguration.java
rename to web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundleConfiguration.java
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
new file mode 100644
index 0000000000..03bb4fbb73
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
@@ -0,0 +1,88 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.lm.LandmarkStorage;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupHelper;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.BBox;
+import io.dropwizard.lifecycle.Managed;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import static com.graphhopper.util.Helper.UTF_CS;
+
+public class GraphHopperManaged implements Managed {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final GraphHopper graphHopper;
+
+    public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
+        String splitAreaLocation = configuration.get(Parameters.Landmark.PREPARE + "split_area_location", "");
+        JsonFeatureCollection landmarkSplittingFeatureCollection;
+        try (Reader reader = splitAreaLocation.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(splitAreaLocation), UTF_CS)) {
+            landmarkSplittingFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+        } catch (IOException e1) {
+            logger.error("Problem while reading border map GeoJSON. Skipping this.", e1);
+            landmarkSplittingFeatureCollection = null;
+        }
+        graphHopper = new GraphHopperOSM(landmarkSplittingFeatureCollection).forServer();
+        String spatialRuleLocation = configuration.get("spatial_rules.location", "");
+        if (!spatialRuleLocation.isEmpty()) {
+            final BBox maxBounds = BBox.parseBBoxString(configuration.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
+            try (final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS)) {
+                JsonFeatureCollection jsonFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+                SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, maxBounds, jsonFeatureCollection);
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        graphHopper.init(configuration);
+    }
+
+    @Override
+    public void start() {
+        graphHopper.importOrLoad();
+        logger.info("loaded graph at:" + graphHopper.getGraphHopperLocation()
+                + ", data_reader_file:" + graphHopper.getDataReaderFile()
+                + ", flag_encoders:" + graphHopper.getEncodingManager()
+                + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
+    }
+
+    GraphHopper getGraphHopper() {
+        return graphHopper;
+    }
+
+    @Override
+    public void stop() {
+        graphHopper.close();
+    }
+
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
new file mode 100644
index 0000000000..f548ffc1ff
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
@@ -0,0 +1,16 @@
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+
+public class IllegalArgumentExceptionMapper implements ExceptionMapper<IllegalArgumentException> {
+
+    @Override
+    public Response toResponse(IllegalArgumentException e) {
+        return Response.status(Response.Status.BAD_REQUEST)
+                .entity(new MultiException(e))
+                .build();
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java
new file mode 100644
index 0000000000..2f53c12107
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionGPXMessageBodyWriter.java
@@ -0,0 +1,99 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+import javax.ws.rs.Produces;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Provider;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+@Provider
+@Produces("application/gpx+xml")
+public class MultiExceptionGPXMessageBodyWriter implements MessageBodyWriter<MultiException> {
+
+    @Override
+    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
+        return true;
+    }
+
+    @Override
+    public long getSize(MultiException e, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
+        return -1;
+    }
+
+    @Override
+    public void writeTo(MultiException e, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
+        if (e.getErrors().isEmpty())
+            throw new RuntimeException("errorsToXML should not be called with an empty list");
+
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
+
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
+
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
+
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(e.getErrors().iterator().next().getMessage());
+
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
+
+            for (Throwable t : e.getErrors()) {
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                error.setAttribute("details", t.getClass().getName());
+            }
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            transformer.transform(new DOMSource(doc), new StreamResult(entityStream));
+        } catch (ParserConfigurationException | TransformerException e2) {
+            throw new RuntimeException(e2);
+        }
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/IntIterator.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
similarity index 65%
rename from core/src/main/java/com/graphhopper/storage/IntIterator.java
rename to web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
index 90e7455331..03c87e3819 100644
--- a/core/src/main/java/com/graphhopper/storage/IntIterator.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
@@ -15,25 +15,19 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage;
 
-/**
- * @author Peter Karich
- */
-public interface IntIterator {
-    boolean next();
+package com.graphhopper.http;
 
-    int getValue();
+import com.graphhopper.MultiException;
 
-    void remove();
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
 
-    class Helper {
-        public static int count(IntIterator iter) {
-            int counter = 0;
-            while (iter.next()) {
-                ++counter;
-            }
-            return counter;
-        }
+@Provider
+public class MultiExceptionMapper implements ExceptionMapper<MultiException> {
+    @Override
+    public Response toResponse(MultiException exception) {
+        return Response.status(Response.Status.BAD_REQUEST).entity(exception).build();
     }
 }
diff --git a/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java b/web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java
similarity index 55%
rename from reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
rename to web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java
index cf835aca07..7c38043c3d 100644
--- a/reader-json/src/main/java/com/graphhopper/json/GHJsonJackson.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/TypeGPXFilter.java
@@ -15,26 +15,26 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.json;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
+package com.graphhopper.http;
 
-import java.io.IOException;
-import java.io.Reader;
+import javax.annotation.Priority;
+import javax.ws.rs.Priorities;
+import javax.ws.rs.container.ContainerRequestContext;
+import javax.ws.rs.container.ContainerRequestFilter;
+import javax.ws.rs.container.PreMatching;
+import javax.ws.rs.core.HttpHeaders;
 
-class GHJsonJackson implements GHJson {
-    private final ObjectMapper objectMapper;
-
-    GHJsonJackson(ObjectMapper om) {
-        this.objectMapper = om;
-    }
+@PreMatching
+@Priority(Priorities.HEADER_DECORATOR)
+public class TypeGPXFilter implements ContainerRequestFilter {
 
     @Override
-    public <T> T fromJson(Reader source, Class<T> aClass) {
-        try {
-            return objectMapper.readValue(source, aClass);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
+    public void filter(ContainerRequestContext rc) {
+        String maybeType = rc.getUriInfo().getQueryParameters().getFirst("type");
+        if (maybeType != null && maybeType.equals("gpx")) {
+            rc.getHeaders().putSingle(HttpHeaders.ACCEPT, "application/gpx+xml");
         }
     }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/health/GraphHopperHealthCheck.java b/web-bundle/src/main/java/com/graphhopper/http/health/GraphHopperHealthCheck.java
similarity index 100%
rename from web/src/main/java/com/graphhopper/http/health/GraphHopperHealthCheck.java
rename to web-bundle/src/main/java/com/graphhopper/http/health/GraphHopperHealthCheck.java
diff --git a/web/src/main/java/com/graphhopper/http/health/GraphHopperStorageHealthCheck.java b/web-bundle/src/main/java/com/graphhopper/http/health/GraphHopperStorageHealthCheck.java
similarity index 100%
rename from web/src/main/java/com/graphhopper/http/health/GraphHopperStorageHealthCheck.java
rename to web-bundle/src/main/java/com/graphhopper/http/health/GraphHopperStorageHealthCheck.java
diff --git a/web/src/main/java/com/graphhopper/http/resources/ChangeGraphResource.java b/web-bundle/src/main/java/com/graphhopper/resources/ChangeGraphResource.java
similarity index 97%
rename from web/src/main/java/com/graphhopper/http/resources/ChangeGraphResource.java
rename to web-bundle/src/main/java/com/graphhopper/resources/ChangeGraphResource.java
index a1504f4107..4480c06f7f 100644
--- a/web/src/main/java/com/graphhopper/http/resources/ChangeGraphResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/ChangeGraphResource.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http.resources;
+package com.graphhopper.resources;
 
 import com.codahale.metrics.annotation.Timed;
 import com.graphhopper.GraphHopper;
diff --git a/web/src/main/java/com/graphhopper/http/resources/I18NResource.java b/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
similarity index 91%
rename from web/src/main/java/com/graphhopper/http/resources/I18NResource.java
rename to web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
index 95401c3d9f..095f0660ff 100644
--- a/web/src/main/java/com/graphhopper/http/resources/I18NResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/I18NResource.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http.resources;
+package com.graphhopper.resources;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.util.Translation;
@@ -44,11 +44,14 @@ public I18NResource(TranslationMap map) {
     public static class Response {
         public String locale;
         public Map<String, String> en;
-        @JsonProperty("default") public Map<String, String> defaultTr;
+        @JsonProperty("default")
+        public Map<String, String> defaultTr;
     }
 
     @GET
     public Response getFromHeader(@HeaderParam("Accept-Language") String acceptLang) {
+        if (acceptLang == null)
+            return get("");
         return get(acceptLang.split(",")[0]);
     }
 
diff --git a/web/src/main/java/com/graphhopper/http/resources/InfoResource.java b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
similarity index 91%
rename from web/src/main/java/com/graphhopper/http/resources/InfoResource.java
rename to web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
index 8229416676..dcf060a784 100644
--- a/web/src/main/java/com/graphhopper/http/resources/InfoResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http.resources;
+package com.graphhopper.resources;
 
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.Constants;
@@ -65,7 +65,8 @@ public InfoResource(GraphHopperStorage storage, @Named("hasElevation") Boolean h
     @GET
     public Info getInfo() {
         final Info info = new Info();
-        info.bbox = storage.getBounds();
+        // use bbox always without elevation (for backward compatibility)
+        info.bbox = new BBox(storage.getBounds().minLon, storage.getBounds().maxLon, storage.getBounds().minLat, storage.getBounds().maxLat);
         info.supported_vehicles = storage.getEncodingManager().toString().split(",");
         for (String v : info.supported_vehicles) {
             Info.PerVehicle perVehicleJson = new Info.PerVehicle();
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
new file mode 100644
index 0000000000..4bf2790cfa
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -0,0 +1,149 @@
+package com.graphhopper.resources;
+
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.isochrone.algorithm.Isochrone;
+import com.graphhopper.isochrone.algorithm.DelaunayTriangulationIsolineBuilder;
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.shapes.GHPoint;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.inject.Inject;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriInfo;
+import java.util.*;
+
+@Path("isochrone")
+public class IsochroneResource {
+
+    private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
+
+    private final GraphHopper graphHopper;
+    private final EncodingManager encodingManager;
+    private final DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
+
+    @Inject
+    public IsochroneResource(GraphHopper graphHopper, EncodingManager encodingManager, DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder) {
+        this.graphHopper = graphHopper;
+        this.encodingManager = encodingManager;
+        this.delaunayTriangulationIsolineBuilder = delaunayTriangulationIsolineBuilder;
+    }
+
+    @GET
+    @Produces({MediaType.APPLICATION_JSON})
+    public Response doGet(
+            @Context HttpServletRequest httpReq,
+            @Context UriInfo uriInfo,
+            @QueryParam("vehicle") @DefaultValue("car") String vehicle,
+            @QueryParam("buckets") @DefaultValue("1") int nBuckets,
+            @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
+            @QueryParam("point") GHPoint point,
+            @QueryParam("result") @DefaultValue("polygon") String resultStr,
+            @QueryParam("time_limit") @DefaultValue("600") long timeLimitInSeconds,
+            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
+
+        if (nBuckets > 20 || nBuckets < 1)
+            throw new IllegalArgumentException("Number of buckets has to be in the range [1, 20]");
+
+        if (point == null)
+            throw new IllegalArgumentException("point parameter cannot be null");
+
+        StopWatch sw = new StopWatch().start();
+
+        if (!encodingManager.supports(vehicle))
+            throw new IllegalArgumentException("vehicle not supported:" + vehicle);
+
+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+        EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
+        LocationIndex locationIndex = graphHopper.getLocationIndex();
+        QueryResult qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+        if (!qr.isValid())
+            throw new IllegalArgumentException("Point not found:" + point);
+
+        Graph graph = graphHopper.getGraphHopperStorage();
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.singletonList(qr));
+
+        HintsMap hintsMap = new HintsMap();
+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());
+
+        Weighting weighting = graphHopper.createWeighting(hintsMap, encoder, graph);
+        Isochrone isochrone = new Isochrone(queryGraph, weighting, reverseFlow);
+
+        if (distanceInMeter > 0) {
+            isochrone.setDistanceLimit(distanceInMeter);
+        } else {
+            isochrone.setTimeLimit(timeLimitInSeconds);
+        }
+
+        List<List<Coordinate>> buckets = isochrone.searchGPS(qr.getClosestNode(), nBuckets);
+        if (isochrone.getVisitedNodes() > graphHopper.getMaxVisitedNodes() / 5) {
+            throw new IllegalArgumentException("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
+        }
+
+        int counter = 0;
+        for (List<Coordinate> bucket : buckets) {
+            if (bucket.size() < 2) {
+                throw new IllegalArgumentException("Too few points found for bucket " + counter + ". "
+                        + "Please try a different 'point', a smaller 'buckets' count or a larger 'time_limit'. "
+                        + "And let us know if you think this is a bug!");
+            }
+            counter++;
+        }
+
+        if ("pointlist".equalsIgnoreCase(resultStr)) {
+            sw.stop();
+            logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
+            return Response.fromResponse(jsonSuccessResponse(buckets, sw.getSeconds()))
+                    .header("X-GH-Took", "" + sw.getSeconds() * 1000)
+                    .build();
+        } else if ("polygon".equalsIgnoreCase(resultStr)) {
+            ArrayList<JsonFeature> features = new ArrayList<>();
+            List<Coordinate[]> polygonShells = delaunayTriangulationIsolineBuilder.calcList(buckets, buckets.size() - 1);
+            for (Coordinate[] polygonShell : polygonShells) {
+                JsonFeature feature = new JsonFeature();
+                HashMap<String, Object> properties = new HashMap<>();
+                properties.put("bucket", features.size());
+                feature.setProperties(properties);
+                feature.setGeometry(geometryFactory.createPolygon(polygonShell));
+                features.add(feature);
+            }
+            sw.stop();
+            logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
+            return Response.fromResponse(jsonSuccessResponse(features, sw.getSeconds()))
+                    .header("X-GH-Took", "" + sw.getSeconds() * 1000)
+                    .build();
+        } else {
+            throw new IllegalArgumentException("type not supported:" + resultStr);
+        }
+    }
+
+    private Response jsonSuccessResponse(Object result, float took) {
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.putPOJO("polygons", result);
+        // If you replace GraphHopper with your own brand name, this is fine.
+        // Still it would be highly appreciated if you mention us in your about page!
+        final ObjectNode info = json.putObject("info");
+        info.putArray("copyrights")
+                .add("GraphHopper")
+                .add("OpenStreetMap contributors");
+        info.put("took", Math.round(took * 1000));
+        return Response.ok(json).build();
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/resources/NearestResource.java b/web-bundle/src/main/java/com/graphhopper/resources/NearestResource.java
similarity index 98%
rename from web/src/main/java/com/graphhopper/http/resources/NearestResource.java
rename to web-bundle/src/main/java/com/graphhopper/resources/NearestResource.java
index 5d434f7391..9de7512947 100644
--- a/web/src/main/java/com/graphhopper/http/resources/NearestResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/NearestResource.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http.resources;
+package com.graphhopper.resources;
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
new file mode 100644
index 0000000000..9a39461cdf
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -0,0 +1,225 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.resources;
+
+import com.graphhopper.isochrone.algorithm.ContourBuilder;
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.reader.gtfs.*;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.GHPoint;
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.index.strtree.STRtree;
+import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
+import org.locationtech.jts.triangulate.ConstraintVertex;
+import org.locationtech.jts.triangulate.DelaunayTriangulationBuilder;
+import org.locationtech.jts.triangulate.quadedge.QuadEdge;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.triangulate.quadedge.Vertex;
+
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
+import java.time.Instant;
+import java.util.*;
+import java.util.function.Function;
+
+@Path("isochrone")
+public class PtIsochroneResource {
+
+    private static final double JTS_TOLERANCE = 0.00001;
+
+    private GtfsStorage gtfsStorage;
+    private EncodingManager encodingManager;
+    private GraphHopperStorage graphHopperStorage;
+    private LocationIndex locationIndex;
+//    private final STRtree spatialIndex;
+
+    private final Function<Label, Double> z = label -> (double) label.currentTime;
+
+    public PtIsochroneResource(GtfsStorage gtfsStorage, EncodingManager encodingManager, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex) {
+        this.gtfsStorage = gtfsStorage;
+        this.encodingManager = encodingManager;
+        this.graphHopperStorage = graphHopperStorage;
+        this.locationIndex = locationIndex;
+//        spatialIndex = new STRtree();
+//        PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
+//        AllEdgesIterator allEdges = graphHopperStorage.getAllEdges();
+//        while (allEdges.next()) {
+//            if (ptFlagEncoder.getEdgeType(allEdges.getFlags()) == GtfsStorage.EdgeType.HIGHWAY) {
+//                LineString geom = allEdges.fetchWayGeometry(3).toLineString(false);
+//                spatialIndex.insert(geom.getEnvelopeInternal(), allEdges.getEdge());
+//            }
+//        }
+    }
+
+    public static class Response {
+        public static class Info {
+            public List<String> copyrights = new ArrayList<>();
+        }
+        public List<JsonFeature> polygons = new ArrayList<>();
+        public Info info = new Info();
+    }
+
+    @GET
+    @Produces({MediaType.APPLICATION_JSON})
+    public Response doGet(
+            @QueryParam("point") GHPoint source,
+            @QueryParam("time_limit") @DefaultValue("600") long seconds,
+            @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
+            @QueryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME) String departureTimeString,
+            @QueryParam(Parameters.PT.BLOCKED_ROUTE_TYPES) @DefaultValue("0") int blockedRouteTypes,
+            @QueryParam("result") @DefaultValue("multipolygon") String format) {
+        Instant initialTime;
+        try {
+            initialTime = Instant.parse(departureTimeString);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+
+        double targetZ = initialTime.toEpochMilli() + seconds * 1000;
+
+        GeometryFactory geometryFactory = new GeometryFactory();
+        QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+        QueryResult queryResult = locationIndex.findClosest(source.lat, source.lon, filter);
+        queryGraph.lookup(Collections.singletonList(queryResult));
+        if (!queryResult.isValid()) {
+            throw new IllegalArgumentException("Cannot find point: " + source);
+        }
+
+        PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
+        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, Collections.emptyList(), false, 5.0);
+        MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, ptFlagEncoder, reverseFlow, Double.MAX_VALUE, false, false, false, 1000000, Collections.emptyList());
+
+        Map<Coordinate, Double> z1 = new HashMap<>();
+        NodeAccess nodeAccess = queryGraph.getNodeAccess();
+
+        MultiCriteriaLabelSetting.SPTVisitor sptVisitor = nodeLabel -> {
+            Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(nodeLabel.adjNode), nodeAccess.getLatitude(nodeLabel.adjNode));
+            z1.merge(nodeCoordinate, this.z.apply(nodeLabel), Math::min);
+        };
+
+        if (format.equals("multipoint")) {
+            router.calcLabels(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
+            MultiPoint exploredPoints = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+            return wrap(exploredPoints);
+        } else {
+            router.calcLabelsAndNeighbors(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
+            MultiPoint exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+
+            // This is what we need to do once we can do bounding-box queries on our spatial index.
+            // Then it should be impossible for unreachable encroaching points to not be found.
+
+//            spatialIndex.query(exploredPointsAndNeighbors.getEnvelopeInternal(), edgeId -> {
+//                EdgeIteratorState e = graphHopperStorage.getEdgeIteratorState((int) edgeId, Integer.MIN_VALUE);
+//                Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getBaseNode()), nodeAccess.getLatitude(e.getBaseNode()));
+//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
+//                nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getAdjNode()), nodeAccess.getLatitude(e.getAdjNode()));
+//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
+//            });
+//            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+
+            CoordinateList siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(exploredPointsAndNeighbors);
+            List<ConstraintVertex> constraintVertices = new ArrayList<>();
+            for (Object siteCoord : siteCoords) {
+                Coordinate coord = (Coordinate) siteCoord;
+                constraintVertices.add(new ConstraintVertex(coord));
+            }
+
+            ConformingDelaunayTriangulator cdt = new ConformingDelaunayTriangulator(constraintVertices, JTS_TOLERANCE);
+            cdt.setConstraints(new ArrayList(), new ArrayList());
+            cdt.formInitialDelaunay();
+
+            QuadEdgeSubdivision tin = cdt.getSubdivision();
+
+            for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+                if (tin.isFrameVertex(vertex)) {
+                    vertex.setZ(Double.MAX_VALUE);
+                } else {
+                    Double aDouble = z1.get(vertex.getCoordinate());
+                    if (aDouble != null) {
+                        vertex.setZ(aDouble);
+                    } else {
+                        vertex.setZ(Double.MAX_VALUE);
+                    }
+                }
+            }
+
+            ContourBuilder contourBuilder = new ContourBuilder(tin);
+            MultiPolygon isoline = contourBuilder.computeIsoline(targetZ);
+
+            // debugging tool
+            if (format.equals("triangulation")) {
+                Response response = new Response();
+                for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+                    JsonFeature feature = new JsonFeature();
+                    feature.setGeometry(geometryFactory.createPoint(vertex.getCoordinate()));
+                    HashMap<String, Object> properties = new HashMap<>();
+                    properties.put("z", vertex.getZ());
+                    feature.setProperties(properties);
+                    response.polygons.add(feature);
+                }
+                for (QuadEdge edge : (Collection<QuadEdge>) tin.getPrimaryEdges(false)) {
+                    JsonFeature feature = new JsonFeature();
+                    feature.setGeometry(edge.toLineSegment().toGeometry(geometryFactory));
+                    HashMap<String, Object> properties = new HashMap<>();
+                    feature.setProperties(properties);
+                    response.polygons.add(feature);
+                }
+                JsonFeature feature = new JsonFeature();
+                feature.setGeometry(isoline);
+                HashMap<String, Object> properties = new HashMap<>();
+                properties.put("z", targetZ);
+                feature.setProperties(properties);
+                response.polygons.add(feature);
+                response.info.copyrights.add("GraphHopper");
+                response.info.copyrights.add("OpenStreetMap contributors");
+                return response;
+            } else {
+                return wrap(isoline);
+            }
+        }
+
+    }
+
+    private Response wrap(Geometry isoline) {
+        JsonFeature feature = new JsonFeature();
+        feature.setGeometry(isoline);
+        HashMap<String, Object> properties = new HashMap<>();
+        properties.put("bucket", 0);
+        feature.setProperties(properties);
+
+        Response response = new Response();
+        response.polygons.add(feature);
+        response.info.copyrights.add("GraphHopper");
+        response.info.copyrights.add("OpenStreetMap contributors");
+        return response;
+    }
+
+}
diff --git a/web/src/main/java/com/graphhopper/http/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
similarity index 77%
rename from web/src/main/java/com/graphhopper/http/resources/RouteResource.java
rename to web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 6441009107..517bbb51ee 100644
--- a/web/src/main/java/com/graphhopper/http/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -15,14 +15,17 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http.resources;
+package com.graphhopper.resources;
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.MultiException;
 import com.graphhopper.http.WebHelper;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
@@ -33,8 +36,12 @@
 import javax.inject.Named;
 import javax.servlet.http.HttpServletRequest;
 import javax.ws.rs.*;
+import javax.ws.rs.container.ContainerRequestContext;
 import javax.ws.rs.core.*;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 
 import static com.graphhopper.util.Parameters.Routing.*;
 
@@ -51,13 +58,11 @@
     private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
 
     private final GraphHopperAPI graphHopper;
-    private final EncodingManager encodingManager;
     private final Boolean hasElevation;
 
     @Inject
-    public RouteResource(GraphHopperAPI graphHopper, EncodingManager encodingManager, @Named("hasElevation") Boolean hasElevation) {
+    public RouteResource(GraphHopperAPI graphHopper, @Named("hasElevation") Boolean hasElevation) {
         this.graphHopper = graphHopper;
-        this.encodingManager = encodingManager;
         this.hasElevation = hasElevation;
     }
 
@@ -66,6 +71,7 @@ public RouteResource(GraphHopperAPI graphHopper, EncodingManager encodingManager
     public Response doGet(
             @Context HttpServletRequest httpReq,
             @Context UriInfo uriInfo,
+            @Context ContainerRequestContext rc,
             @QueryParam(WAY_POINT_MAX_DISTANCE) @DefaultValue("1") double minPathPrecision,
             @QueryParam("point") List<GHPoint> requestPoints,
             @QueryParam("type") @DefaultValue("json") String type,
@@ -90,22 +96,15 @@ public Response doGet(
 
         StopWatch sw = new StopWatch().start();
 
-        if(requestPoints.isEmpty()) {
-            throw new WebApplicationException(WebHelper.errorResponse(new IllegalArgumentException("You have to pass at least one point"), writeGPX));
-        }
-
-        if (!encodingManager.supports(vehicleStr)) {
-            throw new WebApplicationException(WebHelper.errorResponse(new IllegalArgumentException("Vehicle not supported: " + vehicleStr), writeGPX));
-        } else if (enableElevation && !hasElevation) {
-            throw new WebApplicationException(WebHelper.errorResponse(new IllegalArgumentException("Elevation not supported!"), writeGPX));
-        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size()) {
-            throw new WebApplicationException(WebHelper.errorResponse(new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
-                    + "or equal to the number of points (" + requestPoints.size() + ")"), writeGPX));
-        }
-
-        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size()) {
-            throw new WebApplicationException(WebHelper.errorResponse(new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored"), writeGPX));
-        }
+        if (requestPoints.isEmpty())
+            throw new IllegalArgumentException("You have to pass at least one point");
+        if (enableElevation && !hasElevation)
+            throw new IllegalArgumentException("Elevation not supported!");
+        if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
+            throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
+                    + "or equal to the number of points (" + requestPoints.size() + ")");
+        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size())
+            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored");
 
         GHRequest request;
         if (favoredHeadings.size() > 0) {
@@ -122,7 +121,7 @@ public Response doGet(
         }
 
         initHints(request.getHints(), uriInfo.getQueryParameters());
-        request.setVehicle(encodingManager.getEncoder(vehicleStr).toString()).
+        request.setVehicle(vehicleStr).
                 setWeighting(weighting).
                 setAlgorithm(algoStr).
                 setLocale(localeStr).
@@ -143,15 +142,16 @@ public Response doGet(
 
         if (ghResponse.hasErrors()) {
             logger.error(logStr + ", errors:" + ghResponse.getErrors());
-            throw new WebApplicationException(WebHelper.errorResponse(ghResponse.getErrors(), writeGPX));
+            throw new MultiException(ghResponse.getErrors());
         } else {
             logger.info(logStr + ", alternatives: " + ghResponse.getAll().size()
                     + ", distance0: " + ghResponse.getBest().getDistance()
+                    + ", weight0: " + ghResponse.getBest().getRouteWeight()
                     + ", time0: " + Math.round(ghResponse.getBest().getTime() / 60000f) + "min"
                     + ", points0: " + ghResponse.getBest().getPoints().getSize()
                     + ", debugInfo: " + ghResponse.getDebugInfo());
             return writeGPX ?
-                    WebHelper.gpxSuccessResponseBuilder(ghResponse, timeString, trackName, enableElevation, withRoute, withTrack, withWayPoints).
+                    gpxSuccessResponseBuilder(ghResponse, timeString, trackName, enableElevation, withRoute, withTrack, withWayPoints, Constants.VERSION).
                             header("X-GH-Took", "" + Math.round(took * 1000)).
                             build()
                     :
@@ -161,7 +161,18 @@ public Response doGet(
         }
     }
 
-    private static void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
+    private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String
+            trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
+        if (ghRsp.getAll().size() > 1) {
+            throw new IllegalArgumentException("Alternatives are currently not yet supported for GPX");
+        }
+
+        long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
+        return Response.ok(ghRsp.getBest().getInstructions().createGPX(trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version), "application/gpx+xml").
+                header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
+    }
+
+    static void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
         for (Map.Entry<String, List<String>> e : parameterMap.entrySet()) {
             if (e.getValue().size() == 1) {
                 m.put(e.getKey(), e.getValue().get(0));
diff --git a/web/pom.xml b/web/pom.xml
index b423597a79..68455453d3 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.12-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.12-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>9.4.2.v20170220</jetty.version>
@@ -21,53 +21,29 @@
 
     <dependencies>
         <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-osm</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-json</artifactId>
-            <version>${project.parent.version}</version>
+            <groupId>javax.activation</groupId>
+            <artifactId>activation</artifactId>
+            <version>1.1.1</version>
         </dependency>
         <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-gtfs</artifactId>
-            <version>${project.parent.version}</version>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-core</artifactId>
+            <version>${dropwizard.version}</version>
         </dependency>
-
         <dependency>
             <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-isochrone</artifactId>
+            <artifactId>graphhopper-web-bundle</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-
-        <!-- required for JDK9 -->
-        <dependency>
-            <groupId>javax.xml.ws</groupId>
-            <artifactId>jaxws-api</artifactId>
-            <version>2.3.0</version>
-        </dependency>
-        <!-- required for dropwizard -->
-        <dependency>
-            <groupId>com.google.guava</groupId>
-            <artifactId>guava</artifactId>
-            <version>21.0</version>
-        </dependency>
-        <dependency>
-            <groupId>io.dropwizard</groupId>
-            <artifactId>dropwizard-core</artifactId>
-            <version>1.2.2</version>
-        </dependency>
         <dependency>
             <groupId>io.dropwizard-bundles</groupId>
             <artifactId>dropwizard-configurable-assets-bundle</artifactId>
-            <version>1.0.5</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.2.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -81,7 +57,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>directions-api-client</artifactId>
-            <version>0.10.0</version>
+            <version>${directions-api-client.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -92,7 +68,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
diff --git a/web/src/main/assembly/jar.xml b/web/src/main/assembly/jar.xml
deleted file mode 100644
index 9deb284f62..0000000000
--- a/web/src/main/assembly/jar.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one
-  or more contributor license agreements.  See the NOTICE file
-  distributed with this work for additional information
-  regarding copyright ownership.  The ASF licenses this file
-  to you under the Apache License, Version 2.0 (the
-  "License"); you may not use this file except in compliance
-  with the License.  You may obtain a copy of the License at
-
-  http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing,
-  software distributed under the License is distributed on an
-  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-  KIND, either express or implied.  See the License for the
-  specific language governing permissions and limitations
-  under the License.
--->
-
-<!-- START SNIPPET: jar-with-dependencies -->
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion}" 
-          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion} http://maven.apache.org/xsd/assembly-${mdoVersion}.xsd">
-    <id>with-dep</id>
-    <formats>
-        <format>jar</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <dependencySets>
-        <dependencySet>
-            <outputDirectory>/</outputDirectory>
-            <useProjectArtifact>true</useProjectArtifact>
-            <unpack>true</unpack>
-            <scope>runtime</scope>
-        </dependencySet>
-    </dependencySets>
-</assembly>
-<!-- END SNIPPET: jar-with-dependencies -->
diff --git a/web/src/main/assembly/zip.xml b/web/src/main/assembly/zip.xml
deleted file mode 100644
index 278b9a9dc6..0000000000
--- a/web/src/main/assembly/zip.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
-          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
-    <id>bin</id>
-    <formats>
-        <format>zip</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <fileSets>
-        <fileSet>
-            <directory>${project.basedir}/src/main/</directory>
-            <outputDirectory/>
-            <includes>
-                <include>resources/assets/**</include>
-            </includes>
-        </fileSet>
-        <fileSet>
-            <directory>${project.basedir}/..</directory>
-            <outputDirectory/>
-            <includes>
-                <include>NOTICE*</include>
-                <include>LICENSE*</include>
-                <include>CONTRIBUTORS*</include>
-                <include>config-example.properties</include>
-            </includes>
-        </fileSet>
-        <fileSet>
-            <directory>${project.build.directory}</directory>
-            <outputDirectory/>
-            <includes>
-                <include>*-with-dep.jar</include>
-            </includes>
-        </fileSet>
-    </fileSets>
-</assembly>
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index 3e1d9a24cb..31c081afc2 100644
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -27,13 +27,11 @@
 public class CORSFilter implements Filter {
     @Override
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-        if (!"jsonp".equals(request.getParameter("type"))) {
-            HttpServletResponse rsp = (HttpServletResponse) response;
-            rsp.setHeader("Access-Control-Allow-Methods", "GET, POST, HEAD, OPTIONS");
-            rsp.setHeader("Access-Control-Allow-Headers", "Origin,Accept,X-Requested-With,"
-                    + "Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers");
-            rsp.setHeader("Access-Control-Allow-Origin", "*");
-        }
+        HttpServletResponse rsp = (HttpServletResponse) response;
+        rsp.setHeader("Access-Control-Allow-Methods", "GET, POST, HEAD, OPTIONS");
+        rsp.setHeader("Access-Control-Allow-Headers", "Origin,Accept,X-Requested-With,"
+                + "Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers");
+        rsp.setHeader("Access-Control-Allow-Origin", "*");
 
         chain.doFilter(request, response);
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index a2dcdb2758..601643b45d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -17,16 +17,6 @@
  */
 package com.graphhopper.http;
 
-import com.bedatadriven.jackson.datatype.jts.JtsModule;
-import com.fasterxml.jackson.annotation.JsonInclude;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.databind.BeanDescription;
-import com.fasterxml.jackson.databind.SerializationConfig;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
-import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
-import com.fasterxml.jackson.databind.util.ISO8601DateFormat;
 import com.graphhopper.http.cli.ImportCommand;
 import com.graphhopper.http.resources.RootResource;
 import io.dropwizard.Application;
@@ -34,8 +24,8 @@
 import io.dropwizard.setup.Bootstrap;
 import io.dropwizard.setup.Environment;
 
-import java.util.List;
-import java.util.stream.Collectors;
+import javax.servlet.DispatcherType;
+import java.util.EnumSet;
 
 public final class GraphHopperApplication extends Application<GraphHopperServerConfiguration> {
 
@@ -47,32 +37,13 @@ public static void main(String[] args) throws Exception {
     public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
         bootstrap.addBundle(new GraphHopperBundle());
         bootstrap.addBundle(new ConfiguredAssetsBundle("/assets/", "/maps/", "index.html"));
-        bootstrap.addCommand(new ImportCommand());
+        bootstrap.addCommand(new ImportCommand(bootstrap.getObjectMapper()));
     }
 
     @Override
-    public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
-        environment.getObjectMapper().setDateFormat(new ISO8601DateFormat());
-        environment.getObjectMapper().registerModule(new JtsModule());
-        environment.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
-        // Because VirtualEdgeIteratorState has getters which throw Exceptions.
-        // http://stackoverflow.com/questions/35359430/how-to-make-jackson-ignore-properties-if-the-getters-throw-exceptions
-        environment.getObjectMapper().registerModule(new SimpleModule().setSerializerModifier(new BeanSerializerModifier() {
-            @Override
-            public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
-                return beanProperties.stream().map(bpw -> new BeanPropertyWriter(bpw) {
-                    @Override
-                    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
-                        try {
-                            super.serializeAsField(bean, gen, prov);
-                        } catch (Exception e) {
-                            // Ignoring expected exception, see above.
-                        }
-                    }
-                }).collect(Collectors.toList());
-            }
-        }));
-
+    public void run(GraphHopperServerConfiguration configuration, Environment environment) {
         environment.jersey().register(new RootResource());
+        environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
+        environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java
deleted file mode 100644
index f1a37f274d..0000000000
--- a/web/src/main/java/com/graphhopper/http/GraphHopperManaged.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.graphhopper.http;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.osm.GraphHopperOSM;
-import com.graphhopper.spatialrules.SpatialRuleLookupHelper;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Parameters;
-import io.dropwizard.lifecycle.Managed;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-@Singleton
-public class GraphHopperManaged implements Managed {
-
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final GraphHopper graphHopper;
-
-    @Inject
-    public GraphHopperManaged(CmdArgs configuration) {
-        graphHopper = new GraphHopperOSM(
-                SpatialRuleLookupHelper.createLandmarkSplittingFeatureCollection(configuration.get(Parameters.Landmark.PREPARE + "split_area_location", ""))
-        ).forServer();
-        SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, configuration);
-        graphHopper.init(configuration);
-    }
-
-    @Override
-    public void start() {
-        graphHopper.importOrLoad();
-        logger.info("loaded graph at:" + graphHopper.getGraphHopperLocation()
-                + ", data_reader_file:" + graphHopper.getDataReaderFile()
-                + ", flag_encoders:" + graphHopper.getEncodingManager()
-                + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
-    }
-
-    GraphHopper getGraphHopper() {
-        return graphHopper;
-    }
-
-    @Override
-    public void stop() throws Exception {
-        graphHopper.close();
-    }
-
-
-}
diff --git a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
index 389abbc6b9..8ce4b6e8c2 100644
--- a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
+++ b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
@@ -18,6 +18,7 @@
 
 package com.graphhopper.http.cli;
 
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.http.GraphHopperManaged;
 import com.graphhopper.http.GraphHopperServerConfiguration;
 import io.dropwizard.cli.ConfiguredCommand;
@@ -26,13 +27,16 @@
 
 public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
 
-    public ImportCommand() {
+    private final ObjectMapper objectMapper;
+
+    public ImportCommand(ObjectMapper objectMapper) {
         super("import", "creates the graphhopper files used for later (faster) starts");
+        this.objectMapper = objectMapper;
     }
 
     @Override
-    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) throws Exception {
-        final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration());
+    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) {
+        final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), objectMapper);
         graphHopper.start();
         graphHopper.stop();
     }
diff --git a/web/src/main/java/com/graphhopper/http/resources/IsochroneResource.java b/web/src/main/java/com/graphhopper/http/resources/IsochroneResource.java
deleted file mode 100644
index 781b9d44b2..0000000000
--- a/web/src/main/java/com/graphhopper/http/resources/IsochroneResource.java
+++ /dev/null
@@ -1,219 +0,0 @@
-package com.graphhopper.http.resources;
-
-import com.fasterxml.jackson.databind.node.ArrayNode;
-import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.fasterxml.jackson.databind.node.ObjectNode;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.isochrone.algorithm.Isochrone;
-import com.graphhopper.isochrone.algorithm.RasterHullBuilder;
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.exceptions.GHException;
-import com.graphhopper.util.shapes.GHPoint;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.inject.Inject;
-import javax.servlet.http.HttpServletRequest;
-import javax.ws.rs.*;
-import javax.ws.rs.core.*;
-import java.util.*;
-
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-
-@Path("isochrone")
-public class IsochroneResource {
-
-    private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
-
-    private final GraphHopper graphHopper;
-    private final EncodingManager encodingManager;
-    private final RasterHullBuilder rasterHullBuilder;
-
-    @Inject
-    public IsochroneResource(GraphHopper graphHopper, EncodingManager encodingManager, RasterHullBuilder rasterHullBuilder) {
-        this.graphHopper = graphHopper;
-        this.encodingManager = encodingManager;
-        this.rasterHullBuilder = rasterHullBuilder;
-    }
-
-    @GET
-    @Produces({MediaType.APPLICATION_JSON})
-    public Response doGet(
-            @Context HttpServletRequest httpReq,
-            @Context UriInfo uriInfo,
-            @QueryParam("vehicle") @DefaultValue("car") String vehicle,
-            @QueryParam("weighting") @DefaultValue("fastest") String weightingStr,
-            @QueryParam("buckets") @DefaultValue("1") int buckets,
-            @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
-            @QueryParam("point") GHPoint point,
-            @QueryParam("result") @DefaultValue("polygon") String resultStr,
-            @QueryParam("time_limit") @DefaultValue("600") long timeLimitInSeconds,
-            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
-
-        if (buckets > 20 || buckets < 1)
-            throwArgExc("Number of buckets has to be in the range [1, 20]");
-
-        if (point == null)
-            throwArgExc("point parameter cannot be null");
-
-        StopWatch sw = new StopWatch().start();
-
-        if (!encodingManager.supports(vehicle))
-            throwArgExc("vehicle not supported:" + vehicle);
-
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        LocationIndex locationIndex = graphHopper.getLocationIndex();
-        QueryResult qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-        if (!qr.isValid())
-            throwArgExc("Point not found:" + point);
-
-        Graph graph = graphHopper.getGraphHopperStorage();
-        QueryGraph queryGraph = new QueryGraph(graph);
-        queryGraph.lookup(Collections.singletonList(qr));
-
-        HintsMap hintsMap = new HintsMap();
-
-        initHints(hintsMap, uriInfo.getQueryParameters());
-
-        Weighting weighting = graphHopper.createWeighting(hintsMap, encoder, graph);
-        Isochrone isochrone = new Isochrone(queryGraph, weighting, reverseFlow);
-
-        if (distanceInMeter > 0) {
-            double maxMeter = 50 * 1000;
-            if (distanceInMeter > maxMeter)
-                throwArgExc("Specify a limit of less than " + maxMeter / 1000f + "km");
-            if (buckets > (distanceInMeter / 500))
-                throwArgExc("Specify buckets less than the number of explored kilometers");
-
-            isochrone.setDistanceLimit(distanceInMeter);
-        } else {
-
-            long maxSeconds = 80 * 60;
-            if (timeLimitInSeconds > maxSeconds)
-                throwArgExc("Specify a limit of less than " + maxSeconds + " seconds");
-            if (buckets > (timeLimitInSeconds / 60))
-                throwArgExc("Specify buckets less than the number of explored minutes");
-
-            isochrone.setTimeLimit(timeLimitInSeconds);
-        }
-
-        List<List<Double[]>> list = isochrone.searchGPS(qr.getClosestNode(), buckets);
-        if (isochrone.getVisitedNodes() > graphHopper.getMaxVisitedNodes() / 5) {
-            throwArgExc("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
-        }
-
-        int counter = 0;
-        for (List<Double[]> tmp : list) {
-            if (tmp.size() < 2) {
-                throwArgExc("Too few points found for bucket " + counter + ". "
-                        + "Please try a different 'point', a smaller 'buckets' count or a larger 'time_limit'. "
-                        + "And let us know if you think this is a bug!");
-            }
-            counter++;
-        }
-
-        Object calcRes;
-        if ("pointlist".equalsIgnoreCase(resultStr)) {
-            calcRes = list;
-
-        } else if ("polygon".equalsIgnoreCase(resultStr)) {
-            list = rasterHullBuilder.calcList(list, list.size() - 1);
-
-            ArrayList polyList = new ArrayList();
-            int index = 0;
-            for (List<Double[]> polygon : list) {
-                HashMap<String, Object> geoJsonMap = new HashMap<>();
-                HashMap<String, Object> propMap = new HashMap<>();
-                HashMap<String, Object> geometryMap = new HashMap<>();
-                polyList.add(geoJsonMap);
-                geoJsonMap.put("type", "Feature");
-                geoJsonMap.put("properties", propMap);
-                geoJsonMap.put("geometry", geometryMap);
-
-                propMap.put("bucket", index);
-                geometryMap.put("type", "Polygon");
-                // we have no holes => embed in yet another list
-                geometryMap.put("coordinates", Collections.singletonList(polygon));
-                index++;
-            }
-            calcRes = polyList;
-        } else {
-            throw new WebApplicationException(jsonErrorResponse(Collections.singletonList(new IllegalArgumentException("type not supported:" + resultStr))));
-        }
-
-        logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
-        return Response.fromResponse(jsonSuccessResponse(calcRes, sw.stop().getSeconds()))
-                .header("X-GH-Took", "" + sw.stop().getSeconds() * 1000)
-                .build();
-    }
-
-    private void throwArgExc(String msg) {
-        throw new WebApplicationException(jsonErrorResponse(Collections.singletonList(new IllegalArgumentException(msg))));
-    }
-
-
-    private Response jsonErrorResponse(List<Throwable> errors) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.put("message", getMessage(errors.get(0)));
-        ArrayNode errorHintList = json.putArray("hints");
-        for (Throwable t : errors) {
-            ObjectNode error = errorHintList.addObject();
-            error.put("message", getMessage(t));
-            error.put("details", t.getClass().getName());
-            if (t instanceof GHException) {
-                ((GHException) t).getDetails().forEach(error::putPOJO);
-            }
-        }
-        return Response.status(SC_BAD_REQUEST).entity(json).build();
-    }
-
-    private String getMessage(Throwable t) {
-        if (t.getMessage() == null)
-            return t.getClass().getSimpleName();
-        else
-            return t.getMessage();
-    }
-
-    // TODO Copied from RouteResource
-    private void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
-        for (Map.Entry<String, List<String>> e : parameterMap.entrySet()) {
-            if (e.getValue().size() == 1) {
-                m.put(e.getKey(), e.getValue().get(0));
-            } else {
-                // Do nothing.
-                // TODO: this is dangerous: I can only silently swallow
-                // the forbidden multiparameter. If I comment-in the line below,
-                // I get an exception, because "point" regularly occurs
-                // multiple times.
-                // I think either unknown parameters (hints) should be allowed
-                // to be multiparameters, too, or we shouldn't use them for
-                // known parameters either, _or_ known parameters
-                // must be filtered before they come to this code point,
-                // _or_ we stop passing unknown parameters alltogether..
-                //
-                // throw new WebApplicationException(String.format("This query parameter (hint) is not allowed to occur multiple times: %s", e.getKey()));
-            }
-        }
-    }
-
-    private Response jsonSuccessResponse(Object result, float took) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.putPOJO("polygons", result);
-        // If you replace GraphHopper with your own brand name, this is fine.
-        // Still it would be highly appreciated if you mention us in your about page!
-        final ObjectNode info = json.putObject("info");
-        info.putArray("copyrights")
-                .add("GraphHopper")
-                .add("OpenStreetMap contributors");
-        info.put("took", Math.round(took * 1000));
-
-        return Response.ok(json).build();
-    }
-}
diff --git a/web/src/main/resources/assets/css/style.css b/web/src/main/resources/assets/css/style.css
index 817b29b81d..d0c296eeee 100644
--- a/web/src/main/resources/assets/css/style.css
+++ b/web/src/main/resources/assets/css/style.css
@@ -205,7 +205,6 @@ body {
     /* color: #666666; */
     font-size: smaller;
     opacity: 0.8;
-    width: 200px;
 }
 
 #footer {
diff --git a/web/src/main/resources/assets/index.html b/web/src/main/resources/assets/index.html
index 647e4424b7..715aba0cae 100644
--- a/web/src/main/resources/assets/index.html
+++ b/web/src/main/resources/assets/index.html
@@ -33,7 +33,7 @@
         <link rel="stylesheet" href="css/leaflet.loading.css?v=0.1.24" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui.min.css" />
         <link rel="stylesheet" href="css/flatpickr.min.css?v=4.4.6">
-        <script type="text/javascript" src="js/main.js?v=0.10.0"></script>
+        <script type="text/javascript" src="js/main.js?v=0.11.0"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
     </head>
     <body>
diff --git a/web/src/main/resources/assets/js/autocomplete.js b/web/src/main/resources/assets/js/autocomplete.js
index def693032b..5fc477f7af 100644
--- a/web/src/main/resources/assets/js/autocomplete.js
+++ b/web/src/main/resources/assets/js/autocomplete.js
@@ -104,7 +104,6 @@ AutoComplete.prototype.showListForIndex = function (ghRequest, routeIfAllResolve
 
     var options = {
         containerClass: "autocomplete",
-        /* as we use can potentially use jsonp we need to set the timeout to a small value */
         timeout: 1000,
         /* avoid too many requests when typing quickly */
         deferRequestBy: 5,
@@ -160,15 +159,6 @@ AutoComplete.prototype.showListForIndex = function (ghRequest, routeIfAllResolve
     };
 
     myAutoDiv.autocomplete(options);
-
-    // with the following more stable code we cannot click on suggestions any longer
-//    $("#" + fromOrTo + "Input").focusout(function() {
-//        myAutoDiv.autocomplete().disable();
-//        myAutoDiv.autocomplete().hide();
-//    });
-//    $("#" + fromOrTo + "Input").focusin(function() {
-//        myAutoDiv.autocomplete().enable();
-//    });
 };
 
 AutoComplete.prototype.createStub = function () {
diff --git a/web/src/main/resources/assets/js/graphhopper/GHRequest.js b/web/src/main/resources/assets/js/graphhopper/GHRequest.js
index 3ca0dbcb34..a91f8f6b18 100644
--- a/web/src/main/resources/assets/js/graphhopper/GHRequest.js
+++ b/web/src/main/resources/assets/js/graphhopper/GHRequest.js
@@ -36,7 +36,6 @@ var GHRequest = function (host, api_key) {
 
     this.do_zoom = true;
     this.useMiles = false;
-    // use jsonp here if host allows CORS
     this.dataType = "json";
     this.api_params = {"locale": "en", "vehicle": "car", "weighting": "fastest", "elevation": false,
         "key": api_key, "pt": {}};
@@ -258,8 +257,6 @@ GHRequest.prototype.doRequest = function (url, callback) {
             callback(json);
         },
         error: function (err) {
-            // problematic: this callback is not invoked when using JSONP!
-            // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
             var json;
 
diff --git a/web/src/main/resources/assets/js/main-template.js b/web/src/main/resources/assets/js/main-template.js
index 3807aa2fca..bc7cd7bae9 100644
--- a/web/src/main/resources/assets/js/main-template.js
+++ b/web/src/main/resources/assets/js/main-template.js
@@ -183,7 +183,7 @@ $(document).ready(function (e) {
                 mapLayer.initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, urlParams.layer, urlParams.use_miles);
             });
 
-    var language_code = urlParams.locale.split('-', 1)[0];
+    var language_code = urlParams.locale && urlParams.locale.split('-', 1)[0];
     if (language_code != 'en') {
         // A few language codes are different in GraphHopper and Flatpickr.
         var flatpickr_locale;
diff --git a/web/src/main/resources/assets/js/main.js b/web/src/main/resources/assets/js/main.js
index de1ecc5a4e..af33ef9b41 100644
--- a/web/src/main/resources/assets/js/main.js
+++ b/web/src/main/resources/assets/js/main.js
@@ -66,7 +66,7 @@ L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number
 
 },{}],23:[function(require,module,exports){
 (function (global){
-global.d3=require("d3");var Flatpickr=require("flatpickr");require("flatpickr/dist/l10n");var L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading");var moment=require("moment");require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var metaVersionInfo,mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicleTools=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={};function initFromParams(e,t){ghRequest.init(e);var r=new Flatpickr(document.getElementById("input_date_0"),{defaultDate:new Date,allowInput:!0,minuteIncrement:15,time_24hr:!0,enableTime:!0});ghRequest.getEarliestDepartureTime()&&r.setDate(ghRequest.getEarliestDepartureTime());var o,a=0;if(e.point)for(var n=0;n<e.point.length;n++)""!==e.point[n]&&(a++,o=n);e.point&&a>=2?resolveCoords(e.point,t):e.point&&1===a&&(ghRequest.route.set(e.point[o],o,!0),resolveIndex(o).done(function(){mapLayer.focus(ghRequest.route.getIndex(o),15,o)}))}function resolveCoords(e,t){for(var r=0,o=e.length;r<o;r++){var a=e[r],n=ghRequest.route.getIndex(r);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,r,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var r=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(r.locale),ghRequest.getInfo()).then(function(e,t){var o=e[0];autocomplete.setLocale(o.locale),ghRequest.setLocale(o.locale),translate.init(o);var a=t[0],n=a.bbox;bounds.initialized=!0,bounds.minLon=n[0],bounds.minLat=n[1],bounds.maxLon=n[2],bounds.maxLat=n[3],nominatim.setBounds(bounds);var s=$("#vehicles");function i(e,t){var r=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&r.hide(),r.attr("id",e),r.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),r.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),r}if(a.features){ghRequest.features=a.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=r.vehicle&&(!l[r.vehicle]||l[r.vehicle]>3),p=vehicleTools.getSortedVehicleKeys(a.features,l);p.length>0&&ghRequest.initVehicle(p[0]),ghRequest.isPublicTransit()&&$(".time_input").show();var d=[];for(var c in p){var g=i(p[c].toLowerCase(),!u&&c>2);s.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var h=$("<a id='more-vehicle-btn'> ...</a>").click(function(){for(var e in h.hide(),d)d[e].show()});s.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),s.append(h)}}metaVersionInfo=messages.extractMetaVersionInfo(a),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles),initFromParams(r,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles)});var o=r.locale.split("-",1)[0];if("en"!=o){var a;switch(o){case"ca":a="cat";break;case"el":a="gr";break;default:a=o}Flatpickr.l10ns.hasOwnProperty(a)&&Flatpickr.localize(Flatpickr.l10ns[a])}$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var r=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(r===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var r=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),checkInput(),routeLatLng(ghRequest,!1)},o=0;o<t;o++){var a=$("#locationpoints > div.pointDiv").eq(o);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:o})),a=$("#locationpoints > div.pointDiv").eq(o));var n=getToFrom(o);if(a.data("index",o),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(r).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,o),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===o?$(s).attr("placeholder",translate.tr("from_hint")):o===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route").map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(t,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var r=getToFrom(t),o=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);o._openPopup=o.openPopup,o.openPopup=function(){var e,t=this.getLatLng(),r=ghRequest.route.getIndexFromCoord(t);if(r.resolvedList&&r.resolvedList[0]&&r.resolvedList[0].locationDetails){var o=r.resolvedList[0].locationDetails;e=format.formatAddress(o),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:setToStart,index:1};-1===r&&o.options.contextmenuItems.push(a),o.on("dragend",function(e){mapLayer.clearLayers();var r=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(r.lat,r.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,r=ghRequest.route.size();t<r;t++)e[t]=resolveIndex(t);return ghRequest.isPublicTransit()&&ghRequest.setEarliestDepartureTime(moment($("#input_date_0").val(),"YYYY-MM-DD HH:mm").toISOString()),e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var r,o=e.do_zoom;e.do_zoom=!0;var a=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var n=urlTools.parseUrl(a);return console.log(n),n.do_zoom=o,n.mathRandom=Math.random(),void History.pushState(n,messages.browserTitle,a)}var s=$("#info");s.empty(),s.show();var i=$("<div class='route_results'/>");s.append(i),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var l=e.createURL();i.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(l,function(t){if(i.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var s=0;s<t.hints.length;s++)i.append("<div class='error'>"+t.hints[s].message+"</div>");else i.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(i.append(l),i.append("<div class='clear'/>"));var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],h=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}};if(t.paths.length>0&&t.paths[0].points_order){mapLayer.clearLayers();var m=t.paths[0].points_order;for(r=0;r<m.length;r++)setFlag(ghRequest.route.getIndex(m[r]),r)}for(var v=0;v<t.paths.length;v++){var f=$("<li>").append(v+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===v&&(u=f),l.append(f);var q=t.paths[v],b=0===v?p:c,y={type:"Feature",geometry:q.points,properties:{style:b,name:"route",snapped_waypoints:q.snapped_waypoints}};g.push(y),mapLayer.addDataToRoutingLayer(y);var R=$("<div class='route_result_tab'>");i.append(R),f.click(Y(g,v,f,R,e.hasElevation(),e.useMiles));var x=$("<div class='route_description'>");q.description&&q.description.length>0&&(x.text(q.description),x.append("<br/>"));var I,_=translate.createDistanceString(q.distance,e.useMiles);if(e.isPublicTransit()){var w=moment(ghRequest.getEarliestDepartureTime()).add(q.time,"milliseconds").format("LT");I=q.transfers>=0?translate.tr("pt_route_info",[w,q.transfers,_]):translate.tr("pt_route_info_walking",[w,_])}else{var k=translate.createTimeString(q.time);I=translate.tr("route_info",[_,k])}x.append(I);var T=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");T.text(translate.tr2("km_abbr")),T.click(h(!1));var C=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");C.text(translate.tr2("mi_abbr")),C.click(h(!0));var F=$("<span style='float: right;'>");if(F.append(T),F.append("|"),F.append(C),x.append(F),e.hasElevation()&&x.append(translate.createEleInfoString(q.ascend,q.descend,e.useMiles)),x.append($("<div style='clear:both'/>")),R.append(x),q.instructions){var M=require("./instructions.js");R.append(M.create(mapLayer,q,a,e))}var j=q.details;if(j&&e.api_params.debug)for(var D in j){var S=j[D];for(r=0;r<S.length;r++){var A=S[r],z=A[0],E=A[2],P=q.points.coordinates[z];L.marker([P[1],P[0]],{icon:L.icon({iconUrl:"./img/marker-small-blue.png",iconSize:[15,15]}),draggable:!0,autoPan:!0}).addTo(mapLayer.getRoutingLayer()).bindPopup(D+":"+E)}}}u.click(),mapLayer.adjustMapSize();var H=t.paths[0];if(H.bbox&&o){var B=H.bbox[0],O=H.bbox[1],G=H.bbox[2],V=H.bbox[3],U=new L.LatLngBounds(new L.LatLng(O,B),new L.LatLng(V,G));mapLayer.fitMapToBounds(U)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}function Y(e,t,r,o,a,n){return function(){var s=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===s;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(s,n)),l.find("li").removeClass("current"),i.find("div").removeClass("current"),r.addClass("current"),o.addClass("current")}}})}function mySubmit(){var e,t,r,o=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val())!==translate.tr("from_hint")&&""!==e?o.push(e):a=!1:n===s-1?(t=$(this).val())!==translate.tr("to_hint")&&""!==t?o.push(t):a=!1:(r=$(this).val())!==translate.tr("via_hint")&&""!==r?o.push(r):a=!1}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(o))}function isProduction(){return host.indexOf("graphhopper.com")>0}module.exports.setFlag=setFlag;
+global.d3=require("d3");var Flatpickr=require("flatpickr");require("flatpickr/dist/l10n");var L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading");var moment=require("moment");require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var metaVersionInfo,mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicleTools=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={};function initFromParams(e,t){ghRequest.init(e);var r=new Flatpickr(document.getElementById("input_date_0"),{defaultDate:new Date,allowInput:!0,minuteIncrement:15,time_24hr:!0,enableTime:!0});ghRequest.getEarliestDepartureTime()&&r.setDate(ghRequest.getEarliestDepartureTime());var o,a=0;if(e.point)for(var n=0;n<e.point.length;n++)""!==e.point[n]&&(a++,o=n);e.point&&a>=2?resolveCoords(e.point,t):e.point&&1===a&&(ghRequest.route.set(e.point[o],o,!0),resolveIndex(o).done(function(){mapLayer.focus(ghRequest.route.getIndex(o),15,o)}))}function resolveCoords(e,t){for(var r=0,o=e.length;r<o;r++){var a=e[r],n=ghRequest.route.getIndex(r);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,r,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var r=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(r.locale),ghRequest.getInfo()).then(function(e,t){var o=e[0];autocomplete.setLocale(o.locale),ghRequest.setLocale(o.locale),translate.init(o);var a=t[0],n=a.bbox;bounds.initialized=!0,bounds.minLon=n[0],bounds.minLat=n[1],bounds.maxLon=n[2],bounds.maxLat=n[3],nominatim.setBounds(bounds);var s=$("#vehicles");function i(e,t){var r=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&r.hide(),r.attr("id",e),r.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),r.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),r}if(a.features){ghRequest.features=a.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=r.vehicle&&(!l[r.vehicle]||l[r.vehicle]>3),p=vehicleTools.getSortedVehicleKeys(a.features,l);p.length>0&&ghRequest.initVehicle(p[0]),ghRequest.isPublicTransit()&&$(".time_input").show();var d=[];for(var c in p){var g=i(p[c].toLowerCase(),!u&&c>2);s.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var h=$("<a id='more-vehicle-btn'> ...</a>").click(function(){for(var e in h.hide(),d)d[e].show()});s.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),s.append(h)}}metaVersionInfo=messages.extractMetaVersionInfo(a),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles),initFromParams(r,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles)});var o=r.locale&&r.locale.split("-",1)[0];if("en"!=o){var a;switch(o){case"ca":a="cat";break;case"el":a="gr";break;default:a=o}Flatpickr.l10ns.hasOwnProperty(a)&&Flatpickr.localize(Flatpickr.l10ns[a])}$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var r=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(r===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var r=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),checkInput(),routeLatLng(ghRequest,!1)},o=0;o<t;o++){var a=$("#locationpoints > div.pointDiv").eq(o);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:o})),a=$("#locationpoints > div.pointDiv").eq(o));var n=getToFrom(o);if(a.data("index",o),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(r).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,o),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===o?$(s).attr("placeholder",translate.tr("from_hint")):o===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route").map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(t,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var r=getToFrom(t),o=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);o._openPopup=o.openPopup,o.openPopup=function(){var e,t=this.getLatLng(),r=ghRequest.route.getIndexFromCoord(t);if(r.resolvedList&&r.resolvedList[0]&&r.resolvedList[0].locationDetails){var o=r.resolvedList[0].locationDetails;e=format.formatAddress(o),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:setToStart,index:1};-1===r&&o.options.contextmenuItems.push(a),o.on("dragend",function(e){mapLayer.clearLayers();var r=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(r.lat,r.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,r=ghRequest.route.size();t<r;t++)e[t]=resolveIndex(t);return ghRequest.isPublicTransit()&&ghRequest.setEarliestDepartureTime(moment($("#input_date_0").val(),"YYYY-MM-DD HH:mm").toISOString()),e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var r,o=e.do_zoom;e.do_zoom=!0;var a=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var n=urlTools.parseUrl(a);return console.log(n),n.do_zoom=o,n.mathRandom=Math.random(),void History.pushState(n,messages.browserTitle,a)}var s=$("#info");s.empty(),s.show();var i=$("<div class='route_results'/>");s.append(i),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var l=e.createURL();i.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(l,function(t){if(i.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var s=0;s<t.hints.length;s++)i.append("<div class='error'>"+t.hints[s].message+"</div>");else i.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(i.append(l),i.append("<div class='clear'/>"));var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],h=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}};if(t.paths.length>0&&t.paths[0].points_order){mapLayer.clearLayers();var m=t.paths[0].points_order;for(r=0;r<m.length;r++)setFlag(ghRequest.route.getIndex(m[r]),r)}for(var v=0;v<t.paths.length;v++){var f=$("<li>").append(v+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===v&&(u=f),l.append(f);var q=t.paths[v],b=0===v?p:c,y={type:"Feature",geometry:q.points,properties:{style:b,name:"route",snapped_waypoints:q.snapped_waypoints}};g.push(y),mapLayer.addDataToRoutingLayer(y);var R=$("<div class='route_result_tab'>");i.append(R),f.click(Y(g,v,f,R,e.hasElevation(),e.useMiles));var x=$("<div class='route_description'>");q.description&&q.description.length>0&&(x.text(q.description),x.append("<br/>"));var I,_=translate.createDistanceString(q.distance,e.useMiles);if(e.isPublicTransit()){var w=moment(ghRequest.getEarliestDepartureTime()).add(q.time,"milliseconds").format("LT");I=q.transfers>=0?translate.tr("pt_route_info",[w,q.transfers,_]):translate.tr("pt_route_info_walking",[w,_])}else{var k=translate.createTimeString(q.time);I=translate.tr("route_info",[_,k])}x.append(I);var T=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");T.text(translate.tr2("km_abbr")),T.click(h(!1));var C=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");C.text(translate.tr2("mi_abbr")),C.click(h(!0));var F=$("<span style='float: right;'>");if(F.append(T),F.append("|"),F.append(C),x.append(F),e.hasElevation()&&x.append(translate.createEleInfoString(q.ascend,q.descend,e.useMiles)),x.append($("<div style='clear:both'/>")),R.append(x),q.instructions){var M=require("./instructions.js");R.append(M.create(mapLayer,q,a,e))}var j=q.details;if(j&&e.api_params.debug)for(var D in j){var S=j[D];for(r=0;r<S.length;r++){var A=S[r],z=A[0],E=A[2],P=q.points.coordinates[z];L.marker([P[1],P[0]],{icon:L.icon({iconUrl:"./img/marker-small-blue.png",iconSize:[15,15]}),draggable:!0,autoPan:!0}).addTo(mapLayer.getRoutingLayer()).bindPopup(D+":"+E)}}}u.click(),mapLayer.adjustMapSize();var H=t.paths[0];if(H.bbox&&o){var B=H.bbox[0],O=H.bbox[1],G=H.bbox[2],V=H.bbox[3],U=new L.LatLngBounds(new L.LatLng(O,B),new L.LatLng(V,G));mapLayer.fitMapToBounds(U)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}function Y(e,t,r,o,a,n){return function(){var s=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===s;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(s,n)),l.find("li").removeClass("current"),i.find("div").removeClass("current"),r.addClass("current"),o.addClass("current")}}})}function mySubmit(){var e,t,r,o=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val())!==translate.tr("from_hint")&&""!==e?o.push(e):a=!1:n===s-1?(t=$(this).val())!==translate.tr("to_hint")&&""!==t?o.push(t):a=!1:(r=$(this).val())!==translate.tr("via_hint")&&""!==r?o.push(r):a=!1}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(o))}function isProduction(){return host.indexOf("graphhopper.com")>0}module.exports.setFlag=setFlag;
 
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./autocomplete.js":9,"./config/options.js":10,"./config/tileLayers.js":11,"./gpxexport.js":12,"./graphhopper/GHInput.js":13,"./graphhopper/GHRequest.js":14,"./instructions.js":17,"./lib/jquery-ui-custom-1.12.0.min.js":18,"./lib/jquery.autocomplete.js":19,"./lib/jquery.history.js":20,"./lib/leaflet.elevation-0.0.4.min.js":21,"./lib/leaflet_numbered_markers.js":22,"./map.js":24,"./messages.js":25,"./nominatim.js":26,"./routeManipulation.js":27,"./tools/format.js":28,"./tools/url.js":30,"./tools/vehicle.js":31,"./translate.js":32,"d3":1,"flatpickr":2,"flatpickr/dist/l10n":3,"jquery":4,"leaflet":7,"leaflet-contextmenu":5,"leaflet-loading":6,"moment":8}],24:[function(require,module,exports){
@@ -95,7 +95,7 @@ module.exports.getSortedVehicleKeys=function(e,r){var t=Object.keys(e);return t.
 
 },{}],32:[function(require,module,exports){
 (function (global){
-var i18nIsInitialized,defaultTranslationMap=null,enTranslationMap=null,mathTools=require("./tools/math.js");function tr2(t,r){if(null===t)return console.log("ERROR: key was null?"),"";if(null===defaultTranslationMap)return console.log("ERROR: defaultTranslationMap was not initialized?"),t;t=t.toLowerCase();var o=defaultTranslationMap[t];return!o&&enTranslationMap&&(o=enTranslationMap[t]),o?stringFormat(o,r):t}function tr(t,r){return t!==t.toLowerCase()&&console.log("key "+t+" has to be lower case"),tr2("web."+t,r)}function stringFormat(t,r){if("string"==typeof r&&(r=[r]),t.indexOf("%1$s")>=0)return t.replace(/\%(\d+)\$s/g,function(t,o){return void 0!==r[--o]?r[o]:t});var o=0;return t.replace(/\%s/g,function(t){var n=void 0!==r[o]?r[o]:t;return o++,n})}function initI18N(){if(global.$){$("#searchButton").attr("value",tr("search_button"));var t=$("#locationpoints > div.pointDiv > input.pointInput"),r=t.size;$(t).each(function(t){0===t?$(this).attr("placeholder",tr("from_hint")):t===r-1?$(this).attr("placeholder",tr("to_hint")):$(this).attr("placeholder",tr("via_hint"))}),$(".pointFlag").each(function(){$(this).attr("title",tr("drag_to_reorder"))}),$(".pointDelete").each(function(){$(this).attr("title",tr("delete_from_route"))}),$("#export-link").attr("title",tr("staticlink")),$("#gpxExportButton").attr("title",tr("gpx_export_button"))}}function mToKm(t){return t/1e3}function mToFt(t){return t/.3048}function mToMi(t){return t/1609.344}module.exports.createDistanceString=function(t,r){return r?t<152?mathTools.round(mToFt(t),1)+tr2("ft_abbr"):((t=mathTools.round(mToMi(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("mi_abbr")):t<900?mathTools.round(t,1)+tr2("m_abbr"):((t=mathTools.round(mToKm(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("km_abbr"))},module.exports.createEleInfoString=function(t,r,o){var n="";return(t>0||r>0)&&(n="<br/> ",t>0&&(n+=o?"&#8599;"+mathTools.round(mToFt(t),1)+tr2("ft_abbr"):"&#8599;"+mathTools.round(t,1)+tr2("m_abbr")),r>0&&(n+=o?" &#8600;"+mathTools.round(mToFt(r),1)+tr2("ft_abbr"):" &#8600;"+mathTools.round(r,1)+tr2("m_abbr"))),n},module.exports.createTimeString=function(t){var r,o=mathTools.round(t/60/1e3,1e3);return o>60?o/60>24?(r=mathTools.floor(o/60/24,1)+tr2("day_abbr"),(o=mathTools.floor(o/60%24,1))>0&&(r+=" "+o+tr2("hour_abbr"))):(r=mathTools.floor(o/60,1)+tr2("hour_abbr"),(o=mathTools.floor(o%60,1))>0&&(r+=" "+o+tr2("min_abbr"))):r=mathTools.round(o%60,1)+tr2("min_abbr"),r},module.exports.tr=tr,module.exports.tr2=tr2,module.exports.nanoTemplate=function(t,r){return t.replace(/\{([\w\.]*)\}/g,function(t,o){var n=o.split("."),a=r[n.shift()];for(i=0,l=n.length;i<l;_i++)a=a[this];return void 0!==a&&null!==a?a:""})},module.exports.init=function(t){defaultTranslationMap=t.default,enTranslationMap=t.en,defaultTranslationMap||(defaultTranslationMap=enTranslationMap),i18nIsInitialized=!0,initI18N()},module.exports.isI18nIsInitialized=function(){return i18nIsInitialized};
+var i18nIsInitialized,defaultTranslationMap=null,enTranslationMap=null,mathTools=require("./tools/math.js");function tr2(t,r){if(null===t)return console.log("ERROR: key was null?"),"";if(null===defaultTranslationMap)return console.log("ERROR: defaultTranslationMap was not initialized?"),t;t=t.toLowerCase();var o=defaultTranslationMap[t];return!o&&enTranslationMap&&(o=enTranslationMap[t]),o?stringFormat(o,r):t}function tr(t,r){return t!==t.toLowerCase()&&console.log("key "+t+" has to be lower case"),tr2("web."+t,r)}function stringFormat(t,r){if("string"==typeof r&&(r=[r]),t.indexOf("%1$s")>=0)return t.replace(/\%(\d+)\$s/g,function(t,o){return void 0!==r[--o]?r[o]:t});var o=0;return t.replace(/\%s/g,function(t){var n=void 0!==r[o]?r[o]:t;return o++,n})}function initI18N(){if(global.$){$("#searchButton").attr("value",tr("search_button"));var t=$("#locationpoints > div.pointDiv > input.pointInput"),r=t.size;$(t).each(function(t){0===t?($(this).attr("placeholder",tr("from_hint")),$(this).focus()):t===r-1?$(this).attr("placeholder",tr("to_hint")):$(this).attr("placeholder",tr("via_hint"))}),$(".pointFlag").each(function(){$(this).attr("title",tr("drag_to_reorder"))}),$(".pointDelete").each(function(){$(this).attr("title",tr("delete_from_route"))}),$("#export-link").attr("title",tr("staticlink")),$("#gpxExportButton").attr("title",tr("gpx_export_button"))}}function mToKm(t){return t/1e3}function mToFt(t){return t/.3048}function mToMi(t){return t/1609.344}module.exports.createDistanceString=function(t,r){return r?t<152?mathTools.round(mToFt(t),1)+tr2("ft_abbr"):((t=mathTools.round(mToMi(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("mi_abbr")):t<900?mathTools.round(t,1)+tr2("m_abbr"):((t=mathTools.round(mToKm(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("km_abbr"))},module.exports.createEleInfoString=function(t,r,o){var n="";return(t>0||r>0)&&(n="<br/> ",t>0&&(n+=o?"&#8599;"+mathTools.round(mToFt(t),1)+tr2("ft_abbr"):"&#8599;"+mathTools.round(t,1)+tr2("m_abbr")),r>0&&(n+=o?" &#8600;"+mathTools.round(mToFt(r),1)+tr2("ft_abbr"):" &#8600;"+mathTools.round(r,1)+tr2("m_abbr"))),n},module.exports.createTimeString=function(t){var r,o=mathTools.round(t/60/1e3,1e3);return o>60?o/60>24?(r=mathTools.floor(o/60/24,1)+tr2("day_abbr"),(o=mathTools.floor(o/60%24,1))>0&&(r+=" "+o+tr2("hour_abbr"))):(r=mathTools.floor(o/60,1)+tr2("hour_abbr"),(o=mathTools.floor(o%60,1))>0&&(r+=" "+o+tr2("min_abbr"))):r=mathTools.round(o%60,1)+tr2("min_abbr"),r},module.exports.tr=tr,module.exports.tr2=tr2,module.exports.nanoTemplate=function(t,r){return t.replace(/\{([\w\.]*)\}/g,function(t,o){var n=o.split("."),a=r[n.shift()];for(i=0,l=n.length;i<l;_i++)a=a[this];return void 0!==a&&null!==a?a:""})},module.exports.init=function(t){defaultTranslationMap=t.default,enTranslationMap=t.en,defaultTranslationMap||(defaultTranslationMap=enTranslationMap),i18nIsInitialized=!0,initI18N()},module.exports.isI18nIsInitialized=function(){return i18nIsInitialized};
 
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./tools/math.js":29}]},{},[23]);
diff --git a/web/src/main/resources/assets/js/translate.js b/web/src/main/resources/assets/js/translate.js
index 1d382cbe5e..5df696ac55 100644
--- a/web/src/main/resources/assets/js/translate.js
+++ b/web/src/main/resources/assets/js/translate.js
@@ -57,12 +57,14 @@ function initI18N() {
         var location_points = $("#locationpoints > div.pointDiv > input.pointInput");
         var l = location_points.size;
         $(location_points).each(function (index) {
-            if (index === 0)
+            if (index === 0) {
                 $(this).attr("placeholder", tr("from_hint"));
-            else if (index === (l - 1))
+                $(this).focus();
+            } else if (index === (l - 1)) {
                 $(this).attr("placeholder", tr("to_hint"));
-            else
+            } else {
                 $(this).attr("placeholder", tr("via_hint"));
+            }
         });
         $('.pointFlag').each(function () {
             $(this).attr('title', tr('drag_to_reorder'));
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
similarity index 96%
rename from web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
index 8838374ac1..609935761c 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
@@ -31,11 +31,11 @@
 import static org.junit.Assert.*;
 
 /**
- * Tests the DataFlagencoder with the SpatialRuleLookup enabled
+ * Tests the DataFlagEncoder with the SpatialRuleLookup enabled
  *
  * @author Robin Boldt
  */
-public class GraphHopperDataflagEncoderSpatialRulesIT {
+public class GraphHopperDataFlagEncoderSpatialRulesTest {
     private static final String DIR = "./target/north-bayreuth-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
index 427ee6e923..a98ab0a243 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
@@ -36,7 +36,7 @@
  *
  * @author Robin Boldt
  */
-public class GraphHopperLandmarksIT {
+public class GraphHopperLandmarksTest {
     private static final String DIR = "./target/landmark-test-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
similarity index 75%
rename from web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
rename to web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
index 34d909d12d..a4ee7df810 100644
--- a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
@@ -7,11 +7,13 @@
 import com.graphhopper.http.GraphHopperServerConfiguration;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.Polygon;
 import io.dropwizard.testing.junit.DropwizardAppRule;
 import org.junit.AfterClass;
 import org.junit.ClassRule;
 import org.junit.Test;
 
+import javax.ws.rs.core.Response;
 import java.io.File;
 import java.util.List;
 
@@ -19,7 +21,7 @@
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
 
-public class IsochroneResourceIT {
+public class IsochroneResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -48,7 +50,7 @@ public static void cleanUp() {
     @Test
     public void requestByTimeLimit() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary",
-                5 * 60, -1, "car", 2, false);
+                5 * 60, -1, "car", 2, false, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -63,7 +65,7 @@ public void requestByTimeLimit() throws Exception {
     @Test
     public void requestByDistanceLimit() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary", -1,
-                3_000, "car", 2, false);
+                3_000, "car", 2, false, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -78,7 +80,7 @@ public void requestByDistanceLimit() throws Exception {
     @Test
     public void requestReverseFlow() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary",
-                5 * 60, -1, "car", 2, true);
+                5 * 60, -1, "car", 2, true, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -90,6 +92,29 @@ public void requestReverseFlow() throws Exception {
         assertFalse(contains(polygon1, 42.53841, 1.635246));
     }
 
+    @Test
+    public void requestBadRequest() {
+        Response response = app.client().target("http://localhost:8080/route?point=-1.816719,51.557148").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+    }
+  
+    public void requestWithShortest() throws Exception {
+        IsochroneResponse rsp = client.isochroneGet("42.509644,1.540554", "no_key_necessary", 130,
+                -1, "car", 1, false, "shortest");
+        assertEquals(1, rsp.getPolygons().size());
+        List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
+
+        assertTrue(contains(polygon0, 42.507145, 1.527057));
+        assertFalse(contains(polygon0, 42.507081, 1.525404));
+
+        // more like a circle => shorter is expected
+        assertTrue(polygon0.size() < 185);
+        rsp = client.isochroneGet("42.509644,1.540554", "no_key_necessary", 130,
+                -1, "car", 1, false, "fastest");
+        polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
+        assertTrue(polygon0.size() >= 190);
+    }
+
     private boolean contains(List polygon, double lat, double lon) {
         int index = 0;
         double lats[] = new double[polygon.size()];
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/Polygon.java b/web/src/test/java/com/graphhopper/http/isochrone/Polygon.java
deleted file mode 100644
index 420818bbf4..0000000000
--- a/web/src/test/java/com/graphhopper/http/isochrone/Polygon.java
+++ /dev/null
@@ -1,160 +0,0 @@
-package com.graphhopper.http.isochrone;
-
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * TODO Use JTS
- */
-public class Polygon {
-
-    private final double[] lat;
-    private final double[] lon;
-
-    private double minLat;
-    private double minLon;
-    private double maxLat;
-    private double maxLon;
-
-    private final double epsilon;
-
-    public Polygon(double[] lat, double[] lon) {
-        if (lat.length != lon.length) {
-            throw new IllegalArgumentException("Points must be of equal length but was " + lat.length + " vs. " + lon.length);
-        }
-        if (lat.length == 0) {
-            throw new IllegalArgumentException("Points must not be empty");
-        }
-        this.lat = lat;
-        this.lon = lon;
-
-        for (int i = 0; i < lat.length; i++) {
-            if (i == 0) {
-                minLat = lat[i];
-                maxLat = lat[i];
-                minLon = lon[i];
-                maxLon = lon[i];
-            } else {
-                if (lat[i] < minLat) {
-                    minLat = lat[i];
-                } else if (lat[i] > maxLat) {
-                    maxLat = lat[i];
-                }
-                if (lon[i] < minLon) {
-                    minLon = lon[i];
-                } else if (lon[i] > maxLon) {
-                    maxLon = lon[i];
-                }
-            }
-        }
-
-        epsilon = (maxLat - minLat) / 10;
-    }
-
-    /**
-     * Wrapper method for {@link Polygon#contains(double, double)}.
-     */
-    public boolean contains(GHPoint point) {
-        return contains(point.lat, point.lon);
-    }
-
-    /**
-     * Implements the ray casting algorithm
-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788
-     *
-     * @param lat Latitude of the point to be checked
-     * @param lon Longitude of the point to be checked
-     * @return true if point is inside polygon
-     */
-    public boolean contains(double lat, double lon) {
-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {
-            return false;
-        }
-
-        double rayStartLat = maxLat - (minLat / 2);
-        double rayStartLon = minLon - epsilon;
-
-        boolean inside = false;
-        int len = this.lat.length;
-        for (int i = 0; i < len; i++) {
-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))
-                inside = !inside;
-        }
-        return inside;
-
-    }
-
-    private boolean edgesAreIntersecting(
-            double v1x1, double v1y1, double v1x2, double v1y2,
-            double v2x1, double v2y1, double v2x2, double v2y2
-    ) {
-
-
-        double d1, d2;
-        double a1, a2, b1, b2, c1, c2;
-
-        // Convert vector 1 to a line (line 1) of infinite length.
-        // We want the line in linear equation standard form: A*x + B*y + C = 0
-        // See: http://en.wikipedia.org/wiki/Linear_equation
-        a1 = v1y2 - v1y1;
-        b1 = v1x1 - v1x2;
-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);
-
-        // Every point (x,y), that solves the equation above, is on the line,
-        // every point that does not solve it, is not. The equation will have a
-        // positive result if it is on one side of the line and a negative one
-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector
-        // 2 into the equation above.
-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;
-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;
-
-        // If d1 and d2 both have the same sign, they are both on the same side
-        // of our line 1 and in that case no intersection is possible. Careful,
-        // 0 is a special case, that's why we don't test ">=" and "<=",
-        // but "<" and ">".
-        if (d1 > 0 && d2 > 0) return false;
-        if (d1 < 0 && d2 < 0) return false;
-
-        // The fact that vector 2 intersected the infinite line 1 above doesn't
-        // mean it also intersects the vector 1. Vector 1 is only a subset of that
-        // infinite line 1, so it may have intersected that line before the vector
-        // started or after it ended. To know for sure, we have to repeat the
-        // the same test the other way round. We start by calculating the
-        // infinite line 2 in linear equation standard form.
-        a2 = v2y2 - v2y1;
-        b2 = v2x1 - v2x2;
-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);
-
-        // Calculate d1 and d2 again, this time using points of vector 1.
-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;
-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;
-
-        // Again, if both have the same sign (and neither one is 0),
-        // no intersection is possible.
-        if (d1 > 0 && d2 > 0) return false;
-        if (d1 < 0 && d2 < 0) return false;
-
-        // If we get here, only two possibilities are left. Either the two
-        // vectors intersect in exactly one point or they are collinear, which
-        // means they intersect in any number of points from zero to infinite.
-        if ((a1 * b2) - (a2 * b1) == 0) return false;
-
-        // If they are not collinear, they must intersect in exactly one point.
-        return true;
-    }
-
-    public double getMinLat() {
-        return minLat;
-    }
-
-    public double getMinLon() {
-        return minLon;
-    }
-
-    public double getMaxLat() {
-        return maxLat;
-    }
-
-    public double getMaxLon() {
-        return maxLon;
-    }
-}
\ No newline at end of file
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
new file mode 100644
index 0000000000..3848316bbb
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
@@ -0,0 +1,118 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.isochrone;
+
+import com.graphhopper.http.GHPointConverterProvider;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.resources.PtIsochroneResource;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.ResourceTestRule;
+import org.junit.AfterClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
+
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import java.io.File;
+import java.time.LocalDateTime;
+import java.time.ZoneId;
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PtIsochroneResourceTest {
+
+    private static final String GRAPH_LOC = "target/PtIsochroneResourceTest";
+    private static final ZoneId zoneId = ZoneId.of("America/Los_Angeles");
+    private static GraphHopperStorage graphHopperStorage;
+    private static LocationIndex locationIndex;
+    private static PtIsochroneResource isochroneResource;
+    private GeometryFactory geometryFactory = new GeometryFactory();
+
+    static {
+        Helper.removeDir(new File(GRAPH_LOC));
+        final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = new EncodingManager(Arrays.asList(carFlagEncoder, footFlagEncoder, ptFlagEncoder), 8);
+        GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("../reader-gtfs/files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        isochroneResource = new PtIsochroneResource(gtfsStorage, graphHopperStorage.getEncodingManager(), graphHopperStorage, locationIndex);
+    }
+
+    @ClassRule
+    public static final ResourceTestRule resources = ResourceTestRule.builder()
+            .addProvider(new GHPointConverterProvider())
+            .setMapper(Jackson.newObjectMapper())
+            .addResource(isochroneResource)
+            .build();
+
+
+    @Test
+    public void testIsoline() {
+        WebTarget webTarget = resources
+                .target("/isochrone")
+                .queryParam("point", "36.914893,-116.76821") // NADAV
+                .queryParam("pt.earliest_departure_time", LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant())
+                .queryParam("time_limit", 6 * 60 * 60 + 49 * 60); // exactly the time I should arrive at NANAA
+        Invocation.Builder request = webTarget.request();
+        PtIsochroneResource.Response isochroneResponse = request.get(PtIsochroneResource.Response.class);
+        Geometry isoline = isochroneResponse.polygons.get(0).getGeometry();
+        // NADAV is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.76821, 36.914893)))));
+        // NANAA is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.761472, 36.914944)))));
+        // DADAN is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.768242, 36.909489)))));
+        // EMSI is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.76218, 36.905697)))));
+        // STAGECOACH is out
+        assertFalse(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.751677, 36.915682)))));
+    }
+
+    // Snap coordinate to GraphHopper's implicit grid of allowable points.
+    // Otherwise, we can't reliably use coordinates from input data in tests.
+    private Coordinate makePrecise(Coordinate coordinate) {
+        return new Coordinate(Helper.intToDegree(Helper.degreeToInt(coordinate.x)), Helper.intToDegree(Helper.degreeToInt(coordinate.y)));
+    }
+
+    @AfterClass
+    public static void close() {
+        graphHopperStorage.close();
+        locationIndex.close();
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
index 8a0674a3d9..e156867450 100644
--- a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
@@ -37,7 +37,7 @@
 /**
  * @author Peter Karich
  */
-public class ChangeGraphResourceIT {
+public class ChangeGraphResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
new file mode 100644
index 0000000000..60387208a4
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
@@ -0,0 +1,52 @@
+package com.graphhopper.http.resources;
+
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class I18nResourceTest {
+    private static final String DIR = "./target/andorra-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    static {
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("prepare.ch.weightings", "no").
+                put("graph.flag_encoders", "car").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
+            GraphHopperApplication.class, config);
+
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void requestI18n() {
+        Response response = app.client().target("http://localhost:8080/i18n").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        String str = response.readEntity(String.class);
+        assertTrue(str, str.contains("\"en\":") && str.contains("\"locale\":\"\""));
+
+        response = app.client().target("http://localhost:8080/i18n/de").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        str = response.readEntity(String.class);
+        assertTrue(str, str.contains("\"default\":") && str.contains("\"locale\":\"de\""));
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
similarity index 96%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
index 4a2c8ff43d..f27ecb63c3 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
@@ -19,7 +19,7 @@
 
 import com.graphhopper.http.GraphHopperApplication;
 import com.graphhopper.http.GraphHopperServerConfiguration;
-import com.graphhopper.http.resources.NearestResource;
+import com.graphhopper.resources.NearestResource;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import io.dropwizard.testing.junit.DropwizardAppRule;
@@ -36,7 +36,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceIT {
+public class NearestResourceTest {
     private static final String dir = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
index 42d45ea2d8..eb016196a2 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
@@ -37,7 +37,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceWithEleIT {
+public class NearestResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
similarity index 91%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index fa3a33f238..fb5cd545c8 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -46,7 +46,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceIT {
+public class RouteResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -71,7 +71,7 @@ public static void cleanUp() {
     }
 
     @Test
-    public void testBasicQuery() throws Exception {
+    public void testBasicQuery() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -83,6 +83,14 @@ public void testBasicQuery() throws Exception {
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testWrongPointFormat() {
+        final Response response = app.client().target("http://localhost:8080/route?point=1234&point=42.510071,1.548128").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+        JsonNode json = response.readEntity(JsonNode.class);
+        assertTrue("There should be an error " + json.get("message"), json.get("message").asText().contains("Cannot parse point '1234'"));
+    }
+
     @Test
     public void testQueryWithDirections() throws Exception {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
@@ -99,7 +107,7 @@ public void testQueryWithDirections() throws Exception {
 
     @Test
     public void testQueryWithStraightVia() throws Exception {
-        // Note, in general specifying straightvia does not work with CH, but this is an example where it works
+        // Note, in general specifying pass_through does not work with CH, but this is an example where it works
         final Response response = app.client().target("http://localhost:8080/route?point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -181,7 +189,7 @@ public void testPathDetails() throws Exception {
 
         List<PathDetail> edgeIdDetails = pathDetails.get("edge_id");
         assertEquals(77, edgeIdDetails.size());
-        assertEquals(3759L, edgeIdDetails.get(0).getValue());
+        assertEquals(880L, edgeIdDetails.get(0).getValue());
         assertEquals(2, edgeIdDetails.get(0).getLength());
         assertEquals(881L, edgeIdDetails.get(1).getValue());
         assertEquals(8, edgeIdDetails.get(1).getLength());
@@ -189,7 +197,7 @@ public void testPathDetails() throws Exception {
         long expectedTime = rsp.getBest().getTime();
         long actualTime = 0;
         List<PathDetail> timeDetails = pathDetails.get("time");
-        for (PathDetail pd: timeDetails) {
+        for (PathDetail pd : timeDetails) {
             actualTime += (Long) pd.getValue();
         }
 
@@ -219,7 +227,7 @@ public void testPathDetailsNoConnection() throws Exception {
 
     @Test
     public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
-        final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&details=average_speed").request().buildGet().invoke();
+        final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&details=average_speed&details=edge_id").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
         JsonNode infoJson = json.get("info");
@@ -233,6 +241,12 @@ public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
         assertEquals(14, averageSpeed.get(0).get(1).asInt());
         assertEquals(60.0, averageSpeed.get(1).get(2).asDouble(), .01);
         assertEquals(19, averageSpeed.get(1).get(1).asInt());
+        assertTrue(details.has("edge_id"));
+        JsonNode edgeIds = details.get("edge_id");
+        int firstLink = edgeIds.get(0).get(2).asInt();
+        int lastLink = edgeIds.get(edgeIds.size() - 1).get(2).asInt();
+        assertEquals(880, firstLink);
+        assertEquals(1420, lastLink);
     }
 
     @Test
@@ -277,10 +291,16 @@ public void testGraphHopperWebRealExceptions() {
         ex = rsp.getErrors().get(0);
         assertTrue("Wrong exception found: " + ex.getClass().getName()
                 + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // an IllegalArgumentException from inside the core is written as JSON
+        final Response response = app.client().target("http://localhost:8080/route?vehicle=SPACE-SHUTTLE&point=42.554851,1.536198&point=42.510071,1.548128").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+        String msg = (String) response.readEntity(Map.class).get("message");
+        assertTrue(msg, msg.contains("Vehicle not supported:"));
     }
 
     @Test
-    public void testGPX() throws Exception {
+    public void testGPX() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&type=gpx").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         String str = response.readEntity(String.class);
@@ -311,7 +331,7 @@ public void testGPXWithTrackAndWaypointsSelection() throws Exception {
     }
 
     @Test
-    public void testGPXWithError() throws Exception {
+    public void testGPXWithError() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&type=gpx").request().buildGet().invoke();
         assertEquals(400, response.getStatus());
         String str = response.readEntity(String.class);
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
index 4c3165e774..cb13a5c894 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
@@ -36,7 +36,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceWithEleIT {
+public class RouteResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
