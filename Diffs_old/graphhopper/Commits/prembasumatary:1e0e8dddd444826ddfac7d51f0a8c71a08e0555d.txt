diff --git a/.gitattributes b/.gitattributes
index ca8f2dfd33..9229c31f2c 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -3,6 +3,7 @@
 
 # Explicitly declare text files we want to always be normalized and converted 
 # to native line endings on checkout.
+*.sh text
 *.java text
 *.xml text
 *.js text
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 1b4e199d52..bc8f46f57a 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -1,6 +1,7 @@
 [Members](https://github.com/graphhopper?tab=members) and [Contributors](https://github.com/graphhopper/graphhopper/contributors)
 
  * AnahitaS, docs for Android, Android, Tomcat
+ * andreaswolf, flag encoder versioning and more
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
  * cgarreau, increase of routing success rate via subnetwork cleanup
@@ -15,7 +16,7 @@
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
  * henningvs, doc improvements
- * jansoe, one of the core developers
+ * jansoe, many improvements regarding A* algorithm, forcing direction, roundabouts etc
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
  * karussell, one of the core developers
@@ -24,10 +25,12 @@
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
  * ratrun, route relations, GPX information, bike handling etc
+ * rajanski, script to do routing via PostGIS
  * rodneyodonnell, improved dead end removal and fords
  * rodo, more descriptions
+ * Svantulden, improved documentation and nearest API
 
 # Translations
 
 A lot people helped to create translations - thanks!
-See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
\ No newline at end of file
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
diff --git a/android/app/build.gradle b/android/app/build.gradle
index d1437430be..152d1dbb52 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -6,8 +6,8 @@ android {
 
     defaultConfig {
         applicationId "com.graphhopper.android"
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion 10
+        targetSdkVersion 22
     }
 
     buildTypes {
@@ -35,7 +35,7 @@ configurations.all {
  **/
 
 dependencies {
-    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.4-SNAPSHOT') {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.5-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
@@ -46,6 +46,6 @@ dependencies {
     compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.1'
     compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.1'
 
-    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.10'
-    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.10'
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.12'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.12'
 }
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 717a64c65e..c76f32f7cc 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -76,13 +76,13 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.7.10</version>
+            <version>1.7.12</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.10</version>
+            <version>1.7.12</version>
         </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
@@ -126,7 +126,7 @@
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 8 = platform 2.2) -->                        
-                        <platform>10</platform>
+                        <platform>22</platform>
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index 4908215b43..aa1cea3964 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -1,29 +1,29 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.graphhopper.android"
-          android:versionCode="1"
-          android:versionName="0.1" >
+    package="com.graphhopper.android"
+    android:versionCode="1"
+    android:versionName="0.1" >
 
     <!-- mapsforge cache and saving maps -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    
+
     <!-- necessary to easily download maps via wifi -->
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
     <uses-sdk
-        android:minSdkVersion="8"
-        android:targetSdkVersion="19" />
+        android:minSdkVersion="10"
+        android:targetSdkVersion="22" />
 
     <application
-        android:allowBackup="true"
+        android:hardwareAccelerated="false"
+        android:allowBackup="true"        
         android:icon="@drawable/logo"
-        android:label="@string/app_name"        
+        android:label="@string/app_name"
         android:theme="@style/AppTheme" >
-        
         <activity
             android:name=".MainActivity"
-            android:label="@string/title_activity_main" 
-            android:screenOrientation="portrait">
+            android:label="@string/title_activity_main"
+            android:screenOrientation="portrait" >
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
index 63f874629a..becd0e6280 100644
--- a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -15,30 +15,37 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-public class AndroidDownloader extends Downloader {
-
-    public AndroidDownloader() {
+public class AndroidDownloader extends Downloader
+{
+    public AndroidDownloader()
+    {
         super("GraphHopper Android");
     }
 
-    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
+    @Override
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
         HttpEntity entity = getEntity(url);
         InputStream iStream = entity.getContent();
         final long length = entity.getContentLength();
 
-        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
             @Override
-            public void update(long sumBytes) {
+            public void update( long sumBytes )
+            {
                 progressListener.update((int) (100 * sumBytes / length));
             }
         });
     }
 
-    private HttpEntity getEntity(String url) {
+    private HttpEntity getEntity( String url )
+    {
         // there is something broken with HTTPS and Android HttpURLConnection
         HttpClient httpclient = new DefaultHttpClient();
         HttpGet httpget = new HttpGet(url);
-        try {
+        try
+        {
             HttpResponse response = httpclient.execute(httpget);
             HttpEntity entity = response.getEntity();
             if (entity == null)
@@ -46,13 +53,15 @@ private HttpEntity getEntity(String url) {
 
             return entity;
 
-        } catch (Exception ex) {
+        } catch (Exception ex)
+        {
             throw new RuntimeException(ex);
         }
     }
 
     @Override
-    public String downloadAsString(String url) throws IOException {
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
+    {
         return Helper.isToString(getEntity(url).getContent());
     }
 }
diff --git a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index 62923ec579..e60f0d4663 100644
--- a/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,7 +20,7 @@ protected C doInBackground( A... params )
         }
     }
 
-	public boolean hasError()
+    public boolean hasError()
     {
         return error != null;
     }
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 3cd489e212..13c3942ba0 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -77,6 +77,7 @@
     private String downloadURL;
     private File mapsFolder;
     private TileCache tileCache;
+    private TileRendererLayer tileRendererLayer;
 
     protected boolean onMapTap( LatLong tapLatLong, Point layerXY, Point tapXY )
     {
@@ -177,6 +178,14 @@ protected void onDestroy()
         hopper = null;
         // necessary?
         System.gc();
+
+        // Cleanup Mapsforge
+        this.mapView.getLayerManager().getLayers().remove(this.tileRendererLayer);
+        this.tileRendererLayer.onDestroy();
+        this.tileCache.destroy();
+        this.mapView.getModel().mapViewPosition.destroy();
+        this.mapView.destroy();
+        AndroidGraphicFactory.clearResourceMemoryCache();
     }
 
     boolean isReady()
@@ -240,7 +249,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL, false).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -261,7 +270,7 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if(nameList.isEmpty())
+                if (nameList.isEmpty())
                 {
                     logUser("No maps created for your version!? " + fileListURL);
                     return;
@@ -296,7 +305,7 @@ public void onSelect( String selectedArea, String selectedFile )
     }
 
     private void chooseArea( Button button, final Spinner spinner,
-            List<String> nameList, final MySpinnerListener mylistener )
+                             List<String> nameList, final MySpinnerListener mylistener )
     {
         final Map<String, String> nameToFullName = new TreeMap<String, String>();
         for (String fullName : nameList)
@@ -403,15 +412,15 @@ void loadMap( File areaFolder )
 
         mapView.getLayerManager().getLayers().clear();
 
-        TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
-        		mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
-                {
-                    @Override
-                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
-                    {
-                        return onMapTap(tapLatLong, layerXY, tapXY);
-                    }
-                };
+        tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
+                mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
+        {
+            @Override
+            public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
+            {
+                return onMapTap(tapLatLong, layerXY, tapXY);
+            }
+        };
         tileRendererLayer.setTextScale(1.5f);
         tileRendererLayer.setXmlRenderTheme(InternalRenderTheme.OSMARENDER);
         mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(mapDataStore.boundingBox().getCenterPoint(), (byte) 15));
@@ -430,7 +439,7 @@ protected Path saveDoInBackground( Void... v ) throws Exception
             {
                 GraphHopper tmpHopp = new GraphHopper().forMobile();
                 tmpHopp.load(new File(mapsFolder, currentArea).getAbsolutePath());
-                log("found graph " + tmpHopp.getGraph().toString() + ", nodes:" + tmpHopp.getGraph().getNodes());
+                log("found graph " + tmpHopp.getGraphHopperStorage().toString() + ", nodes:" + tmpHopp.getGraphHopperStorage().getNodes());
                 hopper = tmpHopp;
                 return null;
             }
@@ -462,9 +471,9 @@ private Polyline createPolyline( GHResponse response )
         paintStroke.setStyle(Style.STROKE);
         paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
-        {
-            25, 15
-        });
+                {
+                        25, 15
+                });
         paintStroke.setStrokeWidth(8);
 
         // TODO: new mapsforge version wants an mapsforge-paint, not an android paint.
@@ -489,7 +498,7 @@ private Marker createMarker( LatLong p, int resource )
     }
 
     public void calcPath( final double fromLat, final double fromLon,
-            final double toLat, final double toLon )
+                          final double toLat, final double toLon )
     {
 
         log("calculating path ...");
@@ -546,6 +555,7 @@ private void logUser( String str )
         log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
+
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
 
     @Override
diff --git a/core/files/N43E007hgt.zip b/core/files/N43E007.hgt.zip
similarity index 100%
rename from core/files/N43E007hgt.zip
rename to core/files/N43E007.hgt.zip
diff --git a/core/files/N49E011hgt.zip b/core/files/N49E011.hgt.zip
similarity index 100%
rename from core/files/N49E011hgt.zip
rename to core/files/N49E011.hgt.zip
diff --git a/core/files/N50E011hgt.zip b/core/files/N50E011.hgt.zip
similarity index 100%
rename from core/files/N50E011hgt.zip
rename to core/files/N50E011.hgt.zip
diff --git a/core/files/N52E008.hgt.zip b/core/files/N52E008.hgt.zip
new file mode 100644
index 0000000000..bbc3b2e502
Binary files /dev/null and b/core/files/N52E008.hgt.zip differ
diff --git a/core/files/N55W003hgt.zip b/core/files/N55W003.hgt.zip
similarity index 100%
rename from core/files/N55W003hgt.zip
rename to core/files/N55W003.hgt.zip
diff --git a/core/files/N55W004hgt.zip b/core/files/N55W004hgt.zip
deleted file mode 100644
index 3073befc2f..0000000000
Binary files a/core/files/N55W004hgt.zip and /dev/null differ
diff --git a/core/files/S29W072hgt.zip b/core/files/S29W072.hgt.zip
similarity index 100%
rename from core/files/S29W072hgt.zip
rename to core/files/S29W072.hgt.zip
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 01daaa0cde..f0775a9a96 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,5 +1,18 @@
 0.5
+    Several names have changed see #466, #467, #468
+    GraphHopper.optimize removed use postProcessing instead
+    method GraphHopper.getGraph() changed to getGraphHopperStorage()
+    the interface GraphStorage does no longer extend from the Graph interface. Use GraphHopperStorage (which implements the Graph interface via the base graph) or only Graph instead
+    now it is necessary to call baseGraph/chGraph.freeze in order to use the chGraph (to simply determine when an edgeId is a shortcut)    
+    LevelGraphStorage is now a GraphHopperStorage with an additional ch graph (CHGraphImpl)
+    GraphHopperStorage implements now the Graph interface and delegates all necessary methods to the underlying base graph. To do routing you call getGraph(CHGraph.class or Graph.class) where the parameter Graph.class returns the base graph and the behaviour is identical to GraphHopperStorage itself
+    renamed LevelGraph* to CHGraph*
+    renamed NoGraphExtension to NoOpExtension
+    removed visitedNodes method in GraphHopper replaced with per response information: response.getHints().getLong("visited_nodes.sum", 0)
+    added ability to store hints in GHResponse which will be forwarded to the json too
+    breaking change in HTTP API: error JSON format changed to be message:"" instead of within info.errors, see updated api documentation
     made GHResponse.getMillis, Path.getMillis, GPXEntry.getMillis deprecated, use getTime instead
+    in AbstractFlagEncoder, parse*() and getStr() are now deprecated, use properties.get* instead
 
 0.4
     translation key turn changed and merged with left etc into turn_left, turn_right etc
diff --git a/core/files/intellij-settings.jar b/core/files/intellij-settings.jar
new file mode 100644
index 0000000000..a7553f8d0e
Binary files /dev/null and b/core/files/intellij-settings.jar differ
diff --git a/core/files/map-bug432.osm.gz b/core/files/map-bug432.osm.gz
new file mode 100644
index 0000000000..e12a1de28d
Binary files /dev/null and b/core/files/map-bug432.osm.gz differ
diff --git a/core/files/postgis/gh_from_a_to_b_local.sql b/core/files/postgis/gh_from_a_to_b_local.sql
new file mode 100644
index 0000000000..380ae87141
--- /dev/null
+++ b/core/files/postgis/gh_from_a_to_b_local.sql
@@ -0,0 +1,62 @@
+
+CREATE OR REPLACE FUNCTION gh_from_a_to_b_local(lata double precision, lona double precision, latb double precision, lonb double precision, vehicle varchar)
+  RETURNS text[] AS
+$BODY$
+import requests, json,os
+def ms_to_hms(milliseconds):
+    hours, milliseconds = divmod(milliseconds, 3600000)
+    minutes, milliseconds = divmod(milliseconds, 60000)
+    seconds = float(milliseconds) / 1000
+    s = "%i:%02i" % (hours, minutes)
+    return s
+def ghroutetime(p1,p2,v):
+    gcurl="http://localhost:8989/route?"
+    params=[]
+    result={}
+    #result=''
+    for x in range(6):
+        params.append([])
+    params[0].append('point')
+    params[0].append(p1)
+    params[1].append('point')
+    params[1].append(p2)
+    params[2].append('instructions')
+    params[2].append('false')
+    params[3].append('calc_points')
+    params[3].append('true')
+    params[4].append('vehicle')
+    params[4].append(v)
+    params[5].append('points_encoded')
+    params[5].append('false')
+    data = requests.get(url=gcurl, params=params)
+    binary = data.content
+    result=json.loads(binary)
+    result['paths'][0]['time']=ms_to_hms(result['paths'][0]['time'])
+    distance=(result['paths'][0]['distance'])
+    time=result['paths'][0]['time']
+    geom=json.dumps(result['paths'][0]['points'])
+    return distance,time,geom
+def format_point(lat, lon):
+	p=str(lat)+', '+str(lon)
+	return p
+try:
+	dist,time,geom=ghroutetime(format_point(lata,lona),format_point(latb,lonb),vehicle)
+except:
+	dist,time,geom=0,0,''
+return dist,time,geom	
+$BODY$
+  LANGUAGE plpythonu VOLATILE
+  COST 100;
+  
+comment on function gh_from_a_to_b_local(lata double precision, lona double precision, latb double precision, lonb double precision, vehicle varchar) is 
+'
+pl/python function to enable graphhopper routing from postgis.
+Make sure to have created the extension plpythonu beforehand.
+
+Result is a text array with 
+
+Distance[m] 
+drivetime[hh:mm] 
+Geometry as GeoJSON in CRS 4326 (WGS84)
+To transform the GeoJSON geometry to wkb, use the postgis function "st_geomfromgeojson(geojson)"
+';
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index a639564511..45ceb6915a 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca de_DE el es fa fil fi fr gl he hu_HU it ja ne nl pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
+translations="en_US SKIP ar bg ca cs_CZ de_DE el es fa fil fi fr gl he hsb hu_HU it ja lt_LT ne nl pl_PL pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index f68f7cf332..4337f00b3d 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -20,25 +20,32 @@
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
  * <p/>
+ *
  * @author Peter Karich
  * @author ratrun
  */
 public class GHRequest
 {
     private String algo = "";
-    private List<GHPoint> points;
+    private final List<GHPoint> points;
     private final WeightingMap hints = new WeightingMap();
     private String vehicle = "";
     private boolean possibleToAdd = false;
     private Locale locale = Locale.US;
 
+    // List of favored start (1st element) and arrival heading (all other).
+    // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+    private final List<Double> favoredHeadings;
+
     public GHRequest()
     {
         this(5);
@@ -47,49 +54,152 @@ public GHRequest()
     public GHRequest( int size )
     {
         points = new ArrayList<GHPoint>(size);
+        favoredHeadings = new ArrayList<Double>(size);
         possibleToAdd = true;
     }
 
     /**
-     * Calculate the path from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon).
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
+     * with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference.
+     */
+    public GHRequest( double fromLat, double fromLon, double toLat, double toLon,
+                      double startHeading, double endHeading )
+    {
+        this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon), startHeading, endHeading);
+    }
+
+    /**
+     * Set routing request from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon)
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
     {
         this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
+
     /**
-     * Calculate the path from specified startPlace to endPlace.
+     * Set routing request from specified startPlace to endPlace with a preferred start and end heading.
+     * Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
      */
-    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace, double startHeading, double endHeading )
     {
         if (startPlace == null)
             throw new IllegalStateException("'from' cannot be null");
 
         if (endPlace == null)
             throw new IllegalStateException("'to' cannot be null");
+
         points = new ArrayList<GHPoint>(2);
         points.add(startPlace);
         points.add(endPlace);
+
+        favoredHeadings = new ArrayList<Double>(2);
+        validateAzimuthValue(startHeading);
+        favoredHeadings.add(startHeading);
+        validateAzimuthValue(endHeading);
+        favoredHeadings.add(endHeading);
     }
 
-    public GHRequest( List<GHPoint> points )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace )
+    {
+        this(startPlace, endPlace, Double.NaN, Double.NaN);
+    }
+
+
+    /**
+     * Set routing request
+     *
+     * @param points          List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     * @param favoredHeadings List of favored headings for starting (start point) and arrival (via and end points)
+     *                        Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest( List<GHPoint> points, List<Double> favoredHeadings )
     {
+        if (points.size() != favoredHeadings.size())
+            throw new IllegalArgumentException("Size of headings (" + favoredHeadings.size() +
+                    ") must match size of points (" + points.size() + ")");
+
+        for (Double heading : favoredHeadings)
+        {
+            validateAzimuthValue(heading);
+        }
         this.points = points;
+        this.favoredHeadings = favoredHeadings;
     }
 
-    public GHRequest addPoint( GHPoint point )
+    /**
+     * Set routing request
+     *
+     * @param points List of stopover points in order: start, 1st stop, 2nd stop, ..., end
+     */
+    public GHRequest( List<GHPoint> points )
+    {
+        this(points, Collections.nCopies(points.size(), Double.NaN));
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point          geographical position (see GHPoint)
+     * @param favoredHeading north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public GHRequest addPoint( GHPoint point, Double favoredHeading )
     {
         if (point == null)
             throw new IllegalArgumentException("point cannot be null");
+
+
         if (!possibleToAdd)
             throw new IllegalStateException("Please call empty constructor if you intent to use "
                     + "more than two places via addPlace method.");
 
         points.add(point);
+        validateAzimuthValue(favoredHeading);
+        favoredHeadings.add(favoredHeading);
+        return this;
+    }
+
+    /**
+     * Add stopover point to routing request.
+     *
+     * @param point geographical position (see GHPoint)
+     */
+    public GHRequest addPoint( GHPoint point )
+    {
+        addPoint(point, Double.NaN);
         return this;
     }
 
+    /**
+     * @return north based azimuth (clockwise) in (0, 360) or NaN for equal preference
+     */
+    public double getFavoredHeading( int i )
+    {
+        return favoredHeadings.get(i);
+    }
+
+    /**
+     * @return if there exist a preferred heading for start/via/end point i
+     */
+    public boolean hasFavoredHeading( int i )
+    {
+        if (i >= favoredHeadings.size())
+            throw new IndexOutOfBoundsException("Index: " + i + " too large for list of size " + favoredHeadings.size());
+
+        return !Double.isNaN(favoredHeadings.get(i));
+    }
+
+    // validate Azimuth entry
+    private void validateAzimuthValue( Double heading )
+    {
+        // heading must be in (0, 360) oder Nan
+        if (!Double.isNaN(heading) && ((Double.compare(heading, 360) > 0) || (Double.compare(heading, 0) < 0)))
+        {
+            throw new IllegalArgumentException("Heading " + heading + " must be in range (0,360) or NaN");
+        }
+    }
+
     public List<GHPoint> getPoints()
     {
         return points;
@@ -163,9 +273,12 @@ public String toString()
         for (GHPoint point : points)
         {
             if (res.isEmpty())
+            {
                 res = point.toString();
-            else
+            } else
+            {
                 res += "; " + point.toString();
+            }
         }
         return res + "(" + algo + ")";
     }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 985995ddc6..d5fae8c28b 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -18,8 +18,10 @@
 package com.graphhopper;
 
 import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -36,7 +38,8 @@
     private double distance;
     private double routeWeight;
     private long time;
-    private InstructionList instructions = null;
+    private InstructionList instructions;
+    private final PMap hintsMap = new PMap();
 
     public GHResponse()
     {
@@ -110,7 +113,7 @@ public GHResponse setDistance( double distance )
     /**
      * This method returns the distance of the path. Always prefer this method over
      * getPoints().calcDistance
-     * <p>
+     * <p/>
      * @return distance in meter
      */
     public double getDistance()
@@ -191,8 +194,8 @@ public BBox calcRouteBBox( BBox _fallback )
     @Override
     public String toString()
     {
-        String str = "nodes:" + list.getSize() + ": " + list.toString();
-        if (!instructions.isEmpty())
+        String str = "nodes:" + list.getSize() + "; " + list.toString();
+        if (instructions != null && !instructions.isEmpty())
             str += ", " + instructions.toString();
 
         if (hasErrors())
@@ -214,4 +217,9 @@ public InstructionList getInstructions()
 
         return instructions;
     }
+
+    public PMap getHints()
+    {
+        return hintsMap;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index b047f17bed..e7d0a6a1a9 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -26,30 +26,31 @@
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
 import java.text.SimpleDateFormat;
 import java.util.*;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
- * @see GraphHopperAPI
+ *
  * @author Peter Karich
+ * @see GraphHopperAPI
  */
 public class GraphHopper implements GraphHopperAPI
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
-    private GraphStorage graph;
+    private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
     private int defaultSegmentSize = -1;
     private String ghLocation = "";
@@ -78,19 +79,19 @@
     private boolean doPrepare = true;
     private boolean chEnabled = true;
     private String chWeightingStr = "fastest";
-    private int periodicUpdates = -1;
-    private int lazyUpdates = -1;
-    private int neighborUpdates = -1;
-    private double logMessages = -1;
+    private int preparePeriodicUpdates = -1;
+    private int prepareLazyUpdates = -1;
+    private int prepareNeighborUpdates = -1;
+    private int prepareContractedNodes = -1;
+    private double prepareLogMessages = -1;
     // for OSM import
     private String osmFile;
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils    
+    // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final AtomicLong visitedSum = new AtomicLong(0);
 
     public GraphHopper()
     {
@@ -99,9 +100,9 @@ public GraphHopper()
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph( GraphHopperStorage g )
     {
-        this.graph = g;
+        this.ghStorage = g;
         fullyLoaded = true;
         initLocationIndex();
         return this;
@@ -124,9 +125,7 @@ public GraphHopper setEncodingManager( EncodingManager em )
     FlagEncoder getDefaultVehicle()
     {
         if (encodingManager == null)
-        {
             throw new IllegalStateException("No encoding manager specified or loaded");
-        }
 
         return encodingManager.fetchEdgeEncoders().get(0);
     }
@@ -248,7 +247,8 @@ public GraphHopper setInMemory()
      * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
-     * <p>
+     * <p/>
+     *
      * @param storeOnFlush true by default
      */
     public GraphHopper setStoreOnFlush( boolean storeOnFlush )
@@ -284,6 +284,7 @@ private GraphHopper setUnsafeMemory()
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
+     *
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
@@ -313,7 +314,8 @@ public GraphHopper setDoPrepare( boolean doPrepare )
      * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
      * Disabling CH is only recommended for short routes or in combination with
      * setDefaultWeightLimit and called flexibility mode
-     * <p>
+     * <p/>
+     *
      * @see #setDefaultWeightLimit(double)
      */
     public GraphHopper setCHEnable( boolean enable )
@@ -426,20 +428,22 @@ public String getOSMFile()
 
     /**
      * The underlying graph used in algorithms.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if graph is not instantiated.
      */
-    public GraphStorage getGraph()
+    public GraphHopperStorage getGraphHopperStorage()
     {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
+        if (ghStorage == null)
+            throw new IllegalStateException("GraphHopper storage not initialized");
 
-        return graph;
+        return ghStorage;
     }
 
-    public void setGraph( GraphStorage graph )
+    public void setGraphHopperStorage( GraphHopperStorage ghStorage )
     {
-        this.graph = graph;
+        this.ghStorage = ghStorage;
+        fullyLoaded = true;
     }
 
     protected void setLocationIndex( LocationIndex locationIndex )
@@ -449,7 +453,8 @@ protected void setLocationIndex( LocationIndex locationIndex )
 
     /**
      * The location index created from the graph.
-     * <p>
+     * <p/>
+     *
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex()
@@ -561,10 +566,11 @@ public GraphHopper init( CmdArgs args )
         if (chEnabled)
             setCHWeighting(tmpCHWeighting);
 
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
+        preparePeriodicUpdates = args.getInt("prepare.updates.periodic", preparePeriodicUpdates);
+        prepareLazyUpdates = args.getInt("prepare.updates.lazy", prepareLazyUpdates);
+        prepareNeighborUpdates = args.getInt("prepare.updates.neighbor", prepareNeighborUpdates);
+        prepareContractedNodes = args.getInt("prepare.contracted-nodes", prepareContractedNodes);
+        prepareLogMessages = args.getDouble("prepare.logmessages", prepareLogMessages);
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
@@ -587,8 +593,8 @@ public GraphHopper init( CmdArgs args )
     private void printInfo()
     {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+        if (ghStorage != null)
+            logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
     }
 
     /**
@@ -618,7 +624,7 @@ private GraphHopper process( String graphHopperLocation )
         Lock lock = null;
         try
         {
-            if (graph.getDirectory().getDefaultType().isStoring())
+            if (ghStorage.getDirectory().getDefaultType().isStoring())
             {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
@@ -629,13 +635,12 @@ private GraphHopper process( String graphHopperLocation )
             try
             {
                 importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+                ghStorage.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
             } catch (IOException ex)
             {
                 throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
             }
             cleanUp();
-            optimize();
             postProcessing();
             flush();
         } finally
@@ -649,7 +654,7 @@ private GraphHopper process( String graphHopperLocation )
     protected DataReader importData() throws IOException
     {
         ensureWriteAccess();
-        if (graph == null)
+        if (ghStorage == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
         if (osmFile == null)
@@ -657,15 +662,15 @@ protected DataReader importData() throws IOException
                     + " but also cannot import from OSM file as it wasn't specified!");
 
         encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+        DataReader reader = createReader(ghStorage);
+        logger.info("using " + ghStorage.toString() + ", memory:" + Helper.getMemInfo());
         reader.readGraph();
         return reader;
     }
 
-    protected DataReader createReader( GraphStorage tmpGraph )
+    protected DataReader createReader( GraphHopperStorage ghStorage )
     {
-        return initOSMReader(new OSMReader(tmpGraph));
+        return initOSMReader(new OSMReader(ghStorage));
     }
 
     protected OSMReader initOSMReader( OSMReader reader )
@@ -685,6 +690,7 @@ protected OSMReader initOSMReader( OSMReader reader )
     /**
      * Opens existing graph.
      * <p/>
+     *
      * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
      * too)
      */
@@ -732,21 +738,17 @@ public boolean load( String graphHopperFolder )
             dataAccessType = DAType.MMAP_RO;
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
-        if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
-        else
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
-
-        graph.setSegmentSize(defaultSegmentSize);
+        GraphExtension ext = encodingManager.needsTurnCostsSupport()
+                ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
+        ghStorage = new GraphHopperStorage(chEnabled, dir, encodingManager, hasElevation(), ext);
+        ghStorage.setSegmentSize(defaultSegmentSize);
 
         Lock lock = null;
         try
         {
             // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
             // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+            if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites())
             {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
@@ -754,7 +756,7 @@ else if (encodingManager.needsTurnCostsSupport())
                     throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
             }
 
-            if (!graph.loadExisting())
+            if (!ghStorage.loadExisting())
                 return false;
 
             postProcessing();
@@ -785,11 +787,27 @@ public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
      */
     protected void postProcessing()
     {
+        // Later: move this into the GraphStorage.optimize method
+        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
+        if (sortGraph)
+        {
+            if (ghStorage.isCHPossible() && isPrepared())
+                throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
+
+            GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
+            GHUtility.sortDFS(ghStorage, newGraph);
+            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+            ghStorage = newGraph;
+        }
+
         initLocationIndex();
         if (chEnabled)
+        {
+            if (algoFactory != null)
+                throw new IllegalStateException("Customizing of the routing algorithm factory is currently not supported");
+
             algoFactory = createPrepare();
-        else
-            algoFactory = new RoutingAlgorithmFactorySimple();
+        }
 
         if (!isPrepared())
             prepare();
@@ -797,19 +815,21 @@ protected void postProcessing()
 
     private boolean isPrepared()
     {
-        return "true".equals(graph.getProperties().get("prepare.done"));
+        return "true".equals(ghStorage.getProperties().get("prepare.done"));
     }
 
     protected RoutingAlgorithmFactory createPrepare()
     {
         FlagEncoder defaultVehicle = getDefaultVehicle();
         Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
-                setLazyUpdates(lazyUpdates).
-                setNeighborUpdates(neighborUpdates).
-                setLogMessages(logMessages);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
+                new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class),
+                defaultVehicle, weighting, traversalMode);
+        tmpPrepareCH.setPeriodicUpdates(preparePeriodicUpdates).
+                setLazyUpdates(prepareLazyUpdates).
+                setNeighborUpdates(prepareNeighborUpdates).
+                setContractedNodes(prepareContractedNodes).
+                setLogMessages(prepareLogMessages);
 
         return tmpPrepareCH;
     }
@@ -818,12 +838,13 @@ protected RoutingAlgorithmFactory createPrepare()
      * Based on the weightingParameters and the specified vehicle a Weighting instance can be
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
-     * <p>
-     * @see WeightingMap
+     * <p/>
+     *
      * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
      * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
      * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
+     * @see WeightingMap
      */
     public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
@@ -836,9 +857,9 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
         } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
         {
             if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
+                result = new PriorityWeighting(encoder, weightingMap);
             else
-                result = new FastestWeighting(encoder);
+                result = new FastestWeighting(encoder, weightingMap);
         } else
         {
             throw new UnsupportedOperationException("weighting " + weighting + " not supported");
@@ -881,10 +902,10 @@ public GHResponse route( GHRequest request )
 
     protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
-        if (graph == null || !fullyLoaded)
+        if (ghStorage == null || !fullyLoaded)
             throw new IllegalStateException("Call load or importOrLoad before routing");
 
-        if (graph.isClosed())
+        if (ghStorage.isClosed())
             throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
         String vehicle = request.getVehicle();
@@ -916,8 +937,7 @@ public GHResponse route( GHRequest request )
             return Collections.emptyList();
         }
 
-        visitedSum.set(0);
-
+        long visitedNodesSum = 0;
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
 
@@ -938,18 +958,21 @@ public GHResponse route( GHRequest request )
 
         String debug = "idLookup:" + sw.stop().getSeconds() + "s";
 
-        QueryGraph queryGraph;
+        Graph routingGraph = ghStorage;
         RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
-        {
-            // fall back to normal traversing
-            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
-            queryGraph = new QueryGraph(graph.getBaseGraph());
-        } else
+        if (chEnabled)
         {
-            queryGraph = new QueryGraph(graph);
+            if (!vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+            {
+                // fall back to normal traversing
+                tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            } else
+            {
+                routingGraph = ghStorage.getGraph(CHGraph.class);
+            }
         }
 
+        QueryGraph queryGraph = new QueryGraph(routingGraph);
         queryGraph.lookup(qResults);
 
         List<Path> paths = new ArrayList<Path>(points.size() - 1);
@@ -963,9 +986,25 @@ public GHResponse route( GHRequest request )
                 algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
                 build();
 
+        boolean viaTurnPenalty = request.getHints().getBool("pass_through", false);
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
+            if (placeIndex == 1)
+            {
+                // enforce start direction
+                queryGraph.enforceHeading(fromQResult.getClosestNode(), request.getFavoredHeading(0), false);
+            } else if (viaTurnPenalty)
+            {
+                // enforce straight start after via stop
+                EdgeIteratorState incomingVirtualEdge = paths.get(placeIndex - 2).getFinalEdge();
+                queryGraph.enforceHeadingByEdgeId(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge(), false);
+            }
+
             QueryResult toQResult = qResults.get(placeIndex);
+
+            // enforce end direction
+            queryGraph.enforceHeading(toQResult.getClosestNode(), request.getFavoredHeading(placeIndex), true);
+
             sw = new StopWatch().start();
             RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
             algo.setWeightLimit(weightLimit);
@@ -979,7 +1018,10 @@ public GHResponse route( GHRequest request )
             paths.add(path);
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
 
-            visitedSum.addAndGet(algo.getVisitedNodes());
+            // reset all direction enforcements in queryGraph to avoid influencing next path
+            queryGraph.clearUnfavoredStatus();
+
+            visitedNodesSum += algo.getVisitedNodes();
             fromQResult = toQResult;
         }
 
@@ -990,12 +1032,14 @@ public GHResponse route( GHRequest request )
             throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
         rsp.setDebugInfo(debug);
+        rsp.getHints().put("visited_nodes.sum", visitedNodesSum);
+        rsp.getHints().put("visited_nodes.average", (float) visitedNodesSum / (points.size() - 1));
         return paths;
     }
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
+        LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
         tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
@@ -1015,61 +1059,44 @@ protected void initLocationIndex()
         if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
-        locationIndex = createLocationIndex(graph.getDirectory());
-    }
-
-    protected void optimize()
-    {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
-
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
-            if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
-
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
+        locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
+        boolean tmpPrepare = doPrepare && getAlgorithmFactory() instanceof PrepareContractionHierarchies;
         if (tmpPrepare)
         {
             ensureWriteAccess();
             logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+            ghStorage.freeze();
             ((PrepareContractionHierarchies) algoFactory).doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+            ghStorage.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
-        graph.getProperties().put("prepare.done", tmpPrepare);
+        ghStorage.getProperties().put("prepare.done", tmpPrepare);
     }
 
     protected void cleanUp()
     {
-        int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
+        int prevNodeCount = ghStorage.getNodes();
+        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(ghStorage, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
         preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
+        int currNodeCount = ghStorage.getNodes();
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+        logger.info("edges: " + ghStorage.getAllEdges().getMaxId() + ", nodes " + currNodeCount
+                + ", there were " + preparation.getSubNetworks()
+                + " subnetworks. removed them => " + (prevNodeCount - currNodeCount)
+                + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
-        graph.flush();
+        logger.info("flushing graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString() + ", "
+                + Helper.getMemInfo() + ")");
+        ghStorage.flush();
         fullyLoaded = true;
     }
 
@@ -1079,8 +1106,8 @@ protected void flush()
      */
     public void close()
     {
-        if (graph != null)
-            graph.close();
+        if (ghStorage != null)
+            ghStorage.close();
 
         if (locationIndex != null)
             locationIndex.close();
@@ -1125,13 +1152,4 @@ protected void ensureWriteAccess()
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
-
-    /**
-     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
-     * debugging purposes.
-     */
-    long getVisitedSum()
-    {
-        return visitedSum.get();
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 9f76e601b5..f1bc8e66d8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -27,7 +27,7 @@
     /**
      * Connects to the specified service (graphhopper URL) or loads a graph from the graphhopper
      * folder.
-     * <p>
+     * <p/>
      * @return true if successfully connected or loaded
      */
     boolean load( String urlOrFile );
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 4036672e37..6fcb3fc3aa 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -21,6 +21,7 @@
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
 import java.util.List;
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSet.java b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
index 914b892b7a..597672c888 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSet.java
@@ -33,11 +33,6 @@
 
     void clear();
 
-    /**
-     * Ensures that the specified index is valid and can be accessed.
-     */
-    void ensureCapacity( int index );
-
     /**
      * Searches for a greater or equal entry and returns it.
      * <p/>
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index d006901e16..20ae8c5433 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -34,41 +34,36 @@ public GHBitSetImpl( int nbits )
     }
 
     @Override
-    public boolean contains( int index )
+    public final boolean contains( int index )
     {
         return super.get(index);
     }
 
     @Override
-    public void add( int index )
+    public final void add( int index )
     {
         super.set(index);
     }
 
     @Override
-    public int getCardinality()
+    public final int getCardinality()
     {
         return super.cardinality();
     }
 
     @Override
-    public void ensureCapacity( int size )
-    {
-    }
-
-    @Override
-    public int next( int index )
+    public final int next( int index )
     {
         return super.nextSetBit(index);
     }
 
-    public int nextClear( int index )
+    public final int nextClear( int index )
     {
         return super.nextClearBit(index);
     }
 
     @Override
-    public GHBitSet copyTo( GHBitSet bs )
+    public final GHBitSet copyTo( GHBitSet bs )
     {
         bs.clear();
         if (bs instanceof GHBitSetImpl)
@@ -77,9 +72,8 @@ public GHBitSet copyTo( GHBitSet bs )
         } else
         {
             int len = size();
-            bs.ensureCapacity(len);
             for (int index = super.nextSetBit(0); index >= 0;
-                    index = super.nextSetBit(index + 1))
+                 index = super.nextSetBit(index + 1))
             {
                 bs.add(index);
             }
diff --git a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
index 4eca459cb2..53e9a4684f 100644
--- a/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
+++ b/core/src/main/java/com/graphhopper/coll/GHLongIntBTree.java
@@ -18,7 +18,9 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -472,6 +474,7 @@ static int binarySearch( long keys[], int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long guessedKey = keys[guess];
             if (guessedKey < key)
diff --git a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
index 7aaab98cc1..7b17fad7e7 100644
--- a/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
+++ b/core/src/main/java/com/graphhopper/coll/GHSortedCollection.java
@@ -19,6 +19,7 @@
 
 import gnu.trove.iterator.TIntIterator;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Map.Entry;
 import java.util.TreeMap;
 
diff --git a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
index 74a0f512c9..dccfae6cc6 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTBitSet.java
@@ -45,42 +45,37 @@ public GHTBitSet()
     }
 
     @Override
-    public boolean contains( int index )
+    public final boolean contains( int index )
     {
         return tHash.contains(index);
     }
 
     @Override
-    public void add( int index )
+    public final void add( int index )
     {
         tHash.add(index);
     }
 
     @Override
-    public String toString()
+    public final String toString()
     {
         return tHash.toString();
     }
 
     @Override
-    public int getCardinality()
+    public final int getCardinality()
     {
         return tHash.size();
     }
 
     @Override
-    public void clear()
+    public final void clear()
     {
         tHash.clear();
     }
 
     @Override
-    public void ensureCapacity( int index )
-    {
-    }
-
-    @Override
-    public GHBitSet copyTo( GHBitSet bs )
+    public final GHBitSet copyTo( GHBitSet bs )
     {
         bs.clear();
         if (bs instanceof GHTBitSet)
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index faee1ee386..78bf9bc378 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.BitUtil;
+
 import java.util.TreeMap;
 
 /**
@@ -67,7 +68,7 @@ public void insert( int key, int value )
     public int peekValue()
     {
         long key = map.firstEntry().getKey();
-        return (int) (key >>> 32);
+        return (int) (key >> 32);
     }
 
     public int peekKey()
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 906242e37b..96c55d345f 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -104,6 +104,7 @@ static long binarySearch( DataAccess da, long start, long len, long key )
         byte[] longBytes = new byte[8];
         while (high - low > 1)
         {
+            // use >>> for average or we could get an integer overflow. 
             guess = (high + low) >>> 1;
             long tmp = guess << 3;
             da.getBytes(tmp, longBytes, 8);
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
index 967b117b0e..e1f451a42d 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/coll/SparseArray.java b/core/src/main/java/com/graphhopper/coll/SparseArray.java
index 7b48993699..c9d9bf0392 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseArray.java
@@ -373,7 +373,8 @@ private static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
diff --git a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
index 220c23d2f2..b3e95ef529 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
@@ -396,7 +396,8 @@ static int binarySearch( int[] a, int start, int len, int key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -434,6 +435,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private int[] mKeys;
     private int[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
index e84b46824c..2398eceec7 100644
--- a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
+++ b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
@@ -400,7 +400,8 @@ static int binarySearch( long[] a, int start, int len, long key )
         int high = start + len, low = start - 1, guess;
         while (high - low > 1)
         {
-            guess = (high + low) / 2;
+            // use >>> for average or we could get an integer overflow. 
+            guess = (high + low) >>> 1;
 
             if (a[guess] < key)
             {
@@ -438,6 +439,7 @@ private void checkIntegrity()
             }
         }
     }
+
     private long[] mKeys;
     private long[] mValues;
     private int mSize;
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index 00de04f07b..c676cfad4a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -131,7 +131,7 @@ public void setTag( String name, Object value )
      */
     public boolean hasTag( String key, Object value )
     {
-        return value.equals(properties.get(key));
+        return value.equals(getTag(key, ""));
     }
 
     /**
@@ -161,7 +161,7 @@ public boolean hasTag( String key, String... values )
      */
     public final boolean hasTag( String key, Set<String> values )
     {
-        return values.contains(properties.get(key));
+        return values.contains(getTag(key, ""));
     }
 
     /**
@@ -172,12 +172,25 @@ public boolean hasTag( List<String> keyList, Set<String> values )
     {
         for (String key : keyList)
         {
-            if (values.contains(properties.get(key)))
+            if (values.contains(getTag(key, "")))
                 return true;
         }
         return false;
     }
 
+    /**
+     * Returns the first existing tag of the specified list where the order is important.
+     */
+    public String getFirstPriorityTag( List<String> restrictions )
+    {
+        for (String str : restrictions)
+        {
+            if (hasTag(str))
+                return getTag(str);
+        }
+        return "";
+    }
+
     public void removeTag( String name )
     {
         properties.remove(name);
@@ -202,5 +215,5 @@ public boolean isType( int type )
     public String toString()
     {
         return properties.toString();
-    }        
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index 276227a0e5..43c5e70f38 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -240,6 +240,7 @@ public void close() throws IOException
                 pbfReaderThread.interrupt();
         }
     }
+
     Thread pbfReaderThread;
 
     private void openPBFReader( InputStream stream )
diff --git a/core/src/main/java/com/graphhopper/reader/OSMNode.java b/core/src/main/java/com/graphhopper/reader/OSMNode.java
index d8153cbea4..ea42f49425 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMNode.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMNode.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import com.graphhopper.util.PointAccess;
+
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index e12036317e..e061372d79 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static com.graphhopper.util.Helper.nf;
+
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
@@ -48,6 +49,7 @@
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TLongObjectHashMap;
+
 import java.util.*;
 
 /**
@@ -57,7 +59,7 @@
  * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
  * osmNodeIdToIndexMap returns EMPTY.
- * <p>
+ * <p/>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
  * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
  * of the relation.
@@ -83,7 +85,8 @@
     private static final Logger logger = LoggerFactory.getLogger(OSMReader.class);
     private long locations;
     private long skippedLocations;
-    private final GraphStorage graphStorage;
+    private final GraphStorage ghStorage;
+    private final Graph graph;
     private final NodeAccess nodeAccess;
     private EncodingManager encodingManager = null;
     private int workerThreads = -1;
@@ -114,20 +117,21 @@
     // negative but increasing to avoid clash with custom created OSM files
     private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private boolean exitOnlyPillarNodeException = true;
+    private final boolean exitOnlyPillarNodeException = true;
     private File osmFile;
-    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
-    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
-    public OSMReader( GraphStorage storage )
+    public OSMReader( GraphHopperStorage ghStorage )
     {
-        this.graphStorage = storage;
-        this.nodeAccess = graphStorage.getNodeAccess();
+        this.ghStorage = ghStorage;
+        this.graph = ghStorage;
+        this.nodeAccess = graph.getNodeAccess();
 
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        pillarInfo = new PillarInfo(nodeAccess.is3D(), ghStorage.getDirectory());
     }
 
     @Override
@@ -268,7 +272,7 @@ private void writeOsm2Graph( File osmFile )
     {
         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
         logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-        graphStorage.create(tmp);
+        ghStorage.create(tmp);
         long wayStart = -1;
         long relationStart = -1;
         long counter = 1;
@@ -323,7 +327,7 @@ private void writeOsm2Graph( File osmFile )
         }
 
         finishedReading();
-        if (graphStorage.getNodes() == 0)
+        if (graph.getNodes() == 0)
             throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
     }
 
@@ -442,7 +446,7 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null)
             {
-                GraphExtension extendedStorage = graphStorage.getExtension();
+                GraphExtension extendedStorage = graph.getExtension();
                 if (extendedStorage instanceof TurnCostExtension)
                 {
                     TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
@@ -489,10 +493,10 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
 
         if (edgeOutExplorer == null || edgeInExplorer == null)
         {
-            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            edgeOutExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
             outExplorerMap.put(encoder, edgeOutExplorer);
 
-            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            edgeInExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
             inExplorerMap.put(encoder, edgeInExplorer);
         }
         return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
@@ -658,7 +662,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
+    Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
     {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
@@ -777,15 +781,22 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
                     pillarNodes.add(lat, lon);
             }
         }
-        if (towerNodeDistance == 0)
+        if (towerNodeDistance < 0.0001)
         {
             // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very release points.
+            // but end up in two very close points.
             zeroCounter++;
             towerNodeDistance = 0.0001;
         }
 
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+        if (Double.isInfinite(towerNodeDistance) || Double.isNaN(towerNodeDistance))
+        {
+            logger.warn("Bug in OSM or GraphHopper. Illegal tower node distance " + towerNodeDistance + " reset to 1m, osm way " + wayOsmId);
+            towerNodeDistance = 1;
+        }
+
+        EdgeIteratorState iter = graph.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+
         if (nodes > 2)
         {
             if (doSimplify)
@@ -893,7 +904,7 @@ private long createNewNodeId()
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
-     * <p>
+     * <p/>
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
@@ -997,10 +1008,11 @@ public OSMReader setOSMFile( File osmFile )
 
     private void printInfo( String str )
     {
-        LoggerFactory.getLogger(getClass()).info(
-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+        logger.info("finished " + str + " processing." + " nodes: " + graph.getNodes()
+                + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+                + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
+                + ", zeroCounter:" + zeroCounter
+                + " " + Helper.getMemInfo());
     }
 
     @Override
@@ -1008,9 +1020,4 @@ public String toString()
     {
         return getClass().getSimpleName();
     }
-
-    public GraphStorage getGraphStorage()
-    {
-        return graphStorage;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index c3e922d7e7..27c5c7051a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -7,11 +7,12 @@
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
- * <p>
+ * <p/>
  * @author Karl Hbner
  */
 public class OSMTurnRelation
@@ -69,13 +70,13 @@ long getOsmIdTo()
 
     /**
      * Transforms this relation into a collection of turn cost entries
-     * <p>
+     * <p/>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
     public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
+                                                                   EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
     {
         int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 0c612d5e7b..9ef7e4664e 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -25,7 +25,7 @@
 
 /**
  * This class helps to store lat,lon,ele for every node parsed in OSMReader
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PillarInfo implements PointAccess
@@ -61,7 +61,7 @@ public void ensureNode( int nodeId )
     {
         long tmp = (long) nodeId * rowSizeInBytes;
         da.ensureCapacity(tmp + rowSizeInBytes);
-    }        
+    }
 
     @Override
     public void setNode( int nodeId, double lat, double lon )
diff --git a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
index 7b6a6438ba..977337760a 100644
--- a/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/main/java/com/graphhopper/reader/PrinctonReader.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.Helper;
+
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index 0de2549665..ada6645c76 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
+
 import java.awt.image.Raster;
 import java.io.*;
 import java.net.SocketTimeoutException;
@@ -31,6 +32,7 @@
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
+
 import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
 import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
 import org.apache.xmlgraphics.image.codec.util.SeekableStream;
@@ -41,14 +43,14 @@
  * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
  * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
  * http://graphhopper.com/public/license/CGIAR.txt
- * <p>
+ * <p/>
  * Every zip contains readme.txt with the necessary information e.g.:
  * <ol>
  * <li>
  * All GeoTiffs with 6000 x 6000 pixels.
  * </li>
  * </ol>
- * <p>
+ * <p/>
  * @author NopMap
  * @author Peter Karich
  */
@@ -60,7 +62,7 @@
     private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
     private File cacheDir = new File("/tmp/cgiar");
     // for alternatives see #346
-    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";    
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
     private Directory dir;
     private DAType daType = DAType.MMAP;
     final double precision = 1e7;
@@ -105,6 +107,11 @@ public ElevationProvider setCacheDir( File cacheDir )
         return this;
     }
 
+    protected File getCacheDir()
+    {
+        return cacheDir;
+    }        
+
     @Override
     public ElevationProvider setBaseURL( String baseUrl )
     {
@@ -210,7 +217,7 @@ public double getEle( double lat, double lon )
                     {
                         entry = zis.getNextEntry();
                     }
-
+                    
                     ss = SeekableStream.wrapInputStream(zis, true);
                     TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
                     raster = imageDecoder.decodeAsRaster();
@@ -315,6 +322,9 @@ private Directory getDirectory()
     public static void main( String[] args )
     {
         CGIARProvider provider = new CGIARProvider();
+        
+        System.out.println(provider.getEle(46, -20));
+        
         // 337.0
         System.out.println(provider.getEle(49.949784, 11.57517));
         // 453.0
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index aed7740ae7..293b6a6e6d 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index c0c27c476e..f559b2d494 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -19,6 +19,7 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DataAccess;
+
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
@@ -29,7 +30,7 @@
 
 /**
  * One rectangle of height data from Shuttle Radar Topography Mission.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class HeightTile
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index fbac0cd8c5..162d8fe404 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -23,20 +23,22 @@
 import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
+
 import java.io.*;
 import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
- * <p>
+ * Elevation data from NASA (SRTM).
+ * <p/>
  * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
  * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
  * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
  * 90 meters in extent.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SRTMProvider implements ElevationProvider
@@ -72,7 +74,8 @@ public static void main( String[] args ) throws IOException
     private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
     private final double precision = 1e7;
     private final double invPrecision = 1 / precision;
-    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
+    // possible alternatives see #451
+    // http://mirror.ufs.ac.za/datasets/SRTM3/
     private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
     private boolean calcMean = false;
 
@@ -97,9 +100,9 @@ private SRTMProvider init()
         try
         {
             String strs[] =
-            {
-                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-            };
+                    {
+                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+                    };
             for (String str : strs)
             {
                 InputStream is = getClass().getResourceAsStream(str + "_names.txt");
@@ -249,7 +252,7 @@ public double getEle( double lat, double lon )
                 heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
                     File file = new File(cacheDir, new File(zippedURL).getName());
                     InputStream is;
                     // get zip file if not already in cacheDir - unzip later and in-memory only!
@@ -268,8 +271,8 @@ public double getEle( double lat, double lon )
                                 continue;
                             } catch (FileNotFoundException ex)
                             {
-                                // now try different URL (with point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                                // now try different URL (without point!), necessary if mirror is used
+                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
                                 continue;
                             }
                         }
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
index 58ab2d598c..a862aaf326 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
@@ -12,9 +12,9 @@
 
 import java.io.IOException;
 import java.util.*;
-import java.util.logging.Level;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -85,13 +85,11 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
 
         // Build the list of active and unsupported features in the file.
         List<String> supportedFeatures = Arrays.asList("OsmSchema-V0.6", "DenseNodes");
-        List<String> activeFeatures = new ArrayList<String>();
         List<String> unsupportedFeatures = new ArrayList<String>();
         for (String feature : header.getRequiredFeaturesList())
         {
             if (supportedFeatures.contains(feature))
             {
-                activeFeatures.add(feature);
             } else
             {
                 unsupportedFeatures.add(feature);
@@ -140,7 +138,7 @@ private void processOsmHeader( byte[] data ) throws InvalidProtocolBufferExcepti
         Iterator<Integer> valueIterator = values.iterator();
         if (keyIterator.hasNext())
         {
-            Map<String, String> tags = new HashMap<String, String>();
+            Map<String, String> tags = new HashMap<String, String>(keys.size());
             while (keyIterator.hasNext())
             {
                 String key = fieldDecoder.decodeString(keyIterator.next());
@@ -291,8 +289,8 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
     }
 
     private void buildRelationMembers( OSMRelation relation,
-            List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
-            PbfFieldDecoder fieldDecoder )
+                                       List<Long> memberIds, List<Integer> memberRoles, List<Osmformat.Relation.MemberType> memberTypes,
+                                       PbfFieldDecoder fieldDecoder )
     {
 
         ArrayList<OSMRelation.Member> members = relation.getMembers();
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
index 421979704f..6ff39041c0 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
@@ -2,6 +2,7 @@
 package com.graphhopper.reader.pbf;
 
 import com.graphhopper.reader.OSMElement;
+
 import java.util.Date;
 
 import java.util.LinkedList;
@@ -37,7 +38,7 @@
      * @param sink The sink to send all decoded entities to.
      */
     public PbfDecoder( PbfStreamSplitter streamSplitter, ExecutorService executorService, int maxPendingBlobs,
-            Sink sink )
+                       Sink sink )
     {
         this.streamSplitter = streamSplitter;
         this.executorService = executorService;
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
index 7615e10ae1..a1921bed2e 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfFieldDecoder.java
@@ -9,7 +9,7 @@
  * Manages decoding of the lower level PBF data structures.
  * <p/>
  * @author Brett Henderson
- * <p/>
+ *         <p/>
  */
 public class PbfFieldDecoder
 {
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 4a77796207..80b88f570f 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -79,8 +79,10 @@ public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
         to1 = to;
+
         weightApprox.setGoalNode(to);
-        currEdge = createEdgeEntry(from, 0);
+        double weightToGoal = weightApprox.approximate(from);
+        currEdge = new AStarEdge(EdgeIterator.NO_EDGE, from, 0 + weightToGoal, 0);
         if (!traversalMode.isEdgeBased())
         {
             fromMap.put(from, currEdge);
@@ -159,9 +161,9 @@ protected Path extractPath()
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 46ea986a06..7fd97d3d22 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -24,6 +24,7 @@
 import java.util.PriorityQueue;
 
 import com.graphhopper.routing.AStar.AStarEdge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 
@@ -93,17 +94,24 @@ public AStarBidirection setApproximation( WeightApproximator approx )
     }
 
     @Override
-    protected AStarEdge createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new AStarEdge(EdgeIterator.NO_EDGE, node, dist, dist);
+        throw new IllegalStateException("use AStarEdge constructor directly");
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
+        currFrom = new AStarEdge(EdgeIterator.NO_EDGE, from, weight, weight);
         weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
+
+        if (currTo != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapFrom.put(from, currFrom);
@@ -126,11 +134,18 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
+        currTo = new AStarEdge(EdgeIterator.NO_EDGE, to, weight, weight);
         weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
+
+        if (currFrom != null)
+        {
+            currFrom.weight += weightApprox.approximate(currFrom.adjNode, false);
+            currTo.weight += weightApprox.approximate(currTo.adjNode, true);
+        }
+
         if (!traversalMode.isEdgeBased())
         {
             bestWeightMapTo.put(to, currTo);
@@ -169,10 +184,15 @@ protected Path extractPath()
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
+    }
+
+    @Override
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
     @Override
@@ -217,7 +237,7 @@ boolean fillEdgesTo()
     }
 
     private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
-            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+                            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
         int currNode = currEdge.adjNode;
@@ -261,7 +281,6 @@ private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOp
         }
     }
 
-//    @Override -> TODO use only weight => then a simple EdgeEntry is possible
     public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent, int currLoc )
     {
         AStarEdge entryOther = bestWeightMapOther.get(currLoc);
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 7e92c25b06..c0c2fcd0f0 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,7 +40,9 @@
 
     protected abstract Path createAndInitPath();
 
-    abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
+    protected abstract double getCurrentFromWeight();
+
+    protected abstract double getCurrentToWeight();
 
     abstract boolean fillEdgesFrom();
 
@@ -66,11 +68,19 @@ protected void runAlgo()
     {
         while (!finished() && !isWeightLimitExceeded())
         {
-            if (!finishedFrom)
+            if (!finishedFrom && !finishedTo)
+            {
+                if (getCurrentFromWeight() < getCurrentToWeight())
+                    finishedFrom = !fillEdgesFrom();
+                else
+                    finishedTo = !fillEdgesTo();
+            } else if (!finishedFrom)
+            {
                 finishedFrom = !fillEdgesFrom();
-
-            if (!finishedTo)
+            } else
+            {
                 finishedTo = !fillEdgesTo();
+            }
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 174aa1795a..e52e24dd5a 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -90,9 +90,9 @@ protected void checkAlreadyRun()
         alreadyRun = true;
     }
 
-    protected EdgeEntry createEdgeEntry( int node, double dist )
+    protected EdgeEntry createEdgeEntry( int node, double weight )
     {
-        return new EdgeEntry(EdgeIterator.NO_EDGE, node, dist);
+        return new EdgeEntry(EdgeIterator.NO_EDGE, node, weight);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
index 6cd1313e15..433ff9cff8 100644
--- a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -30,7 +30,7 @@
  *        weighting(weighting).
  *        build();
  * </pre>
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class AlgorithmOptions
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 439a6aea69..52584c66e5 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -36,7 +36,7 @@
  * Calculates best path in bidirectional way.
  * <p/>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -67,9 +67,9 @@ protected void initCollections( int nodes )
     }
 
     @Override
-    public void initFrom( int from, double dist )
+    public void initFrom( int from, double weight )
     {
-        currFrom = createEdgeEntry(from, dist);
+        currFrom = createEdgeEntry(from, weight);
         openSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -93,9 +93,9 @@ public void initFrom( int from, double dist )
     }
 
     @Override
-    public void initTo( int to, double dist )
+    public void initTo( int to, double weight )
     {
-        currTo = createEdgeEntry(to, dist);
+        currTo = createEdgeEntry(to, weight);
         openSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -135,10 +135,15 @@ protected Path extractPath()
     }
 
     @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
+    protected double getCurrentFromWeight()
+    {
+        return currFrom.weight;
+    }
+
+    @Override
+    protected double getCurrentToWeight()
     {
-        if (bestWeightMapFrom.isEmpty() || bestWeightMapTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
+        return currTo.weight;
     }
 
     @Override
@@ -186,10 +191,9 @@ protected boolean isWeightLimitExceeded()
     }
 
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
-            TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
-    {
-        int currNode = currEdge.adjNode;
-        EdgeIterator iter = explorer.setBaseNode(currNode);
+                    TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
+    {        
+        EdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);
         while (iter.next())
         {
             if (!accept(iter, currEdge.edge))
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 6cc1649de1..a114e7b61b 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -25,6 +25,7 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index a96c414f44..3f55be5862 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -25,6 +25,7 @@
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -194,6 +195,14 @@ public Path extract()
         return setFound(true);
     }
 
+    /**
+     * Yields the final edge of the path
+     */
+    public EdgeIteratorState getFinalEdge()
+    {
+        return graph.getEdgeIteratorState(edgeIds.get(edgeIds.size() - 1), endNode);
+    }
+
     /**
      * @return the time it took to extract the path in nano (!) seconds
      */
@@ -212,7 +221,7 @@ public String getDebugInfo()
      */
     protected void processEdge( int edgeId, int adjNode )
     {
-        EdgeIteratorState iter = graph.getEdgeProps(edgeId, adjNode);
+        EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
         double dist = iter.getDistance();
         distance += dist;
         time += calcMillis(dist, iter.getFlags(), false);
@@ -251,7 +260,7 @@ protected long calcMillis( double distance, long flags, boolean revert )
     /**
      * Iterates over all edges in this path sorted from start to end and calls the visitor callback
      * for every edge.
-     * <p>
+     * <p/>
      * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
      * be stored.
      */
@@ -261,14 +270,14 @@ private void forEveryEdge( EdgeVisitor visitor )
         int len = edgeIds.size();
         for (int i = 0; i < len; i++)
         {
-            EdgeIteratorState edgeBase = graph.getEdgeProps(edgeIds.get(i), tmpNode);
+            EdgeIteratorState edgeBase = graph.getEdgeIteratorState(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
                 throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode
                         + ", array index:" + i + ", edges:" + edgeIds.size());
 
             tmpNode = edgeBase.getBaseNode();
             // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
-            edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
+            edgeBase = graph.getEdgeIteratorState(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
     }
@@ -323,7 +332,7 @@ public void next( EdgeIteratorState eb, int i )
 
     /**
      * This method calculated a list of points for this path
-     * <p>
+     * <p/>
      * @return this path its geometry
      */
     public PointList calcPoints()
@@ -416,7 +425,7 @@ public void next( EdgeIteratorState edge, int index )
                 double latitude, longitude;
 
                 PointList wayGeo = edge.fetchWayGeometry(3);
-                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+                boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
 
                 if (wayGeo.getSize() <= 2)
                 {
@@ -490,7 +499,7 @@ public void next( EdgeIteratorState edge, int index )
                         EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
                         while (edgeIter.next())
                         {
-                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            if (!encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
                             {
                                 ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
                                 break;
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
index 39cb980c28..09a27cad73 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidir.java
@@ -35,7 +35,7 @@
     private EdgeWrapper edgeWTo;
 
     public PathBidir( Graph g, FlagEncoder encoder,
-            EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
+                      EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
     {
         super(g, encoder);
         this.edgeWFrom = edgesFrom;
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ffbb943041..f4275e0da5 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -25,7 +25,6 @@
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
@@ -33,16 +32,14 @@
 import gnu.trove.procedure.TObjectProcedure;
 import gnu.trove.set.hash.TIntHashSet;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
+import java.util.*;
 
 /**
  * A class which is used to query the underlying graph with real GPS points. It does so by
  * introducing virtual nodes and edges. It is lightweight in order to be created every time a new
  * query comes in, which makes the behaviour thread safe.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class QueryGraph implements Graph
@@ -58,20 +55,22 @@
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
      * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
-    private List<EdgeIteratorState> virtualEdges;
-    private final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
+    List<VirtualEdgeIteratorState> virtualEdges;
+    final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
 
     /**
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
+    private static final AngleCalc ac = new AngleCalc();
+    private List<VirtualEdgeIteratorState> modifiedEdges = new ArrayList<VirtualEdgeIteratorState>(5);
 
     public QueryGraph( Graph graph )
     {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getCount();
+        mainEdges = graph.getAllEdges().getMaxId();
 
         if (mainGraph.getExtension() instanceof TurnCostExtension)
             wrappedExtension = new QueryGraphTurnExt(this);
@@ -117,7 +116,7 @@ public void lookup( List<QueryResult> resList )
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
         // initialize all none-final variables
-        virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
+        virtualEdges = new ArrayList<VirtualEdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
         baseGraph.virtualEdges = virtualEdges;
@@ -131,11 +130,10 @@ public void lookup( List<QueryResult> resList )
         for (QueryResult res : resList)
         {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
-            EdgeIteratorState closestEdge = res.getClosestEdge();
-
             if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            EdgeIteratorState closestEdge = res.getClosestEdge();
             if (closestEdge == null)
                 throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
 
@@ -219,6 +217,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                 GHPoint3D prevPoint = fullPL.toGHPoint(0);
                 int adjNode = closestEdge.getAdjNode();
+                int origTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
+                int origRevTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
                 long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
@@ -244,7 +244,8 @@ public int compare( QueryResult o1, QueryResult o2 )
                     }
 
                     queryResults.add(res);
-                    createEdges(prevPoint, prevWayIndex,
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
                             fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
 
@@ -267,7 +268,9 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                 // two edges between last result and adjacent node are still missing if not all points skipped
                 if (addedEdges)
-                    createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                    createEdges(origTraversalKey, origRevTraversalKey,
+                            prevPoint, prevWayIndex,
+                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
                             fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
@@ -278,7 +281,7 @@ public int compare( QueryResult o1, QueryResult o2 )
     @Override
     public Graph getBaseGraph()
     {
-        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a 
         // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
         // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
         return baseGraph;
@@ -328,9 +331,10 @@ public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
         }
     }
 
-    private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
-            PointList fullPL, EdgeIteratorState closestEdge,
-            int prevNodeId, int nodeId, long reverseFlags )
+    private void createEdges( int origTraversalKey, int origRevTraversalKey,
+                              GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+                              PointList fullPL, EdgeIteratorState closestEdge,
+                              int prevNodeId, int nodeId, long reverseFlags )
     {
         int max = wayIndex + 1;
         // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
@@ -347,15 +351,110 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
-        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
-                baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId, nodeId, prevNodeId,
-                baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
+        VirtualEdgeIteratorState baseEdge = new VirtualEdgeIteratorState(origTraversalKey,
+                virtEdgeId, prevNodeId, nodeId, baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
+        VirtualEdgeIteratorState baseReverseEdge = new VirtualEdgeIteratorState(origRevTraversalKey,
+                virtEdgeId, nodeId, prevNodeId, baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
 
         virtualEdges.add(baseEdge);
         virtualEdges.add(baseReverseEdge);
     }
 
+    /**
+     * set edges at virtual node unfavored which require at least a turn of 100 from favoredHeading
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param favoredHeading north based azimuth of favored heading between 0 and 360
+     * @param incoming if true, incoming edges are unfavored, else outgoing edges
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeading( int nodeId, double favoredHeading, boolean incoming )
+    {
+        if (!isInitialized())
+            throw new IllegalStateException("QueryGraph.lookup has to be called in before heading enforcement");
+
+        if (Double.isNaN(favoredHeading))
+            return false;
+
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        int virtNodeIDintern = nodeId - mainNodes;
+        favoredHeading = ac.convertAzimuth2xaxisAngle(favoredHeading);
+
+        // either penalize incoming or outgoing edges
+        List<Integer> edgePositions = incoming ? Arrays.asList(VE_BASE, VE_ADJ_REV) : Arrays.asList(VE_BASE_REV, VE_ADJ);
+        boolean enforcementOccured = false;
+        for (int edgePos : edgePositions)
+        {
+            VirtualEdgeIteratorState edge = virtualEdges.get(virtNodeIDintern * 4 + edgePos);
+
+            PointList wayGeo = edge.fetchWayGeometry(3);
+            double edgeOrientation;
+            if (incoming)
+            {
+                int numWayPoints = wayGeo.getSize();
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(numWayPoints - 2), wayGeo.getLon(numWayPoints - 2),
+                        wayGeo.getLat(numWayPoints - 1), wayGeo.getLon(numWayPoints - 1));
+            } else
+            {
+                edgeOrientation = ac.calcOrientation(wayGeo.getLat(0), wayGeo.getLon(0),
+                        wayGeo.getLat(1), wayGeo.getLon(1));
+            }
+
+            edgeOrientation = ac.alignOrientation(favoredHeading, edgeOrientation);
+            double delta = (edgeOrientation - favoredHeading);
+
+            if (Math.abs(delta) > 1.74) // penalize if a turn of more than 100
+            {
+                edge.setVirtualEdgePreference(true, false);
+                modifiedEdges.add(edge);
+                //also apply to opposite edge for reverse routing
+                VirtualEdgeIteratorState reverseEdge = virtualEdges.get(virtNodeIDintern * 4 + getPosOfReverseEdge(edgePos));
+                reverseEdge.setVirtualEdgePreference(true, true);
+                modifiedEdges.add(reverseEdge);
+                enforcementOccured = true;
+            }
+
+        }
+        return enforcementOccured;
+    }
+
+    /**
+     * set specific edge at virtual node unfavored, to enforce routing along other edges
+     * <p>
+     * @param nodeId VirtualNode at which edges get unfavored
+     * @param edgeId edge to become unfavored
+     * @param incoming if true, incoming edge is unfavored, else outgoing edge
+     * @return boolean indicating if enforcement took place
+     */
+    public boolean enforceHeadingByEdgeId( int nodeId, int edgeId, boolean incoming )
+    {
+        if (!isVirtualNode(nodeId))
+            return false;
+
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, nodeId);
+        VirtualEdgeIteratorState reverseEdge = (VirtualEdgeIteratorState) getEdgeIteratorState(edgeId, incomingEdge.getBaseNode());
+        incomingEdge.setVirtualEdgePreference(true, !incoming);
+        modifiedEdges.add(incomingEdge);
+        reverseEdge.setVirtualEdgePreference(true, incoming);
+        modifiedEdges.add(reverseEdge);
+        return true;
+    }
+
+    /**
+     * removes the unfavored status of all virtual edges
+     */
+    public void clearUnfavoredStatus()
+    {
+        for (VirtualEdgeIteratorState edge : modifiedEdges)
+        {
+            edge.setVirtualEdgePreference(false, false);
+            edge.setVirtualEdgePreference(false, true);
+        }
+
+    }
+
     @Override
     public int getNodes()
     {
@@ -464,21 +563,17 @@ public BBox getBounds()
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
+    public EdgeIteratorState getEdgeIteratorState( int origEdgeId, int adjNode )
     {
         if (!isVirtualEdge(origEdgeId))
-            return mainGraph.getEdgeProps(origEdgeId, adjNode);
+            return mainGraph.getEdgeIteratorState(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
         if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
+        edgeId = getPosOfReverseEdge(edgeId);
 
-        // find reverse edge via convention. see virtualEdges comment above
-        if (edgeId % 2 == 0)
-            edgeId++;
-        else
-            edgeId--;
         EdgeIteratorState eis2 = virtualEdges.get(edgeId);
         if (eis2.getAdjNode() == adjNode)
             return eis2;
@@ -486,6 +581,17 @@ public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
                 + ". found edges were:" + eis + ", " + eis2);
     }
 
+    private int getPosOfReverseEdge( int edgeId )
+    {
+        // find reverse edge via convention. see virtualEdges comment above
+        if (edgeId % 2 == 0)
+            edgeId++;
+        else
+            edgeId--;
+
+        return edgeId;
+    }
+
     @Override
     public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
     {
@@ -568,7 +674,7 @@ public EdgeIterator setBaseNode( int baseNode )
      * Creates a fake edge iterator pointing to multiple edge states.
      */
     private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
-            int node, int virtNode )
+                                  int node, int virtNode )
     {
         VirtualEdgeIterator existingIter = node2EdgeMap.get(node);
         if (existingIter == null)
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index 58d0f17a3a..675ed64816 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -24,5 +24,5 @@
  */
 public interface RoutingAlgorithmFactory
 {
-    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );   
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
index ae6609148f..e3e11cef2b 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -25,15 +25,14 @@
 
 /**
  * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
 {
     @Override
     public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
-    {        
-        AbstractRoutingAlgorithm algo;
+    {
         String algoStr = opts.getAlgorithm();
         if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
         {
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index 22abb0004f..7388faa14d 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -15,18 +15,16 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
+
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- *
  * @author Peter Karich
  */
-class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState {
+class VirtualEdgeIterator implements EdgeIterator, CHEdgeIteratorState
+{
     private final List<EdgeIteratorState> edges;
     private int current;
 
@@ -133,6 +131,12 @@ public EdgeIteratorState setName( String name )
         return edges.get(current).setName(name);
     }
 
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default)
+    {
+        return edges.get(current).getBoolean(key, reverse, _default);
+    }
+
     @Override
     public String toString()
     {
@@ -161,18 +165,18 @@ public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
     public boolean isShortcut()
     {
         EdgeIteratorState edge = edges.get(current);
-        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+        return edge instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) edge).isShortcut();
     }
 
     @Override
     public double getWeight()
     {
         // will be called only from PreparationWeighting and if isShortcut is true
-        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+        return ((CHEdgeIteratorState) edges.get(current)).getWeight();
     }
 
     @Override
-    public EdgeSkipIterState setWeight( double weight )
+    public CHEdgeIteratorState setWeight( double weight )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
@@ -194,5 +198,5 @@ public void setSkippedEdges( int edge1, int edge2 )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
similarity index 71%
rename from core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
rename to core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index 9552052d02..f99882baa5 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -15,14 +15,16 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 
 /**
  * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ * <p/>
+ * Note, this class is not suited for public use and can change with minor releases unexpectedly or
+ * even gets removed.
  */
-class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState {
+public class VirtualEdgeIteratorState implements EdgeIteratorState, CHEdgeIteratorState
+{
     private final PointList pointList;
     private final int edgeId;
     private double distance;
@@ -30,9 +32,15 @@
     private String name;
     private final int baseNode;
     private final int adjNode;
+    private final int originalTraversalKey;
+    // indication if edges are dispreferred as start/stop edge 
+    private boolean unfavoredReverseEdge;
+    private boolean unfavored;
 
-    public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+
+    public VirtualEdgeIteratorState( int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
     {
+        this.originalTraversalKey = originalTraversalKey;
         this.edgeId = edgeId;
         this.baseNode = baseNode;
         this.adjNode = adjNode;
@@ -42,6 +50,17 @@ public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance
         this.pointList = pointList;
     }
 
+    /**
+     * This method returns the original edge via its traversal key. I.e. also the direction is
+     * already correctly encoded.
+     * <p/>
+     * @see GHUtility#createEdgeKey(int, int, int, boolean)
+     */
+    public int getOriginalTraversalKey()
+    {
+        return originalTraversalKey;
+    }
+
     @Override
     public int getEdge()
     {
@@ -125,7 +144,33 @@ public EdgeIteratorState setName( String name )
         this.name = name;
         return this;
     }
+    
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default )
+    {
+        if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
+        {
+            if (reverse)
+                return unfavoredReverseEdge;
+            else
+                return unfavored;
+        }
+        // for non-existent keys return default
+        return _default;
+    }
 
+    /**
+     * set edge to unfavored status for routing from/to start/stop points
+     * @param reverse indicates if forward or backward direction is affected
+     */
+    public void setVirtualEdgePreference( boolean unfavored, boolean reverse )
+    {
+        if (reverse)
+              unfavoredReverseEdge = unfavored;
+        else
+            this.unfavored = unfavored;
+    }
+    
     @Override
     public String toString()
     {
@@ -181,7 +226,7 @@ public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
     }
 
     @Override
-    public EdgeSkipIterState setWeight( double weight )
+    public CHEdgeIteratorState setWeight( double weight )
     {
         throw new UnsupportedOperationException("Not supported.");
     }
@@ -191,5 +236,5 @@ public double getWeight()
     {
         throw new UnsupportedOperationException("Not supported.");
     }
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index d020cb5d8a..0d50c4f269 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -20,13 +20,13 @@
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
  * Recursivly unpack shortcuts.
  * <p/>
- * @see PrepareContractionHierarchies
  * @author Peter Karich
+ * @see PrepareContractionHierarchies
  */
 public class Path4CH extends PathBidirRef
 {
@@ -43,10 +43,10 @@ protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
     }
 
-    private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
+    private void expandEdge( CHEdgeIteratorState mainEdgeState, boolean reverse )
     {
         if (!mainEdgeState.isShortcut())
         {
@@ -73,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
+            CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
+                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
+            CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
+                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 9fa3bf8ed4..a5afb21395 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -20,12 +20,13 @@
 
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
- * Used in CH preparation and therefor assumed that all edges are of type EdgeSkipIterState
- * <p>
+ * Used in CH preparation and therefor assumed that all edges are of type CHEdgeIteratorState
+ * <p/>
  * @author Peter Karich
+ * @see PrepareContractionHierarchies
  */
 public class PreparationWeighting implements Weighting
 {
@@ -45,13 +46,11 @@ public final double getMinWeight( double distance )
     @Override
     public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
-        if (edgeState instanceof EdgeSkipIterState)
-        {
-            EdgeSkipIterState tmp = (EdgeSkipIterState) edgeState;
-            if (tmp.isShortcut())
-                // if a shortcut is in both directions the weight is identical => no need for 'reverse'
-                return tmp.getWeight();
-        }
+        CHEdgeIteratorState tmp = (CHEdgeIteratorState) edgeState;
+        if (tmp.isShortcut())
+            // if a shortcut is in both directions the weight is identical => no need for 'reverse'
+            return tmp.getWeight();
+
         return userWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 114fd3da8d..f098fa6438 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -27,7 +27,9 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -49,14 +51,15 @@
     private final PreparationWeighting prepareWeighting;
     private final FlagEncoder prepareFlagEncoder;
     private final TraversalMode traversalMode;
-    private EdgeSkipExplorer vehicleInExplorer;
-    private EdgeSkipExplorer vehicleOutExplorer;
-    private EdgeSkipExplorer vehicleAllExplorer;
-    private EdgeSkipExplorer vehicleAllTmpExplorer;
-    private EdgeSkipExplorer calcPrioAllExplorer;
+    private CHEdgeExplorer vehicleInExplorer;
+    private CHEdgeExplorer vehicleOutExplorer;
+    private CHEdgeExplorer vehicleAllExplorer;
+    private CHEdgeExplorer vehicleAllTmpExplorer;
+    private CHEdgeExplorer calcPrioAllExplorer;
     private final LevelEdgeFilter levelFilter;
     private int maxLevel;
-    private final LevelGraph prepareGraph;
+    private final GraphHopperStorage ghStorage;
+    private final CHGraphImpl prepareGraph;
 
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
@@ -78,10 +81,17 @@
     private int initialCollectionSize = 5000;
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
-
-    public PrepareContractionHierarchies( Directory dir, LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
+    private double dijkstraTime;
+    private double periodTime;
+    private double lazyTime;
+    private double neighborTime;
+    private int maxEdgesCount;
+
+    public PrepareContractionHierarchies( Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
+                                          FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
-        this.prepareGraph = g;
+        this.ghStorage = ghStorage;
+        this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
         this.prepareFlagEncoder = encoder;
         long scFwdDir = encoder.setAccess(0, true, false);
@@ -158,14 +168,18 @@ public PrepareContractionHierarchies setLogMessages( double logMessages )
 
     /**
      * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
-     * faster contraction duration. Not yet ready for prime time.
+     * faster contraction duration.
      */
-    void setNodesContracted( double nodesContracted )
+    public PrepareContractionHierarchies setContractedNodes( double nodesContracted )
     {
+        if (nodesContracted < 0)
+            return this;
+
         if (nodesContracted > 100)
             throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
 
         this.nodesContractedPercentage = nodesContracted;
+        return this;
     }
 
     /**
@@ -191,27 +205,12 @@ public void doWork()
         super.doWork();
 
         initFromGraph();
-        if (!prepareEdges())
-            return;
-
         if (!prepareNodes())
             return;
 
         contractNodes();
     }
 
-    boolean prepareEdges()
-    {
-        EdgeIterator iter = prepareGraph.getAllEdges();
-        int c = 0;
-        while (iter.next())
-        {
-            c++;
-            setOrigEdgeCount(iter.getEdge(), 1);
-        }
-        return c > 0;
-    }
-
     boolean prepareNodes()
     {
         int nodes = prepareGraph.getNodes();
@@ -234,7 +233,7 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getMaxId() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
@@ -251,10 +250,9 @@ void contractNodes()
         if (periodicUpdatesPercentage == 0)
             periodicUpdate = false;
 
-        // disable as preparation is slower and query time does not benefit
-        long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0L
-                : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+        // disable lazy updates for last x percentage of nodes as preparation is then a lot slower
+        // and query time does not really benefit
+        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
@@ -269,7 +267,6 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -294,17 +291,20 @@ void contractNodes()
 
             if (counter % logSize == 0)
             {
+                dijkstraTime += dijkstraSW.getSeconds();
+                periodTime += periodSW.getSeconds();
+                lazyTime += lazySW.getSeconds();
+                neighborTime += neighborSW.getSeconds();
+
                 logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
                         + ", shortcuts:" + Helper.nf(newShortcuts)
                         + ", dijkstras:" + Helper.nf(dijkstraCount)
-                        + ", t(dijk):" + (int) dijkstraSW.getSeconds()
-                        + ", t(period):" + (int) periodSW.getSeconds()
-                        + ", t(lazy):" + (int) lazySW.getSeconds()
-                        + ", t(neighbor):" + (int) neighborSW.getSeconds()
+                        + ", " + getTimesAsString()
                         + ", meanDegree:" + (long) meanDegree
                         + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
+
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
                 lazySW = new StopWatch();
@@ -313,11 +313,11 @@ void contractNodes()
 
             counter++;
             int polledNode = sortedNodes.pollKey();
-            if (sortedNodes.getSize() < lastNodesLazyUpdates)
+            if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates)
             {
                 lazySW.start();
                 int priority = oldPriorities[polledNode] = calculatePriority(polledNode);
-                if (!sortedNodes.isEmpty() && priority > sortedNodes.peekValue())
+                if (priority > sortedNodes.peekValue())
                 {
                     // current node got more important => insert as new value and contract it later
                     sortedNodes.insert(polledNode, priority);
@@ -336,7 +336,7 @@ void contractNodes()
                 // skipped nodes are already set to maxLevel
                 break;
 
-            EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
+            CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
@@ -354,22 +354,24 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
+                prepareGraph.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
         // Preparation works only once so we can release temporary data.
         // The preparation object itself has to be intact to create the algorithm.
         close();
+
+        dijkstraTime += dijkstraSW.getSeconds();
+        periodTime += periodSW.getSeconds();
+        lazyTime += lazySW.getSeconds();
+        neighborTime += neighborSW.getSeconds();
         logger.info("took:" + (int) allSW.stop().getSeconds()
-                + ", new shortcuts: " + newShortcuts
+                + ", new shortcuts: " + Helper.nf(newShortcuts)
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
                 + ", dijkstras:" + dijkstraCount
-                + ", t(dijk):" + (int) dijkstraSW.getSeconds()
-                + ", t(period):" + (int) periodSW.getSeconds()
-                + ", t(lazy):" + (int) lazySW.getSeconds()
-                + ", t(neighbor):" + (int) neighborSW.getSeconds()
+                + ", " + getTimesAsString()
                 + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
@@ -378,6 +380,31 @@ void contractNodes()
                 + ", " + Helper.getMemInfo());
     }
 
+    public long getDijkstraCount()
+    {
+        return dijkstraCount;
+    }
+
+    public double getLazyTime()
+    {
+        return lazyTime;
+    }
+
+    public double getPeriodTime()
+    {
+        return periodTime;
+    }
+
+    public double getDijkstraTime()
+    {
+        return dijkstraTime;
+    }
+
+    public double getNeighborTime()
+    {
+        return neighborTime;
+    }
+
     public void close()
     {
         prepareAlgo.close();
@@ -385,15 +412,24 @@ public void close()
         sortedNodes = null;
         oldPriorities = null;
     }
+
     AddShortcutHandler addScHandler = new AddShortcutHandler();
     CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
 
+    private String getTimesAsString()
+    {
+        return "t(dijk):" + Helper.round2(dijkstraTime)
+                + ", t(period):" + Helper.round2(periodTime)
+                + ", t(lazy):" + Helper.round2(lazyTime)
+                + ", t(neighbor):" + Helper.round2(neighborTime);
+    }
+
     interface ShortcutHandler
     {
         void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount );
+                            double existingDirectWeight, double distance,
+                            EdgeIterator outgoingEdges,
+                            int skippedEdge1, int incomingEdgeOrigCount );
 
         int getNode();
     }
@@ -420,9 +456,9 @@ public int getNode()
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double distance,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double distance,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             shortcuts++;
             originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
@@ -452,9 +488,9 @@ public AddShortcutHandler setNode( int n )
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, double existingDistSum,
-                EdgeIterator outgoingEdges,
-                int skippedEdge1, int incomingEdgeOrigCount )
+                                   double existingDirectWeight, double existingDistSum,
+                                   EdgeIterator outgoingEdges,
+                                   int skippedEdge1, int incomingEdgeOrigCount )
         {
             // FOUND shortcut 
             // but be sure that it is the only shortcut in the collection 
@@ -519,7 +555,7 @@ int calculatePriority( int v )
         // number of already contracted neighbors of v
         int contractedNeighbors = 0;
         int degree = 0;
-        EdgeSkipIterator iter = calcPrioAllExplorer.setBaseNode(v);
+        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(v);
         while (iter.next())
         {
             degree++;
@@ -625,7 +661,7 @@ int addShortcuts( int v )
         {
             boolean updatedInGraph = false;
             // check if we need to update some existing shortcut in the graph
-            EdgeSkipIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
+            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
             while (iter.next())
             {
                 if (iter.isShortcut() && iter.getAdjNode() == sc.to
@@ -640,8 +676,8 @@ int addShortcuts( int v )
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
                                 + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
                                 + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
@@ -658,7 +694,7 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
                 edgeState.setWeight(sc.weight);
@@ -682,6 +718,8 @@ String getCoords( EdgeIteratorState e, Graph g )
 
     PrepareContractionHierarchies initFromGraph()
     {
+        ghStorage.freeze();
+        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
         vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
         vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
         final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
@@ -725,9 +763,9 @@ public int getShortcuts()
     {
         int avoidNode;
         int maxLevel;
-        LevelGraph graph;
+        CHGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
+        public IgnoreNodeFilter( CHGraph g, int maxLevel )
         {
             this.graph = g;
             this.maxLevel = maxLevel;
@@ -748,17 +786,30 @@ public final boolean accept( EdgeIteratorState iter )
         }
     }
 
-    private void setOrigEdgeCount( int index, int value )
+    private void setOrigEdgeCount( int edgeId, int value )
     {
-        long tmp = (long) index * 4;
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+        {
+            // ignore setting as every normal edge has original edge count of 1            
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" + ghStorage.getAllEdges().getMaxId());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
         originalEdges.ensureCapacity(tmp + 4);
         originalEdges.setInt(tmp, value);
     }
 
-    private int getOrigEdgeCount( int index )
+    private int getOrigEdgeCount( int edgeId )
     {
-        // TODO possible memory usage improvement: avoid storing the value 1 for normal edges (does not change)!
-        long tmp = (long) index * 4;
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
         originalEdges.ensureCapacity(tmp + 4);
         return originalEdges.getInt(tmp);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index 6aee636cba..7fed0cca87 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -21,7 +21,7 @@
 /**
  * The flags are stored differently for shortcuts: just a weight and the direction flags. Currently
  * it is not allowed to store multiple vehicles.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PrepareEncoder
@@ -44,7 +44,7 @@ public static final long getScFwdDir()
     /**
      * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
      * changing the directions of flags1.
-     * <p>
+     * <p/>
      * @return true if flags2 is enabled in both directions or if both flags are pointing into the
      * same direction.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index b1e769dc80..03801d4a92 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -24,6 +24,7 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.util.*;
+
 import java.util.*;
 
 /**
@@ -38,7 +39,7 @@
 public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
 {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-    private final static int K_FORWARD = 0, K_BACKWARD = 1;
+    protected final static int K_FORWARD = 0, K_BACKWARD = 1;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
@@ -52,6 +53,8 @@
     protected long acceptBit;
     protected long ferryBit;
 
+    protected PMap properties;
+
     // This value determines the maximal possible speed of any road regardless the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
@@ -66,19 +69,29 @@
 
     /* restriction definitions where order is important */
     protected final List<String> restrictions = new ArrayList<String>(5);
-    protected final HashSet<String> intendedValues = new HashSet<String>(5);
-    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected final HashSet<String> ferries = new HashSet<String>(5);
-    protected final HashSet<String> oneways = new HashSet<String>(5);
-    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+    protected final Set<String> intendedValues = new HashSet<String>(5);
+    protected final Set<String> restrictedValues = new HashSet<String>(5);
+    protected final Set<String> ferries = new HashSet<String>(5);
+    protected final Set<String> oneways = new HashSet<String>(5);
+    protected final Set<String> acceptedRailways = new HashSet<String>(5);
     // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
-    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+    protected final Set<String> absoluteBarriers = new HashSet<String>(5);
+    protected final Set<String> potentialBarriers = new HashSet<String>(5);
     private boolean blockByDefault = true;
     private boolean blockFords = true;
     protected final int speedBits;
     protected final double speedFactor;
 
+    public AbstractFlagEncoder( PMap properties )
+    {
+        throw new RuntimeException("This method must be overridden in derived classes");
+    }
+
+    public AbstractFlagEncoder( String propertiesStr )
+    {
+        this(new PMap(propertiesStr));
+    }
+
     /**
      * @param speedBits specify the number of bits used for speed
      * @param speedFactor specify the factor to multiple the stored value (can be used to increase
@@ -130,7 +143,7 @@ public boolean isBlockFords()
 
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineNodeBits( int index, int shift )
@@ -141,7 +154,6 @@ public int defineNodeBits( int index, int shift )
     /**
      * Defines bits used for edge flags used for access, speed etc.
      * <p/>
-     * @param index
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -168,7 +180,7 @@ public int defineWayBits( int index, int shift )
 
     /**
      * Defines the bits which are used for relation flags.
-     * <p>
+     * <p/>
      * @return incremented shift value pointing behind the last used bit
      */
     public int defineRelationBits( int index, int shift )
@@ -279,15 +291,24 @@ public long setAccess( long flags, boolean forward, boolean backward )
     @Override
     public long setSpeed( long flags, double speed )
     {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed
+        if (speed < 0 || Double.isNaN(speed))
+            throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed
                     + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, false);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
+
         return speedEncoder.setDoubleValue(flags, speed);
     }
 
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        return setAccess(speedEncoder.setDoubleValue(flags, 0), false, false);
+    }
+
     @Override
     public double getSpeed( long flags )
     {
@@ -367,11 +388,24 @@ public boolean equals( Object obj )
     /**
      * @return the speed in km/h
      */
-    protected static double parseSpeed( String str )
+    protected double parseSpeed( String str )
     {
         if (Helper.isEmpty(str))
             return -1;
 
+        // on some German autobahns and a very few other places
+        if ("none".equals(str))
+            return 140;
+
+        if (str.endsWith(":rural") || str.endsWith(":trunk"))
+            return 80;
+
+        if (str.endsWith(":urban"))
+            return 50;
+
+        if (str.equals("walk") || str.endsWith(":living_street"))
+            return 6;
+
         try
         {
             int val;
@@ -544,7 +578,7 @@ long getNodeBitMask()
 
     /**
      * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
+     * <p/>
      * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
@@ -553,7 +587,7 @@ public int defineTurnBits( int index, int shift )
         if (maxTurnCosts == 0)
             return shift;
 
-        // optimization for turn restrictions only 
+        // optimization for turn restrictions only
         else if (maxTurnCosts == 1)
         {
             turnRestrictionBit = 1L << shift;
@@ -569,7 +603,7 @@ public final long getValue( long flags )
             {
                 // find value
                 flags &= mask;
-                flags >>= shift;
+                flags >>>= shift;
                 return flags;
             }
         };
@@ -714,6 +748,7 @@ public double getDouble( long flags, int key )
         throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
     }
 
+    @Deprecated
     protected static double parseDouble( String str, String key, double defaultD )
     {
         String val = getStr(str, key);
@@ -722,6 +757,7 @@ protected static double parseDouble( String str, String key, double defaultD )
         return Double.parseDouble(val);
     }
 
+    @Deprecated
     protected static long parseLong( String str, String key, long defaultL )
     {
         String val = getStr(str, key);
@@ -730,6 +766,7 @@ protected static long parseLong( String str, String key, long defaultL )
         return Long.parseLong(val);
     }
 
+    @Deprecated
     protected static boolean parseBoolean( String str, String key, boolean defaultB )
     {
         String val = getStr(str, key);
@@ -738,6 +775,7 @@ protected static boolean parseBoolean( String str, String key, boolean defaultB
         return Boolean.parseBoolean(val);
     }
 
+    @Deprecated
     protected static String getStr( String str, String key )
     {
         key = key.toLowerCase();
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
similarity index 87%
rename from core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java
rename to core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
index 5472f13182..ee52d98335 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllCHEdgesIterator.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.CHEdgeIterator;
 
 /**
  * @author Peter Karich
  */
-public interface AllEdgesSkipIterator extends AllEdgesIterator, EdgeSkipIterator
+public interface AllCHEdgesIterator extends AllEdgesIterator, CHEdgeIterator
 {
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3a88c83a7b..bde8fc1918 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -25,7 +25,7 @@
 public interface AllEdgesIterator extends EdgeIterator
 {
     /**
-     * @return the number of edges
+     * @return the maximum edgeId in the graph which is roughly the number of edges.
      */
-    int getCount();
+    int getMaxId();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
index 5df84cfe62..6164434da5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -3,49 +3,52 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 
 /**
- * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * Approximates the distance to the goal node by weighting the beeline distance according to the
+ * distance weighting
+ * <p/>
  * @author jansoe
  */
-public class BeelineWeightApproximator implements WeightApproximator {
-
-    private NodeAccess nodeAccess;
-    private Weighting weighting;
-    private DistanceCalc distanceCalc;
-    double toLat, toLon;
-
-    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+public class BeelineWeightApproximator implements WeightApproximator
+{
+    private final NodeAccess nodeAccess;
+    private final Weighting weighting;
+    private DistanceCalc distanceCalc = Helper.DIST_EARTH;
+    private double toLat, toLon;
+
+    public BeelineWeightApproximator( NodeAccess nodeAccess, Weighting weighting )
+    {
         this.nodeAccess = nodeAccess;
         this.weighting = weighting;
-        setDistanceCalc(new DistanceCalcEarth());
     }
 
-    public void setGoalNode(int toNode){
+    @Override
+    public void setGoalNode( int toNode )
+    {
         toLat = nodeAccess.getLatitude(toNode);
         toLon = nodeAccess.getLongitude(toNode);
     }
 
     @Override
-    public WeightApproximator duplicate() {
+    public WeightApproximator duplicate()
+    {
         return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
     }
 
-
     @Override
-    public double approximate(int fromNode) {
-
-        double fromLat, fromLon, dist2goal, weight2goal;
-        fromLat  = nodeAccess.getLatitude(fromNode);
-        fromLon = nodeAccess.getLongitude(fromNode);
-        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
-        weight2goal = weighting.getMinWeight(dist2goal);
-
+    public double approximate( int fromNode )
+    {
+        double fromLat = nodeAccess.getLatitude(fromNode);
+        double fromLon = nodeAccess.getLongitude(fromNode);
+        double dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        double weight2goal = weighting.getMinWeight(dist2goal);
         return weight2goal;
     }
 
-    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
+    public BeelineWeightApproximator setDistanceCalc( DistanceCalc distanceCalc )
+    {
         this.distanceCalc = distanceCalc;
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index becd547b97..8f0d7eb0e4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -21,17 +21,19 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
+
 import static com.graphhopper.util.Helper.*;
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder
 {
-    private EncodedDoubleValue reverseSpeed;
+    private EncodedDoubleValue reverseSpeedEncoder;
 
     public Bike2WeightFlagEncoder()
     {
@@ -40,7 +42,12 @@ public Bike2WeightFlagEncoder()
 
     public Bike2WeightFlagEncoder( String propertiesStr )
     {
-        super(propertiesStr);
+        super(new PMap(propertiesStr));
+    }
+
+    public Bike2WeightFlagEncoder( PMap properties )
+    {
+        super(properties);
     }
 
     public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -48,20 +55,26 @@ public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCos
         super(speedBits, speedFactor, maxTurnCosts);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     @Override
     public int defineWayBits( int index, int shift )
     {
         shift = super.defineWayBits(index, shift);
-        reverseSpeed = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, 
-                                               getHighwaySpeed("cycleway"), maxPossibleSpeed);
-        shift += reverseSpeed.getBits();
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                getHighwaySpeed("cycleway"), maxPossibleSpeed);
+        shift += reverseSpeedEncoder.getBits();
         return shift;
     }
 
     @Override
     public double getReverseSpeed( long flags )
     {
-        return reverseSpeed.getDoubleValue(flags);
+        return reverseSpeedEncoder.getDoubleValue(flags);
     }
 
     @Override
@@ -70,37 +83,36 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
-        return reverseSpeed.setDoubleValue(flags, speed);
+        return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
     @Override
-    public long handleSpeed( OSMWay way, double speed, long encoded )
+    public long handleSpeed( OSMWay way, double speed, long flags )
     {
         // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
-                && !way.hasTag("oneway:bicycle", "no")
-                && !way.hasTag("cycleway", oppositeLanes))
-        {
+        flags = super.handleSpeed(way, speed, flags);
+        if (isBackward(flags))
+            flags = setReverseSpeed(flags, speed);
 
-            if (way.hasTag("oneway", "-1"))
-            {
-                encoded |= backwardBit;
-                encoded = setReverseSpeed(encoded, speed);
-            } else
-            {
-                encoded |= forwardBit;
-                encoded = setSpeed(encoded, speed);
-            }
-        } else
-        {
-            encoded |= directionBitMask;
-            encoded = setSpeed(encoded, speed);
-            encoded = setReverseSpeed(encoded, speed);
-        }
-        return encoded;
+        if (isForward(flags))
+            flags = setSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
     }
 
     @Override
@@ -108,7 +120,7 @@ public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = super.flagsDefault(forward, backward);
         if (backward)
-            return reverseSpeed.setDefaultValue(flags);
+            return reverseSpeedEncoder.setDefaultValue(flags);
 
         return flags;
     }
@@ -130,7 +142,7 @@ public long reverseFlags( long flags )
         flags = super.reverseFlags(flags);
 
         // swap speeds 
-        double otherValue = reverseSpeed.getDoubleValue(flags);
+        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
         flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
         return setSpeed(flags, otherValue);
     }
@@ -157,9 +169,17 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double decEleSum = 0, decDist2DSum = 0;
             // double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
             double prevEle = pl.getElevation(0);
-            double fullDist2D = 0;
+            double fullDist2D = edge.getDistance();
+
+            if (Double.isInfinite(fullDist2D))
+            {
+                System.err.println("infinity distance? for way:" + way.getId());
+                return;
+            }
+            // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
+            if (fullDist2D < 1)
+                return;
 
-            fullDist2D = edge.getDistance();
             double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
             if (eleDelta > 0.1)
             {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 7d93b2e779..af99b1f01e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
@@ -47,16 +49,22 @@
     protected final Set<String> preferHighwayTags = new HashSet<String>();
     protected final Set<String> avoidHighwayTags = new HashSet<String>();
     protected final Set<String> unpavedSurfaceTags = new HashSet<String>();
-    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
-    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> trackTypeSpeeds = new HashMap<String, Integer>();
+    private final Map<String, Integer> surfaceSpeeds = new HashMap<String, Integer>();
     private final Set<String> roadValues = new HashSet<String>();
-    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> highwaySpeeds = new HashMap<String, Integer>();
     // convert network tag of bicycle routes into a way route code
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
     protected EncodedValue relationCodeEncoder;
     private EncodedValue wayTypeEncoder;
     private EncodedValue preferWayEncoder;
 
+    // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
+    private int avoidSpeedLimit;
+
+    // This is the specific bicycle class
+    private String specificBicycleClass;
+
     protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
@@ -81,7 +89,6 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         // potentialBarriers.add("lift_gate");
         potentialBarriers.add("swing_gate");
 
-        absoluteBarriers.add("kissing_gate");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
@@ -116,7 +123,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         roadValues.add("secondary_link");
         roadValues.add("tertiary");
         roadValues.add("tertiary_link");
-        
+
         maxPossibleSpeed = 30;
 
         setTrackTypeSpeed("grade1", 18); // paved
@@ -156,7 +163,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
 
         setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 18);
+        setHighwaySpeed("path", 12);
         setHighwaySpeed("footway", 6);
         setHighwaySpeed("pedestrian", 6);
         setHighwaySpeed("track", 12);
@@ -189,6 +196,14 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
 
         setCyclingNetworkPreference("deprecated", PriorityCode.AVOID_AT_ALL_COSTS.getValue());
+
+        setAvoidSpeedLimit(71);
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -196,8 +211,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"),
-                                              maxPossibleSpeed);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeeds.get("cycleway"),
+                maxPossibleSpeed);
         shift += speedEncoder.getBits();
 
         unpavedBit = 1L << shift++;
@@ -239,7 +254,7 @@ public long acceptWay( OSMWay way )
             return 0;
         }
 
-        if (!highwaySpeed.containsKey(highwayValue))
+        if (!highwaySpeeds.containsKey(highwayValue))
             return 0;
 
         // use the way if it is tagged for bikes
@@ -333,9 +348,9 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
         } else
         {
             encoded = handleFerryTags(way,
-                    highwaySpeed.get("living_street"),
-                    highwaySpeed.get("track"),
-                    highwaySpeed.get("primary"));
+                    highwaySpeeds.get("living_street"),
+                    highwaySpeeds.get("track"),
+                    highwaySpeeds.get("primary"));
             encoded |= directionBitMask;
         }
         return encoded;
@@ -344,38 +359,47 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     int getSpeed( OSMWay way )
     {
         int speed = PUSHING_SECTION_SPEED;
+        String highwayTag = way.getTag("highway");
+        Integer highwaySpeed = highwaySpeeds.get(highwayTag);
+
         String s = way.getTag("surface");
         if (!Helper.isEmpty(s))
         {
-            Integer sInt = surfaceSpeed.get(s);
-            if (sInt != null)
-                speed = sInt;
+            Integer surfaceSpeed = surfaceSpeeds.get(s);
+            if (surfaceSpeed != null)
+            {
+                speed = surfaceSpeed;
+                // Boost handling for good surfaces
+                if (highwaySpeed != null && surfaceSpeed > highwaySpeed)
+                {
+                    // Avoid boosting if pushing section
+                    if (pushingSections.contains(highwayTag))
+                        speed = highwaySpeed;
+                    else
+                        speed = surfaceSpeed;
+                }
+            }
         } else
         {
             String tt = way.getTag("tracktype");
             if (!Helper.isEmpty(tt))
             {
-                Integer tInt = trackTypeSpeed.get(tt);
+                Integer tInt = trackTypeSpeeds.get(tt);
                 if (tInt != null)
                     speed = tInt;
             } else
             {
-                String highway = way.getTag("highway");
-                if (!Helper.isEmpty(highway))
+                if (highwaySpeed != null)
                 {
-                    Integer hwInt = highwaySpeed.get(highway);
-                    if (hwInt != null)
-                    {
-                        if (way.getTag("service") == null)
-                            speed = hwInt;
-                        else
-                            speed = highwaySpeed.get("living_street");
-                    }
+                    if (!way.hasTag("service"))
+                        speed = highwaySpeed;
+                    else
+                        speed = highwaySpeeds.get("living_street");
                 }
             }
         }
 
-        // Until now we assumed that the way is no pusing section
+        // Until now we assumed that the way is no pushing section
         // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
         if ((speed > PUSHING_SECTION_SPEED)
                 && (!way.hasTag("bicycle", intendedValues) && way.hasTag("highway", pushingSections)))
@@ -441,7 +465,7 @@ String getWayName( int pavementType, int wayType, Translation tr )
     /**
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
-     * <p>
+     * <p/>
      * @return new priority based on priorityFromRelation and on the tags in OSMWay.
      */
     protected int handlePriority( OSMWay way, int priorityFromRelation )
@@ -458,6 +482,39 @@ protected int handlePriority( OSMWay way, int priorityFromRelation )
         return weightToPrioMap.lastEntry().getValue();
     }
 
+    // Conversion of class value to priority. See http://wiki.openstreetmap.org/wiki/Class:bicycle
+    private PriorityCode convertCallValueToPriority( String tagvalue )
+    {
+        int classvalue;
+        try
+        {
+            classvalue = Integer.parseInt(tagvalue);
+        } catch (NumberFormatException e)
+        {
+            return PriorityCode.UNCHANGED;
+        }
+
+        switch (classvalue)
+        {
+            case 3:
+                return PriorityCode.BEST;
+            case 2:
+                return PriorityCode.VERY_NICE;
+            case 1:
+                return PriorityCode.PREFER;
+            case 0:
+                return PriorityCode.UNCHANGED;
+            case -1:
+                return PriorityCode.AVOID_IF_POSSIBLE;
+            case -2:
+                return PriorityCode.REACH_DEST;
+            case -3:
+                return PriorityCode.AVOID_AT_ALL_COSTS;
+            default:
+                return PriorityCode.UNCHANGED;
+        }
+    }
+
     /**
      * @param weightToPrioMap associate a weight with every priority. This sorted map allows
      * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
@@ -474,27 +531,49 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
         double maxSpeed = getMaxSpeed(way);
         if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
         {
-            weightToPrioMap.put(40d, PREFER.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(40d, UNCHANGED.getValue());
+            if (maxSpeed < avoidSpeedLimit)
+            {
+                weightToPrioMap.put(40d, PREFER.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+            }
+        } else
+        {
+            if (avoidHighwayTags.contains(highway) || ((maxSpeed >= avoidSpeedLimit) && (highway != "track")))
+            {
+                weightToPrioMap.put(50d, REACH_DEST.getValue());
+                if (way.hasTag("tunnel", intendedValues))
+                    weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            }
         }
 
         if (pushingSections.contains(highway)
                 || way.hasTag("bicycle", "use_sidepath")
                 || "parking_aisle".equals(service))
         {
-            weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+            if (way.hasTag("bicycle", "yes"))
+                weightToPrioMap.put(100d, UNCHANGED.getValue());
+            else
+                weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
         }
 
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
+        if (way.hasTag("railway", "tram"))
+            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+
+        String classBicycleSpecific = way.getTag(specificBicycleClass);
+        if (classBicycleSpecific != null)
         {
-            weightToPrioMap.put(50d, REACH_DEST.getValue());
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            // We assume that humans are better in classifying preferences compared to our algorithm above -> weight = 100
+            weightToPrioMap.put(100d, convertCallValueToPriority(classBicycleSpecific).getValue());
+        } else
+        {
+            String classBicycle = way.getTag("class:bicycle");
+            if (classBicycle != null)
+            {
+                weightToPrioMap.put(100d, convertCallValueToPriority(classBicycle).getValue());
+            }
         }
 
-        if (way.hasTag("railway", "tram"))
-            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
     }
 
     /**
@@ -608,8 +687,10 @@ protected long handleSpeed( OSMWay way, double speed, long encoded )
 
         // handle oneways        
         boolean isOneway = way.hasTag("oneway", oneways)
+                || way.hasTag("oneway:bicycle", oneways)
                 || way.hasTag("vehicle:backward")
-                || way.hasTag("vehicle:forward");
+                || way.hasTag("vehicle:forward")
+                || way.hasTag("bicycle:forward");
 
         if ((isOneway || way.hasTag("junction", "roundabout"))
                 && !way.hasTag("oneway:bicycle", "no")
@@ -617,7 +698,9 @@ protected long handleSpeed( OSMWay way, double speed, long encoded )
                 && !way.hasTag("cycleway", oppositeLanes))
         {
             boolean isBackward = way.hasTag("oneway", "-1")
-                    || way.hasTag("vehicle:forward", "no");
+                    || way.hasTag("oneway:bicycle", "-1")
+                    || way.hasTag("vehicle:forward", "no")
+                    || way.hasTag("bicycle:forward", "no");
             if (isBackward)
                 encoded |= backwardBit;
             else
@@ -652,22 +735,22 @@ public int getValue()
 
     protected void setHighwaySpeed( String highway, int speed )
     {
-        highwaySpeed.put(highway, speed);
+        highwaySpeeds.put(highway, speed);
     }
 
     protected int getHighwaySpeed( String key )
     {
-        return highwaySpeed.get(key);
+        return highwaySpeeds.get(key);
     }
 
     void setTrackTypeSpeed( String tracktype, int speed )
     {
-        trackTypeSpeed.put(tracktype, speed);
+        trackTypeSpeeds.put(tracktype, speed);
     }
 
     void setSurfaceSpeed( String surface, int speed )
     {
-        surfaceSpeed.put(surface, speed);
+        surfaceSpeeds.put(surface, speed);
     }
 
     void setCyclingNetworkPreference( String network, int code )
@@ -688,4 +771,15 @@ public boolean supports( Class<?> feature )
 
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
+
+    public void setAvoidSpeedLimit( int limit )
+    {
+        avoidSpeedLimit = limit;
+    }
+
+    public void setSpecificBicycleClass( String subkey )
+    {
+        specificBicycleClass = "class:bicycle:" + subkey.toString();
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 98c28f33d2..69c1735016 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
 
 /**
  * Specifies the settings for cycletouring/trekking
@@ -32,12 +33,18 @@ public BikeFlagEncoder()
         this(4, 2, 0);
     }
 
-    public BikeFlagEncoder( String propertiesStr )
+    public BikeFlagEncoder( String propertiesString )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesString));
+    }
+
+    public BikeFlagEncoder( PMap properties )
+    {
+        this((int) properties.getLong("speedBits", 4),
+                properties.getLong("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 1 : 0);
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
     }
 
     public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -61,6 +68,15 @@ public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        absoluteBarriers.add("kissing_gate");
+        setSpecificBicycleClass("touring");
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 0edec7fea2..b1e6c0ff2c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -25,11 +25,13 @@
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+
 import java.util.*;
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  */
@@ -52,12 +54,18 @@ public CarFlagEncoder()
         this(5, 5, 0);
     }
 
+    public CarFlagEncoder( PMap properties )
+    {
+        this((int) properties.getLong("speedBits", 5),
+                properties.getDouble("speedFactor", 5),
+                properties.getBool("turnCosts", false) ? 1 : 0);
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public CarFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesStr));
     }
 
     public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -102,8 +110,8 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         badSurfaceSpeedMap.add("ground");
         badSurfaceSpeedMap.add("grass");
 
-        maxPossibleSpeed = 100;
-        
+        maxPossibleSpeed = 140;
+
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
@@ -131,6 +139,12 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         defaultSpeedMap.put("track", 15);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
@@ -139,8 +153,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), 
-                                              maxPossibleSpeed);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"),
+                maxPossibleSpeed);
         return shift + speedEncoder.getBits();
     }
 
@@ -196,13 +210,18 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
index c7b67e7c68..483e4f837a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -1,7 +1,5 @@
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.NodeAccess;
-
 /**
  * Turns an unidirectional weight Approximation into a bidirectional consistent one.
  * <p/>
@@ -9,34 +7,35 @@
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
  * pages 291296.
  * <p/>
- *
  * @author jansoe
  */
-public class ConsistentWeightApproximator {
-
-    private NodeAccess nodeAccess;
-    private Weighting weighting;
-    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+public class ConsistentWeightApproximator
+{
+    private final WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
 
-    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+    public ConsistentWeightApproximator( WeightApproximator weightApprox )
+    {
         uniDirApproximatorForward = weightApprox;
         uniDirApproximatorReverse = weightApprox.duplicate();
     }
 
-    public void setSourceNode(int sourceNode){
+    public void setSourceNode( int sourceNode )
+    {
         uniDirApproximatorReverse.setGoalNode(sourceNode);
     }
 
-    public void setGoalNode(int goalNode){
+    public void setGoalNode( int goalNode )
+    {
         uniDirApproximatorForward.setGoalNode(goalNode);
     }
 
-    public double approximate(int fromNode, boolean reverse)    {
-        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
-                                          - uniDirApproximatorReverse.approximate(fromNode));
-        if (reverse) {
+    public double approximate( int fromNode, boolean reverse )
+    {
+        double weightApproximation = 0.5
+                * (uniDirApproximatorForward.approximate(fromNode) - uniDirApproximatorReverse.approximate(fromNode));
+
+        if (reverse)
             weightApproximation *= -1;
-        }
 
         return weightApproximation;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index f00dc17928..e5233e75f0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -55,7 +55,10 @@ public long setDefaultValue( long flags )
 
     public long setDoubleValue( long flags, double value )
     {
-        // scale value        
+        if (Double.isNaN(value))
+            throw new IllegalStateException("Value cannot be NaN");
+
+        // scale value
         long tmpValue = Math.round(value / factor);
         checkValue(Math.round(tmpValue * factor));
         tmpValue <<= shift;
@@ -71,13 +74,13 @@ public double getDoubleValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return flags * factor;
     }
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedDoubleValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index d2c961bf15..d96090e13f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -92,7 +92,7 @@ public long getValue( long flags )
     {
         // find value
         flags &= mask;
-        flags >>= shift;
+        flags >>>= shift;
         return Math.round(flags * factor);
     }
 
@@ -113,7 +113,7 @@ public long getMaxValue()
 
     /**
      * Swap the contents controlled by this value encoder with the given value.
-     * <p>
+     * <p/>
      * @return the new flags
      */
     public long swap( long flags, EncodedValue otherEncoder )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 4b2aa8a183..573d1b4a99 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -26,9 +26,10 @@
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
-import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+
 import java.util.*;
 
 /**
@@ -60,8 +61,7 @@
 
     /**
      * Instantiate manager with the given list of encoders. The manager knows the default encoders:
-     * CAR, FOOT and BIKE (ignoring the case). Custom encoders can be specified by giving a full
-     * class name e.g. "car:com.graphhopper.myproject.MyCarEncoder"
+     * CAR, FOOT and BIKE (ignoring the case).
      * <p/>
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
@@ -135,39 +135,49 @@ public int getBytesForFlags()
                 entryVal = entry;
                 entry = entry.split("\\|")[0];
             }
+            PMap configuration = new PMap(entryVal);
 
             AbstractFlagEncoder fe;
             if (entry.equals(CAR))
-                fe = new CarFlagEncoder(entryVal);
+                fe = new CarFlagEncoder(configuration);
 
             else if (entry.equals(BIKE))
-                fe = new BikeFlagEncoder(entryVal);
+                fe = new BikeFlagEncoder(configuration);
 
             else if (entry.equals(BIKE2))
-                fe = new Bike2WeightFlagEncoder(entryVal);
+                fe = new Bike2WeightFlagEncoder(configuration);
 
             else if (entry.equals(RACINGBIKE))
-                fe = new RacingBikeFlagEncoder(entryVal);
+                fe = new RacingBikeFlagEncoder(configuration);
 
             else if (entry.equals(MOUNTAINBIKE))
-                fe = new MountainBikeFlagEncoder(entryVal);
+                fe = new MountainBikeFlagEncoder(configuration);
 
             else if (entry.equals(FOOT))
-                fe = new FootFlagEncoder(entryVal);
+                fe = new FootFlagEncoder(configuration);
 
             else if (entry.equals(MOTORCYCLE))
-                fe = new MotorcycleFlagEncoder(entryVal);
+                fe = new MotorcycleFlagEncoder(configuration);
 
             else
                 throw new IllegalArgumentException("entry in encoder list not supported " + entry);
 
+            if (configuration.has("version"))
+            {
+                if (fe.getVersion() != configuration.getInt("version", -1))
+                {
+                    throw new IllegalArgumentException("Encoder " + entry + " was used in version "
+                            + configuration.getLong("version", -1) + ", but current version is " + fe.getVersion());
+                }
+            }
+
             resultEncoders.add(fe);
         }
         return resultEncoders;
     }
 
     private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long.";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytesForFlags=8";
 
     private void registerEncoder( AbstractFlagEncoder encoder )
     {
@@ -290,9 +300,11 @@ public String toDetailsString()
             if (str.length() > 0)
                 str.append(",");
 
-            str.append(encoder.toString());
-            str.append("|");
-            str.append(encoder.getPropertiesString());
+            str.append(encoder.toString())
+                    .append("|")
+                    .append(encoder.getPropertiesString())
+                    .append("|version=")
+                    .append(encoder.getVersion());
         }
 
         return str.toString();
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 3a5a7f1632..2850ef17bb 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -18,11 +18,13 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
  * in seconds.
  * <p/>
+ *
  * @author Peter Karich
  */
 public class FastestWeighting implements Weighting
@@ -32,15 +34,23 @@
      * costs or traffic light costs etc)
      */
     protected final static double SPEED_CONV = 3.6;
+    final static double DEFAULT_HEADING_PENALTY = 300; //[s]
+    private final double heading_penalty;
     protected final FlagEncoder encoder;
     private final double maxSpeed;
 
-    public FastestWeighting( FlagEncoder encoder )
+    public FastestWeighting( FlagEncoder encoder, PMap pMap )
     {
         this.encoder = encoder;
+        heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
         maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
+    public FastestWeighting( FlagEncoder encoder )
+    {
+        this(encoder, new PMap(0));
+    }
+
     @Override
     public double getMinWeight( double distance )
     {
@@ -49,11 +59,19 @@ public double getMinWeight( double distance )
 
     @Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
-    {        
+    {
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / speed * SPEED_CONV;
+
+        double time = edge.getDistance() / speed * SPEED_CONV;
+
+        // add direction penalties at start/stop/via points
+        boolean penalizeEdge = edge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, reverse, false);
+        if (penalizeEdge)
+            time += heading_penalty;
+
+        return time;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 96b6a599d3..cb024b32d9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -28,6 +28,11 @@
  */
 public interface FlagEncoder extends TurnCostEncoder
 {
+    /**
+     * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are introduced
+     */
+    int getVersion();
+
     /**
      * @return the maximum speed in km/h
      */
@@ -40,7 +45,7 @@
 
     /**
      * Sets the speed in km/h.
-     * <p>
+     * <p/>
      * @return modified setProperties
      */
     long setSpeed( long flags, double speed );
@@ -57,14 +62,14 @@
 
     /**
      * Sets the access of the edge.
-     * <p>
+     * <p/>
      * @return modified flags
      */
     long setAccess( long flags, boolean forward, boolean backward );
 
     /**
      * Sets speed and access properties.
-     * <p>
+     * <p/>
      * @return created flags
      */
     long setProperties( double speed, boolean forward, boolean backward );
@@ -105,7 +110,7 @@
     long setLong( long flags, int key, long value );
 
     /**
-     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * Returns arbitrary double value identified by the specified key. E.g. can be used to return the
      * maximum width or height allowed for an edge.
      */
     double getDouble( long flags, int key );
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 85fd12d15f..762f75dfd0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -22,12 +22,15 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.*;
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author Nop
  * @author Karl Hbner
@@ -54,11 +57,19 @@ public FootFlagEncoder()
         this(4, 1);
     }
 
+    public FootFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 1)
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public FootFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 1));
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesStr));
     }
 
     public FootFlagEncoder( int speedBits, double speedFactor )
@@ -117,10 +128,16 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         hikingNetworkToCode.put("nwn", BEST.getValue());
         hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
         hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
-        
+
         maxPossibleSpeed = FERRY_SPEED;
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     @Override
     public int defineWayBits( int index, int shift )
     {
@@ -153,7 +170,7 @@ public int defineTurnBits( int index, int shift )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return <code>false</code>
      */
     @Override
@@ -164,7 +181,7 @@ public boolean isTurnRestricted( long flag )
 
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * <p>
+     * <p/>
      * @return 0
      */
     @Override
@@ -182,7 +199,6 @@ public long getTurnFlags( boolean restricted, double costs )
     /**
      * Some ways are okay but not separate for pedestrians.
      * <p/>
-     * @param way
      */
     @Override
     public long acceptWay( OSMWay way )
@@ -381,17 +397,23 @@ void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
             weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
         }
 
-        if (way.hasTag("sidewalk", sidewalks))
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
         {
-            weightToPrioMap.put(45d, PREFER.getValue());
+            if (way.hasTag("sidewalk", sidewalks))
+            {
+               weightToPrioMap.put(45d, REACH_DEST.getValue());
+            }
+            else
+            {
+                weightToPrioMap.put(45d, AVOID_AT_ALL_COSTS.getValue());
+            }
         }
-
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
+        else
         {
-            weightToPrioMap.put(50d, REACH_DEST.getValue());
-
-            if (way.hasTag("tunnel", intendedValues))
-                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+            if (way.hasTag("sidewalk", sidewalks))
+            {
+                weightToPrioMap.put(45d, PREFER.getValue());
+            }
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 985a4477d5..887ba98427 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -17,10 +17,9 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -29,10 +28,10 @@
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    private final LevelGraph graph;
+    private final CHGraph graph;
     private final int maxNodes;
 
-    public LevelEdgeFilter( LevelGraph g )
+    public LevelEdgeFilter( CHGraph g )
     {
         graph = g;
         maxNodes = g.getNodes();
@@ -48,7 +47,7 @@ public boolean accept( EdgeIteratorState edgeIterState )
             return true;
 
         // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
-        if (((EdgeSkipIterState) edgeIterState).isShortcut())
+        if (((CHEdgeIteratorState) edgeIterState).isShortcut())
             return true;
 
         return graph.getLevel(base) <= graph.getLevel(adj);
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index fc8fc55617..12d46c0cd4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -19,12 +19,15 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.HashSet;
 
 /**
  * Defines bit layout for motorbikes
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoder extends CarFlagEncoder
@@ -34,12 +37,20 @@
     private final HashSet<String> avoidSet = new HashSet<String>();
     private final HashSet<String> preferSet = new HashSet<String>();
 
+    public MotorcycleFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 5),
+                properties.getDouble("speedFactor", 5),
+                properties.getBool("turnCosts", false) ? 1 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public MotorcycleFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesStr));
     }
 
     public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -63,8 +74,8 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         avoidSet.add("motorroad");
         preferSet.add("primary");
         preferSet.add("secondary");
-        
-        maxPossibleSpeed = 100;
+
+        maxPossibleSpeed = 120;
 
         // autobahn
         defaultSpeedMap.put("motorway", 100);
@@ -93,6 +104,12 @@ public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         defaultSpeedMap.put("track", 15);
     }
 
+    @Override
+    public int getVersion()
+    {
+        return 1;
+    }
+
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
@@ -101,8 +118,8 @@ public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, 
-                                                     defaultSpeedMap.get("secondary"), maxPossibleSpeed);
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
+                defaultSpeedMap.get("secondary"), maxPossibleSpeed);
         shift += reverseSpeedEncoder.getBits();
 
         preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
@@ -142,13 +159,17 @@ public long acceptWay( OSMWay way )
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
+        String firstValue = way.getFirstPriorityTag(restrictions);
+        if (!firstValue.isEmpty())
+        {
+            if (restrictedValues.contains(firstValue))
+                return 0;
+            if (intendedValues.contains(firstValue))
+                return acceptBit;
+        }
 
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+        // do not drive street cars into fords
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -224,12 +245,24 @@ public long setReverseSpeed( long flags, double speed )
         if (speed < 0)
             throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
+        if (speed < speedEncoder.factor / 2)
+            return setLowSpeed(flags, speed, true);
+
         if (speed > getMaxSpeed())
             speed = getMaxSpeed();
 
         return reverseSpeedEncoder.setDoubleValue(flags, speed);
     }
 
+    @Override
+    protected long setLowSpeed( long flags, double speed, boolean reverse )
+    {
+        if (reverse)
+            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
+
+        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
+    }
+
     @Override
     public long flagsDefault( boolean forward, boolean backward )
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index 585b424f8a..7c5b056ea7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -26,6 +26,7 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
 
 /**
  * Specifies the settings for mountain biking
@@ -40,12 +41,20 @@ public MountainBikeFlagEncoder()
         this(4, 2, 0);
     }
 
+    public MountainBikeFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 1 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public MountainBikeFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesStr));
     }
 
     public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
@@ -133,6 +142,15 @@ public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCo
         preferHighwayTags.add("tertiary_link");
         preferHighwayTags.add("residential");
         preferHighwayTags.add("unclassified");
+
+        potentialBarriers.add("kissing_gate");
+        setSpecificBicycleClass("mtb");
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
@@ -177,7 +195,7 @@ boolean allowedSacScale( String sacScale )
 
     @Override
     public String toString()
-    {        
+    {
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index a02bf36a83..cf39fbc627 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -19,8 +19,9 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.*;
+
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -40,7 +41,7 @@
 public class PrepareRoutingSubnetworks
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final GraphStorage g;
+    private final GraphHopperStorage ghStorage;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
@@ -48,9 +49,9 @@
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
     private FlagEncoder singleEncoder;
 
-    public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
+    public PrepareRoutingSubnetworks( GraphHopperStorage ghStorage, EncodingManager em )
     {
-        this.g = g;
+        this.ghStorage = ghStorage;
         List<FlagEncoder> encoders = em.fetchEdgeEncoders();
         if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
@@ -73,17 +74,20 @@ public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSi
     public void doWork()
     {
         int del = removeZeroDegreeNodes();
-        Map<Integer, Integer> map = findSubnetworks();
-        keepLargeNetworks(map);
 
         int unvisitedDeadEnds = -1;
-        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+        if (minOneWayNetworkSize > 0 && singleEncoder != null)
+        {
             unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
+        }
+
+        Map<Integer, Integer> map = findSubnetworks();
+        keepLargeNetworks(map);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
                 + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
-        g.optimize();
+        ghStorage.optimize();
         subNetworks = map.size();
     }
 
@@ -94,18 +98,18 @@ public int getSubNetworks()
 
     public Map<Integer, Integer> findSubnetworks()
     {
-        return findSubnetworks(g.createEdgeExplorer(edgeFilter));
+        return findSubnetworks(ghStorage.createEdgeExplorer(edgeFilter));
     }
 
     private Map<Integer, Integer> findSubnetworks( final EdgeExplorer explorer )
     {
         final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
         final AtomicInteger integ = new AtomicInteger(0);
-        int locs = g.getNodes();
+        int locs = ghStorage.getNodes();
         final GHBitSet bs = new GHBitSetImpl(locs);
         for (int start = 0; start < locs; start++)
         {
-            if (g.isNodeRemoved(start) || bs.contains(start))
+            if (ghStorage.isNodeRemoved(start) || bs.contains(start))
                 continue;
 
             new BreadthFirstSearch()
@@ -121,6 +125,9 @@ protected GHBitSet createBitSet()
                 @Override
                 protected final boolean goFurther( int nodeId )
                 {
+                    if (ghStorage.isNodeRemoved(nodeId))
+                        return false;
+
                     if (tmpCounter > maxEdgesPerNode.get())
                         maxEdgesPerNode.set(tmpCounter);
 
@@ -148,12 +155,13 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
      */
     void keepLargeNetworks( Map<Integer, Integer> map )
     {
-        if (map.size() < 2)
+        if (map.size() <= 1)
             return;
 
         int biggestStart = -1;
         int maxCount = -1;
-        GHBitSetImpl bs = new GHBitSetImpl(g.getNodes());
+        int allRemoved = 0;
+        GHBitSetImpl bs = new GHBitSetImpl(ghStorage.getNodes());
         for (Entry<Integer, Integer> e : map.entrySet())
         {
             if (biggestStart < 0)
@@ -163,32 +171,40 @@ void keepLargeNetworks( Map<Integer, Integer> map )
                 continue;
             }
 
+            int removed;
             if (maxCount < e.getValue())
             {
                 // new biggest area found. remove old
-                removeNetwork(biggestStart, maxCount, bs);
+                removed = removeNetwork(biggestStart, maxCount, bs);
 
                 biggestStart = e.getKey();
                 maxCount = e.getValue();
             } else
             {
-                removeNetwork(e.getKey(), e.getValue(), bs);
+                removed = removeNetwork(e.getKey(), e.getValue(), bs);
             }
+
+            allRemoved += removed;
         }
+
+        if (allRemoved > ghStorage.getNodes() / 2)
+            throw new IllegalStateException("Too many total nodes were removed: " + allRemoved + ", all nodes:" + ghStorage.getNodes());
     }
 
     /**
      * Deletes the complete subnetwork reachable through start
      */
-    void removeNetwork( int start, int entries, final GHBitSet bs )
+    int removeNetwork( int start, int entries, final GHBitSet bs )
     {
         if (entries >= minNetworkSize)
         {
             // logger.info("did not remove large network (" + entries + ")");
-            return;
+            return 0;
         }
-        EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new DepthFirstSearch()
+
+        final AtomicInteger removed = new AtomicInteger(0);
+        EdgeExplorer explorer = ghStorage.createEdgeExplorer(edgeFilter);
+        new BreadthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -199,10 +215,37 @@ protected GHBitSet createBitSet()
             @Override
             protected boolean goFurther( int nodeId )
             {
-                g.markNodeRemoved(nodeId);
+                if (ghStorage.isNodeRemoved(nodeId))
+                    return false;
+
+                ghStorage.markNodeRemoved(nodeId);
+                removed.incrementAndGet();
                 return super.goFurther(nodeId);
             }
         }.start(explorer, start);
+
+        if (entries != removed.get())
+            throw new IllegalStateException("Did not expect " + removed.get() + " removed nodes; "
+                    + " Expected:" + entries + ", all nodes:" + ghStorage.getNodes() + "; "
+                    + " Neighbours:" + toString(explorer.setBaseNode(start)) + "; "
+                    + " Start:" + start + "  (" + ghStorage.getNodeAccess().getLat(start) + "," + ghStorage.getNodeAccess().getLon(start) + ")");
+
+        return removed.get();
+    }
+
+    String toString( EdgeIterator iter )
+    {
+        String str = "";
+        while (iter.next())
+        {
+            int adjNode = iter.getAdjNode();
+            str += adjNode + " (" + ghStorage.getNodeAccess().getLat(adjNode) + "," + ghStorage.getNodeAccess().getLon(adjNode) + "), ";
+            str += "speed  (fwd:" + singleEncoder.getSpeed(iter.getFlags()) + ", rev:" + singleEncoder.getReverseSpeed(iter.getFlags()) + "), ";
+            str += "access (fwd:" + singleEncoder.isForward(iter.getFlags()) + ", rev:" + singleEncoder.isBackward(iter.getFlags()) + "), ";
+            str += "distance:" + iter.getDistance();
+            str += ";\n ";
+        }
+        return str;
     }
 
     /**
@@ -213,47 +256,47 @@ protected boolean goFurther( int nodeId )
     int removeZeroDegreeNodes()
     {
         int removed = 0;
-        int locs = g.getNodes();
-        EdgeExplorer explorer = g.createEdgeExplorer();
+        int locs = ghStorage.getNodes();
+        EdgeExplorer explorer = ghStorage.createEdgeExplorer();
         for (int start = 0; start < locs; start++)
         {
             EdgeIterator iter = explorer.setBaseNode(start);
             if (!iter.next())
             {
                 removed++;
-                g.markNodeRemoved(start);
+                ghStorage.markNodeRemoved(start);
             }
         }
         return removed;
     }
 
     /**
-     * Clean small networks that will be never be visited by this explorer See #86 For example,
+     * Clean small networks that will be never be visited by this explorer See #86 for example,
      * small areas like parking lots are sometimes connected to the whole network through a one-way
-     * road. This is clearly an error - but is causes the routing to fail when point get connected
-     * to this small area. This routines removed all these points from the graph.
+     * road. This is clearly an error - but is causes the routing to fail when a point gets
+     * connected to this small area. This routine removes all these points from the graph.
      * <p/>
-     * @return number of removed nodes;
+     * @return number of removed nodes
      */
     public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
     {
-        // Partition g into strongly connected components using Tarjan's Algorithm.
+        // Partition g into strongly connected components using Tarjan's algorithm.
         final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
-        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
+        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(ghStorage, filter).findComponents();
 
         // remove components less than minimum size
-        int removed = 0;
+        int removedNodes = 0;
         for (TIntArrayList component : components)
         {
             if (component.size() < minOneWayNetworkSize)
             {
                 for (int i = 0; i < component.size(); i++)
                 {
-                    g.markNodeRemoved(component.get(i));
-                    removed++;
+                    ghStorage.markNodeRemoved(component.get(i));
+                    removedNodes++;
                 }
             }
         }
-        return removed;
+        return removedNodes;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index e21eab1310..4ffd1b1906 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -20,12 +20,11 @@
 /**
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum PriorityCode
 {
-    WORST(0),
     AVOID_AT_ALL_COSTS(1),
     REACH_DEST(2),
     AVOID_IF_POSSIBLE(3),
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
index 1b20c872a4..3003347ccc 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -19,22 +19,28 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
 
 /**
  * Special weighting for (motor)bike
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PriorityWeighting extends FastestWeighting
 {
     /**
-     * For now used only in BikeCommonFlagEncoder and MotorcycleFlagEncoder
+     * For now used only in BikeCommonFlagEncoder, FootEncoder and MotorcycleFlagEncoder
      */
     public static final int KEY = 101;
 
+    public PriorityWeighting( FlagEncoder encoder, PMap pMap )
+    {
+        super(encoder, pMap);
+    }
+
     public PriorityWeighting( FlagEncoder encoder )
     {
-        super(encoder);
+        this(encoder, new PMap(0));
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index d870fd9250..9b49d87624 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -18,7 +18,10 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.PMap;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import java.util.TreeMap;
 
 /**
@@ -34,14 +37,23 @@ public RacingBikeFlagEncoder()
         this(4, 2, 0);
     }
 
+    public RacingBikeFlagEncoder( PMap properties )
+    {
+        this(
+                (int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 2),
+                properties.getBool("turnCosts", false) ? 1 : 0
+        );
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("blockFords", true));
+    }
+
     public RacingBikeFlagEncoder( String propertiesStr )
     {
-        this((int) parseLong(propertiesStr, "speedBits", 4),
-                parseDouble(propertiesStr, "speedFactor", 2),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-        this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
+        this(new PMap(propertiesStr));
     }
 
+
     public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
         super(speedBits, speedFactor, maxTurnCosts);
@@ -115,6 +127,18 @@ public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCost
         setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
         setCyclingNetworkPreference("lcn", PriorityCode.UNCHANGED.getValue());
         setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+
+        absoluteBarriers.add("kissing_gate");
+
+        setAvoidSpeedLimit(81);
+        setSpecificBicycleClass("roadcycling");
+
+    }
+
+    @Override
+    public int getVersion()
+    {
+        return 1;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index 418caed170..3309065849 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -34,7 +34,7 @@ public double getMinWeight( double currDistToGoal )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         return edgeState.getDistance();
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
index 1eff527304..93c77d83f8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -1,7 +1,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.stack.array.TIntArrayStack;
@@ -11,16 +11,16 @@
 import java.util.Stack;
 
 /**
- * Implementation of Tarjan's algorithm using an explicit stack.
- * (The traditional recursive approach runs into stack overflow pretty quickly.)
- *
+ * Implementation of Tarjan's algorithm using an explicit stack. (The traditional recursive approach
+ * runs into stack overflow pretty quickly.)
+ * <p/>
  * Used for finding strongly connected components to detect dead-ends.
- *
+ * <p/>
  * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
  */
-public class TarjansStronglyConnectedComponentsAlgorithm {
-
-    private final GraphStorage g;
+public class TarjansStronglyConnectedComponentsAlgorithm
+{
+    private final GraphHopperStorage graph;
     private final TIntArrayStack nodeStack;
     private final GHBitSetImpl onStack;
     private final int[] nodeIndex;
@@ -30,23 +30,26 @@
     private int index = 1;
     private final EdgeFilter edgeFilter;
 
-    public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final EdgeFilter edgeFilter) {
-        this.g = g;
+    public TarjansStronglyConnectedComponentsAlgorithm( GraphHopperStorage graph, final EdgeFilter edgeFilter )
+    {
+        this.graph = graph;
         this.nodeStack = new TIntArrayStack();
-        this.onStack = new GHBitSetImpl(g.getNodes());
-        this.nodeIndex = new int[g.getNodes()];
-        this.nodeLowLink = new int[g.getNodes()];
+        this.onStack = new GHBitSetImpl(graph.getNodes());
+        this.nodeIndex = new int[graph.getNodes()];
+        this.nodeLowLink = new int[graph.getNodes()];
         this.edgeFilter = edgeFilter;
     }
 
     /**
      * Find and return list of all strongly connected components in g.
      */
-    public List<TIntArrayList> findComponents() {
-
-        int nodes = g.getNodes();
-        for (int start = 0; start < nodes; start++) {
-            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start)) {
+    public List<TIntArrayList> findComponents()
+    {
+        int nodes = graph.getNodes();
+        for (int start = 0; start < nodes; start++)
+        {
+            if (nodeIndex[start] == 0 && !graph.isNodeRemoved(start))
+            {
                 strongConnect(start);
             }
         }
@@ -55,29 +58,33 @@ public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final E
     }
 
     // Find all components reachable from firstNode, add them to 'components'
-    private void strongConnect(int firstNode) {
+    private void strongConnect( int firstNode )
+    {
         final Stack<TarjanState> stateStack = new Stack<TarjanState>();
         stateStack.push(TarjanState.startState(firstNode));
 
         // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
         nextState:
 
-        while (!stateStack.empty()) {
+        while (!stateStack.empty())
+        {
             TarjanState state = stateStack.pop();
             final int start = state.start;
             final EdgeIterator iter;
 
-            if (state.isStart()) {
+            if (state.isStart())
+            {
                 // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
                 nodeIndex[start] = index;
                 nodeLowLink[start] = index;
-                index ++;
+                index++;
                 nodeStack.push(start);
                 onStack.set(start);
 
-                iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
+                iter = graph.createEdgeExplorer(edgeFilter).setBaseNode(start);
 
-            } else { // if (state.isResume()) {
+            } else
+            { // if (state.isResume()) {
 
                 // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
                 iter = state.iter;
@@ -91,23 +98,27 @@ private void strongConnect(int firstNode) {
             while (iter.next())
             {
                 int connectedId = iter.getAdjNode();
-                if (nodeIndex[connectedId] == 0) {
+                if (nodeIndex[connectedId] == 0)
+                {
                     // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
                     // Ideally we'd just call strongConnectIterative(connectedId);
                     stateStack.push(TarjanState.resumeState(start, iter));
                     stateStack.push(TarjanState.startState(connectedId));
                     continue nextState;
-                } else if (onStack.contains(connectedId)) {
+                } else if (onStack.contains(connectedId))
+                {
                     nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
                 }
             }
 
             // If nodeLowLink == nodeIndex, then we are the first element in a component.
             // Add all nodes higher up on nodeStack to this component.
-            if (nodeIndex[start] == nodeLowLink[start]) {
+            if (nodeIndex[start] == nodeLowLink[start])
+            {
                 TIntArrayList component = new TIntArrayList();
                 int node;
-                while ((node = nodeStack.pop()) != start) {
+                while ((node = nodeStack.pop()) != start)
+                {
                     component.add(node);
                     onStack.clear(node);
                 }
@@ -121,23 +132,30 @@ private void strongConnect(int firstNode) {
 
     // Internal stack state of algorithm, used to avoid recursive function calls and hitting stack overflow exceptions.
     // State is either 'start' for new nodes or 'resume' for partially traversed nodes.
-    private static class TarjanState {
+    private static class TarjanState
+    {
         final int start;
         final EdgeIterator iter;
 
         // Iterator only present in 'resume' state.
-        boolean isStart() { return iter == null; }
+        boolean isStart()
+        {
+            return iter == null;
+        }
 
-        private TarjanState(final int start, final EdgeIterator iter) {
+        private TarjanState( final int start, final EdgeIterator iter )
+        {
             this.start = start;
             this.iter = iter;
         }
 
-        public static TarjanState startState(int start) {
+        public static TarjanState startState( int start )
+        {
             return new TarjanState(start, null);
         }
 
-        public static TarjanState resumeState(int start, EdgeIterator iter) {
+        public static TarjanState resumeState( int start, EdgeIterator iter )
+        {
             return new TarjanState(start, iter);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 66d437d1ac..b34172516f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -20,11 +20,13 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -45,7 +47,7 @@ public TestAlgoCollector( String name )
     }
 
     public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
-            OneRun oneRun )
+                                             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
         QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
@@ -149,12 +151,14 @@ void printSummary()
     public static class AlgoHelperEntry
     {
         private Graph queryGraph;
+        private final Graph baseGraph;
         private final LocationIndex idx;
         private AlgorithmOptions opts;
 
-        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        public AlgoHelperEntry( Graph g, Graph baseGraph, AlgorithmOptions opts, LocationIndex idx )
         {
             this.queryGraph = g;
+            this.baseGraph = baseGraph;
             this.opts = opts;
             this.idx = idx;
         }
@@ -169,6 +173,11 @@ public void setQueryGraph( Graph queryGraph )
             this.queryGraph = queryGraph;
         }
 
+        public Graph getBaseGraph()
+        {
+            return baseGraph;
+        }
+
         public void setAlgorithmOptions( AlgorithmOptions opts )
         {
             this.opts = opts;
@@ -187,7 +196,7 @@ public RoutingAlgorithm createAlgo( Graph qGraph )
         @Override
         public String toString()
         {
-            return opts.getAlgorithm();
+            return opts.getAlgorithm() + (queryGraph instanceof CHGraph ? "CH" : "");
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index 20738fd6a9..97016e72c9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
+
 import java.util.Arrays;
 
 /**
@@ -27,7 +28,7 @@
  * Different options define how precise turn restrictions and costs are taken into account, but
  * still all are without via-way support. BTW: this would not be done at runtime, this would be a
  * pre-processing step to avoid performance penalities.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public enum TraversalMode
@@ -73,7 +74,7 @@
      * Returns the identifier to access the map of the shortest path tree according to the traversal
      * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
      * in edge-based behavior
-     * <p>
+     * <p/>
      * @param iterState the current {@link EdgeIteratorState}
      * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
      * backward searches in bidirectional algorithms.
@@ -86,12 +87,35 @@ public final int createTraversalId( EdgeIteratorState iterState, boolean reverse
             if (noOfStates == 1)
                 return iterState.getEdge();
 
-            return GHUtility.createEdgeKey(iterState.getAdjNode(), iterState.getBaseNode(), iterState.getEdge(), reverse);
+            return GHUtility.createEdgeKey(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
         }
 
         return iterState.getAdjNode();
     }
 
+    /**
+     * If you have an EdgeIteratorState the other createTraversalId is preferred!
+     */
+    public final int createTraversalId( int baseNode, int adjNode, int edgeId, boolean reverse )
+    {
+        if (edgeBased)
+        {
+            if (noOfStates == 1)
+                return edgeId;
+
+            return GHUtility.createEdgeKey(baseNode, adjNode, edgeId, reverse);
+        }
+
+        return adjNode;
+    }
+
+    public int reverseEdgeKey( int edgeKey )
+    {
+        if (edgeBased && noOfStates > 1)
+            return GHUtility.reverseEdgeKey(edgeKey);
+        return edgeKey;
+    }
+
     public int getNoOfStates()
     {
         return noOfStates;
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index ca8ce6cb7c..fa769794f9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -19,7 +19,7 @@
 
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
- * <p>
+ * <p/>
  * @author Karl Hbner
  */
 public interface TurnCostEncoder
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index bde1c79da6..9372701727 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -23,7 +23,7 @@
 
 /**
  * Provides methods to retrieve turn costs for a specific turn.
- * <p>
+ * <p/>
  * @author Karl Hbner
  * @author Peter Karich
  */
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
index f471be0d07..9941a97067 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -11,9 +11,9 @@
     /**
      * @return minimal weight fromNode to the goalNode
      */
-    double approximate(int fromNode);
+    double approximate( int fromNode );
 
-    void setGoalNode(int to);
+    void setGoalNode( int to );
 
     /**
      * makes a deep copy of itself
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index b69f61d8f7..3caa6064ff 100644
--- a/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -20,7 +20,6 @@
 import com.graphhopper.util.PMap;
 
 /**
- *
  * @author Peter Karich
  */
 public class WeightingMap extends PMap
@@ -31,8 +30,7 @@ public WeightingMap()
 
     /**
      * Convenient constructor if only one parameter is provided
-     * <p>
-     * @param weighting
+     * <p/>
      */
     public WeightingMap( String weighting )
     {
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index 06239cf252..f1db4c9024 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index 71c10990cc..ec619f6c6f 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -56,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(4));
             return true;
         }
 
@@ -87,10 +87,6 @@ public long put( String name )
         bytePointer++;
         names.setBytes(bytePointer, bytes, bytes.length);
         bytePointer += bytes.length;
-        if (bytePointer < 0)
-        {
-            throw new IllegalStateException("Way index is too large. Cannot contain more than 2GB");
-        }
         lastName = name;
         lastIndex = oldPointer;
         return oldPointer;
@@ -123,13 +119,12 @@ public long put( String name )
     public String get( long pointer )
     {
         if (pointer < 0)
-        {
-            throw new IllegalStateException("pointer cannot be negative:" + pointer);
-        }
+            throw new IllegalStateException("Pointer to access NameIndex cannot be negative:" + pointer);
+
+        // default
         if (pointer == 0)
-        {
             return "";
-        }
+
         byte[] sizeBytes = new byte[1];
         names.getBytes(pointer, sizeBytes, 1);
         int size = sizeBytes[0] & 0xFF;
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 164da777d0..1332f2b5a8 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -18,6 +18,7 @@
 package com.graphhopper.search;
 
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.util.List;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 1839ce1f43..846cb2ecde 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -76,7 +77,7 @@ public void close()
     public boolean isClosed()
     {
         return closed;
-    }        
+    }
 
     @Override
     public void setHeader( int bytePos, int value )
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 21fbf67926..4c669c8d74 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -2,14 +2,14 @@
  *  Licensed to Peter Karich under one or more contributor license
  *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- *
+ * 
  *  Peter Karich licenses this file to you under the Apache License,
  *  Version 2.0 (the "License"); you may not use this file except
  *  in compliance with the License. You may obtain a copy of the
  *  License at
- *
+ * 
  *       http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,25 +18,142 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.coll.SparseIntIntArray;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterator;
-import com.graphhopper.util.PointList;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.search.NameIndex;
+import com.graphhopper.util.*;
+import static com.graphhopper.util.Helper.nf;
 import com.graphhopper.util.shapes.BBox;
+import java.io.UnsupportedEncodingException;
 
 /**
- * @author Peter Karich
+ * The base graph handles nodes and edges file format. It can be used with different Directory
+ * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
+ * thread safe usage.
+ * <p/>
+ * Note: A RAM DataAccess Object is thread-safe in itself but if used in this Graph implementation
+ * it is not write thread safe.
+ * <p/>
+ * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
+ * loadExisting, (4) usage, (5) flush, (6) close
  */
 class BaseGraph implements Graph
 {
-    private final LevelGraph lg;
+    // Emergency stop. to detect if something went wrong with our storage system and to prevent us from an infinit loop.
+    // Road networks typically do not have nodes with plenty of edges!
+    private static final int MAX_EDGES = 1000;
 
-    BaseGraph( LevelGraph lg )
+    // edge memory layout not found in EdgeAccess:
+    int E_GEO, E_NAME, E_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per edge.
+     */
+    int edgeEntryBytes;
+    private boolean initialized = false;
+    final DataAccess edges;
+    /**
+     * interval [0,n)
+     */
+    protected int edgeCount;
+    // node memory layout:
+    protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per node
+     */
+    int nodeEntryBytes;
+    final DataAccess nodes;
+    /**
+     * interval [0,n)
+     */
+    private int nodeCount;
+    final BBox bounds;
+    // remove markers are not yet persistent!
+    private GHBitSet removedNodes;
+    private int edgeEntryIndex, nodeEntryIndex;
+    final NodeAccess nodeAccess;
+    final GraphExtension extStorage;
+    // length | nodeA | nextNode | ... | nodeB
+    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
+    final DataAccess wayGeometry;
+    private int maxGeoRef;
+    final NameIndex nameIndex;
+    final BitUtil bitUtil;
+    private final Directory dir;
+    final EncodingManager encodingManager;
+    private final InternalGraphEventListener listener;
+    private boolean frozen = false;
+    final EdgeAccess edgeAccess;
+
+    public BaseGraph( Directory dir, final EncodingManager encodingManager, boolean withElevation,
+                      InternalGraphEventListener listener, GraphExtension extendedStorage )
     {
-        this.lg = lg;
+        this.dir = dir;
+        this.encodingManager = encodingManager;
+        this.bitUtil = BitUtil.get(dir.getByteOrder());
+        this.wayGeometry = dir.find("geometry");
+        this.nameIndex = new NameIndex(dir);
+        this.nodes = dir.find("nodes");
+        this.edges = dir.find("edges");
+        this.listener = listener;
+        this.edgeAccess = new EdgeAccess(edges, bitUtil)
+        {
+            @Override
+            final EdgeIterable createSingleEdge( EdgeFilter filter )
+            {
+                return new EdgeIterable(BaseGraph.this, this, filter);
+            }
+
+            @Override
+            final int getEdgeRef( int nodeId )
+            {
+                return nodes.getInt((long) nodeId * nodeEntryBytes + N_EDGE_REF);
+            }
+
+            @Override
+            final void setEdgeRef( int nodeId, int edgeId )
+            {
+                nodes.setInt((long) nodeId * nodeEntryBytes + N_EDGE_REF, edgeId);
+            }
+
+            @Override
+            final int getEntryBytes()
+            {
+                return edgeEntryBytes;
+            }
+
+            @Override
+            final long toPointer( int edgeId )
+            {
+                assert isInBounds(edgeId) : "edgeId " + edgeId + " not in bounds [0," + edgeCount + ")";
+                return (long) edgeId * edgeEntryBytes;
+            }
+
+            @Override
+            final boolean isInBounds( int edgeId )
+            {
+                return edgeId < edgeCount && edgeId >= 0;
+            }
+
+            @Override
+            final long reverseFlags( long edgePointer, long flags )
+            {
+                return encodingManager.reverseFlags(flags);
+            }
+
+            @Override
+            public String toString()
+            {
+                return "base edge access";
+            }
+        };
+        this.bounds = BBox.createInverse(withElevation);
+        this.nodeAccess = new GHNodeAccess(this, withElevation);
+        this.extStorage = extendedStorage;
+        this.extStorage.init(this, dir);
     }
 
     @Override
@@ -45,205 +162,1268 @@ public Graph getBaseGraph()
         return this;
     }
 
+    void checkInit()
+    {
+        if (initialized)
+            throw new IllegalStateException("You cannot configure this GraphStorage "
+                    + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
+    }
+
+    protected int loadNodesHeader()
+    {
+        int hash = nodes.getHeader(0);
+        if (hash != stringHashCode(getClass().getName()))
+            throw new IllegalStateException("Cannot load the graph when using instance of "
+                    + getClass().getName() + " and location: " + dir);
+
+        nodeEntryBytes = nodes.getHeader(1 * 4);
+        nodeCount = nodes.getHeader(2 * 4);
+        bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
+        bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
+        bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
+        bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }
+
+        frozen = nodes.getHeader(9 * 4) == 1;
+        return 10;
+    }
+
+    protected int setNodesHeader()
+    {
+        nodes.setHeader(0, stringHashCode(getClass().getName()));
+        nodes.setHeader(1 * 4, nodeEntryBytes);
+        nodes.setHeader(2 * 4, nodeCount);
+        nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
+        nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
+        nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
+        nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
+        nodes.setHeader(9 * 4, isFrozen() ? 1 : 0);
+        return 10;
+    }
+
+    protected int loadEdgesHeader()
+    {
+        edgeEntryBytes = edges.getHeader(0 * 4);
+        edgeCount = edges.getHeader(1 * 4);
+        return 5;
+    }
+
+    protected int setEdgesHeader()
+    {
+        edges.setHeader(0, edgeEntryBytes);
+        edges.setHeader(1 * 4, edgeCount);
+        edges.setHeader(2 * 4, encodingManager.hashCode());
+        edges.setHeader(3 * 4, extStorage.hashCode());
+        return 5;
+    }
+
+    protected int loadWayGeometryHeader()
+    {
+        maxGeoRef = wayGeometry.getHeader(0);
+        return 1;
+    }
+
+    protected int setWayGeometryHeader()
+    {
+        wayGeometry.setHeader(0, maxGeoRef);
+        return 1;
+    }
+
+    void initStorage()
+    {
+        edgeEntryIndex = 0;
+        nodeEntryIndex = 0;
+        boolean flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
+        edgeAccess.init(nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(4),
+                nextEdgeEntryIndex(encodingManager.getBytesForFlags()),
+                flagsSizeIsLong);
+
+        E_GEO = nextEdgeEntryIndex(4);
+        E_NAME = nextEdgeEntryIndex(4);
+        if (extStorage.isRequireEdgeField())
+            E_ADDITIONAL = nextEdgeEntryIndex(4);
+        else
+            E_ADDITIONAL = -1;
+
+        N_EDGE_REF = nextNodeEntryIndex(4);
+        N_LAT = nextNodeEntryIndex(4);
+        N_LON = nextNodeEntryIndex(4);
+        if (nodeAccess.is3D())
+            N_ELE = nextNodeEntryIndex(4);
+        else
+            N_ELE = -1;
+
+        if (extStorage.isRequireNodeField())
+            N_ADDITIONAL = nextNodeEntryIndex(4);
+        else
+            N_ADDITIONAL = -1;
+
+        initNodeAndEdgeEntrySize();
+        listener.initStorage();
+        initialized = true;
+    }
+
+    /**
+     * Initializes the node area with the empty edge value and default additional value.
+     */
+    void initNodeRefs( long oldCapacity, long newCapacity )
+    {
+        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes)
+        {
+            nodes.setInt(pointer, EdgeIterator.NO_EDGE);
+        }
+        if (extStorage.isRequireNodeField())
+        {
+            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes)
+            {
+                nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());
+            }
+        }
+    }
+
+    protected final int nextEdgeEntryIndex( int sizeInBytes )
+    {
+        int tmp = edgeEntryIndex;
+        edgeEntryIndex += sizeInBytes;
+        return tmp;
+    }
+
+    protected final int nextNodeEntryIndex( int sizeInBytes )
+    {
+        int tmp = nodeEntryIndex;
+        nodeEntryIndex += sizeInBytes;
+        return tmp;
+    }
+
+    protected final void initNodeAndEdgeEntrySize()
+    {
+        nodeEntryBytes = nodeEntryIndex;
+        edgeEntryBytes = edgeEntryIndex;
+    }
+
+    /**
+     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
+     * extend byte capacity
+     */
+    final void ensureNodeIndex( int nodeIndex )
+    {
+        if (!initialized)
+            throw new AssertionError("The graph has not yet been initialized.");
+
+        if (nodeIndex < nodeCount)
+            return;
+
+        long oldNodes = nodeCount;
+        nodeCount = nodeIndex + 1;
+        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
+        if (capacityIncreased)
+        {
+            long newBytesCapacity = nodes.getCapacity();
+            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
+        }
+    }
+
     @Override
     public int getNodes()
     {
-        return lg.getNodes();
+        return nodeCount;
     }
 
     @Override
     public NodeAccess getNodeAccess()
     {
-        return lg.getNodeAccess();
+        return nodeAccess;
     }
 
     @Override
     public BBox getBounds()
     {
-        return lg.getBounds();
+        return bounds;
     }
 
     @Override
-    public EdgeIteratorState edge( int a, int b )
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirection )
     {
-        return lg.edge(a, b);
+        return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
     }
 
-    @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    void setSegmentSize( int bytes )
     {
-        return lg.edge(a, b, distance, bothDirections);
+        checkInit();
+        nodes.setSegmentSize(bytes);
+        edges.setSegmentSize(bytes);
+        wayGeometry.setSegmentSize(bytes);
+        nameIndex.setSegmentSize(bytes);
+        extStorage.setSegmentSize(bytes);
     }
 
-    @Override
-    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    void freeze()
     {
-        if (lg.isShortcut(edgeId))
-            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+        if (isFrozen())
+            throw new IllegalStateException("base graph already frozen");
 
-        return lg.getEdgeProps(edgeId, adjNode);
+        frozen = true;
+        listener.freeze();
     }
 
-    @Override
-    public AllEdgesIterator getAllEdges()
+    boolean isFrozen()
+    {
+        return frozen;
+    }
+
+    public void checkFreeze()
+    {
+        if (isFrozen())
+            throw new IllegalStateException("Cannot add edge or node after baseGraph.freeze was called");
+    }
+
+    void create( long initSize )
+    {
+        nodes.create(initSize);
+        edges.create(initSize);
+        wayGeometry.create(initSize);
+        nameIndex.create(1000);
+        extStorage.create(initSize);
+        initStorage();
+        // 0 stands for no separate geoRef
+        maxGeoRef = 4;
+
+        initNodeRefs(0, nodes.getCapacity());
+    }
+
+    String toDetailsString()
+    {
+        return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
+                + "nodes:" + nf(getNodes()) + "(" + nodes.getCapacity() / Helper.MB + "), "
+                + "name: -(" + nameIndex.getCapacity() / Helper.MB + "), "
+                + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
+                + "bounds:" + bounds;
+    }
+
+    void flush()
     {
-        final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
-        return new AllEdgesIterator()
+        setNodesHeader();
+        setEdgesHeader();
+        setWayGeometryHeader();
+
+        wayGeometry.flush();
+        nameIndex.flush();
+        edges.flush();
+        nodes.flush();
+        extStorage.flush();
+    }
+
+    void close()
+    {
+        wayGeometry.close();
+        nameIndex.close();
+        edges.close();
+        nodes.close();
+        extStorage.close();
+    }
+
+    long getCapacity()
+    {
+        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity()
+                + wayGeometry.getCapacity() + extStorage.getCapacity();
+    }
+
+    void loadExisting( String dim )
+    {
+        if (!nodes.loadExisting())
+            throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
+
+        if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
+            throw new IllegalStateException("Configured dimension (" + nodeAccess.getDimension() + ") is not equal "
+                    + "to dimension of loaded graph (" + dim + ")");
+
+        if (!edges.loadExisting())
+            throw new IllegalStateException("Cannot load edges. corrupt file or directory? " + dir);
+
+        if (!wayGeometry.loadExisting())
+            throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
+
+        if (!nameIndex.loadExisting())
+            throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
+
+        if (!extStorage.loadExisting())
+            throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
+
+        // first define header indices of this storage
+        initStorage();
+
+        // now load some properties from stored data
+        loadNodesHeader();
+        loadEdgesHeader();
+        loadWayGeometryHeader();
+    }
+
+    protected static class EdgeIterable implements EdgeExplorer, EdgeIterator
+    {
+        final EdgeFilter filter;
+        int baseNode;
+        int adjNode;
+        int edgeId;
+        long edgePointer = -1;
+        int nextEdgeId;
+        boolean reverse;
+        final BaseGraph baseGraph;
+        EdgeAccess edgeAccess;
+        private boolean freshFlags;
+        private long cachedFlags;
+
+        public EdgeIterable( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
         {
-            @Override
-            public int getCount()
-            {
-                return tmpIter.getCount();
-            }
+            if (filter == null)
+                throw new IllegalArgumentException("Instead null filter use EdgeFilter.ALL_EDGES");
 
-            @Override
-            public boolean next()
-            {
-                while (tmpIter.next())
-                {
-                    if (!tmpIter.isShortcut())
-                    {
-                        return true;
-                    }
-                }
-                return false;
-            }
+            this.baseGraph = baseGraph;
+            this.filter = filter;
+            this.edgeAccess = edgeAccess;
+        }
 
-            @Override
-            public int getEdge()
-            {
-                return tmpIter.getEdge();
-            }
+        final void setEdgeId( int edgeId )
+        {
+            this.nextEdgeId = this.edgeId = edgeId;
+        }
 
-            @Override
-            public int getBaseNode()
+        final boolean init( int tmpEdgeId, int expectedAdjNode )
+        {
+            setEdgeId(tmpEdgeId);
+            if (tmpEdgeId != EdgeIterator.NO_EDGE)
             {
-                return tmpIter.getBaseNode();
+                selectEdgeAccess();
+                this.edgePointer = edgeAccess.toPointer(tmpEdgeId);
             }
 
-            @Override
-            public int getAdjNode()
-            {
-                return tmpIter.getAdjNode();
-            }
+            // expect only edgePointer is properly initialized via setEdgeId            
+            baseNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
+            if (baseNode == EdgeAccess.NO_NODE)
+                throw new IllegalStateException("content of edgeId " + edgeId + " is marked as invalid - ie. the edge is already removed!");
 
-            @Override
-            public PointList fetchWayGeometry( int type )
+            adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
+            // a next() call should return false
+            nextEdgeId = EdgeIterator.NO_EDGE;
+            if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE)
             {
-                return tmpIter.fetchWayGeometry(type);
-            }
-
-            @Override
-            public EdgeIteratorState setWayGeometry( PointList list )
+                reverse = false;
+                return true;
+            } else if (expectedAdjNode == baseNode)
             {
-                return tmpIter.setWayGeometry(list);
+                reverse = true;
+                baseNode = adjNode;
+                adjNode = expectedAdjNode;
+                return true;
             }
+            return false;
+        }
 
-            @Override
-            public double getDistance()
+        final void _setBaseNode( int baseNode )
+        {
+            this.baseNode = baseNode;
+        }
+
+        @Override
+        public EdgeIterator setBaseNode( int baseNode )
+        {
+            // always use base graph edge access
+            setEdgeId(baseGraph.edgeAccess.getEdgeRef(baseNode));
+            _setBaseNode(baseNode);
+            return this;
+        }
+
+        @Override
+        public final int getBaseNode()
+        {
+            return baseNode;
+        }
+
+        @Override
+        public final int getAdjNode()
+        {
+            return adjNode;
+        }
+
+        protected void selectEdgeAccess()
+        {
+        }
+
+        @Override
+        public final boolean next()
+        {
+            while (true)
             {
-                return tmpIter.getDistance();
+                if (nextEdgeId == EdgeIterator.NO_EDGE)
+                    return false;
+
+                selectEdgeAccess();
+                edgePointer = edgeAccess.toPointer(nextEdgeId);
+                edgeId = nextEdgeId;
+                adjNode = edgeAccess.getOtherNode(baseNode, edgePointer);
+                reverse = baseNode > adjNode;
+                freshFlags = false;
+
+                // position to next edge                
+                nextEdgeId = edgeAccess.getEdgeRef(baseNode, adjNode, edgePointer);
+                assert nextEdgeId != edgeId : ("endless loop detected for base node: " + baseNode + ", adj node: " + adjNode
+                        + ", edge pointer: " + edgePointer + ", edge: " + edgeId);
+
+                if (filter.accept(this))
+                    return true;
             }
+        }
 
-            @Override
-            public EdgeIteratorState setDistance( double dist )
+        public final boolean next_debug()
+        {
+            int i = 0;
+            boolean foundNext = false;
+            for (; i < MAX_EDGES; i++)
             {
-                return tmpIter.setDistance(dist);
+                if (nextEdgeId == EdgeIterator.NO_EDGE)
+                    break;
+
+                selectEdgeAccess();
+                edgePointer = edgeAccess.toPointer(nextEdgeId);
+                edgeId = nextEdgeId;
+                adjNode = edgeAccess.getOtherNode(baseNode, edgePointer);
+                reverse = baseNode > adjNode;
+                freshFlags = false;
+
+                // position to next edge                
+                nextEdgeId = edgeAccess.getEdgeRef(baseNode, adjNode, edgePointer);
+                if (nextEdgeId == edgeId)
+                    throw new AssertionError("endless loop detected for base node: " + baseNode + ", adj node: " + adjNode
+                            + ", edge pointer: " + edgePointer + ", edge: " + edgeId);
+
+                foundNext = filter.accept(this);
+                if (foundNext)
+                    break;
             }
 
-            @Override
-            public long getFlags()
+            if (i > MAX_EDGES)
+                throw new IllegalStateException("something went wrong: no end of edge-list found");
+
+            return foundNext;
+        }
+
+        @Override
+        public final double getDistance()
+        {
+            return edgeAccess.getDist(edgePointer);
+        }
+
+        @Override
+        public final EdgeIteratorState setDistance( double dist )
+        {
+            edgeAccess.setDist(edgePointer, dist);
+            return this;
+        }
+
+        @Override
+        public final long getFlags()
+        {
+            if (!freshFlags)
             {
-                return tmpIter.getFlags();
+                cachedFlags = edgeAccess.getFlags_(edgePointer, reverse);
+                freshFlags = true;
             }
+            return cachedFlags;
+        }
 
-            @Override
-            public EdgeIteratorState setFlags( long flags )
+        @Override
+        public final EdgeIteratorState setFlags( long fl )
+        {
+            cachedFlags = fl;
+            freshFlags = true;
+            edgeAccess.setFlags_(edgePointer, reverse, fl);
+            return this;
+        }
+
+        @Override
+        public final int getAdditionalField()
+        {
+            return baseGraph.edges.getInt(edgePointer + baseGraph.E_ADDITIONAL);
+        }
+
+        @Override
+        public final EdgeIteratorState setAdditionalField( int value )
+        {
+            baseGraph.setAdditionalEdgeField(edgePointer, value);
+            return null;
+        }
+
+        @Override
+        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
+        {
+            baseGraph.setWayGeometry_(pillarNodes, edgePointer, reverse);
+            return this;
+        }
+
+        @Override
+        public PointList fetchWayGeometry( int mode )
+        {
+            return baseGraph.fetchWayGeometry_(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
+        }
+
+        @Override
+        public final int getEdge()
+        {
+            return edgeId;
+        }
+
+        @Override
+        public String getName()
+        {
+            int nameIndexRef = baseGraph.edges.getInt(edgePointer + baseGraph.E_NAME);
+            return baseGraph.nameIndex.get(nameIndexRef);
+        }
+
+        @Override
+        public EdgeIteratorState setName( String name )
+        {
+            baseGraph.setName(edgePointer, name);
+            return this;
+        }
+
+        @Override
+        public final boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
+        @Override
+        public EdgeIteratorState detach( boolean reverseArg )
+        {
+            if (edgeId == nextEdgeId || edgeId == EdgeIterator.NO_EDGE)
+                throw new IllegalStateException("call next before detaching or setEdgeId (edgeId:" + edgeId + " vs. next " + nextEdgeId + ")");
+
+            EdgeIterable iter = edgeAccess.createSingleEdge(filter);
+            boolean ret;
+            if (reverseArg)
             {
-                return tmpIter.setFlags(flags);
-            }
+                ret = iter.init(edgeId, baseNode);
+                // for #162
+                iter.reverse = !reverse;
+            } else
+                ret = iter.init(edgeId, adjNode);
+            assert ret;
+            return iter;
+        }
 
-            @Override
-            public String getName()
+        @Override
+        public final String toString()
+        {
+            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
+        }
+
+        @Override
+        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        {
+            return baseGraph.copyProperties(this, edge);
+        }
+    }
+
+    /**
+     * @return to
+     */
+    EdgeIteratorState copyProperties( EdgeIteratorState from, EdgeIteratorState to )
+    {
+        to.setDistance(from.getDistance()).
+                setName(from.getName()).
+                setFlags(from.getFlags()).
+                setWayGeometry(from.fetchWayGeometry(0));
+
+        if (E_ADDITIONAL >= 0)
+            to.setAdditionalField(from.getAdditionalField());
+        return to;
+    }
+
+    /**
+     * Create edge between nodes a and b
+     * <p/>
+     * @return EdgeIteratorState of newly created edge
+     */
+    @Override
+    public EdgeIteratorState edge( int nodeA, int nodeB )
+    {
+        if (isFrozen())
+            throw new IllegalStateException("Cannot create edge if graph is already frozen");
+
+        ensureNodeIndex(Math.max(nodeA, nodeB));
+        int edgeId = edgeAccess.internalEdgeAdd(nextEdgeId(), nodeA, nodeB);
+        EdgeIterable iter = new EdgeIterable(this, edgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(edgeId, nodeB);
+        assert ret;
+        if (extStorage.isRequireEdgeField())
+            iter.setAdditionalField(extStorage.getDefaultEdgeFieldValue());
+
+        return iter;
+    }
+
+    // for test only
+    void setEdgeCount( int cnt )
+    {
+        edgeCount = cnt;
+    }
+
+    /**
+     * Determine next free edgeId and ensure byte capacity to store edge
+     * <p/>
+     * @return next free edgeId
+     */
+    protected int nextEdgeId()
+    {
+        int nextEdge = edgeCount;
+        edgeCount++;
+        if (edgeCount < 0)
+            throw new IllegalStateException("too many edges. new edge id would be negative. " + toString());
+
+        edges.ensureCapacity(((long) edgeCount + 1) * edgeEntryBytes);
+        return nextEdge;
+    }
+
+    @Override
+    public EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
+    {
+        if (!edgeAccess.isInBounds(edgeId))
+            throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
+        checkAdjNodeBounds(adjNode);
+        return edgeAccess.getEdgeProps(edgeId, adjNode);
+    }
+
+    final void checkAdjNodeBounds( int adjNode )
+    {
+        if (adjNode < 0 && adjNode != Integer.MIN_VALUE || adjNode >= nodeCount)
+            throw new IllegalStateException("adjNode " + adjNode + " out of bounds [0," + nf(nodeCount) + ")");
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
+    {
+        return new EdgeIterable(this, edgeAccess, filter);
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
+    }
+
+    @Override
+    public AllEdgesIterator getAllEdges()
+    {
+        return new AllEdgeIterator(this, edgeAccess);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        initialized = true;
+        if (g.getClass().equals(getClass()))
+        {
+            _copyTo((BaseGraph) g);
+            return g;
+        } else
+        {
+            return GHUtility.copyTo(this, g);
+        }
+    }
+
+    void _copyTo( BaseGraph clonedG )
+    {
+        if (clonedG.edgeEntryBytes != edgeEntryBytes)
+            throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
+
+        if (clonedG.nodeEntryBytes != nodeEntryBytes)
+            throw new IllegalStateException("nodeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeEntryBytes + " vs " + nodeEntryBytes);
+
+        if (clonedG.nodeAccess.getDimension() != nodeAccess.getDimension())
+            throw new IllegalStateException("dimension cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeAccess.getDimension() + " vs " + nodeAccess.getDimension());
+
+        // nodes
+        setNodesHeader();
+        nodes.copyTo(clonedG.nodes);
+        clonedG.loadNodesHeader();
+
+        // edges
+        setEdgesHeader();
+        edges.copyTo(clonedG.edges);
+        clonedG.loadEdgesHeader();
+
+        // name
+        nameIndex.copyTo(clonedG.nameIndex);
+
+        // geometry
+        setWayGeometryHeader();
+        wayGeometry.copyTo(clonedG.wayGeometry);
+        clonedG.loadWayGeometryHeader();
+
+        // extStorage
+        extStorage.copyTo(clonedG.extStorage);
+
+        if (removedNodes == null)
+            clonedG.removedNodes = null;
+        else
+            clonedG.removedNodes = removedNodes.copyTo(new GHBitSetImpl());
+    }
+
+    protected void trimToSize()
+    {
+        long nodeCap = (long) nodeCount * nodeEntryBytes;
+        nodes.trimTo(nodeCap);
+//        long edgeCap = (long) (edgeCount + 1) * edgeEntrySize;
+//        edges.trimTo(edgeCap * 4);
+    }
+
+    /**
+     * This methods disconnects all edges from removed nodes. It does no edge compaction. Then it
+     * moves the last nodes into the deleted nodes, where it needs to update the node ids in every
+     * edge.
+     */
+    void inPlaceNodeRemove( int removeNodeCount )
+    {
+        // Prepare edge-update of nodes which are connected to deleted nodes        
+        int toMoveNodes = getNodes();
+        int itemsToMove = 0;
+
+        // sorted map when we access it via keyAt and valueAt - see below!
+        final SparseIntIntArray oldToNewMap = new SparseIntIntArray(removeNodeCount);
+        GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
+        removedNodes.copyTo(toRemoveSet);
+
+        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
+        // create map of old node ids pointing to new ids        
+        for (int removeNode = removedNodes.next(0);
+                removeNode >= 0;
+                removeNode = removedNodes.next(removeNode + 1))
+        {
+            EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);
+            while (delEdgesIter.next())
             {
-                return tmpIter.getName();
+                toRemoveSet.add(delEdgesIter.getAdjNode());
             }
 
-            @Override
-            public EdgeIteratorState setName( String name )
+            toMoveNodes--;
+            for (; toMoveNodes >= 0; toMoveNodes--)
             {
-                return tmpIter.setName(name);
+                if (!removedNodes.contains(toMoveNodes))
+                    break;
             }
 
-            @Override
-            public int getAdditionalField()
+            if (toMoveNodes >= removeNode)
+                oldToNewMap.put(toMoveNodes, removeNode);
+
+            itemsToMove++;
+        }
+
+        EdgeIterable adjNodesToDelIter = (EdgeIterable) createEdgeExplorer();
+        // now similar process to disconnectEdges but only for specific nodes
+        // all deleted nodes could be connected to existing. remove the connections
+        for (int removeNode = toRemoveSet.next(0);
+                removeNode >= 0;
+                removeNode = toRemoveSet.next(removeNode + 1))
+        {
+            // remove all edges connected to the deleted nodes
+            adjNodesToDelIter.setBaseNode(removeNode);
+            long prev = EdgeIterator.NO_EDGE;
+            while (adjNodesToDelIter.next())
             {
-                return tmpIter.getAdditionalField();
+                int nodeId = adjNodesToDelIter.getAdjNode();
+                // already invalidated
+                if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId))
+                {
+                    int edgeToRemove = adjNodesToDelIter.getEdge();
+                    long edgeToRemovePointer = edgeAccess.toPointer(edgeToRemove);
+                    edgeAccess.internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
+                    edgeAccess.invalidateEdge(edgeToRemovePointer);
+                } else
+                {
+                    prev = adjNodesToDelIter.edgePointer;
+                }
             }
+        }
 
-            @Override
-            public EdgeIteratorState setAdditionalField( int value )
+        GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);
+        EdgeExplorer movedEdgeExplorer = createEdgeExplorer();
+        // marks connected nodes to rewrite the edges
+        for (int i = 0; i < itemsToMove; i++)
+        {
+            int oldI = oldToNewMap.keyAt(i);
+            EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
+            while (movedEdgeIter.next())
             {
-                return tmpIter.setAdditionalField(value);
+                int nodeId = movedEdgeIter.getAdjNode();
+                if (nodeId == EdgeAccess.NO_NODE)
+                    continue;
+
+                if (removedNodes.contains(nodeId))
+                    throw new IllegalStateException("shouldn't happen the edge to the node "
+                            + nodeId + " should be already deleted. " + oldI);
+
+                toMoveSet.add(nodeId);
             }
+        }
 
-            @Override
-            public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        // move nodes into deleted nodes
+        for (int i = 0; i < itemsToMove; i++)
+        {
+            int oldI = oldToNewMap.keyAt(i);
+            int newI = oldToNewMap.valueAt(i);
+            long newOffset = (long) newI * nodeEntryBytes;
+            long oldOffset = (long) oldI * nodeEntryBytes;
+            for (long j = 0; j < nodeEntryBytes; j += 4)
             {
-                return tmpIter.copyPropertiesTo(edge);
+                nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));
             }
+        }
 
-            @Override
-            public EdgeIteratorState detach( boolean reverse )
+        // *rewrites* all edges connected to moved nodes
+        // go through all edges and pick the necessary <- this is easier to implement than
+        // a more efficient (?) breadth-first search
+        EdgeIterator iter = getAllEdges();
+        while (iter.next())
+        {
+            int nodeA = iter.getBaseNode();
+            int nodeB = iter.getAdjNode();
+            if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
+                continue;
+
+            // now overwrite exiting edge with new node ids 
+            // also flags and links could have changed due to different node order
+            int updatedA = oldToNewMap.get(nodeA);
+            if (updatedA < 0)
+                updatedA = nodeA;
+
+            int updatedB = oldToNewMap.get(nodeB);
+            if (updatedB < 0)
+                updatedB = nodeB;
+
+            int edgeId = iter.getEdge();
+            long edgePointer = edgeAccess.toPointer(edgeId);
+            int linkA = edgeAccess.getEdgeRef(nodeA, nodeB, edgePointer);
+            int linkB = edgeAccess.getEdgeRef(nodeB, nodeA, edgePointer);
+            long flags = edgeAccess.getFlags_(edgePointer, false);
+            edgeAccess.writeEdge(edgeId, updatedA, updatedB, linkA, linkB);
+            edgeAccess.setFlags_(edgePointer, updatedA > updatedB, flags);
+            if (updatedA < updatedB != nodeA < nodeB)
+                setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);
+        }
+
+        if (removeNodeCount >= nodeCount)
+            throw new IllegalStateException("graph is empty after in-place removal but was " + removeNodeCount);
+
+        // we do not remove the invalid edges => edgeCount stays the same!
+        nodeCount -= removeNodeCount;
+
+        EdgeExplorer explorer = createEdgeExplorer();
+        // health check
+        if (isTestingEnabled())
+        {
+            iter = getAllEdges();
+            while (iter.next())
             {
-                return tmpIter.detach(reverse);
+                int base = iter.getBaseNode();
+                int adj = iter.getAdjNode();
+                String str = iter.getEdge()
+                        + ", r.contains(" + base + "):" + removedNodes.contains(base)
+                        + ", r.contains(" + adj + "):" + removedNodes.contains(adj)
+                        + ", tr.contains(" + base + "):" + toRemoveSet.contains(base)
+                        + ", tr.contains(" + adj + "):" + toRemoveSet.contains(adj)
+                        + ", base:" + base + ", adj:" + adj + ", nodeCount:" + nodeCount;
+                if (adj >= nodeCount)
+                    throw new RuntimeException("Adj.node problem with edge " + str);
+
+                if (base >= nodeCount)
+                    throw new RuntimeException("Base node problem with edge " + str);
+
+                try
+                {
+                    explorer.setBaseNode(adj).toString();
+                } catch (Exception ex)
+                {
+                    org.slf4j.LoggerFactory.getLogger(getClass()).error("adj:" + adj);
+                }
+                try
+                {
+                    explorer.setBaseNode(base).toString();
+                } catch (Exception ex)
+                {
+                    org.slf4j.LoggerFactory.getLogger(getClass()).error("base:" + base);
+                }
             }
-        };
+            // access last node -> no error
+            explorer.setBaseNode(nodeCount - 1).toString();
+        }
+        removedNodes = null;
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    public GraphExtension getExtension()
+    {
+        return extStorage;
+    }
+
+    public void setAdditionalEdgeField( long edgePointer, int value )
     {
-        if (filter == EdgeFilter.ALL_EDGES)
-            return createEdgeExplorer();
+        if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
+            edges.setInt(edgePointer + E_ADDITIONAL, value);
+        else
+            throw new AssertionError("This graph does not support an additional edge field.");
+    }
 
-        return lg.createEdgeExplorer(new EdgeFilter()
+    private void setWayGeometry_( PointList pillarNodes, long edgePointer, boolean reverse )
+    {
+        if (pillarNodes != null && !pillarNodes.isEmpty())
         {
-            @Override
-            public boolean accept( EdgeIteratorState edgeIterState )
+            if (pillarNodes.getDimension() != nodeAccess.getDimension())
+                throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
+                        + "D for graph which is " + nodeAccess.getDimension() + "D");
+
+            int len = pillarNodes.getSize();
+            int dim = nodeAccess.getDimension();
+            int tmpRef = nextGeoRef(len * dim);
+            edges.setInt(edgePointer + E_GEO, tmpRef);
+            long geoRef = (long) tmpRef * 4;
+            byte[] bytes = new byte[len * dim * 4 + 4];
+            ensureGeometry(geoRef, bytes.length);
+            bitUtil.fromInt(bytes, len, 0);
+            if (reverse)
+                pillarNodes.reverse();
+
+            int tmpOffset = 4;
+            boolean is3D = nodeAccess.is3D();
+            for (int i = 0; i < len; i++)
             {
-                if (((EdgeSkipIterator) edgeIterState).isShortcut())
-                    return false;
+                double lat = pillarNodes.getLatitude(i);
+                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
+                tmpOffset += 4;
+                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
+                tmpOffset += 4;
 
-                return filter.accept(edgeIterState);
+                if (is3D)
+                {
+                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
+                    tmpOffset += 4;
+                }
             }
-        });
+
+            wayGeometry.setBytes(geoRef, bytes, bytes.length);
+        } else
+        {
+            edges.setInt(edgePointer + E_GEO, 0);
+        }
     }
 
-    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    private PointList fetchWayGeometry_( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
     {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
+        long geoRef = edges.getInt(edgePointer + E_GEO);
+        int count = 0;
+        byte[] bytes = null;
+        if (geoRef > 0)
         {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+            geoRef *= 4;
+            count = wayGeometry.getInt(geoRef);
+
+            geoRef += 4;
+            bytes = new byte[count * nodeAccess.getDimension() * 4];
+            wayGeometry.getBytes(geoRef, bytes, bytes.length);
+        } else if (mode == 0)
+            return PointList.EMPTY;
+
+        PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
+        if (reverse)
+        {
+            if ((mode & 2) != 0)
+                pillarNodes.add(nodeAccess, adjNode);
+        } else
+        {
+            if ((mode & 1) != 0)
+                pillarNodes.add(nodeAccess, baseNode);
         }
-    };
 
-    @Override
-    public EdgeExplorer createEdgeExplorer()
+        int index = 0;
+        for (int i = 0; i < count; i++)
+        {
+            double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));
+            index += 4;
+            double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
+            index += 4;
+            if (nodeAccess.is3D())
+            {
+                pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
+                index += 4;
+            } else
+            {
+                pillarNodes.add(lat, lon);
+            }
+        }
+
+        if (reverse)
+        {
+            if ((mode & 1) != 0)
+                pillarNodes.add(nodeAccess, baseNode);
+            pillarNodes.reverse();
+        } else
+        {
+            if ((mode & 2) != 0)
+                pillarNodes.add(nodeAccess, adjNode);
+        }
+
+        return pillarNodes;
+    }
+
+    private void setName( long edgePointer, String name )
     {
-        return lg.createEdgeExplorer(NO_SHORTCUTS);
+        int nameIndexRef = (int) nameIndex.put(name);
+        if (nameIndexRef < 0)
+            throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+        edges.setInt(edgePointer + E_NAME, nameIndexRef);
     }
 
-    @Override
-    public Graph copyTo( Graph g )
+    GHBitSet getRemovedNodes()
     {
-        throw new UnsupportedOperationException("Not supported yet.");
+        if (removedNodes == null)
+            removedNodes = new GHBitSetImpl(getNodes());
+
+        return removedNodes;
     }
 
-    @Override
-    public GraphExtension getExtension()
+    private static boolean isTestingEnabled()
+    {
+        boolean enableIfAssert = false;
+        assert (enableIfAssert = true) : true;
+        return enableIfAssert;
+    }
+
+    private void ensureGeometry( long bytePos, int byteLength )
+    {
+        wayGeometry.ensureCapacity(bytePos + byteLength);
+    }
+
+    private int nextGeoRef( int arrayLength )
+    {
+        int tmp = maxGeoRef;
+        // one more integer to store also the size itself
+        maxGeoRef += arrayLength + 1;
+        return tmp;
+    }
+
+    // workaround for graphhopper-ios https://github.com/google/j2objc/issues/423
+    private int stringHashCode( String str )
+    {
+        try
+        {
+            return java.util.Arrays.hashCode(str.getBytes("UTF-8"));
+        } catch (UnsupportedEncodingException ex)
+        {
+            throw new UnsupportedOperationException(ex);
+        }
+    }
+
+    /**
+     * Include all edges of this storage in the iterator.
+     */
+    protected static class AllEdgeIterator implements AllEdgesIterator
     {
-        return lg.getExtension();
+        protected long edgePointer;
+        protected int edgeId = -1;
+        protected EdgeAccess edgeAccess;
+        private int nodeA;
+        private int nodeB;
+        // we need reverse if detach is called 
+        private boolean reverse = false;
+        private final BaseGraph baseGraph;
+
+        public AllEdgeIterator( BaseGraph baseGraph )
+        {
+            this(baseGraph, baseGraph.edgeAccess);
+        }
+
+        private AllEdgeIterator( BaseGraph baseGraph, EdgeAccess edgeAccess )
+        {
+            this.baseGraph = baseGraph;
+            this.edgeAccess = edgeAccess;
+            this.edgePointer = -1;
+        }
+
+        @Override
+        public int getMaxId()
+        {
+            return baseGraph.edgeCount;
+        }
+
+        @Override
+        public boolean next()
+        {
+            while (true)
+            {
+                edgeId++;
+                edgePointer = (long) edgeId * edgeAccess.getEntryBytes();
+                if (!checkRange())
+                    return false;
+
+                nodeA = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
+                // some edges are deleted and have a negative node
+                if (nodeA == EdgeAccess.NO_NODE)
+                    continue;
+
+                nodeB = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
+                // this is always false because of 'getBaseNode() <= getAdjNode()'
+                reverse = false;
+                return true;
+            }
+        }
+
+        protected boolean checkRange()
+        {
+            return edgeId < baseGraph.edgeCount;
+        }
+
+        @Override
+        public int getEdge()
+        {
+            return edgeId;
+        }
+
+        @Override
+        public final int getBaseNode()
+        {
+            return nodeA;
+        }
+
+        @Override
+        public final int getAdjNode()
+        {
+            return nodeB;
+        }
+
+        @Override
+        public final double getDistance()
+        {
+            return edgeAccess.getDist(edgePointer);
+        }
+
+        @Override
+        public final EdgeIteratorState setDistance( double dist )
+        {
+            edgeAccess.setDist(edgePointer, dist);
+            return this;
+        }
+
+        @Override
+        public final long getFlags()
+        {
+            return edgeAccess.getFlags_(edgePointer, reverse);
+        }
+
+        @Override
+        public final EdgeIteratorState setFlags( long flags )
+        {
+            edgeAccess.setFlags_(edgePointer, reverse, flags);
+            return this;
+        }
+
+        @Override
+        public final int getAdditionalField()
+        {
+            return baseGraph.edges.getInt(edgePointer + baseGraph.E_ADDITIONAL);
+        }
+
+        @Override
+        public final EdgeIteratorState setAdditionalField( int value )
+        {
+            baseGraph.setAdditionalEdgeField(edgePointer, value);
+            return this;
+        }
+
+        @Override
+        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        {
+            return baseGraph.copyProperties(this, edge);
+        }
+
+        @Override
+        public final EdgeIteratorState setWayGeometry( PointList pillarNodes )
+        {
+            baseGraph.setWayGeometry_(pillarNodes, edgePointer, reverse);
+            return this;
+        }
+
+        @Override
+        public final PointList fetchWayGeometry( int type )
+        {
+            return baseGraph.fetchWayGeometry_(edgePointer, reverse,
+                    type, getBaseNode(), getAdjNode());
+        }
+
+        @Override
+        public final String getName()
+        {
+            int nameIndexRef = baseGraph.edges.getInt(edgePointer + baseGraph.E_NAME);
+            return baseGraph.nameIndex.get(nameIndexRef);
+        }
+
+        @Override
+        public final EdgeIteratorState setName( String name )
+        {
+            baseGraph.setName(edgePointer, name);
+            return this;
+        }
+
+        @Override
+        public final boolean getBoolean( int key, boolean reverse, boolean _default )
+        {
+            // for non-existent keys return default
+            return _default;
+        }
+
+        @Override
+        public final EdgeIteratorState detach( boolean reverseArg )
+        {
+            if (edgePointer < 0)
+                throw new IllegalStateException("call next before detaching");
+
+            AllEdgeIterator iter = new AllEdgeIterator(baseGraph, edgeAccess);
+            iter.edgeId = edgeId;
+            iter.edgePointer = edgePointer;
+            if (reverseArg)
+            {
+                iter.reverse = !this.reverse;
+                iter.nodeA = nodeB;
+                iter.nodeB = nodeA;
+            } else
+            {
+                iter.reverse = this.reverse;
+                iter.nodeA = nodeA;
+                iter.nodeB = nodeB;
+            }
+            return iter;
+        }
+
+        @Override
+        public String toString()
+        {
+            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
similarity index 68%
rename from core/src/main/java/com/graphhopper/storage/LevelGraph.java
rename to core/src/main/java/com/graphhopper/storage/CHGraph.java
index d7917c32ef..ae51215a51 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -17,18 +17,19 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.EdgeSkipExplorer;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeExplorer;
+import com.graphhopper.util.CHEdgeIteratorState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node and creating
- * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
+ * Extended graph interface which supports Contraction Hierarchies. Ie. storing and retrieving the
+ * levels for a node and creating shortcuts, which are additional 'artificial' edges to speedup
+ * traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
-public interface LevelGraph extends Graph
+public interface CHGraph extends Graph
 {
     /**
      * This methods sets the level of the specified node.
@@ -46,17 +47,17 @@
      * This method creates a shortcut between a to b which is nearly identical to creating an edge
      * except that it can be excluded or included for certain traversals or algorithms.
      */
-    EdgeSkipIterState shortcut( int a, int b );
+    CHEdgeIteratorState shortcut( int a, int b );
 
     @Override
-    EdgeSkipIterState getEdgeProps( int edgeId, int endNode );
+    CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode );
 
     @Override
-    EdgeSkipExplorer createEdgeExplorer();
+    CHEdgeExplorer createEdgeExplorer();
 
     @Override
-    EdgeSkipExplorer createEdgeExplorer( EdgeFilter filter );
+    CHEdgeExplorer createEdgeExplorer( EdgeFilter filter );
 
     @Override
-    AllEdgesSkipIterator getAllEdges();
+    AllCHEdgesIterator getAllEdges();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
new file mode 100644
index 0000000000..887af51f41
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -0,0 +1,622 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.BaseGraph.AllEdgeIterator;
+import com.graphhopper.storage.BaseGraph.EdgeIterable;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+
+/**
+ * A Graph implementation necessary for Contraction Hierarchies. This class enables the storage to
+ * hold the level of a node and shortcut edges per edge.
+ * <p/>
+ * @author Peter Karich
+ */
+public class CHGraphImpl implements CHGraph, Storable<CHGraph>
+{
+    private static final double WEIGHT_FACTOR = 1000f;
+    // 2 bits for access, for now only 32bit => not Long.MAX
+    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
+    private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
+    private int N_LEVEL;
+    int N_CH_REF;
+    // shortcut memory layout is synced with edges indices until E_FLAGS, then:
+    private int S_SKIP_EDGE1, S_SKIP_EDGE2;
+
+    int shortcutEntryBytes;
+    private int shortcutCount = 0;
+    final DataAccess shortcuts;
+    // the nodesCH storage is limited via baseGraph.nodeCount too
+    int nodeCHEntryBytes;
+    final DataAccess nodesCH;
+    final long scDirMask = PrepareEncoder.getScDirMask();
+    private final BaseGraph baseGraph;
+    private final EdgeAccess chEdgeAccess;
+
+    CHGraphImpl( String name, Directory dir, final BaseGraph baseGraph )
+    {
+        this.baseGraph = baseGraph;
+        this.nodesCH = dir.find("nodes_ch");
+        this.shortcuts = dir.find("shortcuts");
+        this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil)
+        {
+            @Override
+            final EdgeIterable createSingleEdge( EdgeFilter edgeFilter )
+            {
+                return new CHEdgeIteratorImpl(baseGraph, this, edgeFilter);
+            }
+
+            @Override
+            final int getEdgeRef( int nodeId )
+            {
+                return nodesCH.getInt((long) nodeId * nodeCHEntryBytes + N_CH_REF);
+            }
+
+            @Override
+            final void setEdgeRef( int nodeId, int edgeId )
+            {
+                nodesCH.setInt((long) nodeId * nodeCHEntryBytes + N_CH_REF, edgeId);
+            }
+
+            @Override
+            final int getEntryBytes()
+            {
+                return shortcutEntryBytes;
+            }
+
+            @Override
+            final long toPointer( int shortcutId )
+            {
+                assert isInBounds(shortcutId) : "shortcutId " + shortcutId + " not in bounds [" + baseGraph.edgeCount + ", " + (baseGraph.edgeCount + shortcutCount) + ")";
+                return (long) (shortcutId - baseGraph.edgeCount) * shortcutEntryBytes;
+            }
+
+            @Override
+            final boolean isInBounds( int shortcutId )
+            {
+                int tmp = shortcutId - baseGraph.edgeCount;
+                return tmp < shortcutCount && tmp >= 0;
+            }
+
+            @Override
+            final long reverseFlags( long edgePointer, long flags )
+            {
+                boolean isShortcut = edgePointer >= toPointer(baseGraph.edgeCount);
+                if (!isShortcut)
+                    return baseGraph.edgeAccess.reverseFlags(edgePointer, flags);
+
+                // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
+                long dir = flags & scDirMask;
+                if (dir == scDirMask || dir == 0)
+                    return flags;
+
+                // swap the last bits with this mask
+                return flags ^ scDirMask;
+            }
+
+            @Override
+            public String toString()
+            {
+                return "ch edge access";
+            }
+        };
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        assert baseGraph.isFrozen() : "level graph not yet frozen";
+        return edgeId >= baseGraph.edgeCount;
+    }
+
+    @Override
+    public final void setLevel( int nodeIndex, int level )
+    {
+        checkNodeId(nodeIndex);
+        nodesCH.setInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL, level);
+    }
+
+    @Override
+    public final int getLevel( int nodeIndex )
+    {
+        checkNodeId(nodeIndex);
+        return nodesCH.getInt((long) nodeIndex * nodeCHEntryBytes + N_LEVEL);
+    }
+
+    final void checkNodeId( int nodeId )
+    {
+        assert nodeId < baseGraph.getNodes() : "node " + nodeId + " is invalid. Not in [0," + baseGraph.getNodes() + ")";
+    }
+
+    @Override
+    public CHEdgeIteratorState shortcut( int a, int b )
+    {
+        if (!baseGraph.isFrozen())
+            throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
+
+        checkNodeId(a);
+        checkNodeId(b);
+
+        int scId = chEdgeAccess.internalEdgeAdd(nextShortcutId(), a, b);
+        CHEdgeIteratorImpl iter = new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(scId, b);
+        assert ret;
+        iter.setSkippedEdges(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        return iter;
+    }
+
+    protected int nextShortcutId()
+    {
+        int nextSC = shortcutCount;
+        shortcutCount++;
+        if (shortcutCount < 0)
+            throw new IllegalStateException("too many shortcuts. new shortcut id would be negative. " + toString());
+
+        shortcuts.ensureCapacity(((long) shortcutCount + 1) * shortcutEntryBytes);
+        return nextSC + baseGraph.edgeCount;
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    {
+        return edge(a, b).setDistance(distance).setFlags(baseGraph.encodingManager.flagsDefault(true, bothDirections));
+    }
+
+    @Override
+    public CHEdgeIteratorState edge( int a, int b )
+    {
+        // increase edge array not for shortcuts
+        baseGraph.ensureNodeIndex(Math.max(a, b));
+        int edgeId = baseGraph.edgeAccess.internalEdgeAdd(baseGraph.nextEdgeId(), a, b);
+        CHEdgeIteratorImpl iter = new CHEdgeIteratorImpl(baseGraph, baseGraph.edgeAccess, EdgeFilter.ALL_EDGES);
+        boolean ret = iter.init(edgeId, b);
+        assert ret;
+        return iter;
+    }
+
+    @Override
+    public CHEdgeExplorer createEdgeExplorer()
+    {
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
+    }
+
+    @Override
+    public CHEdgeExplorer createEdgeExplorer( EdgeFilter filter )
+    {
+        return new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, filter);
+    }
+
+    @Override
+    public final CHEdgeIteratorState getEdgeIteratorState( int edgeId, int endNode )
+    {
+        if (isShortcut(edgeId))
+        {
+            if (!chEdgeAccess.isInBounds(edgeId))
+                throw new IllegalStateException("shortcutId " + edgeId + " out of bounds");
+        } else
+        {
+            if (!baseGraph.edgeAccess.isInBounds(edgeId))
+                throw new IllegalStateException("edgeId " + edgeId + " out of bounds");
+        }
+
+        return (CHEdgeIteratorState) chEdgeAccess.getEdgeProps(edgeId, endNode);
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return baseGraph.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return baseGraph.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return baseGraph.getBounds();
+    }
+
+    void _freeze()
+    {
+        long maxCapacity = ((long) getNodes()) * nodeCHEntryBytes;
+        nodesCH.ensureCapacity(maxCapacity);
+        long baseCapacity = baseGraph.nodes.getCapacity();
+
+        // copy normal edge refs into ch edge refs
+        for (long pointer = N_CH_REF, basePointer = baseGraph.N_EDGE_REF;
+                pointer < maxCapacity;
+                pointer += nodeCHEntryBytes, basePointer += baseGraph.nodeEntryBytes)
+        {
+            if (basePointer >= baseCapacity)
+                throw new IllegalStateException("Cannot copy edge refs into ch graph. "
+                        + "pointer:" + pointer + ", cap:" + maxCapacity + ", basePtr:" + basePointer + ", baseCap:" + baseCapacity);
+
+            nodesCH.setInt(pointer, baseGraph.nodes.getInt(basePointer));
+        }
+    }
+
+    String toDetailsString()
+    {
+        return "shortcuts:" + shortcutCount + ", nodesCH: -(" + nodesCH.getCapacity() / Helper.MB + ")";
+    }
+
+    class CHEdgeIteratorImpl extends EdgeIterable implements CHEdgeExplorer, CHEdgeIterator
+    {
+        public CHEdgeIteratorImpl( BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter )
+        {
+            super(baseGraph, edgeAccess, filter);
+        }
+
+        @Override
+        public final CHEdgeIterator setBaseNode( int baseNode )
+        {
+            assert baseGraph.isFrozen() : "Traversal CHGraph is only possible if BaseGraph is frozen";
+
+            // always use ch edge access
+            setEdgeId(chEdgeAccess.getEdgeRef(baseNode));
+            _setBaseNode(baseNode);
+            return this;
+        }
+
+        @Override
+        public final void setSkippedEdges( int edge1, int edge2 )
+        {
+            assert isShortcut() : "cannot access skipped edges if not a shortcut";
+            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2))
+            {
+                throw new IllegalStateException("Skipped edges of a shortcut needs "
+                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
+            }
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+        }
+
+        @Override
+        public final int getSkippedEdge1()
+        {
+            assert isShortcut() : "cannot access skipped edge if not a shortcut";
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE1);
+        }
+
+        @Override
+        public final int getSkippedEdge2()
+        {
+            assert isShortcut() : "cannot access skipped edge if not a shortcut";
+            return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
+        }
+
+        @Override
+        public final boolean isShortcut()
+        {
+            // assert baseGraph.isFrozen() : "chgraph not yet frozen";
+            return edgeId >= baseGraph.edgeCount;
+        }
+
+        @Override
+        public final CHEdgeIteratorState setWeight( double weight )
+        {
+            CHGraphImpl.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            return CHGraphImpl.this.getWeight(this);
+        }
+
+        @Override
+        protected final void selectEdgeAccess()
+        {
+            if (nextEdgeId < baseGraph.edgeCount)
+                // iterate over edges
+                edgeAccess = baseGraph.edgeAccess;
+            else
+                // ... or shortcuts
+                edgeAccess = chEdgeAccess;
+        }
+
+        @Override
+        public final String getName()
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call getName on shortcut " + getEdge());
+            return super.getName();
+        }
+
+        @Override
+        public final EdgeIteratorState setName( String name )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setName on shortcut " + getEdge());
+            return super.setName(name);
+        }
+
+        @Override
+        public final PointList fetchWayGeometry( int mode )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call fetchWayGeometry on shortcut " + getEdge());
+            return super.fetchWayGeometry(mode);
+        }
+
+        @Override
+        public final EdgeIteratorState setWayGeometry( PointList list )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setWayGeometry on shortcut " + getEdge());
+            return super.setWayGeometry(list);
+        }
+    }
+
+    /**
+     * Disconnects the edges (higher->lower node) via the specified edgeState pointing from lower to
+     * higher node.
+     * <p/>
+     * @param edgeState the edge from lower to higher
+     */
+    public void disconnect( CHEdgeExplorer explorer, EdgeIteratorState edgeState )
+    {
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
+        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
+        CHEdgeIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
+        int tmpPrevEdge = EdgeIterator.NO_EDGE;
+        while (tmpIter.next())
+        {
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
+            {
+                // TODO this is ugly, move this somehow into the underlying iteration logic
+                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
+                        : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
+                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer,
+                        edgeState.getAdjNode(), edgeState.getBaseNode());
+                break;
+            }
+
+            tmpPrevEdge = tmpIter.getEdge();
+        }
+    }
+
+    @Override
+    public AllCHEdgesIterator getAllEdges()
+    {
+        return new AllCHEdgesIteratorImpl(baseGraph);
+    }
+
+    class AllCHEdgesIteratorImpl extends AllEdgeIterator implements AllCHEdgesIterator
+    {
+        public AllCHEdgesIteratorImpl( BaseGraph baseGraph )
+        {
+            super(baseGraph);
+        }
+
+        @Override
+        protected final boolean checkRange()
+        {
+            if (isShortcut())
+                return edgeId < shortcutCount;
+
+            if (super.checkRange())
+                return true;
+
+            // iterate over shortcuts
+            edgeAccess = chEdgeAccess;
+            edgeId = 0;
+            edgePointer = (long) edgeId * shortcutEntryBytes;
+            return edgeId < shortcutCount;
+        }
+
+        @Override
+        public int getMaxId()
+        {
+            return super.getMaxId() + shortcutCount;
+        }
+
+        @Override
+        public final void setSkippedEdges( int edge1, int edge2 )
+        {
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            baseGraph.edges.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+        }
+
+        @Override
+        public final int getSkippedEdge1()
+        {
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE1);
+        }
+
+        @Override
+        public final int getSkippedEdge2()
+        {
+            return baseGraph.edges.getInt(edgePointer + S_SKIP_EDGE2);
+        }
+
+        @Override
+        public final boolean isShortcut()
+        {
+            assert baseGraph.isFrozen() : "level graph not yet frozen";
+            return edgeAccess == chEdgeAccess;
+        }
+
+        @Override
+        public final CHEdgeIteratorState setWeight( double weight )
+        {
+            CHGraphImpl.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            return CHGraphImpl.this.getWeight(this);
+        }
+
+        @Override
+        public int getEdge()
+        {
+            if (isShortcut())
+                return baseGraph.edgeCount + edgeId;
+            return super.getEdge();
+        }
+    }
+
+    final void setWeight( CHEdgeIteratorState edge, double weight )
+    {
+        if (!edge.isShortcut())
+            throw new IllegalStateException("setWeight is only available for shortcuts");
+        if (weight < 0)
+            throw new IllegalArgumentException("weight cannot be negative but was " + weight);
+
+        long weightLong;
+        if (weight > MAX_WEIGHT)
+            weightLong = MAX_WEIGHT_LONG;
+        else
+            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
+
+        long accessFlags = edge.getFlags() & scDirMask;
+        edge.setFlags(weightLong | accessFlags);
+    }
+
+    final double getWeight( CHEdgeIteratorState edge )
+    {
+        if (!edge.isShortcut())
+            throw new IllegalStateException("getWeight is only available for shortcuts");
+
+        // Note: code duplication here but getWeight is very performance critical!
+        // we need to avoid reverseFlags call for getFlags and no need for 64bit
+        int flags32bit = chEdgeAccess.edges.getInt(((CHEdgeIteratorImpl) edge).edgePointer + chEdgeAccess.E_FLAGS);
+        double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
+        if (weight >= MAX_WEIGHT)
+            return Double.POSITIVE_INFINITY;
+
+        return weight;
+    }
+
+    protected int loadEdgesHeader()
+    {
+        shortcutCount = shortcuts.getHeader(0 * 4);
+        shortcutEntryBytes = shortcuts.getHeader(1 * 4);
+        return 3;
+    }
+
+    protected int setEdgesHeader()
+    {
+        shortcuts.setHeader(0 * 4, shortcutCount);
+        shortcuts.setHeader(1 * 4, shortcutEntryBytes);
+        return 3;
+    }
+
+    @Override
+    public GraphExtension getExtension()
+    {
+        return baseGraph.getExtension();
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        CHGraphImpl tmpG = ((CHGraphImpl) g);
+
+        nodesCH.copyTo(tmpG.nodesCH);
+        shortcuts.copyTo(tmpG.shortcuts);
+
+        tmpG.N_LEVEL = N_LEVEL;
+        tmpG.N_CH_REF = N_CH_REF;
+        tmpG.nodeCHEntryBytes = nodeCHEntryBytes;
+        return g;
+    }
+
+    void initStorage()
+    {
+        EdgeAccess ea = baseGraph.edgeAccess;
+        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS, false);
+        // shortcuts
+        S_SKIP_EDGE1 = ea.E_FLAGS + 4;
+        S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
+        shortcutEntryBytes = S_SKIP_EDGE2 + 4;
+
+        // node based data:
+        N_LEVEL = 0;
+        N_CH_REF = N_LEVEL + 4;
+        nodeCHEntryBytes = N_CH_REF + 4;
+    }
+
+    void setSegmentSize( int bytes )
+    {
+        nodesCH.setSegmentSize(bytes);
+        shortcuts.setSegmentSize(bytes);
+    }
+
+    @Override
+    public CHGraph create( long bytes )
+    {
+        nodesCH.create(bytes);
+        shortcuts.create(bytes);
+        return this;
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!nodesCH.loadExisting() || !shortcuts.loadExisting())
+            return false;
+
+        loadEdgesHeader();
+        return true;
+    }
+
+    @Override
+    public void flush()
+    {
+        nodesCH.flush();
+        shortcuts.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        nodesCH.close();
+        shortcuts.close();
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return nodesCH.isClosed();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return nodesCH.getCapacity() + shortcuts.getCapacity();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index a1d337c3d8..13117929fd 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -61,7 +61,9 @@
     {
         HEAP, MMAP, UNSAFE /*, DIRECT */
 
-    };
+    }
+
+    ;
     private final MemRef memRef;
     private final boolean storing;
     private final boolean integ;
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index b22c593851..0810cfe126 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -94,11 +94,11 @@
     /**
      * Ensures that the capacity of this object is at least the specified bytes. The first time you
      * have to call 'create' instead.
-     * <p>
-     * @see #create(long)
+     * <p/>
      * @return true if size was increased
+     * @see #create(long)
      */
-    boolean ensureCapacity(long bytes);
+    boolean ensureCapacity( long bytes );
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 822f967a9f..43c1f7d36a 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -51,6 +51,7 @@
      * Renames the specified DataAccess object into one.
      */
     // DataAccess rename( DataAccess da, String newName );
+
     /**
      * Removes the specified object from the directory.
      */
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
new file mode 100644
index 0000000000..fa8d73c7d5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -0,0 +1,243 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * @author Peter Karich
+ */
+abstract class EdgeAccess
+{
+    // distance of around +-1000 000 meter are ok
+    private static final double INT_DIST_FACTOR = 1000d;
+    static final int NO_NODE = -1;
+    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
+    final DataAccess edges;
+    private final BitUtil bitUtil;
+    private boolean flagsSizeIsLong;
+
+    EdgeAccess( DataAccess edges, BitUtil bitUtil )
+    {
+        this.edges = edges;
+        this.bitUtil = bitUtil;
+    }
+
+    final void init( int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS, boolean flagsSizeIsLong )
+    {
+        this.E_NODEA = E_NODEA;
+        this.E_NODEB = E_NODEB;
+        this.E_LINKA = E_LINKA;
+        this.E_LINKB = E_LINKB;
+        this.E_DIST = E_DIST;
+        this.E_FLAGS = E_FLAGS;
+        this.flagsSizeIsLong = flagsSizeIsLong;
+    }
+
+    abstract BaseGraph.EdgeIterable createSingleEdge( EdgeFilter edgeFilter );
+
+    abstract long toPointer( int edgeOrShortcutId );
+
+    abstract boolean isInBounds( int edgeOrShortcutId );
+
+    abstract long reverseFlags( long edgePointer, long flags );
+
+    abstract int getEdgeRef( int nodeId );
+
+    abstract void setEdgeRef( int nodeId, int edgeId );
+
+    abstract int getEntryBytes();
+
+    final void invalidateEdge( long edgePointer )
+    {
+        edges.setInt(edgePointer + E_NODEA, NO_NODE);
+    }
+
+    final void setDist( long edgePointer, double distance )
+    {
+        edges.setInt(edgePointer + E_DIST, distToInt(distance));
+    }
+
+    /**
+     * Translates double distance to integer in order to save it in a DataAccess object
+     */
+    private int distToInt( double distance )
+    {
+        int integ = (int) (distance * INT_DIST_FACTOR);
+        if (integ < 0)
+            throw new IllegalArgumentException("Distance cannot be empty: "
+                    + distance + ", maybe overflow issue? integer: " + integ);
+
+        // Due to rounding errors e.g. when getting the distance from another DataAccess object
+        // the following exception is not a good idea: 
+        // Allow integ to be 0 only if distance is 0
+        // if (integ == 0 && distance > 0)
+        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
+        //            distance + ", integer: " + integ);
+        return integ;
+    }
+
+    /**
+     * returns distance (already translated from integer to double)
+     */
+    final double getDist( long pointer )
+    {
+        int val = edges.getInt(pointer + E_DIST);
+        if (val == Integer.MAX_VALUE)
+            return Double.POSITIVE_INFINITY;
+
+        return val / INT_DIST_FACTOR;
+    }
+
+    final long getFlags_( long edgePointer, boolean reverse )
+    {
+        int low = edges.getInt(edgePointer + E_FLAGS);
+        long resFlags = low;
+        if (flagsSizeIsLong)
+        {
+            int high = edges.getInt(edgePointer + E_FLAGS + 4);
+            resFlags = bitUtil.combineIntsToLong(low, high);
+        }
+        if (reverse)
+            resFlags = reverseFlags(edgePointer, resFlags);
+
+        return resFlags;
+    }
+
+    final long setFlags_( long edgePointer, boolean reverse, long flags )
+    {
+        if (reverse)
+            flags = reverseFlags(edgePointer, flags);
+
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
+        if (flagsSizeIsLong)
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
+
+        return flags;
+    }
+
+    /**
+     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
+     */
+    final int internalEdgeAdd( int newEdgeId, int fromNodeId, int toNodeId )
+    {
+        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        connectNewEdge(fromNodeId, newEdgeId);
+        if (fromNodeId != toNodeId)
+            connectNewEdge(toNodeId, newEdgeId);
+        return newEdgeId;
+    }
+
+    final int getOtherNode( int nodeThis, long edgePointer )
+    {
+        int nodeA = edges.getInt(edgePointer + E_NODEA);
+        if (nodeA == nodeThis)
+            // return b
+            return edges.getInt(edgePointer + E_NODEB);
+        // return a
+        return nodeA;
+    }
+
+    private long _getLinkPosInEdgeArea( int nodeThis, int nodeOther, long edgePointer )
+    {
+        return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
+    }
+
+    final int getEdgeRef( int nodeThis, int nodeOther, long edgePointer )
+    {
+        return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
+    }
+
+    final void connectNewEdge( int fromNode, int newOrExistingEdge )
+    {
+        int edge = getEdgeRef(fromNode);
+        if (edge > EdgeIterator.NO_EDGE)
+        {
+            long edgePointer = toPointer(newOrExistingEdge);
+            int otherNode = getOtherNode(fromNode, edgePointer);
+            long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
+            edges.setInt(lastLink, edge);
+        }
+        setEdgeRef(fromNode, newOrExistingEdge);
+    }
+
+    final long writeEdge( int edgeId, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther )
+    {
+        if (nodeThis > nodeOther)
+        {
+            int tmp = nodeThis;
+            nodeThis = nodeOther;
+            nodeOther = tmp;
+            tmp = nextEdge;
+            nextEdge = nextEdgeOther;
+            nextEdgeOther = tmp;
+        }
+        if (edgeId < 0 || edgeId == EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("Cannot write edge with illegal ID:" + edgeId + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
+
+        long edgePointer = toPointer(edgeId);
+        edges.setInt(edgePointer + E_NODEA, nodeThis);
+        edges.setInt(edgePointer + E_NODEB, nodeOther);
+        edges.setInt(edgePointer + E_LINKA, nextEdge);
+        edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
+        return edgePointer;
+    }
+
+    /**
+     * This method disconnects the specified edge from the list of edges of the specified node. It
+     * does not release the freed space to be reused.
+     * <p/>
+     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
+     * of nodes
+     */
+    final long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode )
+    {
+        long edgeToRemovePointer = toPointer(edgeToRemove);
+        // an edge is shared across the two nodes even if the edge is not in both directions
+        // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
+        int nextEdgeId = getEdgeRef(baseNode, adjNode, edgeToRemovePointer);
+        if (edgeToUpdatePointer < 0)
+        {
+            setEdgeRef(baseNode, nextEdgeId);
+        } else
+        {
+            // adjNode is different for the edge we want to update with the new link
+            long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
+                    ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
+            edges.setInt(link, nextEdgeId);
+        }
+        return edgeToRemovePointer;
+    }
+
+    final EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    {
+        if (edgeId <= EdgeIterator.NO_EDGE)
+            throw new IllegalStateException("edgeId invalid " + edgeId + ", " + this);
+
+        BaseGraph.EdgeIterable edge = createSingleEdge(EdgeFilter.ALL_EDGES);
+        if (edge.init(edgeId, adjNode))
+            return edge;
+
+        // if edgeId exists but adjacent nodes do not match
+        return null;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index 184a4ba9fe..59bd0f65d2 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -59,7 +59,11 @@ public EdgeEntry cloneFull()
     @Override
     public int compareTo( EdgeEntry o )
     {
-        return Double.compare(weight, o.weight);
+        if (weight < o.weight)
+            return -1;
+
+        // assumption no NaN and no -0        
+        return weight > o.weight ? 1 : 0;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 8309be2a94..4b01333f0f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
 import java.util.Collection;
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index b075f3864f..ea15626ebd 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -22,15 +22,15 @@
 
 /**
  * A helper class for GraphHopperStorage for its node access.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 class GHNodeAccess implements NodeAccess
 {
-    private final GraphHopperStorage that;
+    private final BaseGraph that;
     private final boolean elevation;
 
-    public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
+    public GHNodeAccess( BaseGraph that, boolean withElevation )
     {
         this.that = that;
         this.elevation = withElevation;
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 65e9c63b26..be7b0f1f31 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -25,7 +25,7 @@
 
 /**
  * An interface to represent a (geo) graph - suited for efficient storage as it can be requested via
- * indices called node IDs. To get the lat,lon point you need to set up a Location2IDIndex instance.
+ * indices called node IDs. To get the lat,lon point you need to set up a LocationIndex instance.
  * <p/>
  * @author Peter Karich
  */
@@ -71,12 +71,12 @@
      * Returns a wrapper over the specified edgeId.
      * <p/>
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
-     * Integer.MIN_VALUE then the edge with undefined values for adjNode and baseNode will be
-     * returned.
-     * @return an edge iterator state
+     * Integer.MIN_VALUE then the edge with uncertain values for adjNode and baseNode (two
+     * possibilities) will be returned.
+     * @return an edge iterator state or potentially null if adjNode does not match
      * @throws IllegalStateException if edgeId is not valid
      */
-    EdgeIteratorState getEdgeProps( int edgeId, int adjNode );
+    EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode );
 
     /**
      * @return all edges in this graph, where baseNode will be the smaller node.
@@ -84,26 +84,24 @@
     AllEdgesIterator getAllEdges();
 
     /**
-     * Returns an iterator which makes it possible to traverse all edges of the specified node if
-     * the filter accepts the edge. Reduce calling this method as much as possible, e.g. create it
-     * before a for loop!
+     * Returns an EdgeExplorer which makes it possible to traverse all filtered edges of a specific
+     * node. Reduce calling this method as much as possible, e.g. create an explorer before a for
+     * loop!
      * <p/>
+     * @see EdgeExplorer
      * @see Graph#createEdgeExplorer()
      */
     EdgeExplorer createEdgeExplorer( EdgeFilter filter );
 
     /**
-     * Returns all the edges reachable from the specified index. Same behaviour as
-     * graph.getEdges(index, EdgeFilter.ALL_EDGES);
-     * <p/>
-     * @return all edges regardless of the vehicle type or direction.
+     * @see Graph#createEdgeExplorer(com.graphhopper.routing.util.EdgeFilter)
      */
     EdgeExplorer createEdgeExplorer();
 
     /**
      * Copy this Graph into the specified Graph g.
-     * <p>
-     * @return the specified GraphStorage g
+     * <p/>
+     * @return the specified Graph g
      */
     Graph copyTo( Graph g );
 
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index cfcbc63c83..3cd79ceb30 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -30,7 +30,7 @@
     private String location;
     private boolean mmap;
     private boolean store;
-    private boolean level;
+    private boolean chGraph;
     private boolean elevation;
     private long byteCapacity = 100;
 
@@ -40,13 +40,13 @@ public GraphBuilder( EncodingManager encodingManager )
     }
 
     /**
-     * If true builder will create a LevelGraph
+     * If true builder will create a CHGraph
      * <p/>
-     * @see LevelGraph
+     * @see CHGraph
      */
-    public GraphBuilder setLevelGraph( boolean level )
+    public GraphBuilder setCHGraph( boolean isCHGraph )
     {
-        this.level = level;
+        this.chGraph = isCHGraph;
         return this;
     }
 
@@ -85,17 +85,12 @@ public boolean hasElevation()
         return elevation;
     }
 
-    public LevelGraphStorage levelGraphBuild()
-    {
-        return (LevelGraphStorage) setLevelGraph(true).build();
-    }
-
     /**
-     * Creates a LevelGraphStorage
+     * Creates a CHGraph
      */
-    public LevelGraphStorage levelGraphCreate()
+    public CHGraph chGraphCreate()
     {
-        return (LevelGraphStorage) setLevelGraph(true).create();
+        return setCHGraph(true).create().getGraph(CHGraph.class);
     }
 
     /**
@@ -103,7 +98,7 @@ public LevelGraphStorage levelGraphCreate()
      * Afterwards you'll need to call GraphStorage.create to have a useable object. Better use
      * create.
      */
-    public GraphStorage build()
+    public GraphHopperStorage build()
     {
         Directory dir;
         if (mmap)
@@ -111,16 +106,11 @@ public GraphStorage build()
         else
             dir = new RAMDirectory(location, store);
 
-        GraphStorage graph;
-        if (level)
-            graph = new LevelGraphStorage(dir, encodingManager, elevation);
+        GraphHopperStorage graph;
+        if (encodingManager.needsTurnCostsSupport())
+            graph = new GraphHopperStorage(false, dir, encodingManager, elevation, new TurnCostExtension());
         else
-        {
-            if (encodingManager.needsTurnCostsSupport())
-                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
-            else
-                graph = new GraphHopperStorage(dir, encodingManager, elevation);
-        }
+            graph = new GraphHopperStorage(chGraph, dir, encodingManager, elevation, new TurnCostExtension.NoOpExtension());
 
         return graph;
     }
@@ -128,7 +118,7 @@ public GraphStorage build()
     /**
      * Default graph is a GraphStorage with an in memory directory and disabled storing on flush.
      */
-    public GraphStorage create()
+    public GraphHopperStorage create()
     {
         return build().create(byteCapacity);
     }
@@ -136,9 +126,9 @@ public GraphStorage create()
     /**
      * @throws IllegalStateException if not loadable.
      */
-    public GraphStorage load()
+    public GraphHopperStorage load()
     {
-        GraphStorage gs = build();
+        GraphHopperStorage gs = build();
         if (!gs.loadExisting())
         {
             throw new IllegalStateException("Cannot load graph " + location);
diff --git a/core/src/main/java/com/graphhopper/storage/GraphExtension.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
index 380bf4ec82..b46355dfbe 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -44,9 +44,9 @@
     int getDefaultEdgeFieldValue();
 
     /**
-     * initializes the extended storage by giving the graph storage
+     * initializes the extended storage by giving the base graph
      */
-    void init( GraphStorage graph );
+    void init( Graph graph, Directory dir );
 
     /**
      * sets the segment size in all additional data storages
@@ -62,7 +62,7 @@
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements GraphExtension
+    public class NoOpExtension implements GraphExtension
     {
 
         @Override
@@ -90,7 +90,7 @@ public int getDefaultEdgeFieldValue()
         }
 
         @Override
-        public void init( GraphStorage grap )
+        public void init( Graph grap, Directory dir )
         {
             // noop
         }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index ca0dddb46c..ca5c46e230 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -17,145 +17,92 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.coll.GHBitSet;
-import com.graphhopper.coll.GHBitSetImpl;
-import com.graphhopper.coll.SparseIntIntArray;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
-import static com.graphhopper.util.Helper.nf;
-import java.io.UnsupportedEncodingException;
-
 /**
- * The main implementation which handles nodes and edges file format. It can be used with different
- * Directory implementations like RAMDirectory for fast access or via MMapDirectory for
- * virtual-memory and not thread safe usage.
- * <p/>
- * Note: A RAM DataAccess Object is thread-safe in itself but if used in this Graph implementation
- * it is not write thread safe.
- * <p/>
- * Life cycle: (1) object creation, (2) configuration via setters & getters, (3) create or
- * loadExisting, (4) usage, (5) flush, (6) close
- * <p/>
- * @see GraphBuilder Use the GraphBuilder class to create a (Level)GraphStorage easier.
- * @see LevelGraphStorage
+ * This class manages all storage related methods and delegates the calls to the associated graphs.
+ * The associated graphs manage their own necessary data structures and are used to provide e.g.
+ * different traversal methods. By default this class implements the graph interface and results in
+ * identical behavior as the Graph instance from getGraph(Graph.class)
+ * <p>
  * @author Peter Karich
+ * @see GraphBuilder to create a (CH)Graph easier
+ * @see #getGraph(java.lang.Class)
  */
-public class GraphHopperStorage implements GraphStorage
+public final class GraphHopperStorage implements GraphStorage, Graph
 {
-    private static final int NO_NODE = -1;
-    // Emergency stop. to detect if something went wrong with our storage system and to prevent us from an infinit loop.
-    // Road networks typically do not have nodes with plenty of edges!
-    private static final int MAX_EDGES = 1000;
-    // distance of around +-1000 000 meter are ok
-    private static final double INT_DIST_FACTOR = 1000d;
     private final Directory dir;
-    // edge memory layout:
-    protected int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS, E_GEO, E_NAME, E_ADDITIONAL;
-    /**
-     * Specifies how many entries (integers) are used per edge.
-     */
-    protected int edgeEntryBytes;
-    protected final DataAccess edges;
-    /**
-     * interval [0,n)
-     */
-    protected int edgeCount;
-    // node memory layout:
-    protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
-    /**
-     * Specifies how many entries (integers) are used per node
-     */
-    protected int nodeEntryBytes;
-    protected final DataAccess nodes;
-    /**
-     * interval [0,n)
-     */
-    private int nodeCount;
-    final BBox bounds;
-    // remove markers are not yet persistent!
-    private GHBitSet removedNodes;
-    private int edgeEntryIndex, nodeEntryIndex;
-    // length | nodeA | nextNode | ... | nodeB
-    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
-    private final DataAccess wayGeometry;
-    private int maxGeoRef;
-    private boolean initialized = false;
     private EncodingManager encodingManager;
-    private final NameIndex nameIndex;
     private final StorableProperties properties;
-    private final BitUtil bitUtil;
-    private boolean flagsSizeIsLong;
-    final GraphExtension extStorage;
-    private final NodeAccess nodeAccess;
+    private final BaseGraph baseGraph;
+    // same flush order etc
+    private CHGraphImpl chGraph;
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
     {
-        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
+        this(false, dir, encodingManager, withElevation, new GraphExtension.NoOpExtension());
     }
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
-            GraphExtension extendedStorage )
+    public GraphHopperStorage( boolean enableCH, Directory dir, final EncodingManager encodingManager,
+                               boolean withElevation, GraphExtension extendedStorage )
     {
-        if (encodingManager == null)
-            throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
-                    + "If you need to parse EncodingManager configuration from existing graph use EncodingManager.create");
+        if (extendedStorage == null)
+            throw new IllegalArgumentException("GraphExtension cannot be null, use NoOpExtension");
 
         this.encodingManager = encodingManager;
-        this.extStorage = extendedStorage;
         this.dir = dir;
-        this.bitUtil = BitUtil.get(dir.getByteOrder());
-        this.nodes = dir.find("nodes");
-        this.edges = dir.find("edges");
-        this.wayGeometry = dir.find("geometry");
-        this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.createInverse(withElevation);
-        this.nodeAccess = new GHNodeAccess(this, withElevation);
-        extendedStorage.init(this);
-    }
+        InternalGraphEventListener listener = new InternalGraphEventListener()
+        {
+            @Override
+            public void initStorage()
+            {
+                if (isCHPossible())
+                    chGraph.initStorage();
+            }
 
-    @Override
-    public Graph getBaseGraph()
-    {
-        return this;
-    }
+            @Override
+            public void freeze()
+            {
+                if (isCHPossible())
+                    chGraph._freeze();
+            }
+        };
 
-    void checkInit()
-    {
-        if (initialized)
-            throw new IllegalStateException("You cannot configure this GraphStorage "
-                    + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
-    }
+        this.baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
 
-    protected final int nextEdgeEntryIndex( int sizeInBytes )
-    {
-        int tmp = edgeEntryIndex;
-        edgeEntryIndex += sizeInBytes;
-        return tmp;
+        if (enableCH)
+        {
+            // name level graph according to first flag encoder and fastest?
+            chGraph = new CHGraphImpl("ch", dir, this.baseGraph);
+        }
     }
 
-    protected final int nextNodeEntryIndex( int sizeInBytes )
+    /**
+     * This method returns the routing graph for the specified weighting, could be potentially
+     * filled with shortcuts.
+     */
+    public <T extends Graph> T getGraph( Class<T> clazz )
     {
-        int tmp = nodeEntryIndex;
-        nodeEntryIndex += sizeInBytes;
-        return tmp;
+        if (clazz.equals(Graph.class))
+            return (T) baseGraph;
+
+        // currently only one ch graph        
+        if (chGraph == null)
+            throw new IllegalStateException("Cannot find implementation for " + clazz);
+
+        // TODO later: this method will also contain 'String weighting' to return the correct chGraph 
+        return (T) chGraph;
     }
 
-    protected final void initNodeAndEdgeEntrySize()
+    public boolean isCHPossible()
     {
-        nodeEntryBytes = nodeEntryIndex;
-        edgeEntryBytes = edgeEntryIndex;
+        return chGraph != null;
     }
 
     /**
@@ -170,1457 +117,278 @@ public Directory getDirectory()
     @Override
     public void setSegmentSize( int bytes )
     {
-        checkInit();
-        nodes.setSegmentSize(bytes);
-        edges.setSegmentSize(bytes);
-        wayGeometry.setSegmentSize(bytes);
-        nameIndex.setSegmentSize(bytes);
-        extStorage.setSegmentSize(bytes);
+        baseGraph.setSegmentSize(bytes);
+        if (isCHPossible())
+            chGraph.setSegmentSize(bytes);
     }
 
     /**
      * After configuring this storage you need to create it explicitly.
      */
     @Override
-    public GraphStorage create( long byteCount )
+    public GraphHopperStorage create( long byteCount )
     {
-        checkInit();
+        baseGraph.checkInit();
         if (encodingManager == null)
             throw new IllegalStateException("EncodingManager can only be null if you call loadExisting");
 
         long initSize = Math.max(byteCount, 100);
-        nodes.create(initSize);
-        edges.create(initSize);
-        wayGeometry.create(initSize);
-        nameIndex.create(1000);
         properties.create(100);
-        extStorage.create(initSize);
 
         properties.put("graph.bytesForFlags", encodingManager.getBytesForFlags());
         properties.put("graph.flagEncoders", encodingManager.toDetailsString());
 
         properties.put("graph.byteOrder", dir.getByteOrder());
-        properties.put("graph.dimension", nodeAccess.getDimension());
+        properties.put("graph.dimension", baseGraph.nodeAccess.getDimension());
         properties.putCurrentVersions();
-        initStorage();
-        // 0 stands for no separate geoRef
-        maxGeoRef = 4;
 
-        initNodeRefs(0, nodes.getCapacity());
+        baseGraph.create(initSize);
+
+        if (isCHPossible())
+            chGraph.create(byteCount);
+
         return this;
     }
 
     @Override
-    public int getNodes()
+    public EncodingManager getEncodingManager()
     {
-        return nodeCount;
+        return encodingManager;
     }
 
     @Override
-    public NodeAccess getNodeAccess()
+    public StorableProperties getProperties()
     {
-        return nodeAccess;
+        return properties;
     }
 
-    /**
-     * Translates double distance to integer in order to save it in a DataAccess object
-     */
-    private int distToInt( double distance )
+    public void setAdditionalEdgeField( long edgePointer, int value )
     {
-        int integ = (int) (distance * INT_DIST_FACTOR);
-        if (integ < 0)
-            throw new IllegalArgumentException("Distance cannot be empty: "
-                    + distance + ", maybe overflow issue? integer: " + integ);
-
-        // Due to rounding errors e.g. when getting the distance from another DataAccess object
-        // the following exception is not a good idea: 
-        // Allow integ to be 0 only if distance is 0
-        // if (integ == 0 && distance > 0)
-        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
-        //            distance + ", integer: " + integ);
-        return integ;
+        baseGraph.setAdditionalEdgeField(edgePointer, value);
     }
 
-    /**
-     * returns distance (already translated from integer to double)
-     */
-    private double getDist( long pointer )
+    @Override
+    public void markNodeRemoved( int index )
     {
-        int val = edges.getInt(pointer + E_DIST);
-        if (val == Integer.MAX_VALUE)
-            return Double.POSITIVE_INFINITY;
-
-        return val / INT_DIST_FACTOR;
+        baseGraph.getRemovedNodes().add(index);
     }
 
     @Override
-    public BBox getBounds()
+    public boolean isNodeRemoved( int index )
     {
-        return bounds;
+        return baseGraph.getRemovedNodes().contains(index);
     }
 
-    /**
-     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
-     * extend byte capacity
-     */
-    final void ensureNodeIndex( int nodeIndex )
+    @Override
+    public void optimize()
     {
-        if (!initialized)
-            throw new AssertionError("The graph has not yet been initialized.");
+        if (isFrozen())
+            throw new IllegalStateException("do not optimize after graph was frozen");
 
-        if (nodeIndex < nodeCount)
+        int delNodes = baseGraph.getRemovedNodes().getCardinality();
+        if (delNodes <= 0)
             return;
 
-        long oldNodes = nodeCount;
-        nodeCount = nodeIndex + 1;
-        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
-        if (capacityIncreased)
-        {
-            long newBytesCapacity = nodes.getCapacity();
-            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
-            if (removedNodes != null)
-                getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
-        }
+        // Deletes only nodes.
+        // It reduces the fragmentation of the node space but introduces new unused edges.
+        baseGraph.inPlaceNodeRemove(delNodes);
 
+        // Reduce memory usage
+        baseGraph.trimToSize();
     }
 
-    /**
-     * Initializes the node area with the empty edge value and default additional value.
-     */
-    private void initNodeRefs( long oldCapacity, long newCapacity )
+    @Override
+    public boolean loadExisting()
     {
-        for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes)
+        baseGraph.checkInit();
+        if (properties.loadExisting())
         {
-            nodes.setInt(pointer, EdgeIterator.NO_EDGE);
-        }
-        if (extStorage.isRequireNodeField())
-        {
-            for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes)
+            properties.checkVersions(false);
+            // check encoding for compatiblity
+            String acceptStr = properties.get("graph.flagEncoders");
+
+            if (encodingManager == null)
             {
-                nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());
+                if (acceptStr.isEmpty())
+                    throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
+                            + dir.getLocation());
+
+                int bytesForFlags = 4;
+                if ("8".equals(properties.get("graph.bytesForFlags")))
+                    bytesForFlags = 8;
+                encodingManager = new EncodingManager(acceptStr, bytesForFlags);
+            } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
+            {
+                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
+                        + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
             }
-        }
-    }
 
-    private void ensureEdgeIndex( int edgeIndex )
-    {
-        edges.ensureCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
-    }
+            String byteOrder = properties.get("graph.byteOrder");
+            if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
+                throw new IllegalStateException("Configured byteOrder (" + byteOrder + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
 
-    private void ensureGeometry( long bytePos, int byteLength )
-    {
-        wayGeometry.ensureCapacity(bytePos + byteLength);
-    }
+            String dim = properties.get("graph.dimension");
+            baseGraph.loadExisting(dim);
 
-    @Override
-    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirection )
-    {
-        return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
+            if (isCHPossible())
+            {
+                if (!chGraph.loadExisting())
+                    throw new IllegalStateException("Cannot load ch graph " + chGraph.toString());
+            }
+
+            return true;
+        }
+        return false;
     }
 
-    /**
-     * Create edge between nodes a and b
-     * <p>
-     * @return EdgeIteratorState of newly created edge
-     */
     @Override
-    public EdgeIteratorState edge( int a, int b )
+    public void flush()
     {
-        ensureNodeIndex(Math.max(a, b));
-        int edge = internalEdgeAdd(a, b);
-        EdgeIterable iter = new EdgeIterable(EdgeFilter.ALL_EDGES);
-        iter.setBaseNode(a);
-        iter.setEdgeId(edge);
-        if (extStorage.isRequireEdgeField())
+        if (isCHPossible())
         {
-            iter.setAdditionalField(extStorage.getDefaultEdgeFieldValue());
+            chGraph.setEdgesHeader();
+            chGraph.flush();
         }
-        iter.next();
-        return iter;
-    }
 
-    private int nextGeoRef( int arrayLength )
-    {
-        int tmp = maxGeoRef;
-        // one more integer to store also the size itself
-        maxGeoRef += arrayLength + 1;
-        return tmp;
+        baseGraph.flush();
+        properties.flush();
     }
 
-    /**
-     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
-     */
-    int internalEdgeAdd( int fromNodeId, int toNodeId )
+    @Override
+    public void close()
     {
-        int newEdgeId = nextEdge();
-        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newEdgeId);
-        if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newEdgeId);
-
-        return newEdgeId;
-    }
+        properties.close();
+        baseGraph.close();
 
-    // for test only
-    void setEdgeCount( int cnt )
-    {
-        edgeCount = cnt;
+        if (isCHPossible())
+            chGraph.close();
     }
 
-    /**
-     * Determine next free edgeId and ensure byte capacity to store edge
-     * <p>
-     * @return next free edgeId
-     */
-    private int nextEdge()
+    @Override
+    public boolean isClosed()
     {
-        int nextEdge = edgeCount;
-        edgeCount++;
-        if (edgeCount < 0)
-            throw new IllegalStateException("too many edges. new edge id would be negative. " + toString());
-
-        ensureEdgeIndex(edgeCount);
-        return nextEdge;
+        return baseGraph.nodes.isClosed();
     }
 
-    private void connectNewEdge( int fromNode, int newOrExistingEdge )
+    @Override
+    public long getCapacity()
     {
-        long nodePointer = (long) fromNode * nodeEntryBytes;
-        int edge = nodes.getInt(nodePointer + N_EDGE_REF);
-        if (edge > EdgeIterator.NO_EDGE)
-        {
-            long edgePointer = (long) newOrExistingEdge * edgeEntryBytes;
-            int otherNode = getOtherNode(fromNode, edgePointer);
-            long lastLink = getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
-            edges.setInt(lastLink, edge);
-        }
+        long cnt = baseGraph.getCapacity() + properties.getCapacity();
 
-        nodes.setInt(nodePointer + N_EDGE_REF, newOrExistingEdge);
+        if (isCHPossible())
+            cnt += chGraph.getCapacity();
+        return cnt;
     }
 
-    private long writeEdge( int edge, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther )
+    /**
+     * Avoid that edges and nodes of the base graph are further modified. Necessary as hook for e.g.
+     * ch graphs on top to initilize themself
+     */
+    public void freeze()
     {
-        if (nodeThis > nodeOther)
-        {
-            int tmp = nodeThis;
-            nodeThis = nodeOther;
-            nodeOther = tmp;
-
-            tmp = nextEdge;
-            nextEdge = nextEdgeOther;
-            nextEdgeOther = tmp;
-        }
-
-        long edgePointer = (long) edge * edgeEntryBytes;
-        edges.setInt(edgePointer + E_NODEA, nodeThis);
-        edges.setInt(edgePointer + E_NODEB, nodeOther);
-        edges.setInt(edgePointer + E_LINKA, nextEdge);
-        edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
-        return edgePointer;
+        if (!baseGraph.isFrozen())
+            baseGraph.freeze();
     }
 
-    protected final long getLinkPosInEdgeArea( int nodeThis, int nodeOther, long edgePointer )
+    boolean isFrozen()
     {
-        return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
+        return baseGraph.isFrozen();
     }
 
-    public String getDebugInfo( int node, int area )
+    @Override
+    public String toDetailsString()
     {
-        String str = "--- node " + node + " ---";
-        int min = Math.max(0, node - area / 2);
-        int max = Math.min(nodeCount, node + area / 2);
-        long nodePointer = (long) node * nodeEntryBytes;
-        for (int i = min; i < max; i++)
-        {
-            str += "\n" + i + ": ";
-            for (int j = 0; j < nodeEntryBytes; j += 4)
-            {
-                if (j > 0)
-                {
-                    str += ",\t";
-                }
-                str += nodes.getInt(nodePointer + j);
-            }
-        }
-        int edge = nodes.getInt(nodePointer);
-        str += "\n--- edges " + edge + " ---";
-        int otherNode;
-        for (int i = 0; i < 1000; i++)
-        {
-            str += "\n";
-            if (edge == EdgeIterator.NO_EDGE)
-                break;
-
-            str += edge + ": ";
-            long edgePointer = (long) edge * edgeEntryBytes;
-            for (int j = 0; j < edgeEntryBytes; j += 4)
-            {
-                if (j > 0)
-                {
-                    str += ",\t";
-                }
-                str += edges.getInt(edgePointer + j);
-            }
+        String str = baseGraph.toDetailsString();
+        if (isCHPossible())
+            str += ", " + chGraph.toDetailsString();
 
-            otherNode = getOtherNode(node, edgePointer);
-            long lastLink = getLinkPosInEdgeArea(node, otherNode, edgePointer);
-            edge = edges.getInt(lastLink);
-        }
         return str;
     }
 
-    private int getOtherNode( int nodeThis, long edgePointer )
-    {
-        int nodeA = edges.getInt(edgePointer + E_NODEA);
-        if (nodeA == nodeThis)
-        // return b
-        {
-            return edges.getInt(edgePointer + E_NODEB);
-        }
-        // return a
-        return nodeA;
-    }
-
     @Override
-    public AllEdgesIterator getAllEdges()
+    public String toString()
     {
-        return new AllEdgeIterator();
+        return (isCHPossible() ? "CH|" : "")
+                + encodingManager
+                + "|" + getDirectory().getDefaultType()
+                + "|" + baseGraph.nodeAccess.getDimension() + "D"
+                + "|" + baseGraph.extStorage
+                + "|" + getProperties().versionsToString();
     }
 
+    // now all delegation graph method to avoid ugly programming flow ala
+    // GraphHopperStorage storage = ..;
+    // Graph g = storage.getGraph(Graph.class);
+    // instead directly the storage can be used to traverse the base graph
     @Override
-    public EncodingManager getEncodingManager()
+    public Graph getBaseGraph()
     {
-        return encodingManager;
+        return baseGraph;
     }
 
     @Override
-    public StorableProperties getProperties()
+    public final int getNodes()
     {
-        return properties;
+        return baseGraph.getNodes();
     }
 
-    /**
-     * Include all edges of this storage in the iterator.
-     */
-    protected class AllEdgeIterator implements AllEdgesIterator
+    @Override
+    public final NodeAccess getNodeAccess()
     {
-        protected long edgePointer = -edgeEntryBytes;
-        private final long maxEdges = (long) edgeCount * edgeEntryBytes;
-        private int nodeA;
-        private int nodeB;
-        private boolean reverse = false;
-
-        public AllEdgeIterator()
-        {
-        }
-
-        @Override
-        public int getCount()
-        {
-            return edgeCount;
-        }
-
-        @Override
-        public boolean next()
-        {
-            do
-            {
-                edgePointer += edgeEntryBytes;
-                nodeA = edges.getInt(edgePointer + E_NODEA);
-                nodeB = edges.getInt(edgePointer + E_NODEB);
-                reverse = getBaseNode() > getAdjNode();
-                // some edges are deleted and have a negative node
-            } while (nodeA == NO_NODE && edgePointer < maxEdges);
-            return edgePointer < maxEdges;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return nodeA;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return nodeB;
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return getDist(edgePointer);
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            edges.setInt(edgePointer + E_DIST, distToInt(dist));
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.getInt(edgePointer + E_ADDITIONAL);
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            GraphHopperStorage.this.setAdditionalEdgeField(edgePointer, value);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            GraphHopperStorage.this.setFlags(edgePointer, reverse, flags);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return GraphHopperStorage.this.copyProperties(this, edge);
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return (int) (edgePointer / edgeEntryBytes);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
-        {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
-            return this;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int type )
-        {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse,
-                    type, getBaseNode(), getAdjNode());
-        }
-
-        @Override
-        public String getName()
-        {
-            int nameIndexRef = edges.getInt(edgePointer + E_NAME);
-            return nameIndex.get(nameIndexRef);
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            long nameIndexRef = nameIndex.put(name);
-            if (nameIndexRef < 0)
-                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
-
-            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgePointer < 0)
-                throw new IllegalStateException("call next before detaching");
-            AllEdgeIterator iter = new AllEdgeIterator();
-            iter.nodeA = nodeA;
-            iter.nodeB = nodeB;
-            iter.edgePointer = edgePointer;
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.nodeA = nodeB;
-                iter.nodeB = nodeA;
-            }
-            return iter;
-        }
-
-        @Override
-        public String toString()
-        {
-            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
-        }
+        return baseGraph.getNodeAccess();
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    public final BBox getBounds()
     {
-        if (edgeId <= EdgeIterator.NO_EDGE || edgeId >= edgeCount)
-            throw new IllegalStateException("edgeId " + edgeId + " out of bounds [0," + nf(edgeCount) + "]");
-
-        if (adjNode < 0 && adjNode != Integer.MIN_VALUE)
-            throw new IllegalStateException("adjNode " + adjNode + " out of bounds [0," + nf(nodeCount) + "]");
-
-        long edgePointer = (long) edgeId * edgeEntryBytes;
-        int nodeA = edges.getInt(edgePointer + E_NODEA);
-        if (nodeA == NO_NODE)
-            throw new IllegalStateException("edgeId " + edgeId + " is invalid - already removed!");
-
-        int nodeB = edges.getInt(edgePointer + E_NODEB);
-        SingleEdge edge;
-        if (adjNode == nodeB || adjNode == Integer.MIN_VALUE)
-        {
-            edge = createSingleEdge(edgeId, nodeA);
-            edge.reverse = false;
-            edge.adjNode = nodeB;
-            return edge;
-        } else if (adjNode == nodeA)
-        {
-            edge = createSingleEdge(edgeId, nodeB);
-            edge.adjNode = nodeA;
-            edge.reverse = true;
-            return edge;
-        }
-        // if edgeId exists but adjacent nodes do not match
-        return null;
+        return baseGraph.getBounds();
     }
 
-    protected SingleEdge createSingleEdge( int edgeId, int nodeId )
+    @Override
+    public final EdgeIteratorState edge( int a, int b )
     {
-        return new SingleEdge(edgeId, nodeId);
+        return baseGraph.edge(a, b);
     }
 
-    private long getFlags( long edgePointer, boolean reverse )
+    @Override
+    public final EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        int low = edges.getInt(edgePointer + E_FLAGS);
-        long res = low;
-        if (flagsSizeIsLong)
-        {
-            int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            res = bitUtil.combineIntsToLong(low, high);
-        }
-        if (reverse)
-            return reverseFlags(edgePointer, res);
-        return res;
+        return baseGraph.edge(a, b, distance, bothDirections);
     }
 
-    long reverseFlags( long edgePointer, long flags )
+    @Override
+    public final EdgeIteratorState getEdgeIteratorState( int edgeId, int adjNode )
     {
-        return encodingManager.reverseFlags(flags);
+        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
     }
 
-    private void setFlags( long edgePointer, boolean reverse, long flags )
+    @Override
+    public final AllEdgesIterator getAllEdges()
     {
-        if (reverse)
-            flags = reverseFlags(edgePointer, flags);
-
-        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
-
-        if (flagsSizeIsLong)
-            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
+        return baseGraph.getAllEdges();
     }
 
-    protected class SingleEdge extends EdgeIterable
+    @Override
+    public final EdgeExplorer createEdgeExplorer( EdgeFilter filter )
     {
-        public SingleEdge( int edgeId, int nodeId )
-        {
-            super(EdgeFilter.ALL_EDGES);
-            setBaseNode(nodeId);
-            setEdgeId(edgeId);
-            nextEdge = EdgeIterable.NO_EDGE;
-        }
+        return baseGraph.createEdgeExplorer(filter);
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
+    public final EdgeExplorer createEdgeExplorer()
     {
-        return new EdgeIterable(filter);
+        return baseGraph.createEdgeExplorer();
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer()
+    public final Graph copyTo( Graph g )
     {
-        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
+        return baseGraph.copyTo(g);
     }
 
-    protected class EdgeIterable implements EdgeExplorer, EdgeIterator
+    @Override
+    public final GraphExtension getExtension()
     {
-        final EdgeFilter filter;
-        int baseNode;
-        int adjNode;
-        int edgeId;
-        long edgePointer;
-        int nextEdge;
-        boolean reverse;
-
-        public EdgeIterable( EdgeFilter filter )
-        {
-            if (filter == null)
-                throw new IllegalArgumentException("Instead null filter use EdgeFilter.ALL_EDGES");
-
-            this.filter = filter;
-        }
-
-        protected void setEdgeId( int edgeId )
-        {
-            this.nextEdge = this.edgeId = edgeId;
-            this.edgePointer = (long) nextEdge * edgeEntryBytes;
-        }
-
-        @Override
-        public EdgeIterator setBaseNode( int baseNode )
-        {
-            int edge = nodes.getInt((long) baseNode * nodeEntryBytes + N_EDGE_REF);
-            setEdgeId(edge);
-            this.baseNode = baseNode;
-            return this;
-        }
-
-        @Override
-        public final int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public final int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public final boolean next()
-        {
-            int i = 0;
-            boolean foundNext = false;
-            for (; i < MAX_EDGES; i++)
-            {
-                if (nextEdge == EdgeIterator.NO_EDGE)
-                    break;
-
-                edgePointer = (long) nextEdge * edgeEntryBytes;
-                edgeId = nextEdge;
-                adjNode = getOtherNode(baseNode, edgePointer);
-                reverse = baseNode > adjNode;
-
-                // position to next edge                
-                nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
-                if (nextEdge == edgeId)
-                    throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
-                            + ", " + edgePointer + ", " + edgeId);
-
-                foundNext = filter.accept(this);
-                if (foundNext)
-                    break;
-            }
-
-            if (i > MAX_EDGES)
-                throw new IllegalStateException("something went wrong: no end of edge-list found");
-
-            return foundNext;
-        }
-
-        private long getEdgePointer()
-        {
-            return edgePointer;
-        }
-
-        @Override
-        public final double getDistance()
-        {
-            return getDist(edgePointer);
-        }
-
-        @Override
-        public final EdgeIteratorState setDistance( double dist )
-        {
-            edges.setInt(edgePointer + E_DIST, distToInt(dist));
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
-        }
-
-        @Override
-        public final EdgeIteratorState setFlags( long fl )
-        {
-            GraphHopperStorage.this.setFlags(edgePointer, reverse, fl);
-            return this;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.getInt(edgePointer + E_ADDITIONAL);
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            GraphHopperStorage.this.setAdditionalEdgeField(edgePointer, value);
-            return null;
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
-        {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
-            return this;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
-        }
-
-        @Override
-        public final int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public String getName()
-        {
-            int nameIndexRef = edges.getInt(edgePointer + E_NAME);
-            return nameIndex.get(nameIndexRef);
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            long nameIndexRef = nameIndex.put(name);
-            if (nameIndexRef < 0)
-                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
-
-            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
-            return this;
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgeId == nextEdge)
-                throw new IllegalStateException("call next before detaching");
-
-            EdgeIterable iter = new EdgeIterable(filter);
-            iter.setBaseNode(baseNode);
-            iter.setEdgeId(edgeId);
-            iter.next();
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.adjNode = baseNode;
-                iter.baseNode = adjNode;
-            }
-            return iter;
-        }
-
-        @Override
-        public final String toString()
-        {
-            return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return GraphHopperStorage.this.copyProperties(this, edge);
-        }
-    }
-
-    /**
-     * @return to
-     */
-    EdgeIteratorState copyProperties( EdgeIteratorState from, EdgeIteratorState to )
-    {
-        to.setDistance(from.getDistance()).
-                setName(from.getName()).
-                setFlags(from.getFlags()).
-                setWayGeometry(from.fetchWayGeometry(0));
-
-        if (E_ADDITIONAL >= 0)
-            to.setAdditionalField(from.getAdditionalField());
-        return to;
-    }
-
-    public void setAdditionalEdgeField( long edgePointer, int value )
-    {
-        if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
-            edges.setInt(edgePointer + E_ADDITIONAL, value);
-        else
-            throw new AssertionError("This graph does not support an additional edge field.");
-    }
-
-    private void setWayGeometry( PointList pillarNodes, long edgePointer, boolean reverse )
-    {
-        if (pillarNodes != null && !pillarNodes.isEmpty())
-        {
-            if (pillarNodes.getDimension() != nodeAccess.getDimension())
-                throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
-                        + "D for graph which is " + nodeAccess.getDimension() + "D");
-
-            int len = pillarNodes.getSize();
-            int dim = nodeAccess.getDimension();
-            int tmpRef = nextGeoRef(len * dim);
-            edges.setInt(edgePointer + E_GEO, tmpRef);
-            long geoRef = (long) tmpRef * 4;
-            byte[] bytes = new byte[len * dim * 4 + 4];
-            ensureGeometry(geoRef, bytes.length);
-            bitUtil.fromInt(bytes, len, 0);
-            if (reverse)
-                pillarNodes.reverse();
-
-            int tmpOffset = 4;
-            boolean is3D = nodeAccess.is3D();
-            for (int i = 0; i < len; i++)
-            {
-                double lat = pillarNodes.getLatitude(i);
-                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
-                tmpOffset += 4;
-                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
-                tmpOffset += 4;
-
-                if (is3D)
-                {
-                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
-                    tmpOffset += 4;
-                }
-            }
-
-            wayGeometry.setBytes(geoRef, bytes, bytes.length);
-        } else
-        {
-            edges.setInt(edgePointer + E_GEO, 0);
-        }
-    }
-
-    private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
-    {
-        long geoRef = edges.getInt(edgePointer + E_GEO);
-        int count = 0;
-        byte[] bytes = null;
-        if (geoRef > 0)
-        {
-            geoRef *= 4;
-            count = wayGeometry.getInt(geoRef);
-
-            geoRef += 4;
-            bytes = new byte[count * nodeAccess.getDimension() * 4];
-            wayGeometry.getBytes(geoRef, bytes, bytes.length);
-        } else if (mode == 0)
-            return PointList.EMPTY;
-
-        PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
-        if (reverse)
-        {
-            if ((mode & 2) != 0)
-                pillarNodes.add(nodeAccess, adjNode);
-        } else
-        {
-            if ((mode & 1) != 0)
-                pillarNodes.add(nodeAccess, baseNode);
-        }
-
-        int index = 0;
-        for (int i = 0; i < count; i++)
-        {
-            double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));
-            index += 4;
-            double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
-            index += 4;
-            if (nodeAccess.is3D())
-            {
-                pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
-                index += 4;
-            } else
-            {
-                pillarNodes.add(lat, lon);
-            }
-        }
-
-        if (reverse)
-        {
-            if ((mode & 1) != 0)
-                pillarNodes.add(nodeAccess, baseNode);
-            pillarNodes.reverse();
-        } else
-        {
-            if ((mode & 2) != 0)
-                pillarNodes.add(nodeAccess, adjNode);
-        }
-
-        return pillarNodes;
-    }
-
-    @Override
-    public Graph copyTo( Graph g )
-    {
-        if (g.getClass().equals(getClass()))
-        {
-            return _copyTo((GraphHopperStorage) g);
-        } else
-        {
-            return GHUtility.copyTo(this, g);
-        }
-    }
-
-    Graph _copyTo( GraphHopperStorage clonedG )
-    {
-        if (clonedG.edgeEntryBytes != edgeEntryBytes)
-            throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
-
-        if (clonedG.nodeEntryBytes != nodeEntryBytes)
-            throw new IllegalStateException("nodeEntryBytes cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.nodeEntryBytes + " vs " + nodeEntryBytes);
-
-        if (clonedG.nodeAccess.getDimension() != nodeAccess.getDimension())
-            throw new IllegalStateException("dimension cannot be different for cloned graph. "
-                    + "Cloned: " + clonedG.nodeAccess.getDimension() + " vs " + nodeAccess.getDimension());
-
-        // nodes
-        setNodesHeader();
-        nodes.copyTo(clonedG.nodes);
-        clonedG.loadNodesHeader();
-
-        // edges
-        setEdgesHeader();
-        edges.copyTo(clonedG.edges);
-        clonedG.loadEdgesHeader();
-
-        // name
-        nameIndex.copyTo(clonedG.nameIndex);
-
-        // geometry
-        setWayGeometryHeader();
-        wayGeometry.copyTo(clonedG.wayGeometry);
-        clonedG.loadWayGeometryHeader();
-
-        // extStorage
-        extStorage.copyTo(clonedG.extStorage);
-
-        properties.copyTo(clonedG.properties);
-
-        if (removedNodes == null)
-            clonedG.removedNodes = null;
-        else
-            clonedG.removedNodes = removedNodes.copyTo(new GHBitSetImpl());
-
-        clonedG.encodingManager = encodingManager;
-        initialized = true;
-        return clonedG;
-    }
-
-    private GHBitSet getRemovedNodes()
-    {
-        if (removedNodes == null)
-            removedNodes = new GHBitSetImpl((int) (nodes.getCapacity() / 4));
-
-        return removedNodes;
-    }
-
-    @Override
-    public void markNodeRemoved( int index )
-    {
-        getRemovedNodes().add(index);
-    }
-
-    @Override
-    public boolean isNodeRemoved( int index )
-    {
-        return getRemovedNodes().contains(index);
-    }
-
-    @Override
-    public void optimize()
-    {
-        int delNodes = getRemovedNodes().getCardinality();
-        if (delNodes <= 0)
-            return;
-
-        // Deletes only nodes.
-        // It reduces the fragmentation of the node space but introduces new unused edges.
-        inPlaceNodeRemove(delNodes);
-
-        // Reduce memory usage
-        trimToSize();
-    }
-
-    private void trimToSize()
-    {
-        long nodeCap = (long) nodeCount * nodeEntryBytes;
-        nodes.trimTo(nodeCap);
-//        long edgeCap = (long) (edgeCount + 1) * edgeEntrySize;
-//        edges.trimTo(edgeCap * 4);
-    }
-
-    /**
-     * This method disconnects the specified edge from the list of edges of the specified node. It
-     * does not release the freed space to be reused.
-     * <p/>
-     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
-     * of nodes
-     */
-    long internalEdgeDisconnect( int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode )
-    {
-        long edgeToRemovePointer = (long) edgeToRemove * edgeEntryBytes;
-        // an edge is shared across the two nodes even if the edge is not in both directions
-        // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
-        int nextEdgeId = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgeToRemovePointer));
-        if (edgeToUpdatePointer < 0)
-        {
-            nodes.setInt((long) baseNode * nodeEntryBytes, nextEdgeId);
-        } else
-        {
-            // adjNode is different for the edge we want to update with the new link
-            long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
-                    ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
-            edges.setInt(link, nextEdgeId);
-        }
-        return edgeToRemovePointer;
-    }
-
-    private void invalidateEdge( long edgePointer )
-    {
-        edges.setInt(edgePointer + E_NODEA, NO_NODE);
-    }
-
-    /**
-     * This methods disconnects all edges from removed nodes. It does no edge compaction. Then it
-     * moves the last nodes into the deleted nodes, where it needs to update the node ids in every
-     * edge.
-     */
-    private void inPlaceNodeRemove( int removeNodeCount )
-    {
-        // Prepare edge-update of nodes which are connected to deleted nodes        
-        int toMoveNode = getNodes();
-        int itemsToMove = 0;
-
-        // sorted map when we access it via keyAt and valueAt - see below!
-        final SparseIntIntArray oldToNewMap = new SparseIntIntArray(removeNodeCount);
-        GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
-        removedNodes.copyTo(toRemoveSet);
-
-        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
-        // create map of old node ids pointing to new ids        
-        for (int removeNode = removedNodes.next(0);
-                removeNode >= 0;
-                removeNode = removedNodes.next(removeNode + 1))
-        {
-            EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);
-            while (delEdgesIter.next())
-            {
-                toRemoveSet.add(delEdgesIter.getAdjNode());
-            }
-
-            toMoveNode--;
-            for (; toMoveNode >= 0; toMoveNode--)
-            {
-                if (!removedNodes.contains(toMoveNode))
-                    break;
-            }
-
-            if (toMoveNode >= removeNode)
-                oldToNewMap.put(toMoveNode, removeNode);
-
-            itemsToMove++;
-        }
-
-        EdgeIterable adjNodesToDelIter = (EdgeIterable) createEdgeExplorer();
-        // now similar process to disconnectEdges but only for specific nodes
-        // all deleted nodes could be connected to existing. remove the connections
-        for (int removeNode = toRemoveSet.next(0);
-                removeNode >= 0;
-                removeNode = toRemoveSet.next(removeNode + 1))
-        {
-            // remove all edges connected to the deleted nodes
-            adjNodesToDelIter.setBaseNode(removeNode);
-            long prev = EdgeIterator.NO_EDGE;
-            while (adjNodesToDelIter.next())
-            {
-                int nodeId = adjNodesToDelIter.getAdjNode();
-                // already invalidated
-                if (nodeId != NO_NODE && removedNodes.contains(nodeId))
-                {
-                    int edgeToRemove = adjNodesToDelIter.getEdge();
-                    long edgeToRemovePointer = (long) edgeToRemove * edgeEntryBytes;
-                    internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
-                    invalidateEdge(edgeToRemovePointer);
-                } else
-                {
-                    prev = adjNodesToDelIter.getEdgePointer();
-                }
-            }
-        }
-
-        GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);
-        EdgeExplorer movedEdgeExplorer = createEdgeExplorer();
-        // marks connected nodes to rewrite the edges
-        for (int i = 0; i < itemsToMove; i++)
-        {
-            int oldI = oldToNewMap.keyAt(i);
-            EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
-            while (movedEdgeIter.next())
-            {
-                int nodeId = movedEdgeIter.getAdjNode();
-                if (nodeId == NO_NODE)
-                    continue;
-
-                if (removedNodes.contains(nodeId))
-                    throw new IllegalStateException("shouldn't happen the edge to the node "
-                            + nodeId + " should be already deleted. " + oldI);
-
-                toMoveSet.add(nodeId);
-            }
-        }
-
-        // move nodes into deleted nodes
-        for (int i = 0; i < itemsToMove; i++)
-        {
-            int oldI = oldToNewMap.keyAt(i);
-            int newI = oldToNewMap.valueAt(i);
-            long newOffset = (long) newI * nodeEntryBytes;
-            long oldOffset = (long) oldI * nodeEntryBytes;
-            for (long j = 0; j < nodeEntryBytes; j += 4)
-            {
-                nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));
-            }
-        }
-
-        // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement than
-        // a more efficient (?) breadth-first search
-        EdgeIterator iter = getAllEdges();
-        while (iter.next())
-        {
-            int nodeA = iter.getBaseNode();
-            int nodeB = iter.getAdjNode();
-            if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
-                continue;
-
-            // now overwrite exiting edge with new node ids 
-            // also flags and links could have changed due to different node order
-            int updatedA = oldToNewMap.get(nodeA);
-            if (updatedA < 0)
-                updatedA = nodeA;
-
-            int updatedB = oldToNewMap.get(nodeB);
-            if (updatedB < 0)
-                updatedB = nodeB;
-
-            int edge = iter.getEdge();
-            long edgePointer = (long) edge * edgeEntryBytes;
-            int linkA = edges.getInt(getLinkPosInEdgeArea(nodeA, nodeB, edgePointer));
-            int linkB = edges.getInt(getLinkPosInEdgeArea(nodeB, nodeA, edgePointer));
-            long flags = getFlags(edgePointer, false);
-            writeEdge(edge, updatedA, updatedB, linkA, linkB);
-            setFlags(edgePointer, updatedA > updatedB, flags);
-            if (updatedA < updatedB != nodeA < nodeB)
-                setWayGeometry(fetchWayGeometry(edgePointer, true, 0, -1, -1), edgePointer, false);
-        }
-
-        // we do not remove the invalid edges => edgeCount stays the same!
-        nodeCount -= removeNodeCount;
-
-        EdgeExplorer explorer = createEdgeExplorer();
-        // health check
-        if (isTestingEnabled())
-        {
-            iter = getAllEdges();
-            while (iter.next())
-            {
-                int base = iter.getBaseNode();
-                int adj = iter.getAdjNode();
-                String str = iter.getEdge()
-                        + ", r.contains(" + base + "):" + removedNodes.contains(base)
-                        + ", r.contains(" + adj + "):" + removedNodes.contains(adj)
-                        + ", tr.contains(" + base + "):" + toRemoveSet.contains(base)
-                        + ", tr.contains(" + adj + "):" + toRemoveSet.contains(adj)
-                        + ", base:" + base + ", adj:" + adj + ", nodeCount:" + nodeCount;
-                if (adj >= nodeCount)
-                    throw new RuntimeException("Adj.node problem with edge " + str);
-
-                if (base >= nodeCount)
-                    throw new RuntimeException("Base node problem with edge " + str);
-
-                try
-                {
-                    explorer.setBaseNode(adj).toString();
-                } catch (Exception ex)
-                {
-                    org.slf4j.LoggerFactory.getLogger(getClass()).error("adj:" + adj);
-                }
-                try
-                {
-                    explorer.setBaseNode(base).toString();
-                } catch (Exception ex)
-                {
-                    org.slf4j.LoggerFactory.getLogger(getClass()).error("base:" + base);
-                }
-            }
-            // access last node -> no error
-            explorer.setBaseNode(nodeCount - 1).toString();
-        }
-        removedNodes = null;
-    }
-
-    private static boolean isTestingEnabled()
-    {
-        boolean enableIfAssert = false;
-        assert (enableIfAssert = true) : true;
-        return enableIfAssert;
-    }
-
-    @Override
-    public boolean loadExisting()
-    {
-        checkInit();
-        if (nodes.loadExisting())
-        {
-            String acceptStr = "";
-            if (properties.loadExisting())
-            {
-                properties.checkVersions(false);
-                // check encoding for compatiblity
-                acceptStr = properties.get("graph.flagEncoders");
-
-            } else
-                throw new IllegalStateException("cannot load properties. corrupt file or directory? " + dir);
-
-            if (encodingManager == null)
-            {
-                if (acceptStr.isEmpty())
-                    throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
-                            + dir.getLocation());
-
-                int bytesForFlags = 4;
-                if ("8".equals(properties.get("graph.bytesForFlags")))
-                    bytesForFlags = 8;
-                encodingManager = new EncodingManager(acceptStr, bytesForFlags);
-            } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
-            {
-                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
-                        + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
-            }
-
-            String dim = properties.get("graph.dimension");
-            if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
-                throw new IllegalStateException("Configured dimension (" + dim + ") is not equal to dimension of loaded graph (" + nodeAccess.getDimension() + ")");
-
-            String byteOrder = properties.get("graph.byteOrder");
-            if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
-                throw new IllegalStateException("Configured byteOrder (" + dim + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
-
-            if (!edges.loadExisting())
-                throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
-
-            if (!wayGeometry.loadExisting())
-                throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
-
-            if (!nameIndex.loadExisting())
-                throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
-
-            if (!extStorage.loadExisting())
-                throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
-
-            // first define header indices of this storage
-            initStorage();
-
-            // now load some properties from stored data
-            loadNodesHeader();
-            loadEdgesHeader();
-            loadWayGeometryHeader();
-            return true;
-        }
-        return false;
-    }
-
-    protected void initStorage()
-    {
-        edgeEntryIndex = 0;
-        nodeEntryIndex = 0;
-        E_NODEA = nextEdgeEntryIndex(4);
-        E_NODEB = nextEdgeEntryIndex(4);
-        E_LINKA = nextEdgeEntryIndex(4);
-        E_LINKB = nextEdgeEntryIndex(4);
-        E_DIST = nextEdgeEntryIndex(4);
-        this.flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
-        E_FLAGS = nextEdgeEntryIndex(encodingManager.getBytesForFlags());
-        E_GEO = nextEdgeEntryIndex(4);
-        E_NAME = nextEdgeEntryIndex(4);
-        if (extStorage.isRequireEdgeField())
-            E_ADDITIONAL = nextEdgeEntryIndex(4);
-        else
-            E_ADDITIONAL = -1;
-
-        N_EDGE_REF = nextNodeEntryIndex(4);
-        N_LAT = nextNodeEntryIndex(4);
-        N_LON = nextNodeEntryIndex(4);
-        if (nodeAccess.is3D())
-            N_ELE = nextNodeEntryIndex(4);
-        else
-            N_ELE = -1;
-
-        if (extStorage.isRequireNodeField())
-            N_ADDITIONAL = nextNodeEntryIndex(4);
-        else
-            N_ADDITIONAL = -1;
-
-        initNodeAndEdgeEntrySize();
-        initialized = true;
-    }
-
-    protected int loadNodesHeader()
-    {
-        int hash = nodes.getHeader(0);
-        if (hash != stringHashCode(getClass().getName()))
-            throw new IllegalStateException("Cannot load the graph when using instance of "
-                    + getClass().getName() + " and location: " + dir);
-
-        nodeEntryBytes = nodes.getHeader(1 * 4);
-        nodeCount = nodes.getHeader(2 * 4);
-        bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
-        bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
-        bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
-        bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
-
-        if (bounds.hasElevation())
-        {
-            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
-            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
-        }
-
-        return 7;
-    }
-
-    protected int setNodesHeader()
-    {
-        nodes.setHeader(0, stringHashCode(getClass().getName()));
-        nodes.setHeader(1 * 4, nodeEntryBytes);
-        nodes.setHeader(2 * 4, nodeCount);
-        nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
-        nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
-        nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
-        nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
-        if (bounds.hasElevation())
-        {
-            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
-            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
-        }
-
-        return 7;
-    }
-
-    protected int loadEdgesHeader()
-    {
-        edgeEntryBytes = edges.getHeader(0 * 4);
-        edgeCount = edges.getHeader(1 * 4);
-        return 4;
-    }
-
-    protected int setEdgesHeader()
-    {
-        edges.setHeader(0, edgeEntryBytes);
-        edges.setHeader(1 * 4, edgeCount);
-        edges.setHeader(2 * 4, encodingManager.hashCode());
-        edges.setHeader(3 * 4, extStorage.hashCode());
-        return 4;
-    }
-
-    protected int loadWayGeometryHeader()
-    {
-        maxGeoRef = wayGeometry.getHeader(0);
-        return 1;
-    }
-
-    protected int setWayGeometryHeader()
-    {
-        wayGeometry.setHeader(0, maxGeoRef);
-        return 1;
-    }
-
-    @Override
-    public void flush()
-    {
-        setNodesHeader();
-        setEdgesHeader();
-        setWayGeometryHeader();
-
-        properties.flush();
-        wayGeometry.flush();
-        nameIndex.flush();
-        edges.flush();
-        nodes.flush();
-        extStorage.flush();
-    }
-
-    @Override
-    public void close()
-    {
-        properties.close();
-        wayGeometry.close();
-        nameIndex.close();
-        edges.close();
-        nodes.close();
-        extStorage.close();
-    }
-
-    @Override
-    public boolean isClosed()
-    {
-        return nodes.isClosed();
-    }
-
-    @Override
-    public GraphExtension getExtension()
-    {
-        return extStorage;
-    }
-
-    @Override
-    public long getCapacity()
-    {
-        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity() + wayGeometry.getCapacity()
-                + properties.getCapacity() + extStorage.getCapacity();
-    }
-
-    @Override
-    public String toDetailsString()
-    {
-        return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
-                + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
-                + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
-                + "bounds:" + bounds;
-    }
-
-    // workaround for graphhopper-ios https://github.com/google/j2objc/issues/423
-    private int stringHashCode( String str )
-    {
-        try
-        {
-            return java.util.Arrays.hashCode(str.getBytes("UTF-8"));
-        } catch (UnsupportedEncodingException ex)
-        {
-            throw new UnsupportedOperationException(ex);
-        }
-    }
-
-    @Override
-    public String toString()
-    {
-        return getClass().getSimpleName()
-                + "|" + encodingManager
-                + "|" + getDirectory().getDefaultType()
-                + "|" + nodeAccess.getDimension() + "D"
-                + ((extStorage == null) ? "" : "|" + extStorage)
-                + "|" + getProperties().versionsToString();
+        return baseGraph.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage.java b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
index 4a556f3624..466656a4dd 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
@@ -1,11 +1,12 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
  * 
  *       http://www.apache.org/licenses/LICENSE-2.0
  * 
@@ -19,7 +20,7 @@
 
 import com.graphhopper.routing.util.EncodingManager;
 
-public interface GraphStorage extends Graph, Storable<GraphStorage>
+public interface GraphStorage extends Storable<GraphStorage>
 {
     Directory getDirectory();
 
diff --git a/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
new file mode 100644
index 0000000000..824aa60bf3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/InternalGraphEventListener.java
@@ -0,0 +1,28 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+/**
+ * @author Peter Karich
+ */
+public interface InternalGraphEventListener
+{
+    void freeze();
+
+    void initStorage();
+}
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
deleted file mode 100644
index a4f7477a90..0000000000
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.*;
-
-/**
- * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
- * storage to hold the level of a node and a shortcut edge per edge.
- * <p/>
- * @see GraphBuilder
- * @author Peter Karich
- */
-public class LevelGraphStorage extends GraphHopperStorage implements LevelGraph
-{
-    private static final double WEIGHT_FACTOR = 1000f;
-    // 2 bits for access, for now only 32bit => not Long.MAX
-    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
-    private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
-    private int I_SKIP_EDGE1;
-    private int I_SKIP_EDGE2;
-    private int I_LEVEL;
-    // after the last edge only shortcuts are stored
-    private int lastEdgeIndex = -1;
-    private final long scDirMask = PrepareEncoder.getScDirMask();
-    private final Graph baseGraph;
-
-    public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
-    {
-        super(dir, encodingManager, enabled3D);
-        baseGraph = new BaseGraph(this);
-    }
-
-    @Override
-    public boolean isShortcut( int edgeId )
-    {
-        return edgeId > lastEdgeIndex;
-    }
-
-    @Override
-    protected void initStorage()
-    {
-        super.initStorage();
-        I_SKIP_EDGE1 = nextEdgeEntryIndex(4);
-        I_SKIP_EDGE2 = nextEdgeEntryIndex(4);
-        I_LEVEL = nextNodeEntryIndex(4);
-        initNodeAndEdgeEntrySize();
-    }
-
-    @Override
-    public final void setLevel( int nodeIndex, int level )
-    {
-        if (nodeIndex >= getNodes())
-            return;
-
-        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
-    }
-
-    @Override
-    public final int getLevel( int nodeIndex )
-    {
-        // automatically allocate new nodes only via creating edges or setting node properties
-        if (nodeIndex >= getNodes())
-            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
-
-        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
-    }
-
-    @Override
-    public EdgeSkipIterState shortcut( int a, int b )
-    {
-        return createEdge(a, b);
-    }
-
-    @Override
-    public EdgeSkipIterState edge( int a, int b )
-    {
-        if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create edge after first shortcut was created");
-
-        lastEdgeIndex = edgeCount;
-        return createEdge(a, b);
-    }
-
-    private EdgeSkipIterState createEdge( int a, int b )
-    {
-        ensureNodeIndex(Math.max(a, b));
-        int edgeId = internalEdgeAdd(a, b);
-        EdgeSkipIteratorImpl iter = new EdgeSkipIteratorImpl(EdgeFilter.ALL_EDGES);
-        iter.setBaseNode(a);
-        iter.setEdgeId(edgeId);
-        iter.next();
-        iter.setSkippedEdges(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        return iter;
-    }
-
-    @Override
-    public EdgeSkipExplorer createEdgeExplorer()
-    {
-        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
-    }
-
-    @Override
-    public EdgeSkipExplorer createEdgeExplorer( EdgeFilter filter )
-    {
-        return new EdgeSkipIteratorImpl(filter);
-    }
-
-    @Override
-    public LevelGraphStorage create( long nodeCount )
-    {
-        super.create(nodeCount);
-        return this;
-    }
-
-    @Override
-    public final EdgeSkipIterState getEdgeProps( int edgeId, int endNode )
-    {
-        return (EdgeSkipIterState) super.getEdgeProps(edgeId, endNode);
-    }
-
-    class EdgeSkipIteratorImpl extends EdgeIterable implements EdgeSkipExplorer, EdgeSkipIterator
-    {
-        public EdgeSkipIteratorImpl( EdgeFilter filter )
-        {
-            super(filter);
-        }
-
-        @Override
-        public final EdgeSkipIterator setBaseNode( int baseNode )
-        {
-            super.setBaseNode(baseNode);
-            return this;
-        }
-
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2))
-            {
-                throw new IllegalStateException("Skipped edges of a shortcut needs "
-                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
-            }
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgeId > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-
-        @Override
-        public final EdgeIteratorState detach( boolean reverseArg )
-        {
-            if (edgeId == nextEdge)
-                throw new IllegalStateException("call next before detaching");
-            EdgeSkipIteratorImpl iter = new EdgeSkipIteratorImpl(filter);
-            iter.setBaseNode(baseNode);
-            iter.setEdgeId(edgeId);
-            iter.next();
-            if (reverseArg)
-            {
-                iter.reverse = !this.reverse;
-                iter.adjNode = baseNode;
-                iter.baseNode = adjNode;
-            }
-            return iter;
-        }
-
-        @Override
-        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            super.copyPropertiesTo(edge);
-
-//            EdgeSkipIterator eSkip = (EdgeSkipIterator) edge;
-//            setSkippedEdges(eSkip.getSkippedEdge1(), eSkip.getSkippedEdge2());
-            return edge;
-        }
-
-        @Override
-        public String getName()
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call getName on shortcut " + getEdge());
-            return super.getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call setName on shortcut " + getEdge());
-            return super.setName(name);
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call fetchWayGeometry on shortcut " + getEdge());
-            return super.fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            if (isShortcut())
-                throw new IllegalStateException("Cannot call setWayGeometry on shortcut " + getEdge());
-            return super.setWayGeometry(list);
-        }
-    }
-
-    @Override
-    long reverseFlags( long edgePointer, long flags )
-    {
-        boolean isShortcut = edgePointer > (long) lastEdgeIndex * edgeEntryBytes;
-        if (!isShortcut)
-            return super.reverseFlags(edgePointer, flags);
-
-        // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
-        long dir = flags & scDirMask;
-        if (dir == scDirMask || dir == 0)
-            return flags;
-
-        // swap the last bits with this mask
-        return flags ^ scDirMask;
-    }
-
-    /**
-     * Disconnects the edges (higher->lower node) via the specified edgeState pointing from lower to
-     * higher node.
-     * <p>
-     * @param edgeState the edge from lower to higher
-     */
-    public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
-    {
-        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
-        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
-        EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
-        int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        while (tmpIter.next())
-        {
-            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
-            {
-                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
-                break;
-            }
-
-            tmpPrevEdge = tmpIter.getEdge();
-        }
-    }
-
-    @Override
-    public AllEdgesSkipIterator getAllEdges()
-    {
-        return new AllEdgeSkipIterator();
-    }
-
-    class AllEdgeSkipIterator extends AllEdgeIterator implements AllEdgesSkipIterator
-    {
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgePointer / edgeEntryBytes > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-    }
-
-    @Override
-    protected SingleEdge createSingleEdge( int edge, int nodeId )
-    {
-        return new SingleLevelEdge(edge, nodeId);
-    }
-
-    class SingleLevelEdge extends SingleEdge implements EdgeSkipIterState
-    {
-        public SingleLevelEdge( int edge, int nodeId )
-        {
-            super(edge, nodeId);
-        }
-
-        @Override
-        public final void setSkippedEdges( int edge1, int edge2 )
-        {
-            edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
-            edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
-        }
-
-        @Override
-        public final int getSkippedEdge1()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE1);
-        }
-
-        @Override
-        public final int getSkippedEdge2()
-        {
-            return edges.getInt(edgePointer + I_SKIP_EDGE2);
-        }
-
-        @Override
-        public final boolean isShortcut()
-        {
-            return edgeId > lastEdgeIndex;
-        }
-
-        @Override
-        public final EdgeSkipIterState setWeight( double weight )
-        {
-            LevelGraphStorage.this.setWeight(this, weight);
-            return this;
-        }
-
-        @Override
-        public final double getWeight()
-        {
-            return LevelGraphStorage.this.getWeight(this);
-        }
-    }
-
-    final void setWeight( EdgeSkipIterState edge, double weight )
-    {
-        if (!edge.isShortcut())
-            throw new IllegalStateException("setWeight is only available for shortcuts");
-        if (weight < 0)
-            throw new IllegalArgumentException("weight cannot be negative! but was " + weight);
-
-        long weightLong;
-        if (weight > MAX_WEIGHT)
-            weightLong = MAX_WEIGHT_LONG;
-        else
-            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
-
-        long accessFlags = edge.getFlags() & PrepareEncoder.getScDirMask();
-        edge.setFlags(weightLong | accessFlags);
-    }
-
-    final double getWeight( EdgeSkipIterState edge )
-    {
-        if (!edge.isShortcut())
-            throw new IllegalStateException("getWeight is only available for shortcuts");
-
-        double weight = (edge.getFlags() >> 2) / WEIGHT_FACTOR;
-        if (weight >= MAX_WEIGHT)
-            return Double.POSITIVE_INFINITY;
-
-        return weight;
-    }
-
-    @Override
-    protected int loadEdgesHeader()
-    {
-        int next = super.loadEdgesHeader();
-        lastEdgeIndex = edges.getHeader(next * 4);
-        return next + 1;
-    }
-
-    @Override
-    protected int setEdgesHeader()
-    {
-        int next = super.setEdgesHeader();
-        edges.setHeader(next * 4, lastEdgeIndex);
-        return next + 1;
-    }
-
-    @Override
-    public Graph getBaseGraph()
-    {
-        return baseGraph;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
index ca9c118e67..471b1277ac 100644
--- a/core/src/main/java/com/graphhopper/storage/Lock.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -20,7 +20,7 @@
 
 /**
  * A write lock. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface Lock
@@ -32,6 +32,6 @@
     boolean isLocked();
 
     void release();
-    
+
     Exception getObtainFailedReason();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 324168122c..989abf6218 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -32,7 +33,7 @@
 
 /**
  * This is a data structure which uses the operating system to synchronize between disc and memory.
- * Use SynchDAWrapper if you intent to use this from multiple threads!
+ * Use {@link SynchedDAWrapper} if you intent to use this from multiple threads!
  * <p/>
  * @author Peter Karich
  */
@@ -171,7 +172,7 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         ByteBuffer buf = null;
         IOException ioex = null;
         // One retry if it fails. It could fail e.g. if previously buffer wasn't yet unmapped from the jvm
-        for (int trial = 0; trial < 1;)
+        for (int trial = 0; trial < 1; )
         {
             try
             {
@@ -299,7 +300,7 @@ void close( boolean forceClean )
     @Override
     public final void setInt( long bytePos, int value )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         segments.get(bufferIndex).putInt(index, value);
     }
@@ -307,7 +308,7 @@ public final void setInt( long bytePos, int value )
     @Override
     public final int getInt( long bytePos )
     {
-        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int bufferIndex = (int) (bytePos >> segmentSizePower);
         int index = (int) (bytePos & indexDivisor);
         return segments.get(bufferIndex).getInt(index);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
index 5561bfaab3..4b31a627b3 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDirectory.java
@@ -20,8 +20,8 @@
 /**
  * Manages memory mapped DataAccess objects.
  * <p/>
- * @see MMapDataAccess
  * @author Peter Karich
+ * @see MMapDataAccess
  */
 public class MMapDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index 11f6615ac2..d794fa76fc 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -19,6 +19,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -27,7 +28,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class NativeFSLockFactory implements LockFactory
@@ -240,7 +241,7 @@ public static void main( String[] args ) throws IOException
 
         file.createNewFile();
         FileChannel channel = new RandomAccessFile(file, "r").getChannel();
-        
+
         boolean shared = true;
         FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
 
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
index 5221b1fb6b..0c0aaf1580 100644
--- a/core/src/main/java/com/graphhopper/storage/NodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -24,7 +24,7 @@
  * This interface specifies how to access properties of the nodes in the graph. Similar to
  * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
  * for an additional iterator.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public interface NodeAccess extends PointAccess
@@ -38,7 +38,7 @@
 
     /**
      * Sets the additional value at the specified node index
-     * <p>
+     * <p/>
      * @throws AssertionError if, and only if, the extendedStorage does not require an additional
      * node field
      */
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 3fe15fffc0..edad71b985 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -22,6 +22,7 @@
 import java.io.RandomAccessFile;
 import java.nio.ByteOrder;
 import java.util.Arrays;
+
 import org.slf4j.LoggerFactory;
 
 /**
@@ -92,7 +93,7 @@ public RAMDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
index 8bc65dde68..0288e5523d 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDirectory.java
@@ -20,9 +20,9 @@
 /**
  * Manages in-memory DataAccess objects.
  * <p/>
+ * @author Peter Karich
  * @see RAMDataAccess
  * @see RAMIntDataAccess
- * @author Peter Karich
  */
 public class RAMDirectory extends GHDirectory
 {
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index 7d8f66631c..b2598102a5 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -95,7 +95,7 @@ public RAMIntDataAccess create( long bytes )
     }
 
     @Override
-    public boolean ensureCapacity(long bytes)
+    public boolean ensureCapacity( long bytes )
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -266,8 +266,8 @@ public final short getShort( long bytePos )
         if (bytePos % 4 != 0 && bytePos % 4 != 2)
             throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
 
-        long tmpIndex = bytePos >>> 1;
-        int bufferIndex = (int) (tmpIndex >>> segmentSizeIntsPower);
+        long tmpIndex = bytePos >> 1;
+        int bufferIndex = (int) (tmpIndex >> segmentSizeIntsPower);
         int index = (int) (tmpIndex & indexDivisor);
         if (tmpIndex * 2 == bytePos)
             return (short) segments[bufferIndex][index];
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 54182e6f99..e17d8838b4 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -23,7 +23,7 @@
 
 /**
  * Creates a write lock file. Influenced by Lucene code
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class SimpleFSLockFactory implements LockFactory
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 7c8dec0694..c432160712 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -113,7 +114,7 @@ public void close()
     public boolean isClosed()
     {
         return da.isClosed();
-    }        
+    }
 
     @Override
     public StorableProperties create( long size )
@@ -168,6 +169,10 @@ public boolean checkVersions( boolean silent )
         {
             return false;
         }
+
+        // The check for the encoder version is done in EncoderManager, as this class does not know about the
+        // registered encoders and their version
+
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 841974263f..c157818730 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -100,7 +100,7 @@ public synchronized DataAccess create( long bytes )
     }
 
     @Override
-    public synchronized boolean ensureCapacity(long bytes)
+    public synchronized boolean ensureCapacity( long bytes )
     {
         return inner.ensureCapacity(bytes);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index 84f77a6513..11350ae970 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -23,7 +23,7 @@
  * Holds turn cost tables for each node. The additional field of a node will be used to point
  * towards the first entry within a node cost table to identify turn restrictions, or later, turn
  * getCosts.
- * <p>
+ * <p/>
  * @author Karl Hbner
  * @author Peter Karich
  */
@@ -43,8 +43,6 @@
     private int turnCostsEntryIndex = -4;
     private int turnCostsEntryBytes;
     private int turnCostsCount;
-
-    private GraphStorage graph;
     private NodeAccess nodeAccess;
 
     public TurnCostExtension()
@@ -58,14 +56,13 @@ public TurnCostExtension()
     }
 
     @Override
-    public void init( GraphStorage graph )
+    public void init( Graph graph, Directory dir )
     {
         if (turnCostsCount > 0)
             throw new AssertionError("The turn cost storage must be initialized only once.");
 
-        this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turn_costs");
+        this.turnCosts = dir.find("turn_costs");
     }
 
     private int nextTurnCostEntryIndex()
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index 20d112c42b..b0481339a6 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.NotThreadSafe;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -28,11 +29,11 @@
  * This is a data structure which uses an unsafe access to native memory. The speed up compared to
  * RAMDataAccess is roughly 10% due to index calculations and BitUtil overhead in RAMDataAccess.
  * Notes:
- * <p>
+ * <p/>
  * 1. Highly experimental. Still some bugs and access through file/MMAP should work at some point
- * <p>
+ * <p/>
  * 2. Compared to MMAP no syncDAWrapper is need to make it read and write safe from multiple threads
- * <p>
+ * <p/>
  * 3. Cannot be used on Android as no memory allocation methods are available there
  * <p/>
  * @author Peter Karich
@@ -60,7 +61,7 @@
     }
 
     private long address;
-    private long capacity;    
+    private long capacity;
 
     UnsafeDataAccess( String name, String location, ByteOrder order )
     {
@@ -78,7 +79,7 @@ public UnsafeDataAccess create( long bytes )
     }
 
     @Override
-    public final boolean ensureCapacity(long bytes)
+    public final boolean ensureCapacity( long bytes )
     {
         return ensureCapacity(bytes, true);
     }
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index c609eca201..8595d5b49b 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -76,7 +76,7 @@ void writeByte( byte b )
     /**
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
-     * <p>
+     * <p/>
      * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
@@ -95,7 +95,7 @@ public final void writeVLong( long i )
     /**
      * Reads a long stored in variable-length format. Reads between one and nine bytes. Smaller
      * values take fewer bytes. Negative numbers are not supported.
-     * <p>
+     * <p/>
      * The format is described further in DataOutput writeVInt(int) -> Lucene.
      */
     public long readVLong()
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index ec3a4b9011..39550e04c6 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -21,7 +21,7 @@
  * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
  * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
  * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
- * <p>
+ * <p/>
  * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
  * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
  * http://stackoverflow.com/q/24679963/194609
@@ -31,13 +31,13 @@
 public class BresenhamLine
 {
     public static void calcPoints( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                   PointEmitter emitter )
     {
         bresenham(y1, x1, y2, x2, emitter);
     }
 
     public static void voxelTraversal( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                       PointEmitter emitter )
     {
         // edge case
         x1 = fix(x1);
@@ -115,7 +115,7 @@ static final double frac( double val )
     }
 
     public static void bresenham( int y1, int x1, int y2, int x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
@@ -145,7 +145,7 @@ public static void bresenham( int y1, int x1, int y2, int x2,
     }
 
     public static void xiaolinWu( double y1, double x1, double y2, double x2,
-            PointEmitter emitter )
+                                  PointEmitter emitter )
     {
         double dx = x2 - x1;
         double dy = y2 - y1;
@@ -238,10 +238,10 @@ public static void xiaolinWu( double y1, double x1, double y2, double x2,
     }
 
     public static void calcPoints( final double lat1, final double lon1,
-            final double lat2, final double lon2,
-            final PointEmitter emitter,
-            final double offsetLat, final double offsetLon,
-            final double deltaLat, final double deltaLon )
+                                   final double lat2, final double lon2,
+                                   final PointEmitter emitter,
+                                   final double offsetLat, final double offsetLon,
+                                   final double deltaLat, final double deltaLon )
     {
 //        double y1 = (lat1 - offsetLat) / deltaLat;
 //        double x1 = (lon1 - offsetLon) / deltaLon;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 513e17fa7d..879fbf2a01 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -27,7 +27,9 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Arrays;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,10 +38,10 @@
  * implementation is the a very memory efficient representation for areas with lots of node and
  * edges, but lacks precision. No edge distances are measured.
  * <p/>
+ * @author Peter Karich
  * @see LocationIndexTree which is more precise but more complicated and also slightly slower
  * implementation of LocationIndex.
  * <p/>
- * @author Peter Karich
  */
 class Location2IDQuadtree implements LocationIndex
 {
@@ -316,7 +318,7 @@ public int findID( final double lat, final double lon )
 
     @Override
     public QueryResult findClosest( final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter )
+                                    final EdgeFilter edgeFilter )
     {
         if (isClosed())
             throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index b75690f26f..7d4cf03a60 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -50,12 +50,12 @@
      * This method returns the closest QueryResult for the specified location (lat, lon) and only if
      * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
      * search)
-     * <p>
+     * <p/>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
      *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
-     * <p>
+     * <p/>
      * @return An object containing the closest node and edge for the specfied location. The node id
      * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
      * the method QueryResult.isValid will return false.
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index eee2f2f80c..2bd1521585 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -24,7 +24,7 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -33,7 +33,9 @@
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -76,12 +78,11 @@
 
     /**
      * @param g the graph for which this index should do the lookup based on latitude,longitude.
-     * @param dir
      */
     public LocationIndexTree( Graph g, Directory dir )
     {
-        if (g instanceof LevelGraph)
-            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+        if (g instanceof CHGraph)
+            throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
@@ -281,10 +282,10 @@ public boolean loadExisting()
             return false;
 
         if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
+            throw new IllegalStateException("incorrect location index version, expected:" + MAGIC_INT);
 
         if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph: "
+            throw new IllegalStateException("location index was opened with incorrect graph: "
                     + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
 
         setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
@@ -296,7 +297,7 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        dataAccess.setHeader(0, MAGIC_INT);        
+        dataAccess.setHeader(0, MAGIC_INT);
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
 
@@ -341,7 +342,7 @@ public LocationIndex prepareIndex()
 
     int calcChecksum()
     {
-        // do not include the edges as we could get problem with LevelGraph due to shortcuts
+        // do not include the edges as we could get problem with CHGraph due to shortcuts
         // ^ graph.getAllEdges().count();
         return graph.getNodes();
     }
@@ -416,8 +417,8 @@ void prepare()
         }
 
         void addNode( final int nodeA, final int nodeB,
-                final double lat1, final double lon1,
-                final double lat2, final double lon2 )
+                      final double lat1, final double lon1,
+                      final double lat2, final double lon2 )
         {
             PointEmitter pointEmitter = new PointEmitter()
             {
@@ -628,7 +629,7 @@ final long createReverseKey( long key )
     /**
      * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
      * context of a spatial key tile.
-     * <p>
+     * <p/>
      */
     final double calculateRMin( double lat, double lon )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index c371733f82..ac6619af5e 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -31,7 +31,7 @@
  * |
  * T--S----N
  * </pre>
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class QueryResult
@@ -49,7 +49,7 @@
      * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
      * "on-edge" even if it could be 90. To prefer "on-node" you could use e.g. GHPoint.equals with
      * a default precision of 1e-6.
-     * <p>
+     * <p/>
      * @see DistanceCalc#validEdgeDistance
      */
     public static enum Position
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 800bc7c14d..d995c2ee30 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,19 +17,21 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.PI;
 import static java.lang.Math.cos;
 import static java.lang.Math.toRadians;
 
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
- * <p>
+ * <p/>
  * @author Johannes Pelzer
  * @author Peter Karich
  */
 public class AngleCalc
 {
     private final static double PI_4 = Math.PI / 4.0;
+    private final static double PI_2 = Math.PI / 2.0;
     private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
     static final double atan2( double y, double x )
@@ -56,7 +58,7 @@ static final double atan2( double y, double x )
 
     /**
      * Return orientation of line relative to east.
-     * <p>
+     * <p/>
      * @return Orientation in interval -pi to +pi where 0 is east
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
@@ -65,6 +67,21 @@ public double calcOrientation( double lat1, double lon1, double lat2, double lon
         return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
 
+    /**
+     * convert north based clockwise azimuth (0, 360) into x-axis/east based angle (-Pi, Pi)
+     */
+    public double convertAzimuth2xaxisAngle(double azimuth)
+    {
+        if (Double.compare(azimuth, 360)>0 || Double.compare(azimuth, 0)<0)
+        {
+            throw new IllegalArgumentException("Azimuth " + azimuth + " must be in (0, 360)");
+        }
+        double angleXY = PI_2 - azimuth/180.*Math.PI;
+        if (angleXY<-Math.PI) angleXY += 2*Math.PI;
+        if (angleXY>Math.PI) angleXY -= 2*Math.PI;
+        return angleXY;
+    }
+
     /**
      * Change the representation of an orientation, so the difference to the given baseOrientation
      * will be smaller or equal to PI (180 degree). This is achieved by adding or substracting a
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 11957181dd..ef52addc82 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -21,17 +21,17 @@
 
 /**
  * Examples for BIG endianess (default for Java and computer network).
- * <p>
+ * <p/>
  * byte array: 0=>0100 0001 , 1=>1110 1011, 2=>...
- * <p>
+ * <p/>
  * long: highest=>0100 0001 , 1110 1011, ..., lowest=> ...
- * <p>
+ * <p/>
  * bits to string 0100 0001 , 1110 1011, ...
- * <p>
+ * <p/>
  * LITTLE endianess (default for GraphHopper and most microprocessors)
- * <p>
+ * <p/>
  * byte array ..., 6=>1110 1011, 7=>0100 0001
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public abstract class BitUtil
@@ -221,7 +221,7 @@ public String toLastBitString( long value, int bits )
 
     /**
      * Higher order bits comes first in the returned string.
-     * <p>
+     * <p/>
      * @param bits how many bits should be returned.
      */
     public String toBitString( long value, int bits )
@@ -254,7 +254,7 @@ public String toBitString( long value, int bits )
     public final long reverse( long value, int maxBits )
     {
         long res = 0;
-        for (; maxBits > 0; value >>= 1)
+        for (; maxBits > 0; value >>>= 1)
         {
             res <<= 1;
             res |= value & 1;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index e4ac8415d9..55a815cde7 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -44,16 +44,16 @@ public final int toInt( byte[] b, int offset )
     @Override
     public void fromShort( byte[] bytes, short value, int offset )
     {
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
     @Override
     public final void fromInt( byte[] bytes, int value, int offset )
     {
-        bytes[offset + 3] = (byte) (value >> 24);
-        bytes[offset + 2] = (byte) (value >> 16);
-        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset + 3] = (byte) (value >>> 24);
+        bytes[offset + 2] = (byte) (value >>> 16);
+        bytes[offset + 1] = (byte) (value >>> 8);
         bytes[offset] = (byte) (value);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
index c351f01757..b9520d0366 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeExplorer.java
@@ -17,16 +17,16 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 
 /**
- * Support for skipped edge
+ * The edge explorer for CHGraph
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see CHGraph
  */
-public interface EdgeSkipExplorer extends EdgeExplorer
+public interface CHEdgeExplorer extends EdgeExplorer
 {
     @Override
-    EdgeSkipIterator setBaseNode( int baseNode );
+    CHEdgeIterator setBaseNode( int baseNode );
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
similarity index 84%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
index 26a5dfb725..458ba1fc7e 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterator.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIterator.java
@@ -17,14 +17,14 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
 
 /**
- * Support for skipped edge
+ * Support for CH edges
  * <p/>
- * @see LevelGraph
  * @author Peter Karich
+ * @see CHGraph
  */
-public interface EdgeSkipIterator extends EdgeIterator, EdgeSkipIterState
+public interface CHEdgeIterator extends EdgeIterator, CHEdgeIteratorState
 {
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
similarity index 79%
rename from core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
rename to core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
index 2ccdd75207..0aceebb0dc 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
@@ -18,10 +18,16 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.storage.CHGraph;
+
 /**
+ * The state returned from the EdgeIterator of a CHGraph
+ * <p>
  * @author Peter Karich
+ * @see CHGraph
+ * @see CHEdgeIterator
  */
-public interface EdgeSkipIterState extends EdgeIteratorState
+public interface CHEdgeIteratorState extends EdgeIteratorState
 {
     int getSkippedEdge1();
 
@@ -31,7 +37,7 @@
 
     boolean isShortcut();
 
-    EdgeSkipIterState setWeight( double weight );
+    CHEdgeIteratorState setWeight( double weight );
 
     double getWeight();
 }
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 6c4801f816..9109b37719 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -115,7 +115,7 @@ public static CmdArgs read( String[] args )
 
     /**
      * Command line configuration overwrites the ones in the config file.
-     * <p>
+     * <p/>
      * @return a new CmdArgs object if necessary.
      */
     public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 2da8f5e766..af5af167e5 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -15,6 +15,7 @@
 package com.graphhopper.util;
 
 import static com.graphhopper.util.Helper.readFile;
+
 import java.io.InputStreamReader;
 import java.util.List;
 
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index d0ea52f8a4..79c6fd89bf 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -69,12 +69,12 @@
      *  .
      *    a-------b
      * </pre>
-     * <p>
+     * <p/>
      * @return true for case 1 which is "on edge" or the special case of 90 to the edge
      */
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                               double a_lat_deg, double a_lon_deg,
+                               double b_lat_deg, double b_lon_deg );
 
     /**
      * This method calculates the distance from r to edge (a, b) where the crossing point is c
@@ -82,13 +82,13 @@ boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
      * @return the distance in normalized meter
      */
     double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                       double a_lat_deg, double a_lon_deg,
+                                       double b_lat_deg, double b_lon_deg );
 
     /**
      * @return the crossing point c of the vertical line from r to line (a, b)
      */
     GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg );
+                                     double a_lat_deg, double a_lon_deg,
+                                     double b_lat_deg, double b_lon_deg );
 }
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
index d4a2cb35e2..5261e89702 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc3D.java
@@ -32,7 +32,7 @@
      * @param toHeight in meters above 0
      */
     public double calcDist( double fromLat, double fromLon, double fromHeight,
-            double toLat, double toLon, double toHeight )
+                            double toLat, double toLon, double toHeight )
     {
         double len = super.calcDist(fromLat, fromLon, toLat, toLon);
         double delta = Math.abs(toHeight - fromHeight);
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 3502bb7a85..fbcab38d95 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static java.lang.Math.*;
 
 /**
@@ -88,12 +89,6 @@ public double calcCircumference( double lat )
         return 2 * PI * R * cos(toRadians(lat));
     }
 
-    public double calcSpatialKeyMaxDist( int bit )
-    {
-        bit = bit / 2 + 1;
-        return (int) C >> bit;
-    }
-
     public boolean isDateLineCrossOver( double lon1, double lon2 )
     {
         return abs(lon1 - lon2) > 180.0;
@@ -117,21 +112,21 @@ public BBox createBBox( double lat, double lon, double radiusInMeter )
 
     @Override
     public double calcNormalizedEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                              double a_lat_deg, double a_lon_deg,
+                                              double b_lat_deg, double b_lon_deg )
     {
         return calcNormalizedEdgeDistanceNew(r_lat_deg, r_lon_deg, a_lat_deg, a_lon_deg, b_lat_deg, b_lon_deg, false);
     }
 
     /**
      * New edge distance calculation where no validEdgeDistance check would be necessary
-     * <p>
+     * <p/>
      * @return the normalized distance of the query point "r" to the project point "c" onto the line
      * segment a-b
      */
     public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
+                                                 double a_lat_deg, double a_lon_deg,
+                                                 double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
 
@@ -174,8 +169,8 @@ else if (factor < 0)
 
     @Override
     public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                            double a_lat_deg, double a_lon_deg,
+                                            double b_lat_deg, double b_lon_deg )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
@@ -217,8 +212,8 @@ else if (factor < 0)
 
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
-            double a_lat_deg, double a_lon_deg,
-            double b_lat_deg, double b_lon_deg )
+                                      double a_lat_deg, double a_lon_deg,
+                                      double b_lat_deg, double b_lon_deg )
     {
         double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index db35c29f03..5612ac61e8 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -172,5 +172,5 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         return counter;
     }
 
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 297a917ccb..40ba9e0911 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -41,6 +41,7 @@ public void update( long val )
                     }
                 });
     }
+
     private String referrer = "http://graphhopper.com";
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
@@ -63,25 +64,35 @@ public Downloader setReferrer( String referrer )
         return this;
     }
 
-    public InputStream fetch( HttpURLConnection conn ) throws IOException
+    public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
     {
-        // create connection but before reading get the correct inputstream based on the compression
+        // create connection but before reading get the correct inputstream based on the compression and if error
         conn.connect();
-        String encoding = conn.getContentEncoding();
+
         InputStream is;
-        if (encoding != null && encoding.equalsIgnoreCase("gzip"))
-            is = new GZIPInputStream(conn.getInputStream());
-        else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
-            is = new InflaterInputStream(conn.getInputStream(), new Inflater(true));
+        if (readErrorStreamNoException && conn.getResponseCode() >= 400 && conn.getErrorStream() != null)
+            is = conn.getErrorStream();
         else
             is = conn.getInputStream();
 
+        // wrap
+        try
+        {
+            String encoding = conn.getContentEncoding();
+            if (encoding != null && encoding.equalsIgnoreCase("gzip"))
+                is = new GZIPInputStream(is);
+            else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
+                is = new InflaterInputStream(is, new Inflater(true));
+        } catch (IOException ex)
+        {
+        }
+
         return is;
     }
 
     public InputStream fetch( String url ) throws IOException
     {
-        return fetch((HttpURLConnection) createConnection(url));
+        return fetch((HttpURLConnection) createConnection(url), false);
     }
 
     public HttpURLConnection createConnection( String urlStr ) throws IOException
@@ -104,7 +115,7 @@ public HttpURLConnection createConnection( String urlStr ) throws IOException
     public void downloadFile( String url, String toFile ) throws IOException
     {
         HttpURLConnection conn = createConnection(url);
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
         int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
@@ -127,7 +138,7 @@ public void downloadAndUnzip( String url, String toFolder, final ProgressListene
     {
         HttpURLConnection conn = createConnection(url);
         final int length = conn.getContentLength();
-        InputStream iStream = fetch(conn);
+        InputStream iStream = fetch(conn, false);
 
         new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
         {
@@ -136,11 +147,11 @@ public void update( long sumBytes )
             {
                 progressListener.update((int) (100 * sumBytes / length));
             }
-        });
+        });    
     }
 
-    public String downloadAsString( String url ) throws IOException
+    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
     {
-        return Helper.isToString(fetch(url));
+        return Helper.isToString(fetch((HttpURLConnection) createConnection(url), readErrorStreamNoException));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
index 3d6cebd4c2..4718484140 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeExplorer.java
@@ -18,20 +18,21 @@
 package com.graphhopper.util;
 
 /**
- * Class to get EdgeIterator create it via graph.createEdgeExplorer(). Use one instance per thread.
+ * Class to get an EdgeIterator. Create it via graph.createEdgeExplorer() use one instance per
+ * thread.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeIteratorState
- * @author Peter Karich
  */
 public interface EdgeExplorer
 {
     /**
-     * This method sets the base node for iteration through neighboring edges.
+     * This method sets the base node for iteration through neighboring edges (EdgeIteratorStates).
      * <p/>
-     * @return EdgeIterator around specified baseNode. The resulting iterator can be a new instance
-     * or a reused instance returned in a previous call. So be sure you do not use the explorer from
-     * multiple threads or in a nested loop
+     * @return EdgeIterator around the specified baseNode. The resulting iterator can be a new
+     * instance or a reused instance returned in a previous call. So be sure you do not use the
+     * EdgeExplorer from multiple threads or in a nested loop.
      */
     EdgeIterator setBaseNode( int baseNode );
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index a3f2107628..b28b715223 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -33,16 +33,15 @@
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
  *   ...
  * }
- *
+ * @author Peter Karich
  * @see EdgeIteratorState
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIterator extends EdgeIteratorState
 {
     /**
      * To be called to go to the next edge state.
-     * <p>
+     * <p/>
      * @return true if an edge state is available
      */
     boolean next();
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index e790ec8afb..c5a78bbf55 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -20,12 +20,14 @@
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
  * <p/>
+ * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
- * @author Peter Karich
  */
 public interface EdgeIteratorState
 {
+    final static int K_UNFAVORED_EDGE = -1;
+    
     /**
      * @return the edge id of the current edge. Do not make any assumptions about the concrete
      * values, except that for an implemention it is recommended that they'll be contiguous.
@@ -83,6 +85,13 @@
      */
     int getAdditionalField();
 
+    /**
+     * get additional boolean edge information
+     * @param reverse  if property of reverse edge direction should be returned
+     * @param _default default value if key is not found
+     */
+    boolean getBoolean( int key, boolean reverse, boolean _default);
+    
     /**
      * Updates the additional field value for this edge
      */
@@ -94,7 +103,7 @@
 
     /**
      * Clones this EdgeIteratorState.
-     * <p>
+     * <p/>
      * @param reverse if true a detached edgeState with reversed properties is created where base
      * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
      * about why we need the new reverse parameter.
@@ -103,7 +112,7 @@
 
     /**
      * Copies the properties of this edge into the specified edge. Does not change nodes!
-     * <p>
+     * <p/>
      * @return the specified edge e
      */
     EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index dbe2737226..d0dfd27057 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -19,14 +19,15 @@
 
 import com.graphhopper.routing.PathBidir;
 import gnu.trove.map.hash.TIntIntHashMap;
+
 import java.util.Arrays;
 
 /**
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
  * <p/>
- * @see PathBidir
  * @author Peter Karich
+ * @see PathBidir
  */
 @NotThreadSafe
 public class EdgeWrapper
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index a3623be0a3..85f40310e2 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -20,13 +20,13 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.AllEdgesSkipIterator;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -109,7 +109,8 @@ public static int count( EdgeIterator iter )
 
     public static Set<Integer> getNeighbors( EdgeIterator iter )
     {
-        Set<Integer> list = new HashSet<Integer>();
+        // make iteration order over set static => linked
+        Set<Integer> list = new LinkedHashSet<Integer>();
         while (iter.next())
         {
             list.add(iter.getAdjNode());
@@ -129,14 +130,14 @@ public static int count( EdgeIterator iter )
 
     public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
     {
-        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
         while (iter.next())
         {
             String sc = "";
-            if (iter instanceof AllEdgesSkipIterator)
+            if (iter instanceof AllCHEdgesIterator)
             {
-                AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
+                AllCHEdgesIterator aeSkip = (AllCHEdgesIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
             String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
@@ -164,10 +165,10 @@ protected boolean goFurther( int nodeId )
         }.start(g.createEdgeExplorer(), startNode);
     }
 
-    public static String getNodeInfo( LevelGraph g, int nodeId, EdgeFilter filter )
+    public static String getNodeInfo( CHGraph g, int nodeId, EdgeFilter filter )
     {
-        EdgeSkipExplorer ex = g.createEdgeExplorer(filter);
-        EdgeSkipIterator iter = ex.setBaseNode(nodeId);
+        CHEdgeExplorer ex = g.createEdgeExplorer(filter);
+        CHEdgeIterator iter = ex.setBaseNode(nodeId);
         NodeAccess na = g.getNodeAccess();
         String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
         while (iter.next())
@@ -278,7 +279,7 @@ public static Graph copyTo( Graph fromGraph, Graph toGraph )
     {
         AllEdgesIterator eIter = fromGraph.getAllEdges();
         while (eIter.next())
-        {
+        {            
             int base = eIter.getBaseNode();
             int adj = eIter.getAdjNode();
             eIter.copyPropertiesTo(toGraph.edge(base, adj));
@@ -312,45 +313,30 @@ static Directory guessDirectory( GraphStorage store )
         return outdir;
     }
 
-    static GraphStorage guessStorage( Graph g, Directory outdir, EncodingManager encodingManager )
-    {
-        GraphStorage store;
-        boolean is3D = g.getNodeAccess().is3D();
-        if (g instanceof LevelGraphStorage)
-            store = new LevelGraphStorage(outdir, encodingManager, is3D);
-        else
-            store = new GraphHopperStorage(outdir, encodingManager, is3D);
-
-        return store;
-    }
-
     /**
      * Create a new storage from the specified one without copying the data.
      */
-    public static GraphStorage newStorage( GraphStorage store )
+    public static GraphHopperStorage newStorage( GraphHopperStorage store )
     {
-        return guessStorage(store, guessDirectory(store), store.getEncodingManager()).create(store.getNodes());
-    }
+        Directory outdir = guessDirectory(store);
+        boolean is3D = store.getNodeAccess().is3D();
 
-    /**
-     * @return the graph outGraph
-     */
-    public static Graph clone( Graph g, GraphStorage outGraph )
-    {
-        return g.copyTo(outGraph.create(g.getNodes()));
+        return new GraphHopperStorage(store.isCHPossible(), outdir, store.getEncodingManager(),
+                is3D, store.getExtension()).
+                create(store.getNodes());
     }
 
     public static int getAdjNode( Graph g, int edge, int adjNode )
     {
         if (EdgeIterator.Edge.isValid(edge))
         {
-            EdgeIteratorState iterTo = g.getEdgeProps(edge, adjNode);
+            EdgeIteratorState iterTo = g.getEdgeIteratorState(edge, adjNode);
             return iterTo.getAdjNode();
         }
         return adjNode;
     }
 
-    public static class DisabledEdgeIterator implements EdgeSkipIterator
+    public static class DisabledEdgeIterator implements CHEdgeIterator
     {
         @Override
         public EdgeIterator detach( boolean reverse )
@@ -454,6 +440,12 @@ public EdgeIteratorState setName( String name )
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
+        @Override
+        public boolean getBoolean(int key, boolean reverse, boolean _default )
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+        
         @Override
         public int getAdditionalField()
         {
@@ -479,7 +471,7 @@ public double getWeight()
         }
 
         @Override
-        public EdgeSkipIterState setWeight( double weight )
+        public CHEdgeIteratorState setWeight( double weight )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
@@ -520,4 +512,12 @@ public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
     {
         return edgeKey1 / 2 == edgeKey2 / 2;
     }
+
+    /**
+     * Returns the edgeKey of the opposite direction
+     */
+    public static int reverseEdgeKey( int edgeKey )
+    {
+        return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index 7b31ecb262..cad353c103 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -64,7 +64,7 @@ public void setTime( long time )
 
     /**
      * The time relative to the start time in milli seconds.
-     * <p>
+     * <p/>
      * @deprecated use getTime instead
      */
     public long getMillis()
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 5e56078c64..13a6083c62 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,7 @@
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.io.*;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
@@ -31,14 +32,15 @@
 import java.text.NumberFormat;
 import java.util.*;
 import java.util.Map.Entry;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Several utility classes which are compatible with Java6 on Android.
  * <p/>
- * @see Helper7 for none-Android compatible methods.
  * @author Peter Karich
+ * @see Helper7 for none-Android compatible methods.
  */
 public class Helper
 {
@@ -62,6 +64,10 @@
 
     public static Locale getLocale( String param )
     {
+        int pointIndex = param.indexOf('.');
+        if (pointIndex > 0)
+            param = param.substring(0, pointIndex);
+
         param = param.replace("-", "_");
         int index = param.indexOf("_");
         if (index < 0)
@@ -488,6 +494,6 @@ public static final double round4( double value )
 
     public static final double round2( double value )
     {
-        return Math.round(value * 100) / 100;
+        return Math.round(value * 100) / 100d;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index feef36b489..c0f1cd4c48 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -156,11 +156,11 @@ public PointList getPoints()
     /**
      * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     * <p>
+     * <p/>
      * @return the time offset to add for the next instruction
      */
     long fillGPXList( List<GPXEntry> list, long time,
-            Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
+                      Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
     {
         checkOne();
         int len = points.size();
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 23a2bf3146..d4512f0436 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -132,7 +132,7 @@ public String toString()
     /**
      * @return This method returns a list of gpx entries where the time (in millis) is relative to
      * the first which is 0.
-     * <p>
+     * <p/>
      */
     public List<GPXEntry> createGPXList()
     {
@@ -271,7 +271,7 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
-     * <p>
+     * <p/>
      * @param maxDistance the maximum acceptable distance to the instruction (in meter)
      * @return the next Instruction or null if too far away.
      */
@@ -313,6 +313,8 @@ public Instruction find( double lat, double lon, double maxDistance )
                         } else
                         {
                             distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                            if (pointIndex > 0)
+                                index++;
                         }
 
                         if (distance < foundMinDistance)
@@ -321,7 +323,6 @@ public Instruction find( double lat, double lon, double maxDistance )
                             foundInstruction = index;
                         }
                     }
-
                     prevLat = currLat;
                     prevLon = currLon;
                 }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 590c89b2fa..132c98c109 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import java.text.DecimalFormat;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
index 4e3e493706..badbb59dd2 100644
--- a/core/src/main/java/com/graphhopper/util/PMap.java
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -22,7 +22,7 @@
 
 /**
  * A properties map with convenient accessors
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class PMap
@@ -44,6 +44,22 @@ public PMap( Map<String, String> map )
         this.map = map;
     }
 
+    public PMap( String propertiesString )
+    {
+        // five chosen as arbitrary initial capacity
+        this.map = new HashMap<String, String>(5);
+
+        for (String s : propertiesString.split("\\|"))
+        {
+            s = s.trim();
+            int index = s.indexOf("=");
+            if (index < 0)
+                continue;
+
+            this.map.put(s.substring(0, index).toLowerCase(), s.substring(index + 1));
+        }
+    }
+
     public PMap put( String key, Object str )
     {
         if (str == null)
@@ -143,6 +159,14 @@ String get( String key )
         return val;
     }
 
+    /**
+     * This method copies the underlying structur into a new Map object
+     */
+    public Map<String, String> toMap()
+    {
+        return new HashMap<String, String>(map);
+    }
+
     private Map<String, String> getMap()
     {
         return map;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 3dcd61bda7..f06d7640f8 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -20,11 +20,12 @@
 
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.Path;
+
 import java.util.List;
 
 /**
  * This class merges a list of points into one point recognizing the specified places.
- * <p>
+ * <p/>
  * @author Peter Karich
  * @author ratrun
  */
@@ -38,7 +39,6 @@
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
         int origPoints = 0;
-        StopWatch sw;
         long fullTimeInMillis = 0;
         double fullWeight = 0;
         double fullDistance = 0;
@@ -55,7 +55,6 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             if (enableInstructions)
             {
                 InstructionList il = path.calcInstructions(tr);
-                sw = new StopWatch().start();
 
                 if (!il.isEmpty())
                 {
@@ -76,7 +75,6 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                         fullInstructions.add(i);
                         fullPoints.add(i.getPoints());
                     }
-                    sw.stop();
 
                     // if not yet reached finish replace with 'reached via'
                     if (pathIndex + 1 < paths.size())
@@ -96,9 +94,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (simplifyResponse)
                 {
                     origPoints = tmpPoints.getSize();
-                    sw = new StopWatch().start();
                     douglasPeucker.simplify(tmpPoints);
-                    sw.stop();
                 }
                 fullPoints.add(tmpPoints);
             }
@@ -117,7 +113,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
 
         if (!allFound)
         {
-            rsp.addError(new RuntimeException("Not found"));
+            rsp.addError(new RuntimeException("Connection between locations not found"));
         }
 
         rsp.setPoints(fullPoints).
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index 5d3068a599..ee93ad219b 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -42,7 +42,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon );
@@ -50,7 +50,7 @@
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
-     * <p>
+     * <p/>
      * This methods sets the latitude, longitude and elevation to the specified value.
      */
     void setNode( int nodeId, double lat, double lon, double ele );
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index d3ecbf0087..6cca560fee 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -303,14 +304,15 @@ public String toString()
         {
             if (includeElevation)
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)), Helper.round2(getElevation(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)),
+                                Helper.round2(getElevation(i))
+                        });
             else
                 points.add(new Double[]
-                {
-                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
-                });
+                        {
+                                Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
+                        });
         }
         return points;
     }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index 78b759471a..f8b46f5c76 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -68,22 +68,24 @@ public int getExitNumber()
     }
 
     /**
-     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
-     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     * @return radian of angle -2PI &lt; x &lt; 2PI between roundabout entrance and exit values
+     * <ul>
+     * <li>&gt; 0 is for clockwise rotation</li>
+     * <li>&lt; 0 is for counterclockwise rotation</li>
+     * <li>NaN if direction of rotation is unclear</li>
+     * </ul>
      */
-    public double getRadian()
+    public double getTurnAngle()
     {
         if (Math.abs(clockwise) != 1)
-        {
             return Double.NaN;
-        } else
-        {
-            double tmpRadian = Math.PI - clockwise * radian;
-            tmpRadian *= clockwise;
-            return tmpRadian;
-        }
+        else
+            return Math.PI * clockwise - radian;
     }
 
+    /**
+     * The radian value between entrance (in) and exit (out) of this roundabout.
+     */
     public RoundaboutInstruction setRadian( double radian )
     {
         this.radian = radian;
@@ -95,11 +97,9 @@ public RoundaboutInstruction setRadian( double radian )
     {
         Map<String, Object> tmpMap = new HashMap<String, Object>(2);
         tmpMap.put("exit_number", getExitNumber());
-        double radian = getRadian();
-        if (!Double.isNaN(radian))
-        {
-            tmpMap.put("turn_angle", Helper.round(radian, 2));
-        }
+        double tmpAngle = getTurnAngle();
+        if (!Double.isNaN(tmpAngle))
+            tmpMap.put("turn_angle", Helper.round(tmpAngle, 2));
 
         return tmpMap;
 
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index dbe55ede43..9a64df4379 100644
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -24,7 +24,6 @@
  */
 public class StopWatch
 {
-
     private long lastTime;
     private long nanoTime;
     private String name = "";
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 22176b7abc..d4478781c0 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -22,19 +22,18 @@
 import java.util.Map.Entry;
 
 /**
- * A class which manages the translations in-memory. Translations are managed here:
- * https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0
+ * A class which manages the translations in-memory. See here for more information:
+ * ./docs/core/translations.md
  * <p/>
- * See here for more information: ./docs/core/translations.md
- * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es",
-            "fa", "fil", "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru",
-            "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
+    private static final List<String> LOCALES = Arrays.asList("ar", "bg", "ca", "cs_CZ", "de_DE", "el",
+            "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hsb", "hu_HU", "it", "ja",
+            "lt_LT", "ne", "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk",
+            "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
@@ -154,8 +153,23 @@ private void postImportHook()
                 int expectedCount = countOccurence(enEntry.getValue(), "\\%");
                 if (expectedCount != countOccurence(value, "\\%"))
                 {
-                    sb.append(tr.getLocale()).append(" - error in ").append(enEntry.getKey()).append("->").
+                    sb.append(tr.getLocale()).append(" - error in ").
+                            append(enEntry.getKey()).append("->").
                             append(value).append("\n");
+                } else
+                {
+                    // try if formatting works, many times e.g. '%1$' instead of '%1$s'
+                    Object[] strs = new String[expectedCount];
+                    Arrays.fill(strs, "tmp");
+                    try
+                    {
+                        String.format(value, strs);
+                    } catch (Exception ex)
+                    {
+                        sb.append(tr.getLocale()).append(" - error ").append(ex.getMessage()).append("in ").
+                                append(enEntry.getKey()).append("->").
+                                append(value).append("\n");
+                    }
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index 028a21541a..070aaed5a8 100644
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -16,7 +16,6 @@
 package com.graphhopper.util;
 
 /**
- *
  * @author Peter Karich
  */
 public class ViaInstruction extends Instruction
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index d0eb1ebb46..9b6eb95f22 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+
 import java.util.ArrayList;
 import java.util.List;
 
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 5ca18aa337..277a552a77 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -84,9 +84,9 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat
-        };
+                {
+                        lon, lat
+                };
     }
 
     public static GHPoint parse( String str )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
index cab721686c..6db1d59c78 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -77,8 +77,8 @@ public String toString()
     public Double[] toGeoJson()
     {
         return new Double[]
-        {
-            lon, lat, ele
-        };
+                {
+                        lon, lat, ele
+                };
     }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
new file mode 100644
index 0000000000..561fee2dc3
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=
+continue_onto=%1$s   
+turn_left= 
+turn_right= 
+turn_slight_left=  
+turn_slight_right=  
+turn_sharp_left=  
+turn_sharp_right=  
+turn_onto=%1$s  %1$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX 
+web.routeInfo=%1$s  %2$s
+web.locationsNotFound=     
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle= 
+via= 
+finish=
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike= 
+cycleway= 
+way=
+paved=
+unpaved= 
+stopover= %1$s
+roundaboutEnter= 
+roundaboutExit=       %1$s
+roundaboutExitOnto=       %1$s   %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
new file mode 100644
index 0000000000..623d688b84
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=pokraujte
+continue_onto=pokraujte na %1$s
+turn_left=odbote vlevo
+turn_right=odbote vpravo
+turn_slight_left=odbote mrn vpravo
+turn_slight_right=odbote mrn vpravo
+turn_sharp_left=odbote oste doleva
+turn_sharp_right=odbote oste doprava
+turn_onto=%1$s na %2$s
+web.searchButton=Vyhledat
+web.fromHint=Z
+web.viaHint=Pes 
+web.toHint=Do
+web.moreButton=vce
+web.gpxExportButton=Export do GPX
+web.routeInfo=%1$s bude trvat %2$s
+web.locationsNotFound=Navigovn nen dostupn. Pozice nenalezena v tto oblasti.
+web.bike=Kolo
+web.racingbike=Zvodn kolo
+web.mtb=Horsk kolo
+web.car=Automobil
+web.foot=Pky
+web.staticlink=nemnn odkaz
+web.motorcycle=Motocykl
+via=pes 
+finish=Cl!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=silnice
+off_bike=sesednte z kola
+cycleway=cyklotrasa
+way=cesta
+paved=zpevnn
+unpaved=nezpevnn
+stopover=zastvka %1$s
+roundaboutEnter=Vjete na kruhov objezd
+roundaboutExit=Na kruhovm objezdu pouijte %1$s. vjezd
+roundaboutExitOnto=Na kruhovm objezdu pouijte %1$s. vjezd, smrem na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index 487ae279b0..1ce8dc33b2 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -41,5 +41,5 @@ paved=pavimentado
 unpaved=no pavimentado
 stopover=pasando por %1$s
 roundaboutEnter=Entre en la rotonda
-roundaboutExit=En la rotonda, tome la salida %1$s
-roundaboutExitOnto=En la rotonda, tome la salida %1$s hacia %2$s
+roundaboutExit=En la rotonda, tome la %1$s salida
+roundaboutExitOnto=En la rotonda, tome la %1$s salida hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/hsb.txt b/core/src/main/resources/com/graphhopper/util/hsb.txt
new file mode 100644
index 0000000000..eb762719a5
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/hsb.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=runjewon
+continue_onto=runjewon na %1$s
+turn_left=nalwo wotboi
+turn_right=naprawo wotboi
+turn_slight_left=zlochka nalwo wotboi
+turn_slight_right=zlochka naprawo wotboi
+turn_sharp_left=wtrje nalwo wotboi
+turn_sharp_right=wtrje naprawo wotboi
+turn_onto=%1$s na %2$s
+web.searchButton=pytaj
+web.fromHint=wot
+web.viaHint=pez
+web.toHint=do
+web.moreButton=wjac
+web.gpxExportButton=eksport do GPX
+web.routeInfo=za %1$s so trjeba %2$s
+web.locationsNotFound=ara njeje mna. Mstno so w tutej kninje njenamaka.
+web.bike=koleso
+web.racingbike=wubdowanske koleso
+web.mtb=mountainbike
+web.car=awto
+web.foot=pi
+web.staticlink=link
+web.motorcycle=motorske
+via=via
+finish=doj
+hourAbbr=hod.
+dayAbbr=dny
+minAbbr=mje
+kmAbbr=km
+mAbbr=m
+miAbbr=mile
+ftAbbr=ft
+road=drha
+off_bike=ie
+cycleway=kolesowarski pu
+way=pu
+paved=pitwjerdeny
+unpaved=njepitwjerdeny
+stopover=mjezycil %1$s
+roundaboutEnter=do kruneho wobchada zaj
+roundaboutExit=we krunym wobchade %1$s. wujzd wza
+roundaboutExitOnto=we krunym wobchade %1$s. wujzd na %2$s wza
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 08de85884e..cdc1755b1c 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -11,7 +11,7 @@ turn_sharp_right=
 turn_onto=%1$s%2$s
 web.searchButton=
 web.fromHint=
-web.viaHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
 web.gpxExportButton=GPX
diff --git a/core/src/main/resources/com/graphhopper/util/lt_LT.txt b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
new file mode 100644
index 0000000000..aba326b370
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/lt_LT.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tskite
+continue_onto=tskite toliau %1$s
+turn_left=sukite  kair
+turn_right=sukite  dein
+turn_slight_left=laikykite kairiau
+turn_slight_right=laikykite deiniau
+turn_sharp_left=staigiai sukite kairn
+turn_sharp_right=staigiai sukite deinn
+turn_onto=%1$s  %2$s
+web.searchButton=Iekoti
+web.fromHint=Nuo
+web.viaHint=Per
+web.toHint=Iki
+web.moreButton=dar
+web.gpxExportButton=GPX eksportas
+web.routeInfo=%1$s utruksite %2$s
+web.locationsNotFound=Neimanoma sukurti marruto. Nurodyti takai nerasti ioje zonoje.
+web.bike=Dviratis
+web.racingbike=Plentinis dviratis
+web.mtb=MTB dviratis
+web.car=Automobilis
+web.foot=Psiomis
+web.staticlink=Nuoroda
+web.motorcycle=Motociklas
+via=per
+finish=Tikslas pasiektas!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=kelias
+off_bike=nulipkite nuo dviraio
+cycleway=dvirai takas
+way=kelias
+paved=asfaltuotas
+unpaved=gruntinis
+stopover=sustojimas %1$s
+roundaboutEnter=vaiuokite  ied
+roundaboutExit=iede ivaiuokite %1$s ivaiavime
+roundaboutExitOnto=iede ivaiuokite %1$s ivaiavime   %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index 059c334c4a..869f547fc1 100644
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -2,13 +2,13 @@
 
 continue=neem 
 continue_onto=blijf op %1$s
-turn_left=links afbuigen
-turn_right=rechts afbuigen
-turn_slight_left=houd links aan afbuigen
-turn_slight_right=houd rechts aan afbuigen
-turn_sharp_left=ga linksaf afbuigen
-turn_sharp_right=ga rechtsaf afbuigen
-turn_onto=%1$s af naar %2$s
+turn_left=linksaf
+turn_right=rechtsaf
+turn_slight_left=houd links aan
+turn_slight_right=houd rechts aan
+turn_sharp_left=ga linksaf
+turn_sharp_right=ga rechtsaf
+turn_onto=%1$s naar %2$s
 web.searchButton=zoek
 web.fromHint=van
 web.viaHint=via
diff --git a/core/src/main/resources/com/graphhopper/util/pl_PL.txt b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
new file mode 100644
index 0000000000..47b3b4aace
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/pl_PL.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=kontynuuj
+continue_onto=kontynuuj na %1$s
+turn_left=skr w lewo
+turn_right=skr w prawo
+turn_slight_left=skr delikatnie w lewo
+turn_slight_right=skr delikatnie w prawo
+turn_sharp_left=skr ostro w lewo
+turn_sharp_right=skr ostro w prawo
+turn_onto=%1$s na %2$s
+web.searchButton=Szukaj
+web.fromHint=Z
+web.viaHint=Przez
+web.toHint=Do
+web.moreButton=wicej
+web.gpxExportButton=Eksportuj GPX
+web.routeInfo=%1$s zajmie %2$s
+web.locationsNotFound=Nie mona wyznaczy trasy. Lokalizacja(e) nie zostaa(y) znalezione. 
+web.bike=Rower
+web.racingbike=Rower wycigowy
+web.mtb=Rower grski
+web.car=Samochod
+web.foot=Pieszo
+web.staticlink=link
+web.motorcycle=Motocykl
+via=przez
+finish=Jeste u celu!
+hourAbbr=g
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=droga
+off_bike=zejd z roweru
+cycleway=trasa rowerowa
+way=trasa
+paved=utwierdzona
+unpaved=nieutwardzona
+stopover=przystanek %1$s
+roundaboutEnter=Wjed na rondo
+roundaboutExit=Zjed z ronda %1$s zjazdem
+roundaboutExitOnto=Zjed z ronda %1$s zjazdem na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index 9672f19f3f..0854a07ceb 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -41,5 +41,5 @@ paved=pavimentada
 unpaved=no pavimentada
 stopover=parada %1$s
 roundaboutEnter=Entre na rotatria
-roundaboutExit=Na rotatria, saia na %1$ sada
-roundaboutExitOnto=Na rotatria, saia na %1$ saida em direo a %2$s
+roundaboutExit=Na rotatria, saia na %1$s sada
+roundaboutExitOnto=Na rotatria, saia na %1$s saida em direo a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index 1103e54ae1..688050beb8 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -41,5 +41,5 @@ paved=pavimentado
 unpaved=no pavimentada
 stopover=paragem %1$s
 roundaboutEnter=Entre na rotunda
-roundaboutExit=Na rotunda, saia na %1$ sada
-roundaboutExitOnto=Na rotunda, saia na %1$ saida em direo a %2$s
+roundaboutExit=Na rotunda, saia na %1$s sada
+roundaboutExitOnto=Na rotunda, saia na %1$s saida em direo a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index 67e0da87ad..3b59396800 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -41,5 +41,5 @@ paved=pavat
 unpaved=nepavat
 stopover=escala %1$s
 roundaboutEnter=Intrai n giratoriu 
-roundaboutExit=La giratoriu folosii ieirea %1$
-roundaboutExitOnto=La giratoriu folosii ieirea %1$ ctre %2$
+roundaboutExit=La giratoriu folosii ieirea %1$s
+roundaboutExitOnto=La giratoriu folosii ieirea %1$s ctre %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 623154278c..7f6b68021f 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -26,7 +26,7 @@ web.staticlink=nemenn odkaz
 web.motorcycle=Motocykel
 via=cez
 finish=Cie!
-hourAbbr=Horsk bicykel
+hourAbbr=h
 dayAbbr=d
 minAbbr=min
 kmAbbr=km
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index e679159dc2..97b761ae88 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -18,11 +18,16 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHRequestTest
@@ -36,4 +41,71 @@ public void testGetHint()
         // #173 - will throw an error: Integer cannot be cast to Double
         assertEquals(1, instance.getHints().getDouble("something", 2d), 1e1);
     }
+
+    @Test
+    public void testCorrectInit()
+    {
+        double lat0 = 51, lon0 = 1, lat1 = 52, lon1 = 2, lat2 = 53, lon2 = 3;
+
+        ArrayList<GHPoint> points = new ArrayList<GHPoint>(3);
+        points.add(new GHPoint(lat0, lon0));
+        points.add(new GHPoint(lat1, lon1));
+        points.add(new GHPoint(lat2, lon2));
+        List<Double> favoredHeadings = Arrays.asList(3.14, 4.15, Double.NaN);
+        List<Double> emptyHeadings = Arrays.asList(Double.NaN, Double.NaN, Double.NaN);
+
+        GHRequest instance;
+
+        instance = new GHRequest(points, favoredHeadings);
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest(points.get(0), points.get(1), favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1, favoredHeadings.get(0), favoredHeadings.get(1));
+        compareFavoredHeadings(instance, favoredHeadings.subList(0, 2));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+
+        instance = new GHRequest(3).addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        compareFavoredHeadings(instance, favoredHeadings);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+
+        instance = new GHRequest().addPoint(points.get(0), favoredHeadings.get(0)).
+                addPoint(points.get(1), favoredHeadings.get(1)).
+                addPoint(points.get(2), favoredHeadings.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, favoredHeadings);
+
+        // check init without favoredHeadings
+        instance = new GHRequest(points);
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+
+        instance = new GHRequest(points.get(0), points.get(1));
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest(lat0, lon0, lat1, lon1);
+        assertEquals("Points not initialized correct", points.subList(0, 2), instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings.subList(0, 2));
+
+        instance = new GHRequest().addPoint(points.get(0)).addPoint(points.get(1)).addPoint(points.get(2));
+        assertEquals("Points not initialized correct", points, instance.getPoints());
+        compareFavoredHeadings(instance, emptyHeadings);
+    }
+
+    private void compareFavoredHeadings( GHRequest request, List<Double> expected )
+    {
+        for (int ind = 0; ind < expected.size(); ind++)
+        {
+            double favoredHeading = request.getFavoredHeading(ind);
+            assertEquals(ind + " favored Heading does not match" + expected.get(ind) + " vs ." + favoredHeading,
+                    expected.get(ind), favoredHeading, 0.01);
+        }
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/GHResponseTest.java b/core/src/test/java/com/graphhopper/GHResponseTest.java
new file mode 100644
index 0000000000..d303593cd6
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GHResponseTest.java
@@ -0,0 +1,11 @@
+package com.graphhopper;
+
+import junit.framework.TestCase;
+
+public class GHResponseTest extends TestCase
+{
+    public void testToString() throws Exception
+    {
+        assertEquals("nodes:0; ", new GHResponse().toString());
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index fd7d4a3721..0e20dd8cb5 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -18,14 +18,12 @@
 package com.graphhopper;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperAPITest
@@ -35,7 +33,7 @@
     @Test
     public void testLoad()
     {
-        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
         na.setNode(1, 42.1, 10.1);
@@ -68,7 +66,7 @@ public void testLoad()
     @Test
     public void testDisconnected179()
     {
-        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).create();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 42, 10);
         na.setNode(1, 42.1, 10.1);
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index 55db22a928..7e88dd918c 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -20,14 +20,15 @@
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.*;
 
 import java.io.File;
 import java.util.List;
 import java.util.Map;
-import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
@@ -84,7 +85,7 @@ public void testMonacoWithInstructions() throws Exception
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         // identify the number of counts to compare with CH foot route
-        assertEquals(698, hopper.getVisitedSum());
+        assertEquals(698, rsp.getHints().getLong("visited_nodes.sum", 0));
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
 
@@ -189,6 +190,35 @@ public void testMonacoVia()
         assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
     }
 
+    @Test
+    public void testMonacoEnforcedDirection()
+    {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854), 0.).
+                addPoint(new GHPoint(43.744445, 7.429483), 190.).
+                setVehicle(vehicle).setWeighting("fastest");
+        req.getHints().put("heading_penalty", "300");
+        GHResponse rsp = hopper.route(req);
+
+        assertEquals(921., rsp.getDistance(), 10.);
+        assertEquals(38, rsp.getPoints().getSize());
+    }
+
+    @Test
+    public void testMonacoStraightVia()
+    {
+        GHRequest rq = new GHRequest().
+                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.740371, 7.426946)).
+                addPoint(new GHPoint(43.740794, 7.427294)).
+                setVehicle(vehicle).setWeighting("fastest");
+        rq.getHints().put("pass_through", true);
+        GHResponse rsp = hopper.route(rq);
+
+        assertEquals(297, rsp.getDistance(), 5.);
+        assertEquals(27, rsp.getPoints().getSize());
+    }
+
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
@@ -376,7 +406,9 @@ private void executeCHFootRoute()
                 setVehicle(vehicle));
 
         // identify the number of counts to compare with none-CH foot route which had nearly 700 counts
-        assertTrue("Too many nodes visited " + tmpHopper.getVisitedSum(), tmpHopper.getVisitedSum() < 120);
+        long sum = rsp.getHints().getLong("visited_nodes.sum", 0);
+        assertNotEquals(sum, 0);
+        assertTrue("Too many nodes visited " + sum, sum < 120);
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
         tmpHopper.close();
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index fe5e04f20c..0556892190 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -19,25 +19,31 @@
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 import java.io.File;
 import java.io.IOException;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import org.junit.After;
-import org.junit.Test;
+
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperTest
@@ -275,8 +281,8 @@ public void testFootAndCar()
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
-        assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getCount());
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
+        assertEquals(8, instance.getGraphHopperStorage().getAllEdges().getMaxId());
 
         // A to D
         GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
@@ -319,7 +325,7 @@ public void testFailsForWrongConfig() throws IOException
                 put("prepare.chWeighting", "no")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
-        assertEquals(5, instance.getGraph().getNodes());
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
         instance.close();
 
         // different config (flagEncoder list)
@@ -452,8 +458,8 @@ public void testFootOnly()
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
-        assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getCount());
+        assertEquals(2, instance.getGraphHopperStorage().getNodes());
+        assertEquals(2, instance.getGraphHopperStorage().getAllEdges().getMaxId());
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
@@ -529,4 +535,223 @@ public void testVia()
         assertEquals(5, rsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
     }
+
+    @Test
+    public void testGetPathsDirectionEnforcement1()
+    {
+        // Test enforce start direction
+        // Note: This Test does not pass for CH enabled    
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction; expected nodes (9)-5-8-3-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 3, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement2()
+    {
+        // Test enforce start & end direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+
+        // Test enforce south start direction and east end direction ; expected nodes (9)-5-8-1-2-(10)
+        GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end, 90.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+
+        // Test uni-directional case
+        req.setAlgorithm(AlgorithmOptions.DIJKSTRA);
+        response = new GHResponse();
+        paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            9, 5, 8, 1, 2, 10
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement3()
+    {
+        // Test enforce via direction
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-7
+        GHPoint via = new GHPoint(0.0005, 0.001);
+
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via, 0.).addPoint(end);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 5, 6, 7, 11
+        }, paths.get(0).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement4()
+    {
+        // Test straight via routing
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // Via Point betweeen 8-3
+        GHPoint via = new GHPoint(0.0015, 0.001);
+        GHRequest req = new GHRequest().addPoint(start).addPoint(via).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 11
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            11, 8, 1, 2, 9
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement5()
+    {
+        // Test independence of previous enforcement for subsequent pathes
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // Start in middle of edge 4-5 
+        GHPoint start = new GHPoint(0.0015, 0.002);
+        // End at middle of edge 2-3
+        GHPoint end = new GHPoint(0.002, 0.0005);
+        // First go south and than come from west to via-point at 7-6. Then go back over previously punished (11)-4 edge
+        GHPoint via = new GHPoint(0.000, 0.0015);
+        GHRequest req = new GHRequest().addPoint(start, 0.).addPoint(via, 3.14 / 2).addPoint(end);
+        req.getHints().put("pass_through", true);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            10, 4, 3, 8, 7, 9
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            9, 6, 5, 10, 4, 3, 11
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    @Test
+    public void testGetPathsDirectionEnforcement6()
+    {
+        // Test if query results at tower nodes are ignored
+
+        GraphHopper instance = initSquareGraphInstance(false);
+
+        // QueryPoints directly on TowerNodes 
+        GHPoint start = new GHPoint(0, 0);
+        GHPoint via = new GHPoint(0.002, 0.000);
+        GHPoint end = new GHPoint(0.002, 0.002);
+
+        GHRequest req = new GHRequest().addPoint(start, 90.).addPoint(via, 270.).addPoint(end, 270.);
+        GHResponse response = new GHResponse();
+        List<Path> paths = instance.getPaths(req, response);
+        assertArrayEquals(new int[]
+        {
+            0, 1, 2
+        }, paths.get(0).calcNodes().toArray());
+        assertArrayEquals(new int[]
+        {
+            2, 3, 4
+        }, paths.get(1).calcNodes().toArray());
+    }
+
+    private GraphHopper initSquareGraphInstance( boolean withCH )
+    {
+        EncodingManager encodingManager = new EncodingManager("car");
+
+        GraphHopperStorage g = new GraphHopperStorage(withCH, new RAMDirectory(), encodingManager,
+                false, new GraphExtension.NoOpExtension()).
+                create(20);
+
+        //   2---3---4
+        //  /    |    \
+        //  1----8----5
+        //  /    |    /
+        //  0----7---6
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0.000, 0.000);
+        na.setNode(1, 0.001, 0.000);
+        na.setNode(2, 0.002, 0.000);
+        na.setNode(3, 0.002, 0.001);
+        na.setNode(4, 0.002, 0.002);
+        na.setNode(5, 0.001, 0.002);
+        na.setNode(6, 0.000, 0.002);
+        na.setNode(7, 0.000, 0.001);
+        na.setNode(8, 0.001, 0.001);
+
+        g.edge(0, 1, 100, true);
+        g.edge(1, 2, 100, true);
+        g.edge(2, 3, 100, true);
+        g.edge(3, 4, 100, true);
+        g.edge(4, 5, 100, true);
+        g.edge(5, 6, 100, true);
+        g.edge(6, 7, 100, true);
+        g.edge(7, 0, 100, true);
+
+        g.edge(1, 8, 110, true);
+        g.edge(3, 8, 110, true);
+        g.edge(5, 8, 110, true);
+        g.edge(7, 8, 110, true);
+
+        instance = new GraphHopper().
+                setCHEnable(withCH).
+                setCHWeighting("fastest").
+                setEncodingManager(encodingManager);
+        instance.setGraphHopperStorage(g);
+        instance.postProcessing();
+
+        return instance;
+    }
+
+    @Test
+    public void testCustomFactoryForNoneCH()
+    {
+        GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        RoutingAlgorithmFactory af = new RoutingAlgorithmFactorySimple();
+        closableInstance.setAlgorithmFactory(af);
+        closableInstance.importOrLoad();
+
+        assertTrue(af == closableInstance.getAlgorithmFactory());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 4e9b580902..5cc1e82fa4 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
+
 import java.util.PriorityQueue;
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
index 7a319c30c9..cce5484ab6 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractMyBitSetTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractMyBitSetTest
@@ -89,7 +89,7 @@ public void testEnsureCapacity()
         } catch (Throwable ex)
         {
         }
-        bs.ensureCapacity(16);
+        
         bs.add(8);
         bs.add(9);
         assertFalse(bs.contains(6));
diff --git a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
index cf047c82b4..d5904de16f 100644
--- a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BigLongIntMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
index c88cd05eaf..51471ab1e6 100644
--- a/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
+++ b/core/src/test/java/com/graphhopper/coll/BitSetImplTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitSetImplTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 359acc5890..4f13821970 100644
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.coll;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.Random;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CompressedArrayTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
index 14c923e0e6..33f2582f5f 100644
--- a/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHLongIntBTreeTest.java
@@ -20,11 +20,12 @@
 import java.util.LinkedHashSet;
 import java.util.Random;
 import java.util.Set;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHLongIntBTreeTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
index c5d9692d1a..890b0253fb 100644
--- a/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHSortedCollectionTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHSortedCollectionTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
index 3af8c5672e..9a3c8bc4e6 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTBitSetTest.java
@@ -20,7 +20,6 @@
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTBitSetTest extends AbstractMyBitSetTest
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index edf15886b1..f5ea5511d4 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHTreeMapComposedTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
index c63edcfbf5..6f7109aee5 100644
--- a/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntDoubleBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntDoubleBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
index 21ec8aae4e..a755752b45 100644
--- a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.coll;
 
 /**
- *
  * @author Peter Karich
  */
 public class IntIntBinHeapTest extends AbstractBinHeapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
index bf62ab9c80..1acc36741b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDMapTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
index cdb07c9544..fec5f54f3b 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMIDSegmentedMapTest
diff --git a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
index 9643af641b..cb11ee8218 100644
--- a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.coll;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -29,17 +30,17 @@
     public void testBinarySearch()
     {
         long a[] = new long[]
-        {
-            9, 53, 100
-        };
+                {
+                        9, 53, 100
+                };
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 3, 50));
         assertEquals(~2, SparseLongLongArray.binarySearch(a, 0, 3, 55));
         assertEquals(~3, SparseLongLongArray.binarySearch(a, 0, 3, 155));
 
         a = new long[]
-        {
-            9
-        };
+                {
+                        9
+                };
         assertEquals(~0, SparseLongLongArray.binarySearch(a, 0, 1, 5));
         assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 1, 50));
     }
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index 36dfb74cd2..54ec767ac4 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -68,20 +70,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+
     /*
     * Test if different constructors yield same results
      */
     @Test
     public void testInstantiation()
     {
-        double minLon = 0; 
+        double minLon = 0;
         double minLat = 2;
         double maxLat = 6;
         double maxLon = 5;
-        
-        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
-        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
-        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+
+        BBox bounds = new BBox(minLon, maxLon, minLat, maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4, 4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4, 4).setBounds(minLon, maxLon, minLat, maxLat);
         assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
         assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
     }
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index ca681b6bcd..ff4b3eb0b9 100644
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SpatialKeyAlgoTest
@@ -233,9 +233,10 @@ public void testDifferentInitialBounds()
         algo.decode(1, coord);
         assertEquals(1, algo.encode(coord));
     }
-    
+
     @Test
-    public void testEdgeCases() {
+    public void testEdgeCases()
+    {
         double minLon = -1, maxLon = 1.6;
         double minLat = -1, maxLat = 0.5;
         int parts = 4;
diff --git a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
index ec6753870c..f1b7e610e0 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
@@ -19,11 +19,12 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMElementTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
index ff3610c9ae..4218bafe13 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.reader;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMNodeTest
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 7cdfdf5867..413266569d 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static org.junit.Assert.*;
+
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -45,6 +46,7 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.*;
 
 /**
@@ -80,10 +82,11 @@ public void tearDown()
         Helper.removeDir(new File(dir));
     }
 
-    GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
+    GraphHopperStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
     {
-        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
-                is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
+        boolean ch = false;
+        return new GraphHopperStorage(ch, new RAMDirectory(directory, false), encodingManager, is3D,
+                turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoOpExtension());
     }
 
     class GraphHopperTest extends GraphHopper
@@ -103,8 +106,8 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
 
             if (turnCosts)
             {
-                carEncoder = new CarFlagEncoder(5, 5, 3);
-                bikeEncoder = new BikeFlagEncoder(4, 2, 3);
+                carEncoder = new CarFlagEncoder(5, 5, 1);
+                bikeEncoder = new BikeFlagEncoder(4, 2, 1);
             } else
             {
                 carEncoder = new CarFlagEncoder();
@@ -117,7 +120,7 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
         }
 
         @Override
-        protected DataReader createReader( GraphStorage tmpGraph )
+        protected DataReader createReader( GraphHopperStorage tmpGraph )
         {
             return initOSMReader(new OSMReader(tmpGraph));
         }
@@ -125,8 +128,9 @@ protected DataReader createReader( GraphStorage tmpGraph )
         @Override
         protected DataReader importData() throws IOException
         {
-            GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(), getEncodingManager().needsTurnCostsSupport());
-            setGraph(tmpGraph);
+            GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
+                    getEncodingManager().needsTurnCostsSupport());
+            setGraphHopperStorage(tmpGraph);
 
             DataReader osmReader = createReader(tmpGraph);
             try
@@ -137,8 +141,8 @@ protected DataReader importData() throws IOException
                 throw new RuntimeException(e);
             }
             osmReader.readGraph();
-            carOutExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
-            carAllExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
+            carOutExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+            carAllExplorer = getGraphHopperStorage().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
             return osmReader;
         }
     }
@@ -152,7 +156,7 @@ InputStream getResource( String file )
     public void testMain()
     {
         GraphHopper hopper = new GraphHopperTest(file1).importOrLoad();
-        GraphStorage graph = (GraphStorage) hopper.getGraph();
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
 
         assertNotNull(graph.getProperties().get("osmreader.import.date"));
         assertNotEquals("", graph.getProperties().get("osmreader.import.date"));
@@ -209,8 +213,7 @@ public void testMain()
     public void testSort()
     {
         GraphHopper hopper = new GraphHopperTest(file1).setSortGraph(true).importOrLoad();
-        Graph graph = hopper.getGraph();
-        NodeAccess na = graph.getNodeAccess();
+        NodeAccess na = hopper.getGraphHopperStorage().getNodeAccess();
         assertEquals(10, na.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
         assertEquals(51.249, na.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
     }
@@ -221,7 +224,7 @@ public void testWithBounds()
         GraphHopper hopper = new GraphHopperTest(file1)
         {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
+            protected DataReader createReader( GraphHopperStorage tmpGraph )
             {
                 return new OSMReader(tmpGraph)
                 {
@@ -236,7 +239,7 @@ public boolean isInBounds( OSMNode node )
 
         hopper.importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(4, graph.getNodes());
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
@@ -271,7 +274,7 @@ public boolean isInBounds( OSMNode node )
     public void testOneWay()
     {
         GraphHopper hopper = new GraphHopperTest(file2).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52.0);
         int n22 = AbstractGraphStorageTester.getIdOf(graph, 52.133);
@@ -325,7 +328,7 @@ public void cleanUp()
             {
             }
         }.importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n40 = AbstractGraphStorageTester.getIdOf(graph, 54.0);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 55.0);
@@ -354,7 +357,7 @@ public void cleanUp()
             {
             }
         }.importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56.0);
         EdgeIterator iter = carOutExplorer.setBaseNode(n60);
@@ -366,7 +369,7 @@ public void cleanUp()
     public void testWayReferencesNotExistingAdjNode()
     {
         GraphHopper hopper = new GraphHopperTest(file4).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         assertEquals(2, graph.getNodes());
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
@@ -379,7 +382,7 @@ public void testWayReferencesNotExistingAdjNode()
     public void testFoot()
     {
         GraphHopper hopper = new GraphHopperTest(file3).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
 
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 11.1);
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 12);
@@ -402,7 +405,7 @@ public void testFoot()
     public void testNegativeIds()
     {
         GraphHopper hopper = new GraphHopperTest(fileNegIds).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(4, graph.getNodes());
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
@@ -427,7 +430,7 @@ public void testNegativeIds()
     public void testBarriers()
     {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(8, graph.getNodes());
 
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51);
@@ -462,7 +465,7 @@ public void testBarriers()
     public void testBarriersOnTowerNodes()
     {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(8, graph.getNodes());
 
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56);
@@ -484,7 +487,8 @@ public void testBarriersOnTowerNodes()
     public void testRelation()
     {
         EncodingManager manager = new EncodingManager("bike");
-        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager, false)).
+        GraphHopperStorage ghStorage = new GraphHopperStorage(new RAMDirectory(), manager, false);
+        OSMReader reader = new OSMReader(ghStorage).
                 setEncodingManager(manager);
         OSMRelation osmRel = new OSMRelation(1);
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 1, ""));
@@ -515,7 +519,8 @@ public void testTurnRestrictions()
     {
         GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
                 importOrLoad();
-        GraphStorage graph = hopper.getGraph();
+
+        Graph graph = hopper.getGraphHopperStorage();
         assertEquals(15, graph.getNodes());
         assertTrue(graph.getExtension() instanceof TurnCostExtension);
         TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
@@ -601,7 +606,7 @@ public long handleNodeTags( OSMNode node )
             }
         };
         EncodingManager manager = new EncodingManager(encoder);
-        GraphStorage graph = newGraph(dir, manager, false, false);
+        GraphHopperStorage ghStorage = newGraph(dir, manager, false, false);
         final Map<Integer, Double> latMap = new HashMap<Integer, Double>();
         final Map<Integer, Double> lonMap = new HashMap<Integer, Double>();
         latMap.put(1, 1.1d);
@@ -610,7 +615,7 @@ public long handleNodeTags( OSMNode node )
         lonMap.put(1, 1.0d);
         lonMap.put(2, 1.0d);
         final AtomicInteger increased = new AtomicInteger(0);
-        OSMReader osmreader = new OSMReader(graph)
+        OSMReader osmreader = new OSMReader(ghStorage)
         {
             // mock data access
             @Override
@@ -658,7 +663,7 @@ public void testReadEleFromCustomOSM()
         GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
         {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
+            protected DataReader createReader( GraphHopperStorage tmpGraph )
             {
                 return initOSMReader(new OSMReader(tmpGraph)
                 {
@@ -671,7 +676,7 @@ protected double getElevation( OSMNode node )
             }
         }.setElevation(true).importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49);
 
@@ -689,7 +694,7 @@ public void testReadEleFromDataProvider()
         hopper.setElevationProvider(provider);
         hopper.importOrLoad();
 
-        Graph graph = hopper.getGraph();
+        Graph graph = hopper.getGraphHopperStorage();
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 49.501);
         int n30 = AbstractGraphStorageTester.getIdOf(graph, 49.5011);
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49.5001);
@@ -718,11 +723,12 @@ public void testTurnFlagCombination()
         BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
         EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
 
-        OSMReader reader = new OSMReader(new GraphBuilder(manager).create())
+        GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
+        OSMReader reader = new OSMReader(ghStorage)
         {
             @Override
             public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
-                    OSMTurnRelation turnRelation )
+                                                                                       OSMTurnRelation turnRelation )
             {
                 // simulate by returning one turn cost entry directly
                 if (encoder.toString().equalsIgnoreCase("car"))
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index 7c3629cd9e..d9b52e6021 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -23,17 +23,19 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -41,18 +43,18 @@
     @Test
     public void testGetRestrictionAsEntries()
     {
-        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 1);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
-                
+
         osmNodeToInternal.put(3L, 3);
         // edge ids are only stored if they occured before in an OSMRelation
-        internalToOSMEdge.put(3, 3L);        
-        internalToOSMEdge.put(4, 4L);        
+        internalToOSMEdge.put(3, 3L);
+        internalToOSMEdge.put(4, 4L);
 
-        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
-        EdgeBasedRoutingAlgorithmTest.initGraph(graph);
-        OSMReader osmReader = new OSMReader(graph)
+        GraphHopperStorage ghStorage = new GraphBuilder(new EncodingManager(encoder)).create();
+        EdgeBasedRoutingAlgorithmTest.initGraph(ghStorage);
+        OSMReader osmReader = new OSMReader(ghStorage)
         {
 
             @Override
@@ -65,13 +67,13 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
             public long getOsmIdOfInternalEdge( int edgeId )
             {
                 Long l = internalToOSMEdge.get(edgeId);
-                if(l == null)
+                if (l == null)
                     return -1;
                 return l;
             }
         };
 
-        EdgeExplorer edgeExplorer = graph.createEdgeExplorer();
+        EdgeExplorer edgeExplorer = ghStorage.createEdgeExplorer();
 
         // TYPE == ONLY
         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
@@ -84,13 +86,13 @@ public long getOsmIdOfInternalEdge( int edgeId )
         assertEquals(4, entry.edgeFrom);
         assertEquals(6, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
-        
+
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(2, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
-        
-        
+
+
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
         result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
@@ -100,7 +102,7 @@ public long getOsmIdOfInternalEdge( int edgeId )
         entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(3, entry.edgeTo);
-        assertEquals(3, entry.nodeVia);       
+        assertEquals(3, entry.nodeVia);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
index 24ebc4126e..d829052a6b 100644
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
@@ -21,16 +21,20 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
+
 import static com.graphhopper.util.GHUtility.*;
+
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeExplorer;
+
 import java.io.IOException;
 import java.util.zip.GZIPInputStream;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrinctonReaderTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
index e07c32fe02..8a5825bb84 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -18,11 +18,12 @@
  */
 package com.graphhopper.reader.dem;
 
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CGIARProviderTest
@@ -57,4 +58,22 @@ public void testFileName()
         assertEquals("srtm_34_08", instance.getFileName(20, -15));
         assertEquals("srtm_37_02", instance.getFileName(52.1943832, 0.1363176));
     }
+
+    @Test
+    public void testFileNotFound()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        File file = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".gh");
+        File zipFile = new File(instance.getCacheDir(), instance.getFileName(46, -20) + ".zip");
+        file.delete();
+        zipFile.delete();
+        
+        assertEquals(0, instance.getEle(46, -20), 1);
+
+        // file not found => small!
+        assertTrue(file.exists());
+        assertEquals(228, file.length());        
+        file.delete();
+        zipFile.delete();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
index f9adbc5ae3..d56495704f 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -21,10 +21,10 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.RAMDirectory;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class HeightTileTest
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 79631a5a02..30f2439d3a 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -19,15 +19,18 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.storage.DAType;
+
 import java.io.File;
 import java.io.IOException;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class SRTMProviderTest
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index ea30e4233c..288978ecdb 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.ShortestWeighting;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -26,9 +28,15 @@
 
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +49,20 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {
+                                TraversalMode.NODE_BASED
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_1DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR
+                        },
+                        {
+                                TraversalMode.EDGE_BASED_2DIR_UTURN
+                        }
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -57,7 +73,7 @@ public AStarBidirectionTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
@@ -68,4 +84,40 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             }
         };
     }
+
+    @Test
+    public void testInitFromAndTo()
+    {
+        Graph g = createGHStorage(false);
+        g.edge(0, 1, 1, true);
+        updateDistancesFor(g, 0, 0.00, 0.00);
+        updateDistancesFor(g, 1, 0.01, 0.01);
+
+        final AtomicReference<AStar.AStarEdge> fromRef = new AtomicReference<AStar.AStarEdge>();
+        final AtomicReference<AStar.AStarEdge> toRef = new AtomicReference<AStar.AStarEdge>();
+        AStarBidirection astar = new AStarBidirection(g, carEncoder, new ShortestWeighting(), traversalMode)
+        {
+            @Override
+            public void initFrom( int from, double weight )
+            {
+                super.initFrom(from, weight);
+                fromRef.set(currFrom);
+            }
+
+            @Override
+            public void initTo( int to, double weight )
+            {
+                super.initTo(to, weight);
+                toRef.set(currTo);
+            }
+        };
+        astar.initFrom(0, 1);
+        astar.initTo(1, 0.5);
+
+        assertEquals(1, fromRef.get().weightOfVisitedPath, .1);
+        assertEquals(787.3, fromRef.get().weight, .1);
+
+        assertEquals(0.5, toRef.get().weightOfVisitedPath, .1);
+        assertEquals(786.8, toRef.get().weight, .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 92c5a2b0a7..3e3f71d18d 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -26,6 +27,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
  * @author Peter Karich
@@ -40,12 +42,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -56,7 +58,7 @@ public AStarTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 54edf7b16f..dd01d04570 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -24,19 +24,21 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
+
 import java.util.Random;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithmTester
 {
     // problem is: matrix graph is expensive to create to cache it in a static variable
-    private static Graph matrixGraph;
+    private static GraphHopperStorage matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
     protected FlagEncoder carEncoder;
     protected FlagEncoder footEncoder;
@@ -51,33 +53,38 @@ public void setUp()
                 weighting(new ShortestWeighting()).build();
     }
 
-    protected Graph createGraph( EncodingManager em, boolean is3D )
+    protected Graph getGraph( GraphHopperStorage ghStorage )
+    {
+        return ghStorage.getGraph(Graph.class);
+    }
+
+    protected GraphHopperStorage createGHStorage( EncodingManager em, boolean is3D )
     {
         return new GraphBuilder(em).set3D(is3D).create();
     }
 
-    protected Graph createGraph( boolean is3D )
+    protected GraphHopperStorage createGHStorage( boolean is3D )
     {
-        return createGraph(encodingManager, is3D);
+        return AbstractRoutingAlgorithmTester.this.createGHStorage(encodingManager, is3D);
     }
 
-    public RoutingAlgorithm createAlgo( Graph g )
+    protected final RoutingAlgorithm createAlgo( GraphHopperStorage g )
     {
         return createAlgo(g, defaultOpts);
     }
 
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    protected final RoutingAlgorithm createAlgo( GraphHopperStorage ghStorage, AlgorithmOptions opts )
     {
-        return createFactory(g, opts).createAlgo(g, opts);
+        return createFactory(ghStorage, opts).createAlgo(getGraph(ghStorage), opts);
     }
 
-    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
+    public abstract RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
+        GraphHopperStorage ghStorage = createTestStorage();
+        RoutingAlgorithm algo = createAlgo(ghStorage);
         Path p = algo.calcPath(0, 7);
         assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
@@ -86,8 +93,8 @@ public void testCalcShortestPath()
     @Test
     public void testWeightLimit()
     {
-        Graph graph = createTestGraph();
-        RoutingAlgorithm algo = createAlgo(graph);
+        GraphHopperStorage ghStorage = createTestStorage();
+        RoutingAlgorithm algo = createAlgo(ghStorage);
         algo.setWeightLimit(10);
         Path p = algo.calcPath(0, 7);
         assertTrue(algo.getVisitedNodes() < 7);
@@ -98,7 +105,7 @@ public void testWeightLimit()
     @Test
     public void testWeightLimit_issue380()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initGraphWeightLimit(graph);
         RoutingAlgorithm algo = createAlgo(graph);
         algo.setWeightLimit(3);
@@ -117,21 +124,23 @@ public void testWeightLimit_issue380()
     @Test
     public void testCalcFastestPath()
     {
-        Graph graphShortest = createGraph(false);
+        GraphHopperStorage graphShortest = createGHStorage(false);
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
-        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
+        Path p1 = createAlgo(graphShortest, defaultOpts).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
-        Graph graphFastest = createGraph(false);
+        GraphHopperStorage graphFastest = createGHStorage(false);
         initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest,
-                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+                AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build()).
                 calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
-        assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
-        assertEquals(p2.toString(), 111437, p2.getTime());
+        assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
+        assertEquals(p2.toString(), 111442, p2.getMillis());
     }
 
     // 0-1-2-3
@@ -178,9 +187,9 @@ protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     @Test
     public void testCalcFootPath()
     {
-        Graph graphShortest = createGraph(false);
-        initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+        GraphHopperStorage ghStorage = createGHStorage(false);
+        initFootVsCar(ghStorage);
+        Path p1 = createAlgo(ghStorage, AlgorithmOptions.start().flagEncoder(footEncoder).
                 weighting(new ShortestWeighting()).build()).
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
@@ -213,9 +222,9 @@ protected void initFootVsCar( Graph graph )
     }
 
     // see test-graph.svg !
-    protected Graph createTestGraph()
+    protected GraphHopperStorage createTestStorage()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 7, true);
         graph.edge(0, 4, 6, true);
@@ -254,9 +263,13 @@ protected Graph createTestGraph()
     @Test
     public void testNoPathFound()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
+        graph.edge(100, 101);
         assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
+        graph = createGHStorage(false);
+        graph.edge(100, 101);
+
         // two disconnected areas
         graph.edge(0, 1, 7, true);
 
@@ -269,7 +282,7 @@ public void testNoPathFound()
         // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
-        graph = createGraph(false);
+        graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
         assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
@@ -278,8 +291,8 @@ public void testNoPathFound()
     @Test
     public void testWikipediaShortestPath()
     {
-        Graph graph = createWikipediaTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 4);
+        GraphHopperStorage ghStorage = createWikipediaTestGraph();
+        Path p = createAlgo(ghStorage).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -287,16 +300,15 @@ public void testWikipediaShortestPath()
     @Test
     public void testCalcIf1EdgeAway()
     {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(1, 2);
+        Path p = createAlgo(createTestStorage()).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
-    protected Graph createWikipediaTestGraph()
+    protected GraphHopperStorage createWikipediaTestGraph()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 7, true);
         graph.edge(0, 2, 9, true);
         graph.edge(0, 5, 14, true);
@@ -353,10 +365,7 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next())
         {
-            int adj = iter.getAdjNode();
-            double adjLat = na.getLatitude(adj);
-            double adjLon = na.getLongitude(adj);
-            iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
             // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
@@ -364,19 +373,19 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
     @Test
     public void testBidirectional()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+        // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         Path p = createAlgo(graph).calcPath(0, 4);
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
+        // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
-        assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
         p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 10007.7, p.getDistance(), .1);
     }
 
     // 1-2-3-4-5
@@ -387,7 +396,7 @@ public void testBidirectional()
     @Test
     public void testBidirectional2()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
 
         graph.edge(0, 1, 100, true);
         graph.edge(1, 2, 1, true);
@@ -442,7 +451,7 @@ public void testCorrectWeight()
     @Test
     public void testCannotCalculateSP()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
@@ -453,7 +462,7 @@ public void testCannotCalculateSP()
     @Test
     public void testDirectedGraphBug1()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 3, false);
         graph.edge(1, 2, 2.99, false);
 
@@ -470,7 +479,7 @@ public void testDirectedGraphBug1()
     @Test
     public void testDirectedGraphBug2()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
         graph.edge(2, 3, 1, false);
@@ -488,43 +497,43 @@ public void testDirectedGraphBug2()
     @Test
     public void testWithCoordinates()
     {
-        Graph graph = createGraph(false);
-        NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 0, 2);
-        na.setNode(1, 0, 3.5);
-        na.setNode(2, 1, 1);
-        na.setNode(3, 1.5, 2.5);
-        na.setNode(4, 0.5, 4.5);
+        GraphHopperStorage graph = createGHStorage(false);
 
-        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
-        graph.edge(2, 3, 2, true);
-        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(1, 3.5));
+        graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(1.5, 1));
+        graph.edge(2, 3, 2, true).setWayGeometry(Helper.createPointList(0, 1.5));
+        graph.edge(3, 4, 2, true).setWayGeometry(Helper.createPointList(0, 2));
 
-        graph.edge(0, 2, 0.8, true).setWayGeometry(Helper.createPointList(0, 1.6, 0, 0, 1, 0));
+        // duplicate but one is longer
         graph.edge(0, 2, 1.2, true);
-        graph.edge(1, 3, 1.3, true);
+        graph.edge(0, 2, 1.5, true).setWayGeometry(Helper.createPointList(0.5, 0));
+
+        graph.edge(1, 3, 1.3, true).setWayGeometry(Helper.createPointList(0.5, 1.5));
         graph.edge(1, 4, 1, true);
 
+        updateDistancesFor(graph, 0, 1, 0.6);
+        updateDistancesFor(graph, 1, 1, 1.5);
+        updateDistancesFor(graph, 2, 0, 0);
+        updateDistancesFor(graph, 3, 0, 1);
+        updateDistancesFor(graph, 4, 0, 2);
+
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
-        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
+        Path p = prepare.createAlgo(getGraph(graph), opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
-        assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
-        assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
+        assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
-        // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
-        // System.out.println(p.toDetailsString());
+        // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
+        p = prepare.createAlgo(getGraph(graph), opts).calcPath(2, 1);
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
-        assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
-        assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
+        assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
+        assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
 
     @Test
     public void testCalcIfEmptyWay()
     {
-        Graph graph = createTestGraph();
-        Path p = createAlgo(graph).calcPath(0, 0);
+        Path p = createAlgo(createTestStorage()).calcPath(0, 0);
         assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
     }
@@ -532,23 +541,24 @@ public void testCalcIfEmptyWay()
     @Test
     public void testViaEdges_FromEqualsTo()
     {
-        Graph graph = createTestGraph();
+        GraphHopperStorage ghStorage = createTestStorage();
+        Graph graph = getGraph(ghStorage);
         // identical tower nodes
-        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        Path p = calcPathViaQuery_(ghStorage, 0.001, 0.000, 0.001, 0.000);
         assertTrue(p.isFound());
         assertEquals(Helper.createTList(0), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // identical query points on edge
-        p = calcPath(graph, 0, 1, 0, 1);
+        p = calcPath(ghStorage, 0, 1, 0, 1);
         assertTrue(p.isFound());
         assertEquals(Helper.createTList(8), p.calcNodes());
         // assertEquals(1, p.calcPoints().size());
         assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
 
         // very close
-        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        p = calcPathViaQuery_(ghStorage, 0.00092, 0, 0.00091, 0);
         assertEquals(Helper.createTList(8, 9), p.calcNodes());
         assertEquals(p.toString(), 1.11, p.getDistance(), .1);
     }
@@ -556,16 +566,16 @@ public void testViaEdges_FromEqualsTo()
     @Test
     public void testViaEdges_BiGraph()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initBiGraph(graph);
 
         // 0-7 to 4-3        
-        Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
+        Path p = calcPathViaQuery_(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
         assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
-        p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
+        p = calcPathViaQuery_(graph, 0.001, 0.0001, 0.010, 0.0011);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
         assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
@@ -573,8 +583,8 @@ public void testViaEdges_BiGraph()
     @Test
     public void testViaEdges_WithCoordinates()
     {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 2, 3);
+        GraphHopperStorage ghStorage = createTestStorage();
+        Path p = calcPath(ghStorage, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
         assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
@@ -582,7 +592,7 @@ public void testViaEdges_WithCoordinates()
     @Test
     public void testViaEdges_SpecialCases()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         // 0->1\
         // |    2
         // 4<-3/
@@ -599,17 +609,17 @@ public void testViaEdges_SpecialCases()
         updateDistancesFor(graph, 3, 0, 0.0001);
 
         // 0-1 to 3-4
-        Path p = calcPathViaQuery(graph, 0.00010, 0.00001, 0, 0.00009);
+        Path p = calcPathViaQuery_(graph, 0.00010, 0.00001, 0, 0.00009);
         assertEquals(Helper.createTList(6, 1, 2, 3, 5), p.calcNodes());
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
+        p = calcPathViaQuery_(graph, 0.000049, 0.00014, 0.00001, 0.0001);
         assertEquals(Helper.createTList(5, 6), p.calcNodes());
         assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
-        p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
+        p = calcPathViaQuery_(graph, 0.00009, 0.00011, 0.00001, 0.00011);
         assertEquals(p.toString(), Helper.createTList(6, 2, 5), p.calcNodes());
         assertEquals(p.toString(), 12.57, p.getDistance(), .1);
     }
@@ -617,22 +627,22 @@ public void testViaEdges_SpecialCases()
     @Test
     public void testQueryGraphAndFastest()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         initDirectedAndDiffSpeed(graph, carEncoder);
-        Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
+        Path p = calcPathViaQuery_("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
     }
 
     // Problem: for contraction hierarchy we cannot easily select egdes by nodes as some edges are skipped
-    Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+    Path calcPathViaQuery_( GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
     {
-        return calcPathViaQuery("shortest", graph, fromLat, fromLon, toLat, toLon);
+        return calcPathViaQuery_("shortest", ghStorage, fromLat, fromLon, toLat, toLon);
     }
 
-    Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+    Path calcPathViaQuery_( String weighting, GraphHopperStorage ghStorage, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
+        LocationIndex index = new LocationIndexTree(ghStorage, new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
@@ -642,20 +652,20 @@ Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fro
 
         // correct order for CH: in factory do prepare and afterwards wrap in query graph
         AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
-        RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        RoutingAlgorithmFactory factory = createFactory(ghStorage, opts);
+        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage)).lookup(from, to);
         return factory.createAlgo(qGraph, opts).
                 calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
-    Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
+    Path calcPath( GraphHopperStorage ghStorage, int fromNode1, int fromNode2, int toNode1, int toNode2 )
     {
-        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
-        QueryResult from = newQR(graph, fromNode1, fromNode2);
-        QueryResult to = newQR(graph, toNode1, toNode2);
+        // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2                
+        QueryResult from = newQR(ghStorage, fromNode1, fromNode2);
+        QueryResult to = newQR(ghStorage, toNode1, toNode2);
 
-        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        RoutingAlgorithmFactory factory = createFactory(ghStorage, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(getGraph(ghStorage)).lookup(from, to);
         return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
@@ -687,14 +697,17 @@ QueryResult newQR( Graph graph, int node1, int node2 )
     public void testTwoWeightsPerEdge()
     {
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        Graph graph = initEleGraph(createGraph(new EncodingManager(encoder), true));
+        GraphHopperStorage graph = AbstractRoutingAlgorithmTester.this.createGHStorage(new EncodingManager(encoder), true);
+        initEleGraph(graph);
         // force the other path
         GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
-//        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
+        Path p = createAlgo(graph, AlgorithmOptions.start().
+                flagEncoder(encoder).
+                weighting(new FastestWeighting(encoder)).build()).
+                calcPath(0, 10);
         assertEquals(85124371, p.getTime());
         assertEquals(425622, p.getDistance(), 1);
         assertEquals(85124.4, p.getWeight(), 1);
@@ -703,7 +716,7 @@ public void testTwoWeightsPerEdge()
     @Test
     public void test0SpeedButUnblocked_Issue242()
     {
-        Graph graph = createGraph(false);
+        GraphHopperStorage graph = createGHStorage(false);
         long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
 
         graph.edge(0, 1).setFlags(flags).setDistance(10);
@@ -724,7 +737,8 @@ public void test0SpeedButUnblocked_Issue242()
     public void testTwoWeightsPerEdge2()
     {
         // other direction should be different!
-        Graph graph = initEleGraph(createGraph(true));
+        GraphHopperStorage graph = createGHStorage(true);
+        initEleGraph(graph);
         Path p = createAlgo(graph).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
         assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
@@ -733,7 +747,7 @@ public void testTwoWeightsPerEdge2()
             @Override
             public double getMinWeight( double distance )
             {
-                return distance;
+                return 0.8 * distance;
             }
 
             @Override
@@ -760,13 +774,14 @@ else if (adj == 4)
             }
         };
 
-        graph = initEleGraph(createGraph(true));
+        graph = createGHStorage(true);
+        initEleGraph(graph);
         QueryResult from = newQR(graph, 3, 0);
         QueryResult to = newQR(graph, 10, 9);
 
         AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
         RoutingAlgorithmFactory factory = createFactory(graph, opts);
-        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        QueryGraph qGraph = new QueryGraph(getGraph(graph)).lookup(from, to);
         p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(37009621, p.getTime());
@@ -841,23 +856,23 @@ public static Graph initGraphWeightLimit( Graph g )
         return g;
     }
 
-    public Graph getMatrixGraph()
+    public GraphHopperStorage getMatrixGraph()
     {
         return getMatrixAlikeGraph();
     }
 
-    public static Graph getMatrixAlikeGraph()
+    public static GraphHopperStorage getMatrixAlikeGraph()
     {
         if (matrixGraph == null)
             matrixGraph = createMatrixAlikeGraph();
         return matrixGraph;
     }
 
-    private static Graph createMatrixAlikeGraph()
+    private static GraphHopperStorage createMatrixAlikeGraph()
     {
         int WIDTH = 10;
         int HEIGHT = 15;
-        Graph tmpGraph = new GraphBuilder(encodingManager).create();
+        GraphHopperStorage tmpGraph = new GraphBuilder(encodingManager).create();
         int[][] matrix = new int[WIDTH][HEIGHT];
         int counter = 0;
         Random rand = new Random(12);
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 0f67d59627..66423237ab 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -26,9 +27,9 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +42,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -57,7 +58,7 @@ public DijkstraBidirectionRefTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
@@ -66,6 +67,6 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
                 return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        };    
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 4092c96b44..dd1a8b6fd9 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -20,18 +20,21 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -62,7 +65,7 @@ public DijkstraOneToManyTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
@@ -113,7 +116,9 @@ public void testTwoWeightsPerEdge2()
     @Test
     public void testIssue182()
     {
-        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
+        GraphHopperStorage storage = createGHStorage(false);
+        initGraph(storage);
+        RoutingAlgorithm algo = createAlgo(storage);
         Path p = algo.calcPath(0, 8);
         assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
 
@@ -125,7 +130,7 @@ public void testIssue182()
     @Test
     public void testIssue239_and362()
     {
-        Graph g = createGraph(false);
+        GraphHopperStorage g = createGHStorage(false);
         g.edge(0, 1, 1, true);
         g.edge(1, 2, 1, true);
         g.edge(2, 0, 1, true);
@@ -145,7 +150,7 @@ public void testIssue239_and362()
     @Test
     public void testUseCache()
     {
-        RoutingAlgorithm algo = createAlgo(createTestGraph());
+        RoutingAlgorithm algo = createAlgo(createTestStorage());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
@@ -161,7 +166,7 @@ public void testUseCache()
     @Test
     public void testDifferentEdgeFilter()
     {
-        Graph g = new GraphBuilder(encodingManager).levelGraphCreate();
+        GraphHopperStorage g = new GraphBuilder(encodingManager).setCHGraph(true).create();
         g.edge(4, 3, 10, true);
         g.edge(3, 6, 10, true);
 
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index fb8c479901..f1ab5b196a 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -26,9 +27,9 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphHopperStorage;
 
 /**
- *
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
@@ -41,12 +42,12 @@
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { TraversalMode.NODE_BASED },
-            { TraversalMode.EDGE_BASED_1DIR },
-            { TraversalMode.EDGE_BASED_2DIR },
-            { TraversalMode.EDGE_BASED_2DIR_UTURN }
-        });
+                {
+                        {TraversalMode.NODE_BASED},
+                        {TraversalMode.EDGE_BASED_1DIR},
+                        {TraversalMode.EDGE_BASED_2DIR},
+                        {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                });
     }
 
     private final TraversalMode traversalMode;
@@ -57,7 +58,7 @@ public DijkstraTest( TraversalMode tMode )
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts )
     {
         return new RoutingAlgorithmFactory()
         {
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 1bbc864885..05cc670dd8 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -19,16 +19,16 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
 import static com.graphhopper.util.GHUtility.*;
+
 import java.util.Arrays;
 import java.util.Collection;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -56,13 +56,13 @@ EncodingManager createEncodingManager( boolean restrictedOnly )
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
-        {
-            { AlgorithmOptions.DIJKSTRA },
-            { AlgorithmOptions.DIJKSTRA_BI },
-            { AlgorithmOptions.ASTAR },
-            { AlgorithmOptions.ASTAR_BI }
-        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
-        });
+                {
+                        {AlgorithmOptions.DIJKSTRA},
+                        {AlgorithmOptions.DIJKSTRA_BI},
+                        {AlgorithmOptions.ASTAR},
+                        {AlgorithmOptions.ASTAR_BI}
+                        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+                });
     }
 
     private final String algoStr;
@@ -78,7 +78,7 @@ public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
         return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
-    protected GraphStorage createGraph( EncodingManager em )
+    protected GraphHopperStorage createStorage( EncodingManager em )
     {
         return new GraphBuilder(em).create();
     }
@@ -138,7 +138,7 @@ Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double tu
     @Test
     public void testBasicTurnRestriction()
     {
-        GraphStorage g = createGraph(createEncodingManager(true));
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
@@ -168,7 +168,7 @@ public void testBasicTurnRestriction()
     @Test
     public void testUTurns()
     {
-        GraphStorage g = createGraph(createEncodingManager(true));
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
@@ -186,7 +186,7 @@ public void testUTurns()
                 flagEncoder(carEncoder).
                 weighting(createWeighting(carEncoder, tcs, 50)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
-        Path p = createAlgo(g, opts).calcPath(7, 5);        
+        Path p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
@@ -204,7 +204,7 @@ public void testUTurns()
     @Test
     public void testBasicTurnCosts()
     {
-        GraphStorage g = createGraph(createEncodingManager(false));
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         Path p = createAlgo(g, AlgorithmOptions.start().
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 6f0ffc7d6c..caa7680d98 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -24,7 +24,9 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 6b684c5120..6131a25cdc 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -20,19 +20,22 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
+
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
+
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
+
 import java.util.*;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PathTest
@@ -40,7 +43,7 @@
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
     private final EncodingManager mixedEncoders = new EncodingManager(
-            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
+            new CarFlagEncoder(), new FootFlagEncoder(), new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final AngleCalc ac = new AngleCalc();
@@ -49,7 +52,7 @@
     @Test
     public void testFound()
     {
-        GraphStorage g = new GraphBuilder(carManager).create();
+        GraphHopperStorage g = new GraphBuilder(carManager).create();
         Path p = new Path(g, encoder);
         assertFalse(p.isFound());
         assertEquals(0, p.getDistance(), 1e-7);
@@ -61,7 +64,7 @@ public void testFound()
     public void testTime()
     {
         FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
-        GraphStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
+        GraphHopperStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
         Path p = new Path(g, tmpEnc);
         long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
         assertEquals(375 * 60 * 1000, p.calcMillis(100000, flags, false));
@@ -73,7 +76,7 @@ public void testTime()
     @Test
     public void testWayList()
     {
-        GraphStorage g = new GraphBuilder(carManager).create();
+        GraphHopperStorage g = new GraphBuilder(carManager).create();
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0.0, 0.1);
         na.setNode(1, 1.0, 0.1);
@@ -196,7 +199,7 @@ public void testFindInstruction()
         InstructionList il = path.calcInstructions(tr);
         Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
         assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
-        
+
         Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
 
@@ -237,18 +240,18 @@ private RoundaboutGraph()
 
             na.setNode(1, 52.514, 13.348);
             na.setNode(2, 52.514, 13.349);
-            na.setNode(3, 52.5135,13.35);
+            na.setNode(3, 52.5135, 13.35);
             na.setNode(4, 52.514, 13.351);
-            na.setNode(5, 52.5145,13.351);
+            na.setNode(5, 52.5145, 13.351);
             na.setNode(6, 52.513, 13.35);
             na.setNode(7, 52.514, 13.352);
             na.setNode(8, 52.515, 13.351);
             na.setNode(9, 52.513, 13.351);
-          
-           
+
+
             EdgeIteratorState tmpEdge;
             tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-            
+
             // roundabout
             tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
             roundaboutEdges.add(tmpEdge.detach(false));
@@ -267,28 +270,28 @@ private RoundaboutGraph()
 
             tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
             edge3to9 = tmpEdge.detach(false);
-            
+
             setRoundabout(clockwise);
             inverse3to9();
-            
+
         }
-        
-        public void setRoundabout(boolean clockwise)
+
+        public void setRoundabout( boolean clockwise )
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 for (EdgeIteratorState edge : roundaboutEdges)
                 {
                     edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
                     edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
                 }
-            }    
+            }
             this.clockwise = clockwise;
         }
-        
+
         public void inverse3to9()
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to9.getFlags();
                 edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
@@ -297,21 +300,21 @@ public void inverse3to9()
 
         public void inverse3to6()
         {
-            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
             {
                 long flags = edge3to6.getFlags();
                 edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
             }
         }
-        
 
-        private double getAngle(int n1, int n2, int n3, int n4)
+
+        private double getAngle( int n1, int n2, int n3, int n4 )
         {
             double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
             double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
             outOrientation = ac.alignOrientation(inOrientation, outOrientation);
             double delta = (inOrientation - outOrientation);
-            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            delta = clockwise ? (Math.PI + delta) : -1 * (Math.PI - delta);
             return delta;
         }
     }
@@ -322,7 +325,7 @@ private double getAngle(int n1, int n2, int n3, int n4)
     @Test
     public void testCalcInstructionsRoundabout()
     {
-        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
         {
             Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
                     .calcPath(1, 8);
@@ -336,7 +339,7 @@ public void testCalcInstructionsRoundabout()
             // Test Radian
             double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
             RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-            assertEquals(delta, instr.getRadian(), 0.01);
+            assertEquals(delta, instr.getTurnAngle(), 0.01);
 
             // case of continuing a street through a roundabout
             p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
@@ -349,7 +352,7 @@ public void testCalcInstructionsRoundabout()
             // Test Radian
             delta = roundaboutGraph.getAngle(1, 2, 4, 7);
             instr = (RoundaboutInstruction) wayList.get(1);
-            assertEquals(delta, instr.getRadian(), 0.01);
+            assertEquals(delta, instr.getTurnAngle(), 0.01);
         }
     }
 
@@ -363,13 +366,13 @@ public void testCalcInstructionsRoundaboutBegin()
                 .calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
-                                    "Finish!"),
+        assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
                 tmpList);
     }
 
     /**
-     * case with one node being containig already exit 
+     * case with one node being containig already exit
      */
     @Test
     public void testCalcInstructionsRoundaboutDirectExit()
@@ -404,7 +407,7 @@ public void testCalcInstructionsRoundabout2()
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
+        assertEquals(delta, instr.getTurnAngle(), 0.01);
         roundaboutGraph.inverse3to6();
 
     }
@@ -433,9 +436,9 @@ public void testCalcInstructionsRoundaboutIssue353()
 
         na.setNode(1, 52.514, 13.348);
         na.setNode(2, 52.514, 13.349);
-        na.setNode(3, 52.5135,13.35);
+        na.setNode(3, 52.5135, 13.35);
         na.setNode(4, 52.514, 13.351);
-        na.setNode(5, 52.5145,13.351);
+        na.setNode(5, 52.5145, 13.351);
         na.setNode(6, 52.513, 13.35);
         na.setNode(7, 52.514, 13.352);
         na.setNode(8, 52.515, 13.351);
@@ -451,7 +454,7 @@ public void testCalcInstructionsRoundaboutIssue353()
         tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
 
 
-         // roundabout
+        // roundabout
         tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
         tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
         tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
@@ -474,14 +477,12 @@ public void testCalcInstructionsRoundaboutIssue353()
         tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
 
 
-        
-        
         Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
                 .calcPath(6, 11);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
-                                    "Finish!"),
+                        "Finish!"),
                 tmpList);
     }
 
@@ -497,14 +498,14 @@ public void testCalcInstructionsRoundaboutClockwise()
                 .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "Continue onto MainStreet",
+        assertEquals(Arrays.asList("Continue onto MainStreet",
                         "At roundabout, take exit 1 onto 5-8",
                         "Finish!"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
+        assertEquals(delta, instr.getTurnAngle(), 0.01);
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index bf667e82dd..baf847d097 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -20,25 +20,30 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
+
 import static com.graphhopper.storage.index.QueryResult.Position.*;
+
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.map.TIntObjectMap;
+
 import java.util.Arrays;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryGraphTest
 {
     private EncodingManager encodingManager;
     private FlagEncoder carEncoder;
-    private GraphStorage g;
+    private GraphHopperStorage g;
 
     @Before
     public void setUp()
@@ -197,12 +202,12 @@ public void testMultipleVirtualNodes()
         assertEquals(new GHPoint(1, 2.5), pl.toGHPoint(1));
 
         EdgeIteratorState edge = GHUtility.getEdge(queryGraph, 3, 1);
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 3));
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 1));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 1));
 
         edge = GHUtility.getEdge(queryGraph, 3, 0);
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 3));
-        assertNotNull(queryGraph.getEdgeProps(edge.getEdge(), 0));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
+        assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 0));
 
         // snap again => new virtual node on same edge!
         iter = g.createEdgeExplorer().setBaseNode(1);
@@ -415,7 +420,7 @@ public void testGetEdgeProps()
         queryGraph.lookup(Arrays.asList(res1));
         // get virtual edge
         e1 = GHUtility.getEdge(queryGraph, res1.getClosestNode(), 0);
-        EdgeIteratorState e2 = queryGraph.getEdgeProps(e1.getEdge(), Integer.MIN_VALUE);
+        EdgeIteratorState e2 = queryGraph.getEdgeIteratorState(e1.getEdge(), Integer.MIN_VALUE);
         assertEquals(e1.getEdge(), e2.getEdge());
     }
 
@@ -428,7 +433,7 @@ PointList getPoints( Graph g, int base, int adj )
     }
 
     public QueryResult createLocationResult( double lat, double lon,
-            EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
+                                             EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
     {
         if (edge == null)
             throw new IllegalStateException("Specify edge != null");
@@ -508,7 +513,7 @@ public void testTurnCostsProperlyPropagated_Issue282()
         TurnCostExtension turnExt = new TurnCostExtension();
         FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
 
-        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+        GraphHopperStorage graphWithTurnCosts = new GraphHopperStorage(false, new RAMDirectory(),
                 new EncodingManager(encoder), false, turnExt).
                 create(100);
         NodeAccess na = graphWithTurnCosts.getNodeAccess();
@@ -541,4 +546,147 @@ public void testTurnCostsProperlyPropagated_Issue282()
 
         graphWithTurnCosts.close();
     }
+
+    private void initHorseshoeGraph( Graph g )
+    {
+        // setup graph
+        //   ____
+        //  |    |
+        //  |    |
+        //  0    1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 2);
+        g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(2, 0, 2, 2));
+    }
+
+    private QueryResult fakeEdgeQueryResult( EdgeIteratorState edge, double lat, double lon, int wayIndex )
+    {
+        QueryResult qr = new QueryResult(lat, lon);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(wayIndex);
+        qr.setSnappedPosition(EDGE);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+        return qr;
+    }
+
+    private boolean getEdgePreference( QueryGraph queryGraph, int virtualEdgeTypeId, boolean reverse, boolean _default )
+    {
+        boolean edgeUnfavored = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBoolean(
+                EdgeIteratorState.K_UNFAVORED_EDGE, reverse, _default);
+        return edgeUnfavored;
+    }
+
+    @Test
+    public void testEnforceHeading()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going out north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        boolean expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // test cleared edges south
+        expect = false;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, true, !expect));
+
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE_REV, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_BASE, false, !expect));
+
+        // query result on second vertical part of way (downward)
+        qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce going north
+        queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, false, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, true, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        // enforce coming in north
+        queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
+        // test penalized south
+        expect = true;
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ, true, !expect));
+        assertEquals(expect, getEdgePreference(queryGraph, QueryGraph.VE_ADJ_REV, false, !expect));
+    }
+
+    @Test
+    public void testEnforceHeadingByEdgeId()
+    {
+
+        initHorseshoeGraph(g);
+        EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
+
+        // query result on first vertical part of way (upward)
+        QueryResult qr = fakeEdgeQueryResult(edge, 1.5, 0, 0);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(qr));
+
+        // enforce coming in north
+        queryGraph.enforceHeadingByEdgeId(2, 1, false);
+        // test penalized south
+        boolean expect = true;
+        VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, 2);
+
+        VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, incomingEdge.getBaseNode());
+        // expect incoming edge in reverse direction to be unfavored
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+
+        queryGraph.clearUnfavoredStatus();
+        expect = false;
+        assertEquals(expect, incomingEdge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, true, !expect));
+        // expect reverse incoming edge to be unfavored
+        assertEquals(expect, incomingEdgeReverse.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, false, !expect));
+    }
+
+    @Test
+    public void testInternalAPIOriginalTraversalKey()
+    {
+        initGraph(g);
+
+        EdgeExplorer explorer = g.createEdgeExplorer();
+        QueryGraph queryGraph = new QueryGraph(g);
+        EdgeIterator iter = explorer.setBaseNode(1);
+        assertTrue(iter.next());
+        int origEdgeId = iter.getEdge();
+        QueryResult res = createLocationResult(2, 1.5, iter, 1, PILLAR);
+        queryGraph.lookup(Arrays.asList(res));
+
+        assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
+        assertEquals(3, res.getClosestNode());
+
+        EdgeExplorer qGraphExplorer = queryGraph.createEdgeExplorer();
+        iter = qGraphExplorer.setBaseNode(3);
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(1, 0, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 0)).getOriginalTraversalKey());
+
+        assertTrue(iter.next());
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(GHUtility.createEdgeKey(0, 1, origEdgeId, false),
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 1)).getOriginalTraversalKey());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 6252757154..0a61f13e29 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -33,12 +33,15 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -94,6 +97,35 @@ public void testMonaco()
         assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
+    @Test
+    public void testMonacoMotorcycle()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2697, 117));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3749, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 3164, 165));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2423, 141));
+        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2253, 120));
+        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.419333, 0, 1));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-mc-gh",
+                list, "motorcycle", true, "motorcycle", "fastest", true);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testBike2_issue432()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(52.349969, 8.013813, 52.349713, 8.013293, 56, 7));
+        // reverse route avoids the location
+//        list.add(new OneRun(52.349713, 8.013293, 52.349969, 8.013813, 293, 21));
+        runAlgo(testCollector, "files/map-bug432.osm.gz", "target/map-bug432-gh",
+                list, "bike2", true, "bike2", "fastest", true);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoAllAlgorithmsWithBaseGraph()
     {
@@ -116,17 +148,17 @@ public void testMonacoAllAlgorithmsWithBaseGraph()
         FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
         Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
 
-        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraphHopperStorage(), hopper.getLocationIndex(),
                 encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
         AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
-        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
-            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+        if (!(chPrepare.getQueryGraph() instanceof CHGraph))
+            throw new IllegalStateException("Last prepared QueryGraph has to be a CHGraph");
 
         // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
-        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        Graph baseGraphOfCHPrepared = chPrepare.getBaseGraph();
         for (AlgoHelperEntry ahe : prepares)
         {
-            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            if (!(ahe.getQueryGraph() instanceof CHGraph))
             {
                 ahe.setQueryGraph(baseGraphOfCHPrepared);
             }
@@ -276,7 +308,7 @@ public void testNorthBayreuthFootFastestAnd3D()
         // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
         list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
         // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach'
-        list.add(new OneRun(49.986111, 11.550407, 50.023182, 11.555386, 5165, 133));
+        list.add(new OneRun(49.986111, 11.550407, 50.023182, 11.555386, 6429, 122));
         runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
                 list, "FOOT", true, "FOOT", "fastest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
@@ -490,8 +522,8 @@ public void testNeudrossenfeld()
      * takes a bit longer
      */
     Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
-            String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
+                   String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
+                   boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
         AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
@@ -516,8 +548,8 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
             Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
-                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraphHopperStorage(),
+                    hopper.getLocationIndex(), encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
             for (AlgoHelperEntry entry : prepares)
             {
@@ -531,7 +563,7 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
                 }
             }
 
-            return hopper.getGraph();
+            return hopper.getGraphHopperStorage();
         } catch (Exception ex)
         {
             if (algoEntry == null)
@@ -554,7 +586,7 @@ public void testPerformance() throws IOException
         Random rand = new Random(0);
         EncodingManager eManager = new EncodingManager("CAR");
         FlagEncoder encoder = eManager.getEncoder("CAR");
-        Graph graph = new GraphBuilder(eManager).create();
+        GraphHopperStorage graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
         new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
@@ -601,7 +633,7 @@ public void testMonacoParallel() throws IOException
                 setOSMFile("files/monaco.osm.gz").
                 setGraphHopperLocation(graphFile).
                 importOrLoad();
-        final Graph g = hopper.getGraph();
+        final Graph g = hopper.getGraphHopperStorage();
         final LocationIndex idx = hopper.getLocationIndex();
         final List<OneRun> instances = createMonacoCar();
         List<Thread> threads = new ArrayList<Thread>();
@@ -633,7 +665,7 @@ public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
                             AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
-                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                            testCollector.assertDistance(new AlgoHelperEntry(g, g, opts, idx),
                                     oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
@@ -660,30 +692,35 @@ public void run()
         hopper.close();
     }
 
-    static List<AlgoHelperEntry> createAlgos( Graph g,
-            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
-            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+    static List<AlgoHelperEntry> createAlgos( GraphHopperStorage ghStorage,
+                                              LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+                                              final TraversalMode tMode, final Weighting weighting, 
+                                              final EncodingManager manager )
     {
         List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
         // later: include dijkstraOneToMany        
-        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
 
         final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
         astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
         final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
-        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
-        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(ghStorage, ghStorage, dijkstrabiOpts, idx));
 
         if (withCh)
         {
-            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
-                    graphCH, encoder, weighting, tMode);
+            GraphHopperStorage storageCopy = new GraphBuilder(manager).
+                    set3D(ghStorage.getNodeAccess().is3D()).setCHGraph(true).
+                    create();
+            ghStorage.copyTo(storageCopy);            
+            storageCopy.freeze();
+            final CHGraph graphCH = storageCopy.getGraph(CHGraph.class);
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(
+                    new GHDirectory("", DAType.RAM_INT), storageCopy, graphCH, encoder, weighting, tMode);
             prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
-            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            LocationIndex idxCH = new LocationIndexTree(storageCopy, new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, dijkstrabiOpts, idxCH)
             {
                 @Override
                 public RoutingAlgorithm createAlgo( Graph qGraph )
@@ -692,7 +729,7 @@ public RoutingAlgorithm createAlgo( Graph qGraph )
                 }
             });
 
-            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            prepare.add(new AlgoHelperEntry(graphCH, storageCopy, astarbiOpts, idxCH)
             {
                 @Override
                 public RoutingAlgorithm createAlgo( Graph qGraph )
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 44779975c4..4cc427a10e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -21,9 +21,11 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.Helper;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -35,40 +37,41 @@
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
     // matrix graph is expensive to create and to prepare!
-    private static Graph preparedMatrixGraph;
+    private static GraphHopperStorage preparedMatrixGraph;
 
     @Override
-    public Graph getMatrixGraph()
+    public GraphHopperStorage getMatrixGraph()
     {
         if (preparedMatrixGraph == null)
         {
-            LevelGraph lg = (LevelGraph) createGraph(false);
-            getMatrixAlikeGraph().copyTo(lg);
-            createFactory(lg, defaultOpts);
-            preparedMatrixGraph = lg;
+            GraphHopperStorage ghStorage = createGHStorage(false);
+            getMatrixAlikeGraph().copyTo(ghStorage);
+            createFactory(ghStorage, defaultOpts);
+            preparedMatrixGraph = ghStorage;
         }
         return preparedMatrixGraph;
     }
 
     @Override
-    protected LevelGraph createGraph( EncodingManager em, boolean is3D )
+    protected CHGraph getGraph( GraphHopperStorage ghStorage )
     {
-        return new GraphBuilder(em).set3D(is3D).levelGraphCreate();
+        return ghStorage.getGraph(CHGraph.class);
     }
 
     @Override
-    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    protected GraphHopperStorage createGHStorage( EncodingManager em, boolean is3D )
     {
-        return createFactory(g, opts).createAlgo(g, opts);
+        return new GraphBuilder(em).set3D(is3D).setCHGraph(true).create();
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
+    public RoutingAlgorithmFactory createFactory( GraphHopperStorage ghStorage, AlgorithmOptions opts )
     {
         PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                (LevelGraph) g, opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+                ghStorage, getGraph(ghStorage),
+                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
         // hack: prepare matrixGraph only once
-        if (g != preparedMatrixGraph)
+        if (ghStorage != preparedMatrixGraph)
             ch.doWork();
 
         return ch;
@@ -80,7 +83,8 @@ public void testPathRecursiveUnpacking()
         // use an encoder where it is possible to store 2 weights per edge
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
         EncodingManager em = new EncodingManager(encoder);
-        LevelGraphStorage g2 = (LevelGraphStorage) createGraph(em, false);
+        GraphHopperStorage ghStorage = createGHStorage(em, false);
+        CHGraphImpl g2 = (CHGraphImpl) ghStorage.getGraph(CHGraph.class);
         g2.edge(0, 1, 1, true);
         EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, false);
         EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, false);
@@ -96,11 +100,12 @@ public void testPathRecursiveUnpacking()
         EdgeIteratorState iter2_2 = g2.edge(5, 7);
         iter2_2.setDistance(1.4).setFlags(encoder.setProperties(10, true, false));
 
+        ghStorage.freeze();
         // simulate preparation
-        EdgeSkipIterState iter2_1 = g2.shortcut(0, 5);
+        CHEdgeIteratorState iter2_1 = g2.shortcut(0, 5);
         iter2_1.setDistance(2.8).setFlags(encoder.setProperties(10, true, false));
         iter2_1.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
-        EdgeSkipIterState tmp = g2.shortcut(0, 7);
+        CHEdgeIteratorState tmp = g2.shortcut(0, 7);
         tmp.setDistance(4.2).setFlags(encoder.setProperties(10, true, false));
         tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
         g2.setLevel(1, 0);
@@ -114,8 +119,8 @@ public void testPathRecursiveUnpacking()
 
         ShortestWeighting weighting = new ShortestWeighting();
         AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
-        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT), 
-                g2, encoder, weighting, TraversalMode.NODE_BASED).
+        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                ghStorage, g2, encoder, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
@@ -150,23 +155,23 @@ public long setProperties( double speed, boolean forward, boolean backward )
     public void testBaseGraph()
     {
         CarFlagEncoder carFE = new CarFlagEncoder();
-        Graph g = createGraph(new EncodingManager(carFE), false);
-        initDirectedAndDiffSpeed(g, carFE);
+        GraphHopperStorage ghStorage = createGHStorage(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(ghStorage, carFE);
 
         // do CH preparation for car
-        createFactory(g, defaultOpts);
+        createFactory(ghStorage, defaultOpts);
 
         // use base graph for solving normal Dijkstra
-        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(ghStorage, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 402.29, p1.getDistance(), 1e-2);
         assertEquals(p1.toString(), 144823, p1.getTime());
     }
 
     @Test
     public void testBaseGraphMultipleVehicles()
     {
-        Graph g = createGraph(encodingManager, false);
+        GraphHopperStorage g = createGHStorage(encodingManager, false);
         initFootVsCar(g);
 
         AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
@@ -178,18 +183,18 @@ public void testBaseGraphMultipleVehicles()
         RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
 
         // use contracted graph
-        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        Path p1 = contractedFactory.createAlgo(getGraph(g), carOptions).calcPath(0, 7);
         assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
         assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
 
         // use base graph for solving normal Dijkstra via car
-        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g, carOptions).calcPath(0, 7);
         assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
         assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
         assertEquals(p2.toString(), 2700 * 1000, p2.getTime());
 
         // use base graph for solving normal Dijkstra via foot
-        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g, footOptions).calcPath(0, 7);
         assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
         assertEquals(p3.toString(), 12240 * 1000, p3.getTime());
         assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index fbba76c1a0..301358e8e8 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -22,9 +22,12 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
+
 import java.util.Collection;
 import java.util.Iterator;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -39,14 +42,14 @@
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private Directory dir;
 
-    LevelGraph createGraph()
+    GraphHopperStorage createGHStorage()
     {
-        return new GraphBuilder(encodingManager).levelGraphCreate();
+        return new GraphBuilder(encodingManager).setCHGraph(true).create();
     }
 
-    LevelGraph createExampleGraph()
+    GraphHopperStorage createExampleGraph()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
 
         //5-1-----2
         //   \ __/|
@@ -63,21 +66,24 @@ LevelGraph createExampleGraph()
         g.edge(5, 1, 2, true);
         return g;
     }
-    
+
     @Before
-    public void setUp() {
+    public void setUp()
+    {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
     @Test
     public void testShortestPathSkipNode()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        CHGraph lg = g.getGraph(CHGraph.class);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg,
+                carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(100);
         int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
@@ -90,13 +96,14 @@ public void testShortestPathSkipNode()
     @Test
     public void testShortestPathSkipNode2()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(10);
         int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
@@ -108,11 +115,13 @@ public void testShortestPathSkipNode2()
     @Test
     public void testShortestPathLimit()
     {
-        LevelGraph g = createExampleGraph();
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
+
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(0));
         algo.setWeightLimit(2);
         int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
@@ -122,38 +131,46 @@ public void testShortestPathLimit()
     @Test
     public void testAddShortcuts()
     {
-        LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        GraphHopperStorage g = createExampleGraph();
+        CHGraph lg = g.getGraph(CHGraph.class);
+        int old = lg.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getCount());
+        assertEquals(old + 1, lg.getAllEdges().getMaxId());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
-        LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
+        initShortcutsGraph(lg);
+        int oldCount = g.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 7, g.getAllEdges().getCount());
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount + 7, lg.getAllEdges().getMaxId());
     }
 
     @Test
     public void testDirectedGraph()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         g.edge(5, 4, 3, false);
         g.edge(4, 5, 10, false);
         g.edge(2, 4, 1, false);
         g.edge(5, 2, 1, false);
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
-        int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        g.freeze();
+        int oldCount = GHUtility.count(lg.getAllEdges());
+        assertEquals(6, oldCount);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(2, prepare.getShortcuts());
+        assertEquals(oldCount + 2, GHUtility.count(lg.getAllEdges()));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -162,14 +179,21 @@ public void testDirectedGraph()
     @Test
     public void testDirectedGraph2()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         initDirected2(g);
-        int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        int oldCount = GHUtility.count(g.getAllEdges());
+        assertEquals(19, oldCount);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
-        assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
+
+        assertEquals(9, prepare.getShortcuts());
+        assertEquals(oldCount + 9, lg.getAllEdges().getMaxId());
+        assertEquals(oldCount + 9, GHUtility.count(lg.getAllEdges()));
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -178,12 +202,13 @@ public void testDirectedGraph2()
     @Test
     public void testDirectedGraph3()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
         //5 6 7
         // \|/
-        //4-3_1<-
-        //    \_|_10
-        //   0__2_11
+        //4-3_1<-\ 10
+        //     \_|/
+        //   0___2_11
 
         g.edge(0, 2, 2, true);
         g.edge(10, 2, 2, true);
@@ -198,9 +223,10 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.initFromGraph();
         prepare.prepareNodes();
+
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -281,13 +307,15 @@ void initRoundaboutGraph( Graph g )
     @Test
     public void testRoundaboutUnpacking()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getCount();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        int oldCount = g.getAllEdges().getMaxId();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 23, g.getAllEdges().getCount());
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        assertEquals(oldCount, g.getAllEdges().getMaxId());
+        assertEquals(oldCount + 23, lg.getAllEdges().getMaxId());
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -295,43 +323,58 @@ public void testRoundaboutUnpacking()
     @Test
     public void testFindShortcuts_Roundabout()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        EdgeIteratorState iter1_1 = g.edge(1, 3, 1, true);
-        EdgeIteratorState iter1_2 = g.edge(3, 4, 1, true);
-        EdgeIteratorState iter2_1 = g.edge(4, 5, 1, false);
-        EdgeIteratorState iter2_2 = g.edge(5, 6, 1, false);
-        EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
-        EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
-        g.edge(8, 4, 1, false);
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        EdgeSkipIterState tmp = g.shortcut(1, 4);
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        EdgeIteratorState iter1_3 = ghStorage.edge(1, 3, 1, true);
+        EdgeIteratorState iter3_4 = ghStorage.edge(3, 4, 1, true);
+        EdgeIteratorState iter4_5 = ghStorage.edge(4, 5, 1, false);
+        EdgeIteratorState iter5_6 = ghStorage.edge(5, 6, 1, false);
+        EdgeIteratorState iter6_8 = ghStorage.edge(6, 8, 2, false);
+        EdgeIteratorState iter8_4 = ghStorage.edge(8, 4, 1, false);
+        ghStorage.edge(6, 7, 1, true);
+        ghStorage.freeze();
+        
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg,
+                carEncoder, weighting, tMode);
+        CHEdgeIteratorState tmp = lg.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
+        tmp.setSkippedEdges(iter1_3.getEdge(), iter3_4.getEdge());
         long f = PrepareEncoder.getScFwdDir();
-        tmp = g.shortcut(4, 6);
+        tmp = lg.shortcut(4, 6);
         tmp.setFlags(f);
         tmp.setWeight(2);
-        tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
-        tmp = g.shortcut(6, 4);
+        tmp.setSkippedEdges(iter4_5.getEdge(), iter5_6.getEdge());
+        tmp = lg.shortcut(6, 4);
         tmp.setFlags(f);
         tmp.setWeight(3);
-        tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
+        tmp.setSkippedEdges(iter6_8.getEdge(), iter8_4.getEdge());
 
         prepare.initFromGraph();
         prepare.prepareNodes();
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
+        lg.setLevel(3, 3);
+        lg.setLevel(5, 5);
+        lg.setLevel(7, 7);
+        lg.setLevel(8, 8);
 
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
+        Iterator<Shortcut> iter = sc.iterator();
+        Shortcut sc1 = iter.next();
+        Shortcut sc2 = iter.next();
+        if (sc1.from > sc2.from)
+        {
+            Shortcut tmpSc = sc1;
+            sc1 = sc2;
+            sc2 = tmpSc;
+        }
+
+        assertEquals("1->6, weight:4.0 (7,8)", sc1.toString());
+        assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
     }
 
-    void initUnpackingGraph( LevelGraphStorage g, Weighting w )
+    void initUnpackingGraph( GraphHopperStorage ghStorage, CHGraph g, Weighting w )
     {
         final long flags = carEncoder.setProperties(30, true, false);
         double dist = 1;
@@ -346,12 +389,13 @@ void initUnpackingGraph( LevelGraphStorage g, Weighting w )
         long oneDirFlags = PrepareEncoder.getScFwdDir();
 
         int tmp = iterTmp1.getEdge();
-        EdgeSkipIterState sc1 = g.shortcut(0, 2);
+        ghStorage.freeze();
+        CHEdgeIteratorState sc1 = g.shortcut(0, 2);
         int x = EdgeIterator.NO_EDGE;
         sc1.setWeight(w.calcWeight(iterTmp1, false, x) + w.calcWeight(iter2, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
         sc1.setSkippedEdges(tmp, iter2.getEdge());
         tmp = sc1.getEdge();
-        EdgeSkipIterState sc2 = g.shortcut(0, 3);
+        CHEdgeIteratorState sc2 = g.shortcut(0, 3);
         sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter3, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
         sc2.setSkippedEdges(tmp, iter3.getEdge());
         tmp = sc2.getEdge();
@@ -379,10 +423,11 @@ void initUnpackingGraph( LevelGraphStorage g, Weighting w )
     @Test
     public void testUnpackingOrder()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        initUnpackingGraph(ghStorage, lg, weighting);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -391,12 +436,13 @@ public void testUnpackingOrder()
     @Test
     public void testUnpackingOrder_Fastest()
     {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
+        GraphHopperStorage ghStorage = createGHStorage();
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
         Weighting w = new FastestWeighting(carEncoder);
-        initUnpackingGraph(g, w);
+        initUnpackingGraph(ghStorage, lg, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
-        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -405,7 +451,8 @@ public void testUnpackingOrder_Fastest()
     @Test
     public void testCircleBug()
     {
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         //  /--1
         // -0--/
         //  |
@@ -413,7 +460,7 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -426,7 +473,8 @@ public void testBug178()
         // 0-1->-2--3--4
         //   \-<-/
         //
-        LevelGraph g = createGraph();
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getGraph(CHGraph.class);
         g.edge(1, 2, 1, false);
         g.edge(2, 1, 1, false);
 
@@ -437,7 +485,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -511,7 +559,7 @@ public static void initDirected1( Graph g )
     }
 
     // prepare-routing.svg
-    public static LevelGraph initShortcutsGraph( LevelGraph g )
+    public static CHGraph initShortcutsGraph( CHGraph g )
     {
         g.edge(0, 1, 1, true);
         g.edge(0, 2, 1, true);
@@ -538,7 +586,7 @@ public static LevelGraph initShortcutsGraph( LevelGraph g )
         return g;
     }
 
-//    public static void printEdges(LevelGraph g) {
+    //    public static void printEdges(CHGraph g) {
 //        RawEdgeIterator iter = g.getAllEdges();
 //        while (iter.next()) {
 //            EdgeSkipIterator single = g.getEdgeProps(iter.edge(), iter.nodeB());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
index 27e3d9415e..190f66bd43 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.routing.ch;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrepareEncoderTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 30475dd3f9..a67b0f1f62 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -19,11 +19,17 @@
 
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import com.graphhopper.util.Translation;
+
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
+
 import java.util.Locale;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -353,17 +359,12 @@ public void testReduceToMaxSpeed()
     }
 
     @Test
-    public void testMaxAndMinSpeed()
+    public void testPreferenceForSlowSpeed()
     {
         OSMWay osmWay = new OSMWay(1);
         osmWay.setTag("highway", "tertiary");
         assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49, false))), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
-
-        osmWay.setTag("highway", "tertiary");
-        osmWay.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
-        assertPriority(REACH_DEST.getValue(), osmWay);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index 2fc14399fb..40cb881ac7 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class AbstractFlagEncoderTest
@@ -29,15 +29,22 @@
     @Test
     public void testAcceptsCar()
     {
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40 km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40km/h"), 1e-3);
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40kmh"), 1e-3);
-        assertEquals(64.374, AbstractFlagEncoder.parseSpeed("40mph"), 1e-3);
-        assertEquals(48.28, AbstractFlagEncoder.parseSpeed("30 mph"), 1e-3);
-        assertEquals(-1, AbstractFlagEncoder.parseSpeed(null), 1e-3);
-        assertEquals(18.52, AbstractFlagEncoder.parseSpeed("10 knots"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19 kph"), 1e-3);
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19kph"), 1e-3);
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 0);
+        assertEquals(40, encoder.parseSpeed("40 km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40km/h"), 1e-3);
+        assertEquals(40, encoder.parseSpeed("40kmh"), 1e-3);
+        assertEquals(64.374, encoder.parseSpeed("40mph"), 1e-3);
+        assertEquals(48.28, encoder.parseSpeed("30 mph"), 1e-3);
+        assertEquals(-1, encoder.parseSpeed(null), 1e-3);
+        assertEquals(18.52, encoder.parseSpeed("10 knots"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19 kph"), 1e-3);
+        assertEquals(19, encoder.parseSpeed("19kph"), 1e-3);
+
+        assertEquals(50, encoder.parseSpeed("RO:urban"), 1e-3);
+
+        assertEquals(80, encoder.parseSpeed("RU:rural"), 1e-3);
+
+        assertEquals(6, encoder.parseSpeed("walk"), 1e-3);
     }
 
     @Test
@@ -51,11 +58,4 @@ public void testParseDuration()
         assertEquals(60 * 20, AbstractFlagEncoder.parseDuration("0:20:00"));
         assertEquals(60 * 24 * 2 + 60 * 20 + 2, AbstractFlagEncoder.parseDuration("02:20:02"));
     }
-    
-    @Test
-    public void testParseProperties()
-    {
-        assertEquals(10, AbstractFlagEncoder.parseDouble("car|x", "prop", 10), .1);
-        assertEquals(12.2, AbstractFlagEncoder.parseDouble("car|x|prop=12.2", "prop", 10), .1);
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index 51894b72b3..92784cb5db 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -24,18 +24,25 @@
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
 {
-    private Graph initExampleGraph( FlagEncoder instance )
+    private final EncodingManager em = new EncodingManager("bike,bike2");
+
+    @Override
+    protected BikeCommonFlagEncoder createBikeEncoder()
+    {
+        return (BikeCommonFlagEncoder) em.getEncoder("bike2");
+    }
+
+    private Graph initExampleGraph()
     {
-        EncodingManager em = new EncodingManager(instance);
-        GraphStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
+        GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
         na.setNode(0, 51.1, 12.001, 50);
@@ -44,37 +51,47 @@ private Graph initExampleGraph( FlagEncoder instance )
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
         edge.setDistance(100);
 
-        edge.setFlags(instance.setReverseSpeed(instance.setProperties(10, true, true), 15));
+        edge.setFlags(encoder.setReverseSpeed(encoder.setProperties(10, true, true), 15));
         return gs;
     }
 
     @Test
     public void testApplyWayTags()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         OSMWay way = new OSMWay(1);
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         long flags = edge.getFlags();
         // decrease speed
-        assertEquals(2, instance.getSpeed(flags), 1e-1);
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
         // increase speed but use maximum speed (calculated was 24)
-        assertEquals(18, instance.getReverseSpeed(flags), 1e-1);
+        assertEquals(18, encoder.getReverseSpeed(flags), 1e-1);
     }
-        
+
     @Test
     public void testUnchangedForStepsBridgeAndTunnel()
     {
-        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
-        Graph graph = initExampleGraph(instance);
+        Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
         long oldFlags = edge.getFlags();
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "steps");
-        instance.applyWayTags(way, edge);
+        encoder.applyWayTags(way, edge);
 
         assertEquals(oldFlags, edge.getFlags());
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 1e8b6c5acf..7636e6ac76 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -17,9 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -46,10 +50,52 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
         assertPriority(REACH_DEST.getValue(), way);
 
+        // Pushing section !! This is fine as we obey the law!
+        way.clearTags();
+        way.setTag("highway", "footway");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        // Pushing section irrespective of the pavement
+        way.setTag("surface", "paved");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "yes");
+
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("bicycle", "yes");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        // Pushing section Ok !!
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "paved");
         assertEquals(4, encoder.getSpeed(way));
         assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "designated");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.clearTags();
         way.setTag("highway", "track");
         assertEquals(12, encoder.getSpeed(way));
         assertPriority(UNCHANGED.getValue(), way);
@@ -91,7 +137,21 @@ public void testGetSpeed()
         assertEquals(18, encoder.getSpeed(way));
 
         way.setTag("surface", "unknown_surface");
-        assertEquals(4, encoder.getSpeed(way));
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "fine_gravel");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(18, encoder.getSpeed(way));
 
         way.clearTags();
         way.setTag("highway", "residential");
@@ -162,6 +222,12 @@ public void testOneway()
         assertTrue(encoder.isForward(flags));
         assertFalse(encoder.isBackward(flags));
         way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway:bicycle", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
 
         way.setTag("highway", "tertiary");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -176,6 +242,13 @@ public void testOneway()
         assertTrue(encoder.isBackward(flags));
         way.clearTags();
 
+        way.setTag("highway", "tertiary");
+        way.setTag("bicycle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:backward", "no");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
@@ -197,15 +270,22 @@ public void testOneway()
         way.setTag("bicycle:backward", "no");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));        
+        assertTrue(encoder.isBackward(flags));
 
         way.setTag("bicycle:backward", "yes");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertTrue(encoder.isForward(flags));
         assertTrue(encoder.isBackward(flags));
+
         way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("cycleway", "opposite");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
     }
-    
+
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
@@ -293,7 +373,7 @@ public void testSacScale()
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // allow
-        assertEquals(1, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
 
         way.setTag("highway", "path");
         way.setTag("sac_scale", "mountain_hiking");
@@ -339,6 +419,18 @@ public void testMaxSpeed()
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
         assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), way);
     }
 
     @Test
@@ -399,4 +491,50 @@ public void testTurnFlagEncoding_withCosts()
         assertTrue(encoder.isTurnRestricted(flags_r220));
         assertFalse(encoder.isTurnRestricted(flags_126));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle", "3");
+        assertPriority(BEST.getValue(), way);
+        way.setTag("class:bicycle", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+        way.setTag("class:bicycle", "1");
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("class:bicycle", "0");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "invalidvalue");
+        assertPriority(UNCHANGED.getValue(), way);
+        way.setTag("class:bicycle", "-1");
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+        way.setTag("class:bicycle", "-2");
+        assertPriority(REACH_DEST.getValue(), way);
+        way.setTag("class:bicycle", "-3");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), way);
+
+        // Now we test overriding by a specific class subtype
+        way.setTag("class:bicycle:touring", "2");
+        assertPriority(VERY_NICE.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 2dadef1d67..ae8fa80fa2 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CarFlagEncoderTest
@@ -56,12 +56,6 @@ public void testAccess()
         way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        way.clearTags();
-        way.setTag("highway", "service");
-        way.setTag("access", "no");
-        way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
-
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "delivery");
@@ -86,6 +80,59 @@ public void testAccess()
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
         assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+        
+        way.clearTags();
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "yes");
+        way.setTag("motor_vehicle", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        try
+        {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally
+        {
+            encoder.setBlockFords(true);
+        }
     }
 
     @Test
@@ -123,15 +170,6 @@ public void testOneway()
         way.clearTags();
     }
 
-    @Test
-    public void testMilitaryAccess()
-    {
-        OSMWay way = new OSMWay(1);
-        way.setTag("highway", "track");
-        way.setTag("access", "military");
-        assertFalse(encoder.acceptWay(way) > 0);
-    }
-
     @Test
     public void testSetAccess()
     {
@@ -164,7 +202,7 @@ public void testMaxSpeed()
         way.setTag("maxspeed", "500");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        assertEquals(140, encoder.getSpeed(encoded), 1e-1);
 
         way = new OSMWay(1);
         way.setTag("highway", "primary");
@@ -184,6 +222,12 @@ public void testMaxSpeed()
         way.setTag("maxspeed:backward", "20");
         encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", "none");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(125, encoder.getSpeed(encoded), .1);
     }
 
     @Test
@@ -232,6 +276,18 @@ public void testSetSpeed()
         assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
     }
 
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, encoder.speedFactor * 0.49);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(0, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+    }
+
     @Test
     public void testRoundabout()
     {
@@ -419,7 +475,7 @@ public void testTurnFlagEncoding_withCosts()
     @Test
     public void testMaxValue()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -431,19 +487,19 @@ public void testMaxValue()
         assertEquals(86.9, instance.getSpeed(flags), 1e-1);
         flags = instance.reverseFlags(flags);
         assertEquals(86.9, instance.getSpeed(flags), 1e-1);
-        
+
         // test that maxPossibleValue  is not exceeded
         way = new OSMWay(2);
         way.setTag("highway", "motorway_link");
         way.setTag("maxspeed", "70 mph");
         flags = instance.handleWayTags(way, 1, 0);
-        assertEquals(100, instance.getSpeed(flags), 1e-1);
+        assertEquals(101.5, instance.getSpeed(flags), .1);
     }
 
     @Test
     public void testRegisterOnlyOnceAllowed()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         try
         {
@@ -462,39 +518,12 @@ public void testSetToMaxSpeed()
         assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
     }
 
-    @Test
-    public void testFordAccess()
-    {
-        OSMNode node = new OSMNode(0, 0.0, 0.0);
-        node.setTag("ford", "yes");
-
-        OSMWay way = new OSMWay(1);
-        way.setTag("highway", "unclassified");
-        way.setTag("ford", "yes");
-
-        // Node and way are initially blocking
-        assertTrue(encoder.isBlockFords());
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.handleNodeTags(node) > 0);
-
-        try
-        {
-            // Now they are passable
-            encoder.setBlockFords(false);
-            assertTrue(encoder.acceptWay(way) > 0);
-            assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally
-        {
-            encoder.setBlockFords(true);
-        }
-    }
-
     @Test
     public void testCombination()
     {
         OSMWay way = new OSMWay(123);
         way.setTag("highway", "cycleway");
-        way.setTag("sac_scale", "hiking");        
+        way.setTag("sac_scale", "hiking");
 
         long flags = em.acceptWay(way);
         long edgeFlags = em.handleWayTags(way, flags, 0);
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
index 220a204e0f..f69318a049 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -20,10 +20,10 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedDoubleValueTest
@@ -53,7 +53,7 @@ public void testMaxValueAndSwap()
         long swappedFlags = instance1.swap(flags, instance2);
         assertEquals(expectedFlags, swappedFlags);
 
-        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5, 0);
+        CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
         new EncodingManager(carEncoder);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -62,6 +62,14 @@ public void testMaxValueAndSwap()
 
         // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
         flags = carEncoder.reverseFlags(flags);
-        assertEquals(100, carEncoder.getSpeed(flags), 1e-1);
+        assertEquals(101.5, carEncoder.getSpeed(flags), 1e-1);
+    }
+
+    @Test
+    public void testUnsignedRightShift_issue417()
+    {
+        EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);
+        Long flags = -72057594037927936L;
+        assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
index 9fcb71771d..6ceb80be0c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.routing.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodedValueTest
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index bcd4e4ded1..90904a99fe 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,18 +22,22 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Rule;
 import org.junit.Test;
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
+import org.junit.rules.ExpectedException;
 
 /**
- *
  * @author Peter Karich
  */
 public class EncodingManagerTest
 {
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
     @Test
     public void testCompatibility()
     {
@@ -65,6 +69,13 @@ public void testEncoderAcceptNoException()
         assertFalse(manager.supports("FOOT"));
     }
 
+    @Test
+    public void testEncoderWithWrongVersionIsRejected()
+    {
+        thrown.expect(IllegalArgumentException.class);
+        EncodingManager manager = new EncodingManager("CAR|version=0");
+    }
+
     @Test
     public void testWrongEncoders()
     {
@@ -84,11 +95,57 @@ public void testWrongEncoders()
             assertTrue(false);
         } catch (Exception ex)
         {
-            assertEquals("Encoders are requesting more than 32 bits of way flags. Decrease the number of vehicles or increase the flags to take long.",
-                    ex.getMessage());
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting more than 32 bits of way flags. Decrease the"));
         }
     }
 
+    @Test
+    public void testToDetailsStringIncludesEncoderVersionNumber()
+    {
+        FlagEncoder encoder = new AbstractFlagEncoder(1, 2.0, 3)
+        {
+            @Override
+            public int getVersion()
+            {
+                return 10;
+            }
+
+            @Override
+            public String toString()
+            {
+                return "newEncoder";
+            }
+
+            @Override
+            protected String getPropertiesString()
+            {
+                return "myProperties";
+            }
+
+            @Override
+            public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+            {
+                return 0;
+            }
+
+            @Override
+            public long acceptWay( OSMWay way )
+            {
+                return 0;
+            }
+
+            @Override
+            public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+            {
+                return 0;
+            }
+        };
+
+        EncodingManager subject = new EncodingManager(encoder);
+
+        assertEquals("newEncoder|myProperties|version=10", subject.toDetailsString());
+    }
+
     @Test
     public void testCombineRelations()
     {
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index 816310c551..11464b6731 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -37,6 +41,32 @@ public void testMinWeightHasSameUnitAs_getWeight()
         assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
+    @Test
+    public void testWeightWrongHeading()
+    {
+        FastestWeighting instance = new FastestWeighting(encoder, new PMap().put("heading_penalty", "100"));
+
+        VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
+                encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
+        double time = instance.calcWeight(virtEdge, false, 0);
+
+        virtEdge.setVirtualEdgePreference(true, false);
+        // heading penalty on edge
+        assertEquals(time + 100, instance.calcWeight(virtEdge, false, 0), 1e-8);
+        // but not in reverse heading
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // only after setting it
+        virtEdge.setVirtualEdgePreference(true, true);
+        assertEquals(time + 100, instance.calcWeight(virtEdge, true, 0), 1e-8);
+        // but not after releasing it
+        virtEdge.setVirtualEdgePreference(false, true);
+        assertEquals(time, instance.calcWeight(virtEdge, true, 0), 1e-8);
+
+        // test default penalty
+        instance = new FastestWeighting(encoder);
+        assertEquals(time + FastestWeighting.DEFAULT_HEADING_PENALTY, instance.calcWeight(virtEdge, false, 0), 1e-8);
+    }
+
     @Test
     public void testSpeed0()
     {
@@ -63,6 +93,12 @@ public long getFlags()
             {
                 return flags;
             }
+
+            @Override
+            public boolean getBoolean( int key, boolean reverse, boolean _default )
+            {
+                return _default;
+            }
         };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 8e36afe2c8..4a1e443523 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -25,10 +25,10 @@
 import com.graphhopper.util.GHUtility;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class FootFlagEncoderTest
@@ -133,6 +133,14 @@ public void testAccess()
         assertTrue(footEncoder.acceptWay(way) > 0);
         way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
+        way.setTag("access", "yes");
+        assertFalse(footEncoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("foot", "yes");
+        way.setTag("access", "no");
+        assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "track");
@@ -194,6 +202,9 @@ public void testPriority()
         way.setTag("highway", "cycleway");
         assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
 
+        way.setTag("highway", "primary");
+        assertEquals(PriorityCode.AVOID_AT_ALL_COSTS.getValue(), footEncoder.handlePriority(way, 0));
+        
         way.setTag("highway", "track");
         way.setTag("bicycle", "official");
         assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
@@ -201,6 +212,16 @@ public void testPriority()
         way.setTag("highway", "track");
         way.setTag("bicycle", "designated");
         assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+        
+        way.setTag("highway", "cycleway");
+        way.setTag("bicycle", "designated");
+        way.setTag("foot", "designated"); 
+        assertEquals(PriorityCode.PREFER.getValue(), footEncoder.handlePriority(way, 0));
+        
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("sidewalk", "yes");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));        
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 92f737654c..725da43dd8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoderTest
@@ -41,4 +41,16 @@ public void testHandleWayTags()
         assertEquals(20, encoder.getSpeed(result), .1);
         assertEquals(20, encoder.getReverseSpeed(result), .1);
     }
+
+    @Test
+    public void testSetSpeed0_issue367()
+    {
+        long flags = encoder.setProperties(10, true, true);
+        flags = encoder.setSpeed(flags, 0);
+
+        assertEquals(0, encoder.getSpeed(flags), .1);
+        assertEquals(10, encoder.getReverseSpeed(flags), .1);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index 6fcd32a6f8..cd76e482a1 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -17,10 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -201,4 +205,30 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("", getWayTypeFromFlags(osmWay));
     }
+
+    // Issue 407 : Always block kissing_gate execpt for mountainbikes
+    @Test
+    public void testBarrierAccess()
+    {
+        // kissing_gate without bicycle tag
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag = no
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "no");
+        // barrier!
+        assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // kissing_gate with bicycle tag
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "kissing_gate");
+        node.setTag("bicycle", "yes");
+        // No barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 61a2936111..e6cb3fefb9 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -18,33 +18,35 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
 
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
 {
     private final EncodingManager em = new EncodingManager("car");
 
-    GraphStorage createGraph( EncodingManager eman )
+    GraphHopperStorage createStorage( EncodingManager eman )
     {
         return new GraphBuilder(eman).create();
     }
 
-    GraphStorage createSubnetworkTestGraph()
+    GraphHopperStorage createSubnetworkTestStorage()
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         // big network
         g.edge(1, 2, 1, true);
         g.edge(1, 4, 1, false);
@@ -54,6 +56,7 @@ GraphStorage createSubnetworkTestGraph()
         g.edge(8, 11, 1, true);
         g.edge(12, 11, 1, true);
         g.edge(9, 12, 1, false);
+        g.edge(9, 15, 1, true);
 
         // large network
         g.edge(0, 13, 1, true);
@@ -69,10 +72,31 @@ GraphStorage createSubnetworkTestGraph()
         return g;
     }
 
+    GraphHopperStorage createSubnetworkTestStorage2( EncodingManager em )
+    {
+        GraphHopperStorage g = createStorage(em);
+        // large network
+        g.edge(0, 1, 1, true);
+        g.edge(1, 3, 1, true);
+        g.edge(0, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 7, 1, true);
+        g.edge(7, 8, 1, true);
+
+        // connecting both but do not allow CAR!
+        g.edge(3, 4).setDistance(1);
+
+        // small network
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(4, 6, 1, true);
+        return g;
+    }
+
     @Test
     public void testFindSubnetworks()
     {
-        GraphStorage g = createSubnetworkTestGraph();
+        GraphHopperStorage g = createSubnetworkTestStorage();
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
         Map<Integer, Integer> map = instance.findSubnetworks();
 
@@ -80,79 +104,60 @@ public void testFindSubnetworks()
         // start is at 0 => large network
         assertEquals(5, (int) map.get(0));
         // next smallest and unvisited node is 1 => big network
-        assertEquals(7, (int) map.get(1));
+        assertEquals(8, (int) map.get(1));
         assertEquals(3, (int) map.get(6));
     }
 
     @Test
     public void testKeepLargestNetworks()
     {
-        GraphStorage g = createSubnetworkTestGraph();
+        GraphHopperStorage g = createSubnetworkTestStorage();
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
         Map<Integer, Integer> map = instance.findSubnetworks();
         instance.keepLargeNetworks(map);
         g.optimize();
 
-        assertEquals(7, g.getNodes());
+        assertEquals(8, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         map = instance.findSubnetworks();
         assertEquals(1, map.size());
-        assertEquals(7, (int) map.get(0));
-    }
-
-    GraphStorage createSubnetworkTestGraph2( EncodingManager em )
-    {
-        GraphStorage g = createGraph(em);
-        // large network
-        g.edge(0, 1, 1, true);
-        g.edge(1, 3, 1, true);
-        g.edge(0, 2, 1, true);
-        g.edge(2, 3, 1, true);
-
-        // connecting both but do not allow CAR!
-        g.edge(3, 4).setDistance(1);
-
-        // small network
-        g.edge(4, 5, 1, true);
-        g.edge(5, 6, 1, true);
-        g.edge(4, 6, 1, true);
-        return g;
+        assertEquals(8, (int) map.get(0));
     }
 
     @Test
     public void testRemoveSubnetworkIfOnlyOneVehicle()
     {
-        GraphStorage g = createSubnetworkTestGraph2(em);
+        GraphHopperStorage g = createSubnetworkTestStorage2(em);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em);
         instance.setMinNetworkSize(4);
         instance.doWork();
         g.optimize();
-        assertEquals(4, g.getNodes());
+        assertEquals(6, g.getNodes());
         assertEquals(Arrays.<String>asList(), GHUtility.getProblems(g));
         EdgeExplorer explorer = g.createEdgeExplorer();
-        assertEquals(GHUtility.asSet(2, 1), GHUtility.getNeighbors(explorer.setBaseNode(3)));
+        assertEquals(GHUtility.asSet(2, 1, 5), GHUtility.getNeighbors(explorer.setBaseNode(3)));
 
         // do not remove because small network is big enough
-        g = createSubnetworkTestGraph2(em);
+        g = createSubnetworkTestStorage2(em);
         instance = new PrepareRoutingSubnetworks(g, em);
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
 
         // do not remove because two two vehicles
         EncodingManager em2 = new EncodingManager("CAR,BIKE");
-        g = createSubnetworkTestGraph2(em2);
+        g = createSubnetworkTestStorage2(em2);
         instance = new PrepareRoutingSubnetworks(g, em2);
         instance.setMinNetworkSize(3);
         instance.doWork();
         g.optimize();
-        assertEquals(7, g.getNodes());
+        assertEquals(9, g.getNodes());
     }
 
-    GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
+    GraphHopperStorage createDeadEndUnvisitedNetworkStorage( EncodingManager em )
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
         g.edge(0, 1, 1, true);
         g.edge(1, 2, 1, true);
@@ -169,9 +174,9 @@ GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
         return g;
     }
 
-    GraphStorage createTarjanTestGraph()
+    GraphHopperStorage createTarjanTestStorage()
     {
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
 
         g.edge(1, 2, 1, false);
         g.edge(2, 3, 1, false);
@@ -195,7 +200,7 @@ GraphStorage createTarjanTestGraph()
     @Test
     public void testRemoveDeadEndUnvisitedNetworks()
     {
-        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        GraphHopperStorage g = createDeadEndUnvisitedNetworkStorage(em);
         assertEquals(11, g.getNodes());
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
@@ -211,7 +216,7 @@ public void testRemoveDeadEndUnvisitedNetworks()
     @Test
     public void testTarjan()
     {
-        GraphStorage g = createSubnetworkTestGraph();
+        GraphHopperStorage g = createSubnetworkTestStorage();
 
         // Requires a single vehicle type, otherwise we throw.
         final FlagEncoder flagEncoder = em.getEncoder("car");
@@ -236,7 +241,7 @@ public void testTarjan()
         }), components.get(2));
         assertEquals(new TIntArrayList(new int[]
         {
-            9
+            15, 9
         }), components.get(3));
     }
 
@@ -245,7 +250,7 @@ public void testTarjan()
     public void testNodeOrderingRegression()
     {
         // 1 -> 2 -> 0
-        GraphStorage g = createGraph(em);
+        GraphHopperStorage g = createStorage(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
@@ -254,4 +259,30 @@ public void testNodeOrderingRegression()
 
         assertEquals(3, removed);
     }
+
+    @Test
+    public void test481()
+    {
+        // 0->1->3->4->5->6
+        //  2        7<--/
+        GraphHopperStorage g = createStorage(em);
+        g.edge(0, 1, 1, false);
+        g.edge(1, 2, 1, false);
+        g.edge(2, 0, 1, false);
+
+        g.edge(1, 3, 1, false);
+        g.edge(3, 4, 1, false);
+        
+        g.edge(4, 5, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 7, 1, false);
+        g.edge(7, 4, 1, false);
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2).
+                setMinNetworkSize(4);
+        instance.doWork();
+
+        assertEquals(4, g.getNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index 6012124c1a..ff59093c34 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,13 +19,15 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
 import static com.graphhopper.routing.util.PriorityCode.*;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author ratrun
  */
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
@@ -77,12 +79,12 @@ public void testSacScale()
         way.setTag("sac_scale", "mountain_hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
-        
+
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
-        
+
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
         // but allow this as there is no reason for not allowing it
@@ -113,6 +115,21 @@ public void testGetSpeed()
         way.clearTags();
         way.setTag("highway", "steps");
         assertEquals(2, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "paved");
+        assertEquals(20, getSpeedFromFlags(way), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "primary");
+        way.setTag("surface", "unknownpavement");
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
+
     }
 
     @Test
@@ -186,4 +203,79 @@ public void testHandleWayTagsInfluencedByRelation()
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
     }
+
+    @Test
+    public void testAvoidanceOfHighMaxSpeed()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "tertiary");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "60");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "motorway");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(REACH_DEST.getValue(), osmWay);
+
+        osmWay.setTag("tunnel", "yes");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "80");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("tunnel", "yes");
+        osmWay.setTag("maxspeed", "120");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.clearTags();
+        osmWay.setTag("highway", "notdefined");
+        osmWay.setTag("maxspeed", "50");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+    }
+
+    @Test
+    public void testclassBicycle()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        way.setTag("class:bicycle:roadcycling", "3");
+        assertPriority(BEST.getValue(), way);
+
+        way.setTag("class:bicycle", "-2");
+        assertPriority(BEST.getValue(), way);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index 746d286993..cdc35ad737 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -18,11 +18,13 @@
 package com.graphhopper.search;
 
 import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.Helper;
+import java.io.File;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NameIndexTest
@@ -90,4 +92,26 @@ public void testTooLongNameNoError()
         index.put(str);
         index.close();
     }
+
+    @Test
+    public void testFlush()
+    {
+        String location = "./target/nameindex-store";
+        Helper.removeDir(new File(location));
+
+        NameIndex index = new NameIndex(new RAMDirectory(location, true)).create(1000);
+        long pointer = index.put("test");
+        index.flush();
+        index.close();
+
+        index = new NameIndex(new RAMDirectory(location, true));
+        assertTrue(index.loadExisting());
+        assertEquals("test", index.get(pointer));
+        // make sure bytePointer is correctly set after loadExisting
+        long newPointer = index.put("testing");
+        assertEquals(newPointer + ">" + pointer, pointer + "test".getBytes().length + 1, newPointer);
+        index.close();
+
+        Helper.removeDir(new File(location));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index 8850b1c893..5f293ad0b1 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -18,10 +18,13 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index a49cc8c096..96f8df1c71 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -53,20 +53,20 @@
     EdgeExplorer carOutExplorer;
     EdgeExplorer carInExplorer;
     EdgeExplorer carAllExplorer;
-    protected GraphStorage graph;
+    protected GraphHopperStorage graph;
 
-    protected GraphStorage createGraph()
+    protected GraphHopperStorage createGHStorage()
     {
-        GraphStorage g = createGraph(defaultGraphLoc, false);
+        GraphHopperStorage g = createGHStorage(defaultGraphLoc, false);
         carOutExplorer = g.createEdgeExplorer(carOutFilter);
         carInExplorer = g.createEdgeExplorer(carInFilter);
         carAllExplorer = g.createEdgeExplorer();
         return g;
     }
 
-    abstract GraphStorage createGraph( String location, boolean is3D );
+    abstract GraphHopperStorage createGHStorage( String location, boolean is3D );
 
-    protected GraphStorage newRAMGraph()
+    protected final GraphHopperStorage newRAMGHStorage()
     {
         return new GraphHopperStorage(new RAMDirectory(), encodingManager, false);
     }
@@ -87,7 +87,7 @@ public void tearDown()
     @Test
     public void testInfinityWeight()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState edge = graph.edge(0, 1);
         edge.setDistance(Double.POSITIVE_INFINITY);
         assertTrue(Double.isInfinite(edge.getDistance()));
@@ -96,7 +96,7 @@ public void testInfinityWeight()
     @Test
     public void testSetNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         for (int i = 0; i < defaultSize * 2; i++)
         {
@@ -110,7 +110,7 @@ public void testSetNodes()
     @Test
     public void testPropertiesWithNoInit()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         assertEquals(0, graph.edge(0, 1).getFlags());
         assertEquals(0, graph.edge(0, 2).getDistance(), 1e-6);
     }
@@ -118,7 +118,7 @@ public void testPropertiesWithNoInit()
     @Test
     public void testCreateLocation()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(3, 1, 50, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(1)));
 
@@ -129,7 +129,7 @@ public void testCreateLocation()
     @Test
     public void testEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         assertEquals(1, count(carOutExplorer.setBaseNode(2)));
 
@@ -142,7 +142,7 @@ public void testEdges()
     @Test
     public void testUnidirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(1, 11, 12, false);
@@ -176,7 +176,7 @@ public void testUnidirectional()
     @Test
     public void testUnidirectionalEdgeFilter()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(1, 11, 12, false);
@@ -212,7 +212,7 @@ public void testUnidirectionalEdgeFilter()
     @Test
     public void testUpdateUnidirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         graph.edge(1, 2, 12, false);
         graph.edge(3, 2, 112, false);
@@ -236,7 +236,7 @@ public void testUpdateUnidirectional()
     @Test
     public void testClone()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 10, true);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
@@ -245,19 +245,19 @@ public void testClone()
         na.setNode(3, 5, 9);
         graph.edge(1, 3, 10, true);
 
-        Graph clone = graph.copyTo(createGraph(locationParent + "/clone", false));
-        assertEquals(graph.getNodes(), clone.getNodes());
-        assertEquals(count(carOutExplorer.setBaseNode(1)), count(clone.createEdgeExplorer(carOutFilter).setBaseNode(1)));
-        clone.edge(1, 4, 10, true);
-        assertEquals(3, count(clone.createEdgeExplorer(carOutFilter).setBaseNode(1)));
-        assertEquals(graph.getBounds(), clone.getBounds());
-        Helper.close((Closeable) clone);
+        Graph cloneGraph = graph.copyTo(AbstractGraphStorageTester.this.createGHStorage(locationParent + "/clone", false));
+        assertEquals(graph.getNodes(), cloneGraph.getNodes());
+        assertEquals(count(carOutExplorer.setBaseNode(1)), count(cloneGraph.createEdgeExplorer(carOutFilter).setBaseNode(1)));
+        cloneGraph.edge(1, 4, 10, true);
+        assertEquals(3, count(cloneGraph.createEdgeExplorer(carOutFilter).setBaseNode(1)));
+        assertEquals(graph.getBounds(), cloneGraph.getBounds());
+        Helper.close((Closeable) cloneGraph);
     }
 
     @Test
     public void testCopyProperties()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState edge = graph.edge(1, 3, 10, false).setName("testing").setWayGeometry(Helper.createPointList(1, 2));
 
         EdgeIteratorState newEdge = graph.edge(1, 3, 10, false);
@@ -271,7 +271,7 @@ public void testCopyProperties()
     @Test
     public void testGetLocations()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 22, 23);
@@ -283,17 +283,17 @@ public void testGetLocations()
         graph.edge(0, 2, 10, true);
         assertEquals(3, graph.getNodes());
         Helper.close((Closeable) graph);
-
-        graph = createGraph();
+        
+        graph = createGHStorage();
         assertEquals(0, graph.getNodes());
     }
 
     @Test
     public void testCopyTo()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         initExampleGraph(graph);
-        GraphStorage gs = newRAMGraph();
+        GraphHopperStorage gs = newRAMGHStorage();
         gs.setSegmentSize(8000);
         gs.create(10);
         try
@@ -309,7 +309,7 @@ public void testCopyTo()
         try
         {
             Helper.close((Closeable) graph);
-            graph = createGraph();
+            graph = createGHStorage();
             gs.copyTo(graph);
             checkExampleGraph(graph);
         } catch (Exception ex)
@@ -323,7 +323,7 @@ public void testCopyTo()
     @Test
     public void testAddLocation()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         initExampleGraph(graph);
         checkExampleGraph(graph);
     }
@@ -374,7 +374,7 @@ private void checkExampleGraph( Graph graph )
     @Test
     public void testDirectional()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         graph.edge(2, 3, 12, false);
         graph.edge(3, 4, 12, false);
@@ -405,7 +405,7 @@ public void testDirectional()
     @Test
     public void testDozendEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(1, 2, 12, true);
         assertEquals(1, count(carAllExplorer.setBaseNode(1)));
 
@@ -438,7 +438,7 @@ public void testDozendEdges()
     @Test
     public void testCheckFirstNode()
     {
-        graph = createGraph();
+        graph = createGHStorage();
 
         assertEquals(0, count(carAllExplorer.setBaseNode(1)));
         graph.edge(0, 1, 12, true);
@@ -448,7 +448,7 @@ public void testCheckFirstNode()
     @Test
     public void testDeleteNodeForUnidir()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(10, 10, 1);
         na.setNode(6, 6, 1);
@@ -491,7 +491,7 @@ public void testComplexDeleteNode2()
 
     public void testDeleteNodes( int fillToSize )
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 38.33f, 135.3f);
@@ -563,7 +563,7 @@ public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
     @Test
     public void testSimpleDelete()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 12, 23);
         na.setNode(1, 38.33f, 135.3f);
@@ -594,7 +594,7 @@ public void testSimpleDelete()
     @Test
     public void testSimpleDelete2()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         assertEquals(-1, getIdOf(graph, 12));
         na.setNode(9, 9, 1);
@@ -643,7 +643,7 @@ public void testSimpleDelete2()
     @Test
     public void testSimpleDelete3()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(7, 7, 1);
         na.setNode(8, 8, 1);
@@ -675,7 +675,7 @@ public void testSimpleDelete3()
     @Test
     public void testDeleteAndOptimize()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(20, 10, 10);
         na.setNode(21, 10, 11);
@@ -687,7 +687,7 @@ public void testDeleteAndOptimize()
     @Test
     public void testBounds()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         BBox b = graph.getBounds();
         assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
@@ -706,7 +706,7 @@ public void testBounds()
     @Test
     public void testFlags()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(carEncoder.setProperties(100, true, true));
         graph.edge(2, 3).setDistance(10).setFlags(carEncoder.setProperties(10, true, false));
 
@@ -730,30 +730,30 @@ public void testFlags()
     @Test
     public void testEdgeProperties()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(0, 2, 20, true);
 
         int edgeId = iter1.getEdge();
-        EdgeIteratorState iter = graph.getEdgeProps(edgeId, 0);
+        EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, 0);
         assertEquals(10, iter.getDistance(), 1e-5);
 
         edgeId = iter2.getEdge();
-        iter = graph.getEdgeProps(edgeId, 0);
+        iter = graph.getEdgeIteratorState(edgeId, 0);
         assertEquals(2, iter.getBaseNode());
         assertEquals(0, iter.getAdjNode());
         assertEquals(20, iter.getDistance(), 1e-5);
 
-        iter = graph.getEdgeProps(edgeId, 2);
+        iter = graph.getEdgeIteratorState(edgeId, 2);
         assertEquals(0, iter.getBaseNode());
         assertEquals(2, iter.getAdjNode());
         assertEquals(20, iter.getDistance(), 1e-5);
 
-        iter = graph.getEdgeProps(edgeId, Integer.MIN_VALUE);
+        iter = graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE);
         assertFalse(iter == null);
         assertEquals(0, iter.getBaseNode());
         assertEquals(2, iter.getAdjNode());
-        iter = graph.getEdgeProps(edgeId, 1);
+        iter = graph.getEdgeIteratorState(edgeId, 1);
         assertTrue(iter == null);
 
         // delete
@@ -763,7 +763,7 @@ public void testEdgeProperties()
         // throw exception if accessing deleted edge
         try
         {
-            graph.getEdgeProps(iter1.getEdge(), -1);
+            graph.getEdgeIteratorState(iter1.getEdge(), -1);
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -773,26 +773,26 @@ public void testEdgeProperties()
     @Test
     public void testCreateDuplicateEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(2, 1, 12, true);
         graph.edge(2, 3, 12, true);
         graph.edge(2, 3, 13, false);
         assertEquals(3, GHUtility.count(carOutExplorer.setBaseNode(2)));
 
         // no exception        
-        graph.getEdgeProps(1, 3);
+        graph.getEdgeIteratorState(1, 3);
 
         // raise exception
         try
         {
-            graph.getEdgeProps(4, 3);
+            graph.getEdgeIteratorState(4, 3);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
         try
         {
-            graph.getEdgeProps(-1, 3);
+            graph.getEdgeIteratorState(-1, 3);
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -800,13 +800,13 @@ public void testCreateDuplicateEdges()
 
         EdgeIterator iter = carOutExplorer.setBaseNode(2);
         assertTrue(iter.next());
-        EdgeIteratorState oneIter = graph.getEdgeProps(iter.getEdge(), 3);
+        EdgeIteratorState oneIter = graph.getEdgeIteratorState(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
         assertTrue(carEncoder.isForward(oneIter.getFlags()));
         assertFalse(carEncoder.isBackward(oneIter.getFlags()));
 
-        oneIter = graph.getEdgeProps(iter.getEdge(), 2);
+        oneIter = graph.getEdgeIteratorState(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
         assertFalse(carEncoder.isForward(oneIter.getFlags()));
@@ -819,7 +819,7 @@ public void testCreateDuplicateEdges()
     @Test
     public void testIdenticalNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 0, 100, true);
         assertEquals(1, GHUtility.count(carAllExplorer.setBaseNode(0)));
     }
@@ -827,7 +827,7 @@ public void testIdenticalNodes()
     @Test
     public void testIdenticalNodes2()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 0, 100, false);
         graph.edge(0, 0, 100, false);
         assertEquals(2, GHUtility.count(carAllExplorer.setBaseNode(0)));
@@ -836,7 +836,7 @@ public void testIdenticalNodes2()
     @Test
     public void testEdgeReturn()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter = graph.edge(4, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false));
         assertEquals(4, iter.getBaseNode());
         assertEquals(10, iter.getAdjNode());
@@ -848,7 +848,7 @@ public void testEdgeReturn()
     @Test
     public void testPillarNodes()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.01, 0.01);
         na.setNode(4, 0.4, 0.4);
@@ -898,7 +898,7 @@ public void testPillarNodes()
     @Test
     public void testFootMix()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
         graph.edge(0, 2).setDistance(10).setFlags(carEncoder.setProperties(10, true, true));
         graph.edge(0, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true) | carEncoder.setProperties(10, true, true));
@@ -910,7 +910,7 @@ public void testFootMix()
     @Test
     public void testGetAllEdges()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         graph.edge(3, 1, 1, false);
         graph.edge(3, 2, 1, false);
@@ -938,7 +938,7 @@ public void testGetAllEdges()
     @Test
     public void testGetAllEdgesWithDelete()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0, 5);
         na.setNode(1, 1, 5);
@@ -950,26 +950,26 @@ public void testGetAllEdgesWithDelete()
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getCount());
+        assertEquals(4, iter.getMaxId());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getCount());
+        assertEquals(4, iter.getMaxId());
 
         iter = graph.getAllEdges();
-        iter.next();
+        assertTrue(iter.next());
         EdgeIteratorState eState = iter.detach(false);
         assertEquals(iter.toString(), eState.toString());
-        iter.next();
+        assertTrue(iter.next());
         assertNotEquals(iter.toString(), eState.toString());
 
         EdgeIteratorState eState2 = iter.detach(true);
         assertEquals(iter.getAdjNode(), eState2.getBaseNode());
-        iter.next();
-        assertNotEquals(iter.getAdjNode(), eState2.getBaseNode());
+        assertEquals(iter.getBaseNode(), eState2.getAdjNode());
+        assertFalse(iter.next());
     }
 
     public static void assertPList( PointList expected, PointList list )
@@ -1013,15 +1013,15 @@ public static int getIdOf( Graph g, double latitude, double longitude )
     @Test
     public void testNameIndex()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         EdgeIteratorState iter1 = graph.edge(0, 1, 10, true);
         iter1.setName("named street1");
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 10, true);
         iter2.setName("named street2");
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
     }
 
     @Test
@@ -1063,7 +1063,7 @@ public void test8BytesFlags()
     @Test
     public void testEnabledElevation()
     {
-        graph = createGraph(defaultGraphLoc, true);
+        graph = createGHStorage(defaultGraphLoc, true);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 20, -10);
@@ -1080,7 +1080,7 @@ public void testEnabledElevation()
     @Test
     public void testDetachEdge()
     {
-        graph = createGraph();
+        graph = createGHStorage();
         graph.edge(0, 1, 2, true);
         long flags = carEncoder.setProperties(10, true, false);
         graph.edge(0, 2, 2, true).setWayGeometry(Helper.createPointList(1, 2, 3, 4)).setFlags(flags);
@@ -1097,35 +1097,37 @@ public void testDetachEdge()
         }
 
         iter.next();
-        EdgeIteratorState edgeState2 = iter.detach(false);
+        EdgeIteratorState edgeState02 = iter.detach(false);
         assertEquals(2, iter.getAdjNode());
-        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertEquals(2, edgeState2.getAdjNode());
-        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
-
-        EdgeIteratorState edgeState3 = iter.detach(true);
-        assertEquals(0, edgeState3.getAdjNode());
-        assertEquals(2, edgeState3.getBaseNode());
-        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
-        assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
-        assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
+        assertEquals(1, edgeState02.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(2, edgeState02.getAdjNode());
+        assertTrue(carEncoder.isForward(edgeState02.getFlags()));
+
+        EdgeIteratorState edgeState20 = iter.detach(true);
+        assertEquals(0, edgeState20.getAdjNode());
+        assertEquals(2, edgeState20.getBaseNode());
+        assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertFalse(carEncoder.isForward(edgeState20.getFlags()));
+        assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState02.getFlags());
+        assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState20.getFlags());
 
         iter.next();
         assertEquals(1, iter.getAdjNode());
-        assertEquals(2, edgeState2.getAdjNode());
-        assertEquals(2, edgeState3.getBaseNode());
+        assertEquals(2, edgeState02.getAdjNode());
+        assertEquals(2, edgeState20.getBaseNode());
 
         assertEquals(0, iter.fetchWayGeometry(0).size());
-        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(1, edgeState02.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
 
         // #162 a directed self referencing edge should be able to reverse its state too
         graph.edge(3, 3, 2, true).setFlags(flags);
-        EdgeIterator iter2 = graph.createEdgeExplorer().setBaseNode(3);
-        iter2.next();
-        assertEquals(edgeState2.getFlags(), iter2.detach(false).getFlags());
-        assertEquals(edgeState3.getFlags(), iter2.detach(true).getFlags());
+        EdgeIterator edgeState33 = graph.createEdgeExplorer().setBaseNode(3);
+        edgeState33.next();
+        assertEquals(3, edgeState33.getBaseNode());
+        assertEquals(3, edgeState33.getAdjNode());
+        assertEquals(edgeState02.getFlags(), edgeState33.detach(false).getFlags());
+        assertEquals(edgeState20.getFlags(), edgeState33.detach(true).getFlags());
     }
 
     static class TmpCarFlagEncoder extends CarFlagEncoder
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
index 6e73952da5..ad50056f67 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -20,10 +20,14 @@
 
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.After;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -84,7 +88,7 @@ public void testForceDelete()
         // on windows we cannot forcefully remove an unreleased lock
         if (Constants.WINDOWS)
             lock.release();
-        
+
         instance.forceRemove(lock.getName(), true);
         assertFalse(lock.isLocked());
     }
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index f5ae8eb1d9..6beee78b72 100644
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -19,15 +19,18 @@
 
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
 import java.nio.ByteOrder;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public abstract class DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/EdgeTest.java b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
index 6d840af599..cdc47c664f 100644
--- a/core/src/test/java/com/graphhopper/storage/EdgeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/EdgeTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.util.EdgeIterator;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeTest
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
new file mode 100644
index 0000000000..5078761945
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -0,0 +1,349 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+import java.io.IOException;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperStorageCHTest extends GraphHopperStorageTest
+{
+    protected CHGraph getGraph( GraphHopperStorage ghStorage )
+    {
+        return ghStorage.getGraph(CHGraph.class);
+    }
+
+    @Override
+    public GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
+    {
+        return new GraphHopperStorage(true, dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
+    }
+
+    @Test
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
+    {
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph.flush();
+        graph.close();
+
+        graph = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
+        try
+        {
+            graph.loadExisting();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
+        assertTrue(graph.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(graph.getBounds(), BBox.createInverse(false));
+    }
+
+    @Test
+    public void testPrios()
+    {
+        graph = createGHStorage();
+        CHGraph g = getGraph(graph);
+        g.getNodeAccess().ensureNode(30);
+        graph.freeze();
+
+        assertEquals(0, g.getLevel(10));
+
+        g.setLevel(10, 100);
+        assertEquals(100, g.getLevel(10));
+
+        g.setLevel(30, 100);
+        assertEquals(100, g.getLevel(30));
+    }
+
+    @Test
+    public void testEdgeFilter()
+    {
+        graph = createGHStorage();
+        CHGraph g = getGraph(graph);
+        g.edge(0, 1, 10, true);
+        g.edge(0, 2, 20, true);
+        g.edge(2, 3, 30, true);
+        g.edge(10, 11, 1, true);
+
+        graph.freeze();
+        CHEdgeIteratorState tmpIter = g.shortcut(3, 4);
+        tmpIter.setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
+        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
+
+        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        g.setLevel(0, 1);
+        g.setLevel(4, 1);
+
+        EdgeIterator iter = g.createEdgeExplorer(new LevelEdgeFilter(g)).setBaseNode(0);
+        assertEquals(1, GHUtility.count(iter));
+        iter = g.createEdgeExplorer().setBaseNode(2);
+        assertEquals(2, GHUtility.count(iter));
+
+        tmpIter = g.shortcut(5, 6);
+        tmpIter.setSkippedEdges(1, 2);
+        assertEquals(1, tmpIter.getSkippedEdge1());
+        assertEquals(2, tmpIter.getSkippedEdge2());
+    }
+
+    @Test
+    public void testDisconnectEdge()
+    {
+        graph = createGHStorage();
+        CHGraphImpl lg = (CHGraphImpl) getGraph(graph);
+
+        EdgeExplorer chCarOutExplorer = lg.createEdgeExplorer(carOutFilter);
+        EdgeExplorer tmpCarInExplorer = lg.createEdgeExplorer(carInFilter);
+
+        EdgeExplorer baseCarOutExplorer = graph.createEdgeExplorer(carOutFilter);
+
+        // only remove edges
+        long flags = carEncoder.setProperties(60, true, true);
+        long flags2 = carEncoder.setProperties(60, true, false);
+        lg.edge(4, 1, 30, true);
+        graph.freeze();
+        CHEdgeIteratorState tmp = lg.shortcut(1, 2);
+        tmp.setDistance(10).setFlags(flags);
+        tmp.setSkippedEdges(10, 11);
+        tmp = lg.shortcut(1, 0);
+        tmp.setDistance(20).setFlags(flags2);
+        tmp.setSkippedEdges(12, 13);
+        tmp = lg.shortcut(3, 1);
+        tmp.setDistance(30).setFlags(flags2);
+        tmp.setSkippedEdges(14, 15);
+        // create everytime a new independent iterator for disconnect method
+        EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(1);
+        iter.next();
+        assertEquals(3, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(chCarOutExplorer.setBaseNode(3)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(chCarOutExplorer.setBaseNode(3)));
+        // no shortcuts visible
+        assertEquals(0, GHUtility.count(baseCarOutExplorer.setBaseNode(3)));
+
+        // even directed ways change!
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(tmpCarInExplorer.setBaseNode(0)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(tmpCarInExplorer.setBaseNode(0)));
+
+        iter.next();
+        assertEquals(2, iter.getAdjNode());
+        assertEquals(1, GHUtility.count(chCarOutExplorer.setBaseNode(2)));
+        lg.disconnect(lg.createEdgeExplorer(), iter);
+        assertEquals(0, GHUtility.count(chCarOutExplorer.setBaseNode(2)));
+
+        assertEquals(GHUtility.asSet(0, 2, 4), GHUtility.getNeighbors(chCarOutExplorer.setBaseNode(1)));
+        assertEquals(GHUtility.asSet(4), GHUtility.getNeighbors(baseCarOutExplorer.setBaseNode(1)));
+    }
+
+    @Test
+    public void testGetWeight()
+    {
+        graph = createGHStorage();
+        CHGraphImpl g = (CHGraphImpl) getGraph(graph);
+        assertFalse(g.edge(0, 1).isShortcut());
+        assertFalse(g.edge(1, 2).isShortcut());
+
+        graph.freeze();
+
+        // only remove edges
+        long flags = carEncoder.setProperties(10, true, true);
+        CHEdgeIteratorState sc1 = g.shortcut(0, 1);
+        assertTrue(sc1.isShortcut());
+        sc1.setWeight(2.001);
+        assertEquals(2.001, sc1.getWeight(), 1e-3);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        sc1.setWeight(Double.MAX_VALUE);
+        assertTrue(Double.isInfinite(sc1.getWeight()));
+
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertTrue(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
+
+        flags = carEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertFalse(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
+    }
+
+    @Test
+    public void testGetWeightIfAdvancedEncoder()
+    {
+        FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
+        graph = new GraphBuilder(new EncodingManager(customEncoder)).setCHGraph(true).create();
+        graph.edge(0, 2);
+        graph.freeze();
+
+        CHGraphImpl lg = (CHGraphImpl) graph.getGraph(CHGraph.class);
+        CHEdgeIteratorState sc1 = lg.shortcut(0, 1);
+        long flags = customEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
+
+        sc1 = lg.shortcut(1, 0);
+        assertTrue(sc1.isShortcut());
+        sc1.setFlags(PrepareEncoder.getScDirMask());
+        sc1.setWeight(1.011011);
+        assertEquals(1.011011, sc1.getWeight(), 1e-3);
+    }
+
+    @Test
+    public void testQueryGraph()
+    {
+        graph = createGHStorage();
+        CHGraph chGraph = getGraph(graph);
+        NodeAccess na = chGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = chGraph.edge(0, 1);
+        chGraph.edge(1, 2);
+        graph.freeze();
+        chGraph.shortcut(0, 1);
+
+        QueryGraph qGraph = new QueryGraph(chGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph baseGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = baseGraph.createEdgeExplorer();
+
+        assertTrue(chGraph.getNodes() < qGraph.getNodes());
+        assertTrue(baseGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
+
+    @Test
+    @Override
+    public void testSave_and_Freeze() throws IOException
+    {
+        // belongs to each other
+        super.testSave_and_Freeze();
+        graph.close();
+        
+        // test freeze and shortcut creation & loading
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).
+                create(defaultSize);
+        graph.edge(1, 0);
+        graph.edge(8, 9);
+        graph.freeze();
+        CHGraph chGraph = getGraph(graph);
+
+        assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(1)));
+
+        chGraph.shortcut(2, 3);
+
+        // should be identical to access without shortcut
+        assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(1)));
+
+        // base graph does not see shortcut        
+        assertEquals(0, GHUtility.count(graph.createEdgeExplorer().setBaseNode(2)));
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(2)));
+
+        graph.flush();
+        graph.close();
+
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
+        assertTrue(graph.loadExisting());
+        assertTrue(graph.isFrozen());
+
+        chGraph = getGraph(graph);
+        assertEquals(10, chGraph.getNodes());
+        assertEquals(2, graph.getAllEdges().getMaxId());
+        assertEquals(3, chGraph.getAllEdges().getMaxId());
+        assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(2)));
+
+        AllCHEdgesIterator iter = chGraph.getAllEdges();
+        assertTrue(iter.next());
+        assertFalse(iter.isShortcut());
+        assertEquals(0, iter.getEdge());
+        
+        assertTrue(iter.next());
+        assertFalse(iter.isShortcut());
+        assertEquals(1, iter.getEdge());
+        
+        assertTrue(iter.next());
+        assertTrue(iter.isShortcut());
+        assertEquals(2, iter.getEdge());
+        assertFalse(iter.next());
+    }
+
+    @Test
+    public void testSimpleShortcutCreationAndTraversal()
+    {
+        graph = createGHStorage();
+        graph.edge(1, 3, 10, true);
+        graph.edge(3, 4, 10, true);
+        graph.freeze();
+
+        CHGraph lg = graph.getGraph(CHGraph.class);
+        lg.shortcut(1, 4).setWeight(3).setFlags(carEncoder.setProperties(10, true, true));
+
+        EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
+        // iteration should result in same nodes even if reusing the iterator
+        assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
+        assertEquals(GHUtility.asSet(3, 4), GHUtility.getNeighbors(vehicleOutExplorer.setBaseNode(1)));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index ff4bdbacc0..46ec091388 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -19,27 +19,29 @@
 
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperStorageTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, boolean enabled3D )
+    public GraphHopperStorage createGHStorage( String location, boolean enabled3D )
     {
         // reduce segment size in order to test the case where multiple segments come into the game
-        GraphStorage gs = newGraph(new RAMDirectory(location), enabled3D);
+        GraphHopperStorage gs = newGHStorage(new RAMDirectory(location), enabled3D);
         gs.setSegmentSize(defaultSize / 2);
         gs.create(defaultSize);
         return gs;
     }
 
-    protected GraphStorage newGraph( Directory dir, boolean enabled3D )
+    protected GraphHopperStorage newGHStorage( Directory dir, boolean enabled3D )
     {
         return new GraphHopperStorage(dir, encodingManager, enabled3D);
     }
@@ -47,10 +49,10 @@ protected GraphStorage newGraph( Directory dir, boolean enabled3D )
     @Test
     public void testNoCreateCalled() throws IOException
     {
-        GraphHopperStorage gs = (GraphHopperStorage) new GraphBuilder(encodingManager).build();
+        GraphHopperStorage gs = new GraphBuilder(encodingManager).build();
         try
         {
-            gs.ensureNodeIndex(123);
+            ((BaseGraph) gs.getGraph(Graph.class)).ensureNodeIndex(123);
             assertFalse("AssertionError should be raised", true);
         } catch (AssertionError err)
         {
@@ -67,7 +69,7 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 10, 0);
@@ -89,24 +91,40 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
         checkGraph(graph);
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
         graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
+    @Test
+    public void testSave_and_Freeze() throws IOException
+    {
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph.edge(1, 0);
+        graph.freeze();
+
+        graph.flush();
+        graph.close();
+
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
+        assertTrue(graph.loadExisting());
+        assertEquals(2, graph.getNodes());
+        assertTrue(graph.isFrozen());
+    }
+
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
         assertTrue(na.is3D());
         assertTrue(g.getBounds().isValid());
-        
+
         assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
@@ -144,7 +162,8 @@ protected void checkGraph( Graph g )
     @Test
     public void internalDisconnect()
     {
-        GraphHopperStorage graph = (GraphHopperStorage) createGraph();
+        GraphHopperStorage storage = createGHStorage();
+        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
         EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(1, 2, 10, true);
         EdgeIteratorState iter3 = graph.edge(0, 3, 10, true);
@@ -154,25 +173,27 @@ public void internalDisconnect()
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(2, 0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         // remove edge "1-2" but only from 1 not from 2
-        graph.internalEdgeDisconnect(iter2.getEdge(), -1, iter2.getBaseNode(), iter2.getAdjNode());
+        graph.edgeAccess.internalEdgeDisconnect(iter2.getEdge(), -1,
+                iter2.getBaseNode(), iter2.getAdjNode());
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(1), GHUtility.getNeighbors(explorer.setBaseNode(2)));
         // let 0 unchanged -> no side effects
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
 
         // remove edge "0-1" but only from 0
-        graph.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes, iter0.getBaseNode(), iter0.getAdjNode());
+        graph.edgeAccess.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes,
+                iter0.getBaseNode(), iter0.getAdjNode());
         assertEquals(GHUtility.asSet(3), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(3)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
-        graph.close();
+        storage.close();
     }
 
     @Test
     public void testEnsureSize()
     {
         Directory dir = new RAMDirectory();
-        graph = newGraph(dir, false).create(defaultSize);
+        graph = newGHStorage(dir, false).create(defaultSize);
         int testIndex = dir.find("edges").getSegmentSize() * 3;
         graph.edge(0, testIndex, 10, true);
 
@@ -186,7 +207,7 @@ public void testBigDataEdge()
         Directory dir = new RAMDirectory();
         GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false);
         graph.create(defaultSize);
-        graph.setEdgeCount(Integer.MAX_VALUE / 2);
+        ((BaseGraph) graph.getGraph(Graph.class)).setEdgeCount(Integer.MAX_VALUE / 2);
         assertTrue(graph.getAllEdges().next());
         graph.close();
     }
@@ -194,19 +215,113 @@ public void testBigDataEdge()
     @Test
     public void testDoThrowExceptionIfDimDoesNotMatch()
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false);
         graph.create(1000);
         graph.flush();
         graph.close();
 
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
         try
         {
             graph.loadExisting();
             assertTrue(false);
         } catch (Exception ex)
         {
-
         }
     }
+
+    @Test
+    public void testIdentical()
+    {
+        GraphHopperStorage store = new GraphHopperStorage(new RAMDirectory(), encodingManager, true);
+        assertEquals(store.getNodes(), store.getGraph(Graph.class).getNodes());
+        assertEquals(store.getAllEdges().getMaxId(), store.getGraph(Graph.class).getAllEdges().getMaxId());
+    }
+
+    public void testAdditionalEdgeField()
+    {
+        GraphExtension extStorage = new GraphExtension()
+        {
+            @Override
+            public boolean isRequireNodeField()
+            {
+                return false;
+            }
+
+            @Override
+            public boolean isRequireEdgeField()
+            {
+                return true;
+            }
+
+            @Override
+            public int getDefaultNodeFieldValue()
+            {
+                throw new UnsupportedOperationException("Not supported.");
+            }
+
+            @Override
+            public int getDefaultEdgeFieldValue()
+            {
+                return 2;
+            }
+
+            @Override
+            public void init( Graph graph, Directory dir )
+            {
+            }
+
+            @Override
+            public void setSegmentSize( int bytes )
+            {
+
+            }
+
+            @Override
+            public GraphExtension copyTo( GraphExtension extStorage )
+            {
+                return this;
+            }
+
+            @Override
+            public boolean loadExisting()
+            {
+                return true;
+            }
+
+            @Override
+            public GraphExtension create( long byteCount )
+            {
+                return this;
+            }
+
+            @Override
+            public void flush()
+            {
+            }
+
+            @Override
+            public void close()
+            {
+            }
+
+            @Override
+            public boolean isClosed()
+            {
+                return false;
+            }
+
+            @Override
+            public long getCapacity()
+            {
+                return 0;
+            }
+        };
+
+        GraphHopperStorage storage = new GraphHopperStorage(false, new RAMDirectory(), encodingManager, false, extStorage);
+        storage.create(1000);
+        EdgeIteratorState iter = storage.edge(0, 1, 10, true);
+
+        assertEquals(extStorage.getDefaultEdgeFieldValue(), iter.getAdditionalField());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index e624d5ce83..f9a5b53942 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -28,7 +28,6 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- *
  * @author Karl Hbner
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
@@ -36,23 +35,17 @@
     private TurnCostExtension turnCostStorage;
 
     @Override
-    protected GraphStorage newGraph( Directory dir, boolean is3D )
+    protected GraphHopperStorage newGHStorage( Directory dir, boolean is3D )
     {
         turnCostStorage = new TurnCostExtension();
-        return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
-    }
-
-    @Override
-    protected GraphStorage newRAMGraph()
-    {
-        return newGraph(new RAMDirectory(), false);
+        return new GraphHopperStorage(false, dir, encodingManager, is3D, turnCostStorage);
     }
 
     @Override
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
         assertTrue(na.is3D());
         na.setNode(0, 10, 10, 0);
@@ -78,14 +71,14 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
         checkGraph(graph);
 
-        assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
-        assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
+        assertEquals("named street1", graph.getEdgeIteratorState(iter1.getEdge(), iter1.getAdjNode()).getName());
+        assertEquals("named street2", graph.getEdgeIteratorState(iter2.getEdge(), iter2.getAdjNode()).getName());
 
         assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
         assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
@@ -99,7 +92,7 @@ public void testSave_and_fileFormat() throws IOException
     @Test
     public void testEnsureCapacity() throws IOException
     {
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGHStorage(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
index 3a69d6c9af..adf8352501 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
@@ -23,9 +23,9 @@
 public class GraphStorageViaMMapTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, boolean is3D )
+    public GraphHopperStorage createGHStorage( String location, boolean is3D )
     {
-        GraphStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
+        GraphHopperStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
         gs.setSegmentSize(defaultSize / 2);
         gs.create(defaultSize);
         return gs;
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
deleted file mode 100644
index b7c216b4fb..0000000000
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.BBox;
-import static org.junit.Assert.*;
-import org.junit.Test;
-
-/**
- * @author Peter Karich
- */
-public class LevelGraphStorageTest extends GraphHopperStorageTest
-{
-    @Override
-    protected LevelGraphStorage createGraph()
-    {
-        return (LevelGraphStorage) super.createGraph();
-    }
-
-    @Override
-    public GraphStorage newGraph( Directory dir, boolean is3D )
-    {
-        return new LevelGraphStorage(dir, encodingManager, is3D);
-    }
-
-    @Test
-    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
-    {
-        GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
-        g.flush();
-        g.close();
-
-        g = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
-        try
-        {
-            g.loadExisting();
-            assertTrue(false);
-        } catch (Exception ex)
-        {
-        }
-
-        g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
-        assertTrue(g.loadExisting());
-        // empty graph still has invalid bounds
-        assertEquals(g.getBounds(), BBox.createInverse(false));
-    }
-
-    @Test
-    public void testPriosWhileDeleting()
-    {
-        LevelGraphStorage g = createGraph();
-        g.getNodeAccess().ensureNode(19);
-        for (int i = 0; i < 20; i++)
-        {
-            g.setLevel(i, i);
-        }
-        g.markNodeRemoved(10);
-        g.optimize();
-        assertEquals(9, g.getLevel(9));
-        assertNotSame(10, g.getLevel(10));
-    }
-
-    @Test
-    public void testPrios()
-    {
-        LevelGraph g = createGraph();
-        g.getNodeAccess().ensureNode(30);
-
-        assertEquals(0, g.getLevel(10));
-
-        g.setLevel(10, 100);
-        assertEquals(100, g.getLevel(10));
-
-        g.setLevel(30, 100);
-        assertEquals(100, g.getLevel(30));
-    }
-
-    @Test
-    public void testEdgeFilter()
-    {
-        LevelGraph g = createGraph();
-        g.edge(0, 1, 10, true);
-        g.edge(0, 2, 20, true);
-        g.edge(2, 3, 30, true);
-        EdgeSkipIterState tmpIter = g.shortcut(3, 4);
-        tmpIter.setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
-
-        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
-        g.setLevel(0, 1);
-        g.setLevel(4, 1);
-
-        EdgeIterator iter = g.createEdgeExplorer(new LevelEdgeFilter(g)).setBaseNode(0);
-        assertEquals(1, GHUtility.count(iter));
-        iter = g.createEdgeExplorer().setBaseNode(2);
-        assertEquals(2, GHUtility.count(iter));
-    }
-
-    @Test
-    public void testDisconnectEdge()
-    {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        // only remove edges
-        long flags = carEncoder.setProperties(60, true, true);
-        long flags2 = carEncoder.setProperties(60, true, false);
-        g.edge(4, 1, 30, true);
-        EdgeSkipIterState tmp = g.shortcut(1, 2);
-        tmp.setDistance(10).setFlags(flags);
-        tmp.setSkippedEdges(10, 11);
-        tmp = g.shortcut(1, 0);
-        tmp.setDistance(20).setFlags(flags2);
-        tmp.setSkippedEdges(12, 13);
-        tmp = g.shortcut(3, 1);
-        tmp.setDistance(30).setFlags(flags2);
-        tmp.setSkippedEdges(14, 15);
-        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(1);
-        iter.next();
-        assertEquals(3, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carOutExplorer.setBaseNode(3)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carOutExplorer.setBaseNode(3)));
-
-        // even directed ways change!
-        assertTrue(iter.next());
-        assertEquals(0, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carInExplorer.setBaseNode(0)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carInExplorer.setBaseNode(0)));
-
-        iter.next();
-        assertEquals(2, iter.getAdjNode());
-        assertEquals(1, GHUtility.count(carOutExplorer.setBaseNode(2)));
-        g.disconnect(g.createEdgeExplorer(), iter);
-        assertEquals(0, GHUtility.count(carOutExplorer.setBaseNode(2)));
-    }
-
-    @Test
-    public void testGetWeight()
-    {
-        LevelGraphStorage g = (LevelGraphStorage) createGraph();
-        assertFalse(g.edge(0, 1).isShortcut());
-        assertFalse(g.edge(1, 2).isShortcut());
-
-        // only remove edges
-        long flags = carEncoder.setProperties(10, true, true);
-        EdgeSkipIterState sc1 = g.shortcut(0, 1);
-        assertTrue(sc1.isShortcut());
-        sc1.setWeight(2.001);
-        assertEquals(2.001, sc1.getWeight(), 1e-3);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        sc1.setWeight(Double.MAX_VALUE);
-        assertTrue(Double.isInfinite(sc1.getWeight()));
-
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isForward(sc1.getFlags()));
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-
-        flags = carEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertFalse(carEncoder.isForward(sc1.getFlags()));
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-    }
-
-    @Test
-    public void testGetWeightIfAdvancedEncoder()
-    {
-        FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
-        LevelGraphStorage g = new GraphBuilder(new EncodingManager(customEncoder)).levelGraphCreate();
-
-        EdgeSkipIterState sc1 = g.shortcut(0, 1);
-        long flags = customEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
-
-        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
-        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
-        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
-        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
-
-        sc1 = g.shortcut(1, 0);
-        assertTrue(sc1.isShortcut());
-        sc1.setFlags(PrepareEncoder.getScDirMask());
-        sc1.setWeight(1.011011);
-        assertEquals(1.011011, sc1.getWeight(), 1e-3);
-    }
-
-    @Test
-    public void testQueryGraph()
-    {
-        LevelGraph levelGraph = createGraph();
-        NodeAccess na = levelGraph.getNodeAccess();
-        na.setNode(0, 1.00, 1.00);
-        na.setNode(1, 1.02, 1.00);
-        na.setNode(2, 1.04, 1.00);
-
-        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
-        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
-        levelGraph.shortcut(0, 1);
-        
-        QueryGraph qGraph = new QueryGraph(levelGraph);
-        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
-        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
-        qGraph.lookup(fromRes, toRes);
-
-        Graph oGraph = qGraph.getBaseGraph();
-        EdgeExplorer explorer = oGraph.createEdgeExplorer();
-
-        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
-        assertTrue(oGraph.getNodes() == qGraph.getNodes());
-
-        // traverse virtual edges and normal edges but no shortcuts!
-        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
-        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
-
-        // get neighbors from virtual nodes
-        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
-        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
-    }
-
-    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
-    {
-        QueryResult res = new QueryResult(lat, lon);
-        res.setClosestEdge(edge);
-        res.setWayIndex(wayIndex);
-        res.setSnappedPosition(QueryResult.Position.EDGE);
-        res.calcSnappedPoint(Helper.DIST_PLANE);
-        return res;
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index 941d81b485..261a254183 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
index 722025ebe0..738e019cc0 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class MMapDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
index ddeaa9e012..a853da7b02 100644
--- a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -19,11 +19,12 @@
 package com.graphhopper.storage;
 
 import java.nio.channels.OverlappingFileLockException;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
index 61430209fd..51ce1226b9 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
index 542d875c42..92cba0d9be 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMDirectoryTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMDirectoryTest extends AbstractDirectoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
index fae20891f4..41c28047fc 100644
--- a/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/RAMIntDataAccessTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class RAMIntDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index 1f9badefe4..ef6bb7eef9 100644
--- a/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -19,7 +19,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
diff --git a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
index d758826e03..922a87db3d 100644
--- a/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
+++ b/core/src/test/java/com/graphhopper/storage/StorablePropertiesTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class StorablePropertiesTest
diff --git a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
index cebaee0c5b..76ec1c41e3 100644
--- a/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/SynchedDAWrapperTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 /**
- *
  * @author Peter Karich
  */
 public class SynchedDAWrapperTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
index 824f6a881f..db70ee4313 100644
--- a/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/UnsafeDataAccessTest.java
@@ -18,12 +18,14 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.util.BitUtil;
+
 import java.nio.ByteOrder;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class UnsafeDataAccessTest extends DataAccessTest
diff --git a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
index 7cb369e6e1..1719234f99 100644
--- a/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/VLongStorageTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index e447b1c058..cf5ec3d9d0 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -31,11 +31,15 @@
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
+
 import java.io.Closeable;
 import java.io.File;
 import java.util.Random;
+
 import org.junit.After;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -49,6 +53,16 @@
 
     public abstract LocationIndex createIndex( Graph g, int resolution );
 
+    GraphHopperStorage createGHStorage( EncodingManager encodingManager )
+    {
+        return AbstractLocationIndexTester.this.createGHStorage(new RAMDirectory(), encodingManager, false);
+    }
+
+    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
+    {
+        return new GraphHopperStorage(dir, encodingManager, is3D).create(100);
+    }
+
     public boolean hasEdgeSupport()
     {
         return false;
@@ -71,7 +85,7 @@ public void tearDown()
     @Test
     public void testSimpleGraph()
     {
-        Graph g = createGraph(new EncodingManager("CAR"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -125,7 +139,7 @@ public void initSimpleGraph( Graph g )
     @Test
     public void testSimpleGraph2()
     {
-        Graph g = createGraph(new EncodingManager("CAR"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -248,7 +262,7 @@ public void testNoErrorOnEdgeCase_lastIndex()
     {
         final EncodingManager encodingManager = new EncodingManager("CAR");
         int locs = 10000;
-        Graph g = createGraph(new MMapDirectory(location), encodingManager, false);
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(new MMapDirectory(location), encodingManager, false);
         NodeAccess na = g.getNodeAccess();
         Random rand = new Random(12);
         for (int i = 0; i < locs; i++)
@@ -259,19 +273,9 @@ public void testNoErrorOnEdgeCase_lastIndex()
         Helper.close((Closeable) g);
     }
 
-    Graph createGraph( EncodingManager encodingManager )
-    {
-        return createGraph(new RAMDirectory(), encodingManager, false);
-    }
-
-    Graph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
-    {
-        return new GraphHopperStorage(dir, encodingManager, is3D).create(100);
-    }
-
     public Graph createSampleGraph( EncodingManager encodingManager )
     {
-        Graph graph = createGraph(encodingManager);
+        Graph graph = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         // length does not matter here but lat,lon and outgoing edges do!
 
 //        
@@ -353,7 +357,7 @@ public Graph createSampleGraph( EncodingManager encodingManager )
     public void testDifferentVehicles()
     {
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-        Graph g = createGraph(encodingManager);
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         initSimpleGraph(g);
         idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 50d76f5d68..36b61b1892 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -21,14 +21,17 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+
 import java.util.ArrayList;
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class BresenhamLineTest
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
index 5d6ef736fb..918c9c00a0 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
index dfb41251ce..65478c3cff 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDFullWithEdgesIndexTest extends AbstractLocationIndexTester
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index bb43cef11b..bbc99eaeb4 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -21,11 +21,12 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.MMapDirectory;
 import com.graphhopper.storage.RAMDirectory;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class Location2IDQuadtreeTest extends AbstractLocationIndexTester
@@ -33,7 +34,7 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        if(resolution < 0)
+        if (resolution < 0)
             resolution = 120;
         return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
                 setResolution(resolution).prepareIndex();
@@ -42,7 +43,7 @@ public LocationIndex createIndex( Graph g, int resolution )
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGHStorage(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
similarity index 71%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
index 0f3c93d92b..d165c191a9 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
@@ -19,28 +19,26 @@
 
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.TIntList;
 import gnu.trove.set.TIntSet;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
+public class LocationIndexTreeCHTest extends LocationIndexTreeTest
 {
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
@@ -54,59 +52,63 @@ public LocationIndexTree createIndex( Graph g, int resolution )
     public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        LocationIndexTree tmpIdx = new LocationIndexTree(g, dir);
         tmpIdx.setResolution(resolution);
         return tmpIdx;
     }
 
     @Override
-    LevelGraph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
+    GraphHopperStorage createGHStorage( Directory dir, EncodingManager encodingManager, boolean is3D )
     {
-        return new LevelGraphStorage(dir, encodingManager, is3D).create(100);
+        return new GraphHopperStorage(true, dir, encodingManager, is3D, new GraphExtension.NoOpExtension()).
+                create(100);
     }
 
     @Test
-    public void testLevelGraph()
+    public void testCHGraph()
     {
-        LevelGraph g = createGraph(new RAMDirectory(), encodingManager, false);
+        GraphHopperStorage ghStorage = createGHStorage(new RAMDirectory(), encodingManager, false);
+        CHGraph lg = ghStorage.getGraph(CHGraph.class);
         // 0
         // 1
         // 2
         //  3
         //   4
-        NodeAccess na = g.getNodeAccess();
+        NodeAccess na = ghStorage.getNodeAccess();
         na.setNode(0, 1, 0);
         na.setNode(1, 0.5, 0);
         na.setNode(2, 0, 0);
         na.setNode(3, -1, 1);
         na.setNode(4, -2, 2);
 
-        EdgeIteratorState iter1 = g.edge(0, 1, 10, true);
-        EdgeIteratorState iter2 = g.edge(1, 2, 10, true);
-        EdgeIteratorState iter3 = g.edge(2, 3, 14, true);
-        EdgeIteratorState iter4 = g.edge(3, 4, 14, true);
+        EdgeIteratorState iter1 = ghStorage.edge(0, 1, 10, true);
+        EdgeIteratorState iter2 = ghStorage.edge(1, 2, 10, true);
+        EdgeIteratorState iter3 = ghStorage.edge(2, 3, 14, true);
+        EdgeIteratorState iter4 = ghStorage.edge(3, 4, 14, true);
 
         // create shortcuts
+        ghStorage.freeze();
         FlagEncoder car = encodingManager.getEncoder("CAR");
         long flags = car.setProperties(60, true, true);
-        EdgeSkipIterState iter5 = g.shortcut(0, 2);
+        CHEdgeIteratorState iter5 = lg.shortcut(0, 2);
         iter5.setDistance(20).setFlags(flags);
         iter5.setSkippedEdges(iter1.getEdge(), iter2.getEdge());
-        EdgeSkipIterState iter6 = g.shortcut(2, 4);
+        CHEdgeIteratorState iter6 = lg.shortcut(2, 4);
         iter6.setDistance(28).setFlags(flags);
         iter6.setSkippedEdges(iter3.getEdge(), iter4.getEdge());
-        EdgeSkipIterState tmp = g.shortcut(0, 4);
+        CHEdgeIteratorState tmp = lg.shortcut(0, 4);
         tmp.setDistance(40).setFlags(flags);
         tmp.setSkippedEdges(iter5.getEdge(), iter6.getEdge());
 
-        LocationIndex index = createIndex(g, -1);
+        LocationIndex index = createIndex(ghStorage, -1);
         assertEquals(2, index.findID(0, 0.5));
     }
 
     @Test
     public void testSortHighLevelFirst()
     {
-        final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
+        final CHGraph lg = g.getGraph(CHGraph.class);
         lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
@@ -129,7 +131,7 @@ public int compare( Integer o1, Integer o2 )
     }
 
     @Test
-    public void testLevelGraphBug()
+    public void testCHGraphBug()
     {
         // 0
         // |
@@ -137,15 +139,17 @@ public void testLevelGraphBug()
         // |
         // 1
 
-        LevelGraphStorage lg = (LevelGraphStorage) createGraph(new RAMDirectory(), encodingManager, false);
-        NodeAccess na = lg.getNodeAccess();
+        GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = g.getNodeAccess();
         na.setNode(0, 1, 0);
         na.setNode(1, 0, 0);
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
-        EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        lg.edge(2, 3, 100, true);
+        EdgeIteratorState iter1 = g.edge(1, 0, 100, true);
+        g.edge(2, 3, 100, true);
 
+        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
+        g.freeze();
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
         // disconnect higher 0 from lower 1
@@ -156,17 +160,18 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTree index = createIndex(lg, 100000);
+        LocationIndexTree index = createIndex(g, 100000);
 
         // very close to 2, but should match the edge 0--1
         TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
-        assertEquals(0, index.findID(0.51, 0.2));
-        assertEquals(1, index.findID(0.1, 0.1));
-        assertEquals(2, index.findID(0.51, 0.51));
-        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
         expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
+
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index f4a24cfc41..5e06c00993 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -26,12 +26,14 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+
 import java.util.Arrays;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class LocationIndexTreeTest extends AbstractLocationIndexTester
@@ -43,7 +45,7 @@
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
         if (resolution < 0)
-            resolution = 500000;        
+            resolution = 500000;
         return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
@@ -68,7 +70,7 @@ public boolean hasEdgeSupport()
     // 2---/---/
     Graph createTestGraph()
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
         na.setNode(1, -0.5, -0.5);
@@ -132,7 +134,7 @@ public void testInMemIndex()
         // The optimization if(dist > normedHalf) => feed nodeA or nodeB
         // although this reduces chance of nodes outside of the tile
         // in practice it even increases file size!?
-        // Is this due to the LevelGraph disconnect problem?
+        // Is this due to the CHGraph disconnect problem?
 //        set.clear();
 //        set.add(4);
 //        assertEquals(set, index.findNetworkEntries(-0.7, 1.5));
@@ -214,7 +216,7 @@ public void testReverseSpatialKey()
     @Test
     public void testMoreReal()
     {
-        Graph graph = createGraph(new EncodingManager("CAR"));
+        Graph graph = createGHStorage(new EncodingManager("CAR"));
         NodeAccess na = graph.getNodeAccess();
         na.setNode(1, 51.2492152, 9.4317166);
         na.setNode(0, 52, 9);
@@ -239,7 +241,7 @@ public void testMoreReal()
     //  |
     private Graph createTestGraphWithWayGeometry()
     {
-        Graph graph = createGraph(encodingManager);
+        Graph graph = createGHStorage(encodingManager);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 0.5, -0.5);
         na.setNode(1, -0.5, -0.5);
@@ -271,7 +273,7 @@ public void testWayGeometry()
     @Test
     public void testFindingWayGeometry()
     {
-        Graph g = createGraph(encodingManager);
+        Graph g = createGHStorage(encodingManager);
         NodeAccess na = g.getNodeAccess();
         na.setNode(10, 51.2492152, 9.4317166);
         na.setNode(20, 52, 9);
@@ -305,7 +307,7 @@ public boolean accept( EdgeIteratorState iter )
     // see testgraph2.jpg
     Graph createTestGraph2()
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        Graph graph = createGHStorage(new RAMDirectory(), encodingManager, false);
         NodeAccess na = graph.getNodeAccess();
         na.setNode(8, 49.94553, 11.57214);
         na.setNode(9, 49.94553, 11.57314);
diff --git a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
index 48a9fc00ac..945b3fee3c 100644
--- a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
+++ b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index f41b24ae4b..e5257f79c7 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
@@ -91,4 +92,30 @@ public void testAtan2()
         assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
         assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
     }
+    
+    @Test
+    public void testConvertAzimuth2xaxisAngle()
+    {
+        assertEquals(Math.PI/2, ac.convertAzimuth2xaxisAngle(0), 1E-6);
+        assertEquals(Math.PI/2, Math.abs(ac.convertAzimuth2xaxisAngle(360)), 1E-6);
+        assertEquals(0, ac.convertAzimuth2xaxisAngle(90), 1E-6);
+        assertEquals(-Math.PI/2, ac.convertAzimuth2xaxisAngle(180), 1E-6);
+        assertEquals(Math.PI, Math.abs(ac.convertAzimuth2xaxisAngle(270)), 1E-6);
+        assertEquals(-3*Math.PI/4, ac.convertAzimuth2xaxisAngle(225), 1E-6);
+        assertEquals(3*Math.PI/4, ac.convertAzimuth2xaxisAngle(315), 1E-6);
+    }
+    
+    @Test
+    public void checkAzimuthConsitency()
+    {
+        double azimuthDegree =  ac.calcAzimuth(0, 0, 1, 1);
+        double radianXY = ac.calcOrientation(0, 0, 1, 1);
+        double radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+
+        azimuthDegree =  ac.calcAzimuth(0, 4, 1, 3);
+        radianXY = ac.calcOrientation(0, 4, 1, 3);
+        radian2 = ac.convertAzimuth2xaxisAngle(azimuthDegree);
+        assertEquals(radianXY, radian2, 1E-3);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
index be026ba6e6..893a59a548 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilBigTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilBigTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
index cf314ac516..d4e2d51ecf 100644
--- a/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
+++ b/core/src/test/java/com/graphhopper/util/BitUtilLittleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BitUtilLittleTest extends AbstractBitUtilTester
diff --git a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index 80d48d7f28..bf5ae074d0 100644
--- a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -25,10 +25,10 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BreadthFirstSearchTest
@@ -79,7 +79,7 @@ public boolean goFurther( int v )
         assertEquals(g.getNodes(), counter);
         assertEquals("{0, 5, 3, 2, 1, 10, 8, 7, 6, 9, 4}", list.toString());
     }
-    
+
     @Test
     public void testBFS2()
     {
@@ -110,5 +110,5 @@ public boolean goFurther( int v )
         assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
     }
 
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
similarity index 81%
rename from core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
rename to core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index a9cd7acf44..8708b98c73 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeSkipIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -22,31 +22,29 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphHopperStorage;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
-public class EdgeSkipIteratorTest
+public class CHEdgeIteratorTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
-    private CarFlagEncoder carFlagsEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    private EdgeFilter carOutFilter = new DefaultEdgeFilter(carFlagsEncoder, false, true);
-
-    LevelGraph createGraph()
-    {
-        return new GraphBuilder(encodingManager).levelGraphCreate();
-    }
-
     @Test
     public void testUpdateFlags()
     {
-        LevelGraph g = createGraph();
+        EncodingManager encodingManager = new EncodingManager("CAR");
+        CarFlagEncoder carFlagsEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        EdgeFilter carOutFilter = new DefaultEdgeFilter(carFlagsEncoder, false, true);
+        GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHGraph(true).create();
+        CHGraph g = ghStorage.getGraph(CHGraph.class);
         g.edge(0, 1).setDistance(12).setFlags(carFlagsEncoder.setProperties(10, true, true));
         g.edge(0, 2).setDistance(13).setFlags(carFlagsEncoder.setProperties(20, true, true));
+        ghStorage.freeze();
 
         assertEquals(2, GHUtility.count(g.getAllEdges()));
         assertEquals(1, GHUtility.count(g.createEdgeExplorer(carOutFilter).setBaseNode(1)));
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index 9aa311807b..fce6e2d53f 100644
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -25,14 +25,15 @@
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author jan
  */
-public class DepthFirstSearchTest {
-    
+public class DepthFirstSearchTest
+{
+
     int counter;
     TIntHashSet set = new TIntHashSet();
     TIntList list = new TIntArrayList();
@@ -42,7 +43,7 @@ public void setup()
     {
         counter = 0;
     }
-    
+
     @Test
     public void testDFS1()
     {
@@ -58,13 +59,13 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
         g.edge(1, 2, 1, false);
         g.edge(1, 5, 1, false);
-        g.edge(1, 4, 1, false);       
+        g.edge(1, 4, 1, false);
         g.edge(2, 3, 1, false);
         g.edge(3, 4, 1, false);
         g.edge(5, 6, 1, false);
@@ -75,7 +76,7 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4, 5, 6}", list.toString());
     }
-    
+
     @Test
     public void testDFS2()
     {
@@ -91,7 +92,7 @@ public boolean goFurther( int v )
                 return super.goFurther(v);
             }
         };
-        
+
         EncodingManager em = new EncodingManager("CAR");
         FlagEncoder fe = em.getEncoder("CAR");
         Graph g = new GraphBuilder(em).create();
@@ -106,5 +107,5 @@ public boolean goFurther( int v )
         assertTrue(counter > 0);
         assertEquals("{1, 2, 3, 4}", list.toString());
     }
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 4c8f3b0928..8d1d9c4985 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class DistanceCalcEarthTest
@@ -35,18 +36,6 @@ public void testCalcCircumference()
         assertEquals(DistanceCalcEarth.C, dc.calcCircumference(0), 1e-7);
     }
 
-    @Test
-    public void testGeohashMaxDist()
-    {
-        DistanceCalcEarth dce = new DistanceCalcEarth();
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(0), 1);
-        assertEquals(DistanceCalcEarth.C / 2, dce.calcSpatialKeyMaxDist(1), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(2), 1);
-        assertEquals(DistanceCalcEarth.C / 4, dce.calcSpatialKeyMaxDist(3), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(4), 1);
-        assertEquals(DistanceCalcEarth.C / 8, dce.calcSpatialKeyMaxDist(5), 1);
-    }
-
     @Test
     public void testDistance()
     {
diff --git a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
index c13e850f06..f8d7bd9a2a 100644
--- a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
+++ b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class DouglasPeuckerTest
@@ -69,6 +69,7 @@ public void testSimplifyCheckPointCount()
         assertEquals(20, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
     }
+
     String points2 = "[[9.961074440801317,50.203764443183644],[9.96106605889796,50.20365789987872],[9.960999562464645,50.20318963087774],[9.96094144793469,50.202952888673984],[9.96223002587773,50.20267889356641],[9.962200968612752,50.20262022024289],"
             + "[9.961859918278305,50.201853928011374],[9.961668810881722,50.20138565901039],[9.96216874485095,50.20128507617008],[9.961953795595925,50.20088553877664],[9.961899033827313,50.200686794534775],[9.961716680863127,50.20014066696481],[9.961588158344957,50.199798499043254]]";
 
@@ -82,7 +83,7 @@ public void testSimplifyCheckPointOrder()
         assertEquals(11, pointList.getSize());
         assertFalse(pointList.toString(), pointList.toString().contains("NaN"));
         assertEquals("(50.203764443183644,9.961074440801317), (50.20318963087774,9.960999562464645), (50.202952888673984,9.96094144793469), (50.20267889356641,9.96223002587773), (50.201853928011374,9.961859918278305), "
-                + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
+                        + "(50.20138565901039,9.961668810881722), (50.20128507617008,9.96216874485095), (50.20088553877664,9.961953795595925), (50.200686794534775,9.961899033827313), (50.20014066696481,9.961716680863127), (50.199798499043254,9.961588158344957)",
                 pointList.toString());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
index 0bf9821c66..3a1f77790e 100644
--- a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
+++ b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class EdgeWrapperTest
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index a9a8e09991..3669bcca0b 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -18,15 +18,13 @@
 package com.graphhopper.util;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
+
 import static org.junit.Assert.*;
+
 import org.junit.Test;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHUtilityTest
@@ -108,10 +106,10 @@ public void testCopyWithSelfRef()
         Graph g = initUnsorted(createGraph());
         EdgeIteratorState eb = g.edge(0, 0, 11, true);
 
-        LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
+        CHGraph lg = new GraphBuilder(encodingManager).chGraphCreate();
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
+        assertEquals(g.getAllEdges().getMaxId(), lg.getAllEdges().getMaxId());
     }
 
     @Test
@@ -120,8 +118,11 @@ public void testCopy()
         Graph g = initUnsorted(createGraph());
         EdgeIteratorState eb = g.edge(6, 5, 11, true);
         eb.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
-        LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
+
+        GraphHopperStorage newStore = new GraphBuilder(encodingManager).setCHGraph(true).create();
+        CHGraph lg = newStore.getGraph(CHGraph.class);
         GHUtility.copyTo(g, lg);
+        newStore.freeze();
 
         eb = GHUtility.getEdge(lg, 5, 6);
         assertEquals(Helper.createPointList(-1, 3, 12, 10), eb.fetchWayGeometry(0));
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 26c942a3db..84ff8d2cae 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -19,13 +19,15 @@
 
 import java.io.File;
 import java.util.Locale;
+
 import org.junit.After;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 
 /**
- *
  * @author Peter Karich
  */
 public class HelperTest
@@ -69,6 +71,7 @@ public void testGetLocale() throws Exception
         assertEquals(Locale.GERMANY, Helper.getLocale("de-DE"));
         assertEquals(Locale.ENGLISH, Helper.getLocale("en"));
         assertEquals(Locale.US, Helper.getLocale("en_US"));
+        assertEquals(Locale.US, Helper.getLocale("en_US.UTF-8"));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index ab8763aeae..1b163e036b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -27,6 +27,7 @@
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
+
 import java.io.*;
 import java.util.*;
 import javax.xml.XMLConstants;
@@ -38,12 +39,13 @@
 
 import org.json.JSONObject;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
+
 import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
- *
  * @author Peter Karich
  */
 public class InstructionListTest
@@ -53,9 +55,10 @@
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private EncodingManager carManager;
     private FlagEncoder carEncoder;
-    
+
     @Before
-    public void setUp() {
+    public void setUp()
+    {
         carEncoder = new CarFlagEncoder();
         carManager = new EncodingManager(carEncoder);
     }
@@ -63,7 +66,7 @@ public void setUp() {
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {                
+    {
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -113,13 +116,13 @@ public void testWayList()
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
-                "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
+                        "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
-                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
+                        "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
@@ -136,7 +139,7 @@ public void testWayList()
         assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.1d, 1.1), asL(1.0, 1.1),
-                asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
+                        asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
@@ -462,7 +465,7 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {        
+    {
         Graph g = new GraphBuilder(carManager).create();
         Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
@@ -493,4 +496,45 @@ public void verifyGPX( String gpx )
             throw new RuntimeException(e);
         }
     }
+    
+    @Test
+    public void testFind()
+    {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        //   3-2
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        PointList waypoint = new PointList();
+        waypoint.add(15.2, 9.9);
+        na.setNode(4, 15.2, 10);
+        na.setNode(5, 15.2, 10.1);
+
+        g.edge(1, 2, 10000, true).setName("1-2");
+        g.edge(2, 3, 10000, true).setName("2-3");
+        g.edge(3, 4, 10000, true).setName("3-4").setWayGeometry(waypoint);
+        g.edge(4, 5, 10000, true).setName("4-5");
+
+
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(usTR);
+        
+        // query on first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10, 1000).getName());
+        
+        // query east of first edge, get instruction for second edge
+        assertEquals("2-3", wayList.find(15.05, 10.001, 1000).getName());
+
+        // query south-west of node 3, get instruction for third edge
+        assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
+
+        // query north-west of pillar node n , get instruction for fourth edge
+        assertEquals("4-5", wayList.find(15.21, 9.85, 100000).getName());
+
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 70d8a5f83a..522a3f0a96 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Johannes Pelzer
  */
 public class InstructionTest
@@ -32,7 +32,7 @@ public void testCalcAzimuthAndGetDirection()
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
-        
+
         PointList nextPl = new PointList();
         nextPl.add(49.942, 11.582);
         Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
diff --git a/core/src/test/java/com/graphhopper/util/PMapTest.java b/core/src/test/java/com/graphhopper/util/PMapTest.java
new file mode 100644
index 0000000000..b9ae820355
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/PMapTest.java
@@ -0,0 +1,66 @@
+package com.graphhopper.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PMapTest
+{
+
+    @Test
+    public void singleStringPropertyCanBeRetrieved()
+    {
+        PMap subject = new PMap("foo=bar");
+
+        Assert.assertEquals("bar", subject.get("foo"));
+    }
+
+    @Test
+    public void propertyFromStringWithMultiplePropertiesCanBeRetrieved()
+    {
+        PMap subject = new PMap("foo=valueA|bar=valueB");
+
+        Assert.assertEquals("valueA", subject.get("foo", ""));
+        Assert.assertEquals("valueB", subject.get("bar", ""));
+    }
+
+    @Test
+    public void keyCanHaveAnyCasing()
+    {
+        PMap subject = new PMap("foo=valueA|bar=valueB");
+
+        assertEquals("valueA", subject.get("foo", ""));
+        assertEquals("valueA", subject.get("FOO", ""));
+        assertEquals("valueA", subject.get("Foo", ""));
+    }
+
+    @Test
+    public void numericPropertyCanBeRetrievedAsLong()
+    {
+        PMap subject = new PMap("foo=1234|bar=5678");
+
+        assertEquals(1234L, subject.getLong("foo", 0));
+    }
+
+    @Test
+    public void numericPropertyCanBeRetrievedAsDouble()
+    {
+        PMap subject = new PMap("foo=123.45|bar=56.78");
+
+        assertEquals(123.45, subject.getDouble("foo", 0), 1e-4);
+    }
+
+    @Test
+    public void hasReturnsCorrectResult()
+    {
+        PMap subject = new PMap("foo=123.45|bar=56.78");
+
+        assertTrue(subject.has("foo"));
+        assertTrue(subject.has("bar"));
+        assertFalse(subject.has("baz"));
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index f517e9c3fd..7bd901b9f0 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,6 +20,7 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
index c228f76148..3bbd105f37 100644
--- a/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
+++ b/core/src/test/java/com/graphhopper/util/SimpleIntDequeTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class SimpleIntDequeTest
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 7bd65b5213..0f149fe65d 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import java.util.Locale;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class TranslationMapTest
@@ -41,7 +42,7 @@ public void testToString()
 
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("", ruMap.tr("web.FOOT"));
-        
+
         Translation zhMap = SINGLETON.getWithFallBack(new Locale("vi", "VI"));
         assertEquals("i b", zhMap.tr("web.FOOT"));
 
@@ -61,4 +62,11 @@ public void testToString()
 
         // indonesia assertEquals("in", new Locale("id").getLanguage());
     }
+
+    @Test
+    public void testToRoundaboutString()
+    {
+        Translation ptMap = SINGLETON.get("pt");
+        assertTrue(ptMap.tr("roundaboutExitOnto", "1", "somestreet").contains("somestreet"));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index 95b0918947..e1e894dda6 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class BBoxTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index f6140bbe84..c210c58af1 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -18,10 +18,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.*;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CircleTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index e8847d47fd..4e2980bed7 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class CoordTrigTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
index aa8c97562e..3ea1f41435 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPoint3DTest
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
index 6adac39794..eb324c71c5 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -19,10 +19,10 @@
 package com.graphhopper.util.shapes;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GHPointTest
diff --git a/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg b/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
index 8d8a6500a8..0367a06986 100644
--- a/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
+++ b/core/src/test/resources/com/graphhopper/routing/prepare-routing.svg
@@ -2,469 +2,477 @@
 <!-- Created with Inkscape (http://www.inkscape.org/) -->
 
 <svg
-    xmlns:dc="http://purl.org/dc/elements/1.1/"
-    xmlns:cc="http://creativecommons.org/ns#"
-    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-    xmlns:svg="http://www.w3.org/2000/svg"
-    xmlns="http://www.w3.org/2000/svg"
-    xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-    xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-    width="210mm"
-    height="297mm"
-    id="svg2"
-    version="1.1"
-    inkscape:version="0.48.0 r9654"
-    sodipodi:docname="prepare-routing.svg">
-    <defs
-        id="defs4" />
-    <sodipodi:namedview
-        id="base"
-        pagecolor="#ffffff"
-        bordercolor="#666666"
-        borderopacity="1.0"
-        inkscape:pageopacity="0.0"
-        inkscape:pageshadow="2"
-        inkscape:zoom="1.979899"
-        inkscape:cx="229.16243"
-        inkscape:cy="980.18743"
-        inkscape:document-units="px"
-        inkscape:current-layer="layer1"
-        showgrid="false"
-        inkscape:window-width="1440"
-        inkscape:window-height="850"
-        inkscape:window-x="0"
-        inkscape:window-y="0"
-        inkscape:window-maximized="1" />
-    <metadata
-        id="metadata7">
-        <rdf:RDF>
-            <cc:Work
-                rdf:about="">
-                <dc:format>image/svg+xml</dc:format>
-                <dc:type
-                    rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-                <dc:title></dc:title>
-            </cc:Work>
-        </rdf:RDF>
-    </metadata>
-    <g
-        inkscape:label="Ebene 1"
-        inkscape:groupmode="layer"
-        id="layer1">
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 110.76144,85.010117 133.62219,68.913306"
-            id="path3006"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 110.1697,84.959354 18.40173,20.974256"
-            id="path3008"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 132.14286,70.219325 -3.57143,35.714285 7.71717,36.09065"
-            id="path3010"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 131.79622,67.693944 171.38397,52.78676"
-            id="path3012"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="91.619301"
-            y="92.651894"
-            id="text3014"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3016"
-            x="91.619301"
-            y="92.651894">0</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="127.85714"
-            y="68.076469"
-            id="text3018"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3020"
-            x="127.85714"
-            y="68.076469">1</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="156.8593"
-            y="52.71497"
-            id="text3022"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3024"
-            x="156.8593"
-            y="52.71497">4</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="116.34191"
-            y="122.32629"
-            id="text3026"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3028"
-            x="116.34191"
-            y="122.32629">2</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="122.49308"
-            y="156.95247"
-            id="text3030"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3032"
-            x="122.49308"
-            y="156.95247">3</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 127.02031,107.15298 59.98151,9.21137"
-            id="path3034"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 187.33358,117.3745 -50.74911,25.65991"
-            id="path3036"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 137.33465,144.58554 112.76943,14.96155"
-            id="path3038"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 172.22081,52.909312 209.60665,40.694409"
-            id="path3040"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 210.61681,40.694409 13.63706,34.850263"
-            id="path3042"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="181.82747"
-            y="136.65891"
-            id="text3044"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3046"
-            x="181.82747"
-            y="136.65891">9</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="255.06351"
-            y="165.95334"
-            id="text3048"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3050"
-            x="255.06351"
-            y="165.95334">10</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="201.02036"
-            y="62.412685"
-            id="text3052"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3054"
-            x="201.02036"
-            y="62.412685">5</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="210.11172"
-            y="89.181732"
-            id="text3056"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3058"
-            x="210.11172"
-            y="89.181732">6</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 223.24371,76.049748 27.7792,14.142134"
-            id="path3060"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="232.84016"
-            y="107.86956"
-            id="text3062"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3064"
-            x="232.84016"
-            y="107.86956">7</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="253.04323"
-            y="118.47615"
-            id="text3066"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3068"
-            x="253.04323"
-            y="118.47615">8</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 189.4036,117.97108 64.1447,-3.53554 -3.53553,-24.748734"
-            id="path3070"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 173.24116,53.321316 4.54569,-38.890873 52.52793,2.020305"
-            id="path3072"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="159.60411"
-            y="11.399985"
-            id="text3074"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3076"
-            x="159.60411"
-            y="11.399985">11</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="214.65741"
-            y="12.410138"
-            id="text3078"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3080"
-            x="214.65741"
-            y="12.410138">12</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 185.36299,117.97107 88.89344,10.60661"
-            id="path3082"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 251.0229,159.89242 25.7589,-32.82996"
-            id="path3084"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="271.22595"
-            y="143.2249"
-            id="text3086"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3088"
-            x="271.22595"
-            y="143.2249">14</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 230.31478,15.945672 300.01531,5.3390703"
-            id="path3090"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 230.31478,15.440596 48.48733,47.477168"
-            id="path3092"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 277.79195,63.927917 36.87057,-0.505075"
-            id="path3094"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 300.01531,5.3390703 315.67267,65.948222"
-            id="path3096"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 277.28688,126.55737 316.68282,63.927918"
-            id="path3098"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="cc" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="314.15744"
-            y="72.514214"
-            id="text3100"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3102"
-            x="314.15744"
-            y="72.514214">16</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="306.5813"
-            y="20.996435"
-            id="text3104"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3106"
-            x="306.5813"
-            y="20.996435">13</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="258.09399"
-            y="84.636047"
-            id="text3108"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3110"
-            x="258.09399"
-            y="84.636047">15</tspan></text>
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:12,12;stroke-dashoffset:0"
-            d="M 171.71875 52.8125 L 186.875 115.9375 L 171.71875 52.8125 z "
-            id="path3133" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:8,8;stroke-dashoffset:0"
-            d="M 136.37059,143.72997 272.23611,129.58783"
-            id="path3138"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:6,6;stroke-dashoffset:0"
-            d="M 316.68282,64.93807 233.85031,14.935519"
-            id="path3140"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:8,8;stroke-dashoffset:0"
-            d="M 231.32493,16.955824 172.73609,52.81624"
-            id="path3142"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="160.61426"
-            y="87.161423"
-            id="text3144"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3146"
-            x="160.61426"
-            y="87.161423"
-            style="font-size:12px;fill:#ff0000">(5)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="188.39345"
-            y="32.61319"
-            id="text3148"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3150"
-            x="188.39345"
-            y="32.61319"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="274.25644"
-            y="39.17918"
-            id="text3152"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3154"
-            x="274.25644"
-            y="39.17918"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="218.19295"
-            y="146.25536"
-            id="text3156"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3158"
-            x="218.19295"
-            y="146.25536"
-            style="font-size:12px;fill:#ff0000">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="289.91379"
-            y="72.514214"
-            id="text3928"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930"
-            x="289.91379"
-            y="72.514214"
-            style="font-size:10px">(2)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="248.19583"
-            y="54.672295"
-            id="text3928-8"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-1"
-            x="248.19583"
-            y="54.672295"
-            style="font-size:10px">(1)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="310.82529"
-            y="43.055542"
-            id="text3928-88"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-3"
-            x="310.82529"
-            y="43.055542"
-            style="font-size:10px">(1)</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="263.34811"
-            y="7.1951294"
-            id="text3928-1"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3930-14"
-            x="263.34811"
-            y="7.1951294"
-            style="font-size:10px">(1)</tspan></text>
-    </g>
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="prepare-routing.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1.979899"
+     inkscape:cx="142.28931"
+     inkscape:cy="980.18743"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="1600"
+     inkscape:window-height="1147"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <rect
+       style="opacity:0.94827587999999996;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-opacity:1"
+       id="rect3055"
+       width="299.51022"
+       height="228.79955"
+       x="41.416256"
+       y="10.894916" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 77.931483,137.53805 100.79223,121.44124"
+       id="path3006"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 77.339743,137.48729 18.40173,20.97425"
+       id="path3008"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 99.312903,122.74726 -3.57143,35.71428 7.717167,36.09065"
+       id="path3010"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 98.966263,120.22188 138.55401,105.31469"
+       id="path3012"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="58.789345"
+       y="145.17982"
+       id="text3014"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3016"
+         x="58.789345"
+         y="145.17982">0</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="95.027184"
+       y="120.6044"
+       id="text3018"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3020"
+         x="95.027184"
+         y="120.6044">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="124.02934"
+       y="105.2429"
+       id="text3022"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3024"
+         x="124.02934"
+         y="105.2429">4</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="83.511955"
+       y="174.85422"
+       id="text3026"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3028"
+         x="83.511955"
+         y="174.85422">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="89.663124"
+       y="209.48041"
+       id="text3030"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3032"
+         x="89.663124"
+         y="209.48041">3</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 94.190353,159.68091 59.981507,9.21137"
+       id="path3034"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 154.50362,169.90243 -50.74911,25.65991"
+       id="path3036"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 104.50469,197.11347 112.76943,14.96155"
+       id="path3038"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 139.39085,105.43724 176.77669,93.222341"
+       id="path3040"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 177.78685,93.222341 191.42391,128.0726"
+       id="path3042"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="148.99751"
+       y="189.18684"
+       id="text3044"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3046"
+         x="148.99751"
+         y="189.18684">9</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="222.23355"
+       y="218.48128"
+       id="text3048"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3050"
+         x="222.23355"
+         y="218.48128">10</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="168.1904"
+       y="114.94062"
+       id="text3052"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3054"
+         x="168.1904"
+         y="114.94062">5</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="177.28177"
+       y="141.70967"
+       id="text3056"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3058"
+         x="177.28177"
+         y="141.70967">6</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 190.41375,128.57768 27.7792,14.14213"
+       id="path3060"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="200.01021"
+       y="160.39749"
+       id="text3062"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3064"
+         x="200.01021"
+         y="160.39749">7</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="220.21327"
+       y="171.00409"
+       id="text3066"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3068"
+         x="220.21327"
+         y="171.00409">8</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 156.57364,170.49901 64.1447,-3.53554 -3.53553,-24.74873"
+       id="path3070"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 140.4112,105.84925 4.54569,-38.890875 52.52793,2.020305"
+       id="path3072"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="126.77415"
+       y="63.927917"
+       id="text3074"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3076"
+         x="126.77415"
+         y="63.927917">11</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="181.82745"
+       y="64.938072"
+       id="text3078"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3080"
+         x="181.82745"
+         y="64.938072">12</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 152.53303,170.499 88.89344,10.60661"
+       id="path3082"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 218.19294,212.42035 25.7589,-32.82996"
+       id="path3084"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="238.396"
+       y="195.75284"
+       id="text3086"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3088"
+         x="238.396"
+         y="195.75284">14</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 197.48482,68.473604 267.18535,57.867002"
+       id="path3090"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 197.48482,67.968528 245.97215,115.4457"
+       id="path3092"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 244.96199,116.45585 36.87057,-0.50508"
+       id="path3094"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 267.18535,57.867002 15.65736,60.609148"
+       id="path3096"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 244.45692,179.0853 39.39594,-62.62945"
+       id="path3098"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="281.32748"
+       y="125.04214"
+       id="text3100"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3102"
+         x="281.32748"
+         y="125.04214">16</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="273.75134"
+       y="73.524368"
+       id="text3104"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3106"
+         x="273.75134"
+         y="73.524368">13</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="225.26404"
+       y="137.16399"
+       id="text3108"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3110"
+         x="225.26404"
+         y="137.16399">15</tspan></text>
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:12, 12;stroke-dashoffset:0"
+       d="m 138.88879,105.34043 15.15625,63.125 -15.15625,-63.125 z"
+       id="path3133"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:8, 8;stroke-dashoffset:0"
+       d="M 103.54063,196.2579 239.40615,182.11576"
+       id="path3138"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:6, 6;stroke-dashoffset:0"
+       d="M 283.85286,117.466 201.02035,67.463451"
+       id="path3140"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#ff0000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:8, 8;stroke-dashoffset:0"
+       d="M 198.49497,69.483756 139.90613,105.34417"
+       id="path3142"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="127.7843"
+       y="139.68936"
+       id="text3144"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3146"
+         x="127.7843"
+         y="139.68936"
+         style="font-size:12px;fill:#ff0000">(5)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="155.56349"
+       y="85.141121"
+       id="text3148"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3150"
+         x="155.56349"
+         y="85.141121"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="241.42648"
+       y="91.707115"
+       id="text3152"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3154"
+         x="241.42648"
+         y="91.707115"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="185.36299"
+       y="198.78329"
+       id="text3156"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3158"
+         x="185.36299"
+         y="198.78329"
+         style="font-size:12px;fill:#ff0000">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="257.08383"
+       y="125.04214"
+       id="text3928"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930"
+         x="257.08383"
+         y="125.04214"
+         style="font-size:10px">(2)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="215.36588"
+       y="107.20023"
+       id="text3928-8"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-1"
+         x="215.36588"
+         y="107.20023"
+         style="font-size:10px">(1)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="277.99533"
+       y="95.583473"
+       id="text3928-88"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-3"
+         x="277.99533"
+         y="95.583473"
+         style="font-size:10px">(1)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:24px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="230.51816"
+       y="59.723061"
+       id="text3928-1"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3930-14"
+         x="230.51816"
+         y="59.723061"
+         style="font-size:10px">(1)</tspan></text>
+  </g>
 </svg>
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
index 2e455b0867..913bee91b9 100644
--- a/docs/android/android-studio-setup.md
+++ b/docs/android/android-studio-setup.md
@@ -4,7 +4,8 @@ Get the [GraphHopper sources and demo](./index.md) before you proceed.
 
 ## Setup
 
-[Download](http://developer.android.com/sdk/index.html) and start android studio
+[Download](http://developer.android.com/sdk/index.html) and start android studio. 
+Now you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar
 
 Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
 
diff --git a/docs/android/index.md b/docs/android/index.md
index db67b378d7..cf86b7f66a 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -25,7 +25,7 @@ Download the [Android SDK](http://developer.android.com/sdk/installing/index.htm
 go to the Android SDK Manager and install at least 2.3 (API 9).
 
 ### Maven or NetBeans
- 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
+ 1. Download [Maven Android SDK Deployer](https://github.com/simpligility/maven-android-sdk-deployer) and execute `mvn install -P 5.1` - it uses [Android Maven Plugin](http://simpligility.github.io/android-maven-plugin/) under the hood where you need to set up ANDROID_HOME
  2. Now do `./graphhopper.sh android`
 
 ### Gradle
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 4d55a5c847..f1e3ef6e8c 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -3,9 +3,9 @@
 CH is a post-import process which makes routing faster. 
 In GraphHopper CH is enabled by default but can be easily disabled.
 
-To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
-is necessary which allows to store shortcuts too.
+To make CH work in GraphHopper an additional logic is added to GraphHoppperStorage (CHGraphImpl) 
+which allows to store shortcuts too.
 
-A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
+A prepared graph can also be used for normal graph traversal IF you use chGraph.getBaseGraph().
 
 If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
index ff93ae5036..be932c422a 100644
--- a/docs/core/create-new-flagencoder.md
+++ b/docs/core/create-new-flagencoder.md
@@ -20,6 +20,7 @@ see Bike2WeightFlagEncoder for an example. You'll have to overwrite the followin
  * flagsDefault 
  * setProperties
  * reverseFlags
+ * setLowSpeed
 
 To incorporate or precalculate values based on the elevation data you can hook into applyWayTags
 and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index a054535cc8..a5fa64a68c 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -49,7 +49,7 @@ if (!index.loadExisting())
 
 ```java
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
-QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryResult toQR = index.findClosest(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
 QueryGraph queryGraph = new QueryGraph(graph);
 queryGraph.lookup(fromQR, toQR);
 Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
@@ -62,22 +62,22 @@ Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(),
 Path path = new Dijkstra(graph, encoder).calcPath(fromId, toId);
 ```
 
-### Use LevelGraph to make queries faster
+### Use CHGraph to make queries faster
 
 ```java
 // Creating and saving the graph
 GraphBuilder gb = new GraphBuilder(em).
     setLocation("graphhopper-folder").
     setStore(true).
-    setLevelGraph(true);
-GraphStorage graph = gb.create();
+    setCHGraph(true);
+GraphHopperStorage graph = gb.create();
 // Create a new edge between two nodes, set access, distance, speed, geometry, ..
 EdgeIteratorState edge = graph.edge(fromId, toId);
 ...
 
 // Prepare the graph for fast querying ...
 TraversalMode tMode = TraversalMode.NODE_BASED;
-PrepareContractionHierarchies pch = new PrepareContractionHierarchies(graph, encoder, weighting, tMode);
+PrepareContractionHierarchies pch = new PrepareContractionHierarchies(ghStorage, encoder, weighting, tMode);
 pch.doWork();
 
 // flush after preparation!
@@ -93,7 +93,7 @@ if (!index.loadExisting())
 
 // calculate path is identical
 QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
-QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryResult toQR = index.findClosest(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
 QueryGraph queryGraph = new QueryGraph(graph);
 queryGraph.lookup(fromQR, toQR);
 
@@ -103,4 +103,4 @@ AlgorithmOptions algoOpts = AlgorithmOptions.start().
    build();
 RoutingAlgorithm algorithm = pch.createAlgo(queryGraph, algoOpts);
 Path path = algorithm.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
-```
\ No newline at end of file
+```
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index f6cab16714..bc70a7917b 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -5,7 +5,7 @@
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md). 
 
-Now, before you proceed install git and jdk6, 7 or 8. Then do:
+Now, before you proceed install git and jdk7 or 8, then do:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git
@@ -29,10 +29,16 @@ $ ./graphhopper.sh web north-america_us_new-york.pbf
 
 ## Start Development
 
-Open the project with NetBeans or enable Maven in your IDE. 
+Open the project with NetBeans, IntelliJ or enable Maven in your IDE. 
 [Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
 installed when executing graphhopper.sh.
 
+### NetBeans, IntelliJ, Eclipse
+
+ * For IntelliJ you need to import the code formatting settings (File|Import Settings). Load them from core/files/intellij-settings.jar. See the [special setup](../android/android-studio-setup.md) for Android if using Android studio.
+ * For Eclipse please refer to [this separate setup documentation](./eclipse-setup.md).
+ * Nothing special needs to be done for NetBeans.
+
 ### Java, Embedded Usage
 
 Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 42ebe461e3..166b68d6bc 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -1,8 +1,8 @@
 To do routing in your Java code you'll need just a few lines of code:
 
 ```java
+// create singleton
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.setInMemory(true);
 hopper.setOSMFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
@@ -15,7 +15,8 @@ hopper.importOrLoad();
 // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
 GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
     setWeighting("fastest").
-    setVehicle("car");
+    setVehicle("car").
+    setLocale(Locale.US);
 GHResponse rsp = hopper.route(req);
 
 // first check for errors
@@ -25,22 +26,20 @@ if(rsp.hasErrors()) {
    return;
 }
 
-// route was found? e.g. if disconnected areas (like island) 
-// no route can ever be found
-if(!rsp.isFound()) {
-   // handle properly
-   return;
-}
-
 // points, distance in meters and time in millis of the full path
 PointList pointList = rsp.getPoints();
 double distance = rsp.getDistance();
 long timeInMs = rsp.getTime();
 
-// get the turn instructions for the path
 InstructionList il = rsp.getInstructions();
-Translation tr = trMap.getWithFallBack(Locale.US);
-List<String> iList = il.createDescription(tr);
+// iterate over every turn instruction
+for(Instruction instruction : il) {
+   instruction.getDistance();
+   ...
+}
+
+// or get the json
+List<Map<String, Object>> iList = il.createJson();
 
 // or get the result as gpx entries:
 List<GPXEntry> list = il.createGPXList();
@@ -55,8 +54,7 @@ Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
-hopper.disableCHShortcuts();
-hopper.setInMemory(true);
+hopper.setCHEnable(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
 hopper.setEncodingManager(new EncodingManager("car,bike"));
@@ -68,8 +66,18 @@ GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
 GHResponse res = hopper.route(req);
 ```
 
+In the flexibility mode it is also possible to add a desired heading (north based azimuth between 0 and 360 degree)
+to any point,
+```java
+GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
+```
+or to avoid u-turns at via points
+```java
+req.getHints().put("pass_through", true);
+```
+ 
 In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
- see the 'web' sub module.
+ see the 'web' sub module or [the Java client for the GraphHopper Directions API](https://github.com/graphhopper/directions-api-java-client).
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
@@ -79,4 +87,4 @@ gh.load("http://your-graphhopper-service.com");
 // gh.load("https://graphhopper.com/api/1/route");
 
 GHResponse rsp = gh.route(new GHRequest(...));
-```
\ No newline at end of file
+```
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 4b45a58200..84e3b4f14d 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -38,9 +38,14 @@ Some explanations:
  * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
  * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
 
-For some algorithms there are special implementations of the Graph. E.g. there is a LevelGraphStorage which is a Graph with the possibility to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. For this the graph needs also some preprocessing (which can take several hours for bigger areas like Europe) which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from createAlgo() in the preparation class.
+For some algorithms there are special implementations of the Graph (CHGraph). You enable this in GraphHopperStorage
+to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. 
+For this the graph needs also some preprocessing (which can take several minutes for bigger areas) 
+which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. 
+In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from 
+createAlgo() in the preparation class.
 
-A LevelGraphStorage (and all subclasses of GraphStorage) cannot read files created with GraphStorage and vice versa. Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
 
 ### 3. The Algorithms
 
@@ -51,12 +56,12 @@ An algorithm needs a kind of path extraction: from the shortest-path-tree one ne
 (list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
 can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
 For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
- we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
+ we use the _CHGraph_ which additionally holds shortcuts. While path extraction we need to identify those
  shortcuts and get the edges recursivly, this is done in Path4CH.
 
 ## 3.1 Base Graph
 
-In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
+In order to traverse the _CHGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
 is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
 _LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
 or similar. See issue #116 for more information.
diff --git a/docs/core/translations.md b/docs/core/translations.md
index e78415c906..2cc52cb92a 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -2,7 +2,7 @@
 
 You can help improve GraphHopper by adding your language!
 
-See [this spreadsheet](https://docs.google.com/spreadsheets/d/10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU/pub)
+See [this spreadsheet](https://docs.google.com/spreadsheets/d/10HKSFmxGVEIO92loVQetVmjXT0qpf3EA2jxuQSSYTdU/edit?pli=1#gid=0)
 and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
 
 [https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
index 0cfe351f42..9b206bb610 100644
--- a/docs/core/weighting.md
+++ b/docs/core/weighting.md
@@ -71,4 +71,6 @@ class MyGraphHopper extends GraphHopper {
 ```
 
 For forbiddenEdges you need to determine the edges from some GPS coordinates. 
-Have a look into the [location index docs](./location-index.md).
+Have a look into the [location index docs](./location-index.md). 
+
+If your blocking edges change per-request you need to disable the speed mode e.g. via `prepare.chWeighting=no`
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index f8a190dc4e..4b0027bd75 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -14,7 +14,7 @@ All official parameters are shown in the following table
 
 Parameter   | Default | Description
 :-----------|:--------|:-----------
-point       | -       | Specifiy multiple points for which the route should be calculated. The order is important. Specify at least two points.
+point       | -       | Specify multiple points for which the route should be calculated. The order is important. Specify at least two points.
 locale      | en      | The locale of the result. E.g. `pt_PT` for Portuguese or `de` for German
 instructions| true    | If instruction should be calculated and returned
 vehicle     | car     | The vehicle for which the route should be calculated. Other vehicles are foot and bike
@@ -25,6 +25,9 @@ points_encoded     | true    | If `false` a GeoJson array in `point` is returned
 debug              | false   | If true, the output will be formated.
 calc_points        | true    | If the points for the route should be calculated at all. Sometimes only the distance and time is necessary.
 type               | json    | Specifies the resulting format of the route, for json the content type will be application/json. Other possible format options: <br> jsonp you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> gpx, the content type will be application/xml
+heading            | NaN     | Favored heading direction for points. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree, NaN indicates non specific heading. Does only give valid results in the flexibility mode.
+heading_penalty    | 120     | Penalty for omitting a specified heading. The penalty corresponds to the accepted time delay in seconds in comparison to the route without a heading.
+pass_through       | false   | If `true` u-turns are avoided at via-points with regard to the heading_penalty. Does only give valid results in the flexibility mode.
 
 ## Example output for the case type=json
 
@@ -49,7 +52,7 @@ paths[0].instructions[0].sign                 | A number which specifies the sig
 paths[0].instructions[0].annotation_text      | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
 paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
-paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Null if the direction of rotation is undefined.
 
 ```json
 {
@@ -147,13 +150,11 @@ import_date         | [optional] The date time at which the OSM import was done
 prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
 supported_vehicles  | [deprecated] An array of strings for all supported vehicles
 
-### Output if expected error(s) while routing:
+### Error Output
 ```json
 {
-  "info": {"errors": [{
-    "details": "java.lang.IllegalArgumentException",
-    "message": "Cannot find point 2: 2248.224673, 3.867187"
-  }]}
+  "message": "Cannot find point 2: 2248.224673, 3.867187",
+  "hints": [{"message": "something", ...}]
 }
 ```
 
@@ -162,9 +163,8 @@ indicate a bug in the routing engine and is expected to a certain degree if too
 
 JSON path/attribute    | Description
 :----------------------|:------------
-info.errors            | A list of error messages
-info.errors[0].details | E.g. to see the underlying exception, if any
-info.errors[0].message | Not intended to be displayed to the user as it is currently not translated
+message                | Not intended to be displayed to the user as it is not translated
+hints                  | An optional list of details regarding the error message e.g. `[{"message": "first error message in hints"}]`
 
 
 ### HTTP Error codes
diff --git a/pom.xml b/pom.xml
index 0837ca65c5..dadb688542 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.10</slf4j.version>
+        <slf4j.version>1.7.12</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -44,6 +44,8 @@
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.allowConvertToStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>2</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.countForUsingStaticStarImport>
         <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>*</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.importGroupsOrder>        
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineMethodParams>
+        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.alignMultilineAnnotationArgs>        
     </properties>
     
     <scm>
@@ -91,7 +93,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.2</version>
+                <version>3.3</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -137,7 +139,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.10.1</version>
+                <version>2.10.3</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -147,12 +149,12 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.5.3</version>                    
+                <version>2.5.4</version>                    
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>2.5</version>
+                <version>2.6</version>
             </plugin>
             <plugin>
                 <artifactId>maven-war-plugin</artifactId>
@@ -185,7 +187,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.5</version>
+                        <version>1.6</version>
                         <executions>
                             <execution>
                                 <id>sign-artifacts</id>
diff --git a/tools/src/main/java/com/graphhopper/tools/Bzip2.java b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
index f47d748caf..a950b48f46 100644
--- a/tools/src/main/java/com/graphhopper/tools/Bzip2.java
+++ b/tools/src/main/java/com/graphhopper/tools/Bzip2.java
@@ -18,9 +18,11 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.util.Helper;
+
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+
 import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
 
 /**
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 48fd784f85..9726de4ddb 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -20,20 +20,14 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.MiniPerfTest;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.SimpleDateFormat;
@@ -44,6 +38,7 @@
 import java.util.TreeMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -56,6 +51,7 @@ public static void main( String[] strs )
     {
         new Measurement().start(CmdArgs.read(strs));
     }
+
     private static final Logger logger = LoggerFactory.getLogger(Measurement.class);
     private final Map<String, String> properties = new TreeMap<String, String>();
     private long seed;
@@ -79,12 +75,13 @@ public void doPostProcessing()
         {
             // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getCount();
             setAlgorithmFactory(createPrepare());
             super.prepare();
             setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
+            int edges = getGraphHopperStorage().getAllEdges().getMaxId();
+            int edgesAndShortcuts = getGraphHopperStorage().getGraph(CHGraph.class).getAllEdges().getMaxId();
+            put("prepare.shortcuts", edgesAndShortcuts - edges);
         }
     }
 
@@ -110,18 +107,20 @@ void start( CmdArgs args )
         MeasureHopper hopper = new MeasureHopper();
         hopper.forDesktop();
         if (!hopper.load(graphLocation))
-            throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
-
-        GraphStorage g = hopper.getGraph();
+            throw new IllegalStateException("Cannot load existing graph at " + graphLocation);
+        
+        GraphHopperStorage g = hopper.getGraphHopperStorage();
         if ("true".equals(g.getProperties().get("prepare.done")))
             throw new IllegalStateException("Graph has to be unprepared but wasn't!");
 
         String vehicleStr = args.get("graph.flagEncoders", "");
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicleStr);
         StopWatch sw = new StopWatch().start();
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g, vehicleStr);
+            GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
+            printMiscUnitPerfTests(false, g, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
@@ -134,6 +133,9 @@ void start( CmdArgs args )
             // route via CH. do preparation before                        
             hopper.setCHEnable(true);
             hopper.doPostProcessing();
+            CHGraph lg = g.getGraph(CHGraph.class);
+            fillAllowedEdges(lg.getAllEdges(), allowedEdges);
+            printMiscUnitPerfTests(true, lg, encoder, count * 100, allowedEdges);
             printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
             printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
@@ -161,13 +163,29 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g, String vehicleStr )
+    void fillAllowedEdges( AllEdgesIterator iter, GHBitSet bs )
+    {
+        bs.clear();
+        while (iter.next())
+        {
+            bs.add(iter.getEdge());
+        }
+    }
+
+    private GHBitSet printGraphDetails( GraphHopperStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getCount());
+        put("graph.edges", g.getAllEdges().getMaxId());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
         put("graph.encoder", vehicleStr);
+
+        AllEdgesIterator iter = g.getAllEdges();
+        final int maxEdgesId = g.getAllEdges().getMaxId();
+        final GHBitSet allowedEdges = new GHBitSetImpl(maxEdgesId);
+        fillAllowedEdges(iter, allowedEdges);
+        put("graph.valid_edges", allowedEdges.getCardinality());
+        return allowedEdges;
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
@@ -195,10 +213,92 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
+    private void printMiscUnitPerfTests( boolean isCH, final Graph graph, final FlagEncoder encoder,
+                                         int count, final GHBitSet allowedEdges )
+    {
+        final Random rand = new Random(seed);
+        String description = "";
+        if (isCH)
+        {
+            description = "CH";
+            CHGraph lg = (CHGraph) graph;
+            final CHEdgeExplorer chExplorer = lg.createEdgeExplorer(new LevelEdgeFilter(lg));
+            MiniPerfTest miniPerf = new MiniPerfTest()
+            {
+                @Override
+                public int doCalc( boolean warmup, int run )
+                {
+                    int nodeId = rand.nextInt(maxNode);
+                    return GHUtility.count(chExplorer.setBaseNode(nodeId));
+                }
+            }.setIterations(count).start();
+            print("unit_testsCH.level_edge_state_next", miniPerf);
+
+            final CHEdgeExplorer chExplorer2 = lg.createEdgeExplorer();
+            miniPerf = new MiniPerfTest()
+            {
+                @Override
+                public int doCalc( boolean warmup, int run )
+                {
+                    int nodeId = rand.nextInt(maxNode);
+                    CHEdgeIterator iter = chExplorer2.setBaseNode(nodeId);
+                    while (iter.next())
+                    {
+                        if (iter.isShortcut())
+                            nodeId += (int) iter.getWeight();
+                    }
+                    return nodeId;
+                }
+            }.setIterations(count).start();
+            print("unit_testsCH.get_weight", miniPerf);
+        }
+
+        EdgeFilter outFilter = new DefaultEdgeFilter(encoder, false, true);
+        final EdgeExplorer outExplorer = graph.createEdgeExplorer(outFilter);
+        MiniPerfTest miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(outExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".out_edge_state_next", miniPerf);
+
+        final EdgeExplorer allExplorer = graph.createEdgeExplorer();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                int nodeId = rand.nextInt(maxNode);
+                return GHUtility.count(allExplorer.setBaseNode(nodeId));
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".all_edge_state_next", miniPerf);
+
+        final int maxEdgesId = graph.getAllEdges().getMaxId();
+        miniPerf = new MiniPerfTest()
+        {
+            @Override
+            public int doCalc( boolean warmup, int run )
+            {
+                while (true)
+                {
+                    int edgeId = rand.nextInt(maxEdgesId);
+                    if (allowedEdges.contains(edgeId))
+                        return graph.getEdgeIteratorState(edgeId, Integer.MIN_VALUE).getEdge();
+                }
+            }
+        }.setIterations(count).start();
+        print("unit_tests" + description + ".get_edge_state", miniPerf);
+    }
+
     private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
-            final String vehicle, final boolean withInstructions )
+                                        final String vehicle, final boolean withInstructions )
     {
-        final Graph g = hopper.getGraph();
+        final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
         final AtomicLong distSum = new AtomicLong(0);
@@ -206,6 +306,7 @@ private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String
         final AtomicInteger failedCount = new AtomicInteger(0);
         final DistanceCalc distCalc = new DistanceCalcEarth();
 
+        final AtomicLong visitedNodesSum = new AtomicLong(0);
 //        final AtomicLong extractTimeSum = new AtomicLong(0);
 //        final AtomicLong calcPointsTimeSum = new AtomicLong(0);
 //        final AtomicLong calcDistTimeSum = new AtomicLong(0);
@@ -251,6 +352,7 @@ public int doCalc( boolean warmup, int run )
 
                 if (!warmup)
                 {
+                    visitedNodesSum.addAndGet(res.getHints().getLong("visited_nodes.sum", 0));
                     long dist = (long) res.getDistance();
                     distSum.addAndGet(dist);
 
@@ -278,6 +380,7 @@ public int doCalc( boolean warmup, int run )
         put(prefix + ".distanceMean", (float) distSum.get() / count);
         put(prefix + ".airDistanceMean", (float) airDistSum.get() / count);
         put(prefix + ".distanceMax", maxDistance.get());
+        put(prefix + ".visitedNodesMean", (float) visitedNodesSum.get() / count);
 
 //        put(prefix + ".extractTime", (float) extractTimeSum.get() / count / 1000000f);
 //        put(prefix + ".calcPointsTime", (float) calcPointsTimeSum.get() / count / 1000000f);
@@ -287,7 +390,7 @@ public int doCalc( boolean warmup, int run )
 
     void print( String prefix, MiniPerfTest perf )
     {
-        logger.info(perf.getReport());
+        logger.info(prefix + ": " + perf.getReport());
         put(prefix + ".sum", perf.getSum());
 //        put(prefix+".rms", perf.getRMS());
         put(prefix + ".min", perf.getMin());
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index b5f0a20353..617ccf9b80 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -24,6 +24,7 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.io.*;
 import java.net.URLEncoder;
 import java.util.*;
@@ -31,6 +32,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -45,6 +47,7 @@ public static void main( String[] args )
     {
         new QueryTorture().start(CmdArgs.read(args));
     }
+
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private ExecutorService service;
     private BlockingQueue<Query> queryQueue;
@@ -176,7 +179,7 @@ void execute( int workerNo ) throws InterruptedException
         try
         {
             String url = baseUrl + query.createQueryString();
-            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
+            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url, false);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 94afcf8e3d..5895e43c5c 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index f7872e7bcf..46e8609e85 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index 0ee0376450..6288307fb7 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index 3b6e1264fa..5896045b7d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -24,6 +24,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIteratorState;
+
 import java.awt.Color;
 import java.awt.Graphics2D;
 
diff --git a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
index 42595d979f..d62fa20563 100644
--- a/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
+++ b/tools/src/main/java/com/graphhopper/ui/DefaultMapLayer.java
@@ -20,6 +20,7 @@
 import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.awt.image.RescaleOp;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,9 +37,9 @@
     // a bit transparent:
 //    private RescaleOp op = new RescaleOp(new float[]{1f, 1f, 1f, 0.5f}, new float[4], null);
     private RescaleOp op = new RescaleOp(new float[]
-    {
-        1f, 1f, 1f, 1f
-    }, new float[4], null);
+            {
+                    1f, 1f, 1f, 1f
+            }, new float[4], null);
 
     protected abstract void paintComponent( Graphics2D createGraphics );
 
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index edb05aefbb..0c853caa50 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -20,9 +20,11 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.shapes.BBox;
+
 import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Graphics2D;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -126,6 +128,7 @@ public void plot( Graphics2D g2, double lat, double lon, int width )
         double y = getY(lat);
         g2.fillOval((int) x, (int) y, width, width);
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
 
     void scale( int x, int y, boolean zoomIn )
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 3ac7aa2074..fc27903a8b 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -29,10 +29,12 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import gnu.trove.list.TIntList;
+
 import java.awt.*;
 import java.awt.event.*;
 import java.util.Random;
 import javax.swing.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -54,6 +56,7 @@ public static void main( String[] strs ) throws Exception
         boolean debug = args.getBool("minigraphui.debug", false);
         new MiniGraphUI(hopper, debug).visualize();
     }
+
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
     private RoutingAlgorithmFactory algoFactory;
@@ -73,7 +76,7 @@ public static void main( String[] strs ) throws Exception
 
     public MiniGraphUI( GraphHopper hopper, boolean debug )
     {
-        this.graph = hopper.getGraph();
+        this.graph = hopper.getGraphHopperStorage();
         this.na = graph.getNodeAccess();
         algoFactory = hopper.getAlgorithmFactory();
         encoder = hopper.getEncodingManager().getEncoder("car");
@@ -349,6 +352,7 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
         logger.info("dist:" + tmpPath.getDistance() + ", path points(" + list.getSize() + "):" + list + ", nodes:" + nodes);
         return tmpPath;
     }
+
     private QueryResult fromRes;
     private QueryResult toRes;
 
@@ -429,6 +433,7 @@ public void mouseClicked( MouseEvent e )
 
                             fromDone = !fromDone;
                         }
+
                         boolean dragging = false;
 
                         @Override
@@ -499,6 +504,7 @@ public void mousePressed( MouseEvent e )
             throw new RuntimeException(ex);
         }
     }
+
     // for moving
     int currentPosX;
     int currentPosY;
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index fa5d018259..0fb4b7ccd2 100644
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class QueryTortureTest
diff --git a/web/pom.xml b/web/pom.xml
index 8600391382..9c8651a013 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -35,14 +35,14 @@
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
         
         <!-- necessary to use guice ('@Inject') in servlets -->
         <dependency>
             <groupId>com.google.inject.extensions</groupId>
             <artifactId>guice-servlet</artifactId>
-            <version>3.0</version>
+            <version>4.0</version>
         </dependency>
                 
         <dependency>
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index c29d7c55f9..983887d767 100644
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -23,6 +23,7 @@
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.servlets.UserAgentFilter;
 
 /**
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index 7829d78286..b8e69a5a32 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -57,7 +57,7 @@ protected GraphHopper createGraphHopper( CmdArgs args )
         logger.info("loaded graph at:" + tmp.getGraphHopperLocation()
                 + ", source:" + tmp.getOSMFile()
                 + ", flagEncoders:" + tmp.getEncodingManager()
-                + ", class:" + tmp.getGraph().getClass().getSimpleName());
+                + ", class:" + tmp.getGraphHopperStorage().toDetailsString());
         return tmp;
     }
 
@@ -77,6 +77,8 @@ protected void configure()
                 logger.info("jsonp disabled");
 
             bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
+
+            bind(RouteSerializer.class).toInstance(new SimpleRouteSerializer(graphHopper.getGraphHopperStorage().getBounds()));
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 07fe5d9f38..20597cafad 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -17,24 +17,30 @@
  */
 package com.graphhopper.http;
 
-import java.io.IOException;
-import javax.inject.Named;
-import javax.inject.Inject;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import org.json.JSONException;
 import org.json.JSONObject;
-import static javax.servlet.http.HttpServletResponse.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_OK;
+
 /**
  * @author Peter Karich
  */
 public class GHBaseServlet extends HttpServlet
 {
-    protected Logger logger = LoggerFactory.getLogger(getClass());
+    protected static Logger logger = LoggerFactory.getLogger(GHBaseServlet.class);
     @Inject
     @Named("jsonpAllowed")
     private boolean jsonpAllowed;
@@ -49,54 +55,67 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
             res.setContentType("application/javascript");
             if (!jsonpAllowed)
             {
-                res.sendError(SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+                writeError(res, SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
                 return;
             }
 
             String callbackName = getParam(req, "callback", null);
             if (callbackName == null)
             {
-                res.sendError(SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
+                writeError(res, SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
                 return;
             }
 
             if (debug)
-            {
                 writeResponse(res, callbackName + "(" + json.toString(2) + ")");
-            } else
-            {
+            else
                 writeResponse(res, callbackName + "(" + json.toString() + ")");
-            }
+
         } else
         {
             res.setContentType("application/json");
             if (debug)
-            {
                 writeResponse(res, json.toString(2));
-            } else
-            {
+            else
                 writeResponse(res, json.toString());
-            }
         }
     }
 
-    void returnError( HttpServletResponse res, String errorMessage ) throws IOException
+    protected void writeError( HttpServletResponse res, int code, String message )
     {
-        res.sendError(SC_BAD_REQUEST, errorMessage);
+        JSONObject json = new JSONObject();
+        json.put("message", message);
+        writeJsonError(res, code, json);
+    }
+
+    protected void writeJsonError( HttpServletResponse res, int code, JSONObject json )
+    {
+        try
+        {
+            // no type parameter check here as jsonp does not work if an error
+            // also no debug parameter yet
+            res.setContentType("application/json");
+            res.setCharacterEncoding("UTF-8");
+            res.setStatus(code);
+            res.getWriter().append(json.toString(2));
+        } catch (IOException ex)
+        {
+            logger.error("Cannot write error " + ex.getMessage());
+        }
     }
 
-    protected String getParam( HttpServletRequest req, String string, String _default )
+    protected String getParam( HttpServletRequest req, String key, String _default )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
             return l[0];
 
         return _default;
     }
 
-    protected String[] getParams( HttpServletRequest req, String string )
+    protected String[] getParams( HttpServletRequest req, String key )
     {
-        String[] l = req.getParameterMap().get(string);
+        String[] l = req.getParameterMap().get(key);
         if (l != null && l.length > 0)
         {
             return l;
@@ -104,47 +123,51 @@ protected String getParam( HttpServletRequest req, String string, String _defaul
         return new String[0];
     }
 
-    protected long getLongParam( HttpServletRequest req, String string, long _default )
+    protected List<Double> getDoubleParamList( HttpServletRequest req, String key )
     {
-        try
-        {
-            return Long.parseLong(getParam(req, string, "" + _default));
-        } catch (Exception ex)
+        String[] l = req.getParameterMap().get(key);
+        if (l != null && l.length > 0)
         {
-            return _default;
+            ArrayList<Double> doubleList = new ArrayList<Double>(l.length);
+            for (String s : l)
+            {
+                doubleList.add(Double.valueOf(s));
+            }
+            return doubleList;
         }
+        return Collections.emptyList();
     }
 
-    protected boolean getBooleanParam( HttpServletRequest req, String string, boolean _default )
+    protected long getLongParam( HttpServletRequest req, String key, long _default )
     {
         try
         {
-            return Boolean.parseBoolean(getParam(req, string, "" + _default));
+            return Long.parseLong(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    protected double getDoubleParam( HttpServletRequest req, String string, double _default )
+    protected boolean getBooleanParam( HttpServletRequest req, String key, boolean _default )
     {
         try
         {
-            return Double.parseDouble(getParam(req, string, "" + _default));
+            return Boolean.parseBoolean(getParam(req, key, "" + _default));
         } catch (Exception ex)
         {
             return _default;
         }
     }
 
-    public void writeError( HttpServletResponse res, int code, String str )
+    protected double getDoubleParam( HttpServletRequest req, String key, double _default )
     {
         try
         {
-            res.sendError(code, str);
-        } catch (IOException ex)
+            return Double.parseDouble(getParam(req, key, "" + _default));
+        } catch (Exception ex)
         {
-            logger.error("Cannot write error " + code + " message:" + str, ex);
+            return _default;
         }
     }
 
diff --git a/web/src/main/java/com/graphhopper/http/GHErrorHandler.java b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
new file mode 100644
index 0000000000..4af5465de5
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHErrorHandler.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import java.io.IOException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.ErrorHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * @author Peter Karich
+ */
+public class GHErrorHandler extends ErrorHandler
+{
+    private static final long serialVersionUID = 1L;
+    private final Logger logger = LoggerFactory.getLogger(GHErrorHandler.class);
+
+    @Override
+    public void handle( String str, Request req, HttpServletRequest httpReq, HttpServletResponse httpRes ) throws IOException
+    {
+        Throwable throwable = (Throwable) httpReq.getAttribute("javax.servlet.error.exception");
+        if (throwable != null)
+        {
+            String message = throwable.getMessage();
+            logger.error(message + ", via:" + httpReq.getRequestURL(), throwable);
+        } else
+        {
+            String message = (String) httpReq.getAttribute("javax.servlet.error.message");
+            if (message != null)
+            {
+                logger.error("Internal error " + message + "! Via:" + httpReq.getRequestURL());
+            } else
+            {
+                logger.error("Internal error " + str + ", throwable not known! Via:" + httpReq.getRequestURL());
+            }
+        }
+
+        // you can't call sendError( 500, "Server Error" ) without triggering Jetty's DefaultErrorHandler
+        httpRes.setStatus(SC_INTERNAL_SERVER_ERROR);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
index 828684f0d1..2f8e9250da 100644
--- a/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
+++ b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
@@ -22,6 +22,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
+
 import org.eclipse.jetty.servlets.GzipFilter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 4a749c50ad..c3ceda83aa 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -23,12 +23,14 @@
 import com.google.inject.Module;
 import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
-import java.net.InetSocketAddress;
+
+
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.servlet.ServletHolder;
 
 import java.util.EnumSet;
 import javax.servlet.DispatcherType;
+
 import org.eclipse.jetty.server.Handler;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
@@ -76,6 +78,7 @@ public void start( Injector injector ) throws Exception
         server = new Server();
         // getSessionHandler and getSecurityHandler should always return null
         ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
+        servHandler.setErrorHandler(new GHErrorHandler());
         servHandler.setContextPath("/");
 
         servHandler.addServlet(new ServletHolder(new InvalidRequestServlet()), "/*");
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 76c04d1493..ce66e0ec7a 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -19,6 +19,7 @@
 
 import com.google.inject.servlet.ServletModule;
 import com.graphhopper.util.CmdArgs;
+
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Singleton;
@@ -64,5 +65,8 @@ protected void configureServlets()
 
         serve("/route*").with(GraphHopperServlet.class);
         bind(GraphHopperServlet.class).in(Singleton.class);
+
+        serve("/nearest*").with(NearestServlet.class);
+        bind(NearestServlet.class).in(Singleton.class);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 3c30178ff5..f8733bf554 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -18,64 +18,53 @@
 package com.graphhopper.http;
 
 import com.graphhopper.GHRequest;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.util.*;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-import java.util.Map.Entry;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.*;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
-import org.json.JSONObject;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.*;
+import java.util.Map.Entry;
+
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
 
 /**
- * Servlet to use GraphHopper in a remote application (mobile or browser). Attention: If type is
- * json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
- * used otherwise.
+ * Servlet to use GraphHopper in a remote client application like mobile or browser. Note: If type
+ * is json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
+ * used otherwise. See the full API response format in docs/web/api-doc.md
  * <p/>
+ *
  * @author Peter Karich
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
     @Inject
     private GraphHopper hopper;
+    @Inject
+    private RouteSerializer routeSerializer;
 
     @Override
-    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
-    {
-        try
-        {
-            writePath(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
-
-    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
     {
         List<GHPoint> infoPoints = getPoints(httpReq, "point");
+        GHResponse ghRsp = new GHResponse();
 
         // we can reduce the path length based on the maximum differences to the original coordinates
         double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
@@ -89,19 +78,49 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         String weighting = getParam(httpReq, "weighting", "fastest");
         String algoStr = getParam(httpReq, "algorithm", "");
         String localeStr = getParam(httpReq, "locale", "en");
+        List<Double> favoredHeadings = Collections.EMPTY_LIST;
+        try
+        {
+            favoredHeadings = getDoubleParamList(httpReq, "heading");
+
+        } catch (java.lang.NumberFormatException e)
+        {
+            throw new RuntimeException(e);
+        }
 
         StopWatch sw = new StopWatch().start();
-        GHResponse ghRsp;
         if (!hopper.getEncodingManager().supports(vehicleStr))
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+            ghRsp.addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
         } else if (enableElevation && !hopper.hasElevation())
         {
-            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
-        } else
+            ghRsp.addError(new IllegalArgumentException("Elevation not supported!"));
+        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != infoPoints.size())
+        {
+            ghRsp.addError(new IllegalArgumentException("number of headings must be <= 1 or equal number of points"));
+        }
+        if (!ghRsp.hasErrors())
         {
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-            GHRequest request = new GHRequest(infoPoints);
+
+            GHRequest request;
+            if (favoredHeadings.size() > 0)
+            {
+                // if only one favored heading is specified take as start heading
+                if (favoredHeadings.size() == 1)
+                {
+                    List<Double> paddedHeadings = new ArrayList<Double>(Collections.nCopies(infoPoints.size(),
+                            Double.NaN));
+                    paddedHeadings.set(0, favoredHeadings.get(0));
+                    request = new GHRequest(infoPoints, paddedHeadings);
+                } else
+                {
+                    request = new GHRequest(infoPoints, favoredHeadings);
+                }
+            } else
+            {
+                request = new GHRequest(infoPoints);
+            }
 
             initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
@@ -120,6 +139,7 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
         String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
                 + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+        httpRes.setHeader("X-GH-Took", "" + Math.round(took * 1000));
 
         if (ghRsp.hasErrors())
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
@@ -130,21 +150,33 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
 
         if (writeGPX)
         {
-            writeResponse(res, createGPXString(httpReq, res, ghRsp));
+            String xml = createGPXString(httpReq, httpRes, ghRsp);
+            if (ghRsp.hasErrors())
+            {
+                httpRes.setStatus(SC_BAD_REQUEST);
+                httpRes.getWriter().append(xml);
+            } else
+            {
+                writeResponse(httpRes, xml);
+            }
         } else
         {
-            Map<String, Object> map = createJson(ghRsp,
-                    calcPoints, pointsEncoded, enableElevation, enableInstructions);
+            Map<String, Object> map = routeSerializer.toJSON(ghRsp, calcPoints, pointsEncoded,
+                    enableElevation, enableInstructions);
+
+            // deprecated - remove in 0.5
             Object infoMap = map.get("info");
             if (infoMap != null)
                 ((Map) infoMap).put("took", Math.round(took * 1000));
 
-            writeJson(httpReq, res, new JSONObject(map));
+            if (ghRsp.hasErrors())
+                writeJsonError(httpRes, SC_BAD_REQUEST, new JSONObject(map));
+            else
+                writeJson(httpReq, httpRes, new JSONObject(map));
         }
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
-            throws Exception
     {
         boolean includeElevation = getBooleanParam(req, "elevation", false);
         res.setCharacterEncoding("UTF-8");
@@ -158,99 +190,47 @@ protected String createGPXString( HttpServletRequest req, HttpServletResponse re
             return rsp.getInstructions().createGPX(trackName, time, includeElevation);
     }
 
-    String errorsToXML( List<Throwable> list ) throws Exception
+    String errorsToXML( List<Throwable> list )
     {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        DocumentBuilder builder = factory.newDocumentBuilder();
-        Document doc = builder.newDocument();
-        Element gpxElement = doc.createElement("gpx");
-        gpxElement.setAttribute("creator", "GraphHopper");
-        gpxElement.setAttribute("version", "1.1");
-        doc.appendChild(gpxElement);
+        try
+        {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.newDocument();
+            Element gpxElement = doc.createElement("gpx");
+            gpxElement.setAttribute("creator", "GraphHopper");
+            gpxElement.setAttribute("version", "1.1");
+            doc.appendChild(gpxElement);
 
-        Element mdElement = doc.createElement("metadata");
-        gpxElement.appendChild(mdElement);
+            Element mdElement = doc.createElement("metadata");
+            gpxElement.appendChild(mdElement);
 
-        Element errorsElement = doc.createElement("extensions");
-        mdElement.appendChild(errorsElement);
+            Element extensionsElement = doc.createElement("extensions");
+            mdElement.appendChild(extensionsElement);
 
-        for (Throwable t : list)
-        {
-            Element error = doc.createElement("error");
-            errorsElement.appendChild(error);
-            error.setAttribute("message", t.getMessage());
-            error.setAttribute("details", t.getClass().getName());
-        }
-        TransformerFactory transformerFactory = TransformerFactory.newInstance();
-        Transformer transformer = transformerFactory.newTransformer();
-        StringWriter writer = new StringWriter();
-        transformer.transform(new DOMSource(doc), new StreamResult(writer));
-        return writer.toString();
-    }
+            Element messageElement = doc.createElement("message");
+            extensionsElement.appendChild(messageElement);
+            messageElement.setTextContent(list.get(0).getMessage());
 
-    protected Map<String, Object> createJson( GHResponse rsp,
-            boolean calcPoints,
-            boolean pointsEncoded,
-            boolean includeElevation,
-            boolean enableInstructions )
-    {
-        Map<String, Object> json = new HashMap<String, Object>();
-        Map<String, Object> jsonInfo = new HashMap<String, Object>();
-        json.put("info", jsonInfo);
-        jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Element hintsElement = doc.createElement("hints");
+            extensionsElement.appendChild(hintsElement);
 
-        if (rsp.hasErrors())
-        {
-            List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors())
+            for (Throwable t : list)
             {
-                Map<String, String> map = new HashMap<String, String>();
-                map.put("message", t.getMessage());
-                map.put("details", t.getClass().getName());
-                list.add(map);
+                Element error = doc.createElement("error");
+                hintsElement.appendChild(error);
+                error.setAttribute("message", t.getMessage());
+                error.setAttribute("details", t.getClass().getName());
             }
-            jsonInfo.put("errors", list);
-        } else
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            StringWriter writer = new StringWriter();
+            transformer.transform(new DOMSource(doc), new StreamResult(writer));
+            return writer.toString();
+        } catch (Exception ex)
         {
-            Map<String, Object> jsonPath = new HashMap<String, Object>();
-            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
-            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getTime());
-
-            if (calcPoints)
-            {
-                jsonPath.put("points_encoded", pointsEncoded);
-
-                PointList points = rsp.getPoints();
-                if (points.getSize() >= 2)
-                {
-                    BBox maxBounds = hopper.getGraph().getBounds();
-                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
-                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
-                }
-
-                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
-
-                if (enableInstructions)
-                {
-                    InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson());
-                }
-            }
-            json.put("paths", Collections.singletonList(jsonPath));
+            throw new RuntimeException(ex);
         }
-        return json;
-    }
-
-    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
-    {
-        if (pointsEncoded)
-            return WebHelper.encodePolyline(points, includeElevation);
-
-        Map<String, Object> jsonPoints = new HashMap<String, Object>();
-        jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
-        return jsonPoints;
     }
 
     protected List<GHPoint> getPoints( HttpServletRequest req, String key )
@@ -264,9 +244,7 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
             {
                 GHPoint point = GHPoint.parse(str);
                 if (point != null)
-                {
                     infoPoints.add(point);
-                }
             }
         }
 
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 5d0e60d8e0..f75bdfee4a 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,7 +22,9 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -89,8 +91,7 @@ public GraphHopperWeb setElevation( boolean withElevation )
     @Override
     public GHResponse route( GHRequest request )
     {
-        StopWatch sw = new StopWatch().start();
-        double took = 0;
+        StopWatch sw = new StopWatch().start();        
         try
         {
             String places = "";
@@ -126,41 +127,29 @@ public GHResponse route( GHRequest request )
             if (!tmpKey.isEmpty())
                 url += "&key=" + tmpKey;
 
-            String str = downloader.downloadAsString(url);
+            String str = downloader.downloadAsString(url, true);
             JSONObject json = new JSONObject(str);
 
-            if (json.has("message"))
-                throw new RuntimeException(json.getString("message") + ", code:" + json.getInt("code"));
-
             GHResponse res = new GHResponse();
-
-            if (json.getJSONObject("info").has("errors"))
-            {
-                JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
-                readErrors(res.getErrors(), errors);
+            readErrors(res.getErrors(), json);
+            if (res.hasErrors())
                 return res;
+            
+            JSONArray paths = json.getJSONArray("paths");
+            JSONObject firstPath = paths.getJSONObject(0);
+            readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
+            return res;
 
-            } else
-            {
-                took = json.getJSONObject("info").getDouble("took");
-                JSONArray paths = json.getJSONArray("paths");
-                JSONObject firstPath = paths.getJSONObject(0);
-                readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
-                return res;
-            }
         } catch (Exception ex)
         {
             throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
-        } finally
-        {
-            logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
         }
     }
 
     public static void readPath( GHResponse res, JSONObject firstPath,
-            boolean tmpCalcPoints,
-            boolean tmpInstructions,
-            boolean tmpElevation )
+                                 boolean tmpCalcPoints,
+                                 boolean tmpInstructions,
+                                 boolean tmpElevation )
     {
         double distance = firstPath.getDouble("distance");
         long time = firstPath.getLong("time");
@@ -229,37 +218,57 @@ public static void readPath( GHResponse res, JSONObject firstPath,
         res.setDistance(distance).setTime(time);
     }
 
-    public static void readErrors( List<Throwable> errors, JSONArray errorJson )
+    public static void readErrors( List<Throwable> errors, JSONObject json )
     {
+        JSONArray errorJson;
+
+        if (json.has("message"))
+        {
+            if (json.has("hints"))
+            {
+                errorJson = json.getJSONArray("hints");
+            } else
+            {
+                // should not happen
+                errors.add(new RuntimeException(json.getString("message")));
+                return;
+            }
+        } else if (json.has("info"))
+        {
+            // deprecated JSON format for errors, remove in 0.5 release
+            JSONObject jsonInfo = json.getJSONObject("info");
+            if (jsonInfo.has("errors"))
+                errorJson = jsonInfo.getJSONArray("errors");
+            else
+                return;
+
+        } else
+            return;
+
         for (int i = 0; i < errorJson.length(); i++)
         {
             JSONObject error = errorJson.getJSONObject(i);
             String exClass = "";
             if (error.has("details"))
-            {
                 exClass = error.getString("details");
-            }
+
             String exMessage = error.getString("message");
 
             if (exClass.equals(UnsupportedOperationException.class.getName()))
-            {
                 errors.add(new UnsupportedOperationException(exMessage));
-            } else if (exClass.equals(IllegalStateException.class.getName()))
-            {
+            else if (exClass.equals(IllegalStateException.class.getName()))
                 errors.add(new IllegalStateException(exMessage));
-            } else if (exClass.equals(RuntimeException.class.getName()))
-            {
+            else if (exClass.equals(RuntimeException.class.getName()))
                 errors.add(new RuntimeException(exMessage));
-            } else if (exClass.equals(IllegalArgumentException.class.getName()))
-            {
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
                 errors.add(new IllegalArgumentException(exMessage));
-            } else if (exClass.isEmpty())
-            {
-                errors.add(new Exception(exMessage));
-            } else
-            {
-                errors.add(new Exception(exClass + " " + exMessage));
-            }
+            else if (exClass.isEmpty())
+                errors.add(new RuntimeException(exMessage));
+            else
+                errors.add(new RuntimeException(exClass + " " + exMessage));
         }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.getString("message")));
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 833246508a..46777addb3 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -20,13 +20,14 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.Translation;
+
 import java.io.IOException;
 import java.util.Locale;
 import javax.inject.Inject;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.*;
+
 import org.json.JSONObject;
 
 /**
@@ -40,33 +41,26 @@
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        try
-        {
-            String locale = "";
-            String path = req.getPathInfo();
-            if (!Helper.isEmpty(path) && path.startsWith("/"))
-                locale = path.substring(1);
-
-            if (Helper.isEmpty(locale))
-            {
-                // fall back to language specified in header e.g. via browser settings
-                String acceptLang = req.getHeader("Accept-Language");
-                if (!Helper.isEmpty(acceptLang))
-                    locale = acceptLang.split(",")[0];
-            }
+        String locale = "";
+        String path = req.getPathInfo();
+        if (!Helper.isEmpty(path) && path.startsWith("/"))
+            locale = path.substring(1);
 
-            Translation tr = map.get(locale);
-            JSONObject json = new JSONObject();
-            if (tr != null && !Locale.US.equals(tr.getLocale()))
-                json.put("default", tr.asMap());
-
-            json.put("locale", locale.toString());
-            json.put("en", map.get("en").asMap());
-            writeJson(req, res, json);
-        } catch (Exception ex)
+        if (Helper.isEmpty(locale))
         {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+            // fall back to language specified in header e.g. via browser settings
+            String acceptLang = req.getHeader("Accept-Language");
+            if (!Helper.isEmpty(acceptLang))
+                locale = acceptLang.split(",")[0];
         }
+
+        Translation tr = map.get(locale);
+        JSONObject json = new JSONObject();
+        if (tr != null && !Locale.US.equals(tr.getLocale()))
+            json.put("default", tr.asMap());
+
+        json.put("locale", locale.toString());
+        json.put("en", map.get("en").asMap());
+        writeJson(req, res, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
index 9b40dd4c02..b6076883a4 100644
--- a/web/src/main/java/com/graphhopper/http/IPFilter.java
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -5,16 +5,17 @@
 import java.util.Set;
 import javax.servlet.*;
 import javax.servlet.http.HttpServletResponse;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
- * <p>
+ * <p/>
  * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
- * <p>
+ * <p/>
  * The internal ip filter from jetty did not work (NP exceptions)
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class IPFilter implements Filter
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
index 824d5c3ee1..9fe1792252 100644
--- a/web/src/main/java/com/graphhopper/http/InfoServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -22,6 +22,7 @@
 import com.graphhopper.util.Constants;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.BBox;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -29,8 +30,8 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+
+
 import org.json.JSONObject;
 
 /**
@@ -44,22 +45,7 @@
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        try
-        {
-            writeInfos(req, res);
-        } catch (IllegalArgumentException ex)
-        {
-            writeError(res, SC_BAD_REQUEST, ex.getMessage());
-        } catch (Exception ex)
-        {
-            logger.error("Error while executing request: " + req.getQueryString(), ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
-    }
-
-    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
-    {
-        BBox bb = hopper.getGraph().getBounds();
+        BBox bb = hopper.getGraphHopperStorage().getBounds();
         List<Double> list = new ArrayList<Double>(4);
         list.add(bb.minLon);
         list.add(bb.minLat);
@@ -69,7 +55,7 @@ void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Except
         JSONObject json = new JSONObject();
         json.put("bbox", list);
 
-        String[] vehicles = hopper.getGraph().getEncodingManager().toString().split(",");
+        String[] vehicles = hopper.getGraphHopperStorage().getEncodingManager().toString().split(",");
         json.put("supported_vehicles", vehicles);
         JSONObject features = new JSONObject();
         for (String v : vehicles)
@@ -83,7 +69,7 @@ void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Except
         json.put("version", Constants.VERSION);
         json.put("build_date", Constants.BUILD_DATE);
 
-        StorableProperties props = hopper.getGraph().getProperties();
+        StorableProperties props = hopper.getGraphHopperStorage().getProperties();
         json.put("import_date", props.get("osmreader.import.date"));
 
         if (!Helper.isEmpty(props.get("prepare.date")))
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index b320b38854..8de227530b 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -15,22 +15,20 @@
  */
 package com.graphhopper.http;
 
+import org.json.JSONObject;
+
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import org.json.JSONObject;
 
 public class InvalidRequestServlet extends GHBaseServlet
 {
     @Override
     protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        res.setStatus(HttpServletResponse.SC_NOT_FOUND);
-        res.setContentType("text/plain");
-        res.setContentType("UTF-8");
         JSONObject json = new JSONObject();
-        json.put("error_code", "404");
-        writeJson(req, res, json);
+        json.put("message", "Not found");
+        writeJsonError(res, HttpServletResponse.SC_NOT_FOUND, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
new file mode 100644
index 0000000000..5696fce229
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -0,0 +1,86 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import javax.inject.Inject;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+/**
+ * @author svantulden
+ */
+public class NearestServlet extends GHBaseServlet
+{
+    @Inject
+    private GraphHopper hopper;
+    private final DistanceCalc calc = Helper.DIST_EARTH;
+
+    @Override
+    public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes ) throws ServletException, IOException
+    {
+        String pointStr = getParam(httpReq, "point", null);
+        boolean enabledElevation = getBooleanParam(httpReq, "elevation", false);
+
+        JSONObject result = new JSONObject();
+        if (pointStr != null && !pointStr.equalsIgnoreCase(""))
+        {
+            GHPoint place = GHPoint.parse(pointStr);
+            LocationIndex index = hopper.getLocationIndex();
+            QueryResult qr = index.findClosest(place.lat, place.lon, EdgeFilter.ALL_EDGES);
+
+            if (!qr.isValid())
+            {
+                result.put("error", "Nearest point cannot be found!");
+            } else
+            {
+                GHPoint3D snappedPoint = qr.getSnappedPoint();
+                result.put("type", "Point");
+
+                JSONArray coord = new JSONArray();
+                coord.put(snappedPoint.lon);
+                coord.put(snappedPoint.lat);
+
+                if (hopper.hasElevation() && enabledElevation)
+                    coord.put(snappedPoint.ele);
+
+                result.put("coordinates", coord);
+
+                // Distance from input to snapped point in meters
+                result.put("distance", calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon));
+            }
+        } else
+        {
+            result.put("error", "No lat/lon specified!");
+        }
+
+        writeJson(httpReq, httpRes, result);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index f9cc20ae9a..1890d9628b 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -21,11 +21,13 @@
 import com.graphhopper.search.ReverseGeocoding;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPlace;
+
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -45,6 +47,7 @@ public static void main( String[] args )
         System.out.println("reverse " + new NominatimGeocoder().places2names(new GHPlace(49.9027606, 11.577197),
                 new GHPlace(52.5198535, 13.4385964)));
     }
+
     private String nominatimUrl;
     private String nominatimReverseUrl;
     private BBox bounds;
@@ -157,7 +160,8 @@ public NominatimGeocoder setBounds( BBox bounds )
 
     HttpURLConnection openConnection( String url ) throws IOException
     {
-        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();;
+        HttpURLConnection hConn = (HttpURLConnection) new URL(url).openConnection();
+        ;
         hConn.setRequestProperty("User-Agent", userAgent);
         hConn.setRequestProperty("content-charset", "UTF-8");
         hConn.setConnectTimeout(timeoutInMillis);
diff --git a/web/src/main/java/com/graphhopper/http/RouteSerializer.java b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
new file mode 100644
index 0000000000..31af004887
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/RouteSerializer.java
@@ -0,0 +1,43 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.PointList;
+import java.util.Map;
+
+/**
+ * This interface speficies how the route should be transformed into JSON.
+ * <p>
+ * @author Peter Karich
+ */
+public interface RouteSerializer
+{
+    /**
+     * This method transforms the specified response into a JSON.
+     */
+    Map<String, Object> toJSON( GHResponse response,
+                                boolean calcPoints, boolean pointsEncoded,
+                                boolean includeElevation, boolean enableInstructions );
+
+    /**
+     * This method returns either a Map containing the GeoJSON of the specified points OR the string
+     * encoded polyline of it.
+     */
+    Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation );
+}
diff --git a/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
new file mode 100644
index 0000000000..627b47b3a3
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/SimpleRouteSerializer.java
@@ -0,0 +1,105 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+import java.util.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class SimpleRouteSerializer implements RouteSerializer
+{
+    private final BBox maxBounds;
+
+    public SimpleRouteSerializer( BBox maxBounds )
+    {
+        this.maxBounds = maxBounds;
+    }
+
+    @Override
+    public Map<String, Object> toJSON( GHResponse rsp,
+                                       boolean calcPoints, boolean pointsEncoded,
+                                       boolean includeElevation, boolean enableInstructions )
+    {
+        Map<String, Object> json = new HashMap<String, Object>();
+
+        if (rsp.hasErrors())
+        {
+            json.put("message", rsp.getErrors().get(0).getMessage());
+            List<Map<String, String>> errorHintList = new ArrayList<Map<String, String>>();
+            for (Throwable t : rsp.getErrors())
+            {
+                Map<String, String> map = new HashMap<String, String>();
+                map.put("message", t.getMessage());
+                map.put("details", t.getClass().getName());
+                errorHintList.add(map);
+            }
+            json.put("hints", errorHintList);
+        } else
+        {
+            Map<String, Object> jsonInfo = new HashMap<String, Object>();
+            json.put("info", jsonInfo);
+            json.put("hints", rsp.getHints().toMap());
+            jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+            jsonPath.put("time", rsp.getTime());
+
+            if (calcPoints)
+            {
+                jsonPath.put("points_encoded", pointsEncoded);
+
+                PointList points = rsp.getPoints();
+                if (points.getSize() >= 2)
+                {
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
+
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
+
+                if (enableInstructions)
+                {
+                    InstructionList instructions = rsp.getInstructions();
+                    jsonPath.put("instructions", instructions.createJson());
+                }
+            }
+            json.put("paths", Collections.singletonList(jsonPath));
+        }
+        return json;
+    }
+
+    @Override
+    public Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+    {
+        if (pointsEncoded)
+            return WebHelper.encodePolyline(points, includeElevation);
+
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
+        jsonPoints.put("type", "LineString");
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+        return jsonPoints;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 02e515b8e9..8a5aaeba92 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -18,6 +18,7 @@
 package com.graphhopper.http;
 
 import com.graphhopper.util.PointList;
+
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -26,11 +27,11 @@
 
 /**
  * Code which handles polyline encoding and other web stuff.
- * <p>
+ * <p/>
  * The necessary information for polyline encoding is in this answer:
  * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
  * good explanation.
- * <p>
+ * <p/>
  * @author Peter Karich
  */
 public class WebHelper
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 294f52f9a5..96f1e94adb 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -37,24 +37,18 @@ if (!Function.prototype.bind) {
 }
 
 GHRequest = function (host) {
-    this.way_point_max_distance = 1;
     this.host = host;
     this.route = new GHroute(new GHInput(), new GHInput());
     this.from = this.route.first();
     this.to = this.route.last();
-    this.vehicle = "car";
-    this.weighting = "fastest";
-    this.points_encoded = true;
-    this.instructions = true;
-    this.elevation = false;
+
     this.features = {};
-    this.debug = false;
-    this.locale = "en";
+
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
-    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
-    this.api_params = [];
+
+    this.api_params = {"locale": "en", "vehicle": "car", "weighting": "fastest", "elevation": false};
 
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
@@ -78,11 +72,7 @@ GHRequest = function (host) {
         this.to = this.route.last();
         log("Foo just moved.");
     }.bind(this));
-//    this.route.addListener('route.set', function (evt) {
-//        this.from = this.route.first();
-//        this.to = this.route.last();
-//        log("Foo just moved.");
-//    }.bind(this));
+    
     this.route.addListener('route.reverse', function (evt) {
         this.from = this.route.first();
         this.to = this.route.last();
@@ -306,50 +296,31 @@ GHroute.prototype = {
 };
 
 GHRequest.prototype.init = function (params) {
+
     for (var key in params) {
         var val = params[key];
         if (val === "false")
             val = false;
         else if (val === "true")
             val = true;
-        else {
-            if (parseFloat(val) != NaN)
-                val = parseFloat(val)
-        }
 
-        // todo
-        // this[key] = val;
+        if (key === "point" || key === "mathRandom" || key === "do_zoom" || key === "layer")
+            continue;
 
-        if (key.indexOf('api.') === 0) {
-            this.api_params[key.substring(4)] = val;
-        }
+        this.api_params[key] = val;
     }
 
-    if (params.minPathPrecision)
-        this.minPathPrecision = params.minPathPrecision;
-    if (params.vehicle)
-        this.vehicle = params.vehicle;
-    if (params.weighting)
-        this.weighting = params.weighting;
-    if (params.algorithm)
-        this.algorithm = params.algorithm;
-    if (params.locale)
-        this.locale = params.locale;
-
     if ('do_zoom' in params)
         this.do_zoom = params.do_zoom;
-    if ('instructions' in params)
-        this.instructions = params.instructions;
-    if ('points_encoded' in params)
-        this.points_encoded = params.points_encoded;
 
-    this.elevation = false;
+    // overwrite elevation e.g. important if not supported from feature set
+    this.api_params.elevation = false;
     var featureSet = this.features[this.vehicle];
     if (featureSet && featureSet.elevation) {
         if ('elevation' in params)
-            this.elevation = params.elevation;
+            this.api_params.elevation = params.elevation;
         else
-            this.elevation = true;
+            this.api_params.elevation = true;
     }
 
     if (params.q) {
@@ -381,16 +352,21 @@ GHRequest.prototype.init = function (params) {
 };
 
 GHRequest.prototype.initVehicle = function (vehicle) {
-    this.vehicle = vehicle;
+    this.api_params.vehicle = vehicle;
     var featureSet = this.features[this.vehicle];
+
     if (featureSet && featureSet.elevation)
-        this.elevation = true;
+        this.api_params.elevation = true;
     else
-        this.elevation = false;
+        this.api_params.elevation = false;
 };
 
 GHRequest.prototype.hasElevation = function () {
-    return this.elevation;
+    return this.api_params.elevation;
+};
+
+GHRequest.prototype.getVehicle = function () {
+    return this.api_params.vehicle;
 };
 
 GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
@@ -434,30 +410,15 @@ GHRequest.prototype.createPointParams = function (useRawInput) {
 };
 
 GHRequest.prototype.createPath = function (url) {
-    if (this.vehicle && this.vehicle !== "car")
-        url += "&vehicle=" + this.vehicle;
-    // fastest or shortest
-    if (this.weighting && this.weighting !== "fastest")
-        url += "&weighting=" + this.weighting;
-    if (this.locale && this.locale !== "en")
-        url += "&locale=" + this.locale;
-    // dijkstra, dijkstrabi, astar, astarbi
-    if (this.algorithm && this.algorithm !== "dijkstrabi")
-        url += "&algorithm=" + this.algorithm;
-    if (this.way_point_max_distance !== 1)
-        url += "&way_point_max_distance=" + this.way_point_max_distance;
-    if (!this.instructions)
-        url += "&instructions=false";
-    if (!this.points_encoded)
-        url += "&points_encoded=false";
-
-    if (this.elevation)
-        url += "&elevation=true";
-    if (this.debug)
-        url += "&debug=true";
-
     for (var key in this.api_params) {
-        url += "&" + key + "=" + this.api_params[key];
+        var val = this.api_params[key];
+        if (GHroute.isArray(val)) {
+            for (var keyIndex in val) {
+                url += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(val[keyIndex]);
+            }
+        } else {
+            url += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(val);
+        }
     }
     return url;
 };
@@ -539,22 +500,20 @@ GHRequest.prototype.doRequest = function (url, callback) {
             // problematic: this callback is not invoked when using JSONP!
             // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
+            var json;
+
             if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
-                var jsonError = JSON.parse(err.responseText);
-                msg += jsonError.message;
-            } else if (err && err.statusText && err.statusText !== "OK")
+                json = JSON.parse(err.responseText);
+            } else if (err && err.statusText && err.statusText !== "OK") {
                 msg += err.statusText;
-
+                var details = "Error for " + url;
+                json = {
+                    message: msg,
+                    hints: [{"message": msg, "details": details}]
+                };
+            }
             log(msg + " " + JSON.stringify(err));
-            var details = "Error for " + url;
-            var json = {
-                "info": {
-                    "errors": [{
-                            "message": msg,
-                            "details": details
-                        }]
-                }
-            };
+
             callback(json);
         },
         type: "GET",
@@ -637,7 +596,7 @@ GHInput.prototype.toString = function () {
 
 GHRequest.prototype.setLocale = function (locale) {
     if (locale)
-        this.locale = locale;
+        this.api_params.locale = locale;
 };
 
 GHRequest.prototype.fetchTranslationMap = function (urlLocaleParam) {
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index e7e3c17ee3..3a1a7ea638 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -29,7 +29,7 @@ var defaultTranslationMap = null;
 var enTranslationMap = null;
 var routeSegmentPopup = null;
 var elevationControl = null;
-var activeLayer = 'MapQuest';
+var activeLayer = '';
 var i18nIsInitialized;
 
 var iconFrom = L.icon({
@@ -314,8 +314,14 @@ function initMap(selectLayer) {
     if (L.Browser.retina)
         tp = "lr";
 
-    var sorbianLang = L.tileLayer('http://map.dgpsonline.eu/osmsb/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://www.alberding.eu/"> Alberding GmbH, CC-BY-SA</a>'
+    var lyrk = L.tileLayer('https://tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
+        attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
+        subdomains: ['a', 'b', 'c']
+    });
+
+    var omniscale = L.tileLayer.wms('https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile', {
+        layers: 'osm',
+        attribution: osmAttr + ', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'
     });
 
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
@@ -332,6 +338,15 @@ function initMap(selectLayer) {
         attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
     });
 
+    // not an option as too fast over limit
+//    var mapbox= L.tileLayer('https://{s}.tiles.mapbox.com/v4/peterk.map-vkt0kusv/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoicGV0ZXJrIiwiYSI6IkdFc2FJd2MifQ.YUd7dS_gOpT3xrQnB8_K-w', {
+//        attribution: osmAttr + ', <a href="https://www.mapbox.com/about/maps/">&copy; MapBox</a>'
+//    });
+
+    var sorbianLang = L.tileLayer('http://map.dgpsonline.eu/osmsb/{z}/{x}/{y}.png', {
+        attribution: osmAttr + ', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'
+    });
+
     var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
@@ -369,6 +384,8 @@ function initMap(selectLayer) {
     });
 
     var baseMaps = {
+        "Lyrk": lyrk,
+        "Omniscale": omniscale,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
         "Esri Aerial": esriAerial,
@@ -384,7 +401,7 @@ function initMap(selectLayer) {
 
     var defaultLayer = baseMaps[selectLayer];
     if (!defaultLayer)
-        defaultLayer = mapquest;
+        defaultLayer = omniscale;
 
     // default
     map = L.map('map', {
@@ -458,7 +475,7 @@ function initMap(selectLayer) {
     map.on('baselayerchange', function (a) {
         if (a.name) {
             activeLayer = a.name;
-            $("#export-link a").attr('href', function(i, v) {
+            $("#export-link a").attr('href', function (i, v) {
                 return v.replace(/(layer=)([\w\s]+)/, '$1' + activeLayer);
             });
         }
@@ -892,9 +909,7 @@ function doGeoCoding(input, limit, timeout) {
         type: "GET",
         dataType: "json",
         timeout: timeout
-    }).fail(
-            createCallback("[nominatim] Problem while looking up location " + input)
-            );
+    }).fail(createCallback("[nominatim] Problem while looking up location " + input));
 }
 
 function createCallback(errorFallback) {
@@ -954,17 +969,21 @@ function routeLatLng(request, doQuery) {
     map.contextmenu.setDisabled(menuIntermediate, false);
 
     $("#vehicles button").removeClass("selectvehicle");
-    $("button#" + request.vehicle.toLowerCase()).addClass("selectvehicle");
+    $("button#" + request.getVehicle().toLowerCase()).addClass("selectvehicle");
 
     var urlForAPI = request.createURL();
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
     request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
-        if (json.info.errors) {
-            var tmpErrors = json.info.errors;
+        if (json.message) {
+            var tmpErrors = json.message;
             log(tmpErrors);
-            for (var m = 0; m < tmpErrors.length; m++) {
-                descriptionDiv.append("<div class='error'>" + tmpErrors[m].message + "</div>");
+            if (json.hints) {
+                for (var m = 0; m < json.hints.length; m++) {
+                    descriptionDiv.append("<div class='error'>" + json.hints[m].message + "</div>");
+                }
+            } else {
+                descriptionDiv.append("<div class='error'>" + tmpErrors + "</div>");
             }
             return;
         }
@@ -1059,8 +1078,7 @@ function routeLatLng(request, doQuery) {
                 hiddenDiv.toggle();
             });
             $("#info").append(toggly);
-            var infoStr = "took: " + round(json.info.took / 1000, 1000) + "s"
-                    + ", points: " + path.points.coordinates.length;
+            var infoStr = "points: " + path.points.coordinates.length;
 
             hiddenDiv.append("<span>" + infoStr + "</span>");
 
@@ -1069,10 +1087,11 @@ function routeLatLng(request, doQuery) {
             var osmRouteLink = $("<br/><a>view on OSM</a>");
 
             var osmVehicle = "bicycle";
-            if (request.vehicle.toUpperCase() === "FOOT") {
+            if (request.getVehicle().toUpperCase() === "FOOT") {
                 osmVehicle = "foot";
             }
-            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
+            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" 
+                    + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
             hiddenDiv.append(osmRouteLink);
 
             var osrmLink = $("<a>OSRM</a>");
@@ -1082,11 +1101,11 @@ function routeLatLng(request, doQuery) {
             var googleLink = $("<a>Google</a> ");
             var addToGoogle = "";
             var addToBing = "";
-            if (request.vehicle.toUpperCase() === "FOOT") {
+            if (request.getVehicle().toUpperCase() === "FOOT") {
                 addToGoogle = "&dirflg=w";
                 addToBing = "&mode=W";
-            } else if ((request.vehicle.toUpperCase().indexOf("BIKE") >= 0) ||
-                    (request.vehicle.toUpperCase() === "MTB")) {
+            } else if ((request.getVehicle().toUpperCase().indexOf("BIKE") >= 0) ||
+                    (request.getVehicle().toUpperCase() === "MTB")) {
                 addToGoogle = "&dirflg=b";
                 // ? addToBing = "&mode=B";
             }
@@ -1231,25 +1250,24 @@ function parseUrl(query) {
         if (value === "")
             continue;
 
-        if (key === "point" && !res[key]) {
-            res[key] = [value];
-        } else if (typeof res[key] === "string") {
-            var arr = [res[key], value];
-            res[key] = arr;
-        } else if (typeof res[key] === "undefined") {
-            if (value === 'true') {
-                res[key] = true;
-            } else if (value === 'false') {
-                res[key] = false;
+        // force array for heading and point
+        if (typeof res[key] === "undefined"
+                && key !== "heading" && key !== "point") {
+            if (value === 'true')
+                value = true;
+            else if (value === 'false')
+                value = false;
+
+            res[key] = value;
+        } else {
+            var tmpVal = res[key];
+            if (GHroute.isArray(tmpVal)) {
+                tmpVal.push(value);
+            } else if (tmpVal) {
+                res[key] = [tmpVal, value];
             } else {
-                var tmp = Number(value);
-                if (isNaN(tmp))
-                    res[key] = value;
-                else
-                    res[key] = Number(value);
+                res[key] = [value];
             }
-        } else {
-            res[key].push(value);
         }
     }
     return res;
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index b1c47148fe..924d19d696 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -22,10 +22,15 @@
 import com.google.inject.Module;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.HttpURLConnection;
+
+import static org.junit.Assert.assertEquals;
+
 /**
  * @author Peter Karich
  */
@@ -95,13 +100,45 @@ public static void shutdownJetty( boolean force )
         server = null;
     }
 
-    protected String getTestAPIUrl()
+    protected String getTestRouteAPIUrl()
     {
         String host = "localhost";
         return "http://" + host + ":" + port + "/route";
     }
 
-    protected JSONObject query( String query ) throws Exception
+    protected String getTestNearestAPIUrl()
+    {
+        String host = "localhost";
+        return "http://" + host + ":" + port + "/nearest";
+    }
+
+    protected String queryString( String query, int code ) throws Exception
+    {
+        String resQuery = "";
+        for (String q : query.split("\\&"))
+        {
+            int index = q.indexOf("=");
+            if (index > 0)
+                resQuery += q.substring(0, index + 1) + WebHelper.encodeURL(q.substring(index + 1));
+            else
+                resQuery += WebHelper.encodeURL(q);
+
+            resQuery += "&";
+        }
+        String url = getTestRouteAPIUrl() + "?" + resQuery;
+        Downloader downloader = new Downloader("web integration tester").setTimeout(1000);
+        HttpURLConnection conn = downloader.createConnection(url);
+        conn.connect();
+        assertEquals(code, conn.getResponseCode());
+        return Helper.isToString(downloader.fetch(conn, true));
+    }
+
+    protected JSONObject query( String query, int code ) throws Exception
+    {
+        return new JSONObject(queryString(query, code));
+    }
+
+    protected JSONObject nearestQuery( String query ) throws Exception
     {
         String resQuery = "";
         for (String q : query.split("\\&"))
@@ -114,8 +151,8 @@ protected JSONObject query( String query ) throws Exception
 
             resQuery += "&";
         }
-        String url = getTestAPIUrl() + "?" + resQuery;
+        String url = getTestNearestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
-        return new JSONObject(downloader.downloadAsString(url));
-    }    
+        return new JSONObject(downloader.downloadAsString(url, true));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 6f74987210..fef0887478 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -23,13 +23,15 @@
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.File;
-import java.util.List;
-import java.util.Map;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
 import static org.junit.Assert.*;
 
 /**
@@ -59,7 +61,7 @@ public void setUp()
     @Test
     public void testBasicQuery() throws Exception
     {
-        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128");
+        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -68,10 +70,38 @@ public void testBasicQuery() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testQuerywithDirections() throws Exception
+    {
+        // Note, in general specifying directions does not work with CH, but this is an example where it works
+        JSONObject json = query("point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 960);
+        assertTrue("distance wasn't correct:" + distance, distance < 970);
+    }
+
+    @Test
+    public void testQuerywithStraightVia() throws Exception
+    {
+        // Note, in general specifying straightvia does not work with CH, but this is an example where it works
+        JSONObject json = query(
+                "point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true", 200);
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 320);
+        assertTrue("distance wasn't correct:" + distance, distance < 325);
+    }
+
+
     @Test
     public void testJsonRounding() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
         assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
@@ -79,17 +109,17 @@ public void testJsonRounding() throws Exception
     @Test
     public void testFailIfElevationRequestedButNotIncluded() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true");
-        JSONObject infoJson = json.getJSONObject("info");
-        assertTrue(infoJson.has("errors"));
-        assertEquals("Elevation not supported!", infoJson.getJSONArray("errors").getJSONObject(0).getString("message"));
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
+        assertTrue(json.has("message"));
+        assertEquals("Elevation not supported!", json.get("message"));
+        assertEquals("Elevation not supported!", json.getJSONArray("hints").getJSONObject(0).getString("message"));
     }
 
     @Test
     public void testGraphHopperWeb() throws Exception
     {
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
@@ -112,17 +142,14 @@ public void testGraphHopperWeb() throws Exception
     @Test
     public void testGraphHopperWebRealExceptions()
     {
-        GHResponse rsp;
-        Throwable ex;
-
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
 
         // IllegalStateException (Wrong Request)
-        rsp = hopper.route(new GHRequest());
+        GHResponse rsp = hopper.route(new GHRequest());
         assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
 
-        ex = rsp.getErrors().get(0);
+        Throwable ex = rsp.getErrors().get(0);
         assertTrue("Wrong Exception found: " + ex.getClass().getName()
                 + ", IllegalStateException expected.", ex instanceof IllegalStateException);
 
@@ -146,4 +173,22 @@ public void testGraphHopperWebRealExceptions()
         // RuntimeException
         // Exception
     }
+
+    @Test
+    public void testGPX() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx", 200);
+        assertTrue(str.contains("<gh:distance>115.1</gh:distance>"));
+        assertTrue(str.contains("<trkpt lat=\"42.554839\" lon=\"1.536374\"><time>"));
+    }
+
+    @Test
+    public void testGPXWithError() throws Exception
+    {
+        String str = queryString("point=42.554851,1.536198&type=gpx", 400);
+        assertFalse(str, str.contains("<html>"));
+        assertFalse(str, str.contains("{"));
+        assertTrue("Expected error but was: " + str, str.contains("<message>At least 2 points has to be specified, but was:1</message>"));
+        assertTrue("Expected error but was: " + str, str.contains("<hints><error details=\"java"));
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index 7e5aa6af65..248b1cdee9 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -19,11 +19,14 @@
 
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+
 import java.io.File;
+
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
@@ -56,7 +59,7 @@ public void setUp()
     @Test
     public void testElevation() throws Exception
     {
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -76,7 +79,7 @@ public void testElevation() throws Exception
     public void testNoElevation() throws Exception
     {
         // default is elevation=false
-        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false");
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -87,7 +90,7 @@ public void testNoElevation() throws Exception
         assertTrue("Elevation should not be included!", cson.toString().contains("[7.421392,43.7307]"));
 
         // disable elevation
-        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
+        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false", 200);
         infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         path = json.getJSONArray("paths").getJSONObject(0);
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index c7c6de2be3..7a804e5ca0 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -20,13 +20,16 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.util.Downloader;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.HttpURLConnection;
+
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class GraphHopperWebTest
@@ -39,7 +42,7 @@ public void testReadEncoded() throws Exception
         Downloader downloader = new Downloader("GraphHopper Test")
         {
             @Override
-            public InputStream fetch( String url ) throws IOException
+            public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
             {
                 return getClass().getResourceAsStream("test_encoded.json");
             }
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
index dc2470b6f2..2b6b24ca23 100644
--- a/web/src/test/java/com/graphhopper/http/IPFilterTest.java
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -1,10 +1,10 @@
 package com.graphhopper.http;
 
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class IPFilterTest
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
new file mode 100644
index 0000000000..3cb2a78760
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -0,0 +1,70 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+
+import java.io.File;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletIT extends BaseServletTester
+{
+    private static final String dir = "./target/andorra-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/andorra.osm.pbf").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testBasicNearestQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=42.554851,1.536198");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 42.55483907636756 && lon == 1.5363742288086868);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
new file mode 100644
index 0000000000..cb8f5c2692
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -0,0 +1,95 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+
+import java.io.File;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletWithEleIT extends BaseServletTester
+{
+    private static final String dir = "./target/monaco-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("graph.elevation.provider", "srtm").
+                put("graph.elevation.cachedir", "../core/files/").
+                put("prepare.chWeighting", "no").
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/monaco.osm.gz").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testWithEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=true");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 3D: " + point, point.length() == 3);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        double ele = point.getDouble(2);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon + ", ele=" + ele, lat == 43.73070006215647 && lon == 7.421392181993846 && ele == 66.0);
+    }
+
+    @Test
+    public void testWithoutEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=false");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+
+        // Default elevation is false        
+        json = nearestQuery("point=43.730864,7.420771");
+        assertFalse(json.has("error"));
+        point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        lon = point.getDouble(0);
+        lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
index 4276ca4ed5..1f75fbbb52 100644
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -20,10 +20,10 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
  */
 public class WebHelperTest
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index 5babc0a48f..e9bd301808 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -1,8 +1,8 @@
 /*
  * This software stands under the Apache 2 License
  */
-describe("utils", function() {
-    it("should format time string correctly", function() {
+describe("utils", function () {
+    it("should format time string correctly", function () {
         defaultTranslationMap = {};
         defaultTranslationMap["minabbr"] = 'min';
         defaultTranslationMap["hourabbr"] = 'h';
@@ -16,7 +16,7 @@ describe("utils", function() {
         expect(createTimeString(12000)).toBe("0min");
     });
 
-    it("should format translation string correctly", function() {
+    it("should format translation string correctly", function () {
         // toBe, toBeTruthy, toBeFalsy
         defaultTranslationMap = {};
         defaultTranslationMap["web.somekey1"] = "%s wow %s";
@@ -32,7 +32,7 @@ describe("utils", function() {
         expect(tr("key", [200, "km", "2min"])).toBe("200km werden 2min brauchen");
     });
 
-    it("should format location entry correctly", function() {
+    it("should format location entry correctly", function () {
         var res = formatLocationEntry({
             "state": "Berlin",
             "country": "Deutschland",
@@ -53,7 +53,7 @@ describe("utils", function() {
         expect(res).toEqual({postcode: undefined, city: "Rixdorf, Neuklln", country: "Deutschland", more: "Berlin, Europischen Union"});
     });
 
-    it("should decode the polyline", function() {
+    it("should decode the polyline", function () {
         var list = decodePath("_p~iF~ps|U", false);
         expect(list).toEqual([[-120.2, 38.5]]);
 
@@ -61,7 +61,7 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5], [-120.95, 40.7], [-126.45300000000002, 43.252]]);
     });
 
-    it("should decode the 3D polyline", function() {
+    it("should decode the 3D polyline", function () {
         var list = decodePath("_p~iF~ps|Uo}@", true);
         expect(list).toEqual([[-120.2, 38.5, 10]]);
 
@@ -69,52 +69,65 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5, 10], [-120.95, 40.7, 1234], [-126.45300000000002, 43.252, 1234]]);
     });
 
-    it("should parse URL correctly", function() {
-        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1");
+    it("should parse URL correctly", function () {
+        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1&test5=2.7");
         expect("pest").toEqual(params.test);
         expect(true).toEqual(params.test2);
         expect(false).toEqual(params.test3);
-        expect(2).toEqual(params.test4);
-        expect(1.1).toEqual(params.test5);
-        
-        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");        
-        expect(params.point).toEqual("49.946505,11.571232");        
-        
+        expect("2").toEqual(params.test4);
+        expect(["1.1", "2.7"]).toEqual(params.test5);
+
+        // force array for point
+        // URLs with one point only should work: https://graphhopper.com/maps/?point=50.413331%2C11.699066
+        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
+
         params = parseUrl("blup?point=&point=49.946505%2C11.571232");
-        expect(params.point).toEqual("49.946505,11.571232");
+        expect(params.point).toEqual(["49.946505,11.571232"]);
     });
 
-    it("features should work", function() {
+    it("features should work", function () {
         var ghRequest = new GHRequest("http://test.de?vehicle=car");
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{}};
+        ghRequest.features = {"car": {}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
-        ghRequest.features = {"car":{ elevation: true}};
+
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(true);
-        
+
         var params = {};
         params.elevation = false;
-        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.features = {"car": {elevation: true}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
-        
+
         var params = {};
         params.elevation = true;
-        ghRequest.features = {"car":{ elevation: false}};
+        ghRequest.features = {"car": {elevation: false}};
         ghRequest.init(params);
         expect(ghRequest.elevation).toEqual(false);
+
+        ghRequest = new GHRequest("http://test.de");
+        var params = {point: [[4, 3], [2, 3]], test: "x", test_array: [1, 2]};
+        ghRequest.init(params);
+        
+        // skip point, layer etc
+        expect(ghRequest.api_params.point).toEqual(undefined);
+
+        // include all other parameters
+        expect(ghRequest.api_params.test).toEqual("x");
+        expect(ghRequest.api_params.test_array).toEqual([1, 2]);
     });
-    
-    it("ghrequest should init correctly from params", function() {
+
+    it("ghrequest should init correctly from params", function () {
         var ghRequest = new GHRequest("http://test.de");
         var params = {};
         params.do_zoom = true;
@@ -126,7 +139,7 @@ describe("utils", function() {
         expect(ghRequest.do_zoom).toEqual(params.do_zoom);
     });
 
-    it("input should accept 0 and no addresses", function() {
+    it("input should accept 0 and no addresses", function () {
         var input = new GHInput("12,0");
         expect(input.toString()).toEqual("12,0");
         var input = new GHInput("bluo,0");
@@ -138,19 +151,19 @@ describe("utils", function() {
         var input = new GHInput("");
         expect(input.toString()).toEqual(undefined);
     });
-    
-    it("GHInput should set to unresolved if new input string", function() {
+
+    it("GHInput should set to unresolved if new input string", function () {
         var input = new GHInput("12.44, 68.44");
         expect(input.isResolved()).toEqual(true);
         input.set("blup");
         expect(input.isResolved()).toEqual(false);
     });
 
-    it("point should be parsable", function() {
+    it("point should be parsable", function () {
         expect(new GHInput("12.44, 68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44, 68.44").lng).toEqual(68.44);
         expect(new GHInput("12.44,68.44").lat).toEqual(12.44);
         expect(new GHInput("12.44,68.44").lng).toEqual(68.44);
         expect(new GHInput("london").lon).toEqual(undefined);
-    });    
+    });
 });
\ No newline at end of file
