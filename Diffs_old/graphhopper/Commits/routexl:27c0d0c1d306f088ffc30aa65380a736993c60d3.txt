diff --git a/.gitignore b/.gitignore
index 69ae966692..d5c6eb8b7a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,5 @@
 target/
 *~
-*largeEWD.txt.gz
 TODO.txt
 *-gh/
 *.osm
@@ -10,12 +9,9 @@ build.xml
 queries.sh
 maven/
 measurement*.properties
-live_graphhopper.sh
 gen/
 bin/
 *.map
-scripts/googlecode_upload.py
-deploy.sh
 android/libs/graphhopper-*-android.jar
 */nbactions.xml
 .idea/
@@ -27,4 +23,7 @@ debug.sh
 core/TODO*.txt
 srtmprovider/
 core/docs/
-.*#
\ No newline at end of file
+.*#
+cgiarprovider/
+/nbactions.xml
+tools/nb-configuration.xml
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index c7d586d80c..b1b8faf3f1 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,6 @@
 language: java
 jdk:
   - openjdk7
-  - openjdk6
   - oraclejdk7
   - oraclejdk8
 # do not install anything instead return true via unix command true
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 2d06450a4a..4ce4c879f4 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,28 +1,36 @@
 Submit a new issue only if you are sure it is a missing feature or a bug. Otherwise discuss the topic on the 
-[mailing list](http://graphhopper.com/#developers) first.
+[mailing list](http://graphhopper.com/#developers) first. For new translations or fixes to existing translations
+please refer to [this documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/core/translations.md).
+
+Issues for newcomers are tagged with 
+['good first issue'](https://github.com/graphhopper/graphhopper/labels/good%20first%20issue) 
+and documentation issues are taged with 
+['documentation'](https://github.com/graphhopper/graphhopper/labels/documentation).
 
 ## We love pull requests. Here's a quick guide:
 
-1. [Fork the repo](https://help.github.com/articles/fork-a-repo), optionally create a feature branch
+1. [Fork the repo](https://help.github.com/articles/fork-a-repo) and create a branch for your new feature or bug fix.
 
-2. Run the tests. We only take pull requests with passing tests: `mvn test`
+2. Run the tests. We only take pull requests with passing tests: `mvn clean test verify`
 
-3. Add a test for your change. Only refactoring and documentation changes
-require no new tests. If you are adding functionality or fixing a bug, we need
-a test!
+3. Add at least one test for your change. Only refactoring and documentation changes
+require no new tests. Also make sure you submit a change specific to exactly one issue. If you have ideas for multiple 
+changes please create separate pull requests.
 
-4. Make the test pass.
+4. Make the test(s) pass.
 
-5. Push to your fork and [submit a pull request](https://help.github.com/articles/using-pull-requests)
+5. Push to your fork and [submit a pull request](https://help.github.com/articles/using-pull-requests). A button should
+appear on your fork its github page afterwards.
 
 ## License Agreement
 
-For contributions like pull requests, bug fixes and translations please read and sign 
-the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>. 
+For contributions like pull requests, bug fixes and translations please read and electronically sign 
+the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>,
+which gives not away your rights but it will make sure for others that you agree to the Apache License, Version 2.
 
 ## Syntax:
 
-* Tell this your IDE or just use NetBeans which picks the format from pom.xml. E.g. no tabs - use 4 spaces instead!!
+* Tell this your IDE or just use NetBeans which picks the format from pom.xml. E.g. no tabs - use 4 spaces instead!
 * Follow the conventions you see used in the source already.
 
 And in case we didn't emphasize it enough: we love tests!
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index e7fdd2bdb5..d3264e5372 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -2,16 +2,24 @@
 
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
+ * cgarreau, increase of routing success rate via subnetwork cleanup
  * daisy1754, fixed usage of graphhopper.sh script
  * dardin88, instructions improved
  * lmar, improved instructions information
  * fredao, translations
+ * jansoe, algorithm improvements
  * jansonhanson, general host config
- * JohannesPelzer, improved GPX information
+ * JohannesPelzer, improved GPX information and various other things
  * karussell, lead developer
  * khuebner, pushes turn instructions forward 
  * lmar, improved instructions
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
  * ratrun, route relations, GPX information and bike handling
- * rodo, more descriptions
\ No newline at end of file
+ * rodneyodonnell, improved dead end removal
+ * rodo, more descriptions
+
+# Translations
+
+A lot people helped to create translations - thanks!
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
\ No newline at end of file
diff --git a/NOTICE.md b/NOTICE.md
index a7918942a1..2da14a4df8 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -18,5 +18,7 @@ web
  * org.json, MIT style license
  * com.google.inject, Apache License 2.0
  * images from mapbox https://www.mapbox.com/maki/, BSD License, see core/files
+
+android
  * android, Apache License 2.0
  * org.mapsforge, LGPL
diff --git a/README.md b/README.md
index 071ec834fa..377c3f9495 100644
--- a/README.md
+++ b/README.md
@@ -3,21 +3,42 @@
 [![Build Status](https://secure.travis-ci.org/graphhopper/graphhopper.png?branch=master)](http://travis-ci.org/graphhopper/graphhopper)
 
 GraphHopper is a fast and memory efficient Java road routing engine released under Apache License 2.0.
-It is tuned towards road networks with OpenStreetMap data but can be useful for public transport problems as well.
+Per default it uses OpenStreetMap data but can import other data sources.
 
+GraphHopper for the Web
+--------------
 
-Get Started & Contribute
+See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
+
+[![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
+
+GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api), which provides 
+routing and matrix routing through GraphHopper and also a fast address search via [Photon](https://github.com/komoot/photon).
+Additionally the map tiles from various Providers like [Lyrk](https://geodienste.lyrk.de/pakete)
+are used and all is available for free and through HTTPS for a secure route planning experience!
+
+
+GraphHopper for Mobile
+---------------
+
+There are subprojects to make GraphHopper working offline
+on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+and [iOS](http://github.com/graphhopper/graphhopper-ios)
+
+
+Get Started
 ---------------
 
-Read through our [wiki](https://github.com/graphhopper/graphhopper/wiki/), 
-[how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) and 
+Read through our [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
-or sign up to the [mailing list](http://graphhopper.com/#developers).
+and sign up to the [mailing list](http://graphhopper.com/#developers).
 
-**Please only email me directly if you need consultancy** or can't explain your problem in the public.
 
-There are subprojects to make GraphHopper working on [Android](https://github.com/graphhopper/graphhopper/wiki/Android) or 
-as a [web application](https://github.com/graphhopper/graphhopper/tree/master/web). Have a look into our [live application](http://graphhopper.com/maps)
+Contribute
+---------------
+
+Read through [how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md)
+like finding and fixing bugs and improving our documentation or translations!
 
 
 Features
@@ -27,6 +48,6 @@ Features
  * Open Source
  * Memory efficient and fast
  * Highly customizable
- * Works on the desktop, as a web service and offline on Android
- * Well tested
+ * Works on the desktop, as a web service and offline on Android or iOS
+ * Large test suite
  * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
diff --git a/android/README.md b/android/README.md
index b482c1b545..f896af0373 100644
--- a/android/README.md
+++ b/android/README.md
@@ -1,6 +1,6 @@
-This is a simple Eclipse project which uses graphhoppers routing and mapsforge to display the map.
-
-* Download the apk [here](http://graphhopper.com/#download)
-* More information about setup, maps creation etc is [in the wiki](https://github.com/graphhopper/graphhopper/wiki/Android)
+This maven module can be used for various IDEs like NetBeans or Eclipse to
+make GraphHopper offline routing working on Android. For offline
+maps the mapsforge project is used. For more information see the 
+[android docs](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md).
 
 ![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
diff --git a/android/libs/mapsforge-core-0.4.0-SNAPSHOT.jar b/android/libs/mapsforge-core-0.4.3.jar
similarity index 86%
rename from android/libs/mapsforge-core-0.4.0-SNAPSHOT.jar
rename to android/libs/mapsforge-core-0.4.3.jar
index 75765118b6..82d62ee4f7 100644
Binary files a/android/libs/mapsforge-core-0.4.0-SNAPSHOT.jar and b/android/libs/mapsforge-core-0.4.3.jar differ
diff --git a/android/libs/mapsforge-map-0.4.0-SNAPSHOT.jar b/android/libs/mapsforge-map-0.4.3.jar
similarity index 88%
rename from android/libs/mapsforge-map-0.4.0-SNAPSHOT.jar
rename to android/libs/mapsforge-map-0.4.3.jar
index 3ace39569f..eba6643ef4 100644
Binary files a/android/libs/mapsforge-map-0.4.0-SNAPSHOT.jar and b/android/libs/mapsforge-map-0.4.3.jar differ
diff --git a/android/libs/mapsforge-map-android-0.4.0-SNAPSHOT.jar b/android/libs/mapsforge-map-android-0.4.3.jar
similarity index 87%
rename from android/libs/mapsforge-map-android-0.4.0-SNAPSHOT.jar
rename to android/libs/mapsforge-map-android-0.4.3.jar
index d8044b0b0f..0a6789d6c8 100644
Binary files a/android/libs/mapsforge-map-android-0.4.0-SNAPSHOT.jar and b/android/libs/mapsforge-map-android-0.4.3.jar differ
diff --git a/android/libs/mapsforge-map-reader-0.4.0-SNAPSHOT.jar b/android/libs/mapsforge-map-reader-0.4.3.jar
similarity index 86%
rename from android/libs/mapsforge-map-reader-0.4.0-SNAPSHOT.jar
rename to android/libs/mapsforge-map-reader-0.4.3.jar
index cce15f7fee..214bb5c8f3 100644
Binary files a/android/libs/mapsforge-map-reader-0.4.0-SNAPSHOT.jar and b/android/libs/mapsforge-map-reader-0.4.3.jar differ
diff --git a/android/nb-configuration.xml b/android/nb-configuration.xml
index 94309b4d48..f677015e2a 100644
--- a/android/nb-configuration.xml
+++ b/android/nb-configuration.xml
@@ -16,8 +16,7 @@
         That way multiple projects can share the same settings (useful for formatting rules for example).
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
-        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>       
-        <netbeans.hint.jdkPlatform>JDK_1.6</netbeans.hint.jdkPlatform>
-        <netbeans.compile.on.save>all</netbeans.compile.on.save>        
+        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
+        <netbeans.compile.on.save>all</netbeans.compile.on.save>
     </properties>
 </project-shared-configuration>
diff --git a/android/pom.xml b/android/pom.xml
index 0176187c38..b257acaa32 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.4-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -15,10 +15,13 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.4-SNAPSHOT</version>
     </parent>
     <properties>
+        <!--
         <mapsforge.version>0.3-0.4.0-SNAPSHOT</mapsforge.version>
+        -->
+        <mapsforge.version>0.4.3</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -32,18 +35,12 @@
             <version>${project.parent.version}</version>            
             <type>jar</type>
             <exclusions>
+                <!--
                 <exclusion>
                     <groupId>org.slf4j</groupId>
                     <artifactId>slf4j-api</artifactId>                    
-                </exclusion>
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-log4j12</artifactId>                    
-                </exclusion>
-                <exclusion>
-                    <groupId>log4j</groupId>
-                    <artifactId>log4j</artifactId>                    
-                </exclusion>
+                </exclusion> 
+                -->
                 <exclusion>
                     <groupId>com.google.protobuf</groupId>
                     <artifactId>protobuf-java</artifactId>                    
@@ -52,29 +49,34 @@
                     <groupId>org.openstreetmap.osmosis</groupId>
                     <artifactId>osmosis-osm-binary</artifactId>                    
                 </exclusion>
+                <exclusion>
+                    <groupId>org.apache.xmlgraphics</groupId>
+                    <artifactId>xmlgraphics-commons</artifactId>
+                </exclusion>
             </exclusions>
         </dependency>        
           
-        <!-- see scripts/maven-install-mapsforge.sh !
-            if we would use system dep it doesn't work (classnotfound). See also script for more infos.
+        <!-- see scripts/maven-install-mapsforge.sh if downloading from
+             maven central does not work (it should). 
+             if we would use system dep it doesn't work (classnotfound). See also script for more infos.
         -->          
         <dependency>
-            <groupId>com.graphhopper</groupId>            
+            <groupId>org.mapsforge</groupId>            
             <artifactId>mapsforge-core</artifactId>
             <version>${mapsforge.version}</version>
         </dependency>    
         <dependency>
-            <groupId>com.graphhopper</groupId>            
+            <groupId>org.mapsforge</groupId>            
             <artifactId>mapsforge-map</artifactId>
             <version>${mapsforge.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.graphhopper</groupId>            
+            <groupId>org.mapsforge</groupId>            
             <artifactId>mapsforge-map-android</artifactId>
             <version>${mapsforge.version}</version>
         </dependency>        
         <dependency>
-            <groupId>com.graphhopper</groupId>            
+            <groupId>org.mapsforge</groupId>            
             <artifactId>mapsforge-map-reader</artifactId>
             <version>${mapsforge.version}</version>
         </dependency>
@@ -82,8 +84,14 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.6.1-RC1</version>
-        </dependency>        
+            <version>1.7.7</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>1.7.7</version>
+        </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
         <!--
@@ -128,7 +136,7 @@
                 <!-- See http://code.google.com/p/maven-android-plugin/ -->
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.0</version>
+                <version>3.8.2</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
diff --git a/android/scripts/maven-install-mapsforge.sh b/android/scripts/maven-install-mapsforge.sh
index c396e286e0..f1fac1393c 100755
--- a/android/scripts/maven-install-mapsforge.sh
+++ b/android/scripts/maven-install-mapsforge.sh
@@ -9,12 +9,12 @@
 
 # MAVEN_HOME/bin/mvn
 MVN=mvn
-VERSION=0.4.0-SNAPSHOT
+VERSION=0.4.0
 libs="map map-android map-reader core"
 
 for lib in $libs; do
   FILE=$(ls ./libs/mapsforge-$lib-$VERSION.jar)
   echo "installing file: $FILE"
-  ARGS="-DgroupId=com.graphhopper -DartifactId=mapsforge-$lib -Dversion=0.3-0.4.0-SNAPSHOT -Dpackaging=jar -Dfile=$FILE"
+  ARGS="-DgroupId=com.graphhopper -DartifactId=mapsforge-$lib -Dversion=$VERSION -Dpackaging=jar -Dfile=$FILE"
   $MVN install:install-file $ARGS
 done
diff --git a/android/src/com/graphhopper/android/AndroidDownloader.java b/android/src/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..e5b8e83268
--- /dev/null
+++ b/android/src/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,69 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader
+{
+
+    public AndroidDownloader()
+    {
+        super("GraphHopper Android");
+    }
+
+    @Override
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
+            @Override
+            public void update( long sumBytes )
+            {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    @Override
+    public String downloadAsString( String url ) throws IOException
+    {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+
+    // There is something broken on Android with HTTPS and Android HttpURLConnection.
+    // Probably for 4.* only? See #251 for discussion and https://developer.android.com/training/articles/security-ssl.html
+    private HttpEntity getEntity( String url )
+    {        
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try
+        {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+}
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/src/com/graphhopper/android/MainActivity.java
index 6107002d22..2e038c38c9 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/src/com/graphhopper/android/MainActivity.java
@@ -50,9 +50,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
-import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
@@ -61,7 +60,7 @@
 public class MainActivity extends Activity
 {
     private MapView mapView;
-    private GraphHopperAPI hopper;
+    private GraphHopper hopper;
     private LatLong start;
     private LatLong end;
     private Spinner localSpinner;
@@ -71,7 +70,7 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "http://graphhopper.com/public/maps/0.3/";
+    private String fileListURL = "https://graphhopper.com/public/maps/0.4/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
@@ -166,6 +165,18 @@ protected void onCreate( Bundle savedInstanceState )
         chooseAreaFromLocal();
     }
 
+    @Override
+    protected void onDestroy()
+    {
+        super.onDestroy();
+        if (hopper != null)
+            hopper.close();
+
+        hopper = null;
+        // necessary?
+        System.gc();
+    }
+
     boolean isReady()
     {
         // only return true if already loaded
@@ -227,8 +238,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").
-                        downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -249,8 +259,9 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (hasError())
+                if (hasError() || nameList.isEmpty())
                 {
+                    getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
@@ -261,10 +272,8 @@ protected void onPostExecute( List<String> nameList )
                     public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder, selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder, selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -304,7 +313,7 @@ private void chooseArea( Button button, final Spinner spinner,
             public void onClick( View v )
             {
                 Object o = spinner.getSelectedItem();
-                if (o != null && o.toString().length() > 0)
+                if (o != null && o.toString().length() > 0 && !nameToFullName.isEmpty())
                 {
                     String area = o.toString();
                     mylistener.onSelect(area, nameToFullName.get(area));
@@ -345,7 +354,9 @@ protected Object saveDoInBackground( Void... _ignore )
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                new Downloader("GraphHopper Android").downloadAndUnzip(downloadURL, localFolder,
+                AndroidDownloader downloader = new AndroidDownloader();
+                downloader.setTimeout(30000);
+                downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
                         {
                             @Override
@@ -390,7 +401,7 @@ void loadMap( File areaFolder )
                 true, AndroidGraphicFactory.INSTANCE)
                 {
                     @Override
-                    public boolean onTap( LatLong tapLatLong, Point layerXY, Point tapXY )
+                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
                     {
                         return onMapTap(tapLatLong, layerXY, tapXY);
                     }
@@ -413,7 +424,6 @@ void loadGraphStorage()
             protected Path saveDoInBackground( Void... v ) throws Exception
             {
                 GraphHopper tmpHopp = new GraphHopper().forMobile();
-                tmpHopp.setCHShortcuts("fastest");
                 tmpHopp.load(new File(mapsFolder, currentArea).getAbsolutePath());
                 log("found graph " + tmpHopp.getGraph().toString() + ", nodes:" + tmpHopp.getGraph().getNodes());
                 hopper = tmpHopp;
@@ -428,7 +438,7 @@ protected void onPostExecute( Path o )
                             + getErrorMessage());
                 } else
                 {
-                    logUser("Finished loading graph. Touch to route.");
+                    logUser("Finished loading graph. Press long to define where to start and end the route.");
                 }
 
                 finishPrepare();
@@ -445,7 +455,7 @@ private Polyline createPolyline( GHResponse response )
     {
         Paint paintStroke = AndroidGraphicFactory.INSTANCE.createPaint();
         paintStroke.setStyle(Style.STROKE);
-        paintStroke.setColor(Color.BLUE);
+        paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
         {
             25, 15
@@ -470,7 +480,7 @@ private Marker createMarker( LatLong p, int resource )
     {
         Drawable drawable = getResources().getDrawable(resource);
         Bitmap bitmap = AndroidGraphicFactory.convertToBitmap(drawable);
-        return new Marker(p, bitmap, -bitmap.getHeight(), -bitmap.getWidth() / 2);
+        return new Marker(p, bitmap, 0, -bitmap.getHeight() / 2);
     }
 
     public void calcPath( final double fromLat, final double fromLon,
@@ -486,9 +496,9 @@ protected GHResponse doInBackground( Void... v )
             {
                 StopWatch sw = new StopWatch().start();
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
-                        setAlgorithm("dijkstrabi").
-                        putHint("instructions", false).
-                        putHint("douglas.minprecision", 1);
+                        setAlgorithm(AlgorithmOptions.DIJKSTRA_BI);
+                req.getHints().
+                        put("instructions", "false");
                 GHResponse resp = hopper.route(req);
                 time = sw.stop().getSeconds();
                 return resp;
diff --git a/config-example.properties b/config-example.properties
index 71a234905f..026338ae2c 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,31 +1,25 @@
 #################
 ### OSMReader ###
 
-# graph.dataaccess=MMAP_STORE_SYNC
 graph.dataaccess=RAM_STORE
+# graph.dataaccess=MMAP_STORE_SYNC
 
-# The high-resolution index is bigger and slightly slower but a lot more precise. see #17.
-# Resolution is in meter, decrease from 1000 to 500 in order to speed up queries (but will increase size)
-#index.highResolution=-1
-index.highResolution=500
-
-
-# use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# uncomment this if you need more control of you algorithm. then use graphhopper.chShortcuts(false, false)
-prepare.chShortcuts=fastest
-
-# advanced options:
-# prepare.updates.periodic=3
-# prepare.updates.lazy=10
-# prepare.updates.neighbor=20
-
+# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
+# Use chWeighting=no to disable it (more flexibility while querying) 
+# Java API usage is: GraphHopper.setCHWeighting("fastest")
+prepare.chWeighting=fastest
 
 # increase from 1 to 5, to reduce way geometry e.g. for android
 osmreader.wayPointMaxDistance=1
 
-# possible options: CAR,FOOT,BIKE,MTB,RACINGBIKE (comma separated)
-# when using two or three option together remeber to set "prepare.chShortcuts=no" above
-osmreader.acceptWay=CAR
+# Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
+# When using two or three option together remeber to set "prepare.chWeighting=no" above.
+# bike2 takes elevation data into account (like up-hill is slower than down-hill)
+# and requires enabling graph.elevation.provider below, e.g. see #169
+graph.flagEncoders=car
+
+# to enable turn restrictions for car do
+# graph.flagEncoders=car|turnCosts=true
 
 # if you want to reduce storage size and you don't need instructions for a path uncomment this
 # osmreader.instructions=false
@@ -34,10 +28,13 @@ osmreader.acceptWay=CAR
 # graph.elevation.provider=srtm
 # default location for cache is used /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
+# If you have a slow disk or plenty of RAM change the default MMAP to
+# graph.elevation.dataaccess=RAM_STORE
 
-### default algorithm can be overwritten via the URL parameter &algorithm=<algo>
-### if you use fast routing you have to use dijkstrabi (bidirectional dijkstra)
-#web.defaultAlgorithm=astarbi
-#web.defaultAlgorithm=astar
-routing.defaultAlgorithm=dijkstrabi
+# Location index lookup. Advanced customization. Resolution is in meter, the search specifies the 'radius' in number of tiles.
+# E.g. decrease resolution for a faster lookup and increase region search for a more dynamic search and less 'location not found' results
+# index.highResolution=300
+# index.maxRegionSearch=4
 
+# if you want to support jsonp response type you need to add it explicitely here:
+#web.jsonpAllowed=true
diff --git a/core/files/N50E011hgt.zip b/core/files/N50E011hgt.zip
new file mode 100644
index 0000000000..623adc98a9
Binary files /dev/null and b/core/files/N50E011hgt.zip differ
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 4841c5e7dc..d978edceea 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,44 @@
+0.4.0
+    GHResponse no longer has isFound method, use !hasErrors instead
+    merged unused Edge class into EdgeEntry
+    astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
+    making GPX export according to the schema to support import from various tools like basecamp
+    refactoring: AllEdgesIterator.getMaxId is now named getCount
+    major change of internal API: moved method "Path RoutingAlgorithm.calcPath(QueryResult,QueryResult)" to a helper method QueryGraph.lookup, call queryResult.getClosestNode for the calcPath(nodeFrom,nodeTo) method
+    no cachedWays and cachedPoints in Path anymore
+    Path.findInstruction was moved to InstructionList.find
+    if start and end point are identical an algorithm will find the path consisting only of one node, one point and one instruction (finish instruction), but without edges
+    astarbi has new default values for approximation (false) and approximation_factor (1.2) in RoutingAlgorithmFactorySimple
+    instead of strings use the variables in AlgorithmOptions to specify an algorithm
+    use RoutingAlgorithmFactorySimple instead of RoutingAlgorithmFactory, also more constistent algorithm preparation handling due to new AlgorithmOptions, therefor removed NoOpAlgorithmPreparation
+    GHResponse.getXX methods now fail fast (throw an exception) if an error while route calculation occured. See #287
+    renamed less often used URL parameter 'min_path_precision' to way_point_max_distance which makes it identical to the setWayPointMaxDistance method used for simplification at OSMImport
+    removed douglas.minprecision from Java API ghRequest.hints => use wayPointMaxDistance instead
+    encoder.supportTurnCost is replaced by encoder.supports(TurnWeighting.class)
+    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call
+    removed GHRequest.getHint, instead use the provided methods in GHRequest.getHints().getXY and GHRequest.getHints().put
+    graph incompatibility as properties cannot be loaded => version increase necessary
+        renamed osmreader.bytesForFlags to graph.bytesForFlags
+        renamed config property osmreader.acceptWay to graph.flagEncoders
+    default weighting is now fastest, fixing #261
+    moved method GraphHopper.main into tools module and class com.graphhopper.tools.Import, see #250
+    refactored GraphHopper.createWeighting to accept more than one configuration option, see #237
+    refactored GraphHopper.disableCHShortcuts to setCHEnable(boolean)
+    moving the boolean parameter of GraphHopper.setInMemory into a separate method setStoreOnFlush
+    renaming of GraphHopper.setCHShortcuts to setCHWeighting, as well as the property prepare.chShortcuts to prepare.chWeighting
+    jsonp is disabled by default. You need to enable it in the config.properties, see the config-example.properties
+    EncodingManager cannot be null in GraphHopperStorage since 0.4. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
+    no reflection done in EncodingManager which improves portability and makes configuration of encoders possible before adding to manager
+    removed dijkstraNativebi as no performance advantage but maintenance disadvantage and similar to oneToManyDijkstra
+    to provide context for turn costs we needed to add prevEdgeId into Weighting.calcWeight, see new documentation
+    with the introduction of lock protection mechanism (see #112) GraphHopper needs always write access, see also #217
+    new GraphHopper.clean method to remove the graph directory via Java API
+    FlagEncoder: replaced isFoward and isBackward with more generic isBool(flags, FlagEncoder.FORWARD|BACKWARD)
+
 0.3.0
+    introduced prefer bits, now bike uses more bits and 3 bike encoder do not fit into 32 bit anymore, will be fixed later
+    moved Translation argument into Path.calcInstruction for more fine grained control, instructions are now uncached and GHRequest: new locale parameter
+    CoordTrig and the like are removed, GHPlace is mostly replaced by GHPoint and so GHRequest has now methods ala addPoint instead
     removed isBoth from AbstractFlagEncoder, moved canBeOverwritten and associated test to PrepareEncoder
     removed unused directory.rename
     refactor edge.copyProperties into copyPropertiesTo to have similar semantics as Graph.copyTo
diff --git a/core/files/live_measurement.sh b/core/files/live_measurement.sh
index f37d9ab726..1fbafd5ae6 100755
--- a/core/files/live_measurement.sh
+++ b/core/files/live_measurement.sh
@@ -29,7 +29,7 @@ GH_MAIN=/media/SAMSUNG/maps/unterfranken
 # import graph
 OSM_XML=$GH_MAIN.osm
 GL=$GH_MAIN-gh
-ARGS="osmreader.graph-location=$GL osmreader.osm=$OSM_XML osmreader.chShortcuts=fastest osmreader.type=CAR"
+ARGS="osmreader.graph-location=$GL osmreader.osm=$OSM_XML osmreader.chWeighting=fastest osmreader.type=CAR"
 echo -e "\ncreate graph via $ARGS, $JAR"
 $JAVA $JAVA_OPTS -cp $JAR com.graphhopper.reader.OSMReader $ARGS osmreader.doPrepare=false
 
diff --git a/core/files/north-bayreuth.osm.gz b/core/files/north-bayreuth.osm.gz
new file mode 100644
index 0000000000..53404479bc
Binary files /dev/null and b/core/files/north-bayreuth.osm.gz differ
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
index 7ff63eb41d..fd46e3dd5a 100755
--- a/core/files/travis-build.sh
+++ b/core/files/travis-build.sh
@@ -4,7 +4,7 @@ cd $HOME/../..
 modules="core web tools"
 for module in $modules; do
   echo "====== INSTALL $module ====="
-  mvn -pl $module install -DskipTests=true
+  mvn -pl $module clean install -DskipTests=true
   EXIT_VAL="$?"    
   if [[ "x$EXIT_VAL" != "x0" ]]; then
     exit $EXIT_VAL
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index ab533af689..a735d96d27 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,11 +3,12 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP de_DE ro pt_PT pt_BR bg es ru ja fr si tr SKIP SKIP"
+translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk vi_VI zh_CN"
 file=$1
-#file=/tmp/gh.csv
-#rm $file
-#wget -O $file "https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&pli=1&output=csv"
+
+# You can execute the following
+# curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv
+# ./files/update-translations.sh tmp.tsv && rm tmp.tsv
 
 INDEX=1
 for tr in $translations; do
@@ -15,6 +16,6 @@ for tr in $translations; do
   if [[ "x$tr" = "xSKIP" ]]; then
     continue
   fi
-   
-  tail -n+6 "$file" | cut -d',' -s -f1,$INDEX --output-delimiter='=' > $destination/$tr.txt
+  echo -e '# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh\n' > $destination/$tr.txt
+  tail -n+5 "$file" | cut -s -f1,$INDEX --output-delimiter='=' >> $destination/$tr.txt
 done
diff --git a/core/nb-configuration.xml b/core/nb-configuration.xml
index 1286047075..c95ec72546 100644
--- a/core/nb-configuration.xml
+++ b/core/nb-configuration.xml
@@ -19,7 +19,6 @@
         That way multiple projects can share the same settings (useful for formatting rules for example).
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
-        <netbeans.hint.jdkPlatform>JDK_1.6</netbeans.hint.jdkPlatform>
         <org-netbeans-modules-whitelist.whitelist-oracle>false</org-netbeans-modules-whitelist.whitelist-oracle>
         <netbeans.compile.on.save>all</netbeans.compile.on.save>
     </properties>
diff --git a/core/nbactions.xml b/core/nbactions.xml
index 742874c4cc..79681aad55 100644
--- a/core/nbactions.xml
+++ b/core/nbactions.xml
@@ -18,7 +18,7 @@
         </goals>
         <properties>
             <exec.classpathScope>runtime</exec.classpathScope>
-            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/monaco.osm.gz</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <exec.executable>java</exec.executable>
         </properties>
     </action>
@@ -30,7 +30,7 @@
         </goals>
         <properties>
             <exec.classpathScope>runtime</exec.classpathScope>
-            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/monaco.osm.gz</exec.args>
+            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <jpda.listen>true</jpda.listen>
             <exec.executable>java</exec.executable>
         </properties>
@@ -42,7 +42,7 @@
             <goal>org.codehaus.mojo:exec-maven-plugin:1.1.1:exec</goal>
         </goals>
         <properties>
-            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/monaco.osm.gz</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <profiler.action>profile</profiler.action>
             <exec.executable>${profiler.java}</exec.executable>
         </properties>
diff --git a/core/pom.xml b/core/pom.xml
index e1dd80cb75..d578eb29bb 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper</artifactId>
     <name>GraphHopper</name>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.4-SNAPSHOT</version>
     <packaging>jar</packaging> 
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine 
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.4-SNAPSHOT</version>
     </parent>
         
     <properties>  
@@ -49,7 +49,7 @@
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
             <version>1.0.13</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
         </dependency>
         -->
         
@@ -57,25 +57,39 @@
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
             <version>${slf4j.version}</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
             <version>${log4j.version}</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
+        </dependency>
+        
+        <!-- for using CGIAR: elevation data importing via tif files-->
+        <dependency>
+            <groupId>org.apache.xmlgraphics</groupId>
+            <artifactId>xmlgraphics-commons</artifactId>
+            <version>1.5</version>
         </dependency>
         
         <dependency>
             <groupId>com.google.protobuf</groupId>
             <artifactId>protobuf-java</artifactId>
-            <version>2.5.0</version>
+            <version>2.6.0</version>
         </dependency>        
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <version>20140107</version>
+        </dependency>
+        
     </dependencies>
         
     <build>
@@ -84,28 +98,18 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.4</version>
-                    <configuration>
-                        <archive>
-                            <manifest>
-                                <mainClass>com.graphhopper.GraphHopper</mainClass>
-                            </manifest>
-                        </archive>
+                    <version>2.4.1</version>
+                    <configuration>                     
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
-	                    
-                        <!-- for standalone usage -->
-                        <descriptorRefs>
-                            <descriptorRef>jar-with-dependencies</descriptorRef>
-                        </descriptorRefs>
                     </configuration>
                 </plugin>
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-site-plugin</artifactId>
-                    <version>3.3</version>
+                    <version>3.4</version>
                     <configuration>
                         <reportPlugins>
                             <plugin>
diff --git a/core/src/main/assembly/android.xml b/core/src/main/assembly/android.xml
index 92561e7f09..b3bdba3373 100644
--- a/core/src/main/assembly/android.xml
+++ b/core/src/main/assembly/android.xml
@@ -11,11 +11,10 @@
             <unpack>true</unpack>
             <scope>runtime</scope>
             <excludes>
-                <exclude>org.slf4j:slf4j-api</exclude>
-                <exclude>org.slf4j:slf4j-log4j12</exclude>
-                <exclude>log4j:log4j</exclude>
+                <!-- <exclude>org.slf4j:slf4j-api</exclude>-->                
                 <exclude>com.google.protobuf:protobuf-java</exclude>
                 <exclude>org.openstreetmap.osmosis:osmosis-osm-binary</exclude>
+                <exclude>org.apache.xmlgraphics:xmlgraphics-commons</exclude>
             </excludes>
         </dependencySet>
     </dependencySets>
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index 2770c3513d..f68f7cf332 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -17,11 +17,12 @@
  */
 package com.graphhopper;
 
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
+import java.util.Locale;
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
@@ -31,15 +32,21 @@
  */
 public class GHRequest
 {
-    private String algo = "dijkstrabi";
-    private List<GHPlace> places = new ArrayList<GHPlace>(5);
-    private final Map<String, Object> hints = new HashMap<String, Object>(5);
-    private String vehicle = "CAR";
-    private String weighting = "fastest";
+    private String algo = "";
+    private List<GHPoint> points;
+    private final WeightingMap hints = new WeightingMap();
+    private String vehicle = "";
     private boolean possibleToAdd = false;
+    private Locale locale = Locale.US;
 
     public GHRequest()
     {
+        this(5);
+    }
+
+    public GHRequest( int size )
+    {
+        points = new ArrayList<GHPoint>(size);
         possibleToAdd = true;
     }
 
@@ -48,52 +55,53 @@ public GHRequest()
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
     {
-        this(new GHPlace(fromLat, fromLon), new GHPlace(toLat, toLon));
+        this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
     /**
      * Calculate the path from specified startPlace to endPlace.
      */
-    public GHRequest( GHPlace startPlace, GHPlace endPlace )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace )
     {
         if (startPlace == null)
             throw new IllegalStateException("'from' cannot be null");
 
         if (endPlace == null)
             throw new IllegalStateException("'to' cannot be null");
-        places.add(startPlace);
-        places.add(endPlace);
+        points = new ArrayList<GHPoint>(2);
+        points.add(startPlace);
+        points.add(endPlace);
     }
 
-    public GHRequest( List<GHPlace> places )
+    public GHRequest( List<GHPoint> points )
     {
-        this.places = places;
+        this.points = points;
     }
 
-    public GHRequest addPlace( GHPlace place )
+    public GHRequest addPoint( GHPoint point )
     {
-        if (place == null)
-            throw new IllegalArgumentException("place cannot be null");
+        if (point == null)
+            throw new IllegalArgumentException("point cannot be null");
         if (!possibleToAdd)
             throw new IllegalStateException("Please call empty constructor if you intent to use "
                     + "more than two places via addPlace method.");
 
-        places.add(place);
+        points.add(point);
         return this;
     }
 
-    public List<GHPlace> getPlaces()
+    public List<GHPoint> getPoints()
     {
-        return places;
+        return points;
     }
 
     /**
-     * Possible values: astar (A* algorithm, default), astarbi (bidirectional A*) dijkstra
-     * (Dijkstra), dijkstrabi and dijkstraNativebi (a bit faster bidirectional Dijkstra).
+     * For possible values see AlgorithmOptions.*
      */
     public GHRequest setAlgorithm( String algo )
     {
-        this.algo = algo;
+        if (algo != null)
+            this.algo = algo;
         return this;
     }
 
@@ -102,65 +110,44 @@ public String getAlgorithm()
         return algo;
     }
 
-    public GHRequest putHint( String key, Object value )
+    public Locale getLocale()
     {
-        Object old = hints.put(key, value);
-        if (old != null)
-            throw new RuntimeException("Key is already associated with " + old + ", your value:" + value);
-
-        return this;
+        return locale;
     }
 
-    @SuppressWarnings("unchecked")
-    public <T> T getHint( String key, T defaultValue )
+    public GHRequest setLocale( Locale locale )
     {
-        Object obj = hints.get(key);
-        if (obj == null)
-            return defaultValue;
-
-        if (defaultValue != null && defaultValue instanceof Number)
-        {
-            // what a monster! see #173
-            if (defaultValue instanceof Double)
-                return (T) (Double) ((Number) obj).doubleValue();
-            if (defaultValue instanceof Long)
-                return (T) (Long) ((Number) obj).longValue();
-        }
-
-        return (T) obj;
+        if (locale != null)
+            this.locale = locale;
+        return this;
     }
 
-    @Override
-    public String toString()
+    public GHRequest setLocale( String localeStr )
     {
-        String res = "";
-        for (GHPlace place : places)
-        {
-            if (res.isEmpty())
-                res = place.toString();
-            else
-                res += "; " + place.toString();
-        }
-        return res + "(" + algo + ")";
+        return setLocale(Helper.getLocale(localeStr));
     }
 
     /**
-     * By default it supports fastest and shortest
+     * By default it supports fastest and shortest. Or specify empty to use default.
      */
     public GHRequest setWeighting( String w )
     {
-        this.weighting = w;
+        hints.setWeighting(w);
         return this;
     }
 
     public String getWeighting()
     {
-        return weighting;
+        return hints.getWeighting();
     }
 
+    /**
+     * Specifiy car, bike or foot. Or specify empty to use default.
+     */
     public GHRequest setVehicle( String vehicle )
     {
-        this.vehicle = vehicle;
+        if (vehicle != null)
+            this.vehicle = vehicle;
         return this;
     }
 
@@ -168,4 +155,23 @@ public String getVehicle()
     {
         return vehicle;
     }
+
+    @Override
+    public String toString()
+    {
+        String res = "";
+        for (GHPoint point : points)
+        {
+            if (res.isEmpty())
+                res = point.toString();
+            else
+                res += "; " + point.toString();
+        }
+        return res + "(" + algo + ")";
+    }
+
+    public WeightingMap getHints()
+    {
+        return hints;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index f45cab8e7f..91fd524044 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -20,7 +20,6 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -31,18 +30,60 @@
  */
 public class GHResponse
 {
+    private String debugInfo = "";
+    private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private PointList list = PointList.EMPTY;
     private double distance;
+    private double routeWeight;
     private long time;
-    private String debugInfo = "";
-    private final List<Throwable> errors = new ArrayList<Throwable>(4);
-    private InstructionList instructions = new InstructionList(0);
-    private boolean found;
+    private InstructionList instructions = null;
 
     public GHResponse()
     {
     }
 
+    public String getDebugInfo()
+    {
+        check("getDebugInfo");
+        return debugInfo;
+    }
+
+    public GHResponse setDebugInfo( String debugInfo )
+    {
+        if (debugInfo != null)
+            this.debugInfo = debugInfo;
+        return this;
+    }
+
+    private void check( String method )
+    {
+        if (hasErrors())
+        {
+            throw new RuntimeException("You cannot call " + method + " if response contains errors. Check this with ghResponse.hasErrors(). "
+                    + "Errors are: " + getErrors());
+        }
+    }
+
+    /**
+     * @return true if one or more error found
+     */
+    public boolean hasErrors()
+    {
+        return !errors.isEmpty();
+    }
+
+    public List<Throwable> getErrors()
+    {
+        return errors;
+    }
+
+    @SuppressWarnings("unchecked")
+    public GHResponse addError( Throwable error )
+    {
+        errors.add(error);
+        return this;
+    }
+
     public GHResponse setPoints( PointList points )
     {
         list = points;
@@ -56,6 +97,7 @@ public GHResponse setPoints( PointList points )
      */
     public PointList getPoints()
     {
+        check("getPoints");
         return list;
     }
 
@@ -73,6 +115,7 @@ public GHResponse setDistance( double distance )
      */
     public double getDistance()
     {
+        check("getDistance");
         return distance;
     }
 
@@ -90,15 +133,21 @@ public long getMillis()
         return time;
     }
 
-    public GHResponse setFound( boolean found )
+    public GHResponse setRouteWeight( double weight )
     {
-        this.found = found;
+        this.routeWeight = weight;
         return this;
     }
 
-    public boolean isFound()
+    /**
+     * This method returns a double value which is better than the time for comparison of routes but
+     * only if you know what you are doing, e.g. only to compare routes gained with the same query
+     * parameters like vehicle.
+     */
+    public double getRouteWeight()
     {
-        return found;
+        check("getRouteWeight");
+        return routeWeight;
     }
 
     /**
@@ -106,6 +155,7 @@ public boolean isFound()
      */
     public BBox calcRouteBBox( BBox _fallback )
     {
+        check("calcRouteBBox");
         BBox bounds = BBox.INVERSE.clone();
         int len = list.getSize();
         if (len == 0)
@@ -130,44 +180,14 @@ public BBox calcRouteBBox( BBox _fallback )
         return bounds;
     }
 
-    public String getDebugInfo()
-    {
-        return debugInfo;
-    }
-
-    public GHResponse setDebugInfo( String debugInfo )
-    {
-        this.debugInfo = debugInfo;
-        return this;
-    }
-
-    /**
-     * @return true if one or more error found
-     */
-    public boolean hasErrors()
-    {
-        return !errors.isEmpty();
-    }
-
-    public List<Throwable> getErrors()
-    {
-        return errors;
-    }
-
-    public GHResponse addError( Throwable error )
-    {
-        errors.add(error);
-        return this;
-    }
-
     @Override
     public String toString()
     {
-        String str = "found:" + isFound() + ", nodes:" + list.getSize() + ": " + list.toString();
+        String str = "nodes:" + list.getSize() + ": " + list.toString();
         if (!instructions.isEmpty())
             str += ", " + instructions.toString();
 
-        if (!errors.isEmpty())
+        if (hasErrors())
             str += ", " + errors.toString();
 
         return str;
@@ -180,6 +200,10 @@ public void setInstructions( InstructionList instructions )
 
     public InstructionList getInstructions()
     {
+        check("getInstructions");
+        if (instructions == null)
+            throw new IllegalArgumentException("To access instructions you need to enable creation before routing");
+
         return instructions;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index db69496d43..1d0e4298c2 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -19,23 +19,22 @@
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.OSMReader;
+import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.*;
 import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.shapes.GHPoint;
 
 import java.io.File;
 import java.io.IOException;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -48,61 +47,59 @@
  */
 public class GraphHopper implements GraphHopperAPI
 {
-    public static void main( String[] strs ) throws Exception
-    {
-        CmdArgs args = CmdArgs.read(strs);
-        GraphHopper hopper = new GraphHopper().init(args);
-        hopper.importOrLoad();
-        RoutingAlgorithmSpecialAreaTests tests = new RoutingAlgorithmSpecialAreaTests(hopper);
-        if (args.getBool("graph.testIT", false))
-            tests.start();
-    }
-
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphStorage graph;
+    private EncodingManager encodingManager;
+    private int defaultSegmentSize = -1;
     private String ghLocation = "";
     private DAType dataAccessType = DAType.RAM_STORE;
     private boolean sortGraph = false;
     boolean removeZipped = true;
-    private int dimension = 2;
+    private boolean elevation = false;
+    private LockFactory lockFactory = new NativeFSLockFactory();
+    private final String fileLockName = "gh.lock";
+    private boolean allowWrites = true;
+    boolean enableInstructions = true;
+    private boolean fullyLoaded = false;
     // for routing
-    private boolean simplifyRequest = true;
+    private double defaultWeightLimit = Double.MAX_VALUE;
+    private boolean simplifyResponse = true;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
-    private int preciseIndexResolution = 500;
-    private boolean searchRegion = true;
+    private int preciseIndexResolution = 300;
+    private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    // for CH prepare
-    private AlgorithmPreparation prepare;
+    private int minOneWayNetworkSize = 0;
+    // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
     private String chWeighting = "fastest";
-    private int periodicUpdates = 20;
-    private int lazyUpdates = 10;
-    private int neighborUpdates = 20;
-    private double logMessages = 20;
+    private int periodicUpdates = -1;
+    private int lazyUpdates = -1;
+    private int neighborUpdates = -1;
+    private double logMessages = -1;
     // for OSM import
     private String osmFile;
-    private EncodingManager encodingManager;
-    private double wayPointMaxDistance = 1;
+    private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
-    private int defaultSegmentSize = -1;
-    private boolean turnCosts = false;
-    private boolean enableInstructions = true;
     private boolean calcPoints = true;
-    private boolean fullyLoaded = false;
+    // utils    
+    private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
+    private final AtomicLong visitedSum = new AtomicLong(0);
 
     public GraphHopper()
     {
     }
 
     /**
-     * For testing
+     * For testing only
      */
-    GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph( GraphStorage g )
     {
         this.graph = g;
         fullyLoaded = true;
@@ -114,10 +111,13 @@ GraphHopper loadGraph( GraphStorage g )
      * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
      * how data from every vehicle is written (und read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager( EncodingManager acceptWay )
+    public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
-        this.encodingManager = acceptWay;
+        this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
@@ -129,9 +129,9 @@ public EncodingManager getEncodingManager()
     public GraphHopper setElevationProvider( ElevationProvider eleProvider )
     {
         if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
-            set3D(false);
+            setElevation(false);
         else
-            set3D(true);
+            setElevation(true);
         this.eleProvider = eleProvider;
         return this;
     }
@@ -149,45 +149,60 @@ protected int getWorkerThreads()
      */
     protected double getWayPointMaxDistance()
     {
-        return wayPointMaxDistance;
+        return osmReaderWayPointMaxDistance;
     }
 
+    /**
+     * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+     * value means more details, unit is meter. Default is 1. Disable via 0.
+     */
     public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
     {
-        this.wayPointMaxDistance = wayPointMaxDistance;
+        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+        return this;
+    }
+
+    /**
+     * Sets the default traversal mode used for the algorithms and preparation.
+     */
+    public GraphHopper setTraversalMode( TraversalMode traversalMode )
+    {
+        this.traversalMode = traversalMode;
         return this;
     }
 
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
     /**
-     * Configures the underlying storage to be used on a well equipped server.
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
-        setSimplifyRequest(true);
-        setPreciseIndexResolution(500);
-        return setInMemory(true);
+        setSimplifyResponse(true);
+        return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer with enough RAM but no
-     * network latency.
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
      */
     public GraphHopper forDesktop()
     {
-        setSimplifyRequest(false);
-        setPreciseIndexResolution(500);
-        return setInMemory(true);
+        setSimplifyResponse(false);
+        return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine like Android and
-     * Raspberry Pi with only few RAM.
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
      */
     public GraphHopper forMobile()
     {
-        setSimplifyRequest(false);
-        setPreciseIndexResolution(500);
+        setSimplifyResponse(false);
         return setMemoryMapped();
     }
 
@@ -203,21 +218,36 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
+    /**
+     * This method call results in an in-memory graph.
+     */
+    public GraphHopper setInMemory()
+    {
+        ensureNotLoaded();
+        dataAccessType = DAType.RAM_STORE;
+        return this;
+    }
+
     /**
-     * This method call results in an in-memory graph. Specify storeOnFlush to true if you want that
-     * existing data will be loaded FROM disc and all in-memory data will be flushed TO disc after
-     * flush is called e.g. while OSM import.
+     * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
+     * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+     * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
      * <p>
      * @param storeOnFlush true by default
      */
-    public GraphHopper setInMemory( boolean storeOnFlush )
+    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
     {
         ensureNotLoaded();
         if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
         else
             dataAccessType = DAType.RAM;
-
         return this;
     }
 
@@ -254,12 +284,11 @@ public GraphHopper setDoPrepare( boolean doPrepare )
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
-     * @see #disableCHShortcuts()
+     * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHShortcuts( String weighting )
+    public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chEnabled = true;
         chWeighting = weighting;
         return this;
     }
@@ -270,55 +299,49 @@ public String getCHWeighting()
     }
 
     /**
-     * Disables contraction hierarchies. Enabled by default.
+     * Enables or disables contraction hierarchies. Enabled by default. Disabling CH is only
+     * recommended for a small area or in combination with setDefaultWeightLimit
+     * <p>
+     * @see #setDefaultWeightLimit(double)
      */
-    public GraphHopper disableCHShortcuts()
+    public GraphHopper setCHEnable( boolean enable )
     {
         ensureNotLoaded();
-        chEnabled = false;
+        algoFactory = null;
+        chEnabled = enable;
         return this;
     }
 
-    public boolean isCHEnabled()
-    {
-        return chEnabled;
-    }
-
     /**
-     * @return true if storing and fetching elevation data is enabled. Default is false
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
      */
-    public boolean is3D()
+    public void setDefaultWeightLimit( double defaultWeightLimit )
     {
-        return dimension == 3;
+        this.defaultWeightLimit = defaultWeightLimit;
     }
 
-    /**
-     * Enable storing and fetching elevation data. Default is false
-     */
-    public GraphHopper set3D( boolean is3D )
+    public boolean isCHEnabled()
     {
-        if (is3D)
-            this.dimension = 3;
-        else
-            this.dimension = 2;
-        return this;
+        return chEnabled;
     }
 
     /**
-     * @return if import of turn restrictions is enabled
+     * @return true if storing and fetching elevation data is enabled. Default is false
      */
-    public boolean isEnableTurnRestrictions()
+    public boolean hasElevation()
     {
-        return turnCosts;
+        return elevation;
     }
 
     /**
-     * This method specifies if the import should include turn restrictions if available
+     * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setEnableTurnRestrictions( boolean b )
+    public GraphHopper setElevation( boolean includeElevation )
     {
-        ensureNotLoaded();
-        turnCosts = b;
+        this.elevation = includeElevation;
         return this;
     }
 
@@ -346,9 +369,9 @@ public GraphHopper setEnableCalcPoints( boolean b )
      * This method specifies if the returned path should be simplified or not, via douglas-peucker
      * or similar algorithm.
      */
-    private GraphHopper setSimplifyRequest( boolean doSimplify )
+    private GraphHopper setSimplifyResponse( boolean doSimplify )
     {
-        this.simplifyRequest = doSimplify;
+        this.simplifyResponse = doSimplify;
         return this;
     }
 
@@ -407,6 +430,11 @@ public void setGraph( GraphStorage graph )
         this.graph = graph;
     }
 
+    protected void setLocationIndex( LocationIndex locationIndex )
+    {
+        this.locationIndex = locationIndex;
+    }
+
     /**
      * The location index created from the graph.
      * <p>
@@ -420,11 +448,6 @@ public LocationIndex getLocationIndex()
         return locationIndex;
     }
 
-    public AlgorithmPreparation getPreparation()
-    {
-        return prepare;
-    }
-
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
@@ -435,18 +458,24 @@ public GraphHopper setSortGraph( boolean sortGraph )
         return this;
     }
 
-    /*
-     * Command line configuration overwrites the ones in the config file
+    /**
+     * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+     * possible to create a lock file and so we can avoid write locks.
      */
-    protected CmdArgs mergeArgsFromConfig( CmdArgs args ) throws IOException
+    public GraphHopper setAllowWrites( boolean allowWrites )
     {
-        if (!Helper.isEmpty(args.get("config", "")))
-        {
-            CmdArgs tmp = CmdArgs.readFromConfig(args.get("config", ""), "graphhopper.config");
-            tmp.merge(args);
-            return tmp;
-        }
-        return args;
+        this.allowWrites = allowWrites;
+        return this;
+    }
+
+    public boolean isAllowWrites()
+    {
+        return allowWrites;
+    }
+
+    public TranslationMap getTranslationMap()
+    {
+        return trMap;
     }
 
     /**
@@ -454,9 +483,9 @@ protected CmdArgs mergeArgsFromConfig( CmdArgs args ) throws IOException
      * args) ala CmdArgs.read(args) or via configuration file ala
      * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
      */
-    public GraphHopper init( CmdArgs args ) throws IOException
+    public GraphHopper init( CmdArgs args )
     {
-        args = mergeArgsFromConfig(args);
+        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
         String tmpOsmFile = args.get("osmreader.osm", "");
         if (!Helper.isEmpty(tmpOsmFile))
             osmFile = tmpOsmFile;
@@ -473,24 +502,52 @@ public GraphHopper init( CmdArgs args ) throws IOException
         // graph
         setGraphHopperLocation(graphHopperFolder);
         defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
-        dimension = args.getInt("graph.dimension", dimension);
 
         String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
         dataAccessType = DAType.fromString(graphDATypeStr);
 
         sortGraph = args.getBool("graph.doSort", sortGraph);
         removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        turnCosts = args.getBool("graph.turnCosts", turnCosts);
+        int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
+        if (args.get("graph.locktype", "native").equals("simple"))
+            lockFactory = new SimpleFSLockFactory();
+        else
+            lockFactory = new NativeFSLockFactory();
+
+        // elevation
+        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+        String cacheDirStr = args.get("graph.elevation.cachedir", "");
+        String baseURL = args.get("graph.elevation.baseurl", "");
+        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+        ElevationProvider tmpProvider = ElevationProvider.NOOP;
+        if (eleProviderStr.equalsIgnoreCase("srtm"))
+        {
+            tmpProvider = new SRTMProvider();
+        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+        {
+            CGIARProvider cgiarProvider = new CGIARProvider();
+            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
+            tmpProvider = cgiarProvider;
+        }
+
+        tmpProvider.setCalcMean(eleCalcMean);
+        tmpProvider.setCacheDir(new File(cacheDirStr));
+        if (!baseURL.isEmpty())
+            tmpProvider.setBaseURL(baseURL);
+        tmpProvider.setDAType(elevationDAType);
+        setElevationProvider(tmpProvider);
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String chShortcuts = args.get("prepare.chShortcuts", "fastest");
-        chEnabled = "true".equals(chShortcuts) || "fastest".equals(chShortcuts) || "shortest".equals(chShortcuts);
+        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
         if (chEnabled)
-            setCHShortcuts(chShortcuts);
+            setCHWeighting(tmpCHWeighting);
 
         periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
         lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
@@ -498,39 +555,27 @@ public GraphHopper init( CmdArgs args ) throws IOException
         logMessages = args.getDouble("prepare.logmessages", logMessages);
 
         // osm import
-        wayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", wayPointMaxDistance);
-        String flagEncoders = args.get("osmreader.acceptWay", "CAR");
-        int bytesForFlags = args.getInt("osmreader.bytesForFlags", 4);
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+        String flagEncoders = args.get("graph.flagEncoders", "CAR");
+
+        setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
-        // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
-        String baseURL = args.get("graph.elevation.baseurl", "");
-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm"))
-            tmpProvider = new SRTMProvider();
-        // later:
-//        else if(eleProviderStr.startsWith("cgiar:"))        
-//            eleProvider = new CGIARProvider().setCacheDir(new File());        
-
-        tmpProvider.setCacheDir(new File(cacheDirStr));
-        tmpProvider.setBaseURL(baseURL);
-        tmpProvider.setInMemory(elevationDAType.isInMemory());
-        setElevationProvider(tmpProvider);
-
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
     private void printInfo()
     {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+        if (graph != null)
+            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
     /**
@@ -557,23 +602,40 @@ public GraphHopper importOrLoad()
     private GraphHopper process( String graphHopperLocation )
     {
         setGraphHopperLocation(graphHopperLocation);
+        Lock lock = null;
         try
         {
-            importData();
-            graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-        } catch (IOException ex)
+            if (graph.getDirectory().getDefaultType().isStoring())
+            {
+                lockFactory.setLockDir(new File(graphHopperLocation));
+                lock = lockFactory.create(fileLockName, true);
+                if (!lock.tryLock())
+                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
+            }
+
+            try
+            {
+                importData();
+                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+            } catch (IOException ex)
+            {
+                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+            }
+            cleanUp();
+            optimize();
+            postProcessing();
+            flush();
+        } finally
         {
-            throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+            if (lock != null)
+                lock.release();
         }
-        cleanUp();
-        optimize();
-        postProcessing();
-        flush();
         return this;
     }
 
     protected DataReader importData() throws IOException
     {
+        ensureWriteAccess();
         if (graph == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
@@ -581,9 +643,6 @@ protected DataReader importData() throws IOException
             throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
                     + " but also cannot import from OSM file as it wasn't specified!");
 
-        if (encodingManager == null)
-            throw new IllegalStateException("Missing encoding manager");
-
         encodingManager.setEnableInstructions(enableInstructions);
         DataReader reader = createReader(graph);
         logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
@@ -607,7 +666,7 @@ protected OSMReader initOSMReader( OSMReader reader )
                 setElevationProvider(eleProvider).
                 setWorkerThreads(workerThreads).
                 setEncodingManager(encodingManager).
-                setWayPointMaxDistance(wayPointMaxDistance);
+                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
     }
 
     /**
@@ -631,7 +690,7 @@ public boolean load( String graphHopperFolder )
         } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
         {
             throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (graphHopperFolder.indexOf(".") < 0)
+        } else if (!graphHopperFolder.contains("."))
         {
             if (new File(graphHopperFolder + "-gh").exists())
                 graphHopperFolder += "-gh";
@@ -650,24 +709,62 @@ public boolean load( String graphHopperFolder )
                 }
             }
         }
+
         setGraphHopperLocation(graphHopperFolder);
 
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+        if (encodingManager == null)
+            encodingManager = EncodingManager.create(ghLocation);
 
+        if (!allowWrites && dataAccessType.isMMap())
+            dataAccessType = DAType.MMAP_RO;
+
+        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, is3D());
-        else if (turnCosts)
-            graph = new GraphHopperStorage(dir, encodingManager, is3D(), new TurnCostStorage());
+            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+        else if (encodingManager.needsTurnCostsSupport())
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
         else
-            graph = new GraphHopperStorage(dir, encodingManager, is3D());
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
         graph.setSegmentSize(defaultSegmentSize);
-        if (!graph.loadExisting())
-            return false;
 
-        postProcessing();
-        fullyLoaded = true;
-        return true;
+        Lock lock = null;
+        try
+        {
+            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
+            // (e.g. on a read only filesystem locks would fail)
+            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+            {
+                lockFactory.setLockDir(new File(ghLocation));
+                lock = lockFactory.create(fileLockName, false);
+                if (!lock.tryLock())
+                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
+            }
+
+            if (!graph.loadExisting())
+                return false;
+
+            postProcessing();
+            fullyLoaded = true;
+            return true;
+        } finally
+        {
+            if (lock != null)
+                lock.release();
+        }
+    }
+
+    public RoutingAlgorithmFactory getAlgorithmFactory()
+    {
+        if (algoFactory == null)
+            this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+        return algoFactory;
+    }
+
+    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+    {
+        this.algoFactory = algoFactory;
     }
 
     /**
@@ -677,7 +774,9 @@ protected void postProcessing()
     {
         encodingManager = graph.getEncodingManager();
         if (chEnabled)
-            initCHPrepare();
+            algoFactory = createPrepare();
+        else
+            algoFactory = new RoutingAlgorithmFactorySimple();
 
         if (!isPrepared())
             prepare();
@@ -689,154 +788,202 @@ private boolean isPrepared()
         return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
-    protected void initCHPrepare()
+    protected RoutingAlgorithmFactory createPrepare()
     {
         FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(chWeighting, encoder));
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, encoder,
+                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
                 setLogMessages(logMessages);
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+        return tmpPrepareCH;
+    }
+
+    /**
+     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
+     * created. Note that all URL parameters are available in the weightingParameters as String if
+     * you use the GraphHopper Web module.
+     * <p>
+     * @see Weighting.Params.create
+     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
+     * GHRequest
+     * @param encoder the required vehicle
+     * @return the weighting to be used for route calculation
+     */
+    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    {
+        String weighting = wMap.getWeighting();
+        Weighting result;
+
+        if ("shortest".equalsIgnoreCase(weighting))
+        {
+            result = new ShortestWeighting();
+        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+        {
+            if (encoder.supports(PriorityWeighting.class))
+                result = new PriorityWeighting(encoder);
+            else
+                result = new FastestWeighting(encoder);
+        } else
+        {
+            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+        }
+        return result;
     }
 
-    protected Weighting createWeighting( String weighting, FlagEncoder encoder )
+    /**
+     * Potentially wraps the specified weighting into a TurnWeighting instance.
+     */
+    public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
     {
-        // ignore case
-        weighting = weighting.toLowerCase();
-        if ("shortest".equals(weighting))
-            return new ShortestWeighting();
-        return new FastestWeighting(encoder);
+        if (encoder.supports(TurnWeighting.class))
+            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+        return weighting;
     }
 
     @Override
     public GHResponse route( GHRequest request )
+    {
+        GHResponse response = new GHResponse();
+        List<Path> paths = getPaths(request, response);
+        if (response.hasErrors())
+            return response;
+
+        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
+        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+        Locale locale = request.getLocale();
+        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+
+        new PathMerger().
+                setCalcPoints(tmpCalcPoints).
+                setDouglasPeucker(peucker).
+                setEnableInstructions(tmpEnableInstructions).
+                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
+                doWork(response, paths, trMap.getWithFallBack(locale));
+        return response;
+    }
+
+    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
     {
         if (graph == null || !fullyLoaded)
             throw new IllegalStateException("Call load or importOrLoad before routing");
 
-        GHResponse rsp = new GHResponse();
-        if (!encodingManager.supports(request.getVehicle()))
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+
+        String vehicle = request.getVehicle();
+        if (vehicle.isEmpty())
+            vehicle = encodingManager.getSingle().toString();
+
+        if (!encodingManager.supports(vehicle))
         {
-            rsp.addError(new IllegalArgumentException("Vehicle " + request.getVehicle() + " unsupported. Supported are: "
-                    + getEncodingManager()));
-            return rsp;
+            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+                    + "Supported are: " + getEncodingManager()));
+            return Collections.emptyList();
         }
 
-        List<GHPlace> places = request.getPlaces();
-        if (places.size() < 2)
+        TraversalMode tMode;
+        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+        try
+        {
+            tMode = TraversalMode.fromString(tModeStr);
+        } catch (Exception ex)
+        {
+            rsp.addError(ex);
+            return Collections.emptyList();
+        }
+
+        List<GHPoint> points = request.getPoints();
+        if (points.size() < 2)
         {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + places.size()));
-            return rsp;
+            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
+            return Collections.emptyList();
         }
 
-        FlagEncoder encoder = encodingManager.getEncoder(request.getVehicle());
+        visitedSum.set(0);
+
+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        GHPlace startPlace = request.getPlaces().get(0);
+
         StopWatch sw = new StopWatch().start();
-        QueryResult fromRes = locationIndex.findClosest(startPlace.lat, startPlace.lon, edgeFilter);
-        sw.stop();
-        if (!fromRes.isValid())
-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPlace));
-
-        List<Path> paths = new ArrayList<Path>(places.size() - 1);
-        String debug = "";
-        for (int placeIndex = 1; placeIndex < request.getPlaces().size(); placeIndex++)
+        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
         {
-            GHPlace place = request.getPlaces().get(placeIndex);
-            sw.start();
-            QueryResult toRes = locationIndex.findClosest(place.lat, place.lon, edgeFilter);
-            debug += "[" + placeIndex + "]";
-            debug += ", idLookup:" + sw.stop().getSeconds() + "s";
-            if (!toRes.isValid())
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + place));
+            GHPoint point = points.get(placeIndex);
+            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!res.isValid())
+                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
 
-            if (rsp.hasErrors())
-                return rsp;
+            qResults.add(res);
+        }
 
-            sw = new StopWatch().start();
-            RoutingAlgorithm algo = null;
-            if (chEnabled)
-            {
-                if (prepare == null)
-                    throw new IllegalStateException("Preparation object is null. CH-preparation wasn't done or did you "
-                            + "forgot to call disableCHShortcuts()?");
-
-                if (request.getAlgorithm().equals("dijkstrabi"))
-                    algo = prepare.createAlgo();
-                else if (request.getAlgorithm().equals("astarbi"))
-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
-                else
-                {
-                    rsp.addError(new IllegalStateException(
-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-                    return rsp;
-                }
-            } else
-            {
-                Weighting weighting = createWeighting(request.getWeighting(), encoder);
-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, request.getAlgorithm(), encoder, weighting);
-                algo = prepare.createAlgo();
-            }
+        if (rsp.hasErrors())
+            return Collections.emptyList();
 
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(qResults);
+
+        List<Path> paths = new ArrayList<Path>(points.size() - 1);
+        QueryResult fromQResult = qResults.get(0);
+        Weighting weighting = createWeighting(request.getHints(), encoder);
+        weighting = createTurnWeighting(weighting, queryGraph, encoder);
+
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
+        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
+
+        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+        {
+            QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
+            RoutingAlgorithm algo = getAlgorithmFactory().createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
+            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
-            Path path = algo.calcPath(fromRes, toRes);
+            sw = new StopWatch().start();
+            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
             if (path.getMillis() < 0)
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
-                
+
             paths.add(path);
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
-            fromRes = toRes;
+
+            visitedSum.addAndGet(algo.getVisitedNodes());
+            fromQResult = toQResult;
         }
 
-        enableInstructions = request.getHint("instructions", enableInstructions);
-        calcPoints = request.getHint("calcPoints", calcPoints);
-        simplifyRequest = request.getHint("simplifyRequest", simplifyRequest);
-        double minPathPrecision = request.getHint("douglas.minprecision", 1d);
-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(minPathPrecision);
-        rsp.setDebugInfo(debug);
+        if (rsp.hasErrors())
+            return Collections.emptyList();
 
-        if (places.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + places.size() + ", paths:" + paths.size());
+        if (points.size() - 1 != paths.size())
+            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
-        new PathMerger().
-                setCalcPoints(calcPoints).
-                setDouglasPeucker(peucker).
-                setEnableInstructions(enableInstructions).
-                setSimplifyRequest(simplifyRequest && minPathPrecision > 0).
-                doWork(rsp, paths);
-        return rsp;
+        rsp.setDebugInfo(debug);
+        return paths;
     }
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
         LocationIndex tmpIndex;
-        if (preciseIndexResolution > 0)
+        if (graph instanceof LevelGraph)
         {
-            LocationIndexTree tmpNIndex;
-            if (graph instanceof LevelGraph)
-            {
-                tmpNIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-            } else
-            {
-                tmpNIndex = new LocationIndexTree(graph, dir);
-            }
-            tmpNIndex.setResolution(preciseIndexResolution);
-            tmpNIndex.setSearchRegion(searchRegion);
-            tmpIndex = tmpNIndex;
+            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
         } else
         {
-            tmpIndex = new Location2IDQuadtree(graph, dir);
-            tmpIndex.setResolution(Helper.calcIndexSize(graph.getBounds()));
+            tmpIndex = new LocationIndexTree(graph, dir);
         }
+        tmpIndex.setResolution(preciseIndexResolution);
+        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
 
         if (!tmpIndex.loadExisting())
+        {
+            ensureWriteAccess();
             tmpIndex.prepareIndex();
+        }
 
         return tmpIndex;
     }
@@ -845,6 +992,7 @@ protected LocationIndex createLocationIndex( Directory dir )
      * Initializes the location index. Currently this has to be done after the ch-preparation!
      * Because - to improve performance - certain edges won't be available in a ch-graph and the
      * index needs to know this and selects the correct nodes which still see the correct neighbors.
+     * See #116
      */
     protected void initLocationIndex()
     {
@@ -861,30 +1009,31 @@ protected void optimize()
         logger.info("finished optimize (" + Helper.getMemInfo() + ")");
 
         // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet https://github.com/graphhopper/graphhopper/issues/12
+        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
         if (sortGraph)
         {
             if (graph instanceof LevelGraph && isPrepared())
                 throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
 
-            logger.info("sorting ... (" + Helper.getMemInfo() + ")");
             GraphStorage newGraph = GHUtility.newStorage(graph);
             GHUtility.sortDFS(graph, newGraph);
+            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
             graph = newGraph;
         }
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && prepare != null;
+        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
         if (tmpPrepare)
         {
-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
+            ensureWriteAccess();
+            if (encodingManager.getVehicleCount() > 1)
                 throw new IllegalArgumentException("Contraction hierarchies preparation "
                         + "requires (at the moment) only one vehicle. But was:" + encodingManager);
 
-            logger.info("calling prepare.doWork ... (" + Helper.getMemInfo() + ")");
-            prepare.doWork();
+            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
+            ((PrepareContractionHierarchies) algoFactory).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
@@ -895,12 +1044,13 @@ protected void cleanUp()
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
         // calculate remaining subnetworks
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
                 + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
@@ -912,7 +1062,8 @@ protected void flush()
     }
 
     /**
-     * Releases all associated resources like memory or files.
+     * Releases all associated resources like memory or files. But it does not remove them. To
+     * remove the files created in graphhopperLocation you have to call clean().
      */
     public void close()
     {
@@ -921,12 +1072,27 @@ public void close()
 
         if (locationIndex != null)
             locationIndex.close();
+
+        try
+        {
+            lockFactory.forceRemove(fileLockName, true);
+        } catch (Exception ex)
+        {
+            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
+        }
     }
 
-    protected void ensureNotLoaded()
+    /**
+     * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
+     * load
+     */
+    public void clean()
     {
-        if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+        if (getGraphHopperLocation().isEmpty())
+            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+
+        File folder = new File(getGraphHopperLocation());
+        Helper.removeDir(folder);
     }
 
     // make sure this is identical to buildDate used in pom.xml
@@ -935,4 +1101,25 @@ private String formatDateTime( Date date )
     {
         return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
+
+    protected void ensureNotLoaded()
+    {
+        if (fullyLoaded)
+            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+    }
+
+    protected void ensureWriteAccess()
+    {
+        if (!allowWrites)
+            throw new IllegalStateException("Writes are not allowed!");
+    }
+
+    /**
+     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
+     * debugging purposes.
+     */
+    public long getVisitedSum()
+    {
+        return visitedSum.get();
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 6c89e3e3cd..4036672e37 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -20,7 +20,6 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 75ca1bcfee..906242e37b 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -75,10 +75,10 @@ public int put( long key, int value )
             return oldValue;
         }
 
-        values.incCapacity(size + 4);
+        values.ensureCapacity(size + 4);
         values.setInt(size, value);
         long doubleSize = size * 2;
-        keys.incCapacity(doubleSize + 8);
+        keys.ensureCapacity(doubleSize + 8);
 
         // store long => double of the orig size
         byte[] longBytes = bitUtil.fromLong(key);
diff --git a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
index c25281b989..6d8c2f96a2 100644
--- a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.geohash;
 
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * Defines the mapping between a one dimensional 'number' and a point (lat, lon) which is limited to
@@ -33,9 +33,9 @@
      */
     KeyAlgo setBounds( double minLonInit, double maxLonInit, double minLatInit, double maxLatInit );
 
-    long encode( CoordTrig coord );
+    long encode( GHPoint coord );
 
     long encode( double lat, double lon );
 
-    void decode( long spatialKey, CoordTrig latLon );
+    void decode( long spatialKey, GHPoint latLon );
 }
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 11c58733b5..3b6e167958 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -18,7 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class maps lat,lon to a (tile)number unlike SpatialKeyAlgo.
@@ -71,7 +71,7 @@ protected void setWorldBounds()
     }
 
     @Override
-    public long encode( CoordTrig coord )
+    public long encode( GHPoint coord )
     {
         return encode(coord.lat, coord.lon);
     }
@@ -98,7 +98,7 @@ public final long encode( double lat, double lon )
      * @param linearKey is the input
      */
     @Override
-    public final void decode( long linearKey, CoordTrig latLon )
+    public final void decode( long linearKey, GHPoint latLon )
     {
         double lat = linearKey / lonUnits * latDelta + bounds.minLat;
         double lon = linearKey % lonUnits * lonDelta + bounds.minLon;
diff --git a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
index 1e25589c48..74d3b73abd 100644
--- a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
@@ -18,7 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class implements the idea of a geohash but in 'binary form' - to avoid confusion this is
@@ -135,7 +135,7 @@ protected void setWorldBounds()
     }
 
     @Override
-    public long encode( CoordTrig coord )
+    public long encode( GHPoint coord )
     {
         return encode(coord.lat, coord.lon);
     }
@@ -162,13 +162,13 @@ public final long encode( double lat, double lon )
             if (minLatTmp < maxLatTmp)
             {
                 double midLat = (minLatTmp + maxLatTmp) / 2;
-                if (lat > midLat)
+                if (lat < midLat)
                 {
-                    hash |= 1;
-                    minLatTmp = midLat;
+                    maxLatTmp = midLat;
                 } else
                 {
-                    maxLatTmp = midLat;
+                    hash |= 1;
+                    minLatTmp = midLat;
                 }
             }
             i++;
@@ -182,13 +182,13 @@ public final long encode( double lat, double lon )
             if (minLonTmp < maxLonTmp)
             {
                 double midLon = (minLonTmp + maxLonTmp) / 2;
-                if (lon > midLon)
+                if (lon < midLon)
                 {
-                    hash |= 1;
-                    minLonTmp = midLon;
+                    maxLonTmp = midLon;
                 } else
                 {
-                    maxLonTmp = midLon;
+                    hash |= 1;
+                    minLonTmp = midLon;
                 }
             }
             i++;
@@ -206,7 +206,7 @@ public final long encode( double lat, double lon )
      * @param spatialKey is the input
      */
     @Override
-    public final void decode( long spatialKey, CoordTrig latLon )
+    public final void decode( long spatialKey, GHPoint latLon )
     {
         // Performance: calculating 'midLon' and 'midLat' on the fly is not slower than using 
         // precalculated values from arrays and for 'bits' a precalculated array is even slightly slower!
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index a943eec8cb..9820bbee00 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -21,6 +21,7 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -167,7 +168,7 @@ public final boolean hasTag( String key, Set<String> values )
      * Check a number of tags in the given order for the any of the given values. Used to parse
      * hierarchical access restrictions
      */
-    public boolean hasTag( String[] keyList, Set<String> values )
+    public boolean hasTag( List<String> keyList, Set<String> values )
     {
         for (String key : keyList)
         {
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index 03549347dc..276227a0e5 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -183,27 +183,31 @@ private OSMElement getNextXML() throws XMLStreamException
         {
             if (event == XMLStreamConstants.START_ELEMENT)
             {
-                String name = parser.getLocalName();
-                long id = 0;
-                switch (name.charAt(0))
+                String idStr = parser.getAttributeValue(null, "id");
+                if (idStr != null)
                 {
-                    case 'n':
-                        // note vs. node
-                        if ("node".equals(name))
+                    String name = parser.getLocalName();
+                    long id = 0;
+                    switch (name.charAt(0))
+                    {
+                        case 'n':
+                            // note vs. node
+                            if ("node".equals(name))
+                            {
+                                id = Long.parseLong(idStr);
+                                return OSMNode.create(id, parser);
+                            }
+                            break;
+
+                        case 'w':
                         {
-                            id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                            return OSMNode.create(id, parser);
+                            id = Long.parseLong(idStr);
+                            return OSMWay.create(id, parser);
                         }
-                        break;
-
-                    case 'w':
-                    {
-                        id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                        return OSMWay.create(id, parser);
+                        case 'r':
+                            id = Long.parseLong(idStr);
+                            return OSMRelation.create(id, parser);
                     }
-                    case 'r':
-                        id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                        return OSMRelation.create(id, parser);
                 }
             }
             event = parser.next();
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index b00983edbc..e12036317e 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -42,17 +42,13 @@
 import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalc3D;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DouglasPeucker;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.map.TLongObjectMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
+import java.util.*;
 
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
@@ -104,22 +100,24 @@
     private LongIntMap osmNodeIdToInternalNodeMap;
     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
     private TLongLongHashMap osmWayIdToRouteWeightMap;
-    // stores osm ids used by relations to identify which edge ids needs to be mapped later
-    private TLongHashSet osmIdStoreRequiredSet = new TLongHashSet();
-    ; 
-    private TIntLongMap edgeIdToOsmidMap;
-    private final TLongList barrierNodeIDs = new TLongArrayList();
+    // stores osm way ids used by relations to identify which edge ids needs to be mapped later
+    private TLongHashSet osmWayIdSet = new TLongHashSet();
+    private TIntLongMap edgeIdToOsmWayIdMap;
+    private final TLongList barrierNodeIds = new TLongArrayList();
     protected PillarInfo pillarInfo;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
-    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private boolean doSimplify = true;
     private int nextTowerId = 0;
     private int nextPillarId = 0;
     // negative but increasing to avoid clash with custom created OSM files
-    private long newUniqueOSMId = -Long.MAX_VALUE;
+    private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private boolean exitOnlyPillarNodeException = true;
     private File osmFile;
+    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
     public OSMReader( GraphStorage storage )
     {
@@ -185,7 +183,7 @@ void preProcess( File osmFile )
                             prepareHighwayNode(wayNodes.get(index));
                         }
 
-                        if (++tmpWayCounter % 500000 == 0)
+                        if (++tmpWayCounter % 5000000 == 0)
                         {
                             logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
                                     + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
@@ -223,22 +221,25 @@ private void prepareRestrictionRelation( OSMRelation relation )
         OSMTurnRelation turnRelation = createTurnRelation(relation);
         if (turnRelation != null)
         {
-            getOsmIdStoreRequiredSet().add(((OSMTurnRelation) turnRelation).getOsmIdFrom());
-            getOsmIdStoreRequiredSet().add(((OSMTurnRelation) turnRelation).getOsmIdTo());
+            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
         }
     }
 
-    private TLongSet getOsmIdStoreRequiredSet()
+    /**
+     * @return all required osmWayIds to process e.g. relations.
+     */
+    private TLongSet getOsmWayIdSet()
     {
-        return osmIdStoreRequiredSet;
+        return osmWayIdSet;
     }
 
-    private TIntLongMap getEdgeIdToOsmidMap()
+    private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
-        if (edgeIdToOsmidMap == null)
-            edgeIdToOsmidMap = new TIntLongHashMap(getOsmIdStoreRequiredSet().size());
+        if (edgeIdToOsmWayIdMap == null)
+            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
 
-        return edgeIdToOsmidMap;
+        return edgeIdToOsmWayIdMap;
     }
 
     /**
@@ -306,7 +307,7 @@ private void writeOsm2Graph( File osmFile )
                         processRelation((OSMRelation) item);
                         break;
                 }
-                if (++counter % 5000000 == 0)
+                if (++counter % 100000000 == 0)
                 {
                     logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
                 }
@@ -315,7 +316,7 @@ private void writeOsm2Graph( File osmFile )
             // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
         } catch (Exception ex)
         {
-            throw new RuntimeException("Couldn't process file " + osmFile, ex);
+            throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
         } finally
         {
             Helper.close(in);
@@ -410,9 +411,6 @@ void processWay( OSMWay way )
                     // remember barrier for processing the way behind it
                     lastBarrier = i;
                 }
-            } else if (nodeFlags < 0)
-            {
-                wayFlags = encodingManager.applyNodeFlags(wayFlags, -nodeFlags);
             }
         }
 
@@ -444,22 +442,69 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null)
             {
-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage).getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage)
+                GraphExtension extendedStorage = graphStorage.getExtension();
+                if (extendedStorage instanceof TurnCostExtension)
                 {
-                    Collection<TurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+                    Collection<TurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
                     for (TurnCostTableEntry entry : entries)
                     {
-                        ((TurnCostStorage) extendedStorage).setTurnCosts(entry.nodeVia, entry.edgeFrom, entry.edgeTo, (int) entry.flags);
+                        tcs.addTurnInfo(entry.edgeFrom, entry.nodeVia, entry.edgeTo, entry.flags);
                     }
                 }
             }
         }
     }
 
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation )
+    {
+        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
+
+        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
+        {
+            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation))
+            {
+                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+                if (oldEntry != null)
+                {
+                    // merging different encoders
+                    oldEntry.flags |= entry.flags;
+                } else
+                {
+                    entries.put(entry.getItemId(), entry);
+                }
+            }
+        }
+
+        return entries.valueCollection();
+    }
+
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder, OSMTurnRelation turnRelation )
+    {
+        if (!encoder.supports(TurnWeighting.class))
+            return Collections.emptyList();
+
+        EdgeExplorer edgeOutExplorer = outExplorerMap.get(encoder);
+        EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
+
+        if (edgeOutExplorer == null || edgeInExplorer == null)
+        {
+            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            outExplorerMap.put(encoder, edgeOutExplorer);
+
+            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            inExplorerMap.put(encoder, edgeInExplorer);
+        }
+        return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
+    }
+
+    /**
+     * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
+     * order to reduce memory overhead.
+     */
     public long getOsmIdOfInternalEdge( int edgeId )
     {
-        return getEdgeIdToOsmidMap().get(edgeId);
+        return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
     public int getInternalNodeIdOfOsmNode( long nodeOsmId )
@@ -712,7 +757,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         int nodes = pointList.getSize();
         for (int i = 1; i < nodes; i++)
         {
-            // we could save some lines if we would use pointList.calculateDistance(distCalc);
+            // we could save some lines if we would use pointList.calcDistance(distCalc);
             lat = pointList.getLatitude(i);
             lon = pointList.getLongitude(i);
             if (pointList.is3D())
@@ -743,18 +788,23 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2)
         {
-            simplifyAlgo.simplify(pillarNodes);
+            if (doSimplify)
+                simplifyAlgo.simplify(pillarNodes);
+
             iter.setWayGeometry(pillarNodes);
         }
-        storeOSMWayID(iter.getEdge(), wayOsmId);
+        storeOsmWayID(iter.getEdge(), wayOsmId);
         return iter;
     }
 
-    private void storeOSMWayID( int edgeId, long osmWayID )
+    /**
+     * Stores only osmWayIds which are required for relations
+     */
+    private void storeOsmWayID( int edgeId, long osmWayId )
     {
-        if (getOsmIdStoreRequiredSet().contains(osmWayID))
+        if (getOsmWayIdSet().contains(osmWayId))
         {
-            getEdgeIdToOsmidMap().put(edgeId, osmWayID);
+            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
         }
     }
 
@@ -787,7 +837,7 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList, bool
         return (int) tmpNode;
     }
 
-    void finishedReading()
+    protected void finishedReading()
     {
         printInfo("way");
         pillarInfo.clear();
@@ -795,8 +845,8 @@ void finishedReading()
         osmNodeIdToInternalNodeMap = null;
         osmNodeIdToNodeFlagsMap = null;
         osmWayIdToRouteWeightMap = null;
-        osmIdStoreRequiredSet = null;
-        edgeIdToOsmidMap = null;
+        osmWayIdSet = null;
+        edgeIdToOsmWayIdMap = null;
     }
 
     /**
@@ -824,7 +874,7 @@ long addBarrierNode( long nodeId )
 
     private long createNewNodeId()
     {
-        return newUniqueOSMId++;
+        return newUniqueOsmId++;
     }
 
     /**
@@ -835,10 +885,10 @@ private long createNewNodeId()
         // clear barred directions from routing flags
         flags &= ~nodeFlags;
         // add edge
-        barrierNodeIDs.clear();
-        barrierNodeIDs.add(fromId);
-        barrierNodeIDs.add(toId);
-        return addOSMWay(barrierNodeIDs, flags, wayOsmId);
+        barrierNodeIds.clear();
+        barrierNodeIds.add(fromId);
+        barrierNodeIds.add(toId);
+        return addOSMWay(barrierNodeIds, flags, wayOsmId);
     }
 
     /**
@@ -848,7 +898,7 @@ private long createNewNodeId()
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
     {
-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType((String) relation.getTag("restriction"));
+        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
         if (type != OSMTurnRelation.Type.UNSUPPORTED)
         {
             long fromWayID = -1;
@@ -871,7 +921,7 @@ OSMTurnRelation createTurnRelation( OSMRelation relation )
                     viaNodeID = member.ref();
                 }
             }
-            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
             {
                 return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
             }
@@ -890,12 +940,12 @@ boolean isInBounds( OSMNode node )
     /**
      * Maps OSM IDs (long) to internal node IDs (int)
      */
-    LongIntMap getNodeMap()
+    protected LongIntMap getNodeMap()
     {
         return osmNodeIdToInternalNodeMap;
     }
 
-    TLongLongMap getNodeFlagsMap()
+    protected TLongLongMap getNodeFlagsMap()
     {
         return osmNodeIdToNodeFlagsMap;
     }
@@ -908,14 +958,15 @@ TLongLongHashMap getRelFlagsMap()
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
-    public OSMReader setEncodingManager( EncodingManager acceptWay )
+    public OSMReader setEncodingManager( EncodingManager em )
     {
-        this.encodingManager = acceptWay;
+        this.encodingManager = em;
         return this;
     }
 
     public OSMReader setWayPointMaxDistance( double maxDist )
     {
+        doSimplify = maxDist > 0;
         simplifyAlgo.setMaxDistance(maxDist);
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMRelation.java b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
index 7b997fa2c4..ff7ca2651f 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
@@ -132,9 +132,9 @@ public void add( Member member )
         public static final int WAY = 1;
         public static final int RELATION = 2;
         private static final String typeDecode = "nwr";
-        private int type;
-        private long ref;
-        private String role;
+        private final int type;
+        private final long ref;
+        private final String role;
 
         public Member( XMLStreamReader parser )
         {
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 234e5040f6..c3e922d7e7 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -2,13 +2,12 @@
 
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
 
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
@@ -17,12 +16,11 @@
  */
 public class OSMTurnRelation
 {
-
     enum Type
     {
         UNSUPPORTED, NOT, ONLY;
 
-        private static Map<String, Type> tags = new HashMap<String, Type>();
+        private static final Map<String, Type> tags = new HashMap<String, Type>();
 
         static
         {
@@ -46,31 +44,31 @@ public static Type getRestrictionType( String tag )
         }
     }
 
-    private long fromOsm;
-    private long viaOsm;
-    private long toOsm;
-    private Type restriction;
+    private final long fromOsmWayId;
+    private final long viaOsmNodeId;
+    private final long toOsmWayId;
+    private final Type restriction;
 
     OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
     {
-        this.fromOsm = fromWayID;
-        this.viaOsm = viaNodeID;
-        this.toOsm = toWayID;
+        this.fromOsmWayId = fromWayID;
+        this.viaOsmNodeId = viaNodeID;
+        this.toOsmWayId = toWayID;
         this.restriction = restrictionType;
     }
 
     long getOsmIdFrom()
     {
-        return fromOsm;
+        return fromOsmWayId;
     }
 
     long getOsmIdTo()
     {
-        return toOsm;
+        return toOsmWayId;
     }
 
     /**
-     * transforms this relation into a collection of node cost entries
+     * Transforms this relation into a collection of turn cost entries
      * <p>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
@@ -79,75 +77,65 @@ long getOsmIdTo()
     public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
             EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
     {
-        final Set<TurnCostTableEntry> entries = new HashSet<TurnCostTableEntry>();
-
-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsm);
+        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
         try
         {
-            if (viaNodeId == OSMReader.EMPTY)
-            {
-                throw new IllegalArgumentException("Unknown node osm id");
-            }
+            // street with restriction was not included (access or tag limits etc)
+            if (nodeVia == OSMReader.EMPTY)
+                return Collections.emptyList();
 
             int edgeIdFrom = EdgeIterator.NO_EDGE;
 
             // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
 
             while (iter.next())
             {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsm)
+                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
                 {
                     edgeIdFrom = iter.getEdge();
                     break;
                 }
             }
 
-            //get all outgoing edges of the via node 
-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
-            if (edgeIdFrom != EdgeIterator.NO_EDGE)
+            if (edgeIdFrom == EdgeIterator.NO_EDGE)
+                return Collections.emptyList();
+
+            final Collection<TurnCostTableEntry> entries = new ArrayList<TurnCostTableEntry>();
+            // get all outgoing edges of the via node 
+            iter = edgeOutExplorer.setBaseNode(nodeVia);
+            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
+            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
+            while (iter.next())
             {
-                if (this.restriction == Type.NOT)
+                int edgeId = iter.getEdge();
+                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
                 {
-                    // if we have a restriction of TYPE_NO_* we add restriction only to
-                    // the given turn (from, via, to)  
-                    while (iter.next())
-                    {
-                        if (iter.getEdge() != edgeIdFrom && osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.toOsm)
-                        {
-                            final TurnCostTableEntry entry = new TurnCostTableEntry();
-                            entry.nodeVia = viaNodeId;
-                            entry.edgeFrom = edgeIdFrom;
-                            entry.edgeTo = iter.getEdge();
-                            entry.flags = encoder.getTurnFlags(true, 0);
-                            entries.add(entry);
-                        }
-                    }
-
-                } else if (this.restriction == Type.ONLY)
-                {
-                    // if we have a restriction of TYPE_ONLY_* we add restriction to
-                    // any turn possibility (from, via, * ) except the given turn
-                    while (iter.next())
-                    {
-                        if (iter.getEdge() != edgeIdFrom && osmReader.getOsmIdOfInternalEdge(iter.getEdge()) != this.toOsm)
-                        {
-                            final TurnCostTableEntry entry = new TurnCostTableEntry();
-                            entry.nodeVia = viaNodeId;
-                            entry.edgeFrom = edgeIdFrom;
-                            entry.edgeTo = iter.getEdge();
-                            entry.flags = encoder.getTurnFlags(true, 0);
-                            entries.add(entry);
-                        }
-                    }
+                    final TurnCostTableEntry entry = new TurnCostTableEntry();
+                    entry.nodeVia = nodeVia;
+                    entry.edgeFrom = edgeIdFrom;
+                    entry.edgeTo = iter.getEdge();
+                    entry.flags = encoder.getTurnFlags(true, 0);
+                    entries.add(entry);
+
+                    if (this.restriction == Type.NOT)
+                        break;
                 }
             }
+            return entries;
         } catch (Exception e)
         {
-            throw new IllegalStateException("Could not built node costs table for relation of node [osmId:" + this.viaOsm + "].", e);
+            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
         }
-        return entries;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
     /**
@@ -156,17 +144,24 @@ long getOsmIdTo()
     public static class TurnCostTableEntry
     {
         public int edgeFrom;
-        public int edgeTo;
         public int nodeVia;
+        public int edgeTo;
         public long flags;
 
         /**
-         * @return an unique id (edgeFrom, edgeTo) to avoid doubled entries during parsing
+         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+         * are involved.
          */
         public long getItemId()
         {
             return ((long) edgeFrom) << 32 | ((long) edgeTo);
         }
+
+        @Override
+        public String toString()
+        {
+            return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
+        }
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 00bdcbc28d..2edee09bc7 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -76,7 +76,7 @@ public void setNode( int id, double lat, double lon, double ele )
     private void _setNode( int id, double lat, double lon, double ele )
     {
         long tmp = (long) id * rowSizeInBytes;
-        da.incCapacity(tmp + rowSizeInBytes);
+        da.ensureCapacity(tmp + rowSizeInBytes);
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
         da.setInt(tmp + LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
new file mode 100644
index 0000000000..12301de6c9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -0,0 +1,341 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import java.awt.image.Raster;
+import java.io.*;
+import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
+import org.apache.xmlgraphics.image.codec.util.SeekableStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
+ * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
+ * http://graphhopper.com/public/license/CGIAR.txt
+ * <p>
+ * Every zip contains readme.txt with the necessary information e.g.:
+ * <ol>
+ * <li>
+ * All GeoTiffs with 6000 x 6000 pixels.
+ * </li>
+ * </ol>
+ * <p>
+ * @author NopMap
+ * @author Peter Karich
+ */
+public class CGIARProvider implements ElevationProvider
+{
+    private static final int WIDTH = 6000;
+    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
+    private File cacheDir = new File("/tmp/cgiar");
+    // String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";
+    private String baseUrl = "http://droppr.org/srtm/v4.1/6_5x5_TIFs";
+    private Directory dir;
+    private DAType daType = DAType.MMAP;
+    final double precision = 1e7;
+    private final double invPrecision = 1 / precision;
+    private final int degree = 5;
+    private boolean calcMean = false;
+    private boolean autoRemoveTemporary = true;
+
+    @Override
+    public void setCalcMean( boolean eleCalcMean )
+    {
+        calcMean = eleCalcMean;
+    }
+
+    /**
+     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
+     * our DataAccess object, so this option can be used to disable the default clear mechanism via
+     * specifying 'false'.
+     */
+    public void setAutoRemoveTemporaryFiles( boolean autoRemoveTemporary )
+    {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+    public void setDownloader( Downloader downloader )
+    {
+        this.downloader = downloader;
+    }
+
+    @Override
+    public ElevationProvider setCacheDir( File cacheDir )
+    {
+        if (cacheDir.exists() && !cacheDir.isDirectory())
+            throw new IllegalArgumentException("Cache path has to be a directory");
+        try
+        {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex)
+        {
+            throw new RuntimeException(ex);
+        }
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setBaseURL( String baseUrl )
+    {
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
+
+        this.baseUrl = baseUrl;
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType( DAType daType )
+    {
+        this.daType = daType;
+        return this;
+    }
+
+    @Override
+    public double getEle( double lat, double lon )
+    {
+        // no data we can avoid the trouble
+        if (lat > 60 || lat < -60)
+            return 0;
+
+        lat = (int) (lat * precision) / precision;
+        lon = (int) (lon * precision) / precision;
+        String name = getFileName(lat, lon);
+        HeightTile demProvider = cacheData.get(name);
+        if (demProvider == null)
+        {
+            if (!cacheDir.exists())
+                cacheDir.mkdirs();
+
+            int minLat = down(lat);
+            int minLon = down(lon);
+            // less restrictive against boundary checking
+            demProvider = new HeightTile(minLat, minLon, WIDTH, degree * precision, degree);
+            demProvider.setCalcMean(calcMean);
+
+            cacheData.put(name, demProvider);
+            DataAccess heights = getDirectory().find(name + ".gh");
+            demProvider.setHeights(heights);
+            boolean loadExisting = false;
+            try
+            {
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex)
+            {
+                logger.warn("cannot load " + name + ", error:" + ex.getMessage());
+            }
+
+            if (!loadExisting)
+            {
+                String tifName = name + ".tif";
+                String zippedURL = baseUrl + "/" + name + ".zip";
+                File file = new File(cacheDir, new File(zippedURL).getName());
+
+                // get zip file if not already in cacheDir - unzip later and in-memory only!
+                if (!file.exists())
+                {
+                    try
+                    {
+                        for (int i = 0; i < 3; i++)
+                        {
+                            try
+                            {
+                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                                break;
+                            } catch (SocketTimeoutException ex)
+                            {
+                                // just try again after a little nap
+                                Thread.sleep(2000);
+                                continue;
+                            } catch (IOException ex)
+                            {
+                                demProvider.setSeaLevel(true);
+                                // use small size on disc and in-memory
+                                heights.setSegmentSize(100).create(10).
+                                        flush();
+                                return 0;
+                            }
+                        }
+                    } catch (Exception ex)
+                    {
+                        throw new RuntimeException(ex);
+                    }
+                }
+
+                // short == 2 bytes
+                heights.create(2 * WIDTH * WIDTH);
+
+                // logger.info("start decoding");
+                // decode tiff data
+                Raster raster;
+                SeekableStream ss = null;
+                try
+                {
+                    InputStream is = new FileInputStream(file);
+                    ZipInputStream zis = new ZipInputStream(is);
+                    // find tif file in zip
+                    ZipEntry entry = zis.getNextEntry();
+                    while (entry != null && !entry.getName().equals(tifName))
+                    {
+                        entry = zis.getNextEntry();
+                    }
+
+                    ss = SeekableStream.wrapInputStream(zis, true);
+                    TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
+                    raster = imageDecoder.decodeAsRaster();
+                } catch (Exception e)
+                {
+                    throw new RuntimeException("Can't decode " + tifName, e);
+                } finally
+                {
+                    if (ss != null)
+                        Helper.close(ss);
+                }
+
+                // logger.info("start converting to our format");           
+                final int height = raster.getHeight();
+                final int width = raster.getWidth();
+                int x = 0, y = 0;
+                try
+                {
+                    for (y = 0; y < height; y++)
+                    {
+                        for (x = 0; x < width; x++)
+                        {
+                            short val = (short) raster.getPixel(x, y, (int[]) null)[0];
+                            if (val < -1000 || val > 12000)
+                                val = Short.MIN_VALUE;
+
+                            heights.setShort(2 * (y * WIDTH + x), val);
+                        }
+                    }
+                    heights.flush();
+
+                    // TODO remove tifName and zip?
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
+                }
+            } // loadExisting
+        }
+
+        if (demProvider.isSeaLevel())
+            return 0;
+
+        return demProvider.getHeight(lat, lon);
+    }
+
+    int down( double val )
+    {
+        // 'rounding' to closest 5
+        int intVal = (int) (val / degree) * degree;
+        if (!(val >= 0 || intVal - val < invPrecision))
+            intVal = intVal - degree;
+
+        return intVal;
+    }
+
+    protected String getFileName( double lat, double lon )
+    {
+        lon = 1 + (180 + lon) / degree;
+        int lonInt = (int) lon;
+        lat = 1 + (60 - lat) / degree;
+        int latInt = (int) lat;
+
+        if (Math.abs(latInt - lat) < invPrecision / degree)
+            latInt--;
+
+        // replace String.format as it seems to be slow
+        // String.format("srtm_%02d_%02d", lonInt, latInt);
+        String str = "srtm_";
+        str += lonInt < 10 ? "0" : "";
+        str += lonInt;
+        str += latInt < 10 ? "_0" : "_";
+        str += latInt;
+
+        return str;
+    }
+
+    @Override
+    public void release()
+    {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (autoRemoveTemporary && dir != null)
+            dir.clear();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "CGIAR";
+    }
+
+    private Directory getDirectory()
+    {
+        if (dir != null)
+            return dir;
+
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
+        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    }
+
+    public static void main( String[] args )
+    {
+        CGIARProvider provider = new CGIARProvider();
+        // 337.0
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 453.0
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 447.0
+        System.out.println(provider.getEle(49.968682, 11.574842));
+
+        // 3131
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+
+        // 123               
+        System.out.println(provider.getEle(38.065392, -87.099609));
+
+        // 1615
+        System.out.println(provider.getEle(40, -105.2277023));
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        // 1617
+        System.out.println(provider.getEle(39.999999, -105.2277023));
+
+        // 0
+        System.out.println(provider.getEle(29.840644, -42.890625));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index be431b6654..aed7740ae7 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -18,6 +18,7 @@
  */
 package com.graphhopper.reader.dem;
 
+import com.graphhopper.storage.DAType;
 import java.io.File;
 
 /**
@@ -32,20 +33,26 @@
 
     /**
      * Specifies the service URL where to download the elevation data. An empty string should set it
-     * to the default URL.
+     * to the default URL. Default is a provider-dependent URL which should work out of the box.
      */
     ElevationProvider setBaseURL( String baseURL );
 
     /**
      * Specifies the directory where to temporarily store the elevation data after fetched from base
-     * URL.
+     * URL. Default is a custom provider-dependent subdirectory in '/tmp'
      */
     ElevationProvider setCacheDir( File cacheDir );
 
     /**
-     * Set to true if you have a small area and need high speed access.
+     * Set to true if you have a small area and need high speed access. Default is DAType.MMAP
      */
-    ElevationProvider setInMemory( boolean b );
+    ElevationProvider setDAType( DAType daType );
+
+    /**
+     * Configuration option to include surrounding elevation points when fetching the elevation. Has
+     * only an effect if called before the first getEle call. Turned off by default.
+     */
+    void setCalcMean( boolean calcMean );
 
     /**
      * Release resources.
@@ -73,7 +80,7 @@ public ElevationProvider setBaseURL( String baseURL )
         }
 
         @Override
-        public ElevationProvider setInMemory( boolean b )
+        public ElevationProvider setDAType( DAType daType )
         {
             return this;
         }
@@ -82,5 +89,10 @@ public ElevationProvider setInMemory( boolean b )
         public void release()
         {
         }
+
+        @Override
+        public void setCalcMean( boolean eleCalcMean )
+        {
+        }
     };
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index 852c5f1684..c0c27c476e 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -24,6 +24,7 @@
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.imageio.ImageIO;
 
 /**
@@ -37,17 +38,38 @@
     private final int minLat;
     private final int minLon;
     private final int width;
+    private final int degree;
     private final double lowerBound;
     private final double higherBound;
+    private boolean calcMean;
 
-    public HeightTile( int minLat, int minLon, int width, double precision )
+    public HeightTile( int minLat, int minLon, int width, double precision, int degree )
     {
         this.minLat = minLat;
         this.minLon = minLon;
         this.width = width;
 
         this.lowerBound = -1 / precision;
-        this.higherBound = 1 + 1 / precision;
+        this.higherBound = degree + 1 / precision;
+
+        this.degree = degree;
+    }
+
+    public HeightTile setCalcMean( boolean b )
+    {
+        this.calcMean = b;
+        return this;
+    }
+
+    public HeightTile setSeaLevel( boolean b )
+    {
+        heights.setHeader(0, b ? 1 : 0);
+        return this;
+    }
+
+    public boolean isSeaLevel()
+    {
+        return heights.getHeader(0) == 1;
     }
 
     void setHeights( DataAccess da )
@@ -55,10 +77,10 @@ void setHeights( DataAccess da )
         this.heights = da;
     }
 
-    public short getHeight( double lat, double lon )
+    public double getHeight( double lat, double lon )
     {
-        double deltaLat = lat - minLat;
-        double deltaLon = lon - minLon;
+        double deltaLat = Math.abs(lat - minLat);
+        double deltaLon = Math.abs(lon - minLon);
         if (deltaLat > higherBound || deltaLat < lowerBound)
             throw new IllegalStateException("latitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
         if (deltaLon > higherBound || deltaLon < lowerBound)
@@ -66,9 +88,47 @@ public short getHeight( double lat, double lon )
 
         // first row in the file is the northernmost one
         // http://gis.stackexchange.com/a/43756/9006
-        int lonSimilar = (int) Math.round(width * deltaLon);
-        int latSimilar = width - (int) Math.round(width * deltaLat);
-        return heights.getShort(2 * (latSimilar * width + lonSimilar));
+        int lonSimilar = (int) (width / degree * deltaLon);
+        // different fallback methods for lat and lon as we have different rounding (lon -> positive, lat -> negative)
+        if (lonSimilar >= width)
+            lonSimilar = width - 1;
+        int latSimilar = width - 1 - (int) (width / degree * deltaLat);
+        if (latSimilar < 0)
+            latSimilar = 0;
+
+        // always keep in mind factor 2 because of short value
+        int daPointer = 2 * (latSimilar * width + lonSimilar);
+        int value = heights.getShort(daPointer);
+        AtomicInteger counter = new AtomicInteger(1);
+        if (value == Short.MIN_VALUE)
+            return Double.NaN;
+
+        if (calcMean)
+        {
+            if (lonSimilar > 0)
+                value += includePoint(daPointer - 2, counter);
+
+            if (lonSimilar < width - 1)
+                value += includePoint(daPointer + 2, counter);
+
+            if (latSimilar > 0)
+                value += includePoint(daPointer - 2 * width, counter);
+
+            if (latSimilar < width - 1)
+                value += includePoint(daPointer + 2 * width, counter);
+        }
+
+        return (double) value / counter.get();
+    }
+
+    private double includePoint( int pointer, AtomicInteger counter )
+    {
+        short value = heights.getShort(pointer);
+        if (value == Short.MIN_VALUE)
+            return 0;
+
+        counter.incrementAndGet();
+        return value;
     }
 
     public void toImage( String imageFile ) throws IOException
@@ -85,18 +145,24 @@ protected BufferedImage makeARGB()
         for (int i = 0; i < len; i++)
         {
             int lonSimilar = i % width;
-            // no need for width - x as coordinate system for Graphics is already this way
+            // no need for width - y as coordinate system for Graphics is already this way
             int latSimilar = i / width;
             int green = Math.abs(heights.getShort(i * 2));
-            int red = 0;
-            while (green > 255)
+            if (green == 0)
+            {
+                g.setColor(new Color(255, 0, 0, 255));
+            } else
             {
-                green = green / 10;
-                red += 50;
+                int red = 0;
+                while (green > 255)
+                {
+                    green = green / 10;
+                    red += 50;
+                }
+                if (red > 255)
+                    red = 255;
+                g.setColor(new Color(red, green, 122, 255));
             }
-            if (red > 255)
-                red = 255;
-            g.setColor(new Color(red, green, 122, 255));
             g.drawLine(lonSimilar, latSimilar, lonSimilar, latSimilar);
         }
         g.dispose();
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index be9731f37a..8570012140 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -43,7 +43,21 @@
 {
     public static void main( String[] args ) throws IOException
     {
-        new SRTMProvider().getEle(55, -161);
+        SRTMProvider provider = new SRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new: 
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
     }
 
     private static final BitUtil BIT_UTIL = BitUtil.BIG;
@@ -60,6 +74,7 @@ public static void main( String[] args ) throws IOException
     private final double invPrecision = 1 / precision;
     // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
     private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+    private boolean calcMean = false;
 
     public SRTMProvider()
     {
@@ -67,6 +82,12 @@ public SRTMProvider()
         init();
     }
 
+    @Override
+    public void setCalcMean( boolean calcMean )
+    {
+        this.calcMean = calcMean;
+    }
+
     /**
      * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
      * coordinate has.
@@ -84,7 +105,7 @@ private SRTMProvider init()
                 InputStream is = getClass().getResourceAsStream(str + "_names.txt.zip");
                 ZipInputStream zis = new ZipInputStream(is);
                 zis.getNextEntry();
-                for (String line : Helper.readFile(new InputStreamReader(zis, "UTF-8")))
+                for (String line : Helper.readFile(new InputStreamReader(zis, Helper.UTF_CS)))
                 {
                     int lat = Integer.parseInt(line.substring(1, 3));
                     if (line.substring(0, 1).charAt(0) == 'S')
@@ -123,29 +144,32 @@ public void setDownloader( Downloader downloader )
     public ElevationProvider setCacheDir( File cacheDir )
     {
         if (cacheDir.exists() && !cacheDir.isDirectory())
-            throw new IllegalStateException("Cache path has to be a directory");
+            throw new IllegalArgumentException("Cache path has to be a directory");
 
-        this.cacheDir = cacheDir;
+        try
+        {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex)
+        {
+            throw new RuntimeException(ex);
+        }
         return this;
     }
 
     @Override
     public ElevationProvider setBaseURL( String baseUrl )
     {
-        if (baseUrl.isEmpty())
-            return this;
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
 
         this.baseUrl = baseUrl;
         return this;
     }
 
     @Override
-    public ElevationProvider setInMemory( boolean inMem )
+    public ElevationProvider setDAType( DAType daType )
     {
-        if (inMem)
-            daType = DAType.RAM;
-        else
-            daType = DAType.MMAP;
+        this.daType = daType;
         return this;
     }
 
@@ -207,74 +231,80 @@ public double getEle( double lat, double lon )
 
             int minLat = down(lat);
             int minLon = down(lon);
-            demProvider = new HeightTile(minLat, minLon, WIDTH, precision);
+            demProvider = new HeightTile(minLat, minLon, WIDTH, precision, 1);
+            demProvider.setCalcMean(calcMean);
             cacheData.put(intKey, demProvider);
+            DataAccess heights = getDirectory().find("dem" + intKey);
+            demProvider.setHeights(heights);
+            boolean loadExisting = false;
             try
             {
-                String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
-                File file = new File(cacheDir, new File(zippedURL).getName());
-                InputStream is;
-                // get zip file if not already in cacheDir - unzip later and in-memory only!
-                if (!file.exists())
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex)
+            {
+                logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
+            }
+
+            if (!loadExisting)
+            {
+                byte[] bytes = new byte[2 * WIDTH * WIDTH];
+                heights.create(bytes.length);
+                try
                 {
-                    for (int i = 0; i < 3; i++)
+                    String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    File file = new File(cacheDir, new File(zippedURL).getName());
+                    InputStream is;
+                    // get zip file if not already in cacheDir - unzip later and in-memory only!
+                    if (!file.exists())
                     {
-                        try
-                        {
-                            downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                            break;
-                        } catch (SocketTimeoutException ex)
+                        for (int i = 0; i < 3; i++)
                         {
-                            // just try again after a little nap
-                            Thread.sleep(2000);
-                            continue;
-                        } catch (FileNotFoundException ex)
-                        {
-                            // now try different URL (with point!), necessary if mirror is used
-                            zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
-                            continue;
+                            try
+                            {
+                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                                break;
+                            } catch (SocketTimeoutException ex)
+                            {
+                                // just try again after a little nap
+                                Thread.sleep(2000);
+                                continue;
+                            } catch (FileNotFoundException ex)
+                            {
+                                // now try different URL (with point!), necessary if mirror is used
+                                zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                                continue;
+                            }
                         }
                     }
-                }
-
-                is = new FileInputStream(file);
-                ZipInputStream zis = new ZipInputStream(is);
-                zis.getNextEntry();
-                BufferedInputStream buff = new BufferedInputStream(zis);
-                byte[] bytes = new byte[2 * WIDTH * WIDTH];
-                DataAccess heights = getDirectory().find("dem" + intKey);
-                heights.create(bytes.length);
 
-                demProvider.setHeights(heights);
-                int len;
-                while ((len = buff.read(bytes)) > 0)
-                {
-                    for (int bytePos = 0; bytePos < len; bytePos += 2)
+                    is = new FileInputStream(file);
+                    ZipInputStream zis = new ZipInputStream(is);
+                    zis.getNextEntry();
+                    BufferedInputStream buff = new BufferedInputStream(zis);
+                    int len;
+                    while ((len = buff.read(bytes)) > 0)
                     {
-                        short val = BIT_UTIL.toShort(bytes, bytePos);
-                        if (val < -1000 || val > 10000)
+                        for (int bytePos = 0; bytePos < len; bytePos += 2)
                         {
-                            // TODO fill unassigned gaps with neighbor values -> flood fill algorithm !
-                            // -> calculate mean with an associated weight of how long the distance to the neighbor is
-//                            throw new IllegalStateException("Invalid height value " + val
-//                                    + ", y:" + bytePos / WIDTH + ", x:" + (WIDTH - bytePos % WIDTH));
-                            val = Short.MIN_VALUE;
-                        }
+                            short val = BIT_UTIL.toShort(bytes, bytePos);
+                            if (val < -1000 || val > 12000)
+                                val = Short.MIN_VALUE;
 
-                        heights.setShort(bytePos, val);
+                            heights.setShort(bytePos, val);
+                        }
                     }
+                    heights.flush();
+
+                    // demProvider.toImage("x" + file.getName() + ".png");
+                    // TODO remove hgt and zip?
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException(ex);
                 }
-                // demProvider.toImage(file.getName() + ".png");
-            } catch (Exception ex)
-            {
-                throw new RuntimeException(ex);
-            }
+            } // loadExisting
         }
 
-        short val = demProvider.getHeight(lat, lon);
-        if (val == Short.MIN_VALUE)
-            return Double.NaN;
-        return val;
+        return demProvider.getHeight(lat, lon);
     }
 
     @Override
@@ -298,7 +328,7 @@ private Directory getDirectory()
         if (dir != null)
             return dir;
 
-        logger.info("SRTM Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
         return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index eb23dac775..56ba796d60 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,14 +17,21 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.util.DistancePlaneProjection;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.*;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 
 /**
  * This class implements the A* algorithm according to
@@ -36,32 +43,28 @@
  */
 public class AStar extends AbstractRoutingAlgorithm
 {
-    private DistanceCalc dist;
+    private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEdge> fromMap;
     private PriorityQueue<AStarEdge> prioQueueOpenSet;
     private AStarEdge currEdge;
     private int to1 = -1;
-    private double toLat;
-    private double toLon;
 
-    public AStar( Graph g, FlagEncoder encoder, Weighting weighting )
+    public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(g, encoder, weighting);
+        super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(true);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     /**
-     * @param approx if true it enables an approximative distance calculation from lat,lon values
+     * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( boolean approx )
+    public AStar setApproximation( WeightApproximator approx )
     {
-        if (approx)
-            dist = new DistancePlaneProjection();
-        else
-            dist = new DistanceCalcEarth();
-
+        weightApprox = approx;
         return this;
     }
 
@@ -75,57 +78,66 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        toLat = nodeAccess.getLatitude(to);
-        toLon = nodeAccess.getLongitude(to);
         to1 = to;
+        weightApprox.setGoalNode(to);
         currEdge = createEdgeEntry(from, 0);
-        fromMap.put(from, currEdge);
+        if (!traversalMode.isEdgeBased())
+        {
+            fromMap.put(from, currEdge);
+        }
         return runAlgo();
     }
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation, tmpLat, tmpLon;
+        double currWeightToGoal, distEstimation;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitReached())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
             EdgeIterator iter = explorer.setBaseNode(currVertex);
             while (iter.next())
             {
-                if (!accept(iter))
+                if (!accept(iter, currEdge.edge))
                     continue;
-                if (currEdge.edge == iter.getEdge())
+
+                int neighborNode = iter.getAdjNode();
+                int traversalId = traversalMode.createTraversalId(iter, false);
+                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
+                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
+                        + currEdge.weightOfVisitedPath);
+                if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
-                int adjNode = iter.getAdjNode();
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false) + currEdge.weightToCompare;
-                AStarEdge nEdge = fromMap.get(adjNode);
-                if (nEdge == null || nEdge.weightToCompare > alreadyVisitedWeight)
+                AStarEdge ase = fromMap.get(traversalId);
+                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    tmpLat = nodeAccess.getLatitude(adjNode);
-                    tmpLon = nodeAccess.getLongitude(adjNode);
-                    currWeightToGoal = dist.calcDist(toLat, toLon, tmpLat, tmpLon);
-                    currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                    currWeightToGoal = weightApprox.approximate(neighborNode);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
-                    if (nEdge == null)
+                    if (ase == null)
                     {
-                        nEdge = new AStarEdge(iter.getEdge(), adjNode, distEstimation, alreadyVisitedWeight);
-                        fromMap.put(adjNode, nEdge);
+                        ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
+                        fromMap.put(traversalId, ase);
                     } else
                     {
-                        prioQueueOpenSet.remove(nEdge);
-                        nEdge.edge = iter.getEdge();
-                        nEdge.weight = distEstimation;
-                        nEdge.weightToCompare = alreadyVisitedWeight;
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
+                        prioQueueOpenSet.remove(ase);
+                        ase.edge = iter.getEdge();
+                        ase.weight = distEstimation;
+                        ase.weightOfVisitedPath = alreadyVisitedWeight;
                     }
-                    nEdge.parent = currEdge;
-                    prioQueueOpenSet.add(nEdge);
-                    updateShortest(nEdge, adjNode);
+
+                    ase.parent = currEdge;
+                    prioQueueOpenSet.add(ase);
+
+                    updateBestPath(iter, ase, traversalId);
                 }
             }
 
@@ -164,23 +176,27 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
         // but to compare distance we need it only from start:
-        double weightToCompare;
+        double weightOfVisitedPath;
 
-        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightToCompare )
+        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
             super(edgeId, adjNode, weightForHeap);
-            // round makes distance smaller => heuristic should underestimate the distance!
-            this.weightToCompare = (float) weightToCompare;
+            this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
 
     @Override
     public String getName()
     {
-        return "astar";
+        return AlgorithmOptions.ASTAR;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 13765624ba..f8a92e1bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,35 +17,27 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.AStar.AStarEdge;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.shapes.CoordTrig;
-import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.routing.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
+
 import java.util.PriorityQueue;
 
+import com.graphhopper.routing.AStar.AStarEdge;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.*;
+
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
- * for a bidirectional A* as the finish condition can not be so strict which leads to either
- * suboptimal paths or suboptimal node exploration (too many nodes). Still very good approximations
- * with a rougly twice times faster running time than the normal A* can be reached.
+ * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * Computing the Shortest Path: A Search Meets Graph Theory ->
- * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
+ * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
  * <p/>
- * better stop condition
+ * and
  * <p/>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
@@ -58,10 +50,11 @@
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
  * @author Peter Karich
+ * @author jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
-    private DistanceCalc dist;
+    private ConsistentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -69,19 +62,16 @@
     private TIntObjectMap<AStarEdge> bestWeightMapOther;
     protected AStarEdge currFrom;
     protected AStarEdge currTo;
-    protected double approximationFactor;
-    private CoordTrig fromCoord;
-    private CoordTrig toCoord;
     protected PathBidirRef bestPath;
 
-    public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
-
-        // different default value for approximation than AStar
-        setApproximation(false);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     protected void initCollections( int size )
@@ -96,26 +86,9 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( boolean approx )
-    {
-        if (approx)
-        {
-            dist = new DistancePlaneProjection();
-            approximationFactor = 0.5;
-        } else
-        {
-            dist = new DistanceCalcEarth();
-            approximationFactor = 1.2;
-        }
-        return this;
-    }
-
-    /**
-     * Specify a low value like 0.5 for worse but faster results. Or over 1.1 for more precise.
-     */
-    public AStarBidirection setApproximationFactor( double approxFactor )
+    public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        this.approximationFactor = approxFactor;
+        weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
@@ -129,13 +102,26 @@ protected AStarEdge createEdgeEntry( int node, double dist )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        bestWeightMapFrom.put(from, currFrom);
+        weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
-        fromCoord = new GHPoint(nodeAccess.getLatitude(from), nodeAccess.getLongitude(from));
-        if (currTo != null)
+        if (!traversalMode.isEdgeBased())
         {
-            bestWeightMapOther = bestWeightMapTo;
-            updateShortest(currTo, from);
+            bestWeightMapFrom.put(from, currFrom);
+            if (currTo != null)
+            {
+                bestWeightMapOther = bestWeightMapTo;
+                updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
+            }
+        } else
+        {
+            if (currTo != null && currTo.adjNode == from)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
@@ -143,25 +129,42 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        bestWeightMapTo.put(to, currTo);
+        weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
-        toCoord = new GHPoint(nodeAccess.getLatitude(to), nodeAccess.getLongitude(to));
-        if (currFrom != null)
+        if (!traversalMode.isEdgeBased())
+        {
+            bestWeightMapTo.put(to, currTo);
+            if (currFrom != null)
+            {
+                bestWeightMapOther = bestWeightMapFrom;
+                updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
+            }
+        } else
         {
-            bestWeightMapOther = bestWeightMapFrom;
-            updateShortest(currFrom, to);
+            if (currFrom != null && currFrom.adjNode == to)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
     @Override
-    protected void initPath()
+    protected Path createAndInitPath()
     {
         bestPath = new PathBidirRef(graph, flagEncoder);
+        return bestPath;
     }
 
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -172,17 +175,19 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
             throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
     }
 
-    // Problem is the correct finish condition! if the bounds are too wide too many nodes are visited :/   
-    // d_f (v) + (v, w) + d_r (w) <  + p_r(t)
-    // where pi_r_of_t = p_r(t) = 1/2(pi_r(t) - pi_f(t) + pi_f(s)), and pi_f(t)=0
     @Override
     protected boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight() * approximationFactor;
-        return currFrom.weightToCompare + currTo.weightToCompare >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
     }
 
     @Override
@@ -193,8 +198,8 @@ boolean fillEdgesFrom()
 
         currFrom = prioQueueOpenSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, toCoord, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
-        visitedFromCount++;
+        fillEdges(currFrom, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        visitedCountFrom++;
         return true;
     }
 
@@ -206,13 +211,12 @@ boolean fillEdgesTo()
 
         currTo = prioQueueOpenSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, fromCoord, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
-        visitedToCount++;
+        fillEdges(currTo, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        visitedCountTo++;
         return true;
     }
 
-    private void fillEdges( AStarEdge currEdge, CoordTrig goal,
-            PriorityQueue<AStarEdge> prioQueueOpenSet,
+    private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
             TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
@@ -220,63 +224,83 @@ private void fillEdges( AStarEdge currEdge, CoordTrig goal,
         EdgeIterator iter = explorer.setBaseNode(currNode);
         while (iter.next())
         {
-            if (!accept(iter))
-                continue;
-            if (currEdge.edge == iter.getEdge())
+            if (!accept(iter, currEdge.edge))
                 continue;
 
-            int adjNode = iter.getAdjNode();
+            int neighborNode = iter.getAdjNode();
+            int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse) + currEdge.weightToCompare;
-            AStarEdge de = shortestWeightMap.get(adjNode);
-            if (de == null || de.weightToCompare > alreadyVisitedWeight)
+            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath);
+            if (Double.isInfinite(alreadyVisitedWeight))
+                continue;
+
+            AStarEdge ase = shortestWeightMap.get(traversalId);
+            if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
-                double tmpLat = nodeAccess.getLatitude(adjNode);
-                double tmpLon = nodeAccess.getLongitude(adjNode);
-                double currWeightToGoal = dist.calcDist(goal.lat, goal.lon, tmpLat, tmpLon);
-                currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
-                if (de == null)
+                if (ase == null)
                 {
-                    de = new AStarEdge(iter.getEdge(), adjNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(adjNode, de);
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
+                    shortestWeightMap.put(traversalId, ase);
                 } else
                 {
-                    prioQueueOpenSet.remove(de);
-                    de.edge = iter.getEdge();
-                    de.weight = estimationFullDist;
-                    de.weightToCompare = alreadyVisitedWeight;
+                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
+                    prioQueueOpenSet.remove(ase);
+                    ase.edge = iter.getEdge();
+                    ase.weight = estimationFullDist;
+                    ase.weightOfVisitedPath = alreadyVisitedWeight;
                 }
 
-                de.parent = currEdge;
-                prioQueueOpenSet.add(de);
-                updateShortest(de, adjNode);
+                ase.parent = currEdge;
+                prioQueueOpenSet.add(ase);
+                updateBestPath(iter, ase, traversalId);
             }
         }
     }
 
 //    @Override -> TODO use only weight => then a simple EdgeEntry is possible
-    public void updateShortest( AStarEdge shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent, int currLoc )
     {
         AStarEdge entryOther = bestWeightMapOther.get(currLoc);
         if (entryOther == null)
             return;
 
+        boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update 
-        double newShortest = shortestDE.weightToCompare + entryOther.weightToCompare;
-        if (newShortest < bestPath.getWeight())
+        double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
+        if (traversalMode.isEdgeBased())
+        {
+            if (entryOther.edge != entryCurrent.edge)
+                throw new IllegalStateException("cannot happen for edge based execution of " + getName());
+
+            // see DijkstraBidirectionRef
+            if (entryOther.adjNode != entryCurrent.adjNode)
+            {
+                entryCurrent = (AStar.AStarEdge) entryCurrent.parent;
+                newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
+            } else
+            {
+                // we detected a u-turn at meeting point, skip if not supported
+                if (!traversalMode.hasUTurnSupport())
+                    return;
+            }
+        }
+
+        if (newWeight < bestPath.getWeight())
         {
-            bestPath.setSwitchToFrom(bestWeightMapFrom == bestWeightMapOther);
-            bestPath.edgeEntry = shortestDE;
+            bestPath.setSwitchToFrom(reverse);
+            bestPath.edgeEntry = entryCurrent;
             bestPath.edgeTo = entryOther;
-            bestPath.setWeight(newShortest);
+            bestPath.setWeight(newWeight);
         }
     }
 
     @Override
     public String getName()
     {
-        return "astarbi";
+        return AlgorithmOptions.ASTAR_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 3367e3d0df..2a047c7434 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
@@ -28,16 +29,18 @@
  */
 public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm
 {
-    int visitedFromCount;
-    int visitedToCount;
+    int visitedCountFrom;
+    int visitedCountTo;
     protected boolean finishedFrom;
     protected boolean finishedTo;
 
-    public abstract void initFrom( int from, double dist );
+    abstract void initFrom( int from, double dist );
 
-    public abstract void initTo( int to, double dist );
+    abstract void initTo( int to, double dist );
 
-    protected abstract void initPath();
+    protected abstract Path createAndInitPath();
+
+    protected abstract boolean isWeightLimitReached();
 
     abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
 
@@ -45,24 +48,25 @@
 
     abstract boolean fillEdgesTo();
 
-    public AbstractBidirAlgo( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AbstractBidirAlgo( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
     }
 
     @Override
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        initPath();
+        createAndInitPath();
         initFrom(from, 0);
         initTo(to, 0);
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitReached())
         {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
@@ -70,13 +74,11 @@ private Path runAlgo()
             if (!finishedTo)
                 finishedTo = !fillEdgesTo();
         }
-
-        return extractPath();
     }
 
     @Override
     public int getVisitedNodes()
     {
-        return visitedFromCount + visitedToCount;
+        return visitedCountFrom + visitedCountTo;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index b4f6c5b335..62349b3d81 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -17,18 +17,13 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import java.util.ArrayList;
-import java.util.List;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * @author Peter Karich
@@ -36,68 +31,54 @@
 public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm
 {
     private EdgeFilter additionalEdgeFilter;
-    protected Graph graph;
+    protected final Graph graph;
     protected NodeAccess nodeAccess;
     protected EdgeExplorer inEdgeExplorer;
     protected EdgeExplorer outEdgeExplorer;
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
+    protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
      * @param graph specifies the graph where this algorithm will run on
      * @param encoder sets the used vehicle (bike, car, foot)
      * @param weighting set the used weight calculation (e.g. fastest, shortest).
+     * @param traversalMode how the graph is traversed e.g. if via nodes or edges.
      */
-    public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
         this.weighting = weighting;
         this.flagEncoder = encoder;
-        setGraph(graph);
-    }
-
-    /**
-     * Specify the graph on which this algorithm should operate. API glitch: this method overwrites
-     * graph specified while constructing the algorithm. Only necessary if graph is a QueryGraph.
-     */
-    protected RoutingAlgorithm setGraph( Graph graph )
-    {
+        this.traversalMode = traversalMode;
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
         outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, false, true));
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
-        return this;
-    }
-
-    protected QueryGraph createQueryGraph()
-    {
-        return new QueryGraph(graph);
     }
 
     @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
+    public void setWeightLimit( double weight )
     {
-        QueryGraph queryGraph = createQueryGraph();
-        List<QueryResult> results = new ArrayList<QueryResult>(2);
-        results.add(fromRes);
-        results.add(toRes);
-        queryGraph.lookup(results);
-        setGraph(queryGraph);
-        return calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
+        this.weightLimit = weight;
     }
-
+       
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
     {
         this.additionalEdgeFilter = additionalEdgeFilter;
         return this;
     }
 
-    protected boolean accept( EdgeIterator iter )
+    protected boolean accept( EdgeIterator iter, int prevOrNextEdgeId )
     {
+        if (!traversalMode.hasUTurnSupport() && iter.getEdge() == prevOrNextEdgeId)
+            return false;
+
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);
     }
 
-    protected void updateShortest( EdgeEntry shortestDE, int currLoc )
+    protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry bestEdgeEntry, int traversalId )
     {
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
new file mode 100644
index 0000000000..6cd1313e15
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -0,0 +1,194 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.util.PMap;
+
+/**
+ * The algorithm options. Create an immutable object via:
+ * <pre>
+ * AlgorithmOptions algoOpts = AlgorithmOptions.start().
+ *        algorithm(AlgorithmOptions.DIJKSTRA).
+ *        weighting(weighting).
+ *        build();
+ * </pre>
+ * <p>
+ * @author Peter Karich
+ */
+public class AlgorithmOptions
+{
+    /**
+     * Bidirectional Dijkstra
+     */
+    public static final String DIJKSTRA_BI = "dijkstrabi";
+    /**
+     * Unidirectional Dijkstra
+     */
+    public static final String DIJKSTRA = "dijkstra";
+    /**
+     * one to many Dijkstra
+     */
+    public static final String DIJKSTRA_ONE_TO_MANY = "dijkstraOneToMany";
+    /**
+     * Unidirectional A*
+     */
+    public static final String ASTAR = "astar";
+    /**
+     * Bidirectional A*
+     */
+    public static final String ASTAR_BI = "astarbi";
+    private String algorithm = DIJKSTRA_BI;
+    private Weighting weighting;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private FlagEncoder flagEncoder;
+    private final PMap hints = new PMap(5);
+
+    private AlgorithmOptions()
+    {
+    }
+
+    /**
+     * Default traversal mode NODE_BASED is used.
+     */
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+    }
+
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting, TraversalMode tMode )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+        this.traversalMode = tMode;
+    }
+
+    /**
+     * @return the traversal mode, where node-based is the default.
+     */
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
+    public Weighting getWeighting()
+    {
+        assertNotNull(weighting, "weighting");
+        return weighting;
+    }
+
+    public String getAlgorithm()
+    {
+        assertNotNull(algorithm, "algorithm");
+        return algorithm;
+    }
+
+    public FlagEncoder getFlagEncoder()
+    {
+        assertNotNull(flagEncoder, "flagEncoder");
+        return flagEncoder;
+    }
+
+    public PMap getHints()
+    {
+        return hints;
+    }
+
+    private void assertNotNull( Object optionValue, String optionName )
+    {
+        if (optionValue == null)
+            throw new NullPointerException("Option '" + optionName + "' must NOT be null");
+    }
+
+    @Override
+    public String toString()
+    {
+        return algorithm + ", " + weighting + ", " + flagEncoder + ", " + traversalMode;
+    }
+
+    /**
+     * This method starts the building process for AlgorithmOptions.
+     */
+    public static Builder start()
+    {
+        return new Builder();
+    }
+
+    /**
+     * This method clones the specified AlgorithmOption object with the possibility for further
+     * changes.
+     */
+    public static Builder start( AlgorithmOptions opts )
+    {
+        Builder b = new Builder();
+        if (opts.algorithm != null)
+            b.algorithm(opts.getAlgorithm());
+        if (opts.flagEncoder != null)
+            b.flagEncoder(opts.getFlagEncoder());
+        if (opts.traversalMode != null)
+            b.traversalMode(opts.getTraversalMode());
+        if (opts.weighting != null)
+            b.weighting(opts.getWeighting());
+        return b;
+    }
+
+    public static class Builder
+    {
+        private final AlgorithmOptions opts = new AlgorithmOptions();
+
+        public Builder traversalMode( TraversalMode traversalMode )
+        {
+            if (traversalMode == null)
+                throw new IllegalArgumentException("null as traversal mode is not allowed");
+
+            this.opts.traversalMode = traversalMode;
+            return this;
+        }
+
+        public Builder weighting( Weighting weighting )
+        {
+            this.opts.weighting = weighting;
+            return this;
+        }
+
+        /**
+         * For possible values see AlgorithmOptions.*
+         */
+        public Builder algorithm( String algorithm )
+        {
+            this.opts.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder flagEncoder( FlagEncoder flagEncoder )
+        {
+            this.opts.flagEncoder = flagEncoder;
+            return this;
+        }
+
+        public AlgorithmOptions build()
+        {
+            return opts;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 17d5d064cf..16d7cd0df6 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -17,15 +17,18 @@
  */
 package com.graphhopper.routing;
 
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
 
 /**
  * Implements a single source shortest path algorithm
@@ -35,15 +38,15 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
-    public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting )
+    public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(g, encoder, weighting);
+        super(g, encoder, weighting, tMode);
         initCollections(1000);
     }
 
@@ -59,38 +62,41 @@ public Path calcPath( int from, int to )
         checkAlreadyRun();
         this.to = to;
         currEdge = createEdgeEntry(from, 0);
-        fromMap.put(from, currEdge);
-        return runAlgo();
+        if (!traversalMode.isEdgeBased())
+        {
+            fromMap.put(from, currEdge);
+        }
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitReached() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
             EdgeIterator iter = explorer.setBaseNode(startNode);
             while (iter.next())
             {
-                if (!accept(iter))
-                    continue;
-                // minor speed up
-                if (currEdge.edge == iter.getEdge())
+                if (!accept(iter, currEdge.edge))
                     continue;
 
-                int adjNode = iter.getAdjNode();
-                double tmpWeight = weighting.calcWeight(iter, false) + currEdge.weight;
+                int traversalId = traversalMode.createTraversalId(iter, false);
+                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
+                if (Double.isInfinite(tmpWeight))
+                    continue;
 
-                EdgeEntry nEdge = fromMap.get(adjNode);
+                EdgeEntry nEdge = fromMap.get(traversalId);
                 if (nEdge == null)
                 {
-                    nEdge = new EdgeEntry(iter.getEdge(), adjNode, tmpWeight);
+                    nEdge = new EdgeEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
                     nEdge.parent = currEdge;
-                    fromMap.put(adjNode, nEdge);
+                    fromMap.put(traversalId, nEdge);
                     fromHeap.add(nEdge);
                 } else if (nEdge.weight > tmpWeight)
                 {
@@ -99,19 +105,19 @@ private Path runAlgo()
                     nEdge.weight = tmpWeight;
                     nEdge.parent = currEdge;
                     fromHeap.add(nEdge);
-                }
+                } else
+                    continue;
 
-                updateShortest(nEdge, startNode);
+                updateBestPath(iter, nEdge, traversalId);
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
@@ -123,20 +129,26 @@ protected boolean finished()
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitReached() || !finished())
             return createEmptyPath();
+
         return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
     {
-        return "dijkstra";
+        return visitedNodes;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
deleted file mode 100644
index 2d2e99bc09..0000000000
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.coll.IntDoubleBinHeap;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeWrapper;
-
-/**
- * Calculates shortest path in bidirectional way. Compared to DijkstraBidirectionRef this class is
- * more memory efficient as it does not go the normal Java way via references. In first tests this
- * class saves 30% memory, but as you can see it is more complicated.
- * <p/>
- * Possible improvements
- * <p>
- * 1. use only one EdgeWrapper to save memory. This is not easy if we want it to be as fast as the
- * current solution. But we need to try it out if a forwardSearchBitset.contains(ref) is that
- * expensive
- * <p/>
- * 2. instead of creating references point to the edges itself => we only need an edge+node array
- * and from that can retrieve eg. the distance
- * <p/>
- * @author Peter Karich
- */
-public class DijkstraBidirection extends AbstractBidirAlgo
-{
-    private int currFrom;
-    private double currFromWeight;
-    private int currFromRef;
-    private int currTo;
-    private double currToWeight;
-    private int currToRef;
-    private EdgeWrapper parentRefOther;
-    private IntDoubleBinHeap openSetFrom;
-    private EdgeWrapper parentRefFrom;
-    private IntDoubleBinHeap openSetTo;
-    private EdgeWrapper parentRefTo;
-    private PathBidir nativeBestPath;
-
-    public DijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting weighting )
-    {
-        super(graph, encoder, weighting);
-        initCollections(1000);
-    }
-
-    protected void initCollections( int locs )
-    {
-        openSetFrom = new IntDoubleBinHeap(locs);
-        parentRefFrom = new EdgeWrapper(locs);
-
-        openSetTo = new IntDoubleBinHeap(locs);
-        parentRefTo = new EdgeWrapper(locs);
-    }
-
-    @Override
-    public void initFrom( int from, double dist )
-    {
-        currFrom = from;
-        currFromWeight = dist;
-        currFromRef = parentRefFrom.add(from, dist, EdgeIterator.NO_EDGE);
-        openSetFrom.insert_(currFromWeight, currFromRef);
-        if (currTo >= 0)
-        {
-            parentRefOther = parentRefTo;
-            updateShortest(currFrom, currFromRef, currToWeight);
-        }
-    }
-
-    @Override
-    public void initTo( int to, double dist )
-    {
-        currTo = to;
-        currToWeight = dist;
-        currToRef = parentRefTo.add(to, dist, EdgeIterator.NO_EDGE);
-        openSetTo.insert_(currToWeight, currToRef);
-        if (currFrom >= 0)
-        {
-            parentRefOther = parentRefFrom;
-            updateShortest(currTo, currToRef, currFromWeight);
-        }
-    }
-
-    @Override
-    protected void initPath()
-    {
-        nativeBestPath = new PathBidir(graph, flagEncoder, parentRefFrom, parentRefTo);
-    }
-
-    @Override
-    public Path extractPath()
-    {
-        return nativeBestPath.extract();
-    }
-
-    @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
-    {
-        if (parentRefFrom.isEmpty() || parentRefTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + fromBase + ", to:" + toBase);
-    }
-
-    // http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
-    // a node from overlap may not be on the shortest path!!
-    // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
-    //    search, update shortest =  if df (v) + (v, w) + dr (w) <             
-    @Override
-    protected boolean finished()
-    {
-        if (finishedFrom || finishedTo)
-            return true;
-
-        return currFromWeight + currToWeight >= nativeBestPath.getWeight();
-    }
-
-    void fillEdges( int currNode, double currWeight, int currRef,
-            IntDoubleBinHeap openSet, EdgeWrapper wrapper, EdgeExplorer explorer, boolean reverse )
-    {
-        EdgeIterator iter = explorer.setBaseNode(currNode);
-        while (iter.next())
-        {
-            if (!accept(iter))
-                continue;
-
-            int neighborNode = iter.getAdjNode();
-            // minor speed up
-            int newRef = wrapper.getRef(neighborNode);
-            if (newRef >= 0 && wrapper.getEdgeId(newRef) == iter.getEdge())
-                continue;
-
-            double tmpWeight = weighting.calcWeight(iter, reverse) + currWeight;
-            if (newRef < 0)
-            {
-                newRef = wrapper.add(neighborNode, tmpWeight, iter.getEdge());
-                wrapper.putParent(newRef, currRef);
-                openSet.insert_(tmpWeight, newRef);
-            } else
-            {
-                double weight = wrapper.getWeight(newRef);
-                if (weight > tmpWeight)
-                {
-                    wrapper.putEdgeId(newRef, iter.getEdge());
-                    wrapper.putWeight(newRef, tmpWeight);
-                    wrapper.putParent(newRef, currRef);
-                    openSet.update_(tmpWeight, newRef);
-                }
-            }
-
-            updateShortest(neighborNode, newRef, tmpWeight);
-        }
-    }
-
-    void updateShortest( int nodeId, int ref, double weight )
-    {
-        int otherRef = parentRefOther.getRef(nodeId);
-        if (otherRef < 0)
-            return;
-
-        // update 
-        double newWeight = weight + parentRefOther.getWeight(otherRef);
-        if (newWeight < nativeBestPath.getWeight())
-        {
-            nativeBestPath.switchWrapper = parentRefFrom == parentRefOther;
-            nativeBestPath.fromRef = ref;
-            nativeBestPath.toRef = otherRef;
-            nativeBestPath.setWeight(newWeight);
-        }
-    }
-
-    @Override
-    boolean fillEdgesFrom()
-    {
-        if (openSetFrom.isEmpty())
-            return false;
-
-        currFromRef = openSetFrom.poll_element();
-        currFrom = parentRefFrom.getNode(currFromRef);
-        currFromWeight = parentRefFrom.getWeight(currFromRef);
-
-        parentRefOther = parentRefTo;
-        fillEdges(currFrom, currFromWeight, currFromRef, openSetFrom, parentRefFrom, outEdgeExplorer, false);
-        visitedFromCount++;
-        return true;
-    }
-
-    @Override
-    boolean fillEdgesTo()
-    {
-        if (openSetTo.isEmpty())
-            return false;
-        currToRef = openSetTo.poll_element();
-        currTo = parentRefTo.getNode(currToRef);
-        currToWeight = parentRefTo.getWeight(currToRef);
-
-        parentRefOther = parentRefFrom;
-        fillEdges(currTo, currToWeight, currToRef, openSetTo, parentRefTo, inEdgeExplorer, true);
-        visitedToCount++;
-        return true;
-    }
-
-    @Override
-    public String getName()
-    {
-        return "dijkstraNativebi";
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index c62914e855..d3de4faa19 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -17,15 +17,20 @@
  */
 package com.graphhopper.routing;
 
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 
 /**
  * Calculates best path in bidirectional way.
@@ -45,10 +50,11 @@
     protected EdgeEntry currFrom;
     protected EdgeEntry currTo;
     protected PathBidirRef bestPath;
+    private boolean updateBestPath = true;
 
-    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         initCollections(1000);
     }
 
@@ -65,12 +71,25 @@ protected void initCollections( int nodes )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        bestWeightMapFrom.put(from, currFrom);
         openSetFrom.add(currFrom);
-        if (currTo != null)
+        if (!traversalMode.isEdgeBased())
+        {
+            bestWeightMapFrom.put(from, currFrom);
+            if (currTo != null)
+            {
+                bestWeightMapOther = bestWeightMapTo;
+                updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
+            }
+        } else
         {
-            bestWeightMapOther = bestWeightMapTo;
-            updateShortest(currTo, from);
+            if (currTo != null && currTo.adjNode == from)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
@@ -78,24 +97,41 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        bestWeightMapTo.put(to, currTo);
         openSetTo.add(currTo);
-        if (currFrom != null)
+        if (!traversalMode.isEdgeBased())
         {
-            bestWeightMapOther = bestWeightMapFrom;
-            updateShortest(currFrom, to);
+            bestWeightMapTo.put(to, currTo);
+            if (currFrom != null)
+            {
+                bestWeightMapOther = bestWeightMapFrom;
+                updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
+            }
+        } else
+        {
+            if (currFrom != null && currFrom.adjNode == to)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
     @Override
-    protected void initPath()
+    protected Path createAndInitPath()
     {
         bestPath = new PathBidirRef(graph, flagEncoder);
+        return bestPath;
     }
 
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -107,7 +143,7 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
     }
 
     @Override
-    protected boolean fillEdgesFrom()
+    public boolean fillEdgesFrom()
     {
         if (openSetFrom.isEmpty())
             return false;
@@ -115,19 +151,19 @@ protected boolean fillEdgesFrom()
         currFrom = openSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
         fillEdges(currFrom, openSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
-        visitedFromCount++;
+        visitedCountFrom++;
         return true;
     }
 
     @Override
-    protected boolean fillEdgesTo()
+    public boolean fillEdgesTo()
     {
         if (openSetTo.isEmpty())
             return false;
         currTo = openSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
         fillEdges(currTo, openSetTo, bestWeightMapTo, inEdgeExplorer, true);
-        visitedToCount++;
+        visitedCountTo++;
         return true;
     }
 
@@ -136,7 +172,7 @@ protected boolean fillEdgesTo()
     // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
     //    search, update extractPath =  if df (v) + (v, w) + dr (w) <             
     @Override
-    protected boolean finished()
+    public boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
@@ -144,6 +180,12 @@ protected boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
             TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
@@ -151,66 +193,122 @@ void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
         EdgeIterator iter = explorer.setBaseNode(currNode);
         while (iter.next())
         {
-            if (!accept(iter))
-                continue;
-            // minor speed up
-            if (currEdge.edge == iter.getEdge())
+            if (!accept(iter, currEdge.edge))
                 continue;
 
-            int adjNode = iter.getAdjNode();
-            double tmpWeight = weighting.calcWeight(iter, reverse) + currEdge.weight;
+            int traversalId = traversalMode.createTraversalId(iter, reverse);
+            double tmpWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weight;
+            if (Double.isInfinite(tmpWeight))
+                continue;
 
-            EdgeEntry de = shortestWeightMap.get(adjNode);
-            if (de == null)
+            EdgeEntry ee = shortestWeightMap.get(traversalId);
+            if (ee == null)
             {
-                de = new EdgeEntry(iter.getEdge(), adjNode, tmpWeight);
-                de.parent = currEdge;
-                shortestWeightMap.put(adjNode, de);
-                prioQueue.add(de);
-            } else if (de.weight > tmpWeight)
+                ee = new EdgeEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
+                ee.parent = currEdge;
+                shortestWeightMap.put(traversalId, ee);
+                prioQueue.add(ee);
+            } else if (ee.weight > tmpWeight)
             {
-                prioQueue.remove(de);
-                de.edge = iter.getEdge();
-                de.weight = tmpWeight;
-                de.parent = currEdge;
-                prioQueue.add(de);
-            }
+                prioQueue.remove(ee);
+                ee.edge = iter.getEdge();
+                ee.weight = tmpWeight;
+                ee.parent = currEdge;
+                prioQueue.add(ee);
+            } else
+                continue;
 
-            updateShortest(de, adjNode);
+            if (updateBestPath)
+                updateBestPath(iter, ee, traversalId);
         }
     }
 
     @Override
-    protected void updateShortest( EdgeEntry shortestEE, int currLoc )
+    protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurrent, int traversalId )
     {
-        EdgeEntry entryOther = bestWeightMapOther.get(currLoc);
+        EdgeEntry entryOther = bestWeightMapOther.get(traversalId);
         if (entryOther == null)
             return;
 
+        boolean reverse = bestWeightMapFrom == bestWeightMapOther;
+
         // update 
-        double newShortest = shortestEE.weight + entryOther.weight;
-        if (newShortest < bestPath.getWeight())
+        double newWeight = entryCurrent.weight + entryOther.weight;
+        if (traversalMode.isEdgeBased())
         {
-            bestPath.setSwitchToFrom(bestWeightMapFrom == bestWeightMapOther);
-            bestPath.setEdgeEntry(shortestEE);
-            bestPath.setWeight(newShortest);
-            bestPath.edgeTo = entryOther;
+            if (entryOther.edge != entryCurrent.edge)
+                throw new IllegalStateException("cannot happen for edge based execution of " + getName());
+
+            if (entryOther.adjNode != entryCurrent.adjNode)
+            {
+                // prevents the path to contain the edge at the meeting point twice and subtract the weight (excluding turn weight => no previous edge)
+                entryCurrent = entryCurrent.parent;
+                newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
+            } else
+            {
+                // we detected a u-turn at meeting point, skip if not supported
+                if (!traversalMode.hasUTurnSupport())
+                    return;
+            }
         }
+
+        if (newWeight < bestPath.getWeight())
+        {
+            bestPath.setSwitchToFrom(reverse);
+            bestPath.setEdgeEntry(entryCurrent);
+            bestPath.setWeight(newWeight);
+            bestPath.setEdgeEntryTo(entryOther);
+        }
+    }
+
+    TIntObjectMap<EdgeEntry> getBestFromMap()
+    {
+        return bestWeightMapFrom;
+    }
+
+    TIntObjectMap<EdgeEntry> getBestToMap()
+    {
+        return bestWeightMapTo;
+    }
+
+    void setBestOtherMap( TIntObjectMap<EdgeEntry> other )
+    {
+        bestWeightMapOther = other;
+    }
+
+    void setFromDataStructures( DijkstraBidirectionRef dijkstra )
+    {
+        openSetFrom = dijkstra.openSetFrom;
+        bestWeightMapFrom = dijkstra.bestWeightMapFrom;
+        finishedFrom = dijkstra.finishedFrom;
+        currFrom = dijkstra.currFrom;
+        visitedCountFrom = dijkstra.visitedCountFrom;
+        // outEdgeExplorer
+    }
+
+    void setToDataStructures( DijkstraBidirectionRef dijkstra )
+    {
+        openSetTo = dijkstra.openSetTo;
+        bestWeightMapTo = dijkstra.bestWeightMapTo;
+        finishedTo = dijkstra.finishedTo;
+        currTo = dijkstra.currTo;
+        visitedCountTo = dijkstra.visitedCountTo;
+        // inEdgeExplorer
     }
 
-    public EdgeEntry shortestWeightFrom( int nodeId )
+    void setUpdateBestPath( boolean b )
     {
-        return bestWeightMapFrom.get(nodeId);
+        updateBestPath = b;
     }
 
-    public EdgeEntry shortestWeightTo( int nodeId )
+    void setBestPath( PathBidirRef bestPath )
     {
-        return bestWeightMapTo.get(nodeId);
+        this.bestPath = bestPath;
     }
 
     @Override
     public String getName()
     {
-        return "dijkstrabi";
+        return AlgorithmOptions.DIJKSTRA_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index b6acd5c0bd..d566173302 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -19,22 +19,24 @@
 
 import com.graphhopper.coll.IntDoubleBinHeap;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
 import java.util.Arrays;
 
 /**
- * A simple dijkstra tuned to perform one to many queries more efficient than DijkstraSimple. Old
- * data structures are cache between requests and potentially reused. Useful for CH preparation.
+ * A simple dijkstra tuned to perform one to many queries more efficient than Dijkstra. Old data
+ * structures are cached between requests and potentially reused. Useful for CH preparation.
  * <p/>
  * @author Peter Karich
  */
 public class DijkstraOneToMany extends AbstractRoutingAlgorithm
 {
+    private static final int EMPTY_PARENT = -1;
+    private static final int NOT_FOUND = -1;
     protected double[] weights;
     private final TIntArrayListWithCap changedNodes;
     private int[] parents;
@@ -42,46 +44,34 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
 
-    public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
 
         parents = new int[graph.getNodes()];
-        Arrays.fill(parents, -1);
+        Arrays.fill(parents, EMPTY_PARENT);
 
         edgeIds = new int[graph.getNodes()];
         Arrays.fill(edgeIds, EdgeIterator.NO_EDGE);
 
         weights = new double[graph.getNodes()];
+
         Arrays.fill(weights, Double.MAX_VALUE);
 
         heap = new IntDoubleBinHeap();
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
         return this;
     }
 
-    @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
-    {
-        throw new IllegalStateException("not supported yet");
-    }
-
     @Override
     public Path calcPath( int from, int to )
     {
@@ -97,11 +87,15 @@ public Path extractPath()
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitReached())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
+    /**
+     * Call clear if you have a different start node and need to clear the cache.
+     */
     public DijkstraOneToMany clear()
     {
         doClear = true;
@@ -116,7 +110,7 @@ public double getWeight( int endNode )
     public int findEndNode( int from, int to )
     {
         if (weights.length < 2)
-            return -1;
+            return NOT_FOUND;
 
         this.to = to;
         if (doClear)
@@ -127,7 +121,7 @@ public int findEndNode( int from, int to )
             {
                 int n = changedNodes.get(i);
                 weights[n] = Double.MAX_VALUE;
-                parents[n] = -1;
+                parents[n] = EMPTY_PARENT;
                 edgeIds[n] = EdgeIterator.NO_EDGE;
             }
 
@@ -135,15 +129,21 @@ public int findEndNode( int from, int to )
             changedNodes.reset();
 
             currNode = from;
-            weights[currNode] = 0;
-            changedNodes.add(currNode);
+            if (!traversalMode.isEdgeBased())
+            {
+                weights[currNode] = 0;
+                changedNodes.add(currNode);
+            }
         } else
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode >= 0 || heap.isEmpty())
+            if (parentNode != EMPTY_PARENT && weights[to] < weights[currNode])
                 return to;
 
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+                return NOT_FOUND;
+
             currNode = heap.poll_element();
         }
 
@@ -157,15 +157,17 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                if (!accept(iter))
-                    continue;
                 int adjNode = iter.getAdjNode();
-                // minor speed up
-                if (edgeIds[adjNode] == iter.getEdge())
+                int prevEdgeId = edgeIds[adjNode];
+                if (!accept(iter, prevEdgeId))
                     continue;
 
-                double tmpWeight = weighting.calcWeight(iter, false) + weights[currNode];
-                if (weights[adjNode] == Double.MAX_VALUE)
+                double tmpWeight = weighting.calcWeight(iter, false, prevEdgeId) + weights[currNode];
+                if (Double.isInfinite(tmpWeight))
+                    continue;
+
+                double w = weights[adjNode];
+                if (w == Double.MAX_VALUE)
                 {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
@@ -173,7 +175,7 @@ public int findEndNode( int from, int to )
                     changedNodes.add(adjNode);
                     edgeIds[adjNode] = iter.getEdge();
 
-                } else if (weights[adjNode] > tmpWeight)
+                } else if (w > tmpWeight)
                 {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
@@ -183,8 +185,8 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
-                return -1;
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitReached())
+                return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
             currNode = heap.peek_element();
@@ -198,7 +200,12 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return weights[currNode] >= weightLimit;
     }
 
     public void close()
@@ -218,7 +225,7 @@ public int getVisitedNodes()
     @Override
     public String getName()
     {
-        return "dijkstraOneToMany";
+        return AlgorithmOptions.DIJKSTRA_ONE_TO_MANY;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index edabc66d4f..d919509837 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -34,9 +35,11 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
+    private static final AngleCalc ac = new AngleCalc();
     protected Graph graph;
     private FlagEncoder encoder;
     protected double distance;
@@ -49,8 +52,6 @@
     private int fromNode = -1;
     protected int endNode = -1;
     private TIntList edgeIds;
-    private PointList cachedPoints;
-    private InstructionList cachedWays;
     private double weight;
     private NodeAccess nodeAccess;
 
@@ -111,17 +112,6 @@ private int getFromNode()
         return fromNode;
     }
 
-    /**
-     * @return the last node of this Path.
-     */
-    private int getEndNode()
-    {
-        if (endNode < 0)
-            throw new IllegalStateException("Call extract() before retrieving endNode");
-
-        return endNode;
-    }
-
     public boolean isFound()
     {
         return found;
@@ -177,6 +167,9 @@ public Path setWeight( double w )
      */
     public Path extract()
     {
+        if (isFound())
+            throw new IllegalStateException("Extract can only be called once");
+
         extractSW.start();
         EdgeEntry goalEdge = edgeEntry;
         setEndNode(goalEdge.adjNode);
@@ -223,13 +216,18 @@ protected void processEdge( int edgeId, int adjNode )
      */
     protected long calcMillis( double distance, long flags, boolean revert )
     {
-        // TODO critical
-//        if (revert && !encoder.isBackward(flags)
-//                || !revert && !encoder.isForward(flags))
-//            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
-//                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
+        if (revert && !encoder.isBool(flags, FlagEncoder.K_BACKWARD)
+                || !revert && !encoder.isBool(flags, FlagEncoder.K_FORWARD))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + revert + ", fwd:" + encoder.isBool(flags, FlagEncoder.K_FORWARD) + ", bwd:" + encoder.isBool(flags, FlagEncoder.K_BACKWARD));
 
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
         return (long) (distance * 3600 / speed);
     }
 
@@ -293,7 +291,13 @@ public TIntList calcNodes()
     {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
         if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
+                nodes.add(endNode);
+            }
             return nodes;
+        }
 
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
@@ -311,19 +315,22 @@ public void next( EdgeIteratorState eb, int i )
     /**
      * This method calculated a list of points for this path
      * <p>
-     * @return this path its geometry (cached)
+     * @return this path its geometry
      */
     public PointList calcPoints()
     {
-        if (cachedPoints != null)
-            return cachedPoints;
-
-        cachedPoints = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
+        final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
         if (edgeIds.isEmpty())
-            return cachedPoints;
+        {
+            if (isFound())
+            {
+                points.add(graph.getNodeAccess(), endNode);
+            }
+            return points;
+        }
 
         int tmpNode = getFromNode();
-        cachedPoints.add(nodeAccess, tmpNode);
+        points.add(nodeAccess, tmpNode);
         forEveryEdge(new EdgeVisitor()
         {
             @Override
@@ -332,24 +339,27 @@ public void next( EdgeIteratorState eb, int index )
                 PointList pl = eb.fetchWayGeometry(2);
                 for (int j = 0; j < pl.getSize(); j++)
                 {
-                    cachedPoints.add(pl, j);
+                    points.add(pl, j);
                 }
             }
         });
-        return cachedPoints;
+        return points;
     }
 
     /**
-     * @return the cached list of ways for this path
+     * @return the list of instructions for this path.
      */
-    public InstructionList calcInstructions()
+    public InstructionList calcInstructions( final Translation tr )
     {
-        if (cachedWays != null)
-            return cachedWays;
-
-        cachedWays = new InstructionList(edgeIds.size() / 4);
+        final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
         if (edgeIds.isEmpty())
-            return cachedWays;
+        {
+            if (isFound())
+            {
+                ways.add(new FinishInstruction(nodeAccess, endNode));
+            }
+            return ways;
+        }
 
         final int tmpNode = getFromNode();
         forEveryEdge(new EdgeVisitor()
@@ -376,23 +386,28 @@ public InstructionList calcInstructions()
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private int pavementType;
-            private int wayType;
-            private final AngleCalc2D ac = new AngleCalc2D();
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
+                long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -401,91 +416,160 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    pavementType = encoder.getPavementType(edge.getFlags());
-                    wayType = encoder.getWayType(edge.getFlags());
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, wayType, pavementType, points);
-                    updatePointsAndInstruction(edge, wayGeo);
-                    cachedWays.add(prevInstruction);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                    ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    int tmpPavement = encoder.getPavementType(edge.getFlags());
-                    int tmpWayType = encoder.getWayType(edge.getFlags());
-                    if ((!name.equals(tmpName))
-                            || (pavementType != tmpPavement)
-                            || (wayType != tmpWayType))
+                    if (isRoundabout)
+                        // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                                                annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
+
+                        // Add passed exits to instruction. There is an exit if there are
+                        // at least 2 out-going edges (one continuing in the roundabout)
+                        // This could lead to problems if there are non-complete roundabouts!
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        edgeIter.next();
+                        if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNumber();}
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        pavementType = tmpPavement;
-                        wayType = tmpWayType;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                            .setRadian(deltaInOut)
+                            .setDirOfRotation(deltaOut)
+                            .setExited();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
+                    {
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, wayType, pavementType, points);
-                        cachedWays.add(prevInstruction);
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()) );
+                        ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                }
                 else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong =  wayGeo.getLongitude(beforeLast);
                 }
+                prevInRoundabout = isRoundabout;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
-                    cachedWays.add(new FinishInstruction(adjLat, adjLon,
-                            nodeAccess.is3D() ? nodeAccess.getElevation(adjNode) : 0));
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
+                    ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -494,7 +578,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
@@ -503,37 +587,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
             }
         });
 
-        return cachedWays;
-    }
-
-    public Instruction findInstruction( double lat, double lon )
-    {
-        DistanceCalcEarth distanceCalc = new DistanceCalcEarth();
-
-        double distanceToPath = Double.MAX_VALUE;
-
-        int nextInstrNumber = 0;
-
-        // Search the closest edge to the point
-        for (int i = 0; i < cachedWays.getSize() - 1; i++)
-        {
-            double edgeNodeLat1 = cachedWays.get(i).getPoints().getLatitude(0);
-            double edgeNodeLon1 = cachedWays.get(i).getPoints().getLongitude(0);
-            int node2NOP = cachedWays.get(i + 1).getPoints().getSize();
-            double edgeNodeLat2 = cachedWays.get(i + 1).getPoints().getLatitude(node2NOP - 1);
-            double edgeNodeLon2 = cachedWays.get(i + 1).getPoints().getLongitude(node2NOP - 1);
-
-            //Calculate the distance from the point to the edge
-            double distanceToEdge = distanceCalc.calcNormalizedEdgeDistance(lat, lon, edgeNodeLat1, edgeNodeLon1, edgeNodeLat2, edgeNodeLon2);
-
-            if (distanceToEdge < distanceToPath)
-            {
-                distanceToPath = distanceToEdge;
-                nextInstrNumber = i + 1;
-            }
-        }
-
-        return cachedWays.get(nextInstrNumber);
+        return ways;
     }
 
     @Override
@@ -552,6 +606,6 @@ public String toDetailsString()
 
             str += edgeIds.get(i);
         }
-        return toString() + ", " + str;
+        return toString() + ", found:" + isFound() + ", " + str;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index bd82715004..3ae0152479 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -21,7 +21,6 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.GHUtility;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -66,10 +65,8 @@ public Path extract()
         if (edgeEntry == null || edgeTo == null)
             return this;
 
-        int from = GHUtility.getToNode(graph, edgeEntry.edge, edgeEntry.adjNode);
-        int to = GHUtility.getToNode(graph, edgeTo.edge, edgeTo.adjNode);
-        if (from != to)
-            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString());
+        if (edgeEntry.adjNode != edgeTo.adjNode)
+            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + edgeEntry + ", toEntry:" + edgeTo);
 
         extractSW.start();
         if (switchWrapper)
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
index 207ccc8b5a..6089caa68d 100644
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ b/core/src/main/java/com/graphhopper/routing/PathNative.java
@@ -28,14 +28,14 @@
  */
 public class PathNative extends Path
 {
-    int[] parents;
-    int[] pathEdgeIds;
+    private final int[] parentNodes;
+    private final int[] parentEdges;
 
-    public PathNative( Graph g, FlagEncoder encoder, int[] parents, int[] pathEdgeIds )
+    public PathNative( Graph g, FlagEncoder encoder, int[] parentNodes, int[] parentEdges )
     {
         super(g, encoder);
-        this.parents = parents;
-        this.pathEdgeIds = pathEdgeIds;
+        this.parentNodes = parentNodes;
+        this.parentEdges = parentEdges;
     }
 
     /**
@@ -49,12 +49,12 @@ public Path extract()
 
         while (true)
         {
-            int edgeId = pathEdgeIds[endNode];
+            int edgeId = parentEdges[endNode];
             if (!EdgeIterator.Edge.isValid(edgeId))
                 break;
 
             processEdge(edgeId, endNode);
-            endNode = parents[endNode];
+            endNode = parentNodes[endNode];
         }
         reverseOrder();
         return setFound(true);
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 57b0f12d48..7d794145e1 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -20,7 +20,9 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -55,7 +57,7 @@
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
-     * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap
+     * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
     private List<EdgeIteratorState> virtualEdges;
     private final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
@@ -64,14 +66,32 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = new DistancePlaneProjection();
+    private final DistanceCalc distCalc = Helper.DIST_PLANE;
+    private final GraphExtension wrappedExtension;
 
     public QueryGraph( Graph graph )
     {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getMaxId();
+        mainEdges = graph.getAllEdges().getCount();
+
+        if (mainGraph.getExtension() instanceof TurnCostExtension)
+            wrappedExtension = new QueryGraphTurnExt(this);
+        else
+            wrappedExtension = mainGraph.getExtension();
+    }
+
+    /**
+     * Convenient method to initialize this QueryGraph with the two specified query results.
+     */
+    public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
+    {
+        List<QueryResult> results = new ArrayList<QueryResult>(2);
+        results.add(fromRes);
+        results.add(toRes);
+        lookup(results);
+        return this;
     }
 
     /**
@@ -95,9 +115,13 @@ public void lookup( List<QueryResult> resList )
         {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
             EdgeIteratorState closestEdge = res.getClosestEdge();
-            if (res.getSnappedPosition() == QueryResult.Position.TOWER || closestEdge == null)
+
+            if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            if (closestEdge == null)
+                throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
+
             int base = closestEdge.getBaseNode();
 
             // Force the identical direction for all closest edges. 
@@ -181,18 +205,28 @@ public int compare( QueryResult o1, QueryResult o2 )
                 long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
-                int counter = 0;
                 int virtNodeId = virtualNodes.getSize() + mainNodes;
-                // Create base and adjacent PointLists for all virtual nodes!
+                boolean addedEdges = false;
+
+                // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the                
                 // fullPL into the right pieces.
-                for (QueryResult res : results)
+                for (int counter = 0; counter < results.size(); counter++)
                 {
+                    QueryResult res = results.get(counter);
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
-                    queryResults.add(res);
                     GHPoint3D currSnapped = res.getSnappedPoint();
+
+                    // no new virtual nodes if exactly the same snapped point
+                    if (prevPoint.equals(currSnapped))
+                    {
+                        res.setClosestNode(prevNodeId);
+                        continue;
+                    }
+
+                    queryResults.add(res);
                     createEdges(prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
                             fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
@@ -200,29 +234,64 @@ public int compare( QueryResult o1, QueryResult o2 )
                     virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
                     // add edges again to set adjacent edges for newVirtNodeId
-                    if (counter > 0)
+                    if (addedEdges)
                     {
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                     }
 
+                    addedEdges = true;
                     res.setClosestNode(virtNodeId);
                     prevNodeId = virtNodeId;
                     prevWayIndex = res.getWayIndex() + 1;
                     prevPoint = currSnapped;
-                    counter++;
                     virtNodeId++;
                 }
 
-                // two edges between last result and adjacent node are still missing
-                createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
-                        fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
+                // two edges between last result and adjacent node are still missing if not all points skipped
+                if (addedEdges)
+                    createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
             }
         });
     }
 
+    class QueryGraphTurnExt extends TurnCostExtension
+    {
+        private final TurnCostExtension mainTurnExtension;
+
+        public QueryGraphTurnExt( QueryGraph qGraph )
+        {
+            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
+        }
+
+        @Override
+        public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+        {
+            if (isVirtualNode(nodeVia))
+            {
+                return 0;
+            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo))
+            {
+                if (isVirtualEdge(edgeFrom))
+                {
+                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                if (isVirtualEdge(edgeTo))
+                {
+                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+
+            } else
+            {
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+            }
+        }
+    }
+
     private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
             PointList fullPL, EdgeIteratorState closestEdge,
             int prevNodeId, int nodeId, long reverseFlags )
@@ -239,12 +308,12 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
 
         PointList baseReversePoints = basePoints.clone(true);
         double baseDistance = basePoints.calcDistance(distCalc);
-        int virtEdgeId = virtualEdges.size() + mainEdges;
+        int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
-        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId + VE_BASE, prevNodeId, nodeId,
+        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
                 baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId + VE_BASE_REV, nodeId, prevNodeId,
+        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId, nodeId, prevNodeId,
                 baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
 
         virtualEdges.add(baseEdge);
@@ -263,6 +332,16 @@ public NodeAccess getNodeAccess()
         return nodeAccess;
     }
 
+    private boolean isVirtualNode( int node )
+    {
+        return node >= mainNodes;
+    }
+
+    private boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
     private final NodeAccess nodeAccess = new NodeAccess()
     {
         @Override
@@ -280,7 +359,7 @@ public int getDimension()
         @Override
         public double getLatitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLatitude(nodeId - mainNodes);
             return mainNodeAccess.getLatitude(nodeId);
         }
@@ -288,7 +367,7 @@ public double getLatitude( int nodeId )
         @Override
         public double getLongitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLongitude(nodeId - mainNodes);
             return mainNodeAccess.getLongitude(nodeId);
         }
@@ -296,7 +375,7 @@ public double getLongitude( int nodeId )
         @Override
         public double getElevation( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getElevation(nodeId - mainNodes);
             return mainNodeAccess.getElevation(nodeId);
         }
@@ -304,7 +383,7 @@ public double getElevation( int nodeId )
         @Override
         public int getAdditionalNodeField( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return 0;
             return mainNodeAccess.getAdditionalNodeField(nodeId);
         }
@@ -355,12 +434,12 @@ public BBox getBounds()
     @Override
     public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
     {
-        if (origEdgeId < mainEdges)
+        if (!isVirtualEdge(origEdgeId))
             return mainGraph.getEdgeProps(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
-        if (eis.getAdjNode() == adjNode)
+        if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
 
         // find reverse edge via convention. see virtualEdges comment above
@@ -406,7 +485,9 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
             int virtNode = mainNodes + i;
             node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: a) add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            // replace edge list of neighboring tower nodes: 
+            // add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
             if (towerNode < mainNodes)
@@ -472,7 +553,7 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
 
     void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
     {
-        if (towerNode >= mainNodes)
+        if (isVirtualNode(towerNode))
             throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
@@ -531,360 +612,14 @@ public Graph copyTo( Graph g )
         throw exc();
     }
 
-    private UnsupportedOperationException exc()
+    @Override
+    public GraphExtension getExtension()
     {
-        return new UnsupportedOperationException("QueryGraph cannot be modified.");
+        return wrappedExtension;
     }
 
-    static class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
-    {
-
-        private final List<EdgeIteratorState> edges;
-        private int current;
-
-        public VirtualEdgeIterator( int edgeCount )
-        {
-            edges = new ArrayList<EdgeIteratorState>(edgeCount);
-            reset();
-        }
-
-        void add( EdgeIteratorState edge )
-        {
-            edges.add(edge);
-        }
-
-        EdgeIterator reset()
-        {
-            current = -1;
-            return this;
-        }
-
-        int count()
-        {
-            return edges.size();
-        }
-
-        @Override
-        public boolean next()
-        {
-            current++;
-            return current < edges.size();
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            if (reverse)
-                throw new IllegalStateException("Not yet supported");
-
-            return edges.get(current);
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edges.get(current).getEdge();
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return edges.get(current).getBaseNode();
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return edges.get(current).getAdjNode();
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            return edges.get(current).fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            return edges.get(current).setWayGeometry(list);
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return edges.get(current).getDistance();
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            return edges.get(current).setDistance(dist);
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return edges.get(current).getFlags();
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            return edges.get(current).setFlags(flags);
-        }
-
-        @Override
-        public String getName()
-        {
-            return edges.get(current).getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            return edges.get(current).setName(name);
-        }
-
-        @Override
-        public String toString()
-        {
-            return edges.toString();
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.get(current).getAdditionalField();
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            return edges.get(current).setAdditionalField(value);
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return edges.get(current).copyPropertiesTo(edge);
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            EdgeIteratorState edge = edges.get(current);
-            return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
-        }
-
-        @Override
-        public double getWeight()
-        {
-            // will be called only from PreparationWeighting and if isShortcut is true
-            return ((EdgeSkipIterState) edges.get(current)).getWeight();
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-    }
-
-    /**
-     * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
-     */
-    private static class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState
+    private UnsupportedOperationException exc()
     {
-
-        private final PointList pointList;
-        private final int edgeId;
-        private double distance;
-        private long flags;
-        private String name;
-        private final int baseNode;
-        private final int adjNode;
-
-        public VirtualEdgeIState( int edgeId, int baseNode, int adjNode,
-                double distance, long flags, String name, PointList pointList )
-        {
-            this.edgeId = edgeId;
-            this.baseNode = baseNode;
-            this.adjNode = adjNode;
-            this.distance = distance;
-            this.flags = flags;
-            this.name = name;
-            this.pointList = pointList;
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (pointList.getSize() == 0)
-                return PointList.EMPTY;
-
-            // due to API we need to create a new instance per call!
-            if (mode == 3)
-                return pointList.clone(false);
-            else if (mode == 1)
-                return pointList.copy(0, pointList.getSize() - 1);
-            else if (mode == 2)
-                return pointList.copy(1, pointList.getSize());
-            else if (mode == 0)
-            {
-                if (pointList.getSize() == 1)
-                    return PointList.EMPTY;
-                return pointList.copy(1, pointList.getSize() - 1);
-            }
-
-            throw new UnsupportedOperationException("Illegal mode:" + mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return distance;
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            this.distance = dist;
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return flags;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            this.flags = flags;
-            return this;
-        }
-
-        @Override
-        public String getName()
-        {
-            return name;
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            this.name = name;
-            return this;
-        }
-
-        @Override
-        public String toString()
-        {
-            return baseNode + "->" + adjNode;
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            return false;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public double getWeight()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
+        return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index b1ee8174c5..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.NotThreadSafe;
 
 /**
@@ -36,15 +35,10 @@
     Path calcPath( int from, int to );
 
     /**
-     * Calculates the best path between the specified query results from GPS lookup.
-     * <p/>
-     * Note: The underlying implementation introduces a state of the algorithm and so it is tightly
-     * coupled to the query! Reusing this instance should be done carefully: only from within one
-     * thread and only via this calcPath method.
-     * <p/>
-     * @return the path. Call the method found() to make sure that the path is valid.
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
      */
-    Path calcPath( QueryResult from, QueryResult to );
+    void setWeightLimit( double weight );
 
     /**
      * @return name of this algorithm
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index dcad1dbbb3..58d0f17a3a 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -17,48 +17,12 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
-public class RoutingAlgorithmFactory
+public interface RoutingAlgorithmFactory
 {
-    private String algoStr;
-    private boolean approx;
-
-    /**
-     * @param algo possible values are astar (A* algorithm), astarbi (bidirectional A*) dijkstra
-     * (Dijkstra), dijkstrabi and dijkstraNativebi (a bit faster bidirectional Dijkstra).
-     */
-    public RoutingAlgorithmFactory( String algo, boolean approx )
-    {
-        this.algoStr = algo;
-        this.approx = approx;
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g, FlagEncoder encoder, Weighting weighting )
-    {
-        if ("dijkstrabi".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraBidirectionRef(g, encoder, weighting);
-        } else if ("dijkstraNativebi".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraBidirection(g, encoder, weighting);
-        } else if ("dijkstra".equalsIgnoreCase(algoStr))
-        {
-            return new Dijkstra(g, encoder, weighting);
-        } else if ("astarbi".equalsIgnoreCase(algoStr))
-        {
-            return new AStarBidirection(g, encoder, weighting).setApproximation(approx);
-        } else if ("dijkstraOneToMany".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraOneToMany(g, encoder, weighting);
-        } else
-        {
-            return new AStar(g, encoder, weighting);
-        }
-    }
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );   
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
new file mode 100644
index 0000000000..ae6609148f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -0,0 +1,84 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.BeelineWeightApproximator;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.Helper;
+
+/**
+ * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
+ * <p>
+ * @author Peter Karich
+ */
+public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
+{
+    @Override
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {        
+        AbstractRoutingAlgorithm algo;
+        String algoStr = opts.getAlgorithm();
+        if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.DIJKSTRA.equalsIgnoreCase(algoStr))
+        {
+            return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
+        {
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+                    opts.getTraversalMode());
+            aStarBi.setApproximation(getApproximation(AlgorithmOptions.ASTAR_BI, opts, g.getNodeAccess()));
+            return aStarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
+        {
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            aStar.setApproximation(getApproximation(AlgorithmOptions.ASTAR, opts, g.getNodeAccess()));
+            return aStar;
+        } else
+        {
+            throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
+        }
+
+    }
+
+    private WeightApproximator getApproximation( String prop, AlgorithmOptions opts, NodeAccess na )
+    {
+        String approxAsStr = opts.getHints().get(prop + ".approximation", "BeelineSimplification");
+        if ("BeelineSimplification".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_PLANE);
+            return approx;
+
+        } else if ("BeelineAccurate".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_EARTH);
+            return approx;
+        } else
+        {
+            throw new IllegalArgumentException("Approximation " + approxAsStr + " not found in " + getClass().getName());
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
new file mode 100644
index 0000000000..9552052d02
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+
+/**
+ * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ */
+class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState {
+    private final PointList pointList;
+    private final int edgeId;
+    private double distance;
+    private long flags;
+    private String name;
+    private final int baseNode;
+    private final int adjNode;
+
+    public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+    {
+        this.edgeId = edgeId;
+        this.baseNode = baseNode;
+        this.adjNode = adjNode;
+        this.distance = distance;
+        this.flags = flags;
+        this.name = name;
+        this.pointList = pointList;
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edgeId;
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return baseNode;
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return adjNode;
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        if (pointList.getSize() == 0)
+            return PointList.EMPTY;
+        // due to API we need to create a new instance per call!
+        if (mode == 3)
+            return pointList.clone(false);
+        else if (mode == 1)
+            return pointList.copy(0, pointList.getSize() - 1);
+        else if (mode == 2)
+            return pointList.copy(1, pointList.getSize());
+        else if (mode == 0)
+        {
+            if (pointList.getSize() == 1)
+                return PointList.EMPTY;
+            return pointList.copy(1, pointList.getSize() - 1);
+        }
+        throw new UnsupportedOperationException("Illegal mode:" + mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return distance;
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        this.distance = dist;
+        return this;
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return flags;
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        this.flags = flags;
+        return this;
+    }
+
+    @Override
+    public String getName()
+    {
+        return name;
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        this.name = name;
+        return this;
+    }
+
+    @Override
+    public String toString()
+    {
+        return baseNode + "->" + adjNode;
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        return false;
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public double getWeight()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
new file mode 100644
index 0000000000..22abb0004f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ *
+ * @author Peter Karich
+ */
+class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState {
+    private final List<EdgeIteratorState> edges;
+    private int current;
+
+    public VirtualEdgeIterator( int edgeCount )
+    {
+        edges = new ArrayList<EdgeIteratorState>(edgeCount);
+        reset();
+    }
+
+    void add( EdgeIteratorState edge )
+    {
+        edges.add(edge);
+    }
+
+    EdgeIterator reset()
+    {
+        current = -1;
+        return this;
+    }
+
+    int count()
+    {
+        return edges.size();
+    }
+
+    @Override
+    public boolean next()
+    {
+        current++;
+        return current < edges.size();
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        if (reverse)
+            throw new IllegalStateException("Not yet supported");
+        return edges.get(current);
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edges.get(current).getEdge();
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return edges.get(current).getBaseNode();
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return edges.get(current).getAdjNode();
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        return edges.get(current).fetchWayGeometry(mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        return edges.get(current).setWayGeometry(list);
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return edges.get(current).getDistance();
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        return edges.get(current).setDistance(dist);
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return edges.get(current).getFlags();
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        return edges.get(current).setFlags(flags);
+    }
+
+    @Override
+    public String getName()
+    {
+        return edges.get(current).getName();
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        return edges.get(current).setName(name);
+    }
+
+    @Override
+    public String toString()
+    {
+        return edges.toString();
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        return edges.get(current).getAdditionalField();
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        return edges.get(current).setAdditionalField(value);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        return edges.get(current).copyPropertiesTo(edge);
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        EdgeIteratorState edge = edges.get(current);
+        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+    }
+
+    @Override
+    public double getWeight()
+    {
+        // will be called only from PreparationWeighting and if isShortcut is true
+        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 79e06b5be9..fd3006faf1 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -43,16 +43,16 @@ public double getMinWeight( double distance )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse )
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
     {
-        if (edge instanceof EdgeSkipIterState)
+        if (edgeState instanceof EdgeSkipIterState)
         {
-            EdgeSkipIterState tmp = (EdgeSkipIterState) edge;
+            EdgeSkipIterState tmp = (EdgeSkipIterState) edgeState;
             if (tmp.isShortcut())
                 // if a shortcut is in both directions the weight is identical => no need for 'reverse'
                 return tmp.getWeight();
         }
-        return userWeighting.calcWeight(edge, reverse);
+        return userWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 45421f3373..8a093fb74d 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -18,15 +18,12 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.coll.GHTreeMapComposed;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.AbstractAlgoPreparation;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.LevelEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.routing.AStarBidirection;
-import com.graphhopper.routing.DijkstraBidirectionRef;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.RoutingAlgorithm;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.DAType;
@@ -52,24 +49,25 @@
  * <p/>
  * @author Peter Karich
  */
-public class PrepareContractionHierarchies extends AbstractAlgoPreparation<PrepareContractionHierarchies>
+public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final PreparationWeighting prepareWeighting;
     private final FlagEncoder prepareFlagEncoder;
+    private final TraversalMode traversalMode;
     private EdgeSkipExplorer vehicleInExplorer;
     private EdgeSkipExplorer vehicleOutExplorer;
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
-    private LevelGraph g;
+    private final LevelGraph prepareGraph;
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
     private final DataAccess originalEdges;
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany algo;
+    private DijkstraOneToMany prepareAlgo;
     private boolean removesHigher2LowerEdges = true;
     private long counter;
     private int newShortcuts;
@@ -77,16 +75,19 @@
     private double meanDegree;
     private final Random rand = new Random(123);
     private StopWatch dijkstraSW = new StopWatch();
+    private final StopWatch allSW = new StopWatch();
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
-    private final StopWatch allSW = new StopWatch();
-    private int neighborUpdatePercentage = 10;
-    private int initialCollectionSize = 10000;
+    private int neighborUpdatePercentage = 20;
+    private int initialCollectionSize = 5000;
+    private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
 
-    public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting )
+    public PrepareContractionHierarchies( LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
-        prepareFlagEncoder = encoder;
+        this.prepareGraph = g;
+        this.traversalMode = traversalMode;
+        this.prepareFlagEncoder = encoder;
         long scFwdDir = encoder.setAccess(0, true, false);
 
         // shortcuts store weight in flags where we assume bit 1 and 2 are used for access restriction
@@ -99,13 +100,6 @@ public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting )
         originalEdges.create(1000);
     }
 
-    @Override
-    public PrepareContractionHierarchies setGraph( Graph g )
-    {
-        this.g = (LevelGraph) g;
-        return this;
-    }
-
     /**
      * The higher the values are the longer the preparation takes but the less shortcuts are
      * produced.
@@ -116,7 +110,9 @@ public PrepareContractionHierarchies setGraph( Graph g )
     public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
     {
         if (periodicUpdates < 0)
-            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100]. To disable it use 0");
+            return this;
+        if (periodicUpdates > 100)
+            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100], to disable it use 0");
 
         this.periodicUpdatesPercentage = periodicUpdates;
         return this;
@@ -128,7 +124,10 @@ public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
      */
     public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
     {
-        if (lazyUpdates < 0 || lazyUpdates > 100)
+        if (lazyUpdates < 0)
+            return this;
+
+        if (lazyUpdates > 100)
             throw new IllegalArgumentException("lazyUpdates has to be in [0, 100], to disable it use 0");
 
         this.lastNodesLazyUpdatePercentage = lazyUpdates;
@@ -140,7 +139,10 @@ public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
      */
     public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
     {
-        if (neighborUpdates < 0 || neighborUpdates > 100)
+        if (neighborUpdates < 0)
+            return this;
+
+        if (neighborUpdates > 100)
             throw new IllegalArgumentException("neighborUpdates has to be in [0, 100], to disable it use 0");
 
         this.neighborUpdatePercentage = neighborUpdates;
@@ -153,20 +155,21 @@ public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
      */
     public PrepareContractionHierarchies setLogMessages( double logMessages )
     {
-        this.logMessagesPercentage = logMessages;
+        if (logMessages >= 0)
+            this.logMessagesPercentage = logMessages;
         return this;
     }
 
     /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
+     * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
+     * faster contraction duration. Not yet ready for prime time.
      */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
+    void setNodesContracted( double nodesContracted )
     {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
+        if (nodesContracted > 100)
+            throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
+
+        this.nodesContractedPercentage = nodesContracted;
     }
 
     /**
@@ -179,10 +182,21 @@ public void setInitialCollectionSize( int initialCollectionSize )
         this.initialCollectionSize = initialCollectionSize;
     }
 
+    /**
+     * Disconnect is very important to improve query time and preparation if enabled. It will remove
+     * the edge going from the higher level node to the currently contracted one. But the original
+     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
+     * is true.
+     */
+    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
+    {
+        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
+        return this;
+    }
+
     @Override
-    public PrepareContractionHierarchies doWork()
+    public void doWork()
     {
-        checkGraph();
         if (prepareFlagEncoder == null)
             throw new IllegalStateException("No vehicle encoder set.");
 
@@ -194,18 +208,17 @@ public PrepareContractionHierarchies doWork()
 
         initFromGraph();
         if (!prepareEdges())
-            return this;
+            return;
 
         if (!prepareNodes())
-            return this;
+            return;
 
         contractNodes();
-        return this;
     }
 
     boolean prepareEdges()
     {
-        EdgeIterator iter = g.getAllEdges();
+        EdgeIterator iter = prepareGraph.getAllEdges();
         int c = 0;
         while (iter.next())
         {
@@ -221,7 +234,7 @@ boolean prepareEdges()
     // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = g.getNodes();
+        int len = prepareGraph.getNodes();
 
         for (int node = 0; node < len; node++)
         {
@@ -237,11 +250,11 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = g.getAllEdges().getMaxId() / g.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
-        int logSize = (int) Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
+        long logSize = Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
         if (logMessagesPercentage == 0)
             logSize = Integer.MAX_VALUE;
 
@@ -250,14 +263,18 @@ void contractNodes()
         boolean periodicUpdate = true;
         StopWatch periodSW = new StopWatch();
         int updateCounter = 0;
-        int periodicUpdatesCount = Math.max(10, sortedNodes.getSize() / 100 * periodicUpdatesPercentage);
+        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * periodicUpdatesPercentage));
         if (periodicUpdatesPercentage == 0)
             periodicUpdate = false;
 
         // disable as preparation is slower and query time does not benefit
-        int lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0
-                : sortedNodes.getSize() / 100 * lastNodesLazyUpdatePercentage;
+        long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
+                ? 0l
+                : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+
+        // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
+        // we don't need to wait for all nodes to be contracted
+        long nodesToAvoidContract = Math.round((100 - nodesContractedPercentage) / 100 * sortedNodes.getSize());
         StopWatch lazySW = new StopWatch();
 
         // Recompute priority of uncontracted neighbors.
@@ -268,7 +285,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) g);
+        LevelGraphStorage lg = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -276,10 +293,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = g.getNodes();
+                int len = lg.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (g.getLevel(node) != 0)
+                    if (lg.getLevel(node) != 0)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -293,8 +310,6 @@ void contractNodes()
 
             if (counter % logSize == 0)
             {
-                // TODO necessary?
-                System.gc();
                 logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
                         + ", shortcuts:" + Helper.nf(newShortcuts)
@@ -304,7 +319,7 @@ void contractNodes()
                         + ", t(lazy):" + (int) lazySW.getSeconds()
                         + ", t(neighbor):" + (int) neighborSW.getSeconds()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + algo.getMemoryUsageAsString()
+                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
@@ -330,14 +345,24 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            g.setLevel(polledNode, level);
+            lg.setLevel(polledNode, level);
             level++;
 
+            if (sortedNodes.getSize() < nodesToAvoidContract)
+            {
+                while (!sortedNodes.isEmpty())
+                {
+                    polledNode = sortedNodes.pollKey();
+                    lg.setLevel(polledNode, level);
+                }
+                break;
+            }
+
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (g.getLevel(nn) != 0)
+                if (lg.getLevel(nn) != 0)
                     // already contracted no update necessary
                     continue;
 
@@ -374,12 +399,13 @@ void contractNodes()
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
                 + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage);
+                + ", neighbor:" + neighborUpdatePercentage
+                + ", " + Helper.getMemInfo());
     }
 
     public void close()
     {
-        algo.close();
+        prepareAlgo.close();
         originalEdges.close();
         sortedNodes = null;
         oldPriorities = null;
@@ -464,13 +490,14 @@ public void foundShortcut( int u_fromNode, int w_toNode,
             // then two shortcuts with the same nodes (u<->n.adjNode) exists => check current shortcut against both
             Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
-            {
                 return;
-            } else
+
+            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            if (tmpRetSc != null)
             {
-                Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
-                Shortcut tmpRetSc = shortcuts.get(tmpSc);
-                if (tmpRetSc != null)
+                // overwrite flags only if skipped edges are identical
+                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge())
                 {
                     tmpRetSc.flags = PrepareEncoder.getScDirMask();
                     return;
@@ -552,48 +579,48 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (g.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != 0)
                 continue;
 
             double v_u_dist = incomingEdges.getDistance();
-            double v_u_weight = prepareWeighting.calcWeight(incomingEdges, true);
+            double v_u_weight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
             int skippedEdge1 = incomingEdges.getEdge();
             int incomingEdgeOrigCount = getOrigEdgeCount(skippedEdge1);
             // collect outgoing nodes (goal-nodes) only once
             EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
             // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            algo.clear();
+            prepareAlgo.clear();
             tmpDegreeCounter++;
             while (outgoingEdges.next())
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (g.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
+                if (prepareGraph.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
                 // If we decrease the correct weight we only explore less and introduce more shortcuts.
                 // I.e. no change to accuracy is made.
-                double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false);
+                double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
                 if (Double.isNaN(existingDirectWeight))
                     throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, g) + ", out:" + getCoords(outgoingEdges, g)
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
                             + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
 
                 if (existingDirectWeight >= Double.MAX_VALUE)
                     continue;
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                algo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
                         .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
                 dijkstraCount++;
-                int endNode = algo.findEndNode(u_fromNode, w_toNode);
+                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
                 dijkstraSW.stop();
 
                 // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && algo.getWeight(endNode) <= existingDirectWeight)
+                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
                     // FOUND witness path, so do not add shortcut                
                     continue;
 
@@ -630,17 +657,17 @@ int addShortcuts( int v )
                 if (iter.isShortcut() && iter.getAdjNode() == sc.to
                         && PrepareEncoder.canBeOverwritten(iter.getFlags(), sc.flags))
                 {
-                    if (sc.weight >= prepareWeighting.calcWeight(iter, false))
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE))
                         continue NEXT_SC;
 
                     if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2)
                     {
                         throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, g)
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
                                 + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(g.getEdgeProps(sc.skippedEdge1, sc.from), g)
-                                + ", skippedEdge2: " + getCoords(g.getEdgeProps(sc.skippedEdge2, sc.to), g)
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
@@ -657,7 +684,7 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = g.shortcut(sc.from, sc.to);
+                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
                 edgeState.setWeight(sc.weight);
@@ -681,20 +708,19 @@ String getCoords( EdgeIteratorState e, Graph g )
 
     PrepareContractionHierarchies initFromGraph()
     {
-        checkGraph();
-        vehicleInExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        vehicleAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        vehicleAllTmpExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        calcPrioAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        ignoreNodeFilter = new IgnoreNodeFilter(g);
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph);
         // Use an alternative to PriorityQueue as it has some advantages: 
         //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
         //   2. is slightly faster
         //   but we need additional priorities array to keep old value which is necessary for update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[g.getNodes()];
-        algo = new DijkstraOneToMany(g, prepareFlagEncoder, prepareWeighting);
+        oldPriorities = new int[prepareGraph.getNodes()];
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
         return this;
     }
 
@@ -731,7 +757,7 @@ public final boolean accept( EdgeIteratorState iter )
     private void setOrigEdgeCount( int index, int value )
     {
         long tmp = (long) index * 4;
-        originalEdges.incCapacity(tmp + 4);
+        originalEdges.ensureCapacity(tmp + 4);
         originalEdges.setInt(tmp, value);
     }
 
@@ -739,113 +765,112 @@ private int getOrigEdgeCount( int index )
     {
         // TODO possible memory usage improvement: avoid storing the value 1 for normal edges (does not change)!
         long tmp = (long) index * 4;
-        originalEdges.incCapacity(tmp + 4);
+        originalEdges.ensureCapacity(tmp + 4);
         return originalEdges.getInt(tmp);
     }
 
     @Override
-    public RoutingAlgorithm createAlgo()
+    public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
     {
-        checkGraph();
-        // do not change weight within DijkstraBidirectionRef => so use ShortestWeighting
-        DijkstraBidirectionRef dijkstrabi = new DijkstraBidirectionRef(g, prepareFlagEncoder, prepareWeighting)
+        AbstractBidirAlgo algo;
+        if (AlgorithmOptions.ASTAR_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
-            {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            public boolean finished()
+            AStarBidirection astarBi = new AStarBidirection(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
-
-                // changed also the final finish condition for CH                
-                return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-            }
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-            @Override
-            public void initPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-            }
+                @Override
+                protected boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-            @Override
-            public String getName()
-            {
-                return "dijkstrabiCH";
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                    // changed finish condition for CH
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-        if (!removesHigher2LowerEdges)
-            dijkstrabi.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, flagEncoder);
+                    return bestPath;
+                }
 
-        return dijkstrabi;
-    }
+                @Override
+                public String getName()
+                {
+                    return "astarbiCH";
+                }
 
-    public AStarBidirection createAStar()
-    {
-        checkGraph();
-        AStarBidirection astar = new AStarBidirection(g, prepareFlagEncoder, prepareWeighting)
+                @Override
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+            algo = astarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
+            algo = new DijkstraBidirectionRef(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-            @Override
-            protected boolean finished()
-            {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                public boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-                // changed finish condition for CH
-                double tmpWeight = bestPath.getWeight() * approximationFactor;
-                return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            protected void initPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-            }
+                    // changed also the final finish condition for CH                
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String getName()
-            {
-                return "astarbiCH";
-            }
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, flagEncoder);
+                    return bestPath;
+                }
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                @Override
+                public String getName()
+                {
+                    return "dijkstrabiCH";
+                }
 
-        if (!removesHigher2LowerEdges)
-            astar.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+        } else
+        {
+            throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
+        }
 
-        return astar;
-    }
+        if (!removesHigher2LowerEdges)
+            algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
 
-    private void checkGraph()
-    {
-        if (g == null)
-            throw new NullPointerException("setGraph before usage");
+        return algo;
     }
 
     private static class PriorityNode implements Comparable<PriorityNode>
@@ -926,4 +951,10 @@ public String toString()
             return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
         }
     }
+
+    @Override
+    public String toString()
+    {
+        return "PREPARE|CH|dijkstrabi";
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
index c98da4c65a..3de7c2c89a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
@@ -17,36 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.Graph;
-
 /**
  * @author Peter Karich
  */
-public abstract class AbstractAlgoPreparation<T extends AlgorithmPreparation> implements AlgorithmPreparation
+public abstract class AbstractAlgoPreparation
 {
-    protected Graph _graph;
     private boolean prepared = false;
 
-    @Override
-    public AlgorithmPreparation setGraph( Graph g )
-    {
-        _graph = g;
-        return this;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public T doWork()
+    public void doWork()
     {
         if (prepared)
             throw new IllegalStateException("Call doWork only once!");
 
         prepared = true;
-        // no operation        
-        return (T) this;
     }
 
-    @Override
     public boolean isPrepared()
     {
         return prepared;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 56e85e4d56..f5ccd483c7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -30,7 +30,7 @@
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.util.*;
-import java.util.Collections;
+import java.util.*;
 
 /**
  * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
@@ -49,39 +49,48 @@
     private long nodeBitMask;
     private long wayBitMask;
     private long relBitMask;
-    protected long forwardBit = 0;
-    protected long backwardBit = 0;
-    protected long directionBitMask = 0;
+    protected long forwardBit;
+    protected long backwardBit;
+    protected long directionBitMask;
+    protected long roundaboutBit;
     protected EncodedDoubleValue speedEncoder;
     // bit to signal that way is accepted
-    protected long acceptBit = 0;
-    protected long ferryBit = 0;
+    protected long acceptBit;
+    protected long ferryBit;
 
-    /* Turn Cost Flag Encoder fields */
-    protected int maxCostsBits;
-    protected long costsMask;
-
-    protected long restrictionBit;
-    protected long costShift;
+    private EncodedValue turnCostEncoder;
+    private long turnRestrictionBit;
+    private final int maxTurnCosts;
 
     /* processing properties (to be initialized lazy when needed) */
     protected EdgeExplorer edgeOutExplorer;
     protected EdgeExplorer edgeInExplorer;
 
-    /* restriction definitions */
-    protected String[] restrictions;
-    protected HashSet<String> intended = new HashSet<String>();
-    protected HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected HashSet<String> ferries = new HashSet<String>(5);
-    protected HashSet<String> oneways = new HashSet<String>(5);
-    protected HashSet<String> acceptedRailways = new HashSet<String>(5);
-    protected HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected HashSet<String> potentialBarriers = new HashSet<String>(5);
-    protected int speedBits;
-    protected double speedFactor;
+    /* restriction definitions where order is important */
+    protected final List<String> restrictions = new ArrayList<String>(5);
+    protected final HashSet<String> intendedValues = new HashSet<String>(5);
+    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
+    protected final HashSet<String> ferries = new HashSet<String>(5);
+    protected final HashSet<String> oneways = new HashSet<String>(5);
+    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+    // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
+    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
+    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+    private boolean blockByDefault = true;
+    private boolean blockFords = true;
+    protected final int speedBits;
+    protected final double speedFactor;
 
-    public AbstractFlagEncoder( int speedBits, double speedFactor )
+    /**
+     * @param speedBits specify the number of bits used for speed
+     * @param speedFactor specify the factor to multiple the stored value (can be used to increase
+     * or decrease accuracy of speed value)
+     * @param maxTurnCosts specify the maximum value used for turn costs, if this value is reached a
+     * turn is forbidden and results in costs of positive infinity.
+     */
+    protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
+        this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
         this.speedBits = speedBits;
         this.speedFactor = speedFactor;
         oneways.add("yes");
@@ -93,6 +102,32 @@ public AbstractFlagEncoder( int speedBits, double speedFactor )
         ferries.add("ferry");
 
         acceptedRailways.add("tram");
+        acceptedRailways.add("abandoned");
+        acceptedRailways.add("disused");
+
+        // http://wiki.openstreetmap.org/wiki/Demolished_Railway
+        acceptedRailways.add("dismantled");
+        acceptedRailways.add("razed");
+        acceptedRailways.add("historic");
+        acceptedRailways.add("obliterated");
+    }
+
+    /**
+     * Should potential barriers block when no access limits are given?
+     */
+    public void setBlockByDefault( boolean blockByDefault )
+    {
+        this.blockByDefault = blockByDefault;
+    }
+
+    public void setBlockFords( boolean blockFords )
+    {
+        this.blockFords = blockFords;
+    }
+
+    public boolean isBlockFords()
+    {
+        return blockFords;
     }
 
     /**
@@ -118,17 +153,19 @@ public int defineWayBits( int index, int shift )
             throw new IllegalStateException("You must not register a FlagEncoder (" + toString() + ") twice!");
 
         // define the first 2 speedBits in flags for routing
-        forwardBit = 1 << shift;
-        backwardBit = 2 << shift;
-        directionBitMask = 3 << shift;
+        forwardBit = 1L << shift;
+        backwardBit = 2L << shift;
+        directionBitMask = 3L << shift;
+        shift += 2;
+        roundaboutBit = 1L << shift;
+        shift++;
 
         // define internal flags for parsing
         index *= 2;
-        acceptBit = 1 << index;
-        ferryBit = 2 << index;
+        acceptBit = 1L << index;
+        ferryBit = 2L << index;
 
-        // forward and backward bit:
-        return shift + 2;
+        return shift;
     }
 
     /**
@@ -141,30 +178,6 @@ public int defineRelationBits( int index, int shift )
         return shift;
     }
 
-    /**
-     * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
-     * @param shift bit offset for the first bit used by this encoder
-     * @param numberCostsBits number of bits reserved for storing costs (range of values: [0,
-     * 2^numberCostBits - 1] seconds )
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineTurnBits( int index, int shift, int numberCostsBits )
-    {
-        this.maxCostsBits = numberCostsBits;
-
-        int mask = 0;
-        for (int i = 0; i < this.maxCostsBits; i++)
-        {
-            mask |= (1 << i);
-        }
-        this.costsMask = mask;
-
-        restrictionBit = 1 << shift;
-        costShift = shift + 1;
-        return shift + maxCostsBits + 1;
-    }
-
     /**
      * Analyze the properties of a relation and create the routing flags for the second read step.
      * In the pre-parsing step this method will be called to determine the useful relation tags.
@@ -193,54 +206,48 @@ public int defineTurnBits( int index, int shift, int numberCostsBits )
      */
     public long handleNodeTags( OSMNode node )
     {
-        // movable barriers block if they are not marked as passable
-        if (node.hasTag("barrier", potentialBarriers)
-                && !node.hasTag(restrictions, intended)
-                && !node.hasTag("locked", "no"))
+        // absolute barriers always block
+        if (node.hasTag("barrier", absoluteBarriers))
             return directionBitMask;
 
-        if ((node.hasTag("highway", "ford")
-                || node.hasTag("ford")) && !node.hasTag(restrictions, intended))
-            return directionBitMask;
+        // movable barriers block if they are not marked as passable
+        if (node.hasTag("barrier", potentialBarriers))
+        {
+            boolean locked = false;
+            if (node.hasTag("locked", "yes"))
+                locked = true;
 
-        return 0;
-    }
+            for (String res : restrictions)
+            {
+                if (!locked && node.hasTag(res, intendedValues))
+                    return 0;
 
-    /**
-     * This method is called after determining the node flags and way flags.
-     */
-    public long applyNodeFlags( long wayFlags, long nodeFlags )
-    {
-        return nodeFlags | wayFlags;
-    }
+                if (node.hasTag(res, restrictedValues))
+                    return directionBitMask;
+            }
 
-    @Override
-    public boolean isForward( long flags )
-    {
-        return (flags & forwardBit) != 0;
-    }
+            if (blockByDefault)
+                return directionBitMask;
+        }
 
-    @Override
-    public boolean isBackward( long flags )
-    {
-        return (flags & backwardBit) != 0;
-    }
+        if (blockFords
+                && (node.hasTag("highway", "ford") || node.hasTag("ford"))
+                && !node.hasTag(restrictions, intendedValues))
+            return directionBitMask;
 
-    @Override
-    public int getPavementType( long flags )
-    {
         return 0;
     }
 
     @Override
-    public int getWayType( long flags )
+    public InstructionAnnotation getAnnotation( long flags, Translation tr )
     {
-        return 0;
+        return InstructionAnnotation.EMPTY;
     }
 
     /**
      * Swapping directions means swapping bits which are dependent on the direction of an edge like
-     * the access bits. But also direction dependent speed values should be swapped too.
+     * the access bits. But also direction dependent speed values should be swapped too. Keep in
+     * mind that this method is performance critical!
      */
     public long reverseFlags( long flags )
     {
@@ -263,7 +270,7 @@ public long flagsDefault( boolean forward, boolean backward )
     @Override
     public long setAccess( long flags, boolean forward, boolean backward )
     {
-        return flags | (forward ? forwardBit : 0) | (backward ? backwardBit : 0);
+        return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
     }
 
     @Override
@@ -312,6 +319,23 @@ public double getMaxSpeed()
         return speedEncoder.getMaxValue();
     }
 
+    /**
+     * @return -1 if no maxspeed found
+     */
+    protected double getMaxSpeed( OSMWay way )
+    {
+        double maxSpeed = parseSpeed(way.getTag("maxspeed"));
+        double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
+        if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed))
+            maxSpeed = fwdSpeed;
+
+        double backSpeed = parseSpeed(way.getTag("maxspeed:backward"));
+        if (backSpeed >= 0 && (maxSpeed < 0 || backSpeed < maxSpeed))
+            maxSpeed = backSpeed;
+
+        return maxSpeed;
+    }
+
     @Override
     public int hashCode()
     {
@@ -343,7 +367,7 @@ public boolean equals( Object obj )
     protected static double parseSpeed( String str )
     {
         if (Helper.isEmpty(str))
-            return -1;        
+            return -1;
 
         try
         {
@@ -515,37 +539,234 @@ long getNodeBitMask()
         return nodeBitMask;
     }
 
+    /**
+     * Defines the bits reserved for storing turn restriction and turn cost
+     * <p>
+     * @param shift bit offset for the first bit used by this encoder
+     * @return incremented shift value pointing behind the last used bit
+     */
+    public int defineTurnBits( int index, int shift )
+    {
+        if (maxTurnCosts == 0)
+            return shift;
+
+        // optimization for turn restrictions only 
+        else if (maxTurnCosts == 1)
+        {
+            turnRestrictionBit = 1L << shift;
+            return shift + 1;
+        }
+
+        int turnBits = Helper.countBitValue(maxTurnCosts);
+        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts)
+        {
+            // override to avoid expensive Math.round
+            @Override
+            public final long getValue( long flags )
+            {
+                // find value
+                flags &= mask;
+                flags >>= shift;
+                return flags;
+            }
+        };
+        return shift + turnBits;
+    }
+
     @Override
-    public boolean isTurnRestricted( long flag )
+    public boolean isTurnRestricted( long flags )
     {
-        return (flag & restrictionBit) != 0;
+        if (maxTurnCosts == 0)
+            return false;
+
+        else if (maxTurnCosts == 1)
+            return (flags & turnRestrictionBit) != 0;
+
+        return turnCostEncoder.getValue(flags) == maxTurnCosts;
+    }
+
+    @Override
+    public double getTurnCost( long flags )
+    {
+        if (maxTurnCosts == 0)
+            return 0;
+
+        else if (maxTurnCosts == 1)
+            return ((flags & turnRestrictionBit) == 0) ? 0 : Double.POSITIVE_INFINITY;
+
+        long cost = turnCostEncoder.getValue(flags);
+        if (cost == maxTurnCosts)
+            return Double.POSITIVE_INFINITY;
+
+        return cost;
+    }
+
+    @Override
+    public long getTurnFlags( boolean restricted, double costs )
+    {
+        if (maxTurnCosts == 0)
+            return 0;
+
+        else if (maxTurnCosts == 1)
+        {
+            if (costs != 0)
+                throw new IllegalArgumentException("Only restrictions are supported");
+
+            return restricted ? turnRestrictionBit : 0;
+        }
+
+        if (restricted)
+        {
+            if (costs != 0 || Double.isInfinite(costs))
+                throw new IllegalArgumentException("Restricted turn can only have infinite costs (or use 0)");
+        } else
+        {
+            if (costs >= maxTurnCosts)
+                throw new IllegalArgumentException("Cost is too high. Or specifiy restricted == true");
+        }
+
+        if (costs < 0)
+            throw new IllegalArgumentException("Turn costs cannot be negative");
+
+        if (costs >= maxTurnCosts || restricted)
+            costs = maxTurnCosts;
+        return turnCostEncoder.setValue(0L, (int) costs);
+    }
+
+    protected boolean isFerry( long internalFlags )
+    {
+        return (internalFlags & ferryBit) != 0;
+    }
+
+    protected boolean isAccept( long internalFlags )
+    {
+        return (internalFlags & acceptBit) != 0;
     }
 
     @Override
-    public int getTurnCosts( long flag )
+    public long setBool( long flags, int key, boolean value )
     {
-        long result = (flag >> costShift) & costsMask;
-        if (result >= Math.pow(2, maxCostsBits) || result < 0)
+        switch (key)
         {
-            throw new IllegalStateException("Wrong encoding of turn costs");
+            case K_FORWARD:
+                return value ? flags | forwardBit : flags & ~forwardBit;
+            case K_BACKWARD:
+                return value ? flags | backwardBit : flags & ~backwardBit;
+            case K_ROUNDABOUT:
+                return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+            default:
+                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
         }
-        return Long.valueOf(result).intValue();
     }
 
     @Override
-    public long getTurnFlags( boolean restricted, int costs )
+    public boolean isBool( long flags, int key )
     {
-        costs = Math.min(costs, (int) (Math.pow(2, maxCostsBits) - 1));
-        long encode = costs << costShift;
-        if (restricted)
+        switch (key)
+        {
+            case K_FORWARD:
+                return (flags & forwardBit) != 0;
+            case K_BACKWARD:
+                return (flags & backwardBit) != 0;
+            case K_ROUNDABOUT:
+                return (flags & roundaboutBit) != 0;
+            default:
+                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+    }
+
+    @Override
+    public long setDouble( long flags, int key, double value )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
+    }
+
+    protected static double parseDouble( String str, String key, double defaultD )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultD;
+        return Double.parseDouble(val);
+    }
+
+    protected static long parseLong( String str, String key, long defaultL )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultL;
+        return Long.parseLong(val);
+    }
+
+    protected static boolean parseBoolean( String str, String key, boolean defaultB )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultB;
+        return Boolean.parseBoolean(val);
+    }
+
+    protected static String getStr( String str, String key )
+    {
+        key = key.toLowerCase();
+        for (String s : str.split("\\|"))
         {
-            encode |= restrictionBit;
+            s = s.trim().toLowerCase();
+            int index = s.indexOf("=");
+            if (index < 0)
+                continue;
+
+            String field = s.substring(0, index);
+            String valueStr = s.substring(index + 1);
+            if (key.equals(field))
+                return valueStr;
         }
-        return encode;
+        return "";
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
+    /**
+     * @param force should be false if speed should be changed only if it is bigger than maxspeed.
+     */
+    protected double applyMaxSpeed( OSMWay way, double speed, boolean force )
     {
-        return Collections.emptyList();
+        double maxSpeed = getMaxSpeed(way);
+        // apply only if smaller maxSpeed
+        if (maxSpeed >= 0)
+        {
+            if (force || maxSpeed < speed)
+                return maxSpeed * 0.9;
+        }
+        return speed;
+    }
+
+    protected String getPropertiesString()
+    {
+        return "speedFactor=" + speedFactor + "|speedBits=" + speedBits + "|turnCosts=" + (maxTurnCosts > 0);
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (TurnWeighting.class.isAssignableFrom(feature))
+            return maxTurnCosts > 0;
+
+        return false;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3f256b5280..3a88c83a7b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -24,5 +24,8 @@
  */
 public interface AllEdgesIterator extends EdgeIterator
 {
-    int getMaxId();
+    /**
+     * @return the number of edges
+     */
+    int getCount();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
new file mode 100644
index 0000000000..5df84cfe62
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -0,0 +1,52 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistancePlaneProjection;
+
+/**
+ * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * @author jansoe
+ */
+public class BeelineWeightApproximator implements WeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private DistanceCalc distanceCalc;
+    double toLat, toLon;
+
+    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+        this.nodeAccess = nodeAccess;
+        this.weighting = weighting;
+        setDistanceCalc(new DistanceCalcEarth());
+    }
+
+    public void setGoalNode(int toNode){
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+    }
+
+    @Override
+    public WeightApproximator duplicate() {
+        return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
+    }
+
+
+    @Override
+    public double approximate(int fromNode) {
+
+        double fromLat, fromLon, dist2goal, weight2goal;
+        fromLat  = nodeAccess.getLatitude(fromNode);
+        fromLon = nodeAccess.getLongitude(fromNode);
+        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        weight2goal = weighting.getMinWeight(dist2goal);
+
+        return weight2goal;
+    }
+
+    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
+        this.distanceCalc = distanceCalc;
+        return this;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 20b6dd7809..4fe1beb474 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -20,7 +20,6 @@
 
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import static com.graphhopper.util.Helper.*;
@@ -32,14 +31,28 @@
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder
 {
-    private final DistanceCalc3D distCalc = new DistanceCalc3D();
     private EncodedDoubleValue reverseSpeed;
 
+    public Bike2WeightFlagEncoder()
+    {
+        super();
+    }
+
+    public Bike2WeightFlagEncoder( String propertiesStr )
+    {
+        super(propertiesStr);
+    }
+
+    public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+    }
+
     @Override
     public int defineWayBits( int index, int shift )
     {
         shift = super.defineWayBits(index, shift);
-        reverseSpeed = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, getHighwaySpeed("cycleway"), 30);
+        reverseSpeed = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, getHighwaySpeed("cycleway"), 30);
         shift += reverseSpeed.getBits();
         return shift;
     }
@@ -130,64 +143,83 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
 
         long flags = edge.getFlags();
 
-        // TODO increase speed due to decline only if surface is okay
-        if (way.hasTag("highway", "steps"))
+        if (way.hasTag("tunnel", "yes") || way.hasTag("bridge", "yes") || way.hasTag("highway", "steps"))
         {
-            double speed = getHighwaySpeed("steps");
-            flags = setReverseSpeed(setSpeed(flags, speed), speed);
+            // do not change speed
+            // note: although tunnel can have a difference in elevation it is very unlikely that the elevation data is correct for a tunnel
         } else
         {
+            // Decrease the speed for ele increase (incline), and decrease the speed for ele decrease (decline). The speed-decrease 
+            // has to be bigger (compared to the speed-increase) for the same elevation difference to simulate loosing energy and avoiding hills.
+            // For the reverse speed this has to be the opposite but again keeping in mind that up+down difference.
             double incEleSum = 0, incDist2DSum = 0;
             double decEleSum = 0, decDist2DSum = 0;
-            double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0), prevEle = pl.getElevation(0);
+            // double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
+            double prevEle = pl.getElevation(0);
             double fullDist2D = 0;
-            for (int i = 1; i < pl.size(); i++)
+
+            fullDist2D = edge.getDistance();
+            double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
+            if (eleDelta > 0.1)
+            {
+                incEleSum = eleDelta;
+                incDist2DSum = fullDist2D;
+            } else if (eleDelta < -0.1)
             {
-                double lat = pl.getLatitude(i);
-                double lon = pl.getLongitude(i);
-                double ele = pl.getElevation(i);
-                double eleDelta = ele - prevEle;
-                double dist2D = distCalc.calcDist(prevLat, prevLon, lat, lon);
-                if (eleDelta > 0)
-                {
-                    incEleSum += eleDelta;
-                    incDist2DSum += dist2D;
-                } else
-                {
-                    decEleSum += -eleDelta;
-                    decDist2DSum += dist2D;
-                }
-                fullDist2D += dist2D;
-                prevLat = lat;
-                prevLon = lon;
+                decEleSum = -eleDelta;
+                decDist2DSum = fullDist2D;
             }
 
-            // Calculate slop via tan(asin(height/distance)) but for rather smallish angles tan a=a and sin a=a.
+//            // get a more detailed elevation information, but due to bad SRTM data this does not make sense now.
+//            for (int i = 1; i < pl.size(); i++)
+//            {
+//                double lat = pl.getLatitude(i);
+//                double lon = pl.getLongitude(i);
+//                double ele = pl.getElevation(i);
+//                double eleDelta = ele - prevEle;
+//                double dist2D = distCalc.calcDist(prevLat, prevLon, lat, lon);
+//                if (eleDelta > 0.1)
+//                {
+//                    incEleSum += eleDelta;
+//                    incDist2DSum += dist2D;
+//                } else if (eleDelta < -0.1)
+//                {
+//                    decEleSum += -eleDelta;
+//                    decDist2DSum += dist2D;
+//                }
+//                fullDist2D += dist2D;
+//                prevLat = lat;
+//                prevLon = lon;
+//                prevEle = ele;
+//            }
+            // Calculate slop via tan(asin(height/distance)) but for rather smallish angles where we can assume tan a=a and sin a=a.
             // Then calculate a factor which decreases or increases the speed.
             // Do this via a simple quadratic equation where y(0)=1 and y(0.3)=1/4 for incline and y(0.3)=2 for decline        
-            double fwdInc = incDist2DSum > 1 ? incEleSum / incDist2DSum : 0;
-            double fwdDec = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
+            double fwdIncline = incDist2DSum > 1 ? incEleSum / incDist2DSum : 0;
+            double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
             double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
             double maxSpeed = getHighwaySpeed("cycleway");
-            if (isForward(flags))
+            if (isBool(flags, K_FORWARD))
             {
+                // use weighted mean so that longer incline infuences speed more than shorter
                 double speed = getSpeed(flags);
-                // for decline use a maximum factor between 1 and 2
-                double fwdFaster = keepIn(11.1 * fwdDec * fwdDec + 1, 1, 2);
-                // for ascending use a minimum factor of 1/4 and 1
-                double fwdSlower = keepIn(-8.3 * fwdInc * fwdInc + 1, .25, 1);
-                // use weighted mean so that longer incline infuences speed more            
+                double fwdFaster = 1 + 2 * keepIn(fwdDecline, 0, 0.2);
+                fwdFaster = fwdFaster * fwdFaster;
+                double fwdSlower = 1 - 5 * keepIn(fwdIncline, 0, 0.2);
+                fwdSlower = fwdSlower * fwdSlower;
                 speed = speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum + 1 * restDist2D) / fullDist2D;
-                flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED, maxSpeed));
+                flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
 
-            if (isBackward(flags))
+            if (isBool(flags, K_BACKWARD))
             {
                 double speedReverse = getReverseSpeed(flags);
-                double bwFaster = keepIn(11.1 * fwdInc * fwdInc + 1, 1, 2);
-                double bwSlower = keepIn(-8.3 * fwdDec * fwdDec + 1, 1 / 4, 1);
+                double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
+                bwFaster = bwFaster * bwFaster;
+                double bwSlower = 1 - 5 * keepIn(fwdDecline, 0, 0.2);
+                bwSlower = bwSlower * bwSlower;
                 speedReverse = speedReverse * (bwFaster * incDist2DSum + bwSlower * decDist2DSum + 1 * restDist2D) / fullDist2D;
-                flags = this.setReverseSpeed(flags, keepIn(speedReverse, PUSHING_SECTION_SPEED, maxSpeed));
+                flags = this.setReverseSpeed(flags, keepIn(speedReverse, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
         }
         edge.setFlags(flags);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
new file mode 100644
index 0000000000..084b956469
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -0,0 +1,659 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.reader.OSMRelation;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Translation;
+
+import java.util.*;
+
+/**
+ * Defines bit layout of bicycles (not motorcycles) for speed, access and relations (network).
+ * <p/>
+ * @author Peter Karich
+ * @author Nop
+ * @author ratrun
+ */
+public class BikeCommonFlagEncoder extends AbstractFlagEncoder
+{
+    /**
+     * Reports wether this edge is unpaved.
+     */
+    public static final int K_UNPAVED = 100;
+    protected static final int PUSHING_SECTION_SPEED = 4;
+    private long unpavedBit = 0;
+    // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
+    protected final HashSet<String> pushingSections = new HashSet<String>();
+    protected final HashSet<String> oppositeLanes = new HashSet<String>();
+    protected final Set<String> preferHighwayTags = new HashSet<String>();
+    protected final Set<String> avoidHighwayTags = new HashSet<String>();
+    protected final Set<String> unpavedSurfaceTags = new HashSet<String>();
+    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
+    private final Set<String> roadValues = new HashSet<String>();
+    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
+    // convert network tag of bicycle routes into a way route code
+    private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
+    protected EncodedValue relationCodeEncoder;
+    private EncodedValue wayTypeEncoder;
+    private EncodedValue preferWayEncoder;
+
+    protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        // strict set, usually vehicle and agricultural/forestry are ignored by cyclists
+        restrictions.addAll(Arrays.asList("bicycle", "access"));
+        restrictedValues.add("private");
+        restrictedValues.add("no");
+        restrictedValues.add("restricted");
+
+        intendedValues.add("yes");
+        intendedValues.add("designated");
+        intendedValues.add("official");
+        intendedValues.add("permissive");
+
+        oppositeLanes.add("opposite");
+        oppositeLanes.add("opposite_lane");
+        oppositeLanes.add("opposite_track");
+
+        setBlockByDefault(false);
+        potentialBarriers.add("gate");
+        // potentialBarriers.add("lift_gate");
+        potentialBarriers.add("swing_gate");
+
+        absoluteBarriers.add("kissing_gate");
+        absoluteBarriers.add("stile");
+        absoluteBarriers.add("turnstile");
+
+        unpavedSurfaceTags.add("unpaved");
+        unpavedSurfaceTags.add("gravel");
+        unpavedSurfaceTags.add("ground");
+        unpavedSurfaceTags.add("dirt");
+        unpavedSurfaceTags.add("grass");
+        unpavedSurfaceTags.add("compacted");
+        unpavedSurfaceTags.add("earth");
+        unpavedSurfaceTags.add("fine_gravel");
+        unpavedSurfaceTags.add("grass_paver");
+        unpavedSurfaceTags.add("ice");
+        unpavedSurfaceTags.add("mud");
+        unpavedSurfaceTags.add("salt");
+        unpavedSurfaceTags.add("sand");
+        unpavedSurfaceTags.add("wood");
+
+        roadValues.add("living_street");
+        roadValues.add("road");
+        roadValues.add("service");
+        roadValues.add("unclassified");
+        roadValues.add("residential");
+        roadValues.add("trunk");
+        roadValues.add("trunk_link");
+        roadValues.add("primary");
+        roadValues.add("primary_link");
+        roadValues.add("secondary");
+        roadValues.add("secondary_link");
+        roadValues.add("tertiary");
+        roadValues.add("tertiary_link");
+
+        setTrackTypeSpeed("grade1", 18); // paved
+        setTrackTypeSpeed("grade2", 12); // now unpaved ...
+        setTrackTypeSpeed("grade3", 8);
+        setTrackTypeSpeed("grade4", 6);
+        setTrackTypeSpeed("grade5", 4); // like sand/grass     
+
+        setSurfaceSpeed("paved", 18);
+        setSurfaceSpeed("asphalt", 18);
+        setSurfaceSpeed("cobblestone", 8);
+        setSurfaceSpeed("cobblestone:flattened", 10);
+        setSurfaceSpeed("sett", 10);
+        setSurfaceSpeed("concrete", 18);
+        setSurfaceSpeed("concrete:lanes", 16);
+        setSurfaceSpeed("concrete:plates", 16);
+        setSurfaceSpeed("paving_stones", 12);
+        setSurfaceSpeed("paving_stones:30", 12);
+        setSurfaceSpeed("unpaved", 14);
+        setSurfaceSpeed("compacted", 16);
+        setSurfaceSpeed("dirt", 10);
+        setSurfaceSpeed("earth", 12);
+        setSurfaceSpeed("fine_gravel", 18);
+        setSurfaceSpeed("grass", 8);
+        setSurfaceSpeed("grass_paver", 8);
+        setSurfaceSpeed("gravel", 12);
+        setSurfaceSpeed("ground", 12);
+        setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("metal", 10);
+        setSurfaceSpeed("mud", 10);
+        setSurfaceSpeed("pebblestone", 16);
+        setSurfaceSpeed("salt", 6);
+        setSurfaceSpeed("sand", 6);
+        setSurfaceSpeed("wood", 6);
+
+        setHighwaySpeed("living_street", 6);
+        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
+
+        setHighwaySpeed("cycleway", 18);
+        setHighwaySpeed("path", 18);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("track", 12);
+        setHighwaySpeed("service", 14);
+        setHighwaySpeed("residential", 18);
+        // no other highway applies:
+        setHighwaySpeed("unclassified", 16);
+        // unknown road:
+        setHighwaySpeed("road", 12);
+
+        setHighwaySpeed("trunk", 18);
+        setHighwaySpeed("trunk_link", 18);
+        setHighwaySpeed("primary", 18);
+        setHighwaySpeed("primary_link", 18);
+        setHighwaySpeed("secondary", 18);
+        setHighwaySpeed("secondary_link", 18);
+        setHighwaySpeed("tertiary", 18);
+        setHighwaySpeed("tertiary_link", 18);
+
+        // special case see tests and #191
+        setHighwaySpeed("motorway", 18);
+        setHighwaySpeed("motorway_link", 18);
+        avoidHighwayTags.add("motorway");
+        avoidHighwayTags.add("motorway_link");
+
+        setCyclingNetworkPreference("icn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("ncn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
+        setCyclingNetworkPreference("lcn", PriorityCode.PREFER.getValue());
+        setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+
+        setCyclingNetworkPreference("deprecated", PriorityCode.AVOID_AT_ALL_COSTS.getValue());
+    }
+
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"), 30);
+        shift += speedEncoder.getBits();
+
+        unpavedBit = 1L << shift++;
+        // 2 bits
+        wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3, true);
+        shift += wayTypeEncoder.getBits();
+
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += preferWayEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public int defineRelationBits( int index, int shift )
+    {
+        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        return shift + relationCodeEncoder.getBits();
+    }
+
+    @Override
+    public long acceptWay( OSMWay way )
+    {
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null)
+        {
+            if (way.hasTag("route", ferries))
+            {
+                // if bike is NOT explictly tagged allow bike but only if foot is not specified
+                String bikeTag = way.getTag("bicycle");
+                if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
+                    return acceptBit | ferryBit;
+            }
+            return 0;
+        }
+
+        if (!highwaySpeed.containsKey(highwayValue))
+            return 0;
+
+        // use the way if it is tagged for bikes
+        if (way.hasTag("bicycle", intendedValues))
+            return acceptBit;
+
+        // accept only if explicitely tagged for bike usage
+        if ("motorway".equals(highwayValue) || "motorway_link".equals(highwayValue))
+            return 0;
+
+        if (way.hasTag("motorroad", "yes"))
+            return 0;
+
+        // do not use fords with normal bikes, flagged fords are in included above
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
+            return 0;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues))
+            return 0;
+
+        // do not accept railways (sometimes incorrectly mapped!)
+        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+            return 0;
+
+        String sacScale = way.getTag("sac_scale");
+        if (sacScale != null)
+        {
+            if (!allowedSacScale(sacScale))
+                return 0;
+        }
+        return acceptBit;
+    }
+
+    boolean allowedSacScale( String sacScale )
+    {
+        // other scales are nearly impossible by bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale);
+    }
+
+    @Override
+    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+    {
+        int code = 0;
+        if (relation.hasTag("route", "bicycle"))
+        {
+            Integer val = bikeNetworkToCode.get(relation.getTag("network"));
+            if (val != null)
+                code = val;
+        } else if (relation.hasTag("route", "ferry"))
+        {
+            code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
+        }
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
+        return oldRelationFlags;
+    }
+
+    @Override
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+    {
+        if (!isAccept(allowed))
+            return 0;
+
+        long encoded = 0;
+        if (!isFerry(allowed))
+        {
+            double speed = getSpeed(way);
+            int priorityFromRelation = 0;
+            if (relationFlags != 0)
+                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
+
+            // bike maxspeed handling is different from car as we don't increase speed
+            speed = applyMaxSpeed(way, speed, false);
+            encoded = handleSpeed(way, speed, encoded);
+            encoded = handleBikeRelated(way, encoded, relationFlags > UNCHANGED.getValue());
+
+        } else
+        {
+            encoded = handleFerryTags(way,
+                    highwaySpeed.get("living_street"),
+                    highwaySpeed.get("track"),
+                    highwaySpeed.get("primary"));
+            encoded |= directionBitMask;
+        }
+        return encoded;
+    }
+
+    int getSpeed( OSMWay way )
+    {
+        int speed = PUSHING_SECTION_SPEED;
+        String s = way.getTag("surface");
+        if (!Helper.isEmpty(s))
+        {
+            Integer sInt = surfaceSpeed.get(s);
+            if (sInt != null)
+                speed = sInt;
+        } else
+        {
+            String tt = way.getTag("tracktype");
+            if (!Helper.isEmpty(tt))
+            {
+                Integer tInt = trackTypeSpeed.get(tt);
+                if (tInt != null)
+                    speed = tInt;
+            } else
+            {
+                String highway = way.getTag("highway");
+                if (!Helper.isEmpty(highway))
+                {
+                    Integer hwInt = highwaySpeed.get(highway);
+                    if (hwInt != null)
+                    {
+                        if (way.getTag("service") == null)
+                            speed = hwInt;
+                        else
+                            speed = highwaySpeed.get("living_street");
+                    }
+                }
+            }
+        }
+
+        // Until now we assumed that the way is no pusing section
+        // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
+        if ((speed > PUSHING_SECTION_SPEED)
+                && (!way.hasTag("bicycle", intendedValues) && way.hasTag("highway", pushingSections)))
+        {
+            if (way.hasTag("highway", "steps"))
+                speed = PUSHING_SECTION_SPEED / 2;
+            else
+                speed = PUSHING_SECTION_SPEED;
+        }
+
+        return speed;
+    }
+
+    @Override
+    public InstructionAnnotation getAnnotation( long flags, Translation tr )
+    {
+        int paveType = 0; // paved
+        if (isBool(flags, K_UNPAVED))
+            paveType = 1; // unpaved        
+
+        int wayType = (int) wayTypeEncoder.getValue(flags);
+        String wayName = getWayName(paveType, wayType, tr);
+        return new InstructionAnnotation(0, wayName);
+    }
+
+    String getWayName( int pavementType, int wayType, Translation tr )
+    {
+        String pavementName = "";
+        if (pavementType == 1)
+            pavementName = tr.tr("unpaved");
+
+        String wayTypeName = "";
+        switch (wayType)
+        {
+            case 0:
+                wayTypeName = tr.tr("road");
+                break;
+            case 1:
+                wayTypeName = tr.tr("off_bike");
+                break;
+            case 2:
+                wayTypeName = tr.tr("cycleway");
+                break;
+            case 3:
+                wayTypeName = tr.tr("way");
+                break;
+        }
+
+        if (pavementName.isEmpty())
+        {
+            if (wayType == 0 || wayType == 3)
+                return "";
+            return wayTypeName;
+        } else
+        {
+            if (wayTypeName.isEmpty())
+                return pavementName;
+            else
+                return wayTypeName + ", " + pavementName;
+        }
+    }
+
+    /**
+     * In this method we prefer cycleways or roads with designated bike access and avoid big roads
+     * or roads with trams or pedestrian.
+     * <p>
+     * @return new priority based on priorityFromRelation and on the tags in OSMWay.
+     */
+    protected int handlePriority( OSMWay way, int priorityFromRelation )
+    {
+        TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
+        if (priorityFromRelation == 0)
+            weightToPrioMap.put(0d, UNCHANGED.getValue());
+        else
+            weightToPrioMap.put(110d, priorityFromRelation);
+
+        collect(way, weightToPrioMap);
+
+        // pick priority with biggest order value
+        return weightToPrioMap.lastEntry().getValue();
+    }
+
+    /**
+     * @param weightToPrioMap associate a weight with every priority. This sorted map allows
+     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     */
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        String service = way.getTag("service");
+        String highway = way.getTag("highway");
+        if (way.hasTag("bicycle", "designated"))
+            weightToPrioMap.put(100d, PREFER.getValue());
+        if ("cycleway".equals(highway))
+            weightToPrioMap.put(100d, VERY_NICE.getValue());
+
+        double maxSpeed = getMaxSpeed(way);
+        if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
+        {
+            weightToPrioMap.put(40d, PREFER.getValue());
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(40d, UNCHANGED.getValue());
+        }
+
+        if (pushingSections.contains(highway) || "parking_aisle".equals(service))
+            weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
+        {
+            weightToPrioMap.put(50d, REACH_DEST.getValue());
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+        }
+
+        if (way.hasTag("railway", "tram"))
+            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+    }
+
+    /**
+     * Handle surface and wayType encoding
+     */
+    long handleBikeRelated( OSMWay way, long encoded, boolean partOfCycleRelation )
+    {
+        String surfaceTag = way.getTag("surface");
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+
+        // Populate bits at wayTypeMask with wayType            
+        WayType wayType = WayType.OTHER_SMALL_WAY;
+        boolean isPusingSection = isPushingSection(way);
+        if (isPusingSection && !partOfCycleRelation || "steps".equals(highway))
+            wayType = WayType.PUSHING_SECTION;
+
+        if ("track".equals(highway) && (trackType == null || !"grade1".equals(trackType))
+                || "path".equals(highway) && surfaceTag == null
+                || unpavedSurfaceTags.contains(surfaceTag))
+        {
+            encoded = setBool(encoded, K_UNPAVED, true);
+        }
+
+        if (way.hasTag("bicycle", intendedValues))
+        {
+            if (isPusingSection && !way.hasTag("bicycle", "designated"))
+                wayType = WayType.OTHER_SMALL_WAY;
+            else
+                wayType = WayType.CYCLEWAY;
+        } else if ("cycleway".equals(highway))
+            wayType = WayType.CYCLEWAY;
+        else if (roadValues.contains(highway))
+            wayType = WayType.ROAD;
+
+        return wayTypeEncoder.setValue(encoded, wayType.getValue());
+    }
+
+    @Override
+    public long setBool( long flags, int key, boolean value )
+    {
+        switch (key)
+        {
+            case K_UNPAVED:
+                return value ? flags | unpavedBit : flags & ~unpavedBit;
+            default:
+                return super.setBool(flags, key, value);
+        }
+    }
+
+    @Override
+    public boolean isBool( long flags, int key )
+    {
+        switch (key)
+        {
+            case K_UNPAVED:
+                return (flags & unpavedBit) != 0;
+            default:
+                return super.isBool(flags, key);
+        }
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    boolean isPushingSection( OSMWay way )
+    {
+        return way.hasTag("highway", pushingSections);
+    }
+
+    protected long handleSpeed( OSMWay way, double speed, long encoded )
+    {
+        encoded = setSpeed(encoded, speed);
+
+        // handle oneways
+        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+                && !way.hasTag("oneway:bicycle", "no")
+                && !way.hasTag("cycleway", oppositeLanes))
+        {
+            if (way.hasTag("oneway", "-1"))
+                encoded |= backwardBit;
+            else
+                encoded |= forwardBit;
+
+        } else
+        {
+            encoded |= directionBitMask;
+        }
+        return encoded;
+    }
+
+    private enum WayType
+    {
+        ROAD(0),
+        PUSHING_SECTION(1),
+        CYCLEWAY(2),
+        OTHER_SMALL_WAY(3);
+
+        private final int value;
+
+        private WayType( int value )
+        {
+            this.value = value;
+        }
+
+        public int getValue()
+        {
+            return value;
+        }
+    };
+
+    protected void setHighwaySpeed( String highway, int speed )
+    {
+        highwaySpeed.put(highway, speed);
+    }
+
+    protected int getHighwaySpeed( String key )
+    {
+        return highwaySpeed.get(key);
+    }
+
+    void setTrackTypeSpeed( String tracktype, int speed )
+    {
+        trackTypeSpeed.put(tracktype, speed);
+    }
+
+    void setSurfaceSpeed( String surface, int speed )
+    {
+        surfaceSpeed.put(surface, speed);
+    }
+
+    void setCyclingNetworkPreference( String network, int code )
+    {
+        bikeNetworkToCode.put(network, code);
+    }
+
+    void addPushingSection( String highway )
+    {
+        pushingSections.add(highway);
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java
deleted file mode 100644
index 724246997d..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java
+++ /dev/null
@@ -1,477 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.util.Helper;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Defines bit layout of bicycles (not motorbikes) for speed, access and relations (network).
- * <p/>
- * @author Peter Karich
- * @author Nop
- * @author ratrun
- */
-public class BikeFlagCommonEncoder extends AbstractFlagEncoder
-{
-    protected static final int DEFAULT_REL_CODE = 4;
-    protected static final int PUSHING_SECTION_SPEED = 4;
-    // private int safeWayBit = 0;
-    private int unpavedBit = 0;
-    // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
-    private final HashSet<String> pushingSections = new HashSet<String>();
-    protected final HashSet<String> oppositeLanes = new HashSet<String>();
-    private final Set<String> unpavedSurfaceTags = new HashSet<String>();
-    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
-    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
-    private final Set<String> roadValues = new HashSet<String>();
-    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
-    //Convert network tag of bicycle routes into a way route code stored in the wayMAP
-    private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
-    protected EncodedValue relationCodeEncoder;
-    private EncodedValue wayTypeEncoder;
-
-    /**
-     * Should be only instantied via EncodingManager
-     */
-    protected BikeFlagCommonEncoder()
-    {
-        this(4, 2);
-    }
-
-    protected BikeFlagCommonEncoder( int speedBits, double speedFactor )
-    {
-        super(speedBits, speedFactor);
-        // strict set, usually vehicle and agricultural/forestry are ignored by cyclists
-        restrictions = new String[]
-        {
-            "bicycle", "access"
-        };
-        restrictedValues.add("private");
-        restrictedValues.add("no");
-        restrictedValues.add("restricted");
-
-        intended.add("yes");
-        intended.add("designated");
-        intended.add("official");
-        intended.add("permissive");
-
-        oppositeLanes.add("opposite");
-        oppositeLanes.add("opposite_lane");
-        oppositeLanes.add("opposite_track");
-
-        // With a bike one usually can pass all those barriers:
-        // potentialBarriers.add("gate");
-        // potentialBarriers.add("lift_gate");
-        // potentialBarriers.add("swing_gate");
-        // potentialBarriers.add("cycle_barrier");
-        // potentialBarriers.add("block");
-        absoluteBarriers.add("kissing_gate");
-        absoluteBarriers.add("stile");
-        absoluteBarriers.add("turnstile");
-        // very dangerous
-        // acceptedRailways.remove("tram");
-
-        unpavedSurfaceTags.add("unpaved");
-        unpavedSurfaceTags.add("gravel");
-        unpavedSurfaceTags.add("ground");
-        unpavedSurfaceTags.add("dirt");
-        unpavedSurfaceTags.add("grass");
-        unpavedSurfaceTags.add("compacted");
-        unpavedSurfaceTags.add("earth");
-        unpavedSurfaceTags.add("fine_gravel");
-        unpavedSurfaceTags.add("grass_paver");
-        unpavedSurfaceTags.add("ice");
-        unpavedSurfaceTags.add("mud");
-        unpavedSurfaceTags.add("salt");
-        unpavedSurfaceTags.add("sand");
-        unpavedSurfaceTags.add("wood");
-
-        roadValues.add("living_street");
-        roadValues.add("road");
-        roadValues.add("service");
-        roadValues.add("unclassified");
-        roadValues.add("residential");
-        roadValues.add("trunk");
-        roadValues.add("trunk_link");
-        roadValues.add("primary");
-        roadValues.add("primary_link");
-        roadValues.add("secondary");
-        roadValues.add("secondary_link");
-        roadValues.add("tertiary");
-        roadValues.add("tertiary_link");
-
-        setCyclingNetworkPreference("deprecated", RelationMapCode.AVOID_AT_ALL_COSTS.getValue());
-    }
-
-    @Override
-    public int defineWayBits( int index, int shift )
-    {
-        // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"), 30);
-        shift += speedBits;
-
-        //safeWayBit = 1 << shift++;
-        unpavedBit = 1 << shift++;
-        // 2 bits
-        wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3);
-        return shift + 2;
-    }
-
-    @Override
-    public int defineRelationBits( int index, int shift )
-    {
-        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
-        return shift + 3;
-    }
-
-    @Override
-    public long acceptWay( OSMWay way )
-    {
-        String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
-                // if bike is NOT explictly tagged allow bike but only if foot is not specified
-                String bikeTag = way.getTag("bicycle");
-                if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
-                    return acceptBit | ferryBit;
-            }
-            return 0;
-        }
-
-        if (!highwaySpeed.containsKey(highwayValue))
-            return 0;
-
-        // use the way if it is tagged for bikes
-        if (way.hasTag("bicycle", intended))
-            return acceptBit;
-
-        if (way.hasTag("motorroad", "yes"))
-            return 0;
-
-        // do not use fords with normal bikes, flagged fords are in included above
-        if (way.hasTag("highway", "ford") || way.hasTag("ford"))
-            return 0;
-
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues))
-            return 0;
-
-        // do not accept railways (sometimes incorrectly mapped!)
-        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
-            return 0;
-
-        return acceptBit;
-    }
-
-    @Override
-    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
-    {
-        int code = RelationMapCode.UNCHANGED.getValue();
-        if (relation.hasTag("route", "bicycle"))
-        {
-            Integer val = bikeNetworkToCode.get(relation.getTag("network"));
-            if (val != null)
-                code = val;
-        }
-        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
-        if (oldCode < code)
-            return relationCodeEncoder.setValue(0, code);
-        return oldRelationFlags;
-    }
-
-    // In case that the way belongs to a relation for which we do have a relation triggered weight change.    
-    // FIXME: Re-write in case that there is a more generic way to influence the weighting (issue #124).
-    // Here we boost or reduce the speed according to the relationWeightCode:
-    int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
-    {
-        int speed;
-        if (highwaySpeed < 15)
-            // We know that our way belongs to a cycle route, so we are optimistic and assume 15km/h minimum,
-            // irrespective of the tracktype and surface
-            speed = 15;
-        else
-            speed = highwaySpeed;
-        // Add or remove 4km/h per every relation weight boost point
-        return speed + 4 * (relationCode - DEFAULT_REL_CODE);
-    }
-
-    @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
-    {
-        if ((allowed & acceptBit) == 0)
-            return 0;
-
-        long encoded;
-        if ((allowed & ferryBit) == 0)
-        {
-            // set speed
-            // FIXME Rewrite necessary after decision #124 for other weighting than speed!
-            // Currently there is only speed, so we increase it.
-            double speed;
-            if (relationFlags == 0)
-            {
-                // In case that the way does not belong to a relation
-                speed = getSpeed(way);
-            } else
-            {
-                speed = relationWeightCodeToSpeed(getSpeed(way), (int) relationCodeEncoder.getValue(relationFlags));
-            }
-
-            encoded = handleSpeed(way, speed, 0);
-            encoded = handleBikeRelated(way, encoded);
-
-        } else
-        {
-            encoded = handleFerryTags(way,
-                    highwaySpeed.get("living_street"),
-                    highwaySpeed.get("track"),
-                    highwaySpeed.get("primary"));
-            encoded |= directionBitMask;
-        }
-        return encoded;
-    }
-
-    @Override
-    public long handleNodeTags( OSMNode node )
-    {
-        // absolute barriers always block
-        if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
-
-        return super.handleNodeTags(node);
-    }
-
-    int getSpeed( OSMWay way )
-    {
-        int speed = PUSHING_SECTION_SPEED;
-
-        String s = way.getTag("surface");
-        if (!Helper.isEmpty(s))
-        {
-            Integer sInt = surfaceSpeed.get(s);
-            if (sInt != null)
-                speed = sInt;
-        } else
-        {
-            String tt = way.getTag("tracktype");
-            if (!Helper.isEmpty(tt))
-            {
-                Integer tInt = trackTypeSpeed.get(tt);
-                if (tInt != null)
-                    speed = tInt;
-            } else
-            {
-                String highway = way.getTag("highway");
-                if (!Helper.isEmpty(highway))
-                {
-                    Integer hwInt = highwaySpeed.get(highway);
-                    if (hwInt != null)
-                    {
-                        if (way.getTag("service") == null)
-                            speed = hwInt;
-                        else
-                            speed = highwaySpeed.get("living_street");
-                    }
-                }
-            }
-        }
-
-        // Until now we assumed that the way is no pusing section
-        // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
-        if ((speed > PUSHING_SECTION_SPEED)
-                && (!way.hasTag("bicycle", intended) && way.hasTag("highway", pushingSections)))
-        {
-            if (way.hasTag("highway", "steps"))
-                speed = PUSHING_SECTION_SPEED / 2;
-            else
-                speed = PUSHING_SECTION_SPEED;
-        }
-
-        return speed;
-    }
-
-    @Override
-    public int getPavementType( long flags )
-    {
-        if ((flags & unpavedBit) != 0)
-            return 1; // unpaved
-        else
-            return 0; // paved
-    }
-
-    @Override
-    public int getWayType( long flags )
-    {
-        return (int) wayTypeEncoder.getValue(flags);
-    }
-
-    protected long handleBikeRelated( OSMWay way, long encoded )
-    {
-        String highway = way.getTag("highway");
-
-        /*            
-         // mark safe ways or ways with cycle lanes
-         if (SAFE_HIGHWAY_TAGS.contains(highway) || way.hasTag("cycleway"))
-         {
-         encoded |= safeWayBit;
-         }
-         */
-        // mark unpaved bit
-        String surfaceTag = way.getTag("surface");
-        String trackType = way.getTag("tracktype");
-        if ("track".equals(highway) && trackType == null
-                || ("track".equals(highway) && !"grade1".equals(trackType))
-                || (surfaceTag == null && way.hasTag("highway", "path"))
-                || unpavedSurfaceTags.contains(surfaceTag))
-        {
-            encoded |= unpavedBit;
-        }
-
-        // Populate bits at wayTypeMask with wayType            
-        WayType ourWayType = WayType.OTHER_SMALL_WAY;
-        if (way.hasTag("highway", pushingSections))
-            ourWayType = WayType.PUSHING_SECTION;
-        if ((way.hasTag("bicycle", intended) && way.hasTag("highway", pushingSections))
-                || ("cycleway".equals(way.getTag("highway"))))
-            ourWayType = WayType.CYCLEWAY;
-        if (way.hasTag("highway", roadValues))
-            ourWayType = WayType.ROAD;
-
-        return wayTypeEncoder.setValue(encoded, ourWayType.getValue());
-    }
-
-    protected long handleSpeed( OSMWay way, double speed, long encoded )
-    {
-        encoded = setSpeed(0, speed);
-
-        // handle oneways
-        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
-                && !way.hasTag("oneway:bicycle", "no")
-                && !way.hasTag("cycleway", oppositeLanes))
-        {
-            if (way.hasTag("oneway", "-1"))
-                encoded |= backwardBit;
-            else
-                encoded |= forwardBit;
-
-        } else
-        {
-            encoded |= directionBitMask;
-        }
-        return encoded;
-    }
-
-    public enum RelationMapCode
-    {
-        /* Inspired by http://wiki.openstreetmap.org/wiki/Class:bicycle
-         "-3" = Avoid at all cost. 
-         "-2" = Only use to reach your destination, not well suited. 
-         "-1" = Better take another way 
-         "0" = as well as other ways around. 
-         Try to to avoid using 0 but decide on -1 or +1. 
-         class:bicycle shall only be used as an additional key. 
-         "1" = Prefer 
-         "2" = Very Nice way to cycle 
-         "3" = This way is so nice, it pays out to make a detour also if this means taking 
-         many unsuitable ways to get here. Outstanding for its intended usage class.
-         */
-        //We can't store negative numbers into our map, therefore we add 
-        //unspecifiedRelationWeight=4 to the schema from above
-        AVOID_AT_ALL_COSTS(1),
-        REACH_DEST(2),
-        AVOID_IF_POSSIBLE(3),
-        UNCHANGED(DEFAULT_REL_CODE),
-        PREFER(5),
-        VERY_NICE(6),
-        OUTSTANDING_NICE(7);
-
-        private final int value;
-
-        private RelationMapCode( int value )
-        {
-            this.value = value;
-        }
-
-        public int getValue()
-        {
-            return value;
-        }
-    };
-
-    private enum WayType
-    {
-        ROAD(0),
-        PUSHING_SECTION(1),
-        CYCLEWAY(2),
-        OTHER_SMALL_WAY(3);
-
-        private final int value;
-
-        private WayType( int value )
-        {
-            this.value = value;
-        }
-
-        public int getValue()
-        {
-            return value;
-        }
-
-    };
-
-    protected void setTrackTypeSpeed( String tracktype, int speed )
-    {
-        trackTypeSpeed.put(tracktype, speed);
-    }
-
-    protected void setSurfaceSpeed( String surface, int speed )
-    {
-        surfaceSpeed.put(surface, speed);
-    }
-
-    protected void setHighwaySpeed( String highway, int speed )
-    {
-        highwaySpeed.put(highway, speed);
-    }
-
-    protected int getHighwaySpeed( String key )
-    {
-        return highwaySpeed.get(key);
-    }
-
-    protected void setCyclingNetworkPreference( String network, int code )
-    {
-        bikeNetworkToCode.put(network, code);
-    }
-
-    protected void setPushingSection( String highway )
-    {
-        pushingSections.add(highway);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index d5a1fa75d2..32dc4a7a49 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -17,81 +17,58 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMWay;
+
 /**
  * Specifies the settings for cycletouring/trekking
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class BikeFlagEncoder extends BikeFlagCommonEncoder
+public class BikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    BikeFlagEncoder()
+    public BikeFlagEncoder()
     {
-        setTrackTypeSpeed("grade1", 20); // paved
-        setTrackTypeSpeed("grade2", 12); // now unpaved ...
-        setTrackTypeSpeed("grade3", 12);
-        setTrackTypeSpeed("grade4", 10);
-        setTrackTypeSpeed("grade5", 8); // like sand/grass     
-
-        setSurfaceSpeed("paved", 20);
-        setSurfaceSpeed("asphalt", 20);
-        setSurfaceSpeed("cobblestone", 10);
-        setSurfaceSpeed("cobblestone:flattened", 10);
-        setSurfaceSpeed("sett", 8);
-        setSurfaceSpeed("concrete", 20);
-        setSurfaceSpeed("concrete:lanes", 16);
-        setSurfaceSpeed("concrete:plates", 16);
-        setSurfaceSpeed("paving_stones", 10);
-        setSurfaceSpeed("paving_stones:30", 10);
-        setSurfaceSpeed("unpaved", 16);
-        setSurfaceSpeed("compacted", 18);
-        setSurfaceSpeed("dirt", 10);
-        setSurfaceSpeed("earth", 10);
-        setSurfaceSpeed("fine_gravel", 18);
-        setSurfaceSpeed("grass", 8);
-        setSurfaceSpeed("grass_paver", 8);
-        setSurfaceSpeed("gravel", 12);
-        setSurfaceSpeed("ground", 12);
-        setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
-        setSurfaceSpeed("metal", 10);
-        setSurfaceSpeed("mud", 10);
-        setSurfaceSpeed("pebblestone", 16);
-        setSurfaceSpeed("salt", 6);
-        setSurfaceSpeed("sand", 8);
-        setSurfaceSpeed("wood", 10);
+        this(4, 2, 0);
+    }
 
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
+    public BikeFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
 
-        setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 18);
-        setHighwaySpeed("footway", 18);
-        setHighwaySpeed("pedestrian", 16);
-        setHighwaySpeed("road", 10);
-        setHighwaySpeed("track", 20);
-        setHighwaySpeed("service", 20);
-        setHighwaySpeed("unclassified", 20);
-        setHighwaySpeed("residential", 20);
+    public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        addPushingSection("path");
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
 
-        setHighwaySpeed("trunk", 18);
-        setHighwaySpeed("trunk_link", 18);
-        setHighwaySpeed("primary", 18);
-        setHighwaySpeed("primary_link", 15);
-        setHighwaySpeed("secondary", 16);
-        setHighwaySpeed("secondary_link", 16);
-        setHighwaySpeed("tertiary", 18);
-        setHighwaySpeed("tertiary_link", 18);
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
 
-        setPushingSection("path");
-        setPushingSection("track");
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
+        // preferHighwayTags.add("road");
+        preferHighwayTags.add("service");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+        preferHighwayTags.add("unclassified");
+    }
 
-        setCyclingNetworkPreference("icn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("ncn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("rcn", RelationMapCode.VERY_NICE.getValue());
-        setCyclingNetworkPreference("lcn", RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("mtb", RelationMapCode.UNCHANGED.getValue());
+    @Override
+    boolean isPushingSection( OSMWay way )
+    {
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+        return way.hasTag("highway", pushingSections)
+                || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 9e6ea6ddab..f2ca16fcbe 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -17,19 +17,15 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.Helper;
+import java.util.*;
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
@@ -51,26 +47,31 @@
     /**
      * Should be only instantied via EncodingManager
      */
-    protected CarFlagEncoder()
+    public CarFlagEncoder()
     {
-        this(5, 5);
+        this(5, 5, 0);
     }
 
-    protected CarFlagEncoder( int speedBits, double speedFactor )
+    public CarFlagEncoder( String propertiesStr )
     {
-        super(speedBits, speedFactor);
-        restrictions = new String[]
-        {
-            "motorcar", "motor_vehicle", "vehicle", "access"
-        };
+        this((int) parseLong(propertiesStr, "speedBits", 5),
+                parseDouble(propertiesStr, "speedFactor", 5),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
         restrictedValues.add("private");
         restrictedValues.add("agricultural");
         restrictedValues.add("forestry");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("delivery");
 
-        intended.add("yes");
-        intended.add("permissive");
+        intendedValues.add("yes");
+        intendedValues.add("permissive");
 
         potentialBarriers.add("gate");
         potentialBarriers.add("lift_gate");
@@ -81,6 +82,7 @@ protected CarFlagEncoder( int speedBits, double speedFactor )
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
         absoluteBarriers.add("cycle_barrier");
+        absoluteBarriers.add("motorcycle_barrier");
         absoluteBarriers.add("block");
 
         trackTypeSpeedMap.put("grade1", 20); // paved
@@ -101,6 +103,7 @@ protected CarFlagEncoder( int speedBits, double speedFactor )
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
+        defaultSpeedMap.put("motorroad", 90);
         // bundesstrae
         defaultSpeedMap.put("trunk", 70);
         defaultSpeedMap.put("trunk_link", 65);
@@ -125,7 +128,7 @@ protected CarFlagEncoder( int speedBits, double speedFactor )
     }
 
     /**
-     * Define the place of speedBits in the flags variable for car.
+     * Define the place of the speedBits in the edge flags for car.
      */
     @Override
     public int defineWayBits( int index, int shift )
@@ -133,7 +136,7 @@ public int defineWayBits( int index, int shift )
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
-        return shift + speedBits;
+        return shift + speedEncoder.getBits();
     }
 
     protected double getSpeed( OSMWay way )
@@ -141,7 +144,7 @@ protected double getSpeed( OSMWay way )
         String highwayValue = way.getTag("highway");
         Integer speed = defaultSpeedMap.get(highwayValue);
         if (speed == null)
-            throw new IllegalStateException("car, no speed found for:" + highwayValue);
+            throw new IllegalStateException(toString() + ", no speed found for:" + highwayValue);
 
         if (highwayValue.equals("track"))
         {
@@ -175,6 +178,13 @@ public long acceptWay( OSMWay way )
             return 0;
         }
 
+        if ("track".equals(highwayValue))
+        {
+            String tt = way.getTag("tracktype");
+            if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
+                return 0;
+        }
+
         if (!defaultSpeedMap.containsKey(highwayValue))
             return 0;
 
@@ -182,11 +192,12 @@ public long acceptWay( OSMWay way )
             return 0;
 
         // do not drive street cars into fords
-        if ((way.hasTag("highway", "ford") || way.hasTag("ford")) && !way.hasTag(restrictions, intended))
+        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
             return 0;
 
         // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues))
+        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -203,28 +214,17 @@ public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     }
 
     @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationCode )
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     {
-        if ((allowed & acceptBit) == 0)
+        if (!isAccept(allowed))
             return 0;
 
         long encoded;
-        if ((allowed & ferryBit) == 0)
+        if (!isFerry(allowed))
         {
             // get assumed speed from highway type
             double speed = getSpeed(way);
-            double maxspeed = parseSpeed(way.getTag("maxspeed"));
-            // apply speed limit no matter of the road type
-            if (maxspeed >= 0)
-                // reduce speed limit to reflect average speed
-                speed = maxspeed * 0.9;
-
-            double maxSpeed = parseSpeed(way.getTag("maxspeed:forward"));
-            double backSpeed = parseSpeed(way.getTag("maxspeed:backward"));
-            if (maxSpeed >= 0)
-                speed = maxSpeed * 0.9;
-            if (backSpeed >= 0 && speed > backSpeed * 0.9)
-                speed = backSpeed * 0.9;
+            speed = applyMaxSpeed(way, speed, true);
 
             // limit speed to max 30 km/h if bad surface
             if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
@@ -232,7 +232,11 @@ public long handleWayTags( OSMWay way, long allowed, long relationCode )
 
             encoded = setSpeed(0, speed);
 
-            if (way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+
+            if (way.hasTag("oneway", oneways) || isRoundabout)
             {
                 if (way.hasTag("oneway", "-1"))
                     encoded |= backwardBit;
@@ -250,16 +254,6 @@ public long handleWayTags( OSMWay way, long allowed, long relationCode )
         return encoded;
     }
 
-    @Override
-    public long handleNodeTags( OSMNode node )
-    {
-        // absolute barriers always block
-        if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
-
-        return super.handleNodeTags(node);
-    }
-
     public String getWayInfo( OSMWay way )
     {
         String str = "";
@@ -293,17 +287,6 @@ public String getWayInfo( OSMWay way )
             return "destination: " + str;
     }
 
-    @Override
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-    {
-        if (edgeOutExplorer == null || edgeInExplorer == null)
-        {
-            edgeOutExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, false, true));
-            edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, true, false));
-        }
-        return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer, osmReader);
-    }
-
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
new file mode 100644
index 0000000000..c7b67e7c68
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -0,0 +1,43 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+
+/**
+ * Turns an unidirectional weight Approximation into a bidirectional consistent one.
+ * <p/>
+ * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
+ * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
+ * pages 291296.
+ * <p/>
+ *
+ * @author jansoe
+ */
+public class ConsistentWeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+
+    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+        uniDirApproximatorForward = weightApprox;
+        uniDirApproximatorReverse = weightApprox.duplicate();
+    }
+
+    public void setSourceNode(int sourceNode){
+        uniDirApproximatorReverse.setGoalNode(sourceNode);
+    }
+
+    public void setGoalNode(int goalNode){
+        uniDirApproximatorForward.setGoalNode(goalNode);
+    }
+
+    public double approximate(int fromNode, boolean reverse)    {
+        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
+                                          - uniDirApproximatorReverse.approximate(fromNode));
+        if (reverse) {
+            weightApproximation *= -1;
+        }
+
+        return weightApproximation;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index e091d3ad5e..1cdd5bada9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -44,10 +44,10 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     }
 
     @Override
-    public boolean accept( EdgeIteratorState iter )
+    public final boolean accept( EdgeIteratorState iter )
     {
         long flags = iter.getFlags();
-        return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
+        return out && encoder.isBool(flags, FlagEncoder.K_FORWARD) || in && encoder.isBool(flags, FlagEncoder.K_BACKWARD);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
index 9011a9fed5..f00dc17928 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -69,7 +69,7 @@ public long setDoubleValue( long flags, double value )
 
     public double getDoubleValue( long flags )
     {
-        // find value        
+        // find value
         flags &= mask;
         flags >>= shift;
         return flags * factor;
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 4fa7500307..e2c2d6c18e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,21 +17,15 @@
  */
 package com.graphhopper.routing.util;
 
-import gnu.trove.map.TLongObjectMap;
-import gnu.trove.map.hash.TLongObjectHashMap;
-
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import java.util.*;
@@ -51,29 +45,16 @@
     public static final String RACINGBIKE = "racingbike";
     public static final String MOUNTAINBIKE = "mtb";
     public static final String FOOT = "foot";
-    private static final Map<String, String> defaultEdgeFlagEncoders = new HashMap<String, String>();
-    private static final Map<String, String> defaultTurnFlagEncoders = new HashMap<String, String>();
-
-    static
-    {
-        defaultEdgeFlagEncoders.put(CAR, CarFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(BIKE, BikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(BIKE2, Bike2WeightFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(RACINGBIKE, RacingBikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(MOUNTAINBIKE, MountainBikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(FOOT, FootFlagEncoder.class.getName());
-    }
+    public static final String MOTORCYCLE = "motorcycle";
 
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<AbstractFlagEncoder>();
-    private int edgeEncoderNextBit = 0;
 
     private int nextWayBit = 0;
     private int nextNodeBit = 0;
     private int nextRelBit = 0;
     private int nextTurnBit = 0;
-    private final int bytesForFlags;
-    private final int maxTurnFlagsBits;
-    private final int maxTurnCost;
+    private final int bitsForEdgeFlags;
+    private final int bitsForTurnFlags = 8 * 4;
     private boolean enableInstructions = true;
 
     /**
@@ -90,12 +71,7 @@ public EncodingManager( String flagEncodersStr )
 
     public EncodingManager( String flagEncodersStr, int bytesForFlags )
     {
-        this(flagEncodersStr, bytesForFlags, 0);
-    }
-
-    public EncodingManager( String flagEncodersStr, int bytesForFlags, int maxTurnCost )
-    {
-        this(Arrays.asList(readFromEncoderString(defaultEdgeFlagEncoders, flagEncodersStr).toArray(new FlagEncoder[0])), bytesForFlags, maxTurnCost);
+        this(parseEncoderString(flagEncodersStr), bytesForFlags);
     }
 
     /**
@@ -115,25 +91,22 @@ public EncodingManager( FlagEncoder... flagEncoders )
      */
     public EncodingManager( List<? extends FlagEncoder> flagEncoders )
     {
-        // we don't need turn costs yet, but only restrictions => maxTurnCost = 0
-        this(flagEncoders, 4, 0);
+        this(flagEncoders, 4);
     }
 
-    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForFlags, int maxTurnCost )
+    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
     {
-        if (bytesForFlags != 4 && bytesForFlags != 8)
-            throw new IllegalStateException("For 'flags' currently only 4 or 8 bytes supported");
+        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
+            throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
-        this.maxTurnCost = maxTurnCost;
-        this.bytesForFlags = bytesForFlags * 8;
-        this.maxTurnFlagsBits = bytesForFlags * 8;
+        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
 
         Collections.sort(flagEncoders, new Comparator<FlagEncoder>()
         {
             @Override
             public int compare( FlagEncoder o1, FlagEncoder o2 )
             {
-                return o1.getClass().toString().compareTo(o2.getClass().toString());
+                return o1.toString().compareTo(o2.toString());
             }
         });
         for (FlagEncoder flagEncoder : flagEncoders)
@@ -144,41 +117,56 @@ public int compare( FlagEncoder o1, FlagEncoder o2 )
 
     public int getBytesForFlags()
     {
-        return bytesForFlags / 8;
+        return bitsForEdgeFlags / 8;
     }
 
-    private static List<FlagEncoder> readFromEncoderString( Map<String, String> defaultEncoders, String encoderList )
+    static List<FlagEncoder> parseEncoderString( String encoderList )
     {
+        if (encoderList.contains(":"))
+            throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
+
         String[] entries = encoderList.split(",");
         List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
         for (String entry : entries)
         {
-            entry = entry.trim();
+            entry = entry.trim().toLowerCase();
             if (entry.isEmpty())
                 continue;
 
-            String className = null;
-            int pos = entry.indexOf(":");
-            if (pos > 0)
+            String entryVal = "";
+            if (entry.contains("|"))
             {
-                className = entry.substring(pos + 1);
-            } else
-            {
-                className = defaultEncoders.get(entry.toLowerCase());
-                if (className == null)
-                    throw new IllegalArgumentException("Unknown encoder name " + entry);
+                entryVal = entry;
+                entry = entry.split("\\|")[0];
             }
 
-            try
-            {
-                @SuppressWarnings("unchecked")
-                Class<FlagEncoder> cls = (Class<FlagEncoder>) Class.forName(className);
-                resultEncoders.add((FlagEncoder) cls.getDeclaredConstructor().newInstance());
-            } catch (Exception e)
-            {
-                throw new IllegalArgumentException("Cannot instantiate class " + className, e);
-            }
+            AbstractFlagEncoder fe;
+            if (entry.equals(CAR))
+                fe = new CarFlagEncoder(entryVal);
+
+            else if (entry.equals(BIKE))
+                fe = new BikeFlagEncoder(entryVal);
+
+            else if (entry.equals(BIKE2))
+                fe = new Bike2WeightFlagEncoder(entryVal);
+
+            else if (entry.equals(RACINGBIKE))
+                fe = new RacingBikeFlagEncoder(entryVal);
+
+            else if (entry.equals(MOUNTAINBIKE))
+                fe = new MountainBikeFlagEncoder(entryVal);
+
+            else if (entry.equals(FOOT))
+                fe = new FootFlagEncoder(entryVal);
+
+            else if (entry.equals(MOTORCYCLE))
+                fe = new MotorcycleFlagEncoder(entryVal);
+
+            else
+                throw new IllegalArgumentException("entry in encoder list not supported " + entry);
+
+            resultEncoders.add(fe);
         }
         return resultEncoders;
     }
@@ -189,33 +177,30 @@ public int getBytesForFlags()
     private void registerEncoder( AbstractFlagEncoder encoder )
     {
         int encoderCount = edgeEncoders.size();
-        int usedBits = encoder.defineNodeBits(encoderCount, edgeEncoderNextBit);
-        if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "node"));
+        int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
-        if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "way") + WAY_ERR);
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
-        if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "relation"));
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
-        edgeEncoderNextBit = usedBits;
-
         // turn flag bits are independent from edge encoder bits
-        usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit, determineRequiredBits(maxTurnCost));
-        if (usedBits > maxTurnFlagsBits)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "turn"));
+        usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
+        if (usedBits > bitsForTurnFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "turn"));
         nextTurnBit = usedBits;
 
-        //everything okay, add encoder
         edgeEncoders.add(encoder);
     }
 
@@ -240,7 +225,7 @@ private FlagEncoder getEncoder( String name, boolean throwExc )
                 return encoder;
         }
         if (throwExc)
-            throw new IllegalArgumentException("Encoder for " + name + " not found.");
+            throw new IllegalArgumentException("Encoder for " + name + " not found. Existing: " + toDetailsString());
         return null;
     }
 
@@ -316,8 +301,8 @@ public String toDetailsString()
                 str.append(",");
 
             str.append(encoder.toString());
-            str.append(":");
-            str.append(encoder.getClass().getName());
+            str.append("|");
+            str.append(encoder.getPropertiesString());
         }
 
         return str.toString();
@@ -326,10 +311,10 @@ public String toDetailsString()
     public FlagEncoder getSingle()
     {
         if (getVehicleCount() > 1)
-            throw new IllegalStateException("multiple encoders are active. cannot return one:" + toString());
+            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
 
         if (getVehicleCount() == 0)
-            throw new IllegalStateException("no encoder is active!");
+            throw new IllegalStateException("No encoder is active!");
 
         return edgeEncoders.get(0);
     }
@@ -349,9 +334,11 @@ public long flagsDefault( boolean forward, boolean backward )
      */
     public long reverseFlags( long flags )
     {
-        for (AbstractFlagEncoder encoder : edgeEncoders)
+        // performance critical
+        int len = edgeEncoders.size();
+        for (int i = 0; i < len; i++)
         {
-            flags = encoder.reverseFlags(flags);
+            flags = edgeEncoders.get(i).reverseFlags(flags);
         }
         return flags;
     }
@@ -395,56 +382,6 @@ public long handleNodeTags( OSMNode node )
         return flags;
     }
 
-    /**
-     * When parsing the ways we have the node flags as long variable encoded in analyzeNode.
-     */
-    public long applyNodeFlags( long wayFlags, long nodeFlags )
-    {
-        long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders)
-        {
-            flags |= encoder.applyNodeFlags(wayFlags & encoder.getWayBitMask(), nodeFlags);
-        }
-
-        return flags;
-    }
-
-    private static int determineRequiredBits( int value )
-    {
-        int numberOfBits = 0;
-        while (value > 0)
-        {
-            value = value >> 1;
-            numberOfBits++;
-        }
-        return numberOfBits;
-    }
-
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-    {
-        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
-
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
-        {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
-            for (TurnCostTableEntry entry : encoder.analyzeTurnRelation(turnRelation, osmReader))
-            {
-                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
-                if (oldEntry != null)
-                {
-                    // merging different encoders
-                    oldEntry.flags |= entry.flags;
-                } else
-                {
-                    entries.put(entry.getItemId(), entry);
-                }
-            }
-        }
-
-        return entries.valueCollection();
-    }
-
     public EncodingManager setEnableInstructions( boolean enableInstructions )
     {
         this.enableInstructions = enableInstructions;
@@ -478,10 +415,53 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
         }
     }
 
+    public List<FlagEncoder> fetchEdgeEncoders()
+    {
+        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+        list.addAll(edgeEncoders);
+        return list;
+    }
+
     static String fixWayName( String str )
     {
         if (str == null)
             return "";
         return str.replaceAll(";[ ]*", ", ");
     }
+
+    public boolean needsTurnCostsSupport()
+    {
+        for (FlagEncoder encoder : edgeEncoders)
+        {
+            if (encoder.supports(TurnWeighting.class))
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Create the EncodingManager from the provided GraphHopper location. Throws an
+     * IllegalStateException if it fails.
+     */
+    public static EncodingManager create( String ghLoc )
+    {
+        Directory dir = new RAMDirectory(ghLoc, true);
+        StorableProperties properties = new StorableProperties(dir);
+        if (!properties.loadExisting())
+            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
+                    + dir.getLocation());
+
+        // check encoding for compatiblity
+        properties.checkVersions(false);
+        String acceptStr = properties.get("graph.flagEncoders");
+
+        if (acceptStr.isEmpty())
+            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
+                    + dir.getLocation());
+
+        int bytesForFlags = 4;
+        if ("8".equals(properties.get("graph.bytesForFlags")))
+            bytesForFlags = 8;
+        return new EncodingManager(acceptStr, bytesForFlags);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index a5c3909d50..3a5a7f1632 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -20,19 +20,25 @@
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
- * Calculates the fastest route with the specified vehicle (VehicleEncoder).
+ * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
+ * in seconds.
  * <p/>
  * @author Peter Karich
  */
 public class FastestWeighting implements Weighting
 {
-    private final FlagEncoder encoder;
+    /**
+     * Converting to seconds is not necessary but makes adding other penalities easier (e.g. turn
+     * costs or traffic light costs etc)
+     */
+    protected final static double SPEED_CONV = 3.6;
+    protected final FlagEncoder encoder;
     private final double maxSpeed;
 
     public FastestWeighting( FlagEncoder encoder )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed();
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
     @Override
@@ -42,12 +48,12 @@ public double getMinWeight( double distance )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse )
-    {
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {        
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / speed;
+        return edge.getDistance() / speed * SPEED_CONV;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 6057d0bc20..b68eb0740f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,13 +17,16 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Translation;
+
 /**
  * This class provides methods to define how a value (like speed or direction) converts to a flag
  * (currently an integer value), which is stored in an edge .
  * <p/>
  * @author Peter Karich
  */
-public interface FlagEncoder
+public interface FlagEncoder extends TurnCostEncoder
 {
     /**
      * @return the maximum speed in km/h
@@ -66,19 +69,54 @@
      */
     long setProperties( double speed, boolean forward, boolean backward );
 
-    boolean isForward( long flags );
+    /*
+     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
+     * uses a minimum value which is two magnitudes higher than in the super class. 
+     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
+     */
+    /**
+     * Reports wether the edge is available in forward direction for a certain vehicle
+     */
+    static final int K_FORWARD = 0;
+    /**
+     * Reports wether the edge is available in backward direction for a certain vehicle
+     */
+    static final int K_BACKWARD = 1;
+    /**
+     * Reports wether this edge is part of a roundabout.
+     */
+    static final int K_ROUNDABOUT = 2;
+
+    /**
+     * Returns arbitrary boolean value identified by the specified key.
+     */
+    boolean isBool( long flags, int key );
+
+    long setBool( long flags, int key, boolean value );
+
+    /**
+     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * way or surface type of an edge
+     */
+    long getLong( long flags, int key );
+
+    long setLong( long flags, int key, long value );
+
+    /**
+     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * maximum width or height allowed for an edge.
+     */
+    double getDouble( long flags, int key );
 
-    boolean isBackward( long flags );    
+    long setDouble( long flags, int key, double value );
 
     /**
-     * @return the number to identify a pavement of a road.
-     * @see InstructionList#getWayName
+     * Returns true if the feature class is supported like TurnWeighting or PriorityWeighting.
      */
-    int getPavementType( long flags );
+    public boolean supports( Class<?> feature );
 
     /**
-     * @return the number to identify a pushing section, cycle way etc.
-     * @see InstructionList#getWayName
+     * @return additional cost or warning information for an instruction like ferry or road charges.
      */
-    int getWayType( long flags );
+    InstructionAnnotation getAnnotation( long flags, Translation tr );
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index f14cff77a5..e72d4688f0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -22,6 +22,8 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.*;
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
@@ -32,46 +34,52 @@
  */
 public class FootFlagEncoder extends AbstractFlagEncoder
 {
-    static final int SLOW = 2;
-    static final int MEAN = 5;
-    static final int FERRY = 10;
-    private int safeWayBit = 0;
+    static final int SLOW_SPEED = 2;
+    static final int MEAN_SPEED = 5;
+    static final int FERRY_SPEED = 10;
+    private EncodedValue preferWayEncoder;
+    private EncodedValue relationCodeEncoder;
     protected HashSet<String> sidewalks = new HashSet<String>();
     private final Set<String> safeHighwayTags = new HashSet<String>();
     private final Set<String> allowedHighwayTags = new HashSet<String>();
+    private final Set<String> avoidHighwayTags = new HashSet<String>();
+    // convert network tag of hiking routes into a way route code
+    private final Map<String, Integer> hikingNetworkToCode = new HashMap<String, Integer>();
 
     /**
      * Should be only instantiated via EncodingManager
      */
-    protected FootFlagEncoder()
+    public FootFlagEncoder()
     {
         this(4, 1);
     }
 
-    protected FootFlagEncoder( int speedBits, double speedFactor )
+    public FootFlagEncoder( String propertiesStr )
     {
-        super(speedBits, speedFactor);
-        restrictions = new String[]
-        {
-            "foot", "access"
-        };
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 1));
+    }
+
+    public FootFlagEncoder( int speedBits, double speedFactor )
+    {
+        super(speedBits, speedFactor, 0);
+        restrictions.addAll(Arrays.asList("foot", "access"));
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
 
-        intended.add("yes");
-        intended.add("designated");
-        intended.add("official");
-        intended.add("permissive");
+        intendedValues.add("yes");
+        intendedValues.add("designated");
+        intendedValues.add("official");
+        intendedValues.add("permissive");
 
         sidewalks.add("yes");
         sidewalks.add("both");
         sidewalks.add("left");
         sidewalks.add("right");
 
+        setBlockByDefault(false);
         potentialBarriers.add("gate");
-        //potentialBarriers.add( "lift_gate" );   you can always pass them on foot
-        potentialBarriers.add("swing_gate");
 
         acceptedRailways.add("station");
         acceptedRailways.add("platform");
@@ -85,19 +93,27 @@ protected FootFlagEncoder( int speedBits, double speedFactor )
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
 
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("tertiary");
+        avoidHighwayTags.add("tertiary_link");
+        avoidHighwayTags.add("cycleway");
+
         allowedHighwayTags.addAll(safeHighwayTags);
-        allowedHighwayTags.add("trunk");
-        allowedHighwayTags.add("trunk_link");
-        allowedHighwayTags.add("primary");
-        allowedHighwayTags.add("primary_link");
+        allowedHighwayTags.addAll(avoidHighwayTags);
         allowedHighwayTags.add("secondary");
         allowedHighwayTags.add("secondary_link");
-        allowedHighwayTags.add("tertiary");
-        allowedHighwayTags.add("tertiary_link");
         allowedHighwayTags.add("unclassified");
         allowedHighwayTags.add("road");
         // disallowed in some countries
         //allowedHighwayTags.add("bridleway");
+
+        hikingNetworkToCode.put("iwn", BEST.getValue());
+        hikingNetworkToCode.put("nwn", BEST.getValue());
+        hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
+        hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
     }
 
     @Override
@@ -106,18 +122,26 @@ public int defineWayBits( int index, int shift )
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         // larger value required - ferries are faster than pedestrians
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN, FERRY);
-        shift += speedBits;
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, FERRY_SPEED);
+        shift += speedEncoder.getBits();
 
-        safeWayBit = 1 << shift++;
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += preferWayEncoder.getBits();
         return shift;
     }
 
+    @Override
+    public int defineRelationBits( int index, int shift )
+    {
+        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        return shift + relationCodeEncoder.getBits();
+    }
+
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
      */
     @Override
-    public int defineTurnBits( int index, int shift, int numberCostsBits )
+    public int defineTurnBits( int index, int shift )
     {
         return shift;
     }
@@ -139,15 +163,15 @@ public boolean isTurnRestricted( long flag )
      * @return 0
      */
     @Override
-    public int getTurnCosts( long flag )
+    public double getTurnCost( long flag )
     {
         return 0;
     }
 
     @Override
-    public String toString()
+    public long getTurnFlags( boolean restricted, double costs )
     {
-        return "foot";
+        return 0;
     }
 
     /**
@@ -173,7 +197,8 @@ public long acceptWay( OSMWay way )
         String sacScale = way.getTag("sac_scale");
         if (sacScale != null)
         {
-            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale))
+            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
+                    && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
                 // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
                 return 0;
         }
@@ -182,7 +207,7 @@ public long acceptWay( OSMWay way )
             return acceptBit;
 
         // no need to evaluate ferries or fords - already included here
-        if (way.hasTag("foot", intended))
+        if (way.hasTag("foot", intendedValues))
             return acceptBit;
 
         if (!allowedHighwayTags.contains(highwayValue))
@@ -192,10 +217,7 @@ public long acceptWay( OSMWay way )
             return 0;
 
         // do not get our feet wet, "yes" is already included above
-        if (way.hasTag("highway", "ford") || way.hasTag("ford"))
-            return 0;
-
-        if (way.hasTag("bicycle", "official"))
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
             return 0;
 
         // check access restrictions
@@ -212,41 +234,54 @@ public long acceptWay( OSMWay way )
     @Override
     public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     {
+        int code = 0;
+        if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot"))
+        {
+            Integer val = hikingNetworkToCode.get(relation.getTag("network"));
+            if (val != null)
+                code = val;
+        } else if (relation.hasTag("route", "ferry"))
+        {
+            code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
+        }
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
         return oldRelationFlags;
     }
 
     @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationCode )
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     {
-        if ((allowed & acceptBit) == 0)
+        if (!isAccept(allowed))
             return 0;
 
         long encoded;
-        if ((allowed & ferryBit) == 0)
+        if (!isFerry(allowed))
         {
             String sacScale = way.getTag("sac_scale");
             if (sacScale != null)
             {
                 if ("hiking".equals(sacScale))
-                    encoded = speedEncoder.setDoubleValue(0, MEAN);
+                    encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
                 else
-                    encoded = speedEncoder.setDoubleValue(0, SLOW);
+                    encoded = speedEncoder.setDoubleValue(0, SLOW_SPEED);
             } else
             {
-                encoded = speedEncoder.setDoubleValue(0, MEAN);
+                encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
             }
             encoded |= directionBitMask;
 
-            // mark safe ways or ways with cycle lanes
-            if (safeHighwayTags.contains(way.getTag("highway"))
-                    || way.hasTag("sidewalk", sidewalks))
-            {
-                encoded |= safeWayBit;
-            }
+            int priorityFromRelation = 0;
+            if (relationFlags != 0)
+                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
 
         } else
         {
-            encoded = handleFerryTags(way, SLOW, MEAN, FERRY);
+            encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             encoded |= directionBitMask;
         }
 
@@ -254,14 +289,100 @@ public long handleWayTags( OSMWay way, long allowed, long relationCode )
     }
 
     @Override
-    public int getPavementType( long flags )
+    public double getDouble( long flags, int key )
     {
-        return 0;
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
     }
 
     @Override
-    public int getWayType( long flags )
+    public long getLong( long flags, int key )
     {
-        return 0;
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    protected int handlePriority( OSMWay way, int priorityFromRelation )
+    {
+        TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
+        if (priorityFromRelation == 0)
+            weightToPrioMap.put(0d, UNCHANGED.getValue());
+        else
+            weightToPrioMap.put(110d, priorityFromRelation);
+
+        collect(way, weightToPrioMap);
+
+        // pick priority with biggest order value
+        return weightToPrioMap.lastEntry().getValue();
+    }
+
+    /**
+     * @param weightToPrioMap associate a weight with every priority. This sorted map allows
+     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     */
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        String highway = way.getTag("highway");
+        if (way.hasTag("foot", "designated"))
+            weightToPrioMap.put(100d, PREFER.getValue());
+
+        double maxSpeed = getMaxSpeed(way);
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20
+                || way.hasTag("sidewalk", sidewalks))
+        {
+            weightToPrioMap.put(40d, PREFER.getValue());
+
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(40d, UNCHANGED.getValue());
+        }
+
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 50 || way.hasTag("bicycle", "official"))
+        {
+            weightToPrioMap.put(50d, REACH_DEST.getValue());
+
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+        }
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "foot";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 1db6312e76..0f5954ad1e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -27,16 +27,24 @@
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    protected LevelGraph graph;
+    private final LevelGraph graph;
+    private final int nodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
+        nodes = g.getNodes();
     }
 
     @Override
     public boolean accept( EdgeIteratorState edgeIter )
     {
-        return graph.getLevel(edgeIter.getBaseNode()) <= graph.getLevel(edgeIter.getAdjNode());
+        int base = edgeIter.getBaseNode();
+        int adj = edgeIter.getAdjNode();
+        // for now workaround for #288
+        if (base >= nodes || adj >= nodes)
+            return true;
+
+        return graph.getLevel(base) <= graph.getLevel(adj);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
new file mode 100644
index 0000000000..ce5f0aef68
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -0,0 +1,328 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.BitUtil;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.HashSet;
+
+/**
+ * Defines bit layout for motorbikes
+ * <p>
+ * @author Peter Karich
+ */
+public class MotorcycleFlagEncoder extends CarFlagEncoder
+{
+    private EncodedDoubleValue reverseSpeedEncoder;
+    private EncodedValue preferWayEncoder;
+    private final HashSet<String> avoidSet = new HashSet<String>();
+    private final HashSet<String> preferSet = new HashSet<String>();
+
+    public MotorcycleFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 5),
+                parseDouble(propertiesStr, "speedFactor", 5),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        restrictions.remove("motorcar");
+        //  moped, mofa
+        restrictions.add("motorcycle");
+
+        trackTypeSpeedMap.clear();
+        defaultSpeedMap.clear();
+
+        trackTypeSpeedMap.put("grade1", 20); // paved
+        trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
+        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
+        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+
+        avoidSet.add("motorway");
+        avoidSet.add("trunk");
+        avoidSet.add("motorroad");
+        preferSet.add("primary");
+        preferSet.add("secondary");
+
+        // autobahn
+        defaultSpeedMap.put("motorway", 100);
+        defaultSpeedMap.put("motorway_link", 70);
+        defaultSpeedMap.put("motorroad", 90);
+        // bundesstrae
+        defaultSpeedMap.put("trunk", 80);
+        defaultSpeedMap.put("trunk_link", 75);
+        // linking bigger town
+        defaultSpeedMap.put("primary", 65);
+        defaultSpeedMap.put("primary_link", 60);
+        // linking towns + villages
+        defaultSpeedMap.put("secondary", 60);
+        defaultSpeedMap.put("secondary_link", 50);
+        // streets without middle line separation
+        defaultSpeedMap.put("tertiary", 50);
+        defaultSpeedMap.put("tertiary_link", 40);
+        defaultSpeedMap.put("unclassified", 30);
+        defaultSpeedMap.put("residential", 30);
+        // spielstrae
+        defaultSpeedMap.put("living_street", 5);
+        defaultSpeedMap.put("service", 20);
+        // unknown road
+        defaultSpeedMap.put("road", 20);
+        // forestry stuff
+        defaultSpeedMap.put("track", 15);
+    }
+
+    /**
+     * Define the place of the speedBits in the edge flags for car.
+     */
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+        shift += reverseSpeedEncoder.getBits();
+
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
+        shift += reverseSpeedEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public long acceptWay( OSMWay way )
+    {
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null)
+        {
+            if (way.hasTag("route", ferries))
+            {
+                String motorcycleTag = way.getTag("motorcycle");
+                if (motorcycleTag == null)
+                    motorcycleTag = way.getTag("motor_vehicle");
+
+                if (motorcycleTag == null && !way.hasTag("foot") && !way.hasTag("bicycle") || "yes".equals(motorcycleTag))
+                    return acceptBit | ferryBit;
+            }
+            return 0;
+        }
+
+        if ("track".equals(highwayValue))
+        {
+            String tt = way.getTag("tracktype");
+            if (tt != null && !tt.equals("grade1"))
+                return 0;
+        }
+
+        if (!defaultSpeedMap.containsKey(highwayValue))
+            return 0;
+
+        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+            return 0;
+
+        // do not drive street cars into fords
+        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
+            return 0;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+            return 0;
+
+        // do not drive cars over railways (sometimes incorrectly mapped!)
+        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+            return 0;
+
+        return acceptBit;
+    }
+
+    @Override
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+    {
+        if (!isAccept(allowed))
+            return 0;
+
+        long encoded = 0;
+        if (!isFerry(allowed))
+        {
+            encoded = setLong(encoded, PriorityWeighting.KEY, calcPriority(way, relationFlags));
+
+            // get assumed speed from highway type
+            double speed = getSpeed(way);
+            speed = applyMaxSpeed(way, speed, true);
+
+            double maxMCSpeed = parseSpeed(way.getTag("maxspeed:motorcycle"));
+            if (maxMCSpeed > 0 && maxMCSpeed < speed)
+                speed = maxMCSpeed * 0.9;
+
+            // limit speed to max 30 km/h if bad surface
+            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
+                speed = 30;
+
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+                encoded = setBool(0, K_ROUNDABOUT, true);
+
+            if (way.hasTag("oneway", oneways) || isRoundabout)
+            {
+                if (way.hasTag("oneway", "-1"))
+                {
+                    encoded = setReverseSpeed(encoded, speed);
+                    encoded |= backwardBit;
+                } else
+                {
+                    encoded = setSpeed(encoded, speed);
+                    encoded |= forwardBit;
+                }
+            } else
+            {
+                encoded = setSpeed(encoded, speed);
+                encoded = setReverseSpeed(encoded, speed);
+                encoded |= directionBitMask;
+            }
+
+        } else
+        {
+            encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
+            encoded |= directionBitMask;
+        }
+
+        return encoded;
+    }
+
+    @Override
+    public double getReverseSpeed( long flags )
+    {
+        return reverseSpeedEncoder.getDoubleValue(flags);
+    }
+
+    @Override
+    public long setReverseSpeed( long flags, double speed )
+    {
+        if (speed < 0)
+            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+
+        if (speed > getMaxSpeed())
+            speed = getMaxSpeed();
+
+        return reverseSpeedEncoder.setDoubleValue(flags, speed);
+    }
+
+    @Override
+    public long flagsDefault( boolean forward, boolean backward )
+    {
+        long flags = super.flagsDefault(forward, backward);
+        if (backward)
+            return reverseSpeedEncoder.setDefaultValue(flags);
+
+        return flags;
+    }
+
+    @Override
+    public long setProperties( double speed, boolean forward, boolean backward )
+    {
+        long flags = super.setProperties(speed, forward, backward);
+        if (backward)
+            return setReverseSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    public long reverseFlags( long flags )
+    {
+        // swap access
+        flags = super.reverseFlags(flags);
+
+        // swap speeds 
+        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
+        flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
+        return setSpeed(flags, otherValue);
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    private int calcPriority( OSMWay way, long relationFlags )
+    {
+        String highway = way.getTag("highway", "");
+        if (avoidSet.contains(highway))
+        {
+            return PriorityCode.AVOID_AT_ALL_COSTS.getValue();
+        } else if (preferSet.contains(highway))
+        {
+            return PriorityCode.VERY_NICE.getValue();
+        }
+        return PriorityCode.UNCHANGED.getValue();
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "motorcycle";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index ea8abfb323..26da91bb32 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -17,87 +17,162 @@
  */
 package com.graphhopper.routing.util;
 
-import static com.graphhopper.routing.util.BikeFlagCommonEncoder.PUSHING_SECTION_SPEED;
+import com.graphhopper.reader.OSMRelation;
+import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.TreeMap;
 
 /**
  * Specifies the settings for mountain biking
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class MountainBikeFlagEncoder extends BikeFlagCommonEncoder
+public class MountainBikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    MountainBikeFlagEncoder()
+    public MountainBikeFlagEncoder()
     {
-        setTrackTypeSpeed("grade1", 12); // paved
-        setTrackTypeSpeed("grade2", 20); // now unpaved ...
-        setTrackTypeSpeed("grade3", 20);
-        setTrackTypeSpeed("grade4", 20);
-        setTrackTypeSpeed("grade5", 20); // like sand/grass     
-
-        setSurfaceSpeed("paved", 12);
-        setSurfaceSpeed("asphalt", 12);
+        this(4, 2, 0);
+    }
+
+    public MountainBikeFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        setTrackTypeSpeed("grade1", 18); // paved
+        setTrackTypeSpeed("grade2", 16); // now unpaved ...
+        setTrackTypeSpeed("grade3", 12);
+        setTrackTypeSpeed("grade4", 8);
+        setTrackTypeSpeed("grade5", 6); // like sand/grass     
+
+        setSurfaceSpeed("paved", 18);
+        setSurfaceSpeed("asphalt", 18);
         setSurfaceSpeed("cobblestone", 10);
         setSurfaceSpeed("cobblestone:flattened", 10);
         setSurfaceSpeed("sett", 10);
-        setSurfaceSpeed("concrete", 12);
-        setSurfaceSpeed("concrete:lanes", 14);
-        setSurfaceSpeed("concrete:plates", 14);
-        setSurfaceSpeed("paving_stones", 14);
-        setSurfaceSpeed("paving_stones:30", 14);
-        setSurfaceSpeed("unpaved", 20);
-        setSurfaceSpeed("compacted", 20);
-        setSurfaceSpeed("dirt", 20);
-        setSurfaceSpeed("earth", 20);
-        setSurfaceSpeed("fine_gravel", 20);
-        setSurfaceSpeed("grass", 20);
+        setSurfaceSpeed("concrete", 14);
+        setSurfaceSpeed("concrete:lanes", 16);
+        setSurfaceSpeed("concrete:plates", 16);
+        setSurfaceSpeed("paving_stones", 16);
+        setSurfaceSpeed("paving_stones:30", 16);
+        setSurfaceSpeed("unpaved", 14);
+        setSurfaceSpeed("compacted", 14);
+        setSurfaceSpeed("dirt", 14);
+        setSurfaceSpeed("earth", 14);
+        setSurfaceSpeed("fine_gravel", 18);
+        setSurfaceSpeed("grass", 14);
         setSurfaceSpeed("grass_paver", 14);
-        setSurfaceSpeed("gravel", 20);
-        setSurfaceSpeed("ground", 20);
+        setSurfaceSpeed("gravel", 16);
+        setSurfaceSpeed("ground", 16);
         setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
         setSurfaceSpeed("metal", 10);
-        setSurfaceSpeed("mud", 20);
+        setSurfaceSpeed("mud", 12);
         setSurfaceSpeed("pebblestone", 12);
         setSurfaceSpeed("salt", 12);
-        setSurfaceSpeed("sand", 20);
-        setSurfaceSpeed("wood", 20);
-
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
-
-        setHighwaySpeed("cycleway", 12);
-        setHighwaySpeed("path", 24);
-        setHighwaySpeed("footway", 15);
-        setHighwaySpeed("pedestrian", 15);
-        setHighwaySpeed("road", 10);
-        setHighwaySpeed("track", 24);
-        setHighwaySpeed("service", 15);
-        setHighwaySpeed("unclassified", 15);
-        setHighwaySpeed("residential", 15);
-
-        setHighwaySpeed("trunk", 12);
-        setHighwaySpeed("trunk_link", 12);
-        setHighwaySpeed("primary", 10);
-        setHighwaySpeed("primary_link", 10);
-        setHighwaySpeed("secondary", 12);
-        setHighwaySpeed("secondary_link", 12);
-        setHighwaySpeed("tertiary", 14);
-        setHighwaySpeed("tertiary_link", 14);
-
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
-
-        setCyclingNetworkPreference("icn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("ncn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("rcn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("lcn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("mtb", BikeFlagCommonEncoder.RelationMapCode.OUTSTANDING_NICE.getValue());
+        setSurfaceSpeed("sand", 10);
+        setSurfaceSpeed("wood", 10);
+
+        setHighwaySpeed("living_street", 6);
+        setHighwaySpeed("steps", PUSHING_SECTION_SPEED);
 
+        setHighwaySpeed("cycleway", 18);
+        setHighwaySpeed("path", 18);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("road", 12);
+        setHighwaySpeed("track", 18);
+        setHighwaySpeed("service", 14);
+        setHighwaySpeed("unclassified", 16);
+        setHighwaySpeed("residential", 16);
+
+        setHighwaySpeed("trunk", 18);
+        setHighwaySpeed("trunk_link", 18);
+        setHighwaySpeed("primary", 18);
+        setHighwaySpeed("primary_link", 18);
+        setHighwaySpeed("secondary", 18);
+        setHighwaySpeed("secondary_link", 18);
+        setHighwaySpeed("tertiary", 18);
+        setHighwaySpeed("tertiary_link", 18);
+
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
+
+        setCyclingNetworkPreference("icn", PREFER.getValue());
+        setCyclingNetworkPreference("ncn", PREFER.getValue());
+        setCyclingNetworkPreference("rcn", PREFER.getValue());
+        setCyclingNetworkPreference("lcn", PREFER.getValue());
+        setCyclingNetworkPreference("mtb", BEST.getValue());
+
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
+
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
+
+        preferHighwayTags.add("road");
+        preferHighwayTags.add("track");
+        preferHighwayTags.add("path");
+        preferHighwayTags.add("service");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+        preferHighwayTags.add("unclassified");
     }
 
     @Override
-    public String toString()
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
     {
+        super.collect(way, weightToPrioMap);
+
+        String highway = way.getTag("highway");
+        if ("track".equals(highway))
+        {
+            String trackType = way.getTag("tracktype");
+            if ("grade1".equals(trackType))
+                weightToPrioMap.put(50d, UNCHANGED.getValue());
+            else if (trackType == null)
+                weightToPrioMap.put(90d, PREFER.getValue());
+            else if (trackType.startsWith("grade"))
+                weightToPrioMap.put(100d, VERY_NICE.getValue());
+        }
+    }
+
+    @Override
+    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+    {
+        oldRelationFlags = super.handleRelationTags(relation, oldRelationFlags);
+        int code = 0;
+        if (relation.hasTag("route", "mtb"))
+            code = PREFER.getValue();
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
+        return oldRelationFlags;
+    }
+
+    @Override
+    boolean allowedSacScale( String sacScale )
+    {
+        // other scales are too dangerous even for MTB, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale)
+                || "demanding_mountain_hiking".equals(sacScale) || "alpine_hiking".equals(sacScale);
+    }
+
+    @Override
+    public String toString()
+    {        
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
deleted file mode 100644
index 4f0097362c..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.storage.Graph;
-
-/**
- * @author Peter Karich
- */
-public abstract class NoOpAlgorithmPreparation extends AbstractAlgoPreparation<NoOpAlgorithmPreparation>
-{
-    public NoOpAlgorithmPreparation()
-    {
-    }
-
-    /**
-     * Creates a preparation wrapper for the specified algorithm. Possible values for algorithmStr:
-     * astar (A* algorithm), astarbi (bidirectional A*) dijkstra (Dijkstra), dijkstrabi and
-     * dijkstraNativebi (a bit faster bidirectional Dijkstra).
-     */
-    public static AlgorithmPreparation createAlgoPrepare( Graph g, final String algorithmStr,
-            FlagEncoder encoder, Weighting weighting )
-    {
-        return p(new RoutingAlgorithmFactory(algorithmStr, false), encoder, weighting).setGraph(g);
-    }
-
-    private static AlgorithmPreparation p( final RoutingAlgorithmFactory factory,
-            final FlagEncoder encoder, final Weighting weighting )
-    {
-        return new NoOpAlgorithmPreparation()
-        {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                try
-                {
-                    return factory.createAlgo(_graph, encoder, weighting);
-                } catch (Exception ex)
-                {
-                    throw new RuntimeException(ex);
-                }
-            }
-
-            @Override
-            public String toString()
-            {
-                return createAlgo().getName() + ", " + encoder + ", " + weighting;
-            }
-        };
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 009db0927c..3388a7b256 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -20,16 +20,16 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.XFirstSearch;
+import com.graphhopper.util.*;
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import gnu.trove.list.array.TIntArrayList;
+
 /**
  * Removes nodes which are not part of the largest network. Ie. mostly nodes with no edges at all
  * but also small subnetworks which are nearly always bugs in OSM data or indicate otherwise
@@ -43,8 +43,10 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
+    private final EncodingManager encodingManager;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
@@ -55,6 +57,7 @@ else if (em.getVehicleCount() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
             edgeFilter = new DefaultEdgeFilter(em.getSingle());
+        this.encodingManager = em;
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -63,12 +66,24 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
+    {
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
+        return this;
+    }
+
     public void doWork()
     {
         int del = removeZeroDegreeNodes();
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
+
+        int unvisitedDeadEnds = 0;
+        if ((this.minOneWayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
+                + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
                 + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
         g.optimize();
         subNetworks = map.size();
@@ -80,18 +95,22 @@ public int getSubNetworks()
     }
 
     public Map<Integer, Integer> findSubnetworks()
+    {
+        return findSubnetworks(g.createEdgeExplorer(edgeFilter));
+    }
+
+    private Map<Integer, Integer> findSubnetworks( final EdgeExplorer explorer )
     {
         final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
         final AtomicInteger integ = new AtomicInteger(0);
         int locs = g.getNodes();
         final GHBitSet bs = new GHBitSetImpl(locs);
-        EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
         for (int start = 0; start < locs; start++)
         {
             if (g.isNodeRemoved(start) || bs.contains(start))
                 continue;
 
-            new XFirstSearch()
+            new BreadthFirstSearch()
             {
                 int tmpCounter = 0;
 
@@ -119,7 +138,7 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
                     return true;
                 }
 
-            }.start(explorer, start, false);
+            }.start(explorer, start);
             map.put(start, integ.get());
             integ.set(0);
         }
@@ -127,7 +146,7 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
     }
 
     /**
-     * Deletes all but the larges subnetworks.
+     * Deletes all but the largest subnetworks.
      */
     void keepLargeNetworks( Map<Integer, Integer> map )
     {
@@ -171,7 +190,7 @@ void removeNetwork( int start, int entries, final GHBitSet bs )
             return;
         }
         EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new XFirstSearch()
+        new DepthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -185,7 +204,7 @@ protected boolean goFurther( int nodeId )
                 g.markNodeRemoved(nodeId);
                 return super.goFurther(nodeId);
             }
-        }.start(explorer, start, true);
+        }.start(explorer, start);
     }
 
     /**
@@ -209,4 +228,35 @@ int removeZeroDegreeNodes()
         }
         return removed;
     }
+
+    /**
+     * Clean small networks that will be never be visited by this explorer See #86 For example,
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when point get connected
+     * to this small area. This routines removed all these points from the graph.
+     * <p/>
+     * @return number of removed nodes;
+     */
+    public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
+    {
+        // Partition g into strongly connected components using Tarjan's Algorithm.
+        final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
+        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
+
+        // remove components less than minimum size
+        int removed = 0;
+        for (TIntArrayList component : components)
+        {
+
+            if (component.size() < minOneWayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
+                    g.markNodeRemoved(component.get(i));
+                    removed++;
+                }
+            }
+        }
+        return removed;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/IntRef.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/util/IntRef.java
rename to core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index e349ca4b5f..e21eab1310 100644
--- a/core/src/main/java/com/graphhopper/util/IntRef.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -15,17 +15,34 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.routing.util;
 
 /**
+ * Used to store a priority value in the way flags of an edge. Used in combination with
+ * PriorityWeighting
+ * <p>
  * @author Peter Karich
  */
-public class IntRef
+public enum PriorityCode
 {
-    public int val;
+    WORST(0),
+    AVOID_AT_ALL_COSTS(1),
+    REACH_DEST(2),
+    AVOID_IF_POSSIBLE(3),
+    UNCHANGED(4),
+    PREFER(5),
+    VERY_NICE(6),
+    BEST(7);
+    private final int value;
 
-    public IntRef( int val )
+    private PriorityCode( int value )
     {
-        this.val = val;
+        this.value = value;
     }
+
+    public int getValue()
+    {
+        return value;
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
new file mode 100644
index 0000000000..1b20c872a4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Special weighting for (motor)bike
+ * <p>
+ * @author Peter Karich
+ */
+public class PriorityWeighting extends FastestWeighting
+{
+    /**
+     * For now used only in BikeCommonFlagEncoder and MotorcycleFlagEncoder
+     */
+    public static final int KEY = 101;
+
+    public PriorityWeighting( FlagEncoder encoder )
+    {
+        super(encoder);
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        if (Double.isInfinite(weight))
+            return Double.POSITIVE_INFINITY;
+        return weight / (0.5 + encoder.getDouble(edgeState.getFlags(), KEY));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index 7abd5b9206..9ccb9e1855 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -17,20 +17,45 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.TreeMap;
+
 /**
  * Specifies the settings for racebikeing
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class RacingBikeFlagEncoder extends BikeFlagCommonEncoder
+public class RacingBikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    RacingBikeFlagEncoder()
+    public RacingBikeFlagEncoder()
+    {
+        this(4, 2, 0);
+    }
+
+    public RacingBikeFlagEncoder( String propertiesStr )
     {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        preferHighwayTags.add("road");
+        preferHighwayTags.add("secondary");
+        preferHighwayTags.add("secondary_link");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+
         setTrackTypeSpeed("grade1", 20); // paved
-        setTrackTypeSpeed("grade2", PUSHING_SECTION_SPEED); // now unpaved ...
-        setTrackTypeSpeed("grade3", PUSHING_SECTION_SPEED / 2);
-        setTrackTypeSpeed("grade4", PUSHING_SECTION_SPEED / 2);
-        setTrackTypeSpeed("grade5", PUSHING_SECTION_SPEED / 2); // like sand/grass     
+        setTrackTypeSpeed("grade2", 10); // now unpaved ...
+        setTrackTypeSpeed("grade3", PUSHING_SECTION_SPEED);
+        setTrackTypeSpeed("grade4", PUSHING_SECTION_SPEED);
+        setTrackTypeSpeed("grade5", PUSHING_SECTION_SPEED);
 
         setSurfaceSpeed("paved", 20);
         setSurfaceSpeed("asphalt", 20);
@@ -59,60 +84,71 @@
         setSurfaceSpeed("sand", PUSHING_SECTION_SPEED / 2);
         setSurfaceSpeed("wood", PUSHING_SECTION_SPEED / 2);
 
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
-
         setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 15);
-        setHighwaySpeed("footway", 15);
-        setHighwaySpeed("pedestrian", 15);
-        setHighwaySpeed("road", 10);
+        setHighwaySpeed("path", 8);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("road", 12);
         setHighwaySpeed("track", PUSHING_SECTION_SPEED / 2); // assume unpaved
-        setHighwaySpeed("service", 20);
-        setHighwaySpeed("unclassified", 20);
-        setHighwaySpeed("residential", 20);
+        setHighwaySpeed("service", 12);
+        setHighwaySpeed("unclassified", 16);
+        setHighwaySpeed("residential", 16);
 
         setHighwaySpeed("trunk", 20);
         setHighwaySpeed("trunk_link", 20);
         setHighwaySpeed("primary", 20);
         setHighwaySpeed("primary_link", 20);
-        setHighwaySpeed("secondary", 24);
-        setHighwaySpeed("secondary_link", 24);
-        setHighwaySpeed("tertiary", 24);
-        setHighwaySpeed("tertiary_link", 24);
+        setHighwaySpeed("secondary", 20);
+        setHighwaySpeed("secondary_link", 20);
+        setHighwaySpeed("tertiary", 20);
+        setHighwaySpeed("tertiary_link", 20);
+
+        addPushingSection("path");
+        addPushingSection("track");
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
 
-        setPushingSection("path");
-        setPushingSection("track");
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
+        setCyclingNetworkPreference("icn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("ncn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
+        setCyclingNetworkPreference("lcn", PriorityCode.UNCHANGED.getValue());
+        setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+    }
 
-        setCyclingNetworkPreference("icn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("ncn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("rcn", RelationMapCode.VERY_NICE.getValue());
-        setCyclingNetworkPreference("lcn", RelationMapCode.UNCHANGED.getValue());
-        setCyclingNetworkPreference("mtb", RelationMapCode.UNCHANGED.getValue());
+    @Override
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        super.collect(way, weightToPrioMap);
 
+        String highway = way.getTag("highway");
+        if ("service".equals(highway))
+        {
+            weightToPrioMap.put(40d, UNCHANGED.getValue());
+        } else if ("track".equals(highway))
+        {
+            String trackType = way.getTag("tracktype");
+            if ("grade1".equals(trackType))
+                weightToPrioMap.put(110d, PREFER.getValue());
+            else if (trackType == null || trackType.startsWith("grade"))
+                weightToPrioMap.put(110d, AVOID_AT_ALL_COSTS.getValue());
+        }
     }
 
-    // In case that the way belongs to a relation for which we do have a relation triggered weight change.    
-    // FIXME: Re-write in case that there is a more generic way to influence the weighting (issue #124).
-    // Here we boost or reduce the speed according to the relationWeightCode:
     @Override
-    int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
+    boolean isPushingSection( OSMWay way )
     {
-        int speed;
-        if ((highwaySpeed > PUSHING_SECTION_SPEED) && (highwaySpeed < 15))
-            // We know that our way belongs to a cycle route, so we assume 15km/h minimum
-            speed = 15;
-        else
-            speed = highwaySpeed;
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+        return way.hasTag("highway", pushingSections)
+                || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
+    }
 
-        if (speed > PUSHING_SECTION_SPEED)
-            // Add or remove 4km/h per every relation weight boost point
-            return speed + 4 * (relationCode - DEFAULT_REL_CODE);
-        else
-            return speed;   // We are not pushing unpaved parts
+    @Override
+    boolean allowedSacScale( String sacScale )
+    {
+        // for racing bike it is only allowed if empty
+        return false;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
deleted file mode 100644
index 1ebe625b29..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.coll.MapEntry;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.StopWatch;
-import static com.graphhopper.routing.util.NoOpAlgorithmPreparation.*;
-import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Integration tests for one bigger area - at the moment Unterfranken (Germany). Execute via
- * ./graphhopper.sh test unterfranken.osm
- * <p/>
- * @author Peter Karich
- */
-public class RoutingAlgorithmSpecialAreaTests
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Graph unterfrankenGraph;
-    private final LocationIndex idx;
-
-    public RoutingAlgorithmSpecialAreaTests( GraphHopper graphhopper )
-    {
-        this.unterfrankenGraph = graphhopper.getGraph();
-        StopWatch sw = new StopWatch().start();
-        idx = graphhopper.getLocationIndex();
-        logger.info(idx.getClass().getSimpleName() + " index. Size:"
-                + (float) idx.getCapacity() / (1 << 20) + " MB, took:" + sw.stop().getSeconds());
-    }
-
-    public void start()
-    {
-        testIndex();
-        testAlgos();
-    }
-
-    void testAlgos()
-    {
-        if (unterfrankenGraph instanceof LevelGraph)
-        {
-            throw new IllegalStateException("run testAlgos only with a none-LevelGraph. Use prepare.chShortcuts=false "
-                    + "Or use prepare.chShortcuts=shortest and avoid the preparation");
-        }
-
-        TestAlgoCollector testCollector = new TestAlgoCollector("testAlgos");
-        final EncodingManager encodingManager = new EncodingManager("CAR", 4);
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        boolean ch = true;
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = createAlgos(unterfrankenGraph, idx,
-                carEncoder, ch, new ShortestWeighting(), encodingManager);
-        EdgeFilter ef = new DefaultEdgeFilter(carEncoder);
-
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
-        {
-            AlgorithmPreparation prepare = entry.getKey();
-            LocationIndex currIdx = entry.getValue();
-            int failed = testCollector.errors.size();
-
-            OneRun or = new OneRun(50.0314, 10.5105, 50.0303, 10.5070, 570, 22);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.51451, 9.967346, 50.2920, 10.4650, 107545, 1712);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.0780, 9.1570, 49.5860, 9.9750, 91715, 1299);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.2800, 9.7190, 49.8960, 10.3890, 76411, 1406);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.8020, 9.2470, 50.4940, 10.1970, 125633, 2253);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.72449, 9.23482, 50.4140, 10.2750, 137260.8, 2401);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.1100, 10.7530, 49.6500, 10.3410, 73530, 1462);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-
-            System.out.println("unterfranken " + prepare.createAlgo() + ": " + (testCollector.errors.size() - failed) + " failed");
-        }
-
-        testCollector.printSummary();
-    }
-
-    private static class ME extends MapEntry<AlgorithmPreparation, LocationIndex>
-    {
-        public ME( AlgorithmPreparation ap, LocationIndex idx )
-        {
-            super(ap, idx);
-        }
-    }
-
-    public static Collection<Entry<AlgorithmPreparation, LocationIndex>> createAlgos( Graph g,
-            LocationIndex idx, FlagEncoder encoder, boolean withCh, Weighting weighting, EncodingManager manager )
-    {
-        // List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        prepare.add(new ME(createAlgoPrepare(g, "astar", encoder, weighting), idx));
-        // prepare.add(new ME(createAlgoPrepare(g, "dijkstraOneToMany", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "astarbi", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstraNativebi", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstrabi", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstra", encoder, weighting), idx));
-
-        if (withCh)
-        {
-            LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(encoder, weighting).
-                    setGraph(graphCH);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
-            prepare.add(new ME(prepareCH, idxCH));
-
-            // still one failing test regardless of the approx factor
-//            PrepareContractionHierarchies prepareCHAStar = new PrepareContractionHierarchies(encoder, weighting) {
-//
-//                @Override
-//                public RoutingAlgorithm createAlgo()
-//                {
-//                    return createAStar().setApproximation(true).setApproximationFactor(0.9);
-//                }
-//            }.setGraph(graphCH);            
-//            prepare.add(new ME(prepareCHAStar, idxCH));
-        }
-        return prepare;
-    }
-
-    void testIndex()
-    {
-        TestAlgoCollector testCollector = new TestAlgoCollector("testIndex");
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.080539, 10.125854, 63.35);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.081146, 10.124496, 0.0);
-        testCollector.queryIndex(unterfrankenGraph, idx, 49.68243, 9.933271, 436.29);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.066495, 10.191836, 14.63);
-
-        testCollector.printSummary();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index afb9514524..418caed170 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -27,10 +27,6 @@
  */
 public class ShortestWeighting implements Weighting
 {
-    public ShortestWeighting()
-    {
-    }
-
     @Override
     public double getMinWeight( double currDistToGoal )
     {
@@ -38,9 +34,9 @@ public double getMinWeight( double currDistToGoal )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse )
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
     {
-        return edge.getDistance();
+        return edgeState.getDistance();
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
new file mode 100644
index 0000000000..1eff527304
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -0,0 +1,144 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.util.EdgeIterator;
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.stack.array.TIntArrayStack;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+
+/**
+ * Implementation of Tarjan's algorithm using an explicit stack.
+ * (The traditional recursive approach runs into stack overflow pretty quickly.)
+ *
+ * Used for finding strongly connected components to detect dead-ends.
+ *
+ * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
+ */
+public class TarjansStronglyConnectedComponentsAlgorithm {
+
+    private final GraphStorage g;
+    private final TIntArrayStack nodeStack;
+    private final GHBitSetImpl onStack;
+    private final int[] nodeIndex;
+    private final int[] nodeLowLink;
+    private final ArrayList<TIntArrayList> components = new ArrayList<TIntArrayList>();
+
+    private int index = 1;
+    private final EdgeFilter edgeFilter;
+
+    public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final EdgeFilter edgeFilter) {
+        this.g = g;
+        this.nodeStack = new TIntArrayStack();
+        this.onStack = new GHBitSetImpl(g.getNodes());
+        this.nodeIndex = new int[g.getNodes()];
+        this.nodeLowLink = new int[g.getNodes()];
+        this.edgeFilter = edgeFilter;
+    }
+
+    /**
+     * Find and return list of all strongly connected components in g.
+     */
+    public List<TIntArrayList> findComponents() {
+
+        int nodes = g.getNodes();
+        for (int start = 0; start < nodes; start++) {
+            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start)) {
+                strongConnect(start);
+            }
+        }
+
+        return components;
+    }
+
+    // Find all components reachable from firstNode, add them to 'components'
+    private void strongConnect(int firstNode) {
+        final Stack<TarjanState> stateStack = new Stack<TarjanState>();
+        stateStack.push(TarjanState.startState(firstNode));
+
+        // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
+        nextState:
+
+        while (!stateStack.empty()) {
+            TarjanState state = stateStack.pop();
+            final int start = state.start;
+            final EdgeIterator iter;
+
+            if (state.isStart()) {
+                // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
+                nodeIndex[start] = index;
+                nodeLowLink[start] = index;
+                index ++;
+                nodeStack.push(start);
+                onStack.set(start);
+
+                iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
+
+            } else { // if (state.isResume()) {
+
+                // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
+                iter = state.iter;
+
+                int prevConnectedId = iter.getAdjNode();
+                nodeLowLink[start] = Math.min(nodeLowLink[start], nodeLowLink[prevConnectedId]);
+            }
+
+            // Each element (excluding the first) in the current component should be able to find
+            // a successor with a lower nodeLowLink.
+            while (iter.next())
+            {
+                int connectedId = iter.getAdjNode();
+                if (nodeIndex[connectedId] == 0) {
+                    // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
+                    // Ideally we'd just call strongConnectIterative(connectedId);
+                    stateStack.push(TarjanState.resumeState(start, iter));
+                    stateStack.push(TarjanState.startState(connectedId));
+                    continue nextState;
+                } else if (onStack.contains(connectedId)) {
+                    nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
+                }
+            }
+
+            // If nodeLowLink == nodeIndex, then we are the first element in a component.
+            // Add all nodes higher up on nodeStack to this component.
+            if (nodeIndex[start] == nodeLowLink[start]) {
+                TIntArrayList component = new TIntArrayList();
+                int node;
+                while ((node = nodeStack.pop()) != start) {
+                    component.add(node);
+                    onStack.clear(node);
+                }
+                component.add(start);
+                onStack.clear(start);
+
+                components.add(component);
+            }
+        }
+    }
+
+    // Internal stack state of algorithm, used to avoid recursive function calls and hitting stack overflow exceptions.
+    // State is either 'start' for new nodes or 'resume' for partially traversed nodes.
+    private static class TarjanState {
+        final int start;
+        final EdgeIterator iter;
+
+        // Iterator only present in 'resume' state.
+        boolean isStart() { return iter == null; }
+
+        private TarjanState(final int start, final EdgeIterator iter) {
+            this.start = start;
+            this.iter = iter;
+        }
+
+        public static TarjanState startState(int start) {
+            return new TarjanState(start, null);
+        }
+
+        public static TarjanState resumeState(int start, EdgeIterator iter) {
+            return new TarjanState(start, iter);
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index bfb062ff92..ca06914204 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -18,18 +18,16 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.GHResponse;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.PathMerger;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * @author Peter Karich
@@ -37,56 +35,68 @@
 public class TestAlgoCollector
 {
     private final String name;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
-    public List<String> errors = new ArrayList<String>();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final TranslationMap trMap = new TranslationMap().doImport();
+    public final List<String> errors = new ArrayList<String>();
 
     public TestAlgoCollector( String name )
     {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<QueryResult> queryList, OneRun oneRun )
+    public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+            OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
+        QueryGraph queryGraph = new QueryGraph(algoEntry.originalGraph);
+        queryGraph.lookup(queryList);
+        AlgorithmOptions opts = algoEntry.opts;
+        FlagEncoder encoder = opts.getFlagEncoder();
+        if (encoder.supports(TurnWeighting.class))
+            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), opts.getFlagEncoder(), (TurnCostExtension) queryGraph.getExtension())).build());
+
         for (int i = 0; i < queryList.size() - 1; i++)
         {
-            Path path = prepare.createAlgo().calcPath(queryList.get(i), queryList.get(i + 1));
-            viaPaths.add(path);path.calcPoints().size();
+            Path path = algoEntry.createAlgo(queryGraph).
+                    calcPath(queryList.get(i).getClosestNode(), queryList.get(i + 1).getClosestNode());
+            // System.out.println(path.calcInstructions().createGPX("temp", 0, "GMT"));
+            viaPaths.add(path);
         }
+
         PathMerger pathMerger = new PathMerger().
                 setCalcPoints(true).
-                setSimplifyRequest(false).
+                setSimplifyResponse(false).
                 setEnableInstructions(true);
         GHResponse rsp = new GHResponse();
-        pathMerger.doWork(rsp, viaPaths);
+        pathMerger.doWork(rsp, viaPaths, trMap.getWithFallBack(Locale.US));
 
-        if (!rsp.isFound())
+        if (rsp.hasErrors())
         {
-            errors.add(prepare + " returns no path! expected distance: " + rsp.getDistance()
-                    + ", expected points: " + oneRun + ". " + queryList);
+            errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
+                    + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
         }
 
         PointList pointList = rsp.getPoints();
         double tmpDist = pointList.calcDistance(distCalc);
-        if (Math.abs(rsp.getDistance() - tmpDist) > 5)
+        if (Math.abs(rsp.getDistance() - tmpDist) > 2)
         {
-            errors.add(prepare + " path.getDistance was  " + rsp.getDistance()
+            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
 
-        if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 4)
+        if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2)
         {
-            errors.add(prepare + " returns path not matching the expected distance of " + oneRun.getDistance()
+            errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
                     + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
                     + ", was " + pointList.getSize() + ") " + queryList);
         }
 
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
-        if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 4)
+        if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1)
         {
-            errors.add(prepare + " returns path not matching the expected points of " + oneRun.getLocs()
+            errors.add(algoEntry + " returns path not matching the expected points of " + oneRun.getLocs()
                     + "\t Returned was " + pointList.getSize() + "\t (expected distance " + oneRun.getDistance()
                     + ", was " + rsp.getDistance() + ") " + queryList);
         }
@@ -136,6 +146,41 @@ void printSummary()
         }
     }
 
+    public static class AlgoHelperEntry
+    {
+        private Graph originalGraph;
+        private final LocationIndex idx;
+        private AlgorithmOptions opts;
+
+        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        {
+            this.originalGraph = g;
+            this.opts = opts;
+            this.idx = idx;
+        }
+
+        public void setAlgorithmOptions( AlgorithmOptions opts )
+        {
+            this.opts = opts;
+        }
+
+        public LocationIndex getIdx()
+        {
+            return idx;
+        }
+
+        public RoutingAlgorithm createAlgo( Graph qGraph )
+        {
+            return new RoutingAlgorithmFactorySimple().createAlgo(qGraph, opts);
+        }
+
+        @Override
+        public String toString()
+        {
+            return opts.getAlgorithm();
+        }
+    }
+
     public static class OneRun
     {
         private final List<AssumptionPerPath> assumptions = new ArrayList<AssumptionPerPath>();
@@ -189,9 +234,9 @@ public void setDistance( int index, double dist )
         public List<QueryResult> getList( LocationIndex idx, EdgeFilter edgeFilter )
         {
             List<QueryResult> qr = new ArrayList<QueryResult>();
-            for (AssumptionPerPath or : assumptions)
+            for (AssumptionPerPath p : assumptions)
             {
-                qr.add(idx.findClosest(or.lat, or.lon, edgeFilter));
+                qr.add(idx.findClosest(p.lat, p.lon, edgeFilter));
             }
             return qr;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
new file mode 100644
index 0000000000..20738fd6a9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -0,0 +1,121 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import java.util.Arrays;
+
+/**
+ * Defines how the graph can be traversed while Dijkstra or similar RoutingAlgorithm is in progress.
+ * Different options define how precise turn restrictions and costs are taken into account, but
+ * still all are without via-way support. BTW: this would not be done at runtime, this would be a
+ * pre-processing step to avoid performance penalities.
+ * <p>
+ * @author Peter Karich
+ */
+public enum TraversalMode
+{
+    /**
+     * The simplest traversal mode but without turn restrictions or cost support.
+     */
+    NODE_BASED(false, 1, false),
+    /**
+     * Strictly not recommended as it could lead to 'route not found' for bidirectional algorithms.
+     * An edged-based traversal mode with basic turn restriction and cost support, including the
+     * most scenarios. But without certain turn restrictions and without u-turns. As fast as node
+     * based.
+     */
+    EDGE_BASED_1DIR(true, 1, false),
+    /**
+     * The bidirectional edged-based traversal mode with turn restriction and cost support. Without
+     * u-turn support. 2 times slower than node based.
+     */
+    EDGE_BASED_2DIR(true, 2, false),
+    /**
+     * Not recommended as it leads to strange routes that outsmart the turn costs. The most feature
+     * rich edged-based traversal mode with turn restriction and cost support, including u-turns. 4
+     * times slower than node based.
+     */
+    EDGE_BASED_2DIR_UTURN(true, 2, true);
+
+    private final boolean edgeBased;
+    private final int noOfStates;
+    private final boolean uTurnSupport;
+
+    TraversalMode( boolean edgeBased, int noOfStates, boolean uTurnSupport )
+    {
+        this.edgeBased = edgeBased;
+        this.noOfStates = noOfStates;
+        this.uTurnSupport = uTurnSupport;
+
+        if (noOfStates != 1 && noOfStates != 2)
+            throw new IllegalArgumentException("Currently only 1 or 2 states allowed");
+    }
+
+    /**
+     * Returns the identifier to access the map of the shortest path tree according to the traversal
+     * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
+     * in edge-based behavior
+     * <p>
+     * @param iterState the current {@link EdgeIteratorState}
+     * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
+     * backward searches in bidirectional algorithms.
+     * @return the identifier to access the shortest path tree
+     */
+    public final int createTraversalId( EdgeIteratorState iterState, boolean reverse )
+    {
+        if (edgeBased)
+        {
+            if (noOfStates == 1)
+                return iterState.getEdge();
+
+            return GHUtility.createEdgeKey(iterState.getAdjNode(), iterState.getBaseNode(), iterState.getEdge(), reverse);
+        }
+
+        return iterState.getAdjNode();
+    }
+
+    public int getNoOfStates()
+    {
+        return noOfStates;
+    }
+
+    public boolean isEdgeBased()
+    {
+        return edgeBased;
+    }
+
+    public final boolean hasUTurnSupport()
+    {
+        return uTurnSupport;
+    }
+
+    public static TraversalMode fromString( String name )
+    {
+        try
+        {
+            return valueOf(name.toUpperCase());
+        } catch (Exception ex)
+        {
+            throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
+                    + "Supported are: " + Arrays.asList(TraversalMode.values()));
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index aaff285288..ca8ce6cb7c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -20,21 +20,29 @@
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
  * <p>
- * @author karl.huebner
+ * @author Karl Hbner
  */
 public interface TurnCostEncoder
 {
     /**
-     * @return true, if, and only if it is encoded in flag
+     * @return true, if the turn restriction is encoded in the specified flags
      */
-    boolean isTurnRestricted( long flag );
+    boolean isTurnRestricted( long flags );
 
     /**
-     * @return the costs in seconds encoded in flag
+     * @return the costs encoded in the specified flag, if restricted it will be
+     * Double.POSITIVE_INFINITY
      */
-    int getTurnCosts( long flag );
+    double getTurnCost( long flags );
 
-    long getTurnFlags( boolean restriction, int costs );
+    /**
+     * @param restricted true if restricted turn, equivalent to specifying of costs
+     * Double.POSITIVE_INFINITY
+     * @param costs the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
+     * Only used if restricted == false.
+     * @return the encoded flags
+     */
+    long getTurnFlags( boolean restricted, double costs );
 
     /**
      * whether turn costs nor turn restrictions will be encoded by this encoder, should be used for
@@ -44,23 +52,21 @@
     {
 
         @Override
-        public boolean isTurnRestricted( long flag )
+        public boolean isTurnRestricted( long flags )
         {
             return false;
         }
 
         @Override
-        public int getTurnCosts( long flag )
+        public double getTurnCost( long flags )
         {
             return 0;
         }
 
         @Override
-        public long getTurnFlags( boolean restriction, int costs )
+        public long getTurnFlags( boolean restriction, double costs )
         {
             return 0;
         }
-
     }
-
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
new file mode 100644
index 0000000000..bde1c79da6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -0,0 +1,104 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Provides methods to retrieve turn costs for a specific turn.
+ * <p>
+ * @author Karl Hbner
+ * @author Peter Karich
+ */
+public class TurnWeighting implements Weighting
+{
+    /**
+     * Encoder, which decodes the turn flags
+     */
+    private final TurnCostEncoder turnCostEncoder;
+    private final TurnCostExtension turnCostExt;
+    private final Weighting superWeighting;
+    private double defaultUTurnCost = 40;
+
+    /**
+     * @param turnCostExt the turn cost storage to be used
+     */
+    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostExtension turnCostExt )
+    {
+        this.turnCostEncoder = encoder;
+        this.superWeighting = superWeighting;
+        this.turnCostExt = turnCostExt;
+        if (encoder == null)
+            throw new IllegalArgumentException("No encoder set to calculate turn weight");
+        if (turnCostExt == null)
+            throw new RuntimeException("No storage set to calculate turn weight");
+    }
+
+    /**
+     * Set the default cost for an u-turn in seconds. Default is 40s. Should be that high to avoid
+     * 'tricking' other turn costs or restrictions.
+     */
+    public TurnWeighting setDefaultUTurnCost( double costInSeconds )
+    {
+        this.defaultUTurnCost = costInSeconds;
+        return this;
+    }
+
+    @Override
+    public double getMinWeight( double distance )
+    {
+        return superWeighting.getMinWeight(distance);
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+            return weight;
+
+        int edgeId = edgeState.getEdge();
+        double turnCosts;
+        if (reverse)
+            turnCosts = calcTurnWeight(edgeId, edgeState.getBaseNode(), prevOrNextEdgeId);
+        else
+            turnCosts = calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeId);
+
+        if (turnCosts == 0 && edgeId == prevOrNextEdgeId)
+            return weight + defaultUTurnCost;
+
+        return weight + turnCosts;
+    }
+
+    public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+        if (turnCostEncoder.isTurnRestricted(turnFlags))
+            return Double.POSITIVE_INFINITY;
+
+        return turnCostEncoder.getTurnCost(turnFlags);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "TURN|" + superWeighting.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
new file mode 100644
index 0000000000..f471be0d07
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -0,0 +1,22 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * <p/>
+ * @author jansoe
+ */
+public interface WeightApproximator
+{
+
+    /**
+     * @return minimal weight fromNode to the goalNode
+     */
+    double approximate(int fromNode);
+
+    void setGoalNode(int to);
+
+    /**
+     * makes a deep copy of itself
+     */
+    WeightApproximator duplicate();
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/Weighting.java b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
index 939b9f0b97..412666bf54 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Weighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
@@ -34,11 +34,13 @@
     double getMinWeight( double distance );
 
     /**
-     * @param edge the edge for which the weight should be calculated
+     * @param edgeState the edge for which the weight should be calculated
      * @param reverse if the specified edge is specified in reverse direction e.g. from the reverse
      * case of a bidirectional search.
+     * @param prevOrNextEdgeId if reverse is false this has to be the previous edgeId, if true it
+     * has to be the next edgeId in the direction from start to end.
      * @return the calculated weight with the specified velocity has to be in the range of 0 and
      * +Infinity. Make sure your method does not return NaN which can e.g. occur for 0/0.
      */
-    double calcWeight( EdgeIteratorState edge, boolean reverse );
+    double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId );
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
similarity index 58%
rename from core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java
rename to core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index 6db7def40a..b69f61d8f7 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -15,41 +15,47 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util.shapes;
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.PMap;
 
 /**
  *
  * @author Peter Karich
  */
-public class CoordTrigObjEntry<T> extends CoordTrig<T>
+public class WeightingMap extends PMap
 {
-    private T v;
-
-    public CoordTrigObjEntry()
+    public WeightingMap()
     {
     }
 
-    public CoordTrigObjEntry( T o, double lat, double lon )
+    /**
+     * Convenient constructor if only one parameter is provided
+     * <p>
+     * @param weighting
+     */
+    public WeightingMap( String weighting )
     {
-        super(lat, lon);
-        this.v = o;
+        super(5);
+        setWeighting(weighting);
     }
 
     @Override
-    public void setValue( T t )
+    public WeightingMap put( String key, Object str )
     {
-        v = t;
+        super.put(key, str);
+        return this;
     }
 
-    @Override
-    public T getValue()
+    public WeightingMap setWeighting( String w )
     {
-        return v;
+        if (w != null)
+            super.put("weighting", w);
+        return this;
     }
 
-    @Override
-    public String toString()
+    public String getWeighting()
     {
-        return super.toString() + " value:" + v;
+        return super.get("weighting", "");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index e2a52f4335..06239cf252 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -30,5 +30,5 @@
     /**
      * Returns a list of matching points for the specified place query string.
      */
-    List<GHPlace> name2point( GHPlace... place );
+    List<GHPlace> names2places( GHPlace... place );
 }
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index f2888423af..71c10990cc 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -20,7 +20,8 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Storable;
-import java.io.UnsupportedEncodingException;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Helper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -30,13 +31,13 @@
  */
 public class NameIndex implements Storable<NameIndex>
 {
-    private static Logger logger = LoggerFactory.getLogger(NameIndex.class);
-    private static final int START_POINTER = 1;
-    private int bytePointer = START_POINTER;
-    private DataAccess names;
+    private static final Logger logger = LoggerFactory.getLogger(NameIndex.class);
+    private static final long START_POINTER = 1;
+    private final DataAccess names;
+    private long bytePointer = START_POINTER;
     // minor optimization for the previous stored name
     private String lastName;
-    private int lastIndex;
+    private long lastIndex;
 
     public NameIndex( Directory dir )
     {
@@ -55,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = names.getHeader(0);
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
             return true;
         }
 
@@ -63,9 +64,9 @@ public boolean loadExisting()
     }
 
     /**
-     * @return the integer reference
+     * @return the byte pointer to the name
      */
-    public int put( String name )
+    public long put( String name )
     {
         if (name == null || name.isEmpty())
         {
@@ -76,8 +77,8 @@ public int put( String name )
             return lastIndex;
         }
         byte[] bytes = getBytes(name);
-        int oldPointer = bytePointer;
-        names.incCapacity(bytePointer + 1 + bytes.length);
+        long oldPointer = bytePointer;
+        names.ensureCapacity(bytePointer + 1 + bytes.length);
         byte[] sizeBytes = new byte[]
         {
             (byte) bytes.length
@@ -100,22 +101,16 @@ public int put( String name )
         byte[] bytes = null;
         for (int i = 0; i < 2; i++)
         {
-            try
+            bytes = name.getBytes(Helper.UTF_CS);
+            // we have to store the size of the array into *one* byte
+            if (bytes.length > 255)
             {
-                bytes = name.getBytes("UTF-8");
-                // we have to store the size of the array into *one* byte
-                if (bytes.length > 255)
-                {
-                    String newName = name.substring(0, 256 / 4);
-                    logger.info("Way name is too long: " + name + " truncated to " + newName);
-                    name = newName;
-                    continue;
-                }
-                break;
-            } catch (UnsupportedEncodingException ex)
-            {
-                throw new RuntimeException("Encoding not supported", ex);
+                String newName = name.substring(0, 256 / 4);
+                logger.info("Way name is too long: " + name + " truncated to " + newName);
+                name = newName;
+                continue;
             }
+            break;
         }
         if (bytes.length > 255)
         {
@@ -125,7 +120,7 @@ public int put( String name )
         return bytes;
     }
 
-    public String get( int pointer )
+    public String get( long pointer )
     {
         if (pointer < 0)
         {
@@ -140,19 +135,14 @@ public String get( int pointer )
         int size = sizeBytes[0] & 0xFF;
         byte[] bytes = new byte[size];
         names.getBytes(pointer + sizeBytes.length, bytes, size);
-        try
-        {
-            return new String(bytes, "UTF-8");
-        } catch (UnsupportedEncodingException ex)
-        {
-            throw new RuntimeException("Encoding not supported", ex);
-        }
+        return new String(bytes, Helper.UTF_CS);
     }
 
     @Override
     public void flush()
     {
-        names.setHeader(0, bytePointer);
+        names.setHeader(0, BitUtil.LITTLE.getIntLow(bytePointer));
+        names.setHeader(4, BitUtil.LITTLE.getIntHigh(bytePointer));
         names.flush();
     }
 
@@ -162,6 +152,12 @@ public void close()
         names.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return names.isClosed();
+    }
+
     public void setSegmentSize( int segments )
     {
         names.setSegmentSize(segments);
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 4efd504c53..164da777d0 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -30,5 +30,5 @@
     /**
      * Tries to retrieve a locational string from the specified points (list of lat,lon).
      */
-    List<GHPlace> point2name( GHPlace... points );
+    List<GHPlace> places2names( GHPlace... points );
 }
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 0d7331b51d..1839ce1f43 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -42,6 +42,7 @@
     protected transient int indexDivisor;
     protected final ByteOrder byteOrder;
     protected final BitUtil bitUtil;
+    protected transient boolean closed = false;
 
     public AbstractDataAccess( String name, String location, ByteOrder order )
     {
@@ -68,8 +69,15 @@ protected String getFullName()
     @Override
     public void close()
     {
+        closed = true;
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
+    }        
+
     @Override
     public void setHeader( int bytePos, int value )
     {
@@ -130,7 +138,7 @@ protected void copyHeader( DataAccess da )
     public DataAccess copyTo( DataAccess da )
     {
         copyHeader(da);
-        da.incCapacity(getCapacity());
+        da.ensureCapacity(getCapacity());
         long cap = getCapacity();
         // currently get/setBytes does not support copying more bytes then segmentSize
         int segSize = Math.min(da.getSegmentSize(), getSegmentSize());
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index 86ff0840d1..a1d337c3d8 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -27,29 +27,35 @@
     /**
      * The DA object is hold entirely in-memory. Loading and flushing is a no-op. See RAMDataAccess.
      */
-    public static final DAType RAM = new DAType(MemRef.HEAP, false, false);
+    public static final DAType RAM = new DAType(MemRef.HEAP, false, false, true, false);
     /**
      * Optimized RAM DA type for integer access. The set and getBytes methods cannot be used.
      */
-    public static final DAType RAM_INT = new DAType(MemRef.HEAP, false, true);
+    public static final DAType RAM_INT = new DAType(MemRef.HEAP, false, true, true, false);
     /**
      * The DA object is hold entirely in-memory. It will read load disc and flush to it if they
      * equivalent methods are called. See RAMDataAccess.
      */
-    public static final DAType RAM_STORE = new DAType(MemRef.HEAP, true, false);
+    public static final DAType RAM_STORE = new DAType(MemRef.HEAP, true, false, true, false);
     /**
      * Optimized RAM_STORE DA type for integer access. The set and getBytes methods cannot be used.
      */
-    public static final DAType RAM_INT_STORE = new DAType(MemRef.HEAP, true, true);
+    public static final DAType RAM_INT_STORE = new DAType(MemRef.HEAP, true, true, true, false);
     /**
      * Memory mapped DA object. See MMapDataAccess. To make it read and write thread-safe you need
      * to use 'new DAType(MMAP, true)'
      */
-    public static final DAType MMAP = new DAType(MemRef.MMAP, true, false);
+    public static final DAType MMAP = new DAType(MemRef.MMAP, true, false, true, false);
+
+    /**
+     * Read-only memory mapped DA object. To avoid write access useful for reading on mobile or
+     * embedded data stores.
+     */
+    public static final DAType MMAP_RO = new DAType(MemRef.MMAP, true, false, false, false);
     /**
      * Experimental API. Do not use yet.
      */
-    public static final DAType UNSAFE_STORE = new DAType(MemRef.UNSAFE, true, false);
+    public static final DAType UNSAFE_STORE = new DAType(MemRef.UNSAFE, true, false, true, false);
 
     public enum MemRef
     {
@@ -60,29 +66,26 @@
     private final boolean storing;
     private final boolean integ;
     private final boolean synched;
+    private final boolean allowWrites;
 
     public DAType( DAType type, boolean synched )
     {
-        this(type.getMemRef(), type.isStoring(), type.isInteg(), synched);
+        this(type.getMemRef(), type.isStoring(), type.isInteg(), type.isAllowWrites(), synched);
         if (!synched)
             throw new IllegalStateException("constructor can only be used with synched=true");
         if (type.isSynched())
             throw new IllegalStateException("something went wrong as DataAccess object is already synched!?");
     }
 
-    public DAType( MemRef memRef, boolean storing, boolean integ, boolean synched )
+    public DAType( MemRef memRef, boolean storing, boolean integ, boolean allowWrites, boolean synched )
     {
         this.memRef = memRef;
         this.storing = storing;
         this.integ = integ;
+        this.allowWrites = allowWrites;
         this.synched = synched;
     }
 
-    public DAType( MemRef memRef, boolean store, boolean integ )
-    {
-        this(memRef, store, integ, false);
-    }
-
     /**
      * Memory mapped or purely in memory? default is HEAP
      */
@@ -91,6 +94,11 @@ MemRef getMemRef()
         return memRef;
     }
 
+    public boolean isAllowWrites()
+    {
+        return allowWrites;
+    }
+
     /**
      * @return true if data resides in the JVM heap.
      */
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index d400014f72..b22c593851 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -23,7 +23,7 @@
  * Directory.create. Current implementations are RAM and memory mapped access.
  * <p/>
  * Life cycle: (1) object creation, (2) configuration (e.g. segment size), (3) create or
- * loadExisting, (4) usage, (5) close
+ * loadExisting, (4) usage and calling ensureCapacity if necessary, (5) close
  * <p/>
  * @author Peter Karich
  */
@@ -86,7 +86,7 @@
 
     /**
      * The first time you use a DataAccess object after configuring it you need to call this. After
-     * that first call you have to use incCapacity to ensure that enough space is reserved.
+     * that first call you have to use ensureCapacity to ensure that enough space is reserved.
      */
     @Override
     DataAccess create( long bytes );
@@ -98,7 +98,7 @@
      * @see #create(long)
      * @return true if size was increased
      */
-    boolean incCapacity( long bytes );
+    boolean ensureCapacity(long bytes);
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
@@ -127,5 +127,8 @@
      */
     int getSegments();
 
+    /**
+     * @return the data access type of this object.
+     */
     DAType getType();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Edge.java b/core/src/main/java/com/graphhopper/storage/Edge.java
deleted file mode 100644
index 6a4854908b..0000000000
--- a/core/src/main/java/com/graphhopper/storage/Edge.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-/**
- * 'Edges' do not exist as separate objects in GraphHopper for the storage as this would be too
- * memory intensive. Look into EdgeIterator and Graph.getEdges(index) instead. But it is used as
- * base class in all algorithms except the native BidirectionalDijkstra.
- * <p/>
- * @see EdgeEntry
- * @author Peter Karich
- */
-public class Edge implements Comparable<Edge>
-{
-    public int edge;
-    public int adjNode;
-    public double weight;
-
-    public Edge( int edgeId, int adjNode, double distance )
-    {
-        this.edge = edgeId;
-        this.adjNode = adjNode;
-        this.weight = distance;
-    }
-
-    @Override
-    public int compareTo( Edge o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return adjNode + " (" + edge + ") weight: " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index 82e9565e95..184a4ba9fe 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -22,13 +22,18 @@
  * <p/>
  * @author Peter Karich
  */
-public class EdgeEntry extends Edge implements Cloneable
+public class EdgeEntry implements Cloneable, Comparable<EdgeEntry>
 {
+    public int edge;
+    public int adjNode;
+    public double weight;
     public EdgeEntry parent;
 
-    public EdgeEntry( int edgeId, int adjNode, double distance )
+    public EdgeEntry( int edgeId, int adjNode, double weight )
     {
-        super(edgeId, adjNode, distance);
+        this.edge = edgeId;
+        this.adjNode = adjNode;
+        this.weight = weight;
     }
 
     @Override
@@ -50,4 +55,16 @@ public EdgeEntry cloneFull()
         }
         return de;
     }
+
+    @Override
+    public int compareTo( EdgeEntry o )
+    {
+        return Double.compare(weight, o.weight);
+    }
+
+    @Override
+    public String toString()
+    {
+        return adjNode + " (" + edge + ") weight: " + weight;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index b3cc92601b..68f12c3f56 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -120,8 +120,8 @@ public DataAccess find( String name, DAType type )
                     da = new RAMDataAccess(name, location, false, byteOrder);
             }
         } else if (type.isMMap())
-        {
-            da = new MMapDataAccess(name, location, byteOrder);
+        {            
+            da = new MMapDataAccess(name, location, byteOrder, type.isAllowWrites());
         } else
         {
             da = new UnsafeDataAccess(name, location, byteOrder);
@@ -150,7 +150,7 @@ public void clear()
             removeDA(da, da.getName(), false);
         }
         if (mmapDA != null)
-            mmapDA.cleanHack();
+            Helper.cleanHack();
         map.clear();
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index 63760d7f37..d3a50c7956 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -28,12 +28,12 @@
 class GHNodeAccess implements NodeAccess
 {
     private final GraphHopperStorage that;
-    private final boolean enabled3D;
+    private final boolean elevation;
 
-    public GHNodeAccess( GraphHopperStorage that, boolean enabled3D )
+    public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
     {
         this.that = that;
-        this.enabled3D = enabled3D;
+        this.elevation = withElevation;
     }
 
     @Override
@@ -73,7 +73,7 @@ public final void setNode( int index, double lat, double lon, double ele )
         if (lon < that.bounds.minLon)
             that.bounds.minLon = lon;
 
-        //set the default value for the additional field of this node
+        // set the default value for the additional field of this node
         if (that.extStorage.isRequireNodeField())
             that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
     }
@@ -93,7 +93,7 @@ public final double getLongitude( int nodeId )
     @Override
     public final double getElevation( int nodeId )
     {
-        if (!enabled3D)
+        if (!elevation)
             throw new IllegalStateException("Cannot access elevation - 3D is not enabled");
 
         return Helper.intToEle(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_ELE));
@@ -143,13 +143,13 @@ public final int getAdditionalNodeField( int index )
     @Override
     public final boolean is3D()
     {
-        return enabled3D;
+        return elevation;
     }
 
     @Override
     public int getDimension()
     {
-        if (enabled3D)
+        if (elevation)
             return 3;
         return 2;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index af0348cafa..c259176a2a 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -67,7 +67,7 @@
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
      * Integer.MIN_VALUE then the edge with undefined values for adjNode and baseNode will be
      * returned.
-     * @return an edge iterator over one element where the method next() will always return false.
+     * @return an edge iterator state
      * @throws IllegalStateException if edgeId is not valid
      */
     EdgeIteratorState getEdgeProps( int edgeId, int adjNode );
@@ -100,4 +100,9 @@
      * @return the specified GraphStorage g
      */
     Graph copyTo( Graph g );
+
+    /**
+     * @return the graph extension like a TurnCostExtension
+     */
+    GraphExtension getExtension();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index c6f3f41950..cfcbc63c83 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -31,7 +31,7 @@
     private boolean mmap;
     private boolean store;
     private boolean level;
-    private boolean is3D;
+    private boolean elevation;
     private long byteCapacity = 100;
 
     public GraphBuilder( EncodingManager encodingManager )
@@ -44,7 +44,7 @@ public GraphBuilder( EncodingManager encodingManager )
      * <p/>
      * @see LevelGraph
      */
-    GraphBuilder setLevelGraph( boolean level )
+    public GraphBuilder setLevelGraph( boolean level )
     {
         this.level = level;
         return this;
@@ -74,15 +74,15 @@ public GraphBuilder setExpectedSize( byte cap )
         return this;
     }
 
-    public GraphBuilder set3D( boolean is3D )
+    public GraphBuilder set3D( boolean withElevation )
     {
-        this.is3D = is3D;
+        this.elevation = withElevation;
         return this;
     }
 
-    public boolean is3D()
+    public boolean hasElevation()
     {
-        return is3D;
+        return elevation;
     }
 
     public LevelGraphStorage levelGraphBuild()
@@ -103,7 +103,7 @@ public LevelGraphStorage levelGraphCreate()
      * Afterwards you'll need to call GraphStorage.create to have a useable object. Better use
      * create.
      */
-    GraphStorage build()
+    public GraphStorage build()
     {
         Directory dir;
         if (mmap)
@@ -113,9 +113,14 @@ GraphStorage build()
 
         GraphStorage graph;
         if (level)
-            graph = new LevelGraphStorage(dir, encodingManager, is3D);
+            graph = new LevelGraphStorage(dir, encodingManager, elevation);
         else
-            graph = new GraphHopperStorage(dir, encodingManager, is3D);
+        {
+            if (encodingManager.needsTurnCostsSupport())
+                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
+            else
+                graph = new GraphHopperStorage(dir, encodingManager, elevation);
+        }
 
         return graph;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
similarity index 92%
rename from core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
rename to core/src/main/java/com/graphhopper/storage/GraphExtension.java
index 13747f7a16..56fc19d237 100644
--- a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,7 +21,7 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface ExtendedStorage
+public interface GraphExtension
 {
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
@@ -81,13 +81,13 @@
     /**
      * creates a copy of this extended storage
      */
-    ExtendedStorage copyTo( ExtendedStorage extStorage );
+    GraphExtension copyTo( GraphExtension extStorage );
 
     /**
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements ExtendedStorage
+    public class NoExtendedStorage implements GraphExtension
     {
 
         @Override
@@ -158,11 +158,16 @@ public long getCapacity()
         }
 
         @Override
-        public ExtendedStorage copyTo( ExtendedStorage extStorage )
+        public GraphExtension copyTo( GraphExtension extStorage )
         {
             // noop
             return extStorage;
         }
 
+        @Override
+        public String toString()
+        {
+            return "NoExt";
+        }       
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index d17ac4382c..545685726a 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -24,10 +24,18 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.*;
-import static com.graphhopper.util.Helper.nf;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
+import static com.graphhopper.util.Helper.nf;
+import java.io.UnsupportedEncodingException;
+
 /**
  * The main implementation which handles nodes and edges file format. It can be used with different
  * Directory implementations like RAMDirectory for fast access or via MMapDirectory for
@@ -88,17 +96,21 @@
     private final StorableProperties properties;
     private final BitUtil bitUtil;
     private boolean flagsSizeIsLong;
-    final ExtendedStorage extStorage;
+    final GraphExtension extStorage;
     private final NodeAccess nodeAccess;
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean enabledEle )
+    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
     {
-        this(dir, encodingManager, enabledEle, new ExtendedStorage.NoExtendedStorage());
+        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
     }
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D, ExtendedStorage extendedStorage )
+    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
+            GraphExtension extendedStorage )
     {
-        // here encoding manager can be null e.g. if we want to load existing graph
+        if (encodingManager == null)
+            throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
+                    + "If you need to parse EncodingManager configuration from existing graph use EncodingManager.create");
+
         this.encodingManager = encodingManager;
         this.extStorage = extendedStorage;
         this.dir = dir;
@@ -109,7 +121,7 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
         this.bounds = BBox.INVERSE.clone();
-        this.nodeAccess = new GHNodeAccess(this, enabled3D);
+        this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
 
@@ -178,8 +190,8 @@ public GraphStorage create( long byteCount )
         properties.create(100);
         extStorage.create(initSize);
 
-        properties.put("osmreader.bytesForFlags", encodingManager.getBytesForFlags());
-        properties.put("osmreader.acceptWay", encodingManager.toDetailsString());
+        properties.put("graph.bytesForFlags", encodingManager.getBytesForFlags());
+        properties.put("graph.flagEncoders", encodingManager.toDetailsString());
 
         properties.put("graph.byteOrder", dir.getByteOrder());
         properties.put("graph.dimension", nodeAccess.getDimension());
@@ -241,6 +253,10 @@ public BBox getBounds()
         return bounds;
     }
 
+    /**
+     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
+     * extend byte capacity
+     */
     final void ensureNodeIndex( int nodeIndex )
     {
         if (!initialized)
@@ -251,13 +267,15 @@ final void ensureNodeIndex( int nodeIndex )
 
         long oldNodes = nodeCount;
         nodeCount = nodeIndex + 1;
-        if (!nodes.incCapacity((long) nodeCount * nodeEntryBytes))
-            return;
+        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
+        if (capacityIncreased)
+        {
+            long newBytesCapacity = nodes.getCapacity();
+            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
+            if (removedNodes != null)
+                getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
+        }
 
-        long newBytesCapacity = nodes.getCapacity();
-        initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
-        if (removedNodes != null)
-            getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
     }
 
     /**
@@ -280,12 +298,12 @@ private void initNodeRefs( long oldCapacity, long newCapacity )
 
     private void ensureEdgeIndex( int edgeIndex )
     {
-        edges.incCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
+        edges.ensureCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
     }
 
     private void ensureGeometry( long bytePos, int byteLength )
     {
-        wayGeometry.incCapacity(bytePos + byteLength);
+        wayGeometry.ensureCapacity(bytePos + byteLength);
     }
 
     @Override
@@ -294,6 +312,11 @@ public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirect
         return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
     }
 
+    /**
+     * Create edge between nodes a and b
+     * <p>
+     * @return EdgeIteratorState of newly created edge
+     */
     @Override
     public EdgeIteratorState edge( int a, int b )
     {
@@ -319,17 +342,17 @@ private int nextGeoRef( int arrayLength )
     }
 
     /**
-     * @return edgeIdPointer which is edgeId * edgeEntrySize
+     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
      */
     int internalEdgeAdd( int fromNodeId, int toNodeId )
     {
-        int newOrExistingEdge = nextEdge();
-        writeEdge(newOrExistingEdge, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newOrExistingEdge);
+        int newEdgeId = nextEdge();
+        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        connectNewEdge(fromNodeId, newEdgeId);
         if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newOrExistingEdge);
+            connectNewEdge(toNodeId, newEdgeId);
 
-        return newOrExistingEdge;
+        return newEdgeId;
     }
 
     // for test only
@@ -338,6 +361,11 @@ void setEdgeCount( int cnt )
         edgeCount = cnt;
     }
 
+    /**
+     * Determine next free edgeId and ensure byte capacity to store edge
+     * <p>
+     * @return next free edgeId
+     */
     private int nextEdge()
     {
         int nextEdge = edgeCount;
@@ -481,7 +509,7 @@ public AllEdgeIterator()
         }
 
         @Override
-        public int getMaxId()
+        public int getCount()
         {
             return edgeCount;
         }
@@ -547,7 +575,8 @@ public EdgeIteratorState setAdditionalField( int value )
         @Override
         public EdgeIteratorState setFlags( long flags )
         {
-            throw new UnsupportedOperationException("Not supported yet.");
+            GraphHopperStorage.this.setFlags(edgePointer, reverse, flags);
+            return this;
         }
 
         @Override
@@ -586,8 +615,11 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
@@ -661,7 +693,7 @@ private long getFlags( long edgePointer, boolean reverse )
         if (flagsSizeIsLong)
         {
             int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            res = ((long) high << 32) | (low & 0xFFFFFFFFL);
+            res = bitUtil.combineIntsToLong(low, high);
         }
         if (reverse)
             return reverseFlags(edgePointer, res);
@@ -678,12 +710,10 @@ private void setFlags( long edgePointer, boolean reverse, long flags )
         if (reverse)
             flags = reverseFlags(edgePointer, flags);
 
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
         if (flagsSizeIsLong)
-        {
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
-            edges.setInt(edgePointer + E_FLAGS + 4, (int) (flags >> 32));
-        } else
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
     }
 
     protected class SingleEdge extends EdgeIterable
@@ -776,14 +806,6 @@ public final boolean next()
                             + ", " + edgePointer + ", " + edgeId);
 
                 foundNext = filter == null || filter.accept(this);
-//
-//                if(foundNext && nextEdge != EdgeIterator.NO_EDGE && extStorage instanceof TurnCostStorage){
-//                    int turncosts = ((TurnCostStorage) extStorage).getTurnCosts(baseNode, edgeId, nextEdge);
-//                    if(turncosts == Integer.MAX_VALUE){
-//                        foundNext = false;
-//                    }
-//                }
-
                 if (foundNext)
                     break;
             }
@@ -839,14 +861,14 @@ public EdgeIteratorState setAdditionalField( int value )
         }
 
         @Override
-        public final EdgeIteratorState setWayGeometry( PointList pillarNodes )
+        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
         {
             GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
             return this;
         }
 
         @Override
-        public final PointList fetchWayGeometry( int mode )
+        public PointList fetchWayGeometry( int mode )
         {
             return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
         }
@@ -867,8 +889,11 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
@@ -979,7 +1004,6 @@ private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode,
         {
             geoRef *= 4;
             count = wayGeometry.getInt(geoRef);
-            wayGeometry.getInt(geoRef);
 
             geoRef += 4;
             bytes = new byte[count * nodeAccess.getDimension() * 4];
@@ -1115,7 +1139,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1265,7 +1289,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1352,28 +1376,15 @@ private static boolean isTestingEnabled()
     public boolean loadExisting()
     {
         checkInit();
-        if (edges.loadExisting())
+        if (nodes.loadExisting())
         {
-            if (!nodes.loadExisting())
-                throw new IllegalStateException("cannot load nodes. corrupt file or directory? " + dir);
-
-            if (!wayGeometry.loadExisting())
-                throw new IllegalStateException("cannot load geometry. corrupt file or directory? " + dir);
-
-            if (!nameIndex.loadExisting())
-                throw new IllegalStateException("cannot load name index. corrupt file or directory? " + dir);
-
-            if (!extStorage.loadExisting())
-            {
-                throw new IllegalStateException("cannot load extended storage. corrupt file or directory? " + dir);
-            }
-
             String acceptStr = "";
             if (properties.loadExisting())
             {
                 properties.checkVersions(false);
                 // check encoding for compatiblity
-                acceptStr = properties.get("osmreader.acceptWay");
+                acceptStr = properties.get("graph.flagEncoders");
+
             } else
                 throw new IllegalStateException("cannot load properties. corrupt file or directory? " + dir);
 
@@ -1384,7 +1395,7 @@ public boolean loadExisting()
                             + dir.getLocation());
 
                 int bytesForFlags = 4;
-                if ("8".equals(properties.get("osmreader.bytesForFlags")))
+                if ("8".equals(properties.get("graph.bytesForFlags")))
                     bytesForFlags = 8;
                 encodingManager = new EncodingManager(acceptStr, bytesForFlags);
             } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
@@ -1401,6 +1412,18 @@ public boolean loadExisting()
             if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
                 throw new IllegalStateException("Configured byteOrder (" + dim + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
 
+            if (!edges.loadExisting())
+                throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
+
+            if (!wayGeometry.loadExisting())
+                throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
+
+            if (!nameIndex.loadExisting())
+                throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
+
+            if (!extStorage.loadExisting())
+                throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
+
             // first define header indices of this storage
             initStorage();
 
@@ -1451,7 +1474,7 @@ protected void initStorage()
     protected int loadNodesHeader()
     {
         int hash = nodes.getHeader(0);
-        if (hash != getClass().getName().hashCode())
+        if (hash != stringHashCode(getClass().getName()))
             throw new IllegalStateException("Cannot load the graph when using instance of "
                     + getClass().getName() + " and location: " + dir);
 
@@ -1466,7 +1489,7 @@ protected int loadNodesHeader()
 
     protected int setNodesHeader()
     {
-        nodes.setHeader(0, getClass().getName().hashCode());
+        nodes.setHeader(0, stringHashCode(getClass().getName()));
         nodes.setHeader(1 * 4, nodeEntryBytes);
         nodes.setHeader(2 * 4, nodeCount);
         nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
@@ -1530,7 +1553,14 @@ public void close()
         extStorage.close();
     }
 
-    public ExtendedStorage getExtendedStorage()
+    @Override
+    public boolean isClosed()
+    {
+        return nodes.isClosed();
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
         return extStorage;
     }
@@ -1547,11 +1577,23 @@ public String toDetailsString()
     {
         return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
                 + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: - (" + nameIndex.getCapacity() / Helper.MB + "), "
+                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
                 + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
                 + "bounds:" + bounds;
     }
 
+    // workaround for graphhopper-ios https://github.com/google/j2objc/issues/423
+    private int stringHashCode( String str )
+    {
+        try
+        {
+            return java.util.Arrays.hashCode(str.getBytes("UTF-8"));
+        } catch (UnsupportedEncodingException ex)
+        {
+            throw new UnsupportedOperationException(ex);
+        }
+    }
+
     @Override
     public String toString()
     {
@@ -1559,6 +1601,7 @@ public String toString()
                 + "|" + encodingManager
                 + "|" + getDirectory().getDefaultType()
                 + "|" + nodeAccess.getDimension() + "D"
+                + ((extStorage == null) ? "" : "|" + extStorage)
                 + "|" + getProperties().versionsToString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index 775f84a924..1b666abd0c 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -21,11 +21,7 @@
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipExplorer;
-import com.graphhopper.util.EdgeSkipIterator;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.*;
 
 /**
  * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
@@ -213,6 +209,38 @@ public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
 //            setSkippedEdges(eSkip.getSkippedEdge1(), eSkip.getSkippedEdge2());
             return edge;
         }
+
+        @Override
+        public String getName()
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call getName on shortcut " + getEdge());
+            return super.getName();
+        }
+
+        @Override
+        public EdgeIteratorState setName( String name )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setName on shortcut " + getEdge());
+            return super.setName(name);
+        }
+
+        @Override
+        public PointList fetchWayGeometry( int mode )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call fetchWayGeometry on shortcut " + getEdge());
+            return super.fetchWayGeometry(mode);
+        }
+
+        @Override
+        public EdgeIteratorState setWayGeometry( PointList list )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setWayGeometry on shortcut " + getEdge());
+            return super.setWayGeometry(list);
+        }
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/Lock.java b/core/src/main/java/com/graphhopper/storage/Lock.java
new file mode 100644
index 0000000000..ca9c118e67
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+/**
+ * A write lock. Influenced by Lucene code
+ * <p>
+ * @author Peter Karich
+ */
+public interface Lock
+{
+    String getName();
+
+    boolean tryLock();
+
+    boolean isLocked();
+
+    void release();
+    
+    Exception getObtainFailedReason();
+}
diff --git a/core/src/main/java/com/graphhopper/storage/LockFactory.java b/core/src/main/java/com/graphhopper/storage/LockFactory.java
new file mode 100644
index 0000000000..a4b276c0eb
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/LockFactory.java
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.io.File;
+
+/**
+ * @author Peter Karich
+ */
+public interface LockFactory
+{
+    void setLockDir( File lockDir );
+
+    /**
+     * This creates a file for write or read locks depending on the specified writeAccess property.
+     * Important note: even for read locks we need write access to the underlying filesystem in
+     * order to avoid writes from other processes.
+     */
+    Lock create( String fileName, boolean writeAccess );
+
+    /**
+     * Removes the specified lock. Note: on windows we cannot forcefully remove an unreleased native
+     * lock
+     */
+    void forceRemove( String fileName, boolean writeAccess );
+}
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index 1896d39774..324168122c 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -42,11 +42,12 @@
     private RandomAccessFile raFile;
     private List<ByteBuffer> segments = new ArrayList<ByteBuffer>();
     private boolean cleanAndRemap = false;
-    private transient boolean closed = false;
+    private final boolean allowWrites;
 
-    MMapDataAccess( String name, String location, ByteOrder order )
+    MMapDataAccess( String name, String location, ByteOrder order, boolean allowWrites )
     {
         super(name, location, order);
+        this.allowWrites = allowWrites;
     }
 
     MMapDataAccess cleanAndRemap( boolean cleanAndRemap )
@@ -65,7 +66,7 @@ private void initRandomAccessFile()
         try
         {
             // raFile necessary for loadExisting and create
-            raFile = new RandomAccessFile(getFullName(), "rw");
+            raFile = new RandomAccessFile(getFullName(), allowWrites ? "rw" : "r");
         } catch (IOException ex)
         {
             throw new RuntimeException(ex);
@@ -82,7 +83,7 @@ public MMapDataAccess create( long bytes )
         initRandomAccessFile();
         bytes = Math.max(10 * 4, bytes);
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(bytes);
+        ensureCapacity(bytes);
         return this;
     }
 
@@ -98,7 +99,7 @@ public DataAccess copyTo( DataAccess da )
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity( long bytes )
     {
         return mapIt(HEADER_OFFSET, bytes, true);
     }
@@ -134,7 +135,7 @@ protected boolean mapIt( long offset, long byteCount, boolean clearNew )
             {
                 newSegments = segmentsToMap;
                 clean(0, segments.size());
-                cleanHack();
+                Helper.cleanHack();
                 segments.clear();
             } else
             {
@@ -174,13 +175,15 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         {
             try
             {
-                buf = raFile.getChannel().map(FileChannel.MapMode.READ_WRITE, offset, byteCount);
+                buf = raFile.getChannel().map(
+                        allowWrites ? FileChannel.MapMode.READ_WRITE : FileChannel.MapMode.READ_ONLY,
+                        offset, byteCount);
                 break;
             } catch (IOException tmpex)
             {
                 ioex = tmpex;
                 trial++;
-                cleanHack();
+                Helper.cleanHack();
                 try
                 {
                     // mini sleep to let JVM do unmapping
@@ -224,8 +227,8 @@ public boolean loadExisting()
         if (segments.size() > 0)
             throw new IllegalStateException("already initialized");
 
-        if (closed)
-            return false;
+        if (isClosed())
+            throw new IllegalStateException("already closed");
 
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
@@ -249,10 +252,9 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        if (closed)
-        {
+        if (isClosed())
             throw new IllegalStateException("already closed");
-        }
+
         try
         {
             if (!segments.isEmpty() && segments.get(0) instanceof MappedByteBuffer)
@@ -277,6 +279,7 @@ public void flush()
     @Override
     public void close()
     {
+        super.close();
         close(true);
     }
 
@@ -290,14 +293,7 @@ void close( boolean forceClean )
         segments.clear();
         Helper.close(raFile);
         if (forceClean)
-            cleanHack();
-        closed = true;
-    }
-
-    void cleanHack()
-    {
-        // trying to force the release of the mapped ByteBuffer
-        System.gc();
+            Helper.cleanHack();
     }
 
     @Override
@@ -425,7 +421,7 @@ public void trimTo( long capacity )
         }
 
         clean(remainingSegNo, segments.size());
-        cleanHack();
+        Helper.cleanHack();
         segments = new ArrayList<ByteBuffer>(segments.subList(0, remainingSegNo));
 
         try
@@ -452,7 +448,7 @@ boolean releaseSegment( int segNumber )
 
         Helper.cleanMappedByteBuffer(segment);
         segments.set(segNumber, null);
-        cleanHack();
+        Helper.cleanHack();
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
new file mode 100644
index 0000000000..11f6615ac2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -0,0 +1,253 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.Helper;
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileLock;
+
+/**
+ * Creates a write lock file. Influenced by Lucene code
+ * <p>
+ * @author Peter Karich
+ */
+public class NativeFSLockFactory implements LockFactory
+{
+    private File lockDir;
+
+    public NativeFSLockFactory()
+    {
+    }
+
+    public NativeFSLockFactory( File dir )
+    {
+        this.lockDir = dir;
+    }
+
+    @Override
+    public void setLockDir( File lockDir )
+    {
+        this.lockDir = lockDir;
+    }
+
+    @Override
+    public synchronized Lock create( String fileName, boolean writeAccess )
+    {
+        if (lockDir == null)
+            throw new RuntimeException("Set lockDir before creating " + (writeAccess ? "write" : "read") + " locks");
+
+        return new NativeLock(lockDir, fileName, writeAccess);
+    }
+
+    @Override
+    public synchronized void forceRemove( String fileName, boolean writeAccess )
+    {
+        if (lockDir.exists())
+        {
+            create(fileName, writeAccess).release();
+            File lockFile = new File(lockDir, fileName);
+            if (lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot delete " + lockFile);
+        }
+    }
+
+    static class NativeLock implements Lock
+    {
+        private RandomAccessFile tmpRaFile;
+        private FileChannel tmpChannel;
+        private FileLock tmpLock;
+
+        private final String name;
+        private final File lockDir;
+        private final File lockFile;
+        private final boolean writeLock;
+
+        private Exception failedReason;
+
+        public NativeLock( File lockDir, String fileName, boolean writeLock )
+        {
+            this.name = fileName;
+            this.lockDir = lockDir;
+            this.lockFile = new File(lockDir, fileName);
+            this.writeLock = writeLock;
+        }
+
+        @Override
+        public synchronized boolean tryLock()
+        {
+            // already locked
+            if (lockExists())
+                return false;
+
+            // on-the-fly: make sure directory exists
+            if (!lockDir.exists())
+            {
+                if (!lockDir.mkdirs())
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+            }
+
+            if (!lockDir.isDirectory())
+                throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
+
+            try
+            {
+                failedReason = null;
+                // we need write access even for read locks - in order to create the lock file!
+                tmpRaFile = new RandomAccessFile(lockFile, "rw");
+            } catch (IOException ex)
+            {
+                failedReason = ex;
+                return false;
+            }
+
+            try
+            {
+                tmpChannel = tmpRaFile.getChannel();
+                try
+                {
+                    tmpLock = tmpChannel.tryLock(0, Long.MAX_VALUE, !writeLock);
+                    // OverlappingFileLockException is not an IOException!
+                } catch (Exception ex)
+                {
+                    failedReason = ex;
+                } finally
+                {
+                    if (tmpLock == null)
+                    {
+                        Helper.close(tmpChannel);
+                        tmpChannel = null;
+                    }
+                }
+            } finally
+            {
+                if (tmpChannel == null)
+                {
+                    Helper.close(tmpRaFile);
+                    tmpRaFile = null;
+                }
+            }
+            return lockExists();
+        }
+
+        private synchronized boolean lockExists()
+        {
+            return tmpLock != null;
+        }
+
+        @Override
+        public synchronized boolean isLocked()
+        {
+            if (!lockFile.exists())
+                return false;
+
+            if (lockExists())
+                return true;
+
+            try
+            {
+                boolean obtained = tryLock();
+                if (obtained)
+                    release();
+                return !obtained;
+            } catch (Exception ex)
+            {
+                return false;
+            }
+        }
+
+        @Override
+        public synchronized void release()
+        {
+            if (lockExists())
+            {
+                try
+                {
+                    failedReason = null;
+                    tmpLock.release();
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException(ex);
+                } finally
+                {
+                    tmpLock = null;
+                    try
+                    {
+                        tmpChannel.close();
+                    } catch (Exception ex)
+                    {
+                        throw new RuntimeException(ex);
+                    } finally
+                    {
+                        tmpChannel = null;
+                        try
+                        {
+                            tmpRaFile.close();
+                        } catch (Exception ex)
+                        {
+                            throw new RuntimeException(ex);
+                        } finally
+                        {
+                            tmpRaFile = null;
+                        }
+                    }
+                }
+                lockFile.delete();
+            }
+        }
+
+        @Override
+        public String getName()
+        {
+            return name;
+        }
+
+        @Override
+        public Exception getObtainFailedReason()
+        {
+            return failedReason;
+        }
+
+        @Override
+        public String toString()
+        {
+            return lockFile.toString();
+        }
+    }
+
+    public static void main( String[] args ) throws IOException
+    {
+        // trying FileLock mechanics in different processes
+        File file = new File("tmp.lock");
+
+        file.createNewFile();
+        FileChannel channel = new RandomAccessFile(file, "r").getChannel();
+        
+        boolean shared = true;
+        FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
+
+        System.out.println("locked " + lock1);
+        System.in.read();
+
+        System.out.println("release " + lock1);
+        lock1.release();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 495d795b8d..3fe15fffc0 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -32,9 +32,7 @@
  */
 public class RAMDataAccess extends AbstractDataAccess
 {
-
     private byte[][] segments = new byte[0][];
-    private boolean closed = false;
     private boolean store;
 
     RAMDataAccess( String name, String location, boolean store, ByteOrder order )
@@ -89,12 +87,12 @@ public RAMDataAccess create( long bytes )
 
         // initialize transient values
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(Math.max(10 * 4, bytes));
+        ensureCapacity(Math.max(10 * 4, bytes));
         return this;
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity(long bytes)
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -131,7 +129,10 @@ public boolean loadExisting()
         if (segments.length > 0)
             throw new IllegalStateException("already initialized");
 
-        if (!store || closed)
+        if (isClosed())
+            throw new IllegalStateException("already closed");
+
+        if (!store)
             return false;
 
         File file = new File(getFullName());
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index e733417a87..7d8f66631c 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -90,12 +90,12 @@ public RAMIntDataAccess create( long bytes )
 
         // initialize transient values
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(Math.max(10 * 4, bytes));
+        ensureCapacity(Math.max(10 * 4, bytes));
         return this;
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity(long bytes)
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -130,13 +130,14 @@ public boolean incCapacity( long bytes )
     public boolean loadExisting()
     {
         if (segments.length > 0)
-        {
             throw new IllegalStateException("already initialized");
-        }
-        if (!store || closed)
-        {
+
+        if (isClosed())
+            throw new IllegalStateException("already closed");
+
+        if (!store)
             return false;
-        }
+
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
         {
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
new file mode 100644
index 0000000000..54182e6f99
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -0,0 +1,138 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Creates a write lock file. Influenced by Lucene code
+ * <p>
+ * @author Peter Karich
+ */
+public class SimpleFSLockFactory implements LockFactory
+{
+    private File lockDir;
+
+    public SimpleFSLockFactory()
+    {
+    }
+
+    public SimpleFSLockFactory( File dir )
+    {
+        this.lockDir = dir;
+    }
+
+    @Override
+    public void setLockDir( File lockDir )
+    {
+        this.lockDir = lockDir;
+    }
+
+    @Override
+    public synchronized Lock create( String fileName, boolean writeAccess )
+    {
+        // TODO no read access-only support
+        if (lockDir == null)
+            throw new RuntimeException("Set lockDir before creating locks");
+
+        return new SimpleLock(lockDir, fileName);
+    }
+
+    @Override
+    public synchronized void forceRemove( String fileName, boolean writeAccess )
+    {
+        if (lockDir.exists())
+        {
+            File lockFile = new File(lockDir, fileName);
+            if (lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot delete " + lockFile);
+        }
+    }
+
+    static class SimpleLock implements Lock
+    {
+        private final File lockDir;
+        private final File lockFile;
+        private final String name;
+        private IOException failedReason;
+
+        public SimpleLock( File lockDir, String fileName )
+        {
+            this.name = fileName;
+            this.lockDir = lockDir;
+            this.lockFile = new File(lockDir, fileName);
+        }
+
+        @Override
+        public synchronized boolean tryLock()
+        {
+            // make sure directory exists, do it on-the-fly (not possible when setLockDir is called)
+            if (!lockDir.exists())
+            {
+                if (!lockDir.mkdirs())
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+            }
+
+            // this test can only be performed after the dir has created!
+            if (!lockDir.isDirectory())
+                throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
+
+            try
+            {
+                return lockFile.createNewFile();
+            } catch (IOException ex)
+            {
+                failedReason = ex;
+                return false;
+            }
+        }
+
+        @Override
+        public synchronized boolean isLocked()
+        {
+            return lockFile.exists();
+        }
+
+        @Override
+        public synchronized void release()
+        {
+            if (isLocked() && lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot release lock file: " + lockFile);
+        }
+
+        @Override
+        public String getName()
+        {
+            return name;
+        }
+
+        @Override
+        public synchronized Exception getObtainFailedReason()
+        {
+            return failedReason;
+        }
+
+        @Override
+        public String toString()
+        {
+            return lockFile.toString();
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/Storable.java b/core/src/main/java/com/graphhopper/storage/Storable.java
index ffbcf5b6a9..8acef8afc8 100644
--- a/core/src/main/java/com/graphhopper/storage/Storable.java
+++ b/core/src/main/java/com/graphhopper/storage/Storable.java
@@ -23,10 +23,16 @@
  * Interface for a storage abstraction. Currently is serves just the purpose to ensure the same
  * methods and names through all kind of 'storable' things in graphhopper.
  * <p/>
- * Then the lifecycle is identical for all such objects: <ol> <li>object creation via new</li>
- * <li>optional configuration via additional setters and getters</li>
- * <li>if(!storable.loadExisting()) storable.create()</li> <li>usage and flush() calls
- * in-between</li> <li>close which does no flush()</li> <ol>
+ * Then the lifecycle is identical for all such objects:
+ * <ol>
+ * <li>object creation via new</li>
+ * <li>optional configuration via additional setters and getters which are not in this
+ * interface</li>
+ * <li>if(!storable.loadExisting()) storable.create()</li>
+ * <li>usage storable and optional flush() calls in-between. Keep in mind that some data structure
+ * could require a call to increase memory while usage. E.g. DataAccess.ensureCapacity()</li>
+ * <li>Finally do close() which does no flush()</li>
+ * </ol>
  * <p/>
  * @author Peter Karich
  */
@@ -56,6 +62,8 @@
     @Override
     void close();
 
+    boolean isClosed();
+
     /**
      * @return the allocated storage size in bytes
      */
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 6efea99a49..7c8dec0694 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -53,7 +53,7 @@ public boolean loadExisting()
         da.getBytes(0, bytes, len);
         try
         {
-            Helper.loadProperties(map, new StringReader(new String(bytes, "UTF-8")));
+            Helper.loadProperties(map, new StringReader(new String(bytes, Helper.UTF_CS)));
             return true;
         } catch (IOException ex)
         {
@@ -69,7 +69,7 @@ public void flush()
             StringWriter sw = new StringWriter();
             Helper.saveProperties(map, sw);
             // TODO at the moment the size is limited to da.segmentSize() !
-            byte[] bytes = sw.toString().getBytes("UTF-8");
+            byte[] bytes = sw.toString().getBytes(Helper.UTF_CS);
             da.setBytes(0, bytes, bytes.length);
             da.flush();
         } catch (IOException ex)
@@ -109,6 +109,12 @@ public void close()
         da.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return da.isClosed();
+    }        
+
     @Override
     public StorableProperties create( long size )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 93b0336535..841974263f 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -100,9 +100,9 @@ public synchronized DataAccess create( long bytes )
     }
 
     @Override
-    public synchronized boolean incCapacity( long bytes )
+    public synchronized boolean ensureCapacity(long bytes)
     {
-        return inner.incCapacity(bytes);
+        return inner.ensureCapacity(bytes);
     }
 
     @Override
@@ -153,6 +153,12 @@ public synchronized void close()
         inner.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return inner.isClosed();
+    }
+
     @Override
     public synchronized long getCapacity()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
new file mode 100644
index 0000000000..152cc78179
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -0,0 +1,257 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.EdgeIterator;
+
+/**
+ * Holds turn cost tables for each node. The additional field of a node will be used to point
+ * towards the first entry within a node cost table to identify turn restrictions, or later, turn
+ * getCosts.
+ * <p>
+ * @author Karl Hbner
+ * @author Peter Karich
+ */
+public class TurnCostExtension implements GraphExtension
+{
+    /* pointer for no cost entry */
+    private final int NO_TURN_ENTRY = -1;
+    private final long EMPTY_FLAGS = 0L;
+
+    /*
+     * items in turn cost tables: edge from, edge to, getCosts, pointer to next
+     * cost entry of same node
+     */
+    private final int TC_FROM, TC_TO, TC_FLAGS, TC_NEXT;
+
+    private DataAccess turnCosts;
+    private int turnCostsEntryIndex = -4;
+    private int turnCostsEntryBytes;
+    private int turnCostsCount;
+
+    private GraphStorage graph;
+    private NodeAccess nodeAccess;
+
+    public TurnCostExtension()
+    {
+        TC_FROM = nextTurnCostEntryIndex();
+        TC_TO = nextTurnCostEntryIndex();
+        TC_FLAGS = nextTurnCostEntryIndex();
+        TC_NEXT = nextTurnCostEntryIndex();
+        turnCostsEntryBytes = turnCostsEntryIndex + 4;
+        turnCostsCount = 0;
+    }
+
+    @Override
+    public void init( GraphStorage graph )
+    {
+        if (turnCostsCount > 0)
+            throw new AssertionError("The turn cost storage must be initialized only once.");
+
+        this.graph = graph;
+        this.nodeAccess = graph.getNodeAccess();
+        this.turnCosts = this.graph.getDirectory().find("turnCosts");
+    }
+
+    private int nextTurnCostEntryIndex()
+    {
+        turnCostsEntryIndex += 4;
+        return turnCostsEntryIndex;
+    }
+
+    @Override
+    public void setSegmentSize( int bytes )
+    {
+        turnCosts.setSegmentSize(bytes);
+    }
+
+    @Override
+    public void create( long initBytes )
+    {
+        turnCosts.create((long) initBytes * turnCostsEntryBytes);
+    }
+
+    @Override
+    public void flush()
+    {
+        turnCosts.setHeader(0, turnCostsEntryBytes);
+        turnCosts.setHeader(1 * 4, turnCostsCount);
+        turnCosts.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        turnCosts.close();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return turnCosts.getCapacity();
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!turnCosts.loadExisting())
+            return false;
+
+        turnCostsEntryBytes = turnCosts.getHeader(0);
+        turnCostsCount = turnCosts.getHeader(4);
+        return true;
+    }
+
+    /**
+     * This method adds a new entry which is a turn restriction or cost information via the
+     * turnFlags.
+     */
+    public void addTurnInfo( int from, int viaNode, int to, long turnFlags )
+    {
+        // no need to store turn information
+        if (turnFlags == EMPTY_FLAGS)
+            return;
+
+        // append
+        int newEntryIndex = turnCostsCount;
+        turnCostsCount++;
+        ensureTurnCostIndex(newEntryIndex);
+
+        // determine if we already have an cost entry for this node
+        int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
+        if (previousEntryIndex == NO_TURN_ENTRY)
+        {
+            // set cost-pointer to this new cost entry
+            nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);
+        } else
+        {
+            int i = 0;
+            int tmp = previousEntryIndex;
+            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_TURN_ENTRY)
+            {
+                previousEntryIndex = tmp;
+                // search for the last added cost entry
+                if (i++ > 1000)
+                {
+                    throw new IllegalStateException("Something unexpected happened. A node probably will not have 1000+ relations.");
+                }
+            }
+            // set next-pointer to this new cost entry
+            turnCosts.setInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT, newEntryIndex);
+        }
+        // add entry
+        long costsBase = (long) newEntryIndex * turnCostsEntryBytes;
+        turnCosts.setInt(costsBase + TC_FROM, from);
+        turnCosts.setInt(costsBase + TC_TO, to);
+        turnCosts.setInt(costsBase + TC_FLAGS, (int) turnFlags);
+        // next-pointer is NO_TURN_ENTRY
+        turnCosts.setInt(costsBase + TC_NEXT, NO_TURN_ENTRY);
+    }
+
+    /**
+     * @return turn flags of the specified node and edge properties.
+     */
+    public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
+            throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
+        if (nodeVia < 0)
+            throw new IllegalArgumentException("via node cannot be negative");
+
+        return nextCostFlags(edgeFrom, nodeVia, edgeTo);
+    }
+
+    private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
+        int i = 0;
+        for (; i < 1000; i++)
+        {
+            if (turnCostIndex == NO_TURN_ENTRY)
+                break;
+            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
+            if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM))
+            {
+                if (edgeTo == turnCosts.getInt(turnCostPtr + TC_TO))
+                    return turnCosts.getInt(turnCostPtr + TC_FLAGS);
+            }
+
+            int nextTurnCostIndex = turnCosts.getInt(turnCostPtr + TC_NEXT);
+            if (nextTurnCostIndex == turnCostIndex)
+                throw new IllegalStateException("something went wrong: next entry would be the same");
+
+            turnCostIndex = nextTurnCostIndex;
+        }
+        // so many turn restrictions on one node? here is something wrong
+        if (i > 1000)
+            throw new IllegalStateException("something went wrong: there seems to be no end of the turn cost-list!?");
+        return EMPTY_FLAGS;
+    }
+
+    private void ensureTurnCostIndex( int nodeIndex )
+    {
+        turnCosts.ensureCapacity(((long) nodeIndex + 4) * turnCostsEntryBytes);
+    }
+
+    @Override
+    public boolean isRequireNodeField()
+    {
+        //we require the additional field in the graph to point to the first entry in the node table
+        return true;
+    }
+
+    @Override
+    public boolean isRequireEdgeField()
+    {
+        return false;
+    }
+
+    @Override
+    public int getDefaultNodeFieldValue()
+    {
+        return NO_TURN_ENTRY;
+    }
+
+    @Override
+    public int getDefaultEdgeFieldValue()
+    {
+        throw new UnsupportedOperationException("Not supported by this storage");
+    }
+
+    @Override
+    public GraphExtension copyTo( GraphExtension clonedStorage )
+    {
+        if (!(clonedStorage instanceof TurnCostExtension))
+        {
+            throw new IllegalStateException("the extended storage to clone must be the same");
+        }
+
+        TurnCostExtension clonedTC = (TurnCostExtension) clonedStorage;
+
+        turnCosts.copyTo(clonedTC.turnCosts);
+        clonedTC.turnCostsCount = turnCostsCount;
+
+        return clonedStorage;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "turnCost";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java b/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
deleted file mode 100644
index a9d67d5f90..0000000000
--- a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.TurnCostIterator;
-
-/**
- * Holds turn cost tables for each node. The additional field of a node will be used to point
- * towards the first entry within a node cost table to identify turn restrictions, or later, turn
- * costs.
- * <p>
- * @author karl.huebner
- */
-public class TurnCostStorage implements ExtendedStorage
-{
-
-    /* pointer for no cost entry */
-    protected final int NO_COST_ENTRY = -1;
-
-    /*
-     * items in turn cost tables: edge from, edge to, costs, pointer to next
-     * cost entry of same node
-     */
-    protected final int TC_FROM, TC_TO, TC_COSTS, TC_NEXT;
-
-    protected DataAccess turnCosts;
-    protected int turnCostsEntryIndex = -4;
-    protected int turnCostsEntryBytes;
-    protected int turnCostsCount;
-
-    private GraphStorage graph;
-    private NodeAccess nodeAccess;
-
-    public TurnCostStorage()
-    {
-        TC_FROM = nextTurnCostsEntryIndex();
-        TC_TO = nextTurnCostsEntryIndex();
-        TC_COSTS = nextTurnCostsEntryIndex();
-        TC_NEXT = nextTurnCostsEntryIndex();
-        turnCostsEntryBytes = turnCostsEntryIndex + 4;
-        turnCostsCount = 0;
-    }
-
-    @Override
-    public void init( GraphStorage graph )
-    {
-        if (turnCostsCount > 0)
-            throw new AssertionError("The turn cost storage must be initialized only once.");
-
-        this.graph = graph;
-        this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turnCosts");
-    }
-
-    protected final int nextTurnCostsEntryIndex()
-    {
-        turnCostsEntryIndex += 4;
-        return turnCostsEntryIndex;
-    }
-
-    @Override
-    public void setSegmentSize( int bytes )
-    {
-        turnCosts.setSegmentSize(bytes);
-    }
-
-    @Override
-    public void create( long initBytes )
-    {
-        turnCosts.create((long) initBytes * turnCostsEntryBytes);
-    }
-
-    @Override
-    public void flush()
-    {
-        turnCosts.setHeader(0, turnCostsEntryBytes);
-        turnCosts.setHeader(1 * 4, turnCostsCount);
-        turnCosts.flush();
-    }
-
-    @Override
-    public void close()
-    {
-        turnCosts.close();
-    }
-
-    @Override
-    public long getCapacity()
-    {
-        return turnCosts.getCapacity();
-    }
-
-    public int entries()
-    {
-        return turnCostsCount;
-    }
-
-    @Override
-    public boolean loadExisting()
-    {
-        if (!turnCosts.loadExisting())
-            throw new IllegalStateException("cannot load node costs. corrupt file or directory? " + graph.getDirectory());
-
-        turnCostsEntryBytes = turnCosts.getHeader(0);
-        turnCostsCount = turnCosts.getHeader(4);
-        return true;
-    }
-
-    private int getCostTableAdress( int index )
-    {
-        if (index >= graph.getNodes() || index < 0)
-            return NO_COST_ENTRY;
-
-        return nodeAccess.getAdditionalNodeField(index);
-    }
-
-    public void setTurnCosts( int nodeIndex, int from, int to, int flags )
-    {
-        if (flags == 0)
-        {
-            //no need to store turn costs
-            return;
-        }
-
-        // append
-        int newEntryIndex = turnCostsCount;
-        turnCostsCount++;
-        ensureTurnCostsIndex(newEntryIndex);
-
-        // determine if we already have an cost entry for this node
-        int previousEntryIndex = getCostTableAdress(nodeIndex);
-        if (previousEntryIndex == NO_COST_ENTRY)
-        {
-            // set cost-pointer to this new cost entry
-            nodeAccess.setAdditionalNodeField(nodeIndex, newEntryIndex);
-        } else
-        {
-            int i = 0;
-            int tmp = previousEntryIndex;
-            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_COST_ENTRY)
-            {
-                previousEntryIndex = tmp;
-                // search for the last added cost entry
-                if (i++ > 1000)
-                {
-                    throw new IllegalStateException("Something unexpected happened. A node probably will not have 1000+ relations.");
-                }
-            }
-            // set next-pointer to this new cost entry
-            turnCosts.setInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT, newEntryIndex);
-        }
-        // add entry
-        long costsBase = (long) newEntryIndex * turnCostsEntryBytes;
-        turnCosts.setInt(costsBase + TC_FROM, from);
-        turnCosts.setInt(costsBase + TC_TO, to);
-        turnCosts.setInt(costsBase + TC_COSTS, flags);
-        // next-pointer is NO_COST_ENTRY
-        turnCosts.setInt(costsBase + TC_NEXT, NO_COST_ENTRY);
-    }
-
-    public int getTurnCosts( int node, int edgeFrom, int edgeTo )
-    {
-        if (edgeFrom != EdgeIterator.NO_EDGE && edgeTo != EdgeIterator.NO_EDGE)
-        {
-            TurnCostIterator tc = createTurnCostIterable(node, edgeFrom, edgeTo);
-            if (tc.next())
-            {
-                return tc.costs();
-            }
-        }
-        return 0;
-    }
-
-    public TurnCostIterator createTurnCostIterable( int node, int edgeFrom, int edgeTo )
-    {
-        return new TurnCostIteratable(node, edgeFrom, edgeTo);
-    }
-
-    void ensureTurnCostsIndex( int nodeIndex )
-    {
-        long deltaCap = ((long) nodeIndex + 4) * turnCostsEntryBytes - turnCosts.getCapacity();
-        if (deltaCap <= 0)
-        {
-            return;
-        }
-        turnCosts.incCapacity(deltaCap);
-    }
-
-    @Override
-    public boolean isRequireNodeField()
-    {
-        //we require the additional field in the graph to point to the first entry in the node table
-        return true;
-    }
-
-    @Override
-    public boolean isRequireEdgeField()
-    {
-        return false;
-    }
-
-    @Override
-    public int getDefaultNodeFieldValue()
-    {
-        return NO_COST_ENTRY;
-    }
-
-    @Override
-    public int getDefaultEdgeFieldValue()
-    {
-        throw new UnsupportedOperationException("Not supported by this storage");
-    }
-
-    @Override
-    public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
-    {
-
-        if (!(clonedStorage instanceof TurnCostStorage))
-        {
-            throw new IllegalStateException("the extended storage to clone must be the same");
-        }
-
-        TurnCostStorage clonedTC = (TurnCostStorage) clonedStorage;
-
-        turnCosts.copyTo(clonedTC.turnCosts);
-        clonedTC.turnCostsCount = turnCostsCount;
-
-        return clonedStorage;
-    }
-
-    public class TurnCostIteratable implements TurnCostIterator
-    {
-
-        int nodeVia;
-        int edgeFrom;
-        int edgeTo;
-        int iteratorEdgeFrom;
-        int iteratorEdgeTo;
-        int turnCostIndex;
-        long turnCostPtr;
-
-        public TurnCostIteratable( int node, int edgeFrom, int edgeTo )
-        {
-            this.nodeVia = node;
-            this.iteratorEdgeFrom = edgeFrom;
-            this.iteratorEdgeTo = edgeTo;
-            this.edgeFrom = EdgeIterator.NO_EDGE;
-            this.edgeTo = EdgeIterator.NO_EDGE;
-            this.turnCostIndex = getCostTableAdress(nodeVia);
-            this.turnCostPtr = -1L;
-        }
-
-        @Override
-        public boolean next()
-        {
-            int i = 0;
-            boolean found = false;
-            for (; i < 1000; i++)
-            {
-                if (turnCostIndex == NO_COST_ENTRY)
-                    break;
-                turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
-                edgeFrom = turnCosts.getInt(turnCostPtr + TC_FROM);
-                edgeTo = turnCosts.getInt(turnCostPtr + TC_TO);
-
-                int nextTurnCostIndex = turnCosts.getInt(turnCostPtr + TC_NEXT);
-                if (nextTurnCostIndex == turnCostIndex)
-                {
-                    throw new IllegalStateException("something went wrong: next entry would be the same");
-                }
-                turnCostIndex = nextTurnCostIndex;
-
-                if (edgeFrom != EdgeIterator.NO_EDGE && edgeTo != EdgeIterator.NO_EDGE && //
-                        (iteratorEdgeFrom == TurnCostIterator.ANY_EDGE || edgeFrom == iteratorEdgeFrom) && //
-                        (iteratorEdgeTo == TurnCostIterator.ANY_EDGE || edgeTo == iteratorEdgeTo))
-                {
-                    found = true;
-                    break;
-                }
-            }
-            // so many turn restrictions on one node? here is something wrong
-            if (i > 1000)
-                throw new IllegalStateException("something went wrong: no end of turn cost-list found");
-            return found;
-        }
-
-        public int edgeFrom()
-        {
-            return edgeFrom;
-        }
-
-        public int edgeTo()
-        {
-            return edgeTo;
-        }
-
-        public int costs()
-        {
-            return turnCosts.getInt(turnCostPtr + TC_COSTS);
-        }
-    }
-
-}
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index db8df6fd45..20d112c42b 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.storage;
 
-import static com.graphhopper.storage.AbstractDataAccess.HEADER_OFFSET;
 import com.graphhopper.util.NotThreadSafe;
 import java.io.File;
 import java.io.IOException;
@@ -61,8 +60,7 @@
     }
 
     private long address;
-    private long capacity;
-    private transient boolean closed = false;
+    private long capacity;    
 
     UnsafeDataAccess( String name, String location, ByteOrder order )
     {
@@ -75,12 +73,12 @@ public UnsafeDataAccess create( long bytes )
         // TODO use unsafe.pageSize() instead segmentSizeInBytes?
         // e.g. on my system pageSize is only 4096
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(bytes);
+        ensureCapacity(bytes);
         return this;
     }
 
     @Override
-    public final boolean incCapacity( long bytes )
+    public final boolean ensureCapacity(long bytes)
     {
         return ensureCapacity(bytes, true);
     }
@@ -127,8 +125,8 @@ public DataAccess copyTo( DataAccess da )
     @Override
     public boolean loadExisting()
     {
-        if (closed)
-            return false;
+        if (isClosed())
+            throw new IllegalStateException("already closed");
 
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
@@ -173,7 +171,7 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        if (closed)
+        if (isClosed())
             throw new IllegalStateException("already closed");
 
         try
@@ -204,7 +202,7 @@ public void flush()
     @Override
     public void close()
     {
-        closed = true;
+        super.close();
         UNSAFE.freeMemory(address);
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index 87f0d0c147..ec3a4b9011 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -18,36 +18,124 @@
 package com.graphhopper.storage.index;
 
 /**
- * http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm or even better:
- * http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm
+ * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
+ * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
+ * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
+ * <p>
+ * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
+ * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
+ * http://stackoverflow.com/q/24679963/194609
  * <p/>
  * @author Peter Karich
  */
 public class BresenhamLine
 {
-    // http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Simplification
     public static void calcPoints( int y1, int x1, int y2, int x2,
             PointEmitter emitter )
+    {
+        bresenham(y1, x1, y2, x2, emitter);
+    }
+
+    public static void voxelTraversal( double y1, double x1, double y2, double x2,
+            PointEmitter emitter )
+    {
+        // edge case
+        x1 = fix(x1);
+        y1 = fix(y1);
+        x2 = fix(x2);
+        y2 = fix(y2);
+
+        int x = (int) x1, y = (int) y1;
+        int endX = (int) x2, endY = (int) y2;
+
+        // deltaX and Y is how far we have to move in ray direction until we find a new cell in x or y direction
+        // y = u + t * v, where u=(x1,x2) and v=(stepX,stepY) is the direction vector
+        final double gridCellWidth = 1, gridCellHeight = 1;
+
+        double deltaX = gridCellWidth / Math.abs(x2 - x1);
+        int stepX = (int) Math.signum(x2 - x1);
+        double tmp = frac(x1 / gridCellWidth);
+        double maxX = deltaX * (1.0 - tmp);
+
+        double deltaY = gridCellHeight / Math.abs(y2 - y1);
+        int stepY = (int) Math.signum(y2 - y1);
+        tmp = frac(y1 / gridCellHeight);
+        double maxY = deltaY * (1.0 - tmp);
+
+        boolean reachedY = false, reachedX = false;
+
+        emitter.set(y, x);
+        // trace primary ray
+        while (!(reachedX && reachedY))
+        {
+            if (maxX < maxY)
+            {
+                maxX += deltaX;
+                x += stepX;
+            } else
+            {
+                maxY += deltaY;
+                y += stepY;
+            }
+
+            emitter.set(y, x);
+
+            if (stepX > 0.0)
+            {
+                if (x >= endX)
+                    reachedX = true;
+
+            } else if (x <= endX)
+            {
+                reachedX = true;
+            }
+
+            if (stepY > 0.0)
+            {
+                if (y >= endY)
+                    reachedY = true;
+
+            } else if (y <= endY)
+            {
+                reachedY = true;
+            }
+        }
+    }
+
+    static final double fix( double val )
+    {
+        if (frac(val) == 0)
+            return val + 0.1;
+        return val;
+    }
+
+    static final double frac( double val )
+    {
+        return val - (int) val;
+    }
+
+    public static void bresenham( int y1, int x1, int y2, int x2,
+            PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
         int dLat = Math.abs(y2 - y1), sLat = latIncreasing ? 1 : -1;
         int dLon = Math.abs(x2 - x1), sLon = lonIncreasing ? 1 : -1;
-        int err = 2 * (dLon - dLat);
+        int err = dLon - dLat;
 
         while (true)
         {
             emitter.set(y1, x1);
             if (y1 == y2 && x1 == x2)
-            {
                 break;
-            }
-            int tmpErr = err;
+
+            int tmpErr = 2 * err;
             if (tmpErr > -dLat)
             {
                 err -= dLat;
                 x1 += sLon;
             }
+
             if (tmpErr < dLon)
             {
                 err += dLon;
@@ -56,42 +144,122 @@ public static void calcPoints( int y1, int x1, int y2, int x2,
         }
     }
 
-    public static void calcPoints( double lat1, double lon1,
-            double lat2, double lon2, final PointEmitter emitter,
-            final double offsetLat, final double offsetLon,
-            final double deltaLat, final double deltaLon )
+    public static void xiaolinWu( double y1, double x1, double y2, double x2,
+            PointEmitter emitter )
     {
-        // round to make results of bresenham closer to correct solution
-        int y1 = (int) Math.round((lat1 - offsetLat) / deltaLat);
-        int x1 = (int) Math.round((lon1 - offsetLon) / deltaLon);
-        int y2 = (int) Math.round((lat2 - offsetLat) / deltaLat);
-        int x2 = (int) Math.round((lon2 - offsetLon) / deltaLon);
-        calcPoints(y1, x1, y2, x2, new PointEmitter()
+        double dx = x2 - x1;
+        double dy = y2 - y1;
+
+        if (Math.abs(dx) > Math.abs(dy))
         {
-            @Override
-            public void set( double lat, double lon )
+            if (x2 < x1)
             {
-                emitter.set(((lat) * deltaLat + offsetLat),
-                        ((lon) * deltaLon + offsetLon));
+                // algo only handles rightwards so swap
+                double tmp = x1;
+                x1 = x2;
+                x2 = tmp;
+                tmp = y1;
+                y1 = y2;
+                y2 = tmp;
             }
-        });
+
+            double gradient = dy / dx;
+            // orig: round
+            int xend = (int) (x1);
+            double yend = y1 + gradient * (xend - x1);
+            int xpxl1 = xend;
+            int ypxl1 = (int) yend;
+
+            // first endpoint
+            emitter.set(ypxl1, xpxl1);
+            emitter.set(ypxl1 + 1, xpxl1);
+            double intery = yend + gradient;
+
+            // orig: round
+            xend = (int) (x2);
+            yend = y2 + gradient * (xend - x2);
+            int xpxl2 = xend;
+            int ypxl2 = (int) yend;
+
+            // second endpoint
+            emitter.set(ypxl2, xpxl2);
+            emitter.set(ypxl2 + 1, xpxl2);
+
+            // all the points between the endpoints
+            for (int x = xpxl1 + 1; x <= xpxl2 - 1; ++x)
+            {
+                emitter.set((int) intery, x);
+                emitter.set((int) intery + 1, x);
+                intery += gradient;
+            }
+        } else
+        {
+            if (y2 < y1)
+            {
+                // algo only handles topwards so swap
+                double tmp = x1;
+                x1 = x2;
+                x2 = tmp;
+                tmp = y1;
+                y1 = y2;
+                y2 = tmp;
+            }
+
+            double gradient = dx / dy;
+            // orig: round
+            int yend = (int) (y1);
+            double xend = x1 + gradient * (yend - y1);
+            int ypxl1 = yend;
+            int xpxl1 = (int) xend;
+
+            // first endpoint
+            emitter.set(ypxl1, xpxl1);
+            emitter.set(ypxl1 + 1, xpxl1);
+            double interx = xend + gradient;
+
+            // orig: round
+            yend = (int) (y2);
+            xend = x2 + gradient * (yend - y2);
+            int ypxl2 = yend;
+            int xpxl2 = (int) xend;
+
+            // second endpoint
+            emitter.set(ypxl2, xpxl2);
+            emitter.set(ypxl2 + 1, xpxl2);
+
+            // all the points between the endpoints
+            for (int y = ypxl1 + 1; y <= ypxl2 - 1; ++y)
+            {
+                emitter.set(y, (int) interx);
+                emitter.set(y, (int) interx + 1);
+                interx += gradient;
+            }
+        }
     }
 
-    public static void calcPointsOffset( double lat1, double lon1,
-            double lat2, double lon2, final PointEmitter emitter,
+    public static void calcPoints( final double lat1, final double lon1,
+            final double lat2, final double lon2,
+            final PointEmitter emitter,
             final double offsetLat, final double offsetLon,
             final double deltaLat, final double deltaLon )
     {
+//        double y1 = (lat1 - offsetLat) / deltaLat;
+//        double x1 = (lon1 - offsetLon) / deltaLon;
+//        double y2 = (lat2 - offsetLat) / deltaLat;
+//        double x2 = (lon2 - offsetLon) / deltaLon;
+        // for xiaolinWu or calcPoints
+
+        // round to make results of bresenham closer to correct solution
         int y1 = (int) ((lat1 - offsetLat) / deltaLat);
         int x1 = (int) ((lon1 - offsetLon) / deltaLon);
         int y2 = (int) ((lat2 - offsetLat) / deltaLat);
         int x2 = (int) ((lon2 - offsetLon) / deltaLon);
-        calcPoints(y1, x1, y2, x2, new PointEmitter()
+        bresenham(y1, x1, y2, x2, new PointEmitter()
         {
             @Override
             public void set( double lat, double lon )
             {
-                // +0.5 to move into the center of the tile
+                // +.1 to move more near the center of the tile
                 emitter.set((lat + .1) * deltaLat + offsetLat, (lon + .1) * deltaLon + offsetLon);
             }
         });
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 09f141eec2..8a0a88955f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -22,8 +22,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Circle;
 
 /**
@@ -33,9 +32,10 @@
  */
 public class Location2IDFullIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistancePlaneProjection();
+    private DistanceCalc calc = Helper.DIST_PLANE;
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    private boolean closed = false;
 
     public Location2IDFullIndex( Graph g )
     {
@@ -53,9 +53,9 @@ public boolean loadExisting()
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
 
         return this;
     }
@@ -75,6 +75,9 @@ public LocationIndex prepareIndex()
     @Override
     public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter edgeFilter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         QueryResult res = new QueryResult(queryLat, queryLon);
         Circle circle = null;
         AllEdgesIterator iter = graph.getAllEdges();
@@ -130,6 +133,13 @@ public void flush()
     @Override
     public void close()
     {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 05fadf8dfc..a189adffd4 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -24,6 +24,7 @@
 import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -32,9 +33,10 @@
  */
 public class Location2IDFullWithEdgesIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistanceCalcEarth();
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final Graph graph;
     private final NodeAccess nodeAccess;
+    private boolean closed = false;
 
     public Location2IDFullWithEdgesIndex( Graph g )
     {
@@ -59,10 +61,10 @@ public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
         {
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         } else
         {
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
         }
         return this;
     }
@@ -82,6 +84,9 @@ public int findID( double lat, double lon )
     @Override
     public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter filter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         QueryResult res = new QueryResult(queryLat, queryLon);
         double foundDist = Double.MAX_VALUE;
         AllEdgesIterator iter = graph.getAllEdges();
@@ -158,6 +163,13 @@ public void flush()
     @Override
     public void close()
     {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index d0c30ef8a1..513e17fa7d 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -24,11 +24,7 @@
 import com.graphhopper.geohash.LinearKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.XFirstSearch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.Arrays;
@@ -45,12 +41,12 @@
  * <p/>
  * @author Peter Karich
  */
-public class Location2IDQuadtree implements LocationIndex
+class Location2IDQuadtree implements LocationIndex
 {
     private final static int MAGIC_INT = Integer.MAX_VALUE / 12306;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private KeyAlgo keyAlgo;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
     private final DataAccess index;
     private double maxRasterWidth2InMeterNormed;
     private final Graph graph;
@@ -69,9 +65,9 @@ public Location2IDQuadtree( Graph g, Directory dir )
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
 
         return this;
     }
@@ -322,6 +318,9 @@ public int findID( final double lat, final double lon )
     public QueryResult findClosest( final double queryLat, final double queryLon,
             final EdgeFilter edgeFilter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         if (edgeFilter != EdgeFilter.ALL_EDGES)
             throw new UnsupportedOperationException("edge filters are not yet implemented for " + Location2IDQuadtree.class.getSimpleName());
 
@@ -347,7 +346,7 @@ public QueryResult findClosest( final double queryLat, final double queryLon,
         res.setClosestNode(id);
         res.setQueryDistance(distCalc.calcNormalizedDist(queryLat, queryLon, mainLat, mainLon));
         goFurtherHook(id);
-        new XFirstSearch()
+        new BreadthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -374,7 +373,7 @@ protected boolean goFurther( int baseNode )
 
                 return currNormedDist < maxRasterWidth2InMeterNormed;
             }
-        }.start(graph.createEdgeExplorer(), id, false);
+        }.start(graph.createEdgeExplorer(), id);
 
         // denormalize distance
         res.setQueryDistance(distCalc.calcDenormalizedDist(res.getQueryDistance()));
@@ -401,6 +400,12 @@ public void close()
         index.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return index.isClosed();
+    }
+
     @Override
     public void setSegmentSize( int bytes )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 23bad3c462..2e1193735e 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -28,6 +28,8 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.iterator.TIntIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
@@ -36,9 +38,7 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * This implementation implements an n-tree to get node ids from GPS location. This replaces
- * Location2IDQuadtree except for cases when you only need rough precision or when you need better
- * support for out-of-bounds queries.
+ * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
  * <p/>
  * All leafs are at the same depth, otherwise it is quite complicated to calculate the bresenham
  * line for different resolutions, especially if a leaf node could be split into a tree-node and
@@ -50,8 +50,8 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int MAGIC_INT;
-    protected static DistanceCalc distCalc = new DistancePlaneProjection();
-    private DistanceCalc preciseDistCalc = new DistanceCalcEarth();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
     protected final Graph graph;
     private final NodeAccess nodeAccess;
     final DataAccess dataAccess;
@@ -60,14 +60,14 @@
     // convert spatial key to index for subentry of current depth
     private long[] bitmasks;
     protected SpatialKeyAlgo keyAlgo;
-    private int minResolutionInMeter = 500;
+    private int minResolutionInMeter = 300;
     private double deltaLat;
     private double deltaLon;
     private int initSizeLeafEntries = 4;
     private boolean initialized = false;
     // do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
     static final int START_POINTER = 1;
-    private boolean regionSearch = true;
+    int maxRegionSearch = 4;
     /**
      * If normed distance is smaller than this value the node or edge is 'identical' and the
      * algorithm can stop search.
@@ -98,11 +98,20 @@ public LocationIndexTree setMinResolutionInMeter( int minResolutionInMeter )
     }
 
     /**
-     * Searches also neighbouring quadtree entries to increase map matching precision.
+     * Searches also neighbouring tiles until the maximum distance from the query point is reached
+     * (minResolutionInMeter*regionAround). Set to 1 for to force avoiding a fall back, good if you
+     * have strict performance and lookup-quality requirements. Default is 4.
      */
-    public LocationIndexTree setSearchRegion( boolean regionAround )
+    public LocationIndexTree setMaxRegionSearch( int numTiles )
     {
-        this.regionSearch = regionAround;
+        if (numTiles < 1)
+            throw new IllegalArgumentException("Region of location index must be at least 1 but was " + numTiles);
+
+        // see #232
+        if (numTiles % 2 == 1)
+            numTiles++;
+
+        this.maxRegionSearch = numTiles;
         return this;
     }
 
@@ -201,7 +210,7 @@ private byte getShift( int entries )
 
     private long getBitmask( int shift )
     {
-        long bm = (1 << shift) - 1;
+        long bm = (1L << shift) - 1;
         if (bm <= 0)
         {
             throw new IllegalStateException("invalid bitmask:" + bm);
@@ -261,9 +270,9 @@ public LocationIndex setResolution( int minResolutionInMeter )
     public LocationIndex setApproximation( boolean approx )
     {
         if (approx)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
         return this;
     }
 
@@ -297,8 +306,14 @@ public LocationIndex prepareIndex()
 
         // compact & store to dataAccess
         dataAccess.create(64 * 1024);
-        int lastPointer = inMem.store(inMem.root, START_POINTER);
-        flush();
+        try
+        {
+            inMem.store(inMem.root, START_POINTER);
+            flush();
+        } catch (Exception ex)
+        {
+            throw new IllegalStateException("Problem while storing location index. " + Helper.getMemInfo(), ex);
+        }
         float entriesPerLeaf = (float) inMem.size / inMem.leafs;
         initialized = true;
         logger.info("location index created in " + sw.stop().getSeconds()
@@ -325,6 +340,12 @@ public void close()
         dataAccess.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return dataAccess.isClosed();
+    }
+
     @Override
     public long getCapacity()
     {
@@ -377,7 +398,6 @@ void prepare()
                 }
             } catch (Exception ex)
             {
-//                logger.error("Problem!", ex);
                 logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
                         + ", edge:" + allIter.getEdge(), ex);
             }
@@ -505,7 +525,7 @@ int store( InMemEntry entry, int intIndex )
                 size += len;
                 intIndex++;
                 leafs++;
-                dataAccess.incCapacity((long) (intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
                 if (len == 1)
                 {
                     // less disc space for single entries
@@ -530,7 +550,7 @@ int store( InMemEntry entry, int intIndex )
                     {
                         continue;
                     }
-                    dataAccess.incCapacity((long) (intIndex + 1) * 4);
+                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
                     int beforeIntIndex = intIndex;
                     intIndex = store(subEntry, beforeIntIndex);
                     if (intIndex == beforeIntIndex)
@@ -552,7 +572,7 @@ TIntArrayList getEntries()
     }
 
     // fillIDs according to how they are stored
-    void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
+    final void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
     {
         long pointer = (long) intIndex << 2;
         if (depth == entries.length)
@@ -593,36 +613,170 @@ final long createReverseKey( long key )
         return BitUtil.BIG.reverse(key, keyAlgo.getBits());
     }
 
-    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon )
+    /**
+     * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
+     * context of a spatial key tile.
+     * <p>
+     */
+    final double calculateRMin( double lat, double lon )
+    {
+        return calculateRMin(lat, lon, 0);
+    }
+
+    /**
+     * Calculates the distance to the nearest tile border, where the tile border is the rectangular
+     * region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon
+     * coordinate
+     */
+    final double calculateRMin( double lat, double lon, int paddingTiles )
+    {
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+
+        // deltaLat and deltaLon comes from the LocationIndex:
+        double minLat = center.lat - (0.5 + paddingTiles) * deltaLat;
+        double maxLat = center.lat + (0.5 + paddingTiles) * deltaLat;
+        double minLon = center.lon - (0.5 + paddingTiles) * deltaLon;
+        double maxLon = center.lon + (0.5 + paddingTiles) * deltaLon;
+
+        double dSouthernLat = query.lat - minLat;
+        double dNorthernLat = maxLat - query.lat;
+        double dWesternLon = query.lon - minLon;
+        double dEasternLon = maxLon - query.lon;
+
+        // convert degree deltas into a radius in meter
+        double dMinLat, dMinLon;
+        if (dSouthernLat < dNorthernLat)
+        {
+            dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
+        } else
+        {
+            dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
+        }
+
+        if (dWesternLon < dEasternLon)
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
+        } else
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
+        }
+
+        double rMin = Math.min(dMinLat, dMinLon);
+        return rMin;
+    }
+
+    /**
+     * Provide info about tilesize for testing / visualization
+     */
+    double getDeltaLat()
+    {
+        return deltaLat;
+    }
+
+    double getDeltaLon()
     {
-        TIntHashSet storedNetworkEntryIds = new TIntHashSet();
-        if (regionSearch)
+        return deltaLon;
+    }
+
+    GHPoint getCenter( double lat, double lon )
+    {
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+        return center;
+    }
+
+    /**
+     * This method collects the node indices from the quad tree data structure in a certain order
+     * which makes sure not too many nodes are collected as well as no nodes will be missing. See
+     * discussion at issue #221.
+     */
+    public final TIntHashSet findNetworkEntries( double queryLat, double queryLon, int maxIteration )
+    {
+        TIntHashSet foundEntries = new TIntHashSet();
+
+        for (int iteration = 0; iteration < maxIteration; iteration++)
         {
-            // search all rasters around minResolutionInMeter as we did not fill empty entries
-            double maxLat = queryLat + 1.5 * deltaLat;
-            double maxLon = queryLon + 1.5 * deltaLon;
-            for (double tmpLat = queryLat - deltaLat; tmpLat < maxLat; tmpLat += deltaLat)
+            // find entries in border of searchbox
+            for (int yreg = -iteration; yreg <= iteration; yreg++)
             {
-                for (double tmpLon = queryLon - deltaLon; tmpLon < maxLon; tmpLon += deltaLon)
+                double subqueryLat = queryLat + yreg * deltaLat;
+                double subqueryLonA = queryLon - iteration * deltaLon;
+                double subqueryLonB = queryLon + iteration * deltaLon;
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
+
+                // minor optimization for iteration == 0
+                if (iteration > 0)
                 {
-                    long keyPart = createReverseKey(tmpLat, tmpLon);
-                    // System.out.println(BitUtilLittle.toBitString(key, keyAlgo.bits()));
-                    fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
+                    findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
                 }
             }
-        } else
+
+            for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
+            {
+                double subqueryLon = queryLon + xreg * deltaLon;
+                double subqueryLatA = queryLat - iteration * deltaLat;
+                double subqueryLatB = queryLat + iteration * deltaLat;
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
+            }
+
+            // see #232
+            if (iteration % 2 == 1)
+            {
+                // Check if something was found already...
+                if (foundEntries.size() > 0)
+                {
+                    double rMin = calculateRMin(queryLat, queryLon, iteration);
+                    double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
+
+                    if (minDistance < rMin)
+                    {   // resultEntries contains a nearest node for sure
+                        break;
+                    } // else: continue an undetected nearer node may sit in a neighbouring tile.
+                    // Now calculate how far we have to look outside to find any hidden nearest nodes
+                    // and repeat whole process with wider search area until this distance is covered.
+                }
+            }
+        }
+        return foundEntries;
+    }
+
+    final double calcMinDistance( double queryLat, double queryLon, TIntHashSet pointset )
+    {
+        double min = Double.MAX_VALUE;
+        TIntIterator itr = pointset.iterator();
+        while (itr.hasNext())
         {
-            long keyPart = createReverseKey(queryLat, queryLon);
-            fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
+            int node = itr.next();
+            double lat = nodeAccess.getLat(node);
+            double lon = nodeAccess.getLon(node);
+            double dist = distCalc.calcDist(queryLat, queryLon, lat, lon);
+            if (dist < min)
+            {
+                min = dist;
+            }
         }
-        return storedNetworkEntryIds;
+        return min;
+    }
+
+    final void findNetworkEntriesSingleRegion( TIntHashSet storedNetworkEntryIds, double queryLat, double queryLon )
+    {
+        long keyPart = createReverseKey(queryLat, queryLon);
+        fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
 
     @Override
-    public QueryResult findClosest( final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter )
+    public QueryResult findClosest( final double queryLat, final double queryLon, final EdgeFilter edgeFilter )
     {
-        final TIntHashSet storedNetworkEntryIds = findNetworkEntries(queryLat, queryLon);
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
+        final TIntHashSet storedNetworkEntryIds = findNetworkEntries(queryLat, queryLon, maxRegionSearch);
         final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
         if (storedNetworkEntryIds.isEmpty())
             return closestMatch;
@@ -634,7 +788,7 @@ public QueryResult findClosest( final double queryLat, final double queryLon,
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
-            public boolean execute( final int networkEntryNodeId )
+            public boolean execute( int networkEntryNodeId )
             {
                 new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
                 {
@@ -658,7 +812,7 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
                         }
                         return false;
                     }
-                }.start(explorer, networkEntryNodeId, false);
+                }.start(explorer, networkEntryNodeId);
                 return true;
             }
         });
@@ -676,7 +830,7 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
     /**
      * Make it possible to collect nearby location also for other purposes.
      */
-    protected abstract class XFirstSearchCheck extends XFirstSearch
+    protected abstract class XFirstSearchCheck extends BreadthFirstSearch
     {
         boolean goFurther = true;
         double currNormedDist;
@@ -753,16 +907,19 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             tmpLat, tmpLon, wayLat, wayLon);
                     check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else if (pointIndex + 1 == len)
-                {
-                    tmpNormedDist = adjDist;
-                    pos = QueryResult.Position.TOWER;
                 } else
                 {
-                    tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
-                    pos = QueryResult.Position.PILLAR;
+                    if (pointIndex + 1 == len)
+                    {
+                        tmpNormedDist = adjDist;
+                        pos = QueryResult.Position.TOWER;
+                    } else
+                    {
+                        tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
+                        pos = QueryResult.Position.PILLAR;
+                    }
+                    check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
                 }
-                check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
 
                 if (tmpNormedDist <= equalNormedDelta)
                     return false;
@@ -803,12 +960,12 @@ protected AllEdgesIterator getAllEdges()
 
     static class InMemLeafEntry extends SortedIntSet implements InMemEntry
     {
-        private long key;
+        // private long key;
 
         public InMemLeafEntry( int count, long key )
         {
             super(count);
-            this.key = key;
+            // this.key = key;
         }
 
         public boolean addNode( int nodeId )
@@ -825,7 +982,7 @@ public final boolean isLeaf()
         @Override
         public String toString()
         {
-            return "LEAF " + key + " " + super.toString();
+            return "LEAF " + /*key +*/ " " + super.toString();
         }
 
         TIntArrayList getResults()
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
index 6839b38ede..57d8dbc81b 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
@@ -71,9 +71,9 @@ protected AllEdgesIterator getAllEdges()
         return new AllEdgesIterator()
         {
             @Override
-            public int getMaxId()
+            public int getCount()
             {
-                return tmpIter.getMaxId();
+                return tmpIter.getCount();
             }
 
             @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 26439ffb3c..c371733f82 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -20,23 +20,18 @@
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
 
 /**
  * Result of LocationIndex lookup.
- * <p/>
- * <
- * pre> X=query coordinates S=snapped coordinates: "snapping" real coords to road N=tower or pillar
+ * <pre> X=query coordinates S=snapped coordinates: "snapping" real coords to road N=tower or pillar
  * node T=closest tower node XS=distance
- * <p/>
  * X
  * |
  * T--S----N
- * <p/>
  * </pre>
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class QueryResult
@@ -49,6 +44,14 @@
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
 
+    /**
+     * Due to precision differences it is hard to define when something is exactly 90 or "on-node"
+     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
+     * "on-edge" even if it could be 90. To prefer "on-node" you could use e.g. GHPoint.equals with
+     * a default precision of 1e-6.
+     * <p>
+     * @see DistanceCalc#validEdgeDistance
+     */
     public static enum Position
     {
         EDGE, TOWER, PILLAR
@@ -120,7 +123,6 @@ public Position getSnappedPosition()
      */
     public boolean isValid()
     {
-        // Location2IDQuadtree does not support edges
         return closestNode >= 0;
     }
 
@@ -137,7 +139,7 @@ public EdgeIteratorState getClosestEdge()
         return closestEdge;
     }
 
-    public CoordTrig getQueryPoint()
+    public GHPoint getQueryPoint()
     {
         return queryPoint;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java b/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java
deleted file mode 100644
index 13b5a04f42..0000000000
--- a/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage.index;
-
-/**
- * Helper class used in some Location2IDIndex implementations for findID
- * <p/>
- * @author Peter Karich
- */
-class WeightedNode implements Comparable<WeightedNode>
-{
-    public int node;
-    public double weight;
-
-    WeightedNode( int node, double distance )
-    {
-        this.node = node;
-        this.weight = distance;
-    }
-
-    @Override
-    public int compareTo( WeightedNode o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return node + " weight is " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc2D.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
similarity index 69%
rename from core/src/main/java/com/graphhopper/util/AngleCalc2D.java
rename to core/src/main/java/com/graphhopper/util/AngleCalc.java
index 6777060fff..5e98e3ca80 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc2D.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -18,37 +18,47 @@
 package com.graphhopper.util;
 
 /**
- * Calculates the angle of a turn, defined by three points.
+ * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
+ * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
  * <p>
  * @author Johannes Pelzer
  * @author Peter Karich
  */
-public class AngleCalc2D
+public class AngleCalc
 {
+    private final static double PI_4 = Math.PI / 4.0;
+    private final static double PI3_4 = 3.0 * Math.PI / 4.0;
 
-    /**
-     * Return orientation of line relative to east.
-     * <p>
-     * @return Orientation in interval -pi to +pi where 0 is east
-     * <p>
-     * @Deprecated because it seems to be nicer to align to north so try to use calcOrientationNorth
-     * instaead
-     */
-    @Deprecated
-    public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
+    static final double atan2( double y, double x )
     {
-        return Math.atan2(lat2 - lat1, lon2 - lon1);
-        //return Math.atan2(lon2 - lon1, lat2 - lat1);
+        // kludge to prevent 0/0 condition
+        double absY = Math.abs(y) + 1e-10;
+        double r, angle;
+        if (x < 0.0)
+        {
+            r = (x + absY) / (absY - x);
+            angle = PI3_4;
+        } else
+        {
+            r = (x - absY) / (x + absY);
+            angle = PI_4;
+        }
+
+        angle += (0.1963 * r * r - 0.9817) * r;
+        if (y < 0.0)
+            // negate if in quad III or IV
+            return -angle;
+        return angle;
     }
 
     /**
-     * Return orientation of line relative to north. (North by coordinates, not magnetic north)
+     * Return orientation of line relative to east.
      * <p>
-     * @return Orientation in interval -pi to +pi where 0 is north and pi is south
+     * @return Orientation in interval -pi to +pi where 0 is east
      */
-    public double calcOrientationNorth( double lat1, double lon1, double lat2, double lon2 )
+    public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
     {
-        return Math.atan2(lon2 - lon1, lat2 - lat1);
+        return atan2((lat2 - lat1), (lon2 - lon1));
     }
 
     /**
@@ -77,22 +87,17 @@ public double alignOrientation( double baseOrientation, double orientation )
     }
 
     /**
-     * Calculate Azimuth for a line given by two coordinates. Direction in Degree where 0 is North,
-     * 90 is East, and 270 is West
-     * <p>
-     * @param lat1
-     * @param lon1
-     * @param lat2
-     * @param lon2
-     * @return
+     * Calculate the azimuth in degree for a line given by two coordinates. Direction in 'degree'
+     * where 0 is north, 90 is east, 180 is south and 270 is west.
      */
     double calcAzimuth( double lat1, double lon1, double lat2, double lon2 )
     {
-        double orientation = calcOrientationNorth(lat1, lon1, lat2, lon2);
-        double baseOrientation = calcOrientationNorth(2, 0, 1, 0);    // south
-        double alignedOrientation = alignOrientation(baseOrientation, orientation);
+        double orientation = -calcOrientation(lat1, lon1, lat2, lon2);
+        orientation = Helper.round4(orientation + Math.PI / 2);
+        if (orientation < 0)
+            orientation += 2 * Math.PI;
 
-        return Math.toDegrees(alignedOrientation);
+        return Math.toDegrees(orientation);
     }
 
     String azimuth2compassPoint( double azimuth )
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 2cc2bf043a..11957181dd 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -195,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -265,6 +268,21 @@ public final long reverse( long value, int maxBits )
         return res;
     }
 
+    public final int getIntLow( long longValue )
+    {
+        return (int) (longValue & 0xFFFFFFFFL);
+    }
+
+    public final int getIntHigh( long longValue )
+    {
+        return (int) (longValue >> 32);
+    }
+
+    public final long combineIntsToLong( int intLow, int intHigh )
+    {
+        return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
+    }
+
     public final long reverseLeft( long value, int maxBits )
     {
         long res = 0;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilBig.java b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
index 96be62c536..ee3dfcd59e 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilBig.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
@@ -134,7 +134,7 @@ public String toBitString( byte[] bytes )
      */
     final long reversePart( long v, int maxBits )
     {
-        long rest = v & (~((1 << maxBits) - 1));
+        long rest = v & (~((1L << maxBits) - 1));
         return rest | reverse(v, maxBits);
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
new file mode 100644
index 0000000000..05d3a3d009
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.coll.GHBitSet;
+
+/**
+ * Implementattion of breadth first search (BFS)
+ * <p/>
+ * @author Peter Karich
+ */
+public class BreadthFirstSearch extends XFirstSearch
+{
+    @Override
+    public void start( EdgeExplorer explorer, int startNode )
+    {
+        SimpleIntDeque fifo = new SimpleIntDeque();
+        GHBitSet visited = createBitSet();
+        visited.add(startNode);
+        fifo.push(startNode);
+        int current;
+        while (!fifo.isEmpty())
+        {
+            current = fifo.pop();
+            if (!goFurther(current))
+                continue;
+
+            EdgeIterator iter = explorer.setBaseNode(current);
+            while (iter.next())
+            {
+                int connectedId = iter.getAdjNode();
+                if (checkAdjacent(iter) && !visited.contains(connectedId))
+                {
+                    visited.add(connectedId);
+                    fifo.push(connectedId);
+                }
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 70d4cef0bf..6c4801f816 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -31,110 +31,25 @@
  * <p/>
  * @author Peter Karich
  */
-public class CmdArgs
+public class CmdArgs extends PMap
 {
-    private final Map<String, String> map;
 
     public CmdArgs()
     {
-        this(new LinkedHashMap<String, String>(5));
     }
 
     public CmdArgs( Map<String, String> map )
     {
-        this.map = map;
+        super(map);
     }
 
-    public CmdArgs put( String key, String str )
+    @Override
+    public CmdArgs put( String key, Object str )
     {
-        map.put(key.toLowerCase(), str);
+        super.put(key, str);
         return this;
     }
 
-    public long getLong( String key, long _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Long.parseLong(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public int getInt( String key, int _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Integer.parseInt(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public boolean getBool( String key, boolean _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Boolean.parseBoolean(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public double getDouble( String key, double _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Double.parseDouble(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public String get( String key, String _default )
-    {
-        String str = get(key);
-        if (Helper.isEmpty(str))
-        {
-            return _default;
-        }
-        return str;
-    }
-
-    String get( String key )
-    {
-        if (Helper.isEmpty(key))
-        {
-            return "";
-        }
-        String val = map.get(key.toLowerCase());
-        if (val == null)
-        {
-            return "";
-        }
-        return val;
-    }
-
     /**
      * @param fileStr the file name of config.properties
      * @param systemProperty the property name of the configuration. E.g. -Dgraphhopper.config
@@ -150,7 +65,7 @@ public static CmdArgs readFromConfig( String fileStr, String systemProperty ) th
 
         Map<String, String> map = new LinkedHashMap<String, String>();
         Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
-                new File(configLocation).getAbsoluteFile()), "UTF-8"));
+                new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
         CmdArgs args = new CmdArgs();
         args.merge(map);
 
@@ -198,32 +113,26 @@ public static CmdArgs read( String[] args )
         return new CmdArgs(map);
     }
 
-    public CmdArgs merge( CmdArgs read )
-    {
-        return merge(read.map);
-    }
-
-    CmdArgs merge( Map<String, String> map )
+    /**
+     * Command line configuration overwrites the ones in the config file.
+     * <p>
+     * @return a new CmdArgs object if necessary.
+     */
+    public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
     {
-        for (Entry<String, String> e : map.entrySet())
+        String configVal = args.get(configKey, "");
+        if (!Helper.isEmpty(configVal))
         {
-            if (Helper.isEmpty(e.getKey()))
+            try
             {
-                continue;
+                CmdArgs tmp = CmdArgs.readFromConfig(configVal, configSysAttr);
+                tmp.merge(args);
+                return tmp;
+            } catch (Exception ex)
+            {
+                throw new RuntimeException(ex);
             }
-            this.map.put(e.getKey().toLowerCase(), e.getValue());
         }
-        return this;
-    }
-
-    public boolean has( String key )
-    {
-        return map.containsKey(key);
-    }
-
-    @Override
-    public String toString()
-    {
-        return map.toString();
+        return args;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index ac6a723406..6aa7b92971 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -51,7 +51,7 @@
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
     public static final int VERSION_NODE = 3;
-    public static final int VERSION_EDGE = 5;
+    public static final int VERSION_EDGE = 10;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
@@ -73,7 +73,7 @@ public static String getVersions()
         String version = "0.0";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/version"), "UTF-8"));
+            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/version"), Helper.UTF_CS));
             version = v.get(0);
         } catch (Exception ex)
         {
@@ -103,7 +103,7 @@ public static String getVersions()
         String buildDate = "";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/builddate"), "UTF-8"));
+            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/builddate"), Helper.UTF_CS));
             buildDate = v.get(0);
         } catch (Exception ex)
         {
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
new file mode 100644
index 0000000000..987657798a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -0,0 +1,62 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.coll.GHBitSet;
+import gnu.trove.stack.array.TIntArrayStack;
+
+/**
+ * Implementation of depth first search (DFS) by LIFO queue
+ * <p/>
+ * @author Peter Karich
+ * @author Jan Slter
+ */
+public class DepthFirstSearch extends XFirstSearch
+{
+    /**
+     * beginning with startNode add all following nodes to LIFO queue. If node has been already
+     * explored before, skip reexploration.
+     */
+    @Override
+    public void start( EdgeExplorer explorer, int startNode )
+    {
+        TIntArrayStack stack = new TIntArrayStack();
+
+        GHBitSet explored = createBitSet();
+        stack.push(startNode);
+        int current;
+        while (stack.size() > 0)
+        {
+            current = stack.pop();
+            if (!explored.contains(current) && goFurther(current))
+            {
+                EdgeIterator iter = explorer.setBaseNode(current);
+                while (iter.next())
+                {
+                    int connectedId = iter.getAdjNode();
+                    if (checkAdjacent(iter))
+                    {
+                        stack.push(connectedId);
+                    }
+                }
+                explored.add(current);
+            }
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 0a58b949f5..d0ea52f8a4 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -55,20 +55,23 @@
     double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon );
 
     /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
+     * This method decides for case 1: if we should use distance(r to edge) where r=(lat,lon) or
+     * case 2: min(distance(r to a), distance(r to b)) where edge=(a to b). Note that due to
+     * rounding errors it cannot properly detect if it is case 1 or 90.
+     * <pre>
+     * case 1 (including ):
+     *   r
+     *  .
+     * a-------b
+     *
+     * case 2:
+     * r
+     *  .
+     *    a-------b
+     * </pre>
+     * <p>
+     * @return true for case 1 which is "on edge" or the special case of 90 to the edge
      */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg );
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index c2c88e9eba..7e21bb6055 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -103,9 +103,7 @@ public boolean isDateLineCrossOver( double lon1, double lon2 )
     public BBox createBBox( double lat, double lon, double radiusInMeter )
     {
         if (radiusInMeter <= 0)
-        {
             throw new IllegalArgumentException("Distance must not be zero or negative! " + radiusInMeter + " lat,lon:" + lat + "," + lon);
-        }
 
         // length of a circle at specified lat / dist
         double dLon = (360 / (calcCircumference(lat) / radiusInMeter));
@@ -216,21 +214,6 @@ else if (factor < 0)
         return new GHPoint(c_lat, c_lon / shrink_factor);
     }
 
-    /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
-     */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index 06759ad908..db35c29f03 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -42,9 +42,9 @@ public void setApproximation( boolean a )
     {
         approx = a;
         if (approx)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
     }
 
     /**
@@ -171,4 +171,6 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         }
         return counter;
     }
+
+    
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 4014857e44..297a917ccb 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -29,7 +29,6 @@
  */
 public class Downloader
 {
-
     public static void main( String[] args ) throws IOException
     {
         new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
@@ -46,7 +45,6 @@ public void update( long val )
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
     private int timeout = 4000;
-    private int size = 1024 * 8;
 
     public Downloader( String userAgent )
     {
@@ -107,6 +105,7 @@ public void downloadFile( String url, String toFile ) throws IOException
     {
         HttpURLConnection conn = createConnection(url);
         InputStream iStream = fetch(conn);
+        int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
         try
@@ -130,7 +129,7 @@ public void downloadAndUnzip( String url, String toFolder, final ProgressListene
         final int length = conn.getContentLength();
         InputStream iStream = fetch(conn);
 
-        new Unzipper().setSize(size).unzip(iStream, new File(toFolder), new ProgressListener()
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
         {
             @Override
             public void update( long sumBytes )
@@ -142,26 +141,6 @@ public void update( long sumBytes )
 
     public String downloadAsString( String url ) throws IOException
     {
-        return readString(fetch(url));
-    }
-
-    private String readString( InputStream inputStream ) throws IOException
-    {
-        String encoding = "UTF-8";
-        InputStream in = new BufferedInputStream(inputStream, size);
-        try
-        {
-            byte[] buffer = new byte[size];
-            ByteArrayOutputStream output = new ByteArrayOutputStream();
-            int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
-                output.write(buffer, 0, numRead);
-            }
-            return output.toString(encoding);
-        } finally
-        {
-            in.close();
-        }
+        return Helper.isToString(fetch(url));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index 85ddb34c18..95f5181be9 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.routing.DijkstraBidirection;
 import gnu.trove.map.hash.TIntIntHashMap;
 import java.util.Arrays;
 
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index 80e573ccf8..b59f453b7b 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.storage.NodeAccess;
+
 /**
  * @author Peter Karich
  */
@@ -26,14 +28,20 @@
 
     public FinishInstruction( final double lat, final double lon, final double ele )
     {
-        super(FINISH, "", 0, 0, new PointList(2, true)
-        {   
+        super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
+        {
             {
                 add(lat, lon, ele);
             }
         });
     }
 
+    public FinishInstruction( NodeAccess nodeAccess, int node )
+    {
+        this(nodeAccess.getLatitude(node), nodeAccess.getLongitude(node),
+                nodeAccess.is3D() ? nodeAccess.getElevation(node) : 0);
+    }
+
     void setVia( int i )
     {
         sign = REACHED_VIA;
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 99796fe79b..25902783fb 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -28,6 +28,7 @@
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
@@ -78,7 +79,7 @@
         }
 
 //        for (int i = 0; i < nodes; i++) {
-//            new XFirstSearch().start(g, i, false);
+//            new BreadthFirstSearch().start(g, i);
 //        }
         return problems;
     }
@@ -116,9 +117,19 @@ public static int count( EdgeIterator iter )
         return list;
     }
 
+    public static List<Integer> getEdgeIds( EdgeIterator iter )
+    {
+        List<Integer> list = new ArrayList<Integer>();
+        while (iter.next())
+        {
+            list.add(iter.getEdge());
+        }
+        return list;
+    }
+
     public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
     {
-        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
         while (iter.next())
         {
@@ -128,15 +139,15 @@ public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
                 AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
                 sc = aeSkip.isShortcut() ? "sc" : "  ";
             }
-            String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
-            String bckStr = encoder.isBackward(iter.getFlags()) ? "bckwd" : "";
+            String fwdStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD) ? "fwd" : "   ";
+            String bckStr = encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD) ? "bckwd" : "";
             System.out.println(sc + " " + iter + " " + fwdStr + " " + bckStr);
         }
     }
 
     public static void printInfo( final Graph g, int startNode, final int counts, final EdgeFilter filter )
     {
-        new XFirstSearch()
+        new BreadthFirstSearch()
         {
             int counter = 0;
 
@@ -150,7 +161,7 @@ protected boolean goFurther( int nodeId )
                 }
                 return true;
             }
-        }.start(g.createEdgeExplorer(), startNode, false);
+        }.start(g.createEdgeExplorer(), startNode);
     }
 
     public static String getNodeInfo( LevelGraph g, int nodeId, EdgeFilter filter )
@@ -204,12 +215,12 @@ public static Graph sortDFS( Graph g, Graph sortedGraph )
         int nodes = g.getNodes();
         list.fill(0, nodes, -1);
         final GHBitSetImpl bitset = new GHBitSetImpl(nodes);
-        final IntRef ref = new IntRef(0);
+        final AtomicInteger ref = new AtomicInteger(-1);
         EdgeExplorer explorer = g.createEdgeExplorer();
         for (int startNode = 0; startNode >= 0 && startNode < nodes;
                 startNode = bitset.nextClear(startNode + 1))
         {
-            new XFirstSearch()
+            new DepthFirstSearch()
             {
                 @Override
                 protected GHBitSet createBitSet()
@@ -220,11 +231,10 @@ protected GHBitSet createBitSet()
                 @Override
                 protected boolean goFurther( int nodeId )
                 {
-                    list.set(nodeId, ref.val);
-                    ref.val++;
+                    list.set(nodeId, ref.incrementAndGet());                    
                     return super.goFurther(nodeId);
                 }
-            }.start(explorer, startNode, false);
+            }.start(explorer, startNode);
         }
         return createSortedGraph(g, sortedGraph, list);
     }
@@ -330,14 +340,14 @@ public static Graph clone( Graph g, GraphStorage outGraph )
         return g.copyTo(outGraph.create(g.getNodes()));
     }
 
-    public static int getToNode( Graph g, int edge, int endNode )
+    public static int getAdjNode( Graph g, int edge, int adjNode )
     {
         if (EdgeIterator.Edge.isValid(edge))
         {
-            EdgeIteratorState iterTo = g.getEdgeProps(edge, endNode);
+            EdgeIteratorState iterTo = g.getEdgeProps(edge, adjNode);
             return iterTo.getAdjNode();
         }
-        return endNode;
+        return adjNode;
     }
 
     public static class DisabledEdgeIterator implements EdgeSkipIterator
@@ -489,4 +499,25 @@ public static EdgeIteratorState getEdge( Graph graph, int base, int adj )
         }
         return null;
     }
+
+    /**
+     * Creates unique positive number for specified edgeId taking into account the direction defined
+     * by nodeA, nodeB and reverse.
+     */
+    public static int createEdgeKey( int nodeA, int nodeB, int edgeId, boolean reverse )
+    {
+        edgeId = edgeId << 1;
+        if (reverse)
+            return (nodeA > nodeB) ? edgeId : edgeId + 1;
+        return (nodeA > nodeB) ? edgeId + 1 : edgeId;
+    }
+
+    /**
+     * Returns if the specified edgeKeys (created by createEdgeKey) are identical regardless of the
+     * direction.
+     */
+    public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
+    {
+        return edgeKey1 / 2 == edgeKey2 / 2;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index 8fcd97b5fe..d9279ca1c3 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -18,11 +18,12 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint
+public class GPXEntry extends GHPoint3D
 {
     private long time;
 
@@ -33,10 +34,21 @@ public GPXEntry( GHPoint p, long millis )
 
     public GPXEntry( double lat, double lon, long millis )
     {
-        super(lat, lon);
+        super(lat, lon, Double.NaN);
         this.time = millis;
     }
 
+    public GPXEntry( double lat, double lon, double ele, long millis )
+    {
+        super(lat, lon, ele);
+        this.time = millis;
+    }
+
+    boolean is3D()
+    {
+        return !Double.isNaN(ele);
+    }
+
     /**
      * The time relative to the start time.
      */
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index ac9297f82f..599ca36916 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -24,6 +24,7 @@
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
+import java.nio.charset.Charset;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
@@ -41,8 +42,11 @@
  */
 public class Helper
 {
-    private static final DistanceCalc dce = new DistanceCalcEarth();
+    public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
+    public static final DistanceCalc3D DIST_3D = new DistanceCalc3D();
+    public static final DistancePlaneProjection DIST_PLANE = new DistancePlaneProjection();
     private static final Logger logger = LoggerFactory.getLogger(Helper.class);
+    public static Charset UTF_CS = Charset.forName("UTF-8");
     public static final long MB = 1L << 20;
 
     public static ArrayList<Integer> tIntListToArrayList( TIntList from )
@@ -72,6 +76,15 @@ static String packageToPath( Package pkg )
         return pkg.getName().replaceAll("\\.", File.separator);
     }
 
+    public static int countBitValue( int maxTurnCosts )
+    {
+        double val = Math.log(maxTurnCosts) / Math.log(2);
+        int intVal = (int) val;
+        if (val == intVal)
+            return intVal;
+        return intVal + 1;
+    }
+
     private Helper()
     {
     }
@@ -131,7 +144,7 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
 
     public static List<String> readFile( String file ) throws IOException
     {
-        return readFile(new InputStreamReader(new FileInputStream(file), "UTF-8"));
+        return readFile(new InputStreamReader(new FileInputStream(file), UTF_CS));
     }
 
     public static List<String> readFile( Reader simpleReader ) throws IOException
@@ -152,6 +165,27 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
         }
     }
 
+    public static String isToString( InputStream inputStream ) throws IOException
+    {
+        int size = 1024 * 8;
+        String encoding = "UTF-8";
+        InputStream in = new BufferedInputStream(inputStream, size);
+        try
+        {
+            byte[] buffer = new byte[size];
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            int numRead;
+            while ((numRead = in.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, numRead);
+            }
+            return output.toString(encoding);
+        } finally
+        {
+            in.close();
+        }
+    }
+
     public static int idealIntArraySize( int need )
     {
         return idealByteArraySize(need * 4) / 4;
@@ -260,7 +294,7 @@ public static int calcIndexSize( BBox graphBounds )
         if (!graphBounds.isValid())
             throw new IllegalArgumentException("Bounding box is not valid to calculate index size: " + graphBounds);
 
-        double dist = dce.calcDist(graphBounds.maxLat, graphBounds.minLon,
+        double dist = DIST_EARTH.calcDist(graphBounds.maxLat, graphBounds.minLon,
                 graphBounds.minLat, graphBounds.maxLon);
         // convert to km and maximum is 50000km => 1GB
         dist = Math.min(dist / 1000, 50000);
@@ -374,12 +408,16 @@ public static void cleanMappedByteBuffer( final ByteBuffer buffer )
                 @Override
                 public Object run() throws Exception
                 {
-                    final Method getCleanerMethod = buffer.getClass().getMethod("cleaner");
-                    getCleanerMethod.setAccessible(true);
-                    final Object cleaner = getCleanerMethod.invoke(buffer);
-                    if (cleaner != null)
+                    try
                     {
-                        cleaner.getClass().getMethod("clean").invoke(cleaner);
+                        final Method getCleanerMethod = buffer.getClass().getMethod("cleaner");
+                        getCleanerMethod.setAccessible(true);
+                        final Object cleaner = getCleanerMethod.invoke(buffer);
+                        if (cleaner != null)
+                            cleaner.getClass().getMethod("clean").invoke(cleaner);
+                    } catch (NoSuchMethodException ex)
+                    {
+                        // ignore if method cleaner or clean is not available, like on Android
                     }
                     return null;
                 }
@@ -390,6 +428,15 @@ public Object run() throws Exception
         }
     }
 
+    /**
+     * Trying to force the release of the mapped ByteBuffer. See
+     * http://stackoverflow.com/q/2972986/194609 and use only if you know what you are doing.
+     */
+    public static void cleanHack()
+    {
+        System.gc();
+    }
+
     public static String nf( long no )
     {
         // I like french localization the most: 123654 will be 123 654 instead
@@ -415,4 +462,28 @@ public static final double keepIn( double value, double min, double max )
     {
         return Math.max(min, Math.min(value, max));
     }
+
+    /**
+     * Round the value to the specified exponent
+     */
+    public static double round( double value, int exponent )
+    {
+        double factor = Math.pow(10, exponent);
+        return Math.round(value * factor) / factor;
+    }
+
+    public static final double round6( double value )
+    {
+        return Math.round(value * 1e6) / 1e6;
+    }
+
+    public static final double round4( double value )
+    {
+        return Math.round(value * 1e4) / 1e4;
+    }
+
+    public static final double round2( double value )
+    {
+        return Math.round(value * 100) / 100;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index cd7dad4818..747cd829c8 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,12 +17,16 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
-import java.text.DecimalFormat;
+import java.util.Map;
 
 public class Instruction
 {
-    private static final DistanceCalc distanceCalc = new DistanceCalcEarth();
+    private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -32,50 +36,61 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final int pavementType;
-    private final int wayType;
+    protected String name;
+    protected double radian;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, int wayType, int pavementType, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
         this.sign = sign;
         this.name = name;
         this.points = pl;
-        this.wayType = wayType;
-        this.pavementType = pavementType;
-    }
-
-    public int getPavementType()
-    {
-        return pavementType;
+        this.annotation = ia;
     }
 
-    public int getWayType()
+    public InstructionAnnotation getAnnotation()
     {
-        return wayType;
+        return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName(String name)
+    {
+        this.name = name;
+    }
+
+    public Map<String,Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo(String key, Object value)
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -120,6 +135,11 @@ public long getTime()
         return points.getLongitude(0);
     }
 
+    double getFirstEle()
+    {
+        return points.getElevation(0);
+    }
+
     public PointList getPoints()
     {
         return points;
@@ -139,17 +159,27 @@ long fillGPXList( List<GPXEntry> list, long time,
         long prevTime = time;
         double lat = points.getLatitude(0);
         double lon = points.getLongitude(0);
+        double ele = Double.NaN;
+        boolean is3D = points.is3D();
+        if (is3D)
+            ele = points.getElevation(0);
+
         for (int i = 0; i < len; i++)
         {
+            list.add(new GPXEntry(lat, lon, ele, prevTime));
+
             boolean last = i + 1 == len;
             double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
             double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
+            double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
+            if (is3D)
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
+            else
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
 
-            list.add(new GPXEntry(lat, lon, prevTime));
-            // TODO in the case of elevation data the air-line distance is probably not precise enough
-            prevTime = Math.round(prevTime + this.time * distanceCalc.calcDist(nextLat, nextLon, lat, lon) / distance);
             lat = nextLat;
             lon = nextLon;
+            ele = nextEle;
         }
         return time + this.time;
     }
@@ -159,51 +189,32 @@ public String toString()
     {
         StringBuilder sb = new StringBuilder();
         sb.append('(');
-        sb.append(sign);
-        sb.append(',');
-        sb.append(name);
-        sb.append(',');
-        sb.append(distance);
-        sb.append(',');
+        sb.append(sign).append(',');
+        sb.append(name).append(',');
+        sb.append(distance).append(',');
         sb.append(time);
         sb.append(')');
         return sb.toString();
     }
 
     /**
-     * Return Direction/Compass point based on the first tracksegment of the instruction. If
-     * Instruction does not contain enough coordinate points, NULL will be returned.
-     * <p>
-     * @return
+     * Return the direction like 'NE' based on the first tracksegment of the instruction. If
+     * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String getDirection( Instruction nextI )
+    String calcDirection( Instruction nextI )
     {
-        AngleCalc2D ac = new AngleCalc2D();
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
-            return null;
+            return "";
 
-        String dir = ac.azimuth2compassPoint(azimuth);
-        return dir;
+        return ac.azimuth2compassPoint(azimuth);
     }
 
     /**
-     * Return Azimuth based on the first tracksegment of the instruction. If Instruction does not
-     * contain enough coordinate points, NULL will be returned.
-     * <p>
-     * @return
+     * Return the azimuth in degree based on the first tracksegment of the instruction. If
+     * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String getAzimuth( Instruction nextI )
-    {
-        double az = calcAzimuth(nextI);
-        if (Double.isNaN(az))
-            return null;
-
-        DecimalFormat angleFormatter = new DecimalFormat("#");
-        return angleFormatter.format(az);
-    }
-
-    private double calcAzimuth( Instruction nextI )
+    public double calcAzimuth( Instruction nextI )
     {
         double nextLat;
         double nextLon;
@@ -212,7 +223,7 @@ private double calcAzimuth( Instruction nextI )
         {
             nextLat = points.getLatitude(1);
             nextLon = points.getLongitude(1);
-        } else if (points.getSize() == 1 && null != nextI)
+        } else if (nextI != null && points.getSize() == 1)
         {
             nextLat = nextI.points.getLatitude(0);
             nextLon = nextI.points.getLongitude(0);
@@ -223,11 +234,7 @@ private double calcAzimuth( Instruction nextI )
 
         double lat = points.getLatitude(0);
         double lon = points.getLongitude(0);
-
-        AngleCalc2D ac = new AngleCalc2D();
-
-        double azimuth = ac.calcAzimuth(lat, lon, nextLat, nextLon);
-        return azimuth;
+        return ac.calcAzimuth(lat, lon, nextLat, nextLon);
     }
 
     void checkOne()
@@ -235,4 +242,50 @@ void checkOne()
         if (points.size() < 1)
             throw new IllegalStateException("Instruction must contain at least one point " + toString());
     }
+
+    public String getTurnDescription( Translation tr )
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.FINISH)
+        {
+            str = tr.tr("finish");
+        } else if (indi == Instruction.REACHED_VIA)
+        {
+            str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
+        } else if (indi == Instruction.CONTINUE_ON_STREET)
+        {
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
+        } else
+        {
+            String dir = null;
+            switch (indi)
+            {
+                case Instruction.TURN_SHARP_LEFT:
+                    dir = tr.tr("sharp_left");
+                    break;
+                case Instruction.TURN_LEFT:
+                    dir = tr.tr("left");
+                    break;
+                case Instruction.TURN_SLIGHT_LEFT:
+                    dir = tr.tr("slight_left");
+                    break;
+                case Instruction.TURN_SLIGHT_RIGHT:
+                    dir = tr.tr("slight_right");
+                    break;
+                case Instruction.TURN_RIGHT:
+                    dir = tr.tr("right");
+                    break;
+                case Instruction.TURN_SHARP_RIGHT:
+                    dir = tr.tr("sharp_right");
+                    break;
+            }
+            if (dir == null)
+                throw new IllegalStateException("Indication not found " + indi);
+
+            str = Helper.isEmpty(streetName) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, streetName);
+        }
+        return str;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
new file mode 100644
index 0000000000..c1a02c2d42
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ * @author Peter Karich
+ */
+public class InstructionAnnotation
+{
+    public final static InstructionAnnotation EMPTY = new InstructionAnnotation();
+    private boolean empty;
+    private int importance;
+    private String message;
+
+    private InstructionAnnotation()
+    {
+        setEmpty();
+    }
+
+    public InstructionAnnotation( int importance, String message )
+    {
+        if (message.isEmpty() && importance == 0)
+        {
+            setEmpty();
+        } else
+        {
+            this.empty = false;
+            this.importance = importance;
+            this.message = message;
+        }
+    }
+
+    private void setEmpty()
+    {
+        this.empty = true;
+        this.importance = 0;
+        this.message = "";
+    }
+
+    public boolean isEmpty()
+    {
+        return empty;
+    }
+
+    public int getImportance()
+    {
+        return importance;
+    }
+
+    public String getMessage()
+    {
+        return message;
+    }
+
+    @Override
+    public String toString()
+    {
+        return importance + ": " + getMessage();
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 3;
+        hash = 83 * hash + this.importance;
+        hash = 83 * hash + (this.message != null ? this.message.hashCode() : 0);
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        final InstructionAnnotation other = (InstructionAnnotation) obj;
+        if (this.importance != other.importance)
+            return false;
+        if ((this.message == null) ? (other.message != null) : !this.message.equals(other.message))
+            return false;
+        return true;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 5a1a93d6f1..5d36783569 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -26,16 +26,24 @@
  */
 public class InstructionList implements Iterable<Instruction>
 {
+    public static final InstructionList EMPTY = new InstructionList();
     private final List<Instruction> instructions;
+    private final Translation tr;
 
-    public InstructionList()
+    private InstructionList()
     {
-        this(10);
+        this(0, null);
     }
 
-    public InstructionList( int cap )
+    public InstructionList( Translation tr )
+    {
+        this(10, tr);
+    }
+
+    public InstructionList( int cap, Translation tr )
     {
         instructions = new ArrayList<Instruction>(cap);
+        this.tr = tr;
     }
 
     public void add( Instruction instr )
@@ -53,45 +61,7 @@ public int size()
         return instructions.size();
     }
 
-    public List<String> createDistances( TranslationMap.Translation tr, boolean mile )
-    {
-        List<String> labels = new ArrayList<String>(instructions.size());
-        for (int i = 0; i < instructions.size(); i++)
-        {
-            double distInMeter = instructions.get(i).getDistance();
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
-            {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
-            }
-        }
-        return labels;
-    }
-
-    public List<Map<String, Object>> createJson( TranslationMap.Translation tr )
+    public List<Map<String, Object>> createJson()
     {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
         int pointsIndex = 0;
@@ -101,10 +71,21 @@ public int size()
             Map<String, Object> instrJson = new HashMap<String, Object>();
             instrList.add(instrJson);
 
-            instrJson.put("text", Helper.firstBig(getTurnDescription(instruction, tr)));
+            InstructionAnnotation ia = instruction.getAnnotation();
+            String str = instruction.getTurnDescription(tr);
+            if (Helper.isEmpty(str))
+                str = ia.getMessage();
+            instrJson.put("text", Helper.firstBig(str));
+            if (!ia.isEmpty())
+            {
+                instrJson.put("annotationText", ia.getMessage());
+                instrJson.put("annotationImportance", ia.getImportance());
+            }
+
             instrJson.put("time", instruction.getTime());
-            instrJson.put("distance", instruction.getDistance());
+            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
@@ -119,52 +100,6 @@ public int size()
         return instrList;
     }
 
-    private String getTurnDescription( Instruction instruction, TranslationMap.Translation tr )
-    {
-        String str;
-        String n = getWayName(instruction.getName(), instruction.getPavementType(), instruction.getWayType(), tr);
-        int indi = instruction.getSign();
-        if (indi == Instruction.FINISH)
-        {
-            str = tr.tr("finish");
-        } else if (indi == Instruction.REACHED_VIA)
-        {
-            str = tr.tr("stopover", ((FinishInstruction) instruction).getViaPosition());
-        } else if (indi == Instruction.CONTINUE_ON_STREET)
-        {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
-        } else
-        {
-            String dir = null;
-            switch (indi)
-            {
-                case Instruction.TURN_SHARP_LEFT:
-                    dir = tr.tr("sharp_left");
-                    break;
-                case Instruction.TURN_LEFT:
-                    dir = tr.tr("left");
-                    break;
-                case Instruction.TURN_SLIGHT_LEFT:
-                    dir = tr.tr("slight_left");
-                    break;
-                case Instruction.TURN_SLIGHT_RIGHT:
-                    dir = tr.tr("slight_right");
-                    break;
-                case Instruction.TURN_RIGHT:
-                    dir = tr.tr("right");
-                    break;
-                case Instruction.TURN_SHARP_RIGHT:
-                    dir = tr.tr("sharp_right");
-                    break;
-            }
-            if (dir == null)
-                throw new IllegalStateException("Indication not found " + indi);
-
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
-        }
-        return str;
-    }
-
     public boolean isEmpty()
     {
         return instructions.isEmpty();
@@ -211,17 +146,30 @@ public String toString()
         Instruction lastI = get(size() - 1);
         if (lastI.points.size() != 1)
             throw new IllegalStateException("Last instruction must have exactly one point but was " + lastI.points.size());
-        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon();
-        gpxList.add(new GPXEntry(lastLat, lastLon, timeOffset));
+        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon(),
+                lastEle = lastI.getPoints().is3D() ? lastI.getFirstEle() : Double.NaN;
+        gpxList.add(new GPXEntry(lastLat, lastLon, lastEle, timeOffset));
         return gpxList;
     }
 
     /**
-     * Creates the GPX Format out of the points.
+     * Creates the standard GPX string out of the points according to the schema found here:
+     * https://graphhopper.com/public/schema/gpx-1.1.xsd
      * <p/>
      * @return string to be stored as gpx file
      */
+    public String createGPX()
+    {
+        return createGPX("GraphHopper", 0, "GMT");
+    }
+
     public String createGPX( String trackName, long startTimeMillis, String timeZoneId )
+    {
+        boolean includeElevation = getSize() > 0 ? get(0).getPoints().is3D() : false;
+        return createGPX(trackName, startTimeMillis, timeZoneId, includeElevation);
+    }
+
+    public String createGPX( String trackName, long startTimeMillis, String timeZoneId, boolean includeElevation )
     {
         SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
         TimeZone tz = TimeZone.getDefault();
@@ -230,47 +178,50 @@ public String createGPX( String trackName, long startTimeMillis, String timeZone
 
         formatter.setTimeZone(tz);
         String header = "<?xml version='1.0' encoding='UTF-8' standalone='no' ?>"
-                + "<gpx xmlns='http://www.topografix.com/GPX/1/1' creator='Graphhopper' version='1.1' >"
-                + "<metadata>"
+                + "<gpx xmlns='http://www.topografix.com/GPX/1/1' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'"
+                + " creator='Graphhopper' version='1.1'"
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh='https://graphhopper.com/public/schema/gpx/1.1'>"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
                 + "<link href='http://graphhopper.com'>"
                 + "<text>GraphHopper GPX</text>"
                 + "</link>"
                 + "<time>" + tzHack(formatter.format(startTimeMillis)) + "</time>"
                 + "</metadata>";
         StringBuilder track = new StringBuilder(header);
-        track.append("<trk><name>").append(trackName).append("</name>");
+        if (!isEmpty())
+        {
+            track.append("\n<rte>");
+            Instruction nextInstr = null;
+            for (Instruction currInstr : instructions)
+            {
+                if (null != nextInstr)
+                    createRteptBlock(track, nextInstr, currInstr);
+
+                nextInstr = currInstr;
+            }
+            createRteptBlock(track, nextInstr, null);
+            track.append("</rte>");
+        }
+
+        track.append("\n<trk><name>").append(trackName).append("</name>");
 
         track.append("<trkseg>");
         for (GPXEntry entry : createGPXList())
         {
-            track.append("\n<trkpt lat='").append(entry.getLat()).append("' lon='").append(entry.getLon()).append("'>");
+            track.append("\n<trkpt lat='").append(Helper.round6(entry.getLat()));
+            track.append("' lon='").append(Helper.round6(entry.getLon())).append("'>");
+            if (includeElevation)
+                track.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
             track.append("<time>").append(tzHack(formatter.format(startTimeMillis + entry.getMillis()))).append("</time>");
             track.append("</trkpt>");
         }
         track.append("</trkseg>");
         track.append("</trk>");
 
-        if (!isEmpty())
-        {
-            track.append("<rte>");
-            //Instruction prevI = null, middleI = null, nextI = null;
-            Instruction thisI = null, nextI;
-
-            for (Instruction i : instructions)
-            {
-                nextI = i;
-
-                if (null != thisI)
-                {
-                    createRteptBlock(track, thisI, nextI);
-                }
-                thisI = nextI;
-            }
-            createRteptBlock(track, thisI, null);
-            track.append("</rte>");
-        }
-
-        // TODO #147 use wpt for via points!
+        // we could now use 'wpt' for via points
         track.append("</gpx>");
         return track.toString().replaceAll("\\'", "\"");
     }
@@ -283,114 +234,31 @@ private static String tzHack( String str )
         return str.substring(0, str.length() - 2) + ":" + str.substring(str.length() - 2);
     }
 
-    private static final TranslationMap.Translation NO_TRANSLATE = new TranslationMap.Translation()
-    {
-
-        @Override
-        public String tr( String key, Object... params )
-        {
-            if (key.equals("turn_onto") || key.equals("turn"))
-                key = "";
-
-            for (Object p : params)
-            {
-                key += " " + p.toString();
-            }
-            return key.trim();
-        }
-
-        @Override
-        public Map<String, String> asMap()
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        @Override
-        public Locale getLocale()
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        @Override
-        public String getLanguage()
-        {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-    };
-
     private void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
     {
-        output.append("<rtept lat=\"").append(InstructionList.round(instruction.getFirstLat(), 6)).
-                append("\" lon=\"").append(InstructionList.round(instruction.getFirstLon(), 6)).append("\">");
+        output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
+                append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
 
         if (!instruction.getName().isEmpty())
-            output.append("<desc>").append(getTurnDescription(instruction, NO_TRANSLATE)).append("</desc>");
+            output.append("<desc>").append(instruction.getTurnDescription(tr)).append("</desc>");
 
         output.append("<extensions>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
 
-        output.append("<distance>").append((int) instruction.getDistance()).append("</distance>");
-        output.append("<time>").append(instruction.getTime()).append("</time>");
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
 
-        String direction = instruction.getDirection(nextI);
-        if (null != direction)
-        {
-            output.append("<direction>").append(direction).append("</direction>");
-        }
-        String azimuth = instruction.getAzimuth(nextI);
-        if (null != azimuth)
-        {
-            output.append("<azimuth>").append(azimuth).append("</azimuth>");
-        }
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
+
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
         output.append("</extensions>");
         output.append("</rtept>");
     }
 
-    public static String getWayName( String name, int paveType, int wayType, TranslationMap.Translation tr )
-    {
-        String pavementName = "";
-        if (paveType == 1)
-            pavementName = tr.tr("unpaved");
-
-        String wayClass = "";
-        switch (wayType)
-        {
-            case 0:
-                wayClass = tr.tr("road");
-                break;
-            case 1:
-                wayClass = tr.tr("pushing_section");
-                break;
-            case 2:
-                wayClass = tr.tr("cycleway");
-                break;
-            case 3:
-                wayClass = tr.tr("way");
-                break;
-        }
-
-        if (name.isEmpty())
-            if (pavementName.isEmpty())
-                return wayClass;
-            else
-                return wayClass + ", " + pavementName;
-        else if (pavementName.isEmpty())
-            if (wayType == 0)
-                return name;
-            else
-                return name + ", " + wayClass;
-        else
-            return name + ", " + pavementName;
-    }
-
-    /**
-     * Round the value to the specified exponent
-     */
-    static double round( double value, int exponent )
-    {
-        double factor = Math.pow(10, exponent);
-        return Math.round(value * factor) / factor;
-    }
-
     /**
      * @return list of lat lon
      */
@@ -403,4 +271,75 @@ static double round( double value, int exponent )
         }
         return res;
     }
+
+    /**
+     * This method is useful for navigation devices to find the next instruction for the specified
+     * coordinate (e.g. the current position).
+     * <p>
+     * @param maxDistance the maximum acceptable distance to the instruction (in meter)
+     * @return the next Instruction or null if too far away.
+     */
+    public Instruction find( double lat, double lon, double maxDistance )
+    {
+        // handle special cases
+        if (getSize() == 0)
+        {
+            return null;
+        }
+        PointList points = get(0).getPoints();
+        double prevLat = points.getLatitude(0);
+        double prevLon = points.getLongitude(0);
+        DistanceCalc distCalc = Helper.DIST_EARTH;
+        double foundMinDistance = distCalc.calcNormalizedDist(lat, lon, prevLat, prevLon);
+        int foundInstruction = 0;
+
+        // Search the closest edge to the query point
+        if (getSize() > 1)
+        {
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
+            {
+                points = get(instructionIndex).getPoints();
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
+                {
+                    double currLat = points.getLatitude(pointIndex);
+                    double currLon = points.getLongitude(pointIndex);
+
+                    if (!(instructionIndex == 0 && pointIndex == 0))
+                    {
+                        // calculate the distance from the point to the edge
+                        double distance;
+                        int index = instructionIndex;
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
+                        {
+                            distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
+                            if (pointIndex > 0)
+                                index++;
+                        } else
+                        {
+                            distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                        }
+
+                        if (distance < foundMinDistance)
+                        {
+                            foundMinDistance = distance;
+                            foundInstruction = index;
+                        }
+                    }
+
+                    prevLat = currLat;
+                    prevLon = currLon;
+                }
+            }
+        }
+
+        if (distCalc.calcDenormalizedDist(foundMinDistance) > maxDistance)
+            return null;
+
+        // special case finish condition
+        if (foundInstruction == getSize())
+            foundInstruction--;
+
+        return get(foundInstruction);
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
new file mode 100644
index 0000000000..4e3e493706
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -0,0 +1,179 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A properties map with convenient accessors
+ * <p>
+ * @author Peter Karich
+ */
+public class PMap
+{
+    private final Map<String, String> map;
+
+    public PMap()
+    {
+        this(5);
+    }
+
+    public PMap( int capacity )
+    {
+        this(new HashMap<String, String>(capacity));
+    }
+
+    public PMap( Map<String, String> map )
+    {
+        this.map = map;
+    }
+
+    public PMap put( String key, Object str )
+    {
+        if (str == null)
+            throw new NullPointerException("Value cannot be null. Use remove instead.");
+
+        map.put(key.toLowerCase(), str.toString());
+        return this;
+    }
+
+    public PMap remove( String key )
+    {
+        map.remove(key);
+        return this;
+    }
+
+    public long getLong( String key, long _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Long.parseLong(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public int getInt( String key, int _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Integer.parseInt(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public boolean getBool( String key, boolean _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Boolean.parseBoolean(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public double getDouble( String key, double _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Double.parseDouble(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public String get( String key, String _default )
+    {
+        String str = get(key);
+        if (Helper.isEmpty(str))
+        {
+            return _default;
+        }
+        return str;
+    }
+
+    String get( String key )
+    {
+        if (Helper.isEmpty(key))
+        {
+            return "";
+        }
+        String val = map.get(key.toLowerCase());
+        if (val == null)
+        {
+            return "";
+        }
+        return val;
+    }
+
+    private Map<String, String> getMap()
+    {
+        return map;
+    }
+
+    public PMap merge( PMap read )
+    {
+        return merge(read.getMap());
+    }
+
+    PMap merge( Map<String, String> map )
+    {
+        for (Map.Entry<String, String> e : map.entrySet())
+        {
+            if (Helper.isEmpty(e.getKey()))
+            {
+                continue;
+            }
+            this.getMap().put(e.getKey().toLowerCase(), e.getValue());
+        }
+        return this;
+    }
+
+    public boolean has( String key )
+    {
+        return this.getMap().containsKey(key);
+    }
+
+    @Override
+    public String toString()
+    {
+        return this.getMap().toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 10cdae306b..a8c8288634 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -20,7 +20,6 @@
 
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.Path;
-import com.graphhopper.util.shapes.GHPlace;
 import java.util.List;
 
 /**
@@ -31,42 +30,48 @@
  */
 public class PathMerger
 {
-    boolean enableInstructions = true;
-    boolean simplifyRequest = false;
-    DouglasPeucker douglasPeucker;
-    boolean calcPoints;
+    private boolean enableInstructions = true;
+    private boolean simplifyResponse = true;
+    private DouglasPeucker douglasPeucker;
+    private boolean calcPoints = true;
 
-    public void doWork( GHResponse rsp, List<Path> paths )
+    public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
         int origPoints = 0;
         StopWatch sw;
         long fullMillis = 0;
+        double fullWeight = 0;
         double fullDistance = 0;
         boolean allFound = true;
 
-        InstructionList fullInstructions = new InstructionList();
-        PointList fullPoints = null;
+        InstructionList fullInstructions = new InstructionList(tr);
+        PointList fullPoints = PointList.EMPTY;
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++)
         {
             Path path = paths.get(pathIndex);
             fullMillis += path.getMillis();
             fullDistance += path.getDistance();
+            fullWeight += path.getWeight();
             if (enableInstructions)
             {
-                InstructionList il = path.calcInstructions();
+                InstructionList il = path.calcInstructions(tr);
                 sw = new StopWatch().start();
 
                 if (!il.isEmpty())
                 {
-                    if (fullPoints == null)
-                        fullPoints = createSimilarPL(il.get(0).getPoints());
+                    if (fullPoints.isEmpty())
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
 
                     for (Instruction i : il)
                     {
-                        if (simplifyRequest)
+                        if (simplifyResponse)
                         {
                             origPoints += i.getPoints().size();
-                            douglasPeucker.simplify(i.getPoints());                            
+                            douglasPeucker.simplify(i.getPoints());
                         }
                         fullInstructions.add(i);
                         fullPoints.add(i.getPoints());
@@ -80,14 +85,14 @@ public void doWork( GHResponse rsp, List<Path> paths )
                         fi.setVia(pathIndex + 1);
                     }
                 }
-                
+
             } else if (calcPoints)
             {
-                PointList tmpPoints = path.calcPoints();                
-                if (fullPoints == null)
-                    fullPoints = createSimilarPL(tmpPoints);
+                PointList tmpPoints = path.calcPoints();
+                if (fullPoints.isEmpty())
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
-                if (simplifyRequest)
+                if (simplifyResponse)
                 {
                     origPoints = tmpPoints.getSize();
                     sw = new StopWatch().start();
@@ -99,8 +104,8 @@ public void doWork( GHResponse rsp, List<Path> paths )
 
             allFound = allFound && path.isFound();
         }
-        
-        if (fullPoints != null)
+
+        if (!fullPoints.isEmpty())
         {
             String debug = rsp.getDebugInfo() + ", simplify (" + origPoints + "->" + fullPoints.getSize() + ")";
             rsp.setDebugInfo(debug);
@@ -109,17 +114,17 @@ public void doWork( GHResponse rsp, List<Path> paths )
         if (enableInstructions)
             rsp.setInstructions(fullInstructions);
 
-        rsp.setFound(allFound).
-                setPoints(fullPoints).
+        if (!allFound)
+        {
+            rsp.addError(new RuntimeException("Not found"));
+        }
+
+        rsp.setPoints(fullPoints).
+                setRouteWeight(fullWeight).
                 setDistance(fullDistance).
                 setMillis(fullMillis);
     }
 
-    PointList createSimilarPL( PointList pl )
-    {
-        return new PointList(pl.size(), pl.is3D());
-    }
-
     public PathMerger setCalcPoints( boolean calcPoints )
     {
         this.calcPoints = calcPoints;
@@ -132,9 +137,9 @@ public PathMerger setDouglasPeucker( DouglasPeucker douglasPeucker )
         return this;
     }
 
-    public PathMerger setSimplifyRequest( boolean simplifyRequest )
+    public PathMerger setSimplifyResponse( boolean simplifyRes )
     {
-        this.simplifyRequest = simplifyRequest;
+        this.simplifyResponse = simplifyRes;
         return this;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 665c8b8cc3..1d25102e5b 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -31,7 +31,7 @@
  */
 public class PointList implements PointAccess
 {
-    private final static DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private static String ERR_MSG = "Tried to access PointList with too big index!";
     private double[] latitudes;
     private double[] longitudes;
@@ -94,16 +94,16 @@ else if (!Double.isNaN(ele))
 
     private void incCap( int newSize )
     {
-        if (newSize >= latitudes.length)
-        {
-            int cap = (int) (newSize * 1.7);
-            if (cap < 8)
-                cap = 8;
-            latitudes = Arrays.copyOf(latitudes, cap);
-            longitudes = Arrays.copyOf(longitudes, cap);
-            if (is3D)
-                elevations = Arrays.copyOf(elevations, cap);
-        }
+        if (newSize < latitudes.length)
+            return;
+
+        int cap = newSize * 2;
+        if (cap < 15)
+            cap = 15;
+        latitudes = Arrays.copyOf(latitudes, cap);
+        longitudes = Arrays.copyOf(longitudes, cap);
+        if (is3D)
+            elevations = Arrays.copyOf(elevations, cap);
     }
 
     public void add( double lat, double lon )
@@ -285,18 +285,24 @@ public String toString()
      */
     public List<Double[]> toGeoJson()
     {
+        return toGeoJson(is3D);
+    }
+
+    public List<Double[]> toGeoJson( boolean includeElevation )
+    {
+
         ArrayList<Double[]> points = new ArrayList<Double[]>(size);
         for (int i = 0; i < size; i++)
         {
-            if (is3D)
+            if (includeElevation)
                 points.add(new Double[]
                 {
-                    getLongitude(i), getLatitude(i), getElevation(i)
+                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)), Helper.round2(getElevation(i))
                 });
             else
                 points.add(new Double[]
                 {
-                    getLongitude(i), getLatitude(i)
+                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
                 });
         }
         return points;
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..3c9e78af4b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,136 @@
+package com.graphhopper.util;
+
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by jan on 02.02.15.
+ *
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+
+    private int exitNumber = 0;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl)
+    {
+        super(sign, name, ia, pl);
+    }
+  
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber(int exitNumber)
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation(double deltaIn)
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        }
+        else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle  -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        }
+        else
+        {
+            double tmpRadian = Math.PI - clockwise*radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian(double radian)
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", JSONObject.NULL);
+        } else {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+        return tmpMap;
+        
+    }
+    
+    @Override
+    public String getTurnDescription(Translation tr)
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber()) :
+                        tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/util/Translation.java b/core/src/main/java/com/graphhopper/util/Translation.java
new file mode 100644
index 0000000000..a99296c402
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/Translation.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public interface Translation
+{
+
+    String tr( String key, Object... params );
+
+    Map<String, String> asMap();
+
+    Locale getLocale();
+
+    String getLanguage();
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 3c6f90d7a4..56912dc470 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -25,16 +25,17 @@
  * A class which manages the translations in-memory. Translations are managed here:
  * https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0
  * <p/>
- * and can be easily converted to a language file via: ./core/files/update_translations.sh
- * GraphHopper.csv
- * <p/>
+ * See here for more information: ./docs/core/translations.md
+ * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
-    // use 'en' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "de_DE", "en_US", "es", "fr", "ja", "pt_PT", "pt_BR", "ro", "ru", "si", "tr");
-    private Map<String, Translation> translations = new HashMap<String, Translation>();
+    // ISO codes (639-1), use 'en_US' as reference
+    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
+            "fr", "gl", "he", "it", "ja", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
+            "vi_VI", "zh_CN");
+    private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
      * This loads the translation files from the specified folder.
@@ -49,7 +50,7 @@ public TranslationMap doImport( File folder )
                 trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
                 add(trMap);
             }
-            checkTranslations();
+            postImportHook();
             return this;
         } catch (Exception ex)
         {
@@ -70,7 +71,7 @@ public TranslationMap doImport()
                 trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
                 add(trMap);
             }
-            checkTranslations();
+            postImportHook();
             return this;
         } catch (Exception ex)
         {
@@ -82,8 +83,17 @@ public void add( Translation tr )
     {
         Locale locale = tr.getLocale();
         translations.put(locale.toString(), tr);
-        if (!locale.getCountry().isEmpty())
+        if (!locale.getCountry().isEmpty() && !translations.containsKey(tr.getLanguage()))
             translations.put(tr.getLanguage(), tr);
+
+        // Map old Java 'standard' to latest, Java is a bit ugly here: http://stackoverflow.com/q/13974169/194609
+        // Hebrew
+        if ("iw".equals(locale.getLanguage()))
+            translations.put("he", tr);
+
+        // Indonesia
+        if ("in".equals(locale.getLanguage()))
+            translations.put("id", tr);
     }
 
     /**
@@ -103,7 +113,7 @@ public Translation getWithFallBack( Locale locale )
     }
 
     /**
-     * Returns the Translation object for the specified locale.
+     * Returns the Translation object for the specified locale and returns null if not found.
      */
     public Translation get( String locale )
     {
@@ -122,46 +132,45 @@ public static int countOccurence( String phrase, String splitter )
         return phrase.trim().split(splitter).length;
     }
 
-    private void checkTranslations()
+    /**
+     * This method does some checks and fills missing translation from en
+     */
+    private void postImportHook()
     {
         Map<String, String> enMap = get("en").asMap();
-        // check against english!
         StringBuilder sb = new StringBuilder();
         for (Translation tr : translations.values())
         {
             Map<String, String> trMap = tr.asMap();
-            for (Entry<String, String> e : enMap.entrySet())
+            for (Entry<String, String> enEntry : enMap.entrySet())
             {
-                String value = trMap.get(e.getKey());
+                String value = trMap.get(enEntry.getKey());
                 if (Helper.isEmpty(value))
+                {
+                    trMap.put(enEntry.getKey(), enEntry.getValue());
                     continue;
-                int expectedCount = countOccurence(e.getValue(), "\\%");
+                }
+
+                int expectedCount = countOccurence(enEntry.getValue(), "\\%");
                 if (expectedCount != countOccurence(value, "\\%"))
                 {
-                    sb.append(tr.getLocale()).append(" - error in ").append(e.getKey()).append("->").
+                    sb.append(tr.getLocale()).append(" - error in ").append(enEntry.getKey()).append("->").
                             append(value).append("\n");
                 }
             }
         }
+
         if (sb.length() > 0)
+        {
+            System.out.println(sb);
             throw new IllegalStateException(sb.toString());
-    }
-
-    public static interface Translation
-    {
-        String tr( String key, Object... params );
-
-        Map<String, String> asMap();
-
-        Locale getLocale();
-
-        String getLanguage();
+        }
     }
 
     public static class TranslationHashMap implements Translation
     {
         private final Map<String, String> map = new HashMap<String, String>();
-        private final Locale locale;
+        final Locale locale;
 
         public TranslationHashMap( Locale locale )
         {
@@ -221,7 +230,7 @@ public TranslationHashMap doImport( InputStream is )
                 throw new IllegalStateException("No input stream found in class path!?");
             try
             {
-                for (String line : Helper.readFile(new InputStreamReader(is, "UTF-8")))
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
                 {
                     if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
                         continue;
@@ -234,9 +243,6 @@ public TranslationHashMap doImport( InputStream is )
                         throw new IllegalStateException("No key provided:" + line);
 
                     String value = line.substring(index + 1);
-                    if (value.isEmpty() && !key.contains("web"))
-                        throw new IllegalStateException("A key for the core cannot be empty: " + key);
-
                     if (!value.isEmpty())
                         put(key, value);
 
diff --git a/core/src/main/java/com/graphhopper/util/TurnCostIterator.java b/core/src/main/java/com/graphhopper/util/TurnCostIterator.java
deleted file mode 100644
index 84a5661716..0000000000
--- a/core/src/main/java/com/graphhopper/util/TurnCostIterator.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.graphhopper.util;
-
-/**
- * @author Karl Hbner
- */
-public interface TurnCostIterator
-{
-
-    public static int ANY_EDGE = -2;
-
-    public boolean next();
-
-    public int edgeFrom();
-
-    public int edgeTo();
-
-    public int costs();
-
-}
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index bcb4fee96e..5a68816e8d 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -26,14 +26,6 @@
  */
 public class Unzipper
 {
-    private int size = 1024 * 8;
-
-    public Unzipper setSize( int size )
-    {
-        this.size = size;
-        return this;
-    }
-
     public void unzip( String from, boolean remove ) throws IOException
     {
         String to = Helper.pruneFileEnd(from);
@@ -66,7 +58,7 @@ public void unzip( InputStream fromIs, File toFolder, ProgressListener progressL
         try
         {
             ZipEntry ze = zis.getNextEntry();
-            byte[] buffer = new byte[size];
+            byte[] buffer = new byte[8 * 1024];
             while (ze != null)
             {
                 if (ze.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index fd677f9812..31b56569a7 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -19,65 +19,20 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
-import gnu.trove.stack.array.TIntArrayStack;
 
 /**
- * This class can be used for breadth first search (BFS) or depth first search (DFS)
+ * This abstract class defines commonalities for BFS and DFS
  * <p/>
- * @author Peter Karich
+ * @author Jan Slter
  */
-public class XFirstSearch
+public abstract class XFirstSearch
 {
-    /**
-     * interface to use a queue (FIFO) OR a stack (LIFO)
-     */
-    interface HelperColl
-    {
-        boolean isEmpty();
-
-        int pop();
-
-        void push( int v );
-    }
-
     protected GHBitSet createBitSet()
     {
         return new GHBitSetImpl();
     }
 
-    public void start( EdgeExplorer explorer, int startNode, boolean depthFirst )
-    {
-        HelperColl coll;
-        if (depthFirst)
-        {
-            coll = new MyIntStack();
-        } else
-        {
-            coll = new MyHelperIntQueue();
-        }
-
-        GHBitSet visited = createBitSet();
-        visited.add(startNode);
-        coll.push(startNode);
-        int current;
-        while (!coll.isEmpty())
-        {
-            current = coll.pop();
-            if (goFurther(current))
-            {
-                EdgeIterator iter = explorer.setBaseNode(current);
-                while (iter.next())
-                {
-                    int connectedId = iter.getAdjNode();
-                    if (checkAdjacent(iter) && !visited.contains(connectedId))
-                    {
-                        visited.add(connectedId);
-                        coll.push(connectedId);
-                    }
-                }
-            }
-        }
-    }
+    public abstract void start( EdgeExplorer explorer, int startNode );
 
     protected boolean goFurther( int nodeId )
     {
@@ -88,17 +43,4 @@ protected boolean checkAdjacent( EdgeIteratorState edge )
     {
         return true;
     }
-
-    static class MyIntStack extends TIntArrayStack implements HelperColl
-    {
-        @Override
-        public boolean isEmpty()
-        {
-            return super.size() == 0;
-        }
-    }
-
-    static class MyHelperIntQueue extends SimpleIntDeque implements HelperColl
-    {
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 2ac7c8a57c..09e46810ca 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
 import java.util.ArrayList;
 import java.util.List;
@@ -226,16 +227,16 @@ public boolean isValid()
     public List<Double> toGeoJson()
     {
         List<Double> list = new ArrayList<Double>(4);
-        list.add(minLon);
-        list.add(minLat);
+        list.add(Helper.round6(minLon));
+        list.add(Helper.round6(minLat));
         // hmh
         if (is3D)
-            list.add(minEle);
+            list.add(Helper.round2(minEle));
 
-        list.add(maxLon);
-        list.add(maxLat);
+        list.add(Helper.round6(maxLon));
+        list.add(Helper.round6(maxLat));
         if (is3D)
-            list.add(maxEle);
+            list.add(Helper.round2(maxEle));
 
         return list;
     }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
index 2ff252007a..0eee29724e 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -18,15 +18,14 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * @author Peter Karich
  */
 public class Circle implements Shape
 {
-    private final static DistanceCalc SINGLETON = new DistanceCalcEarth();
-    private DistanceCalc calc = SINGLETON;
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final double radiusInKm;
     private final double lat;
     private final double lon;
@@ -35,7 +34,7 @@
 
     public Circle( double lat, double lon, double radiusInMeter )
     {
-        this(lat, lon, radiusInMeter, SINGLETON);
+        this(lat, lon, radiusInMeter, Helper.DIST_EARTH);
     }
 
     public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java b/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java
deleted file mode 100644
index 967334e4b7..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- * Single precision coordinates without an associated value. To add one - subclass.
- * <p/>
- * @author Peter Karich
- */
-public class CoordFloat<T>
-{
-
-    public float lat;
-    public float lon;
-
-    public CoordFloat()
-    {
-    }
-
-    public CoordFloat( float lat, float lon )
-    {
-        this.lat = lat;
-        this.lon = lon;
-    }
-
-    public void setValue( T t )
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    public T getValue()
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    @Override
-    public String toString()
-    {
-        return lat + "," + lon;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java
deleted file mode 100644
index b4258be814..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-import com.graphhopper.util.NumHelper;
-
-/**
- * Double precision coordinates without an associated value. To add one - subclass.
- * <p/>
- * @author Peter Karich
- */
-public class CoordTrig<T>
-{
-    public double lat = Double.NaN;
-    public double lon = Double.NaN;
-
-    public CoordTrig()
-    {
-    }
-
-    public CoordTrig( double lat, double lon )
-    {
-        this.lat = lat;
-        this.lon = lon;
-    }
-
-    public double getLon()
-    {
-        return lon;
-    }
-
-    public double getLat()
-    {
-        return lat;
-    }
-
-    public boolean isValid()
-    {
-        return !Double.isNaN(lat) && !Double.isNaN(lon);
-    }
-
-    public void setValue( T t )
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    public T getValue()
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    @Override
-    public int hashCode()
-    {
-        int hash = 7;
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
-        return hash;
-    }
-
-    @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-            return false;
-
-        @SuppressWarnings("unchecked")
-        final CoordTrig<T> other = (CoordTrig<T>) obj;
-        return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
-    }
-
-    @Override
-    public String toString()
-    {
-        return lat + "," + lon;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java
deleted file mode 100644
index 1bae9fd822..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- *
- * @author Peter Karich
- */
-public class CoordTrigIntEntry extends CoordTrig<Integer>
-{
-    private int v;
-
-    public CoordTrigIntEntry()
-    {
-    }
-
-    public CoordTrigIntEntry( int o, double lat, double lon )
-    {
-        super(lat, lon);
-        this.v = o;
-    }
-
-    @Override
-    public void setValue( Integer t )
-    {
-        v = t;
-    }
-
-    @Override
-    public Integer getValue()
-    {
-        return v;
-    }
-
-    @Override
-    public String toString()
-    {
-        return super.toString() + " value:" + v;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java
deleted file mode 100644
index f3cf56d9bf..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- *
- * @author Peter Karich
- */
-public class CoordTrigLongEntry extends CoordTrig<Long>
-{
-    private long v;
-
-    public CoordTrigLongEntry()
-    {
-    }
-
-    public CoordTrigLongEntry( long o, double lat, double lon )
-    {
-        super(lat, lon);
-        this.v = o;
-    }
-
-    @Override
-    public void setValue( Long t )
-    {
-        v = t;
-    }
-
-    @Override
-    public Long getValue()
-    {
-        return v;
-    }
-
-    @Override
-    public String toString()
-    {
-        return super.toString() + " value:" + v;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
index ae5a826283..5d855629bc 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
@@ -24,7 +24,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class GHPlace extends CoordTrig<String>
+public class GHPlace extends GHPoint
 {
     private String name = "";
 
@@ -39,11 +39,9 @@ public GHPlace( String name )
 
     public GHPlace( double lat, double lon )
     {
-        this.lat = lat;
-        this.lon = lon;
+        super(lat, lon);
     }
 
-    @Override
     public void setValue( String t )
     {
         setName(t);
@@ -77,33 +75,4 @@ public String toString()
 
         return str.trim();
     }
-
-    public static GHPlace parse( String str )
-    {
-        // if the point is in the format of lat,lon we don't need to call geocoding service
-        String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2)
-        {
-            try
-            {
-                double fromLat = Double.parseDouble(fromStrs[0]);
-                double fromLon = Double.parseDouble(fromStrs[1]);
-                return new GHPlace(fromLat, fromLon);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Attention: geoJson is LON,LAT
-     */
-    public Double[] toGeoJson()
-    {
-        return new Double[]
-        {
-            lon, lat
-        };
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 866b1ef911..5ca18aa337 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -17,18 +17,76 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.graphhopper.util.NumHelper;
+
 /**
  * @author Peter Karich
  */
-public class GHPoint extends CoordTrig<Void>
+public class GHPoint
 {
+    public double lat = Double.NaN;
+    public double lon = Double.NaN;
+
     public GHPoint()
     {
     }
 
     public GHPoint( double lat, double lon )
     {
-        super(lat, lon);
+        this.lat = lat;
+        this.lon = lon;
+    }
+
+    public double getLon()
+    {
+        return lon;
+    }
+
+    public double getLat()
+    {
+        return lat;
+    }
+
+    public boolean isValid()
+    {
+        return !Double.isNaN(lat) && !Double.isNaN(lon);
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 7;
+        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
+        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+
+        @SuppressWarnings("unchecked")
+        final GHPoint other = (GHPoint) obj;
+        return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
+    }
+
+    @Override
+    public String toString()
+    {
+        return lat + "," + lon;
+    }
+
+    /**
+     * Attention: geoJson is LON,LAT
+     */
+    public Double[] toGeoJson()
+    {
+        return new Double[]
+        {
+            lon, lat
+        };
     }
 
     public static GHPoint parse( String str )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
index 77071ae7e5..cab721686c 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -18,12 +18,13 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.graphhopper.util.NumHelper;
+
 /**
  * @author Peter Karich
  */
 public class GHPoint3D extends GHPoint
 {
-
     public double ele;
 
     public GHPoint3D( double lat, double lon, double elevation )
@@ -32,8 +33,52 @@ public GHPoint3D( double lat, double lon, double elevation )
         this.ele = elevation;
     }
 
+    public double getElevation()
+    {
+        return ele;
+    }
+
     public double getEle()
     {
         return ele;
     }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 59 * super.hashCode()
+                + (int) (Double.doubleToLongBits(this.ele) ^ (Double.doubleToLongBits(this.ele) >>> 32));
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+
+        @SuppressWarnings("unchecked")
+        final GHPoint3D other = (GHPoint3D) obj;
+        if (Double.isNaN(ele))
+            // very special case necessary in QueryGraph, asserted via test
+            return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
+        else
+            return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon)
+                    && NumHelper.equalsEps(ele, other.ele);
+    }
+
+    @Override
+    public String toString()
+    {
+        return super.toString() + "," + ele;
+    }
+
+    @Override
+    public Double[] toGeoJson()
+    {
+        return new Double[]
+        {
+            lon, lat, ele
+        };
+    }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index 3dfae328cf..3fed4a65b1 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -1,4 +1,6 @@
-sharp_left= 
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left= 
 sharp_right= 
 left=
 right=
@@ -10,17 +12,21 @@ turn= %1$s
 turn_onto= %1$s  %2$s
 web.searchButton=
 web.fromHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
-web.gpxExportButton=GPX export
-web.routeInfo=%1$s   %2$s
+web.gpxExportButton=GPX 
+web.routeInfo=%1$s   %2$s
 web.locationsNotFound=   .     .
 web.bike=
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike= 
+web.mtb= 
 web.car=
 web.foot=
-finish=
+web.staticlink= 
+web.motorcycle=
+via=
+finish= !
 hourAbbr=
 dayAbbr=
 minAbbr=
@@ -28,10 +34,16 @@ kmAbbr=
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=
+off_bike=       !
+cycleway=
+way=
+paved=
+unpaved=
+stopover= %1$s
+roundaboutInstruction=      %1$s
+roundaboutInstructionWithDir=      %1$s   %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
new file mode 100644
index 0000000000..980f7a8ec0
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=just a l'esquerra
+sharp_right=just a la dreta
+left=a l'esquerra
+right=a la dreta
+slight_left=lleugerament a l'esquerra
+slight_right=lleugerament a la dreta
+continue=continua
+continue_onto=continua per %1$s
+turn=gira %1$s
+turn_onto=gira %1$s per %2$s
+web.searchButton=Buscar
+web.fromHint=Des de
+web.viaHint=passant per
+web.toHint=Cap a
+web.moreButton=ms
+web.gpxExportButton=Exportar GPX
+web.routeInfo=%1$s trigars %2$s
+web.locationsNotFound=No hi ha cap ruta. El dest no es troba dins l'rea.
+web.bike=Bicicleta
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montanya
+web.car=Cotxe
+web.foot=A peu
+web.staticlink=Enlla
+web.motorcycle=
+via=passant per
+finish=Has arribat !!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=pe
+road=carretera
+off_bike=Tros a peu
+cycleway=via ciclista
+way=cam
+paved=pavimentat
+unpaved=sense pavimentar
+stopover=passant per %1$s
+roundaboutInstruction=Entra a la rotonda y agafa la %1$ sortida
+roundaboutInstructionWithDir=Entra a la rotonda y agafa la %1$s sortida direcci %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index 55ad00c1b6..f7db1f2b5b 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=scharf links
 sharp_right=scharf rechts
 left=links
@@ -10,9 +12,10 @@ turn=%1$s abbiegen
 turn_onto=%1$s abbiegen auf %2$s
 web.searchButton=Suche
 web.fromHint=Von
+web.viaHint=ber
 web.toHint=Nach
 web.moreButton=mehr
-web.gpxExportButton=GPX Export
+web.gpxExportButton=GPX export
 web.routeInfo=%1$s werden %2$s brauchen
 web.locationsNotFound=Routing war nicht mglich. Ort(e) nicht gefunden in diesem Gebiet.
 web.bike=Fahrrad
@@ -20,6 +23,9 @@ web.racingbike=Rennrad
 web.mtb=Mountainbike
 web.car=Auto
 web.foot=Zu Fu
+web.staticlink=Link
+web.motorcycle=Motorrad
+via=ber
 finish=Ziel erreicht!
 hourAbbr=h
 dayAbbr=d
@@ -28,10 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=Strasse
-pushing_section=Schiebestrecke
+road=Strae
+off_bike=Schiebestrecke
 cycleway=Radweg
 way=Weg
 paved=befestigt
 unpaved=unbefestigt
-stopover=Zwischenziel %1$s
\ No newline at end of file
+stopover=Zwischenziel %1$s
+roundaboutInstruction=In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen
+roundaboutInstructionWithDir=In den Kreisverkehr einfahren und Ausfahrt %1$s in Richtung %2$s nehmen
+roundaboutInstructionOnto=In den Kreisverkehr einfahren und Ausfahrt %1$s auf %2$s nehmen
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
new file mode 100644
index 0000000000..cb6890ef00
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left= 
+sharp_right= 
+left=
+right=
+slight_left= 
+slight_right= 
+continue=
+continue_onto=  %1$s
+turn= %1$s
+turn_onto= %1$s  %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX 
+web.routeInfo=%1$s  %2$s
+web.locationsNotFound=    .      .
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle=
+via=
+finish=!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=
+off_bike=   
+cycleway=
+way=
+paved=
+unpaved=
+stopover=  %1$s
+roundaboutInstruction=        %1$s
+roundaboutInstructionWithDir=        %1$s   %2$s
+roundaboutInstructionOnto=        %1$s  %2$s
+roundaboutEnter=   
+roundaboutExit=      %1$s
+roundaboutExitOnto=      %1$s  %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 82fa88d8e2..abfebb9177 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=sharp left
 sharp_right=sharp right
 left=left
@@ -10,6 +12,7 @@ turn=turn %1$s
 turn_onto=turn %1$s onto %2$s
 web.searchButton=Search
 web.fromHint=From
+web.viaHint=Via
 web.toHint=To
 web.moreButton=more
 web.gpxExportButton=GPX export
@@ -20,6 +23,9 @@ web.racingbike=Racingbike
 web.mtb=Mountainbike
 web.car=Car
 web.foot=Foot
+web.staticlink=static link
+web.motorcycle=Motorcycle
+via=via
 finish=Finish!
 hourAbbr=h
 dayAbbr=d
@@ -29,9 +35,15 @@ mAbbr=m
 miAbbr=mi
 ftAbbr=ft
 road=road
-pushing_section=pushing section
+off_bike=get off the bike
 cycleway=cycleway
 way=way
 paved=paved
 unpaved=unpaved
 stopover=stopover %1$s
+roundaboutInstruction=Enter roundabout and take exit %1$s
+roundaboutInstructionWithDir=Enter roundabout and take exit %1$s in direction %2$s
+roundaboutInstructionOnto=Enter roundabout and take exit %1$s onto %2$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index 4b4a9f2ff8..9d9ec6ea7c 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=justo a la izquierda
 sharp_right=justo a la derecha
 left=izquierda
@@ -6,21 +8,25 @@ slight_left=gire a la izquierda
 slight_right=gire a la derecha
 continue=contine
 continue_onto=contine por %1$s
-turn=gire %1$s
-turn_onto=gire %1$s por %2$s
+turn=gire a la %1$s
+turn_onto=gire a la %1$s por %2$s
 web.searchButton=Buscar
 web.fromHint=Desde
+web.viaHint=Pasando por
 web.toHint=hasta
 web.moreButton=ms
-web.gpxExportButton=GPX export
+web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s tardar %2$s 
 web.locationsNotFound=No se ha encontrado la ruta. El destino no se encuentra en el rea.
 web.bike=Bicicleta
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montaa
 web.car=Coche
-web.foot=A pi
-finish=Objetivo logrado
+web.foot=A pie
+web.staticlink=enlace esttico
+web.motorcycle=Motocicleta
+via=pasando por
+finish=Objetivo logrado!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -28,10 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=carretera
+off_bike=bajarse de la bicicleta
+cycleway=va ciclista
+way=camino
+paved=pavimentado
+unpaved=no pavimentado
+stopover=pasando por %1$s
+roundaboutInstruction=Entre a la rotonda y tome la salida %1$s
+roundaboutInstructionWithDir=Entre a la rotonda y tome la salida %1$s en direccin a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
new file mode 100644
index 0000000000..3477681d9f
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=matalim kaliwa 
+sharp_right=matalim karapatan 
+left=kaliwa 
+right=karapatan 
+slight_left=bahagyang kaliwa
+slight_right=bahagyang kanan
+continue=tuwirn ang dan
+continue_onto=magpatuloy papunta sa %1$s
+turn=pagliko %1$s
+turn_onto=lumiko %1$s papunta sa %2$s
+web.searchButton=Paghahanap
+web.fromHint=mula sa 
+web.viaHint=
+web.toHint=upang sa
+web.moreButton=mas
+web.gpxExportButton=GPX Export
+web.routeInfo=%1$s ay magdadala sa %2$s
+web.locationsNotFound=Routing hindi maaari, hindi nahanap Lokasyon sa lugar.
+web.bike=Bike
+web.racingbike=RacingBike
+web.mtb=MountainBike
+web.car=kotse
+web.foot=lumakad
+web.staticlink=
+web.motorcycle=
+via=
+finish=Tapusin!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=kalsada 
+off_bike=seksyon pagtulak 
+cycleway=cycleway
+way=landas
+paved=aspaltado 
+unpaved=hindi aspaltado
+stopover=pamahingahan %1$s
+roundaboutInstruction=Lpasok rotonda at gamitin %1$s
+roundaboutInstructionWithDir=Epasok rotonda at gamitin %1$s direksyon %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index 485c00ef4e..f5169052b0 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=fort  gauche
 sharp_right=fort  droite
 left= gauche
@@ -10,16 +12,20 @@ turn=tournez %1$s
 turn_onto=tournez %1$s sur %2$s
 web.searchButton=Rechercher
 web.fromHint=De
+web.viaHint=via
 web.toHint=
 web.moreButton=plus
-web.gpxExportButton=GPX export
+web.gpxExportButton=Export GPX
 web.routeInfo=%1$s durera %2$s 
 web.locationsNotFound=Calcul d'itinraire impossible. Position(s) non trouve(s) dans la zone.
 web.bike=Vlo
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Vlo de route
+web.mtb=VTT
 web.car=Voiture
 web.foot= pied
+web.staticlink=Lien
+web.motorcycle=
+via=via
 finish=Fini!
 hourAbbr=h
 dayAbbr=j
@@ -28,10 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=route
+off_bike=Descendez du vlo
+cycleway=piste cyclable
+way=chemin
+paved=pav
+unpaved=non-pav
+stopover=escale %1$s
+roundaboutInstruction=empruntez le rond point et prenez la sortie %1$s
+roundaboutInstructionWithDir=empruntez le rond point et prenez la sortie %1$s, en direction de %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
new file mode 100644
index 0000000000..ff53f51f72
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=xusto  esquerda
+sharp_right=xusto  dereita
+left=esquerda
+right=dereita
+slight_left=vire  esquerda
+slight_right=vire  dereita
+continue=contine
+continue_onto=contine por %1$s
+turn=vire por %1$s
+turn_onto=vire %1$s por %2$s
+web.searchButton=buscar
+web.fromHint=dende
+web.viaHint=Va
+web.toHint=ata
+web.moreButton=mis
+web.gpxExportButton=GPX Exportacin
+web.routeInfo=%1$s tardar %2$s
+web.locationsNotFound=Non se atopou a ruta. O destino non se atopa na rea
+web.bike=Bicicleta
+web.racingbike=Bicleta de carreiras
+web.mtb=Bicicleta de montaa
+web.car=autombil
+web.foot=A p
+web.staticlink=Enlace
+web.motorcycle=
+via=va
+finish=Obxectivo acadado
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=mts
+miAbbr=mi
+ftAbbr=ft
+road=estrada
+off_bike=sector a p
+cycleway=va ciclista
+way=va 
+paved=asfaltada
+unpaved=non pavimentada
+stopover=escala%1$s
+roundaboutInstruction= Entre na rotonda e tome a sada %1$s
+roundaboutInstructionWithDir=Entre na rotonda e tome a sada %1$s en direccin%2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
new file mode 100644
index 0000000000..672fbf6945
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left= 
+sharp_right= 
+left=
+right=
+slight_left= 
+slight_right= 
+continue=
+continue_onto=  %1$s
+turn=  %1$s
+turn_onto=  %1$s  %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton= GPX
+web.routeInfo=%1$s  %2$s
+web.locationsNotFound=    .    .
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle=
+via=
+finish=!
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike= 
+cycleway= 
+way=
+paved=
+unpaved= 
+stopover=   %1$s
+roundaboutInstruction=      %1$s
+roundaboutInstructionWithDir=      %1$s  %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
new file mode 100644
index 0000000000..1ca1c1259d
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=nettamente a sinistra
+sharp_right=nettamente a destra
+left=a sinistra
+right=a destra
+slight_left=leggermente a sinistra
+slight_right=leggermente a destra
+continue=continua
+continue_onto=continua su %1$s
+turn=gira %1$s
+turn_onto=gira %1$s su %2$s
+web.searchButton=Ricerca
+web.fromHint=Da
+web.viaHint=attraverso
+web.toHint=A
+web.moreButton=altro
+web.gpxExportButton=Esporta GPX
+web.routeInfo=%1$s in %2$s
+web.locationsNotFound=Percorso non calcolabile. Localit non trovata(e) nell'area.
+web.bike=Bicicletta
+web.racingbike=Bici da corsa
+web.mtb=Mountainbike
+web.car=Auto
+web.foot=A piedi
+web.staticlink=permalink
+web.motorcycle=
+via=attraverso
+finish=Arrivo!
+hourAbbr=hh
+dayAbbr=gg
+minAbbr=mm
+kmAbbr=km
+mAbbr=mt
+miAbbr=mi
+ftAbbr=ft
+road=strada
+off_bike=sezione a piedi
+cycleway=pista ciclabile
+way=via
+paved=pavimentata
+unpaved=non pavimentata
+stopover=sosta %1$s
+roundaboutInstruction=Prendere l'uscita %1$s
+roundaboutInstructionWithDir=Prendere l'uscita %1$s in direzione %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 334b1ba456..41c1bdf6b1 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=
 sharp_right=
 left=
@@ -10,16 +12,20 @@ turn=%1$s
 turn_onto=%1$s%2$s
 web.searchButton=
 web.fromHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
-web.gpxExportButton=GPX export
+web.gpxExportButton=GPX
 web.routeInfo=%1$s  %2$s
 web.locationsNotFound=
 web.bike=
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=
+web.mtb=
 web.car=
 web.foot=
+web.staticlink=
+web.motorcycle=
+via=
 finish=
 hourAbbr=
 dayAbbr=
@@ -28,10 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=
+off_bike=
+cycleway=
+way=
+paved=
+unpaved=
+stopover=%1$s
+roundaboutInstruction=%1$s
+roundaboutInstructionWithDir=%1$s%2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
new file mode 100644
index 0000000000..b89fc49ae1
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=draai naar links
+sharp_right=draai naar rechts
+left=links
+right=rechts
+slight_left=houd links aan
+slight_right=houd rechts aan
+continue=neem 
+continue_onto=blijf op %1$s
+turn=%1$s afbuigen
+turn_onto=sla %1$s af naar %2$s
+web.searchButton=zoek
+web.fromHint=van
+web.viaHint=via
+web.toHint=naar
+web.moreButton=meer
+web.gpxExportButton=GPX export
+web.routeInfo=%1$s duurt %2$s
+web.locationsNotFound=Route niet mogelijk. Locatie(s) niet gevonden.
+web.bike=fiets
+web.racingbike=racefiets
+web.mtb=mountainbike
+web.car=auto
+web.foot=te voet
+web.staticlink=statische link
+web.motorcycle=motorfiets
+via=via
+finish=Bestemming bereikt
+hourAbbr=u
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=weg
+off_bike=voetpad
+cycleway=fietspad
+way=weg
+paved=verhard
+unpaved=onverhard
+stopover=tussenbestemming %1$s
+roundaboutInstruction=ga de rotonde op en neem afrit %1$s
+roundaboutInstructionWithDir=ga de rotonde op en neem afrit %1$s richting %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index 2af1a46611..1565698d45 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -1,25 +1,31 @@
-sharp_left=Curva acentuada  esquerda
-sharp_right=Curva acentuada  direita
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=curva acentuada  esquerda
+sharp_right=curva acentuada  direita
 left=esquerda
 right=direita
-slight_left=esquerda
-slight_right=direita
+slight_left=curva suave  esquerda
+slight_right=curva suave  direita
 continue=continuar
-continue_onto=continue para %1$s
-turn=vire %1$s
-turn_onto=vire  %1$s para %2$s
+continue_onto=continue na %1$s
+turn=vire  %1$s
+turn_onto=vire  %1$s em %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
+web.viaHint=Via
 web.toHint=Para
 web.moreButton=mais
-web.gpxExportButton=exportar GPX
+web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s ir levar %2$s
 web.locationsNotFound=Roteamento impossvel. Localizao(es) no encontrada(s) na rea.
 web.bike=Bicicleta
-web.racingbike=BicicletadeCorrida
+web.racingbike=Bicicleta de corrida
 web.mtb=Mountainbike
 web.car=Carro
 web.foot=A p
+web.staticlink=Link esttico
+web.motorcycle=Motocicleta
+via=via
 finish=Destino alcanado
 hourAbbr=h
 dayAbbr=d
@@ -27,11 +33,17 @@ minAbbr=min
 kmAbbr=km
 mAbbr=m
 miAbbr=mi
-ftAbbr=ft
+ftAbbr=ps
 road=estrada
-pushing_section=pushing section
+off_bike=descer da bicicleta
 cycleway=ciclovia
 way=caminho
-paved=asfaltado
-unpaved=no asfaltado
-stopover=stopover %1$s
\ No newline at end of file
+paved=pavimentada
+unpaved=no pavimentada
+stopover=parada %1$s
+roundaboutInstruction=Entre na rotatria e saia na sada nmero %1$s
+roundaboutInstructionWithDir=Entre na rotatria e saia na sada nmero %1$s em direo a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index 8da488ae40..a6e6f3a0fe 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -1,26 +1,32 @@
-sharp_left=esquerda apertada
-sharp_right=direita apertada
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=curva apertada  esquerda
+sharp_right=curva apertada  direita
 left=esquerda
 right=direita
-slight_left=esquerda ligeira
-slight_right=direita ligeira
+slight_left=curva ligeira  esquerda
+slight_right=curva ligeira  direita
 continue=continuar
-continue_onto=continue para %1$s
-turn=vire %1$s
+continue_onto=continue na %1$s
+turn=vire  %1$s
 turn_onto=vire  %1$s para %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
+web.viaHint=Por
 web.toHint=Para
 web.moreButton=mais
-web.gpxExportButton=GPX export
-web.routeInfo=%1$s ir levar %2$s
+web.gpxExportButton=Exportar GPX
+web.routeInfo=%1$s ir demorar %2$s
 web.locationsNotFound=Roteamento impossvel. Localizao(es) no encontrada(s) na rea.
 web.bike=Bicicleta
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Bicicleta de corrida
+web.mtb=Bicicleta de montanha
 web.car=Carro
 web.foot=A p
-finish=meta alcanada
+web.staticlink=Ligao permanente
+web.motorcycle=Motocicleta
+via=por
+finish=Chegou ao seu destino!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -28,10 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=estrada
+off_bike=saia da bicicleta
+cycleway=ciclovia
+way=caminho
+paved=pavimentado
+unpaved=no pavimentada
+stopover=paragem %1$s
+roundaboutInstruction=Entre na rotunda e saia na sada nmero %1$s
+roundaboutInstructionWithDir=Entre na rotunda e saia na sada nmero %1$s em direo a %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index c8d6d9a6fa..95f52e55ab 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -1,37 +1,49 @@
-sharp_left=stnga
-sharp_right=dreapta
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=brusc la stnga
+sharp_right=brusc la dreapta
 left=stnga
 right=dreapta
-slight_left=stnga
-slight_right=dreapta
+slight_left=uor la stnga
+slight_right=uor la dreapta
 continue=continu
 continue_onto=continu pe %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn=schimbai direcia la %1$s
+turn_onto=schimbai direcia la %1$s pe %2$s
 web.searchButton=Caut
-web.fromHint=de la
-web.toHint=la
+web.fromHint=De la
+web.viaHint=Prin
+web.toHint=La
 web.moreButton=mai mult
-web.gpxExportButton=GPX export
+web.gpxExportButton=Export GPX
 web.routeInfo=%1$s dureaz %2$s
 web.locationsNotFound=Traseul nu este posibil. Locul(locurile) nu pot fi gsite n zon.
 web.bike=biciclet
-web.racingbike=Racingbike
+web.racingbike=biciclet de curse
 web.mtb=Mountainbike
 web.car=main
 web.foot=pe jos
+web.staticlink=link
+web.motorcycle=Motociclet
+via=prin
 finish=obiectiv atins
 hourAbbr=h
-dayAbbr=d
+dayAbbr=z
 minAbbr=min
 kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
-stopover=stopover %1$s
\ No newline at end of file
+road=strad
+off_bike=zon pentru mpins
+cycleway=pist pentru biciclete
+way=cale
+paved=pavat
+unpaved=nepavat
+stopover=escala %1$s
+roundaboutInstruction= Intrai n giratoriu i folosii ieirea %1$s
+roundaboutInstructionWithDir= Intrai n giratoriu i folosii ieirea %1$s n direcia %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index 1c757fe0fe..3076988c9e 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left= 
 sharp_right= 
 left=
@@ -10,22 +12,38 @@ turn= %1$s
 turn_onto= %1$s  %2$s
 web.searchButton=
 web.fromHint=
+web.viaHint=
 web.toHint=
 web.moreButton=
-web.gpxExportButton=GPX export
+web.gpxExportButton= GPX
 web.routeInfo=%1$s  %2$s
-web.locationsNotFound=  .   
+web.locationsNotFound=  .   .
 web.bike=
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike= 
+web.mtb= 
 web.car=
 web.foot=
-finish= 
-hourAbbr=h
-dayAbbr=d
-minAbbr=min
-kmAbbr=km
-mAbbr=m
-miAbbr=mi
-ftAbbr=ft
-stopover=stopover %1$s
\ No newline at end of file
+web.staticlink=
+web.motorcycle=
+via=
+finish= !
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=  
+cycleway=
+way=
+paved= 
+unpaved= 
+stopover= %1$s
+roundaboutInstruction=      %1$s
+roundaboutInstructionWithDir=      %1$s   %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index 09a2d8d13e..8954a0701b 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=ostro levo
 sharp_right=ostro desno
 left=levo
@@ -10,16 +12,20 @@ turn=zavite %1$s
 turn_onto=zavite %1$s na %2$s
 web.searchButton=Ii
 web.fromHint=Od 
+web.viaHint=
 web.toHint=Do
 web.moreButton=ve
-web.gpxExportButton=GPX export
+web.gpxExportButton=izvozi GPX
 web.routeInfo=%1$s bo trajalo %2$s
 web.locationsNotFound=Usmerjanje ni mogoe. Lokacije ne pokae na tem obmoju.
 web.bike=Kolo
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=cestno kolo
+web.mtb=gorsko kolo
 web.car=Avto
 web.foot=Pe
+web.staticlink=
+web.motorcycle=
+via=
 finish=Konec!
 hourAbbr=h
 dayAbbr=d
@@ -28,4 +34,16 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-stopover=stopover %1$s
\ No newline at end of file
+road=cesta
+off_bike=pe odsek
+cycleway=kolesarska steza
+way=smer
+paved=tlakovana
+unpaved=netlakovana
+stopover=postanek %1$s
+roundaboutInstruction=zapelji v kroie in izberi izhod %1$
+roundaboutInstructionWithDir=zapelji v kroie in izberi izhod %1$ v smeri %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
new file mode 100644
index 0000000000..96d95aa0dd
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=ostro doava
+sharp_right=ostro doprava
+left=doava
+right=doprava
+slight_left=mierne doava
+slight_right=mierne doprava
+continue=pokraujte
+continue_onto=pokraujte na %1$s
+turn=odbote %1$s
+turn_onto=odbote %1$s na %2$s
+web.searchButton=Vyhada
+web.fromHint=Z
+web.viaHint=Cez
+web.toHint=Do
+web.moreButton=viac
+web.gpxExportButton=Export do GPX
+web.routeInfo=%1$s bude trva %2$s
+web.locationsNotFound=Navigovanie nie je mon. Umiestnenie nebolo njden v oblasti.
+web.bike=Bicykel
+web.racingbike=Zvodn bicykel
+web.mtb=Horsk bicykel
+web.car=Automobil
+web.foot=Peo
+web.staticlink=nemenn odkaz
+web.motorcycle=Motocykel
+via=cez
+finish=Cie!
+hourAbbr=Horsk bicykel
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=cesta
+off_bike=zosadnite z bicykla
+cycleway=cyklotrasa
+way=smer
+paved=spevnen
+unpaved=nespevnen
+stopover=zastvka %1$s
+roundaboutInstruction=Vojdite na kruhov objazd a opustite ho cez %1$s. vjazd
+roundaboutInstructionWithDir=Vojdite na kruhov objazd a opustite ho cez %1$s. vjazd v smere %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
new file mode 100644
index 0000000000..8d2f51b219
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=kraftigt vnster
+sharp_right=kraftigt hger
+left=vnster
+right=hger
+slight_left=svagt vnster
+slight_right=svagt hger
+continue=fortstt
+continue_onto=fortstt in p %1$s
+turn=svng %1$s
+turn_onto=svng %1$s in p %2$s
+web.searchButton=Sk
+web.fromHint=Frn
+web.viaHint=Via
+web.toHint=Till
+web.moreButton=fler
+web.gpxExportButton=exportera GPX-fil
+web.routeInfo=%1$s med krtid %2$s
+web.locationsNotFound=Kan inte berkna rutt. Platsen eller platserna kan inte hittas i omrdet.
+web.bike=Cykel
+web.racingbike=Tvlingscykel
+web.mtb=Mountain bike
+web.car=Bil
+web.foot=Gng
+web.staticlink=Direktlnk
+web.motorcycle=
+via=via
+finish=Framme!
+hourAbbr= tim
+dayAbbr= d
+minAbbr= min
+kmAbbr= km
+mAbbr= m
+miAbbr= mi
+ftAbbr= ft
+road=gata
+off_bike=hoppa av cykeln
+cycleway=cykelvg
+way=vg
+paved=belagd
+unpaved=obelagd
+stopover=delml %1$s
+roundaboutInstruction=Kr in i rondellen och ta avfart %1$s
+roundaboutInstructionWithDir=Kr in i rondellen och ta avfart %1$s mot %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index 7b339cad12..e8299466e9 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -1,3 +1,5 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 sharp_left=sola keskin dn
 sharp_right=saa keskin dn
 left=sol 
@@ -10,22 +12,38 @@ turn=dn %1$s
 turn_onto=-e dn %1$s %2$s
 web.searchButton=ara
 web.fromHint=-den 
+web.viaHint=araciligi ile
 web.toHint=ynne
 web.moreButton=daha fazlas
-web.gpxExportButton=GPX export
+web.gpxExportButton=GPX ihracat
 web.routeInfo=%1$s alacak %2$s
 web.locationsNotFound=Rota planlanamad. Blgede yer bulunamad.
 web.bike=Bisiklet
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=yaris bisikleti
+web.mtb=dag bisikleti
 web.car=Otomobil
 web.foot=Yryerek
+web.staticlink=duragan baglanti
+web.motorcycle=
+via=araciligi ile
 finish=Bitti !
 hourAbbr=s
 dayAbbr=g
-minAbbr=d
+minAbbr=dak
 kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-stopover=stopover %1$s
\ No newline at end of file
+road=yol
+off_bike=bisikletten inmek
+cycleway=bisiklet yolu
+way=yol
+paved=kaldrm
+unpaved=kaldrmsz yol
+stopover=mola yeri %1$s
+roundaboutInstruction=dner kavsaa girin ve ck kullann %1$
+roundaboutInstructionWithDir=dner kavaa girin ve k kullann %1$ - %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
new file mode 100644
index 0000000000..917e9ad796
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left= 
+sharp_right= 
+left=
+right=
+slight_left= 
+slight_right= 
+continue=
+continue_onto=  %1$s
+turn= %1$s
+turn_onto= %1$s  %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=  GPX
+web.routeInfo=%1$s  %2$s
+web.locationsNotFound=  .   .
+web.bike=
+web.racingbike= 
+web.mtb= 
+web.car=
+web.foot=
+web.staticlink= 
+web.motorcycle=
+via=
+finish=    !
+hourAbbr= 
+dayAbbr= 
+minAbbr= 
+kmAbbr= 
+mAbbr= 
+miAbbr= 
+ftAbbr= 
+road=
+off_bike=,   
+cycleway= 
+way=
+paved= 
+unpaved= 
+stopover= %1$s
+roundaboutInstruction=      %1$s
+roundaboutInstructionWithDir=      %1$s   %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
new file mode 100644
index 0000000000..2a048e62da
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=r tri ngay
+sharp_right=r phi ngay
+left=r tri
+right=r phi
+slight_left=r nh tri
+slight_right=r nh phi
+continue=tip tc
+continue_onto=tip tc theo %1$s
+turn=r %1$s
+turn_onto=r %1$s theo %1$s
+web.searchButton=Tm
+web.fromHint=T
+web.viaHint=Qua
+web.toHint=n
+web.moreButton=thm
+web.gpxExportButton=Xut GPX
+web.routeInfo=%1$s mt %2$s
+web.locationsNotFound=Khng tm thy l trnh! Cc im  chn khng tm thy trong vng ny
+web.bike=Xe p
+web.racingbike=Xe ua
+web.mtb=Xe leo ni
+web.car= t
+web.foot=i b
+web.staticlink=lin kt tnh
+web.motorcycle=M t
+via=qua
+finish=Kt thc!
+hourAbbr=g
+dayAbbr=n
+minAbbr=p
+kmAbbr=km
+mAbbr=m
+miAbbr=dm
+ftAbbr=ft
+road=ng
+off_bike=b xe p
+cycleway=ng xe p
+way=ng
+paved=ng lt
+unpaved=ng khng lt
+stopover=im ngh %1$s
+roundaboutInstruction=Vo vng xoay v tm li ra %1$s
+roundaboutInstructionWithDir=Vo vng xoay v tm li ra %1$s theo hng %2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..850f571717
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,49 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+sharp_left=
+sharp_right=
+left=
+right=
+slight_left=
+slight_right=
+continue=
+continue_onto= %1$s
+turn= %1$s
+turn_onto=  %1$s   %2$s
+web.searchButton=
+web.fromHint=
+web.viaHint=
+web.toHint=
+web.moreButton=
+web.gpxExportButton=GPX
+web.routeInfo=%1$s  %2$s 
+web.locationsNotFound=
+web.bike=
+web.racingbike=
+web.mtb=
+web.car=
+web.foot=
+web.staticlink=
+web.motorcycle=
+via=
+finish=
+hourAbbr=
+dayAbbr=
+minAbbr=
+kmAbbr=
+mAbbr=
+miAbbr=
+ftAbbr=
+road=
+off_bike=
+cycleway=
+way=
+paved=
+unpaved=
+stopover= %1$s
+roundaboutInstruction=%1$s
+roundaboutInstructionWithDir=%1$s%2$s
+roundaboutInstructionOnto=
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/log4j.properties b/core/src/main/resources/log4j.properties
deleted file mode 100644
index fedf9e0962..0000000000
--- a/core/src/main/resources/log4j.properties
+++ /dev/null
@@ -1,11 +0,0 @@
-# overwrite this file from command line via:
-# -Dlog4j.configuration=file
-# print internal debug => -Dlog4j.debug
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %C{3} - %m%n
-
-log4j.rootLogger=WARN
-
-log4j.logger.com.graphhopper=INFO, StdoutApp
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
index bc3399867a..e679159dc2 100644
--- a/core/src/test/java/com/graphhopper/GHRequestTest.java
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -31,14 +31,9 @@
     public void testGetHint()
     {
         GHRequest instance = new GHRequest(10, 12, 12, 10);
-        instance.putHint("something", 1);
-        assertEquals(1, (Number) instance.getHint("something", 2));
+        instance.getHints().put("something", "1");
+        assertEquals(1, instance.getHints().getInt("something", 2));
         // #173 - will throw an error: Integer cannot be cast to Double
-        assertEquals(1, instance.getHint("something", 2d), 1e1);
-        
-        instance = new GHRequest(10, 12, 12, 10);
-        instance.putHint("something", 1d);
-        assertEquals(1d, (Number) instance.getHint("something", 2));
-        assertEquals(1d, (Number) instance.getHint("something", 2d));
+        assertEquals(1, instance.getHints().getDouble("something", 2d), 1e1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 0ce5c739a0..fd7d4a3721 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -50,18 +50,50 @@ public void testLoad()
         graph.edge(4, 3, 40, true);
 
         GraphHopper instance = new GraphHopper().
-                setInMemory(false).
+                setStoreOnFlush(false).
                 setEncodingManager(encodingManager).
-                disableCHShortcuts().
+                setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10.4, 42, 10));
-        assertTrue(ph.isFound());
-        assertEquals(80, ph.getDistance(), 1e-6);
-        assertEquals(42, ph.getPoints().getLatitude(0), 1e-5);
-        assertEquals(10.4, ph.getPoints().getLongitude(0), 1e-5);
-        assertEquals(41.9, ph.getPoints().getLatitude(1), 1e-5);
-        assertEquals(10.2, ph.getPoints().getLongitude(1), 1e-5);
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(42, 10.4, 42, 10));
+        assertFalse(rsp.hasErrors());
+        assertEquals(80, rsp.getDistance(), 1e-6);
+        assertEquals(42, rsp.getPoints().getLatitude(0), 1e-5);
+        assertEquals(10.4, rsp.getPoints().getLongitude(0), 1e-5);
+        assertEquals(41.9, rsp.getPoints().getLatitude(1), 1e-5);
+        assertEquals(10.2, rsp.getPoints().getLongitude(1), 1e-5);
+        assertEquals(3, rsp.getPoints().getSize());
+        instance.close();
+    }
+
+    @Test
+    public void testDisconnected179()
+    {
+        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 42, 10);
+        na.setNode(1, 42.1, 10.1);
+        na.setNode(2, 42.1, 10.2);
+        na.setNode(3, 42, 10.4);
+
+        graph.edge(0, 1, 10, true);
+        graph.edge(2, 3, 10, true);
+
+        GraphHopper instance = new GraphHopper().
+                setStoreOnFlush(false).
+                setEncodingManager(encodingManager).
+                setCHEnable(false).
+                loadGraph(graph);
+        GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
+        assertTrue(rsp.hasErrors());
+
+        try
+        {
+            rsp.getPoints();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
         instance.close();
     }
 
@@ -69,9 +101,9 @@ public void testLoad()
     public void testNoLoad()
     {
         GraphHopper instance = new GraphHopper().
-                setInMemory(false).
+                setStoreOnFlush(false).
                 setEncodingManager(encodingManager).
-                disableCHShortcuts();
+                setCHEnable(false);
         try
         {
             instance.route(new GHRequest(42, 10.4, 42, 10));
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 652968b48d..d3ee1547cc 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -17,14 +17,20 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
-import com.graphhopper.util.shapes.GHPlace;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import org.junit.After;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -50,106 +56,255 @@ public void setUp()
     @After
     public void tearDown()
     {
-        instance.close();
+        if (instance != null)
+            instance.close();
         Helper.removeDir(new File(ghLoc));
     }
 
     @Test
     public void testLoadOSM()
     {
-        instance = new GraphHopper().setInMemory(true).
+        GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("CAR")).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
-        instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        closableInstance.importOrLoad();
+        GHResponse rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
-        instance.close();
-        instance = new GraphHopper().setInMemory(true);
-        assertTrue(instance.load(ghLoc));
-        ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        closableInstance.close();
+        closableInstance = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR"));
+        assertTrue(closableInstance.load(ghLoc));
+        rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        closableInstance.close();
+        try
+        {
+            rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("You need to create a new GraphHopper instance as it is already closed", ex.getMessage());
+        }
+
+        try
+        {
+            QueryResult qr = closableInstance.getLocationIndex().findClosest(51.2492152, 9.4317166, EdgeFilter.ALL_EDGES);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("You need to create a new LocationIndex instance as it is already closed", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void testLoadOSMNoCH()
+    {
+        GraphHopper gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        gh.importOrLoad();
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        gh.close();
+        gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR"));
+        assertTrue(gh.load(ghLoc));
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        gh.close();
+    }
+
+    @Test
+    public void testAllowMultipleReadingInstances()
+    {
+        GraphHopper instance1 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        instance1.importOrLoad();
+
+        GraphHopper instance2 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        instance2.load(ghLoc);
+
+        GraphHopper instance3 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        instance3.load(ghLoc);
+
+        instance1.close();
+        instance2.close();
+        instance3.close();
+    }
+
+    @Test
+    public void testDoNotAllowWritingAndLoadingAtTheSameTime() throws Exception
+    {
+        final CountDownLatch latch1 = new CountDownLatch(1);
+        final CountDownLatch latch2 = new CountDownLatch(1);
+        final GraphHopper instance1 = new GraphHopper()
+        {
+            @Override
+            protected DataReader importData() throws IOException
+            {
+                try
+                {
+                    latch2.countDown();
+                    latch1.await(3, TimeUnit.SECONDS);
+                } catch (InterruptedException ex)
+                {
+                }
+                return super.importData();
+            }
+        }.setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        final AtomicReference<Exception> ar = new AtomicReference<Exception>();
+        Thread thread = new Thread()
+        {
+            @Override
+            public void run()
+            {
+                try
+                {
+                    instance1.importOrLoad();
+                } catch (Exception ex)
+                {
+                    ar.set(ex);
+                }
+            }
+        };
+        thread.start();
+
+        GraphHopper instance2 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        try
+        {
+            // let thread reach the CountDownLatch
+            latch2.await(3, TimeUnit.SECONDS);
+            // now importOrLoad should have create a lock which this load call does not like
+            instance2.load(ghLoc);
+            assertTrue(false);
+        } catch (RuntimeException ex)
+        {
+            assertNotNull(ex);
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("To avoid reading partial data"));
+        } finally
+        {
+            instance2.close();
+            latch1.countDown();
+            // make sure the import process wasn't interrupted and no other error happened
+            thread.join();
+        }
+
+        if (ar.get() != null)
+            assertNull(ar.get().getMessage(), ar.get());
+        instance1.close();
     }
 
     @Test
     public void testPrepare()
     {
         instance = new GraphHopper().
-                setInMemory(false).
+                setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("CAR")).
-                setCHShortcuts("shortest").
+                setCHWeighting("shortest").
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", ph.getPoints().toString());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", rsp.getPoints().toString());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
     public void testSortedGraph_noCH()
     {
-        instance = new GraphHopper().setInMemory(false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setSortGraph(true).
                 setEncodingManager(new EncodingManager("CAR")).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), ph.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), ph.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), ph.getPoints().toGHPoint(2));
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+
+        GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
+        boolean old = instance.enableInstructions;
+        req.getHints().put("instructions", true);
+        instance.route(req);
+        assertEquals(old, instance.enableInstructions);
+
+        req.getHints().put("instructions", false);
+        instance.route(req);
+        assertEquals("route method should not change instance field", old, instance.enableInstructions);
     }
 
     @Test
     public void testFootAndCar()
     {
         // now all ways are imported
-        instance = new GraphHopper().setInMemory(false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("CAR,FOOT")).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
         assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(8, instance.getGraph().getAllEdges().getCount());
 
         // A to D
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
-        assertFalse(res.hasErrors());
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
         // => found A and D
-        assertEquals(50, res.getPoints().getLongitude(0), 1e-3);
-        assertEquals(11.1, res.getPoints().getLatitude(0), 1e-3);
-        assertEquals(51, res.getPoints().getLongitude(2), 1e-3);
-        assertEquals(11.3, res.getPoints().getLatitude(2), 1e-3);
+        assertEquals(50, rsp.getPoints().getLongitude(0), 1e-3);
+        assertEquals(11.1, rsp.getPoints().getLatitude(0), 1e-3);
+        assertEquals(51, rsp.getPoints().getLongitude(2), 1e-3);
+        assertEquals(11.3, rsp.getPoints().getLatitude(2), 1e-3);
 
         // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT        
-        res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().getSize());
         // => found a point on edge A-B        
-        assertEquals(11.680, res.getPoints().getLatitude(1), 1e-3);
-        assertEquals(50.644, res.getPoints().getLongitude(1), 1e-3);
+        assertEquals(11.680, rsp.getPoints().getLatitude(1), 1e-3);
+        assertEquals(50.644, rsp.getPoints().getLongitude(1), 1e-3);
 
         // A to E only for foot
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().size());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().size());
 
         // A D E for car
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
-        assertTrue(res.isFound());
-        assertEquals(4, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -157,10 +312,10 @@ public void testFailsForWrongConfig() throws IOException
     {
         instance = new GraphHopper().init(
                 new CmdArgs().
+                put("osmreader.osm", testOsm3).
                 put("osmreader.dataaccess", "RAM").
-                put("osmreader.acceptWay", "FOOT,CAR").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).
+                put("graph.flagEncoders", "FOOT,CAR").
+                put("prepare.chWeighting", "no")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
         assertEquals(5, instance.getGraph().getNodes());
@@ -168,10 +323,10 @@ public void testFailsForWrongConfig() throws IOException
 
         instance = new GraphHopper().init(
                 new CmdArgs().
+                put("osmreader.osm", testOsm3).
                 put("osmreader.dataaccess", "RAM").
-                put("osmreader.acceptWay", "FOOT").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).
+                put("graph.flagEncoders", "FOOT").
+                put("prepare.chWeighting", "no")).
                 setOSMFile(testOsm3);
         try
         {
@@ -184,20 +339,22 @@ public void testFailsForWrongConfig() throws IOException
         // different order should be ok
         instance = new GraphHopper().init(
                 new CmdArgs().
+                put("osmreader.osm", testOsm3).
                 put("osmreader.dataaccess", "RAM").
-                put("osmreader.acceptWay", "CAR,FOOT").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).
+                put("prepare.chWeighting", "no").
+                put("graph.flagEncoders", "CAR,FOOT")).
                 setOSMFile(testOsm3);
         assertTrue(instance.load(ghLoc));
         assertEquals(5, instance.getGraph().getNodes());
     }
 
     @Test
-    public void testNoNPE_ifOnlyLoad()
+    public void testNoNPE_ifLoadNotSuccessful()
     {
         // missing import of graph
-        instance = new GraphHopper().setInMemory(true);
+        instance = new GraphHopper().
+                setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR"));
         try
         {
             assertFalse(instance.load(ghLoc));
@@ -236,7 +393,8 @@ public void testFailsForMissingParameters() throws IOException
 
         // missing OSM file to import
         instance = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
                 setGraphHopperLocation(ghLoc);
         try
         {
@@ -250,7 +408,7 @@ public void testFailsForMissingParameters() throws IOException
 
         // missing encoding manager          
         instance = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         try
@@ -259,12 +417,13 @@ public void testFailsForMissingParameters() throws IOException
             assertTrue(false);
         } catch (IllegalStateException ex)
         {
-            assertEquals("Missing encoding manager", ex.getMessage());
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Cannot load properties to fetch EncodingManager"));
         }
 
-        // Import is possible even if no storeOnFlush but missing OSM file
+        // Import is possible even if no storeOnFlush is specified BUT here we miss the OSM file
         instance = new GraphHopper().
-                setInMemory(false).
+                setStoreOnFlush(false).
+                setEncodingManager(new EncodingManager("CAR")).
                 setGraphHopperLocation(ghLoc);
         try
         {
@@ -281,26 +440,26 @@ public void testFailsForMissingParameters() throws IOException
     public void testFootOnly()
     {
         // now only footable ways are imported => no A D C and B D E => the other both ways have pillar nodes!
-        instance = new GraphHopper().setInMemory(false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("FOOT")).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
         assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(2, instance.getGraph().getAllEdges().getCount());
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
+        assertFalse(res.hasErrors());
         assertEquals(3, res.getPoints().getSize());
     }
 
     @Test
     public void testPrepareOnly()
     {
-        instance = new GraphHopper().setInMemory(true).
-                setCHShortcuts("shortest").
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setCHWeighting("shortest").
                 setEncodingManager(new EncodingManager("FOOT")).
                 setDoPrepare(false).
                 setGraphHopperLocation(ghLoc).
@@ -308,9 +467,10 @@ public void testPrepareOnly()
         instance.importOrLoad();
         instance.close();
 
-        instance = new GraphHopper().setInMemory(true).
-                setCHShortcuts("shortest").
-                setGraphHopperLocation(ghLoc).setOSMFile(testOsm3);
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setCHWeighting("shortest").
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm3);
 
         // wrong encoding manager
         instance.setEncodingManager(new EncodingManager("CAR"));
@@ -324,8 +484,9 @@ public void testPrepareOnly()
         }
 
         // use the encoding manager from the graph
-        instance = new GraphHopper().setInMemory(true).
-                setCHShortcuts("shortest").
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("FOOT")).
+                setCHWeighting("shortest").
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.load(ghLoc);
@@ -334,28 +495,29 @@ public void testPrepareOnly()
     @Test
     public void testVia()
     {
-        instance = new GraphHopper().setInMemory(true).
-                setEncodingManager(new EncodingManager("CAR")).
-                setGraphHopperLocation(ghLoc).
-                setOSMFile(testOsm3);
+        instance = new GraphHopper().setStoreOnFlush(true).
+                init(new CmdArgs().
+                        put("osmreader.osm", testOsm3).
+                        put("prepare.minNetworkSize", "1").
+                        put("graph.acceptWay", "CAR")).
+                setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
         // A -> B -> C
-        GHPlace first = new GHPlace(11.1, 50);
-        GHPlace second = new GHPlace(12, 51);
-        GHPlace third = new GHPlace(11.2, 51.9);
-        GHResponse rsp12 = instance.route(new GHRequest().addPlace(first).addPlace(second));
-        assertTrue("should find 1->2", rsp12.isFound());
-        assertEquals(147931.5, rsp12.getDistance(), .1);
-        GHResponse rsp23 = instance.route(new GHRequest().addPlace(second).addPlace(third));
-        assertTrue("should find 2->3", rsp23.isFound());
+        GHPoint first = new GHPoint(11.1, 50);
+        GHPoint second = new GHPoint(12, 51);
+        GHPoint third = new GHPoint(11.2, 51.9);
+        GHResponse rsp12 = instance.route(new GHRequest().addPoint(first).addPoint(second));
+        assertFalse("should find 1->2", rsp12.hasErrors());
+        assertEquals(147930.5, rsp12.getDistance(), .1);
+        GHResponse rsp23 = instance.route(new GHRequest().addPoint(second).addPoint(third));
+        assertFalse("should find 2->3", rsp23.hasErrors());
         assertEquals(176608.9, rsp23.getDistance(), .1);
 
-        GHResponse rsp = instance.route(new GHRequest().
-                addPlace(first).addPlace(second).addPlace(third));
+        GHResponse rsp = instance.route(new GHRequest().addPoint(first).addPoint(second).addPoint(third));
 
         assertFalse(rsp.hasErrors());
-        assertTrue("should find 1->2->3", rsp.isFound());
+        assertFalse("should find 1->2->3", rsp.hasErrors());
         assertEquals(rsp12.getDistance() + rsp23.getDistance(), rsp.getDistance(), 1e-6);
         assertEquals(5, rsp.getPoints().getSize());
         assertEquals(5, rsp.getInstructions().size());
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 803d4d751d..4e9b580902 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.storage.Edge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
 import java.util.PriorityQueue;
 import java.util.Random;
@@ -123,7 +123,7 @@ public void testRekey()
     @Test
     public void testSize()
     {
-        PriorityQueue<Edge> juQueue = new PriorityQueue<Edge>(100);
+        PriorityQueue<EdgeEntry> juQueue = new PriorityQueue<EdgeEntry>(100);
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
 
         Random rand = new Random(1);
@@ -132,7 +132,7 @@ public void testSize()
         {
             int val = rand.nextInt();
             binHeap.insert(val, i);
-            juQueue.add(new Edge(EdgeIterator.NO_EDGE, i, val));
+            juQueue.add(new EdgeEntry(EdgeIterator.NO_EDGE, i, val));
         }
 
         assertEquals(juQueue.size(), binHeap.getSize());
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 971d0d6e8d..359acc5890 100644
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 import java.util.Random;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -37,7 +37,7 @@ public void testCompress() throws Exception
         arr.write(12, 3);
         arr.flush();
 
-        CoordTrig coord = arr.get(0);
+        GHPoint coord = arr.get(0);
         assertEquals(10, coord.lat, 1e-6);
         assertEquals(1, coord.lon, 1e-6);
 
@@ -64,7 +64,7 @@ public void testCompress2() throws Exception
         }
 
         arr.flush();
-        CoordTrig coord = arr.get(0);
+        GHPoint coord = arr.get(0);
         assertEquals(0, coord.lat, 1e-6);
         assertEquals(65.787100, coord.lon, 1e-6);
 
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index dfa388056e..cb8e34888f 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.geohash;
 
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import static org.junit.Assert.*;
 import org.junit.Test;
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index 5d1cbd0c65..ca681b6bcd 100644
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -18,9 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -148,11 +146,11 @@ public void testBijection()
     public void testBijection( int bits )
     {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
-        CoordTrig coord11 = new CoordTrig();
+        GHPoint coord11 = new GHPoint();
         long key = algo.encode(1, 1);
         algo.decode(key, coord11);
         long resKey = algo.encode(coord11.lat, coord11.lon);
-        CoordTrig coord2 = new CoordTrig();
+        GHPoint coord2 = new GHPoint();
         algo.decode(resKey, coord2);
         assertEquals(key, resKey);
 
@@ -197,7 +195,7 @@ public void testNoFurtherIterationIfBitsIs1()
     {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(4).setBounds(0, 5, 0, 5);
         // 1001
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         algo.decode(9, coord);
         assertEquals(3.125, coord.lat, 1e-4);
         assertEquals(1.875, coord.lon, 1e-4);
@@ -206,7 +204,7 @@ public void testNoFurtherIterationIfBitsIs1()
     @Test
     public void testOddBits()
     {
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         SpatialKeyAlgo algo = new SpatialKeyAlgo(8);
         long key = algo.encode(5, 30);
         assertEquals("11000001", BitUtil.BIG.toLastBitString(key, 8));
@@ -228,11 +226,26 @@ public void testDifferentInitialBounds()
         assertEquals(1, algo.encode(0, 0.5));
         assertEquals(5, algo.encode(0, 1));
 
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         algo.decode(5, coord);
         assertEquals(5, algo.encode(coord));
 
         algo.decode(1, coord);
         assertEquals(1, algo.encode(coord));
     }
+    
+    @Test
+    public void testEdgeCases() {
+        double minLon = -1, maxLon = 1.6;
+        double minLat = -1, maxLat = 0.5;
+        int parts = 4;
+        int bits = (int) (Math.log(parts * parts) / Math.log(2));
+        final KeyAlgo keyAlgo = new SpatialKeyAlgo(bits).setBounds(minLon, maxLon, minLat, maxLat);
+        // lat border 0.125
+        assertEquals(11, keyAlgo.encode(0.125, -0.2));
+        assertEquals(9, keyAlgo.encode(0.124, -0.2));
+        // lon border -0.35
+        assertEquals(11, keyAlgo.encode(0.2, -0.35));
+        assertEquals(10, keyAlgo.encode(0.2, -0.351));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 137a9f41b7..6fc02eeeea 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -38,20 +38,14 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.AbstractGraphStorageTester;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+import java.util.*;
 
 /**
  * Tests the OSMReader with the normal helper initialized.
@@ -69,7 +63,8 @@
     private final String fileTurnRestrictions = "test-restrictions.xml";
     private final String dir = "./target/tmp/test-db";
     private CarFlagEncoder carEncoder;
-    private FootFlagEncoder footEncoder;
+    private BikeFlagEncoder bikeEncoder;
+    private FlagEncoder footEncoder;
     private EdgeExplorer carOutExplorer;
     private EdgeExplorer carAllExplorer;
 
@@ -88,21 +83,37 @@ public void tearDown()
     GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
     {
         return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
-                is3D, turnRestrictionsImport ? new TurnCostStorage() : new ExtendedStorage.NoExtendedStorage());
+                is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
     }
 
     class GraphHopperTest extends GraphHopper
     {
         public GraphHopperTest( String osmFile )
         {
-            setInMemory(false);
+            this(osmFile, false);
+        }
+
+        public GraphHopperTest( String osmFile, boolean turnCosts )
+        {
+            setStoreOnFlush(false);
             setOSMFile(osmFile);
             setGraphHopperLocation(dir);
             setEncodingManager(new EncodingManager("CAR,FOOT"));
-            disableCHShortcuts();
+            setCHEnable(false);
+
+            if (turnCosts)
+            {
+                carEncoder = new CarFlagEncoder(5, 5, 3);
+                bikeEncoder = new BikeFlagEncoder(4, 2, 3);
+            } else
+            {
+                carEncoder = new CarFlagEncoder();
+                bikeEncoder = new BikeFlagEncoder();
+            }
 
-            carEncoder = (CarFlagEncoder) getEncodingManager().getEncoder("CAR");
-            footEncoder = (FootFlagEncoder) getEncodingManager().getEncoder("FOOT");
+            footEncoder = new FootFlagEncoder();
+
+            setEncodingManager(new EncodingManager(footEncoder, carEncoder, bikeEncoder));
         }
 
         @Override
@@ -114,7 +125,7 @@ protected DataReader createReader( GraphStorage tmpGraph )
         @Override
         protected DataReader importData() throws IOException
         {
-            GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), is3D(), isEnableTurnRestrictions());
+            GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(), getEncodingManager().needsTurnCostsSupport());
             setGraph(tmpGraph);
 
             DataReader osmReader = createReader(tmpGraph);
@@ -160,9 +171,9 @@ public void testMain()
         assertEquals("street 123, B 122", iter.getName());
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
-        CarFlagEncoder flags = carEncoder;
-        assertTrue(flags.isForward(iter.getFlags()));
-        assertTrue(flags.isBackward(iter.getFlags()));
+        FlagEncoder flags = carEncoder;
+        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         assertTrue(iter.next());
         assertEquals("route 666", iter.getName());
@@ -174,8 +185,8 @@ public void testMain()
         assertEquals(n10, iter.getAdjNode());
         assertEquals(88643, iter.getDistance(), 1);
 
-        assertTrue(flags.isForward(iter.getFlags()));
-        assertTrue(flags.isBackward(iter.getFlags()));
+        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(flags.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
         assertFalse(iter.next());
 
         // get third added location id=30
@@ -277,31 +288,31 @@ public void testOneWay()
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
 
-        CarFlagEncoder encoder = carEncoder;
+        FlagEncoder encoder = carEncoder;
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
-        assertTrue(encoder.isForward(iter.getFlags()));
-        assertFalse(encoder.isBackward(iter.getFlags()));
+        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         assertTrue(iter.next());
         assertEquals(n22, iter.getAdjNode());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         assertTrue(iter.next());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
-        assertTrue(encoder.isForward(iter.getFlags()));
-        assertFalse(encoder.isBackward(iter.getFlags()));
+        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         assertTrue(iter.next());
         assertEquals(n10, iter.getAdjNode());
-        assertFalse(encoder.isForward(iter.getFlags()));
-        assertTrue(encoder.isBackward(iter.getFlags()));
+        assertFalse(encoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
     }
 
     @Test
@@ -502,60 +513,68 @@ public void testRelation()
     @Test
     public void testTurnRestrictions()
     {
-        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions).setEnableTurnRestrictions(true).importOrLoad();
-        Graph graph = hopper.getGraph();
-        assertEquals(9, graph.getNodes());
-        assertTrue(((GraphHopperStorage) graph).getExtendedStorage() instanceof TurnCostStorage);
-
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
+                importOrLoad();
+        GraphStorage graph = hopper.getGraph();
+        assertEquals(15, graph.getNodes());
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
 
+        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
         int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
         int n3 = AbstractGraphStorageTester.getIdOf(graph, 52, 11);
         int n4 = AbstractGraphStorageTester.getIdOf(graph, 52, 12);
+        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
+        int n6 = AbstractGraphStorageTester.getIdOf(graph, 51, 11);
         int n8 = AbstractGraphStorageTester.getIdOf(graph, 54, 11);
 
-        int edge2_3 = getEdge(n2, n3);
-        int edge3_4 = getEdge(n3, n4);
-        int edge3_8 = getEdge(n3, n8);
+        int edge1_6 = GHUtility.getEdge(graph, n1, n6).getEdge();
+        int edge2_3 = GHUtility.getEdge(graph, n2, n3).getEdge();
+        int edge3_4 = GHUtility.getEdge(graph, n3, n4).getEdge();
+        int edge3_8 = GHUtility.getEdge(graph, n3, n8).getEdge();
 
-        int edge3_2 = getEdge(n3, n2);
-        int edge4_3 = getEdge(n4, n3);
-        int edge8_3 = getEdge(n8, n3);
+        int edge3_2 = GHUtility.getEdge(graph, n3, n2).getEdge();
+        int edge4_3 = GHUtility.getEdge(graph, n4, n3).getEdge();
+        int edge8_3 = GHUtility.getEdge(graph, n8, n3).getEdge();
 
         // (2-3)->(3-4) only_straight_on = (2-3)->(3-8) restricted
         // (4-3)->(3-8) no_right_turn = (4-3)->(3-8) restricted
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_8)));
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge4_3, edge3_8)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge4_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge8_3, edge3_2)));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
+
+        // u-turn restriction for (6-1)->(1-6) but not for (1-6)->(6-1)
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
+
+        int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
+        int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
+        int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
 
-        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
-        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
-        int n6 = AbstractGraphStorageTester.getIdOf(graph, 50, 11);
+        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
+        long costsFlags = tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6);
+        assertFalse(carEncoder.isTurnRestricted(costsFlags));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
 
-        int edge4_5 = getEdge(n4, n5);
-        int edge5_6 = getEdge(n5, n6);
-        int edge5_1 = getEdge(n5, n1);
+        // for bike
+        assertFalse(bikeEncoder.isTurnRestricted(costsFlags));
 
-        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n5, edge4_5, edge5_6)));
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n5, edge4_5, edge5_1)));
-    }
+        int n10 = AbstractGraphStorageTester.getIdOf(graph, 40, 10);
+        int n11 = AbstractGraphStorageTester.getIdOf(graph, 40, 11);
+        int n14 = AbstractGraphStorageTester.getIdOf(graph, 39, 11);
 
-    private int getEdge( int from, int to )
-    {
-        EdgeIterator iter = carOutExplorer.setBaseNode(from);
-        while (iter.next())
-        {
-            if (iter.getAdjNode() == to)
-            {
-                return iter.getEdge();
-            }
-        }
-        return EdgeIterator.NO_EDGE;
+        int edge10_11 = GHUtility.getEdge(graph, n10, n11).getEdge();
+        int edge11_14 = GHUtility.getEdge(graph, n11, n14).getEdge();
+
+        assertEquals(0, tcStorage.getTurnCostFlags(edge11_14, n11, edge10_11));
+
+        costsFlags = tcStorage.getTurnCostFlags(edge10_11, n11, edge11_14);
+        assertFalse(carEncoder.isTurnRestricted(costsFlags));
+        assertTrue(bikeEncoder.isTurnRestricted(costsFlags));
     }
 
     @Test
@@ -580,16 +599,6 @@ public long handleNodeTags( OSMNode node )
                     return -objectEncoder.setValue(0, 1);
                 return 0;
             }
-
-            @Override
-            public long applyNodeFlags( long wayFlags, long nodeFlags )
-            {
-                double speed = getSpeed(wayFlags);
-                if (objectEncoder.getValue(nodeFlags) != 0)
-                    speed -= 5;
-
-                return setSpeed(0, speed);
-            }
         };
         EncodingManager manager = new EncodingManager(encoder);
         GraphStorage graph = newGraph(dir, manager, false, false);
@@ -619,9 +628,6 @@ public long applyNodeFlags( long wayFlags, long nodeFlags )
             @Override
             Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
             {
-                // reduced speed due to node tags
-                increased.incrementAndGet();
-                assertEquals(100 - 5, encoder.getSpeed(wayFlags), 1e-1);
                 return Collections.emptyList();
             }
         };
@@ -644,7 +650,6 @@ public long applyNodeFlags( long wayFlags, long nodeFlags )
         assertEquals(1.0, p.lon, 1e-3);
         Double d = way.getTag("estimated_distance", null);
         assertEquals(11119.5, d, 1e-1);
-        assertEquals(1, increased.get());
     }
 
     @Test
@@ -664,7 +669,7 @@ protected double getElevation( OSMNode node )
                     }
                 });
             }
-        }.set3D(true).importOrLoad();
+        }.setElevation(true).importOrLoad();
 
         Graph graph = hopper.getGraph();
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
@@ -681,8 +686,7 @@ public void testReadEleFromDataProvider()
         // get N10E046.hgt.zip
         ElevationProvider provider = new SRTMProvider();
         provider.setCacheDir(new File("./files"));
-        hopper.set3D(true).
-                setElevationProvider(provider);
+        hopper.setElevationProvider(provider);
         hopper.importOrLoad();
 
         Graph graph = hopper.getGraph();
@@ -691,11 +695,100 @@ public void testReadEleFromDataProvider()
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49.5001);
 
         EdgeIteratorState edge = GHUtility.getEdge(graph, n50, n30);
-        assertEquals(Helper.createPointList3D(49.5001, 11.501, 441, 49.5002, 11.5015, 441, 49.5011, 11.502, 415.0),
+        assertEquals(Helper.createPointList3D(49.5001, 11.501, 426, 49.5002, 11.5015, 441, 49.5011, 11.502, 410.0),
                 edge.fetchWayGeometry(3));
 
         edge = GHUtility.getEdge(graph, n10, n50);
-        assertEquals(Helper.createPointList3D(49.501, 11.5001, 399.0, 49.5001, 11.501, 441.0),
+        assertEquals(Helper.createPointList3D(49.501, 11.5001, 383.0, 49.5001, 11.501, 426.0),
                 edge.fetchWayGeometry(3));
     }
+
+    /**
+     * Tests the combination of different turn cost flags by different encoders.
+     */
+    @Test
+    public void testTurnFlagCombination()
+    {
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
+
+        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
+        FootFlagEncoder foot = new FootFlagEncoder();
+        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
+        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
+
+        OSMReader reader = new OSMReader(new GraphBuilder(manager).create())
+        {
+            @Override
+            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
+                    OSMTurnRelation turnRelation )
+            {
+                // simulate by returning one turn cost entry directly
+                if (encoder.toString().equalsIgnoreCase("car"))
+                {
+
+                    return Collections.singleton(turnCostEntry_car);
+                } else if (encoder.toString().equalsIgnoreCase("foot"))
+                {
+                    return Collections.singleton(turnCostEntry_foot);
+                } else if (encoder.toString().equalsIgnoreCase("bike"))
+                {
+                    return Collections.singleton(turnCostEntry_bike);
+                } else
+                {
+                    throw new IllegalArgumentException("illegal encoder " + encoder.toString());
+                }
+            }
+        }.setEncodingManager(manager);
+
+        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), 
+        // turn cost entry for bike is for another relation (different viaNode) 
+        turnCostEntry_car.edgeFrom = 1;
+        turnCostEntry_foot.edgeFrom = 1;
+        turnCostEntry_bike.edgeFrom = 2;
+
+        // calculating arbitrary flags using the encoders
+        turnCostEntry_car.flags = car.getTurnFlags(true, 0);
+        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
+        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
+
+        // we expect two different entries: the first one is a combination of turn flags of car and foot, 
+        // since they provide the same relation, the other one is for bike only
+        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
+        long assertFlag2 = turnCostEntry_bike.flags;
+
+        // combine flags of all encoders
+        Collection<OSMTurnRelation.TurnCostTableEntry> entries = reader.analyzeTurnRelation(null);
+
+        // we expect two different turnCost entries
+        assertEquals(2, entries.size());
+
+        for (OSMTurnRelation.TurnCostTableEntry entry : entries)
+        {
+            if (entry.edgeFrom == 1)
+            {
+                // the first entry provides turn flags for car and foot only 
+                assertEquals(assertFlag1, entry.flags);
+                assertTrue(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertTrue(Double.isInfinite(car.getTurnCost(entry.flags)));
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, bike.getTurnCost(entry.flags), 1e-1);
+            } else if (entry.edgeFrom == 2)
+            {
+                // the 2nd entry provides turn flags for bike only
+                assertEquals(assertFlag2, entry.flags);
+                assertFalse(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertEquals(0, car.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(10, bike.getTurnCost(entry.flags), 1e-1);
+            }
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
new file mode 100644
index 0000000000..7c3629cd9e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -0,0 +1,106 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader;
+
+import com.graphhopper.reader.OSMTurnRelation.Type;
+import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.util.EdgeExplorer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class OSMTurnRelationTest
+{
+    @Test
+    public void testGetRestrictionAsEntries()
+    {
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
+        final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
+        final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
+                
+        osmNodeToInternal.put(3L, 3);
+        // edge ids are only stored if they occured before in an OSMRelation
+        internalToOSMEdge.put(3, 3L);        
+        internalToOSMEdge.put(4, 4L);        
+
+        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
+        EdgeBasedRoutingAlgorithmTest.initGraph(graph);
+        OSMReader osmReader = new OSMReader(graph)
+        {
+
+            @Override
+            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
+            {
+                return osmNodeToInternal.get(nodeOsmId);
+            }
+
+            @Override
+            public long getOsmIdOfInternalEdge( int edgeId )
+            {
+                Long l = internalToOSMEdge.get(edgeId);
+                if(l == null)
+                    return -1;
+                return l;
+            }
+        };
+
+        EdgeExplorer edgeExplorer = graph.createEdgeExplorer();
+
+        // TYPE == ONLY
+        OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
+        Collection<OSMTurnRelation.TurnCostTableEntry> result
+                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+
+        assertEquals(2, result.size());
+        Iterator<OSMTurnRelation.TurnCostTableEntry> iter = result.iterator();
+        OSMTurnRelation.TurnCostTableEntry entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(6, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);
+        
+        entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(2, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);
+        
+        
+        // TYPE == NOT
+        instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
+        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+
+        assertEquals(1, result.size());
+        iter = result.iterator();
+        entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(3, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);       
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
new file mode 100644
index 0000000000..e07c32fe02
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class CGIARProviderTest
+{
+    @Test
+    public void testDown()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        assertEquals(50, instance.down(52.5));
+        assertEquals(0, instance.down(0.1));
+        assertEquals(0, instance.down(0.01));
+        assertEquals(-5, instance.down(-0.01));
+        assertEquals(-5, instance.down(-2));
+        assertEquals(-10, instance.down(-5.1));
+        assertEquals(50, instance.down(50));
+        assertEquals(45, instance.down(49));
+    }
+
+    @Test
+    public void testFileName()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        assertEquals("srtm_36_02", instance.getFileName(52, -0.1));
+        assertEquals("srtm_35_02", instance.getFileName(50, -10));
+
+        assertEquals("srtm_36_23", instance.getFileName(-52, -0.1));
+        assertEquals("srtm_35_22", instance.getFileName(-50, -10));
+
+        assertEquals("srtm_39_03", instance.getFileName(49.9, 11.5));
+        assertEquals("srtm_34_08", instance.getFileName(20, -11));
+        assertEquals("srtm_34_08", instance.getFileName(20, -14));
+        assertEquals("srtm_34_08", instance.getFileName(20, -15));
+        assertEquals("srtm_37_02", instance.getFileName(52.1943832, 0.1363176));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
new file mode 100644
index 0000000000..f9adbc5ae3
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -0,0 +1,139 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.RAMDirectory;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class HeightTileTest
+{
+    @Test
+    public void testGetHeight()
+    {
+        // data access has same coordinate system as graphical or UI systems have (or the original DEM data has).
+        // But HeightTile has lat,lon system ('mathematically')
+        int width = 10;
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,9
+        heights.setShort(2 * (9 * width + 2), (short) 90);
+
+        assertEquals(1, instance.getHeight(5, 5), 1e-3);
+        assertEquals(70, instance.getHeight(2.5, 1.5), 1e-3);
+        // edge cases for one tile with the boundaries [min,min+degree/width) for lat and lon
+        assertEquals(1, instance.getHeight(3, 2), 1e-3);
+        assertEquals(70, instance.getHeight(2, 1), 1e-3);
+
+        // edge cases for the whole object        
+        assertEquals(1, instance.getHeight(+1.0, 2), 1e-3);
+        assertEquals(90, instance.getHeight(0.5, 2.5), 1e-3);
+        assertEquals(90, instance.getHeight(0.0, 2.5), 1e-3);
+        assertEquals(1, instance.getHeight(+0.0, 3), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 3.5), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 3.0), 1e-3);
+        // fall back to "2,9" if within its boundaries
+        assertEquals(90, instance.getHeight(-0.5, 2.5), 1e-3);
+
+        assertEquals(1, instance.getHeight(0, 0), 1e-3);
+        assertEquals(1, instance.getHeight(9, 10), 1e-3);
+        assertEquals(1, instance.getHeight(10, 9), 1e-3);
+        assertEquals(1, instance.getHeight(10, 10), 1e-3);
+
+        // no error
+        assertEquals(1, instance.getHeight(10.5, 5), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 5), 1e-3);
+        assertEquals(1, instance.getHeight(1, -0.5), 1e-3);
+        assertEquals(1, instance.getHeight(1, 10.5), 1e-3);
+    }
+
+    @Test
+    public void testGetHeightForNegativeTile()
+    {
+        int width = 10;
+        HeightTile instance = new HeightTile(-20, -20, width, 1e-6, 10);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,9
+        heights.setShort(2 * (9 * width + 2), (short) 90);
+
+        assertEquals(1, instance.getHeight(-15, -15), 1e-3);
+        assertEquals(70, instance.getHeight(-17.5, -18.5), 1e-3);
+        // edge cases for one tile with the boundaries [min,min+degree/width) for lat and lon
+        assertEquals(1, instance.getHeight(-17, -18), 1e-3);
+        assertEquals(70, instance.getHeight(-18, -19), 1e-3);
+    }
+
+    @Test
+    public void testCalcMean()
+    {
+        int width = 10;
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10).setCalcMean(true);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=0,9
+        heights.setShort(2 * (9 * width + 0), (short) 10);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,8
+        heights.setShort(2 * (8 * width + 2), (short) 90);
+
+        assertEquals((70 + 4) / 5d, instance.getHeight(2, 1), 1e-3);
+
+        assertEquals((70 + 90 + 3) / 5d, instance.getHeight(2.5, 2.5), 1e-3);
+
+        assertEquals((90 + 3) / 4d, instance.getHeight(-0.5, 2.5), 1e-3);
+
+        assertEquals((10 + 2) / 3d, instance.getHeight(-0.5, -0.5), 1e-3);
+    }
+
+    private void init( DataAccess da, int width, int i )
+    {
+        for (int x = 0; x < width; x++)
+        {
+            for (int y = 0; y < width; y++)
+            {
+                da.setShort(2 * (y * width + x), (short) 1);
+            }
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index f640c8280f..79631a5a02 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -18,6 +18,7 @@
  */
 package com.graphhopper.reader.dem;
 
+import com.graphhopper.storage.DAType;
 import java.io.File;
 import java.io.IOException;
 import org.junit.After;
@@ -67,11 +68,11 @@ public void testGetHeight() throws IOException
 //        instance.getEle(43, 13);
 
         // siegesturm
-        assertEquals(466, instance.getEle(49.969331, 11.574783), 1e-1);
+        assertEquals(466, instance.getEle(49.968651, 11.574869), 1e-1);
         // am main
         assertEquals(330, instance.getEle(49.958233, 11.558647), 1e-1);
         // south america
-        assertEquals(1691, instance.getEle(-28.88316, -71.070557), 1e-1);
+        assertEquals(1678, instance.getEle(-28.88316, -71.070557), 1e-1);
         assertEquals(0, instance.getEle(-28.671311, -71.38916), 1e-1);
 
         // montevideo
@@ -81,20 +82,19 @@ public void testGetHeight() throws IOException
         // use 0 elevation if area not found
         assertEquals(0, instance.getEle(55.4711873, 19.2501641), 1e-1);
 
-        assertEquals(160, instance.getEle(55.8943144, -3), 1e-1);
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
         // precision = 1e6 => -3
         // assertEquals(160, instance.getEle(55.8943144, -3.0000004), 1e-1);
         // precision = 1e7 => -4
-        assertEquals(154, instance.getEle(55.8943144, -3.0000004), 1e-1);
-
-        assertEquals(160, instance.getEle(55.8943144, -3.0000001), 1e-1);
+        // assertEquals(161, instance.getEle(55.8943144, -3.0004), 1e-1);
+        // assertEquals(161, instance.getEle(55.8943144, -3.0000001), 1e-1);
     }
 
     @Test
     public void testGetHeightMMap() throws IOException
     {
         instance.setCacheDir(new File("./files/"));
-        instance.setInMemory(false);
-        assertEquals(160, instance.getEle(55.8943144, -3), 1e-1);
+        instance.setDAType(DAType.MMAP);
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index c2271245f0..ea30e4233c 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,28 +17,55 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class AStarBidirectionTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public AStarBidirectionTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStarBidirection(_graph, encoder, w);
+                return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 56dcecf7a7..92c5a2b0a7 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -17,27 +17,54 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class AStarTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public AStarTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStar(_graph, encoder, w);
+                return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index a62fcaa609..d1df1a0b63 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -40,6 +40,7 @@
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
     protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+    protected AlgorithmOptions defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new ShortestWeighting()).build();
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -51,20 +52,38 @@ protected Graph createGraph( boolean is3D )
         return createGraph(encodingManager, is3D);
     }
 
-    public AlgorithmPreparation prepareGraph( Graph g )
+    public RoutingAlgorithm createAlgo( Graph g )
     {
-        return prepareGraph(g, carEncoder, new ShortestWeighting());
+        return createAlgo(g, defaultOpts);
     }
 
-    public abstract AlgorithmPreparation prepareGraph( Graph g, FlagEncoder encoder, Weighting w );
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 7);
-        assertEquals(p.toString(), 13, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), 5, p.calcNodes().size());
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
+        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(p.toString(), 62.1, p.getDistance(), .1);
+    }
+
+    @Test
+    public void testCalcShortestPathWithLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
     }
 
     // see calc-fastest-graph.svg
@@ -73,14 +92,17 @@ public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
         initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = prepareGraph(graphShortest, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 3);
+        Path p1 = createAlgo(graphShortest, defaultOpts).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 144823, p1.getMillis());
 
         Graph graphFastest = createGraph(false);
         initDirectedAndDiffSpeed(graphFastest);
-        Path p2 = prepareGraph(graphFastest, carEncoder, new FastestWeighting(carEncoder)).createAlgo().calcPath(0, 3);
+        Path p2 = createAlgo(graphFastest,
+                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
         assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
         assertEquals(p2.toString(), 111437, p2.getMillis());
@@ -132,7 +154,8 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = prepareGraph(graphShortest, footEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 7);
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).weighting(new ShortestWeighting()).build()).
+                calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
@@ -186,24 +209,26 @@ protected Graph createTestGraph()
         graph.edge(5, 6, 2, true);
         graph.edge(5, 7, 1, true);
 
-        graph.edge(6, 7, 5, true);
-        return graph;
-    }
+        EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
 
-    @Test
-    public void testCalcIfEmptyWay()
-    {
-        Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 0);
-        assertEquals(p.toString(), 0, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        updateDistancesFor(graph, 0, 0.0010, 0.00001);
+        updateDistancesFor(graph, 1, 0.0008, 0.0000);
+        updateDistancesFor(graph, 2, 0.0005, 0.0001);
+        updateDistancesFor(graph, 3, 0.0006, 0.0002);
+        updateDistancesFor(graph, 4, 0.0009, 0.0001);
+        updateDistancesFor(graph, 5, 0.0007, 0.0001);
+        updateDistancesFor(graph, 6, 0.0009, 0.0002);
+        updateDistancesFor(graph, 7, 0.0008, 0.0003);
+
+        edge6_7.setDistance(5 * edge6_7.getDistance());
+        return graph;
     }
 
     @Test
     public void testNoPathFound()
     {
         Graph graph = createGraph(false);
-        assertFalse(prepareGraph(graph).createAlgo().calcPath(0, 1).isFound());
+        assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
         // two disconnected areas
         graph.edge(0, 1, 7, true);
@@ -212,23 +237,22 @@ public void testNoPathFound()
         graph.edge(5, 7, 1, true);
         graph.edge(5, 8, 1, true);
         graph.edge(7, 8, 1, true);
-        RoutingAlgorithm algo = prepareGraph(graph).createAlgo();
+        RoutingAlgorithm algo = createAlgo(graph);
         assertFalse(algo.calcPath(0, 5).isFound());
-        // assertEquals(4, algo.getVisitedNodes());
+        // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
         graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
-        algo = prepareGraph(graph).createAlgo();
-        assertFalse(algo.calcPath(1, 2).isFound());
+        assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
     }
 
     @Test
     public void testWikipediaShortestPath()
     {
         Graph graph = createWikipediaTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -237,9 +261,9 @@ public void testWikipediaShortestPath()
     public void testCalcIf1EdgeAway()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        Path p = createAlgo(graph).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
@@ -263,7 +287,7 @@ protected Graph createWikipediaTestGraph()
     // |    8  |
     // \   /   |
     //  7-6----5
-    public static void initBiGraph( Graph graph )
+    public static Graph initBiGraph( Graph graph )
     {
         // distance will be overwritten in second step as we need to calculate it from lat,lon
         graph.edge(0, 1, 1, true);
@@ -290,6 +314,7 @@ public static void initBiGraph( Graph graph )
         updateDistancesFor(graph, 7, 0, 0);
         updateDistancesFor(graph, 6, 0, 0.001);
         updateDistancesFor(graph, 5, 0, 0.004);
+        return graph;
     }
 
     private static final DistanceCalc distCalc = new DistanceCalcEarth();
@@ -305,6 +330,7 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
             double adjLat = na.getLatitude(adj);
             double adjLon = na.getLongitude(adj);
             iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
 
@@ -315,12 +341,12 @@ public void testBidirectional()
         initBiGraph(graph);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
         assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
 
-        p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
@@ -347,7 +373,7 @@ public void testBidirectional2()
         graph.edge(3, 8, 20, true);
         graph.edge(8, 6, 20, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
         assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
@@ -357,7 +383,7 @@ public void testBidirectional2()
     public void testRekeyBugOfIntBinHeap()
     {
         // using Dijkstra + IntBinHeap then rekey loops endlessly
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(36, 91);
+        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
         assertEquals(12, p.calcNodes().size());
 
         TIntList list = p.calcNodes();
@@ -372,7 +398,7 @@ public void testRekeyBugOfIntBinHeap()
     @Test
     public void testBug1()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(34, 36);
+        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
@@ -381,7 +407,7 @@ public void testBug1()
     @Test
     public void testCorrectWeight()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(45, 72);
+        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
@@ -393,7 +419,7 @@ public void testCannotCalculateSP()
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
 
@@ -408,7 +434,7 @@ public void testDirectedGraphBug1()
         graph.edge(3, 4, 3, false);
         graph.edge(4, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
@@ -424,7 +450,7 @@ public void testDirectedGraphBug2()
 
         graph.edge(3, 1, 4, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 3);
+        Path p = createAlgo(graph).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
     }
 
@@ -452,45 +478,69 @@ public void testWithCoordinates()
         graph.edge(1, 3, 1.3, true);
         graph.edge(1, 4, 1, true);
 
-        AlgorithmPreparation prepare = prepareGraph(graph);
-        Path p = prepare.createAlgo().calcPath(4, 0);
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
+        RoutingAlgorithmFactory prepare = createFactory(graph, opts);
+        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
         assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
         assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo().calcPath(2, 1);
+        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
         // System.out.println(p.toDetailsString());
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
         assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
         assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
 
+    @Test
+    public void testCalcIfEmptyWay()
+    {
+        Graph graph = createTestGraph();
+        Path p = createAlgo(graph).calcPath(0, 0);
+        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+    }
+
+    @Test
+    public void testViaEdges_FromEqualsTo()
+    {
+        Graph graph = createTestGraph();
+        // identical tower nodes
+        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(0), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // identical query points on edge
+        p = calcPath(graph, 0, 1, 0, 1);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(8), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // very close
+        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        assertEquals(Helper.createTList(8, 9), p.calcNodes());
+        assertEquals(p.toString(), 1.11, p.getDistance(), .1);
+    }
+
     @Test
     public void testViaEdges_BiGraph()
     {
         Graph graph = createGraph(false);
         initBiGraph(graph);
 
-        // 0-7 to 4-3
+        // 0-7 to 4-3        
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 324.11, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(10, 0, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 1335.42, p.getDistance(), .2);
-    }
-
-    @Test
-    public void testViaEdges_FromEqualsTo()
-    {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 0, 1);
-        // or one node would be acceptable
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
     @Test
@@ -499,7 +549,7 @@ public void testViaEdges_WithCoordinates()
         Graph graph = createTestGraph();
         Path p = calcPath(graph, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
     @Test
@@ -527,9 +577,9 @@ public void testViaEdges_SpecialCases()
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00015, 0.00001, 0.0001);
+        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
         assertEquals(Helper.createTList(5, 6), p.calcNodes());
-        assertEquals(p.toString(), 7, p.getDistance(), .1);
+        assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
@@ -567,7 +617,13 @@ Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fro
         Weighting w = new ShortestWeighting();
         if (weighting.equalsIgnoreCase("fastest"))
             w = new FastestWeighting(carEncoder);
-        return prepareGraph(graph, carEncoder, w).createAlgo().calcPath(from, to);
+
+        // correct order for CH: in factory do prepare and afterwards wrap in query graph
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, opts).
+                calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
@@ -575,7 +631,10 @@ Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNod
         // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
         QueryResult from = newQR(graph, fromNode1, fromNode2);
         QueryResult to = newQR(graph, toNode1, toNode2);
-        return prepareGraph(graph).createAlgo().calcPath(from, to);
+
+        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     /**
@@ -612,19 +671,39 @@ public void testTwoWeightsPerEdge()
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = prepareGraph(graph, encoder, new FastestWeighting(encoder)).
-                createAlgo().calcPath(0, 10);
+        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
 //        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(85124371, p.getMillis());
         assertEquals(425622, p.getDistance(), 1);
-        assertEquals(23646, p.getWeight(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
+    }
+
+    @Test
+    public void test0SpeedButUnblocked_Issue242()
+    {
+        Graph graph = createGraph(false);
+        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+
+        graph.edge(0, 1).setFlags(flags).setDistance(10);
+        graph.edge(1, 2).setFlags(flags).setDistance(10);
+
+        RoutingAlgorithm algo = createAlgo(graph);
+        try
+        {
+            Path p = algo.calcPath(0, 2);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
+        }
     }
 
     @Test
     public void testTwoWeightsPerEdge2()
     {
+        // other direction should be different!
         Graph graph = initEleGraph(createGraph(true));
-        Path p = prepareGraph(graph, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 10);
+        Path p = createAlgo(graph).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
         assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
         Weighting fakeWeighting = new Weighting()
@@ -636,10 +715,10 @@ public double getMinWeight( double distance )
             }
 
             @Override
-            public double calcWeight( EdgeIteratorState edge, boolean reverse )
+            public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
             {
-                int adj = edge.getAdjNode();
-                int base = edge.getBaseNode();
+                int adj = edgeState.getAdjNode();
+                int base = edgeState.getBaseNode();
                 if (reverse)
                 {
                     int tmp = base;
@@ -649,20 +728,24 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse )
 
                 // a 'hill' at node 6
                 if (adj == 6)
-                    return 3 * edge.getDistance();
+                    return 3 * edgeState.getDistance();
                 else if (base == 6)
-                    return edge.getDistance() * 0.9;
+                    return edgeState.getDistance() * 0.9;
                 else if (adj == 4)
-                    return 2 * edge.getDistance();
+                    return 2 * edgeState.getDistance();
 
-                return edge.getDistance() * 0.8;
+                return edgeState.getDistance() * 0.8;
             }
         };
 
         graph = initEleGraph(createGraph(true));
         QueryResult from = newQR(graph, 3, 0);
         QueryResult to = newQR(graph, 10, 9);
-        p = prepareGraph(graph, carEncoder, fakeWeighting).createAlgo().calcPath(from, to);
+
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(37009621, p.getMillis());
         assertEquals(616827, p.getDistance(), 1);
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 21acdad1e4..0f67d59627 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,24 +18,54 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraBidirectionRefTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraBidirectionRefTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraBidirectionRef(_graph, encoder, w);
+                return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };    
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 0e2bba8ff0..3f156783dc 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -17,35 +17,61 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import java.util.Arrays;
+import java.util.Collection;
 import static org.junit.Assert.*;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraOneToManyTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            {
+                TraversalMode.NODE_BASED
+            },
+//            TODO { TraversalMode.EDGE_BASED_1DIR },
+//            TODO { TraversalMode.EDGE_BASED_2DIR },
+//            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraOneToManyTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraOneToMany(_graph, encoder, w);
+                return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 
     @Override
@@ -84,17 +110,45 @@ public void testTwoWeightsPerEdge2()
         // calcPath with QueryResult not supported
     }
 
+    @Test
+    public void testIssue182()
+    {
+        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
+        Path p = algo.calcPath(0, 8);
+        assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
+
+        // expand SPT
+        p = algo.calcPath(0, 10);
+        assertEquals(Helper.createTList(0, 1, 2, 3, 4, 10), p.calcNodes());
+    }
+
+    @Test
+    public void testIssue239()
+    {
+        Graph g = createGraph(false);
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 0, 1, true);
+
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 4, 1, true);
+
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
+        assertEquals(-1, algo.findEndNode(0, 4));
+        assertEquals(-1, algo.findEndNode(0, 4));
+    }
+
     @Test
     public void testUseCache()
     {
-        AlgorithmPreparation prep = prepareGraph(createTestGraph());
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(createTestGraph());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
@@ -111,8 +165,7 @@ public void testDifferentEdgeFilter()
         g.edge(4, 5, 10, true);
         g.edge(5, 6, 10, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         algo.setEdgeFilter(new EdgeFilter()
         {
             @Override
@@ -137,4 +190,22 @@ public boolean accept( EdgeIteratorState iter )
         p = algo.calcPath(4, 6);
         assertEquals(Helper.createTList(4, 5, 6), p.calcNodes());
     }
+
+    private Graph initGraph( Graph g )
+    {
+        // 0-1-2-3-4
+        // |       /
+        // 7-10----
+        // \-8
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(4, 10, 1, true);
+
+        g.edge(0, 7, 1, true);
+        g.edge(7, 8, 1, true);
+        g.edge(7, 10, 10, true);
+        return g;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index c0aca220a0..fb8c479901 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -17,28 +17,55 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting weighting )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new Dijkstra(_graph, encoder, weighting);
+                return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
new file mode 100644
index 0000000000..1bbc864885
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -0,0 +1,232 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import static org.junit.Assert.*;
+import static com.graphhopper.util.GHUtility.*;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/**
+ * @author Peter Karich
+ */
+@RunWith(Parameterized.class)
+public class EdgeBasedRoutingAlgorithmTest
+{
+    private FlagEncoder carEncoder;
+
+    EncodingManager createEncodingManager( boolean restrictedOnly )
+    {
+        if (restrictedOnly)
+            carEncoder = new CarFlagEncoder(5, 5, 1);
+        else
+            // allow for basic costs too
+            carEncoder = new CarFlagEncoder(5, 5, 3);
+        return new EncodingManager(carEncoder);
+    }
+
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { AlgorithmOptions.DIJKSTRA },
+            { AlgorithmOptions.DIJKSTRA_BI },
+            { AlgorithmOptions.ASTAR },
+            { AlgorithmOptions.ASTAR_BI }
+        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+        });
+    }
+
+    private final String algoStr;
+
+    public EdgeBasedRoutingAlgorithmTest( String algo )
+    {
+        this.algoStr = algo;
+    }
+
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
+        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
+    }
+
+    protected GraphStorage createGraph( EncodingManager em )
+    {
+        return new GraphBuilder(em).create();
+    }
+
+    // 0---1
+    // |   /
+    // 2--3--4
+    // |  |  |
+    // 5--6--7
+    public static void initGraph( Graph g )
+    {
+        g.edge(0, 1, 3, true);
+        g.edge(0, 2, 1, true);
+        g.edge(1, 3, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(2, 5, .5, true);
+        g.edge(3, 6, 1, true);
+        g.edge(4, 7, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+    }
+
+    private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder )
+    {
+        long tflags = tEncoder.getTurnFlags(true, 0);
+
+        // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+
+        // only right   from 5-2 to 2-3 => limit 5,2->2,0
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
+
+        // only right   from 7-6 to 6-3 => limit 7,6->6,5
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+
+        // no 5-6 to 6-3
+        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        // no 4-3 to 3-1
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        // no 4-3 to 3-2
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
+
+        // no u-turn at 6-7
+        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
+
+        // no u-turn at 3-6
+        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+    }
+
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
+    {
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
+    }
+
+    @Test
+    public void testBasicTurnRestriction()
+    {
+        GraphStorage g = createGraph(createEncodingManager(true));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        initTurnRestrictions(g, tcs, carEncoder);
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(5, 1);
+        assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
+
+        // test 7-6-5 and reverse
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 7);
+        assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
+
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(7, 5);
+        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testUTurns()
+    {
+        GraphStorage g = createGraph(createEncodingManager(true));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+
+        long tflags = carEncoder.getTurnFlags(true, 0);
+
+        // force u-turn via lowering the cost for it
+        EdgeIteratorState e3_6 = getEdge(g, 3, 6);
+        e3_6.setDistance(0.1);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
+
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);        
+
+        assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
+
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        p = createAlgo(g, opts).calcPath(7, 5);
+
+        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testBasicTurnCosts()
+    {
+        GraphStorage g = createGraph(createEncodingManager(false));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
+
+        // no restriction and costs
+        EdgeIteratorState e3_6 = getEdge(g, 5, 6);
+        e3_6.setDistance(2);
+        assertEquals(Helper.createTList(5, 2, 3, 1), p.calcNodes());
+
+        // now introduce some turn costs
+        long tflags = carEncoder.getTurnFlags(false, 2);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
+
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
+        assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
index 16f987a289..61e00f2f72 100644
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
@@ -23,12 +23,10 @@
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.util.*;
-import com.graphhopper.util.TranslationMap.Translation;
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.shapes.GHPoint;
 
 import java.io.File;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import org.junit.After;
 import org.junit.Test;
@@ -40,8 +38,6 @@
  */
 public class GraphHopperIT
 {
-    TranslationMap trMap = TranslationMapTest.SINGLETON;
-    Translation tr = trMap.getWithFallBack(Locale.US);
     String graphFile = "target/graph-GraphHopperIT";
     String osmFile = "files/monaco.osm.gz";
     String vehicle = "FOOT";
@@ -65,15 +61,15 @@ public void tearDown()
     public void testMonacoWithInstructions() throws Exception
     {
         GraphHopper hopper = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
                 setOSMFile(osmFile).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(graphFile).
                 setEncodingManager(new EncodingManager(importVehicles)).
                 importOrLoad();
 
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
@@ -81,12 +77,12 @@ public void testMonacoWithInstructions() throws Exception
         InstructionList il = rsp.getInstructions();
         assertEquals(13, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson(tr);
+        List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
         assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
         assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
         assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left onto road", resultJson.get(3).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
 
         assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
@@ -114,9 +110,9 @@ public void testMonacoWithInstructions() throws Exception
     public void testSRTMWithInstructions() throws Exception
     {
         GraphHopper hopper = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
                 setOSMFile(osmFile).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(graphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
@@ -124,9 +120,9 @@ public void testSRTMWithInstructions() throws Exception
         hopper.importOrLoad();
 
         GHResponse rsp = hopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
-        assertEquals(1634, rsp.getDistance(), .1);
+        assertEquals(1626.8, rsp.getDistance(), .1);
         assertEquals(60, rsp.getPoints().getSize());
         assertTrue(rsp.getPoints().is3D());
 
@@ -135,50 +131,122 @@ public void testSRTMWithInstructions() throws Exception
         assertTrue(il.get(0).getPoints().is3D());
 
         String str = rsp.getPoints().toString();
-        assertTrue(str,
-                str.startsWith("(43.73068455771767,7.421283689825812,66.0), (43.73067957305937,7.421382123709815,66.0), "
-                        + "(43.73109792316924,7.421546222751131,66.0), (43.73129908884985,7.421589994913116,66.0), "
-                        + "(43.731327028527716,7.421414533736137,66.0), (43.73125047381037,7.421366291225693,66.0), "
-                        + "(43.73125457162979,7.421274090288746,66.0), "
-                        + "(43.73128213877862,7.421115579183003,66.0), (43.731362232521825,7.421145381506057,66.0), "
-                        + "(43.731371359483255,7.421123216028286,66.0), (43.731485725897976,7.42117332118392,45.0), "
-                        + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
-                        + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,45.0)"));
+        assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
+                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
+                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
+                + "(43.73125457162979,7.421274090288746,52.0), "
+                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
+                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
+                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
+                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
+                str.substring(0, 662));
+
+        assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
+                + "(43.727680946587874,7.4191987684222065,11.0)",
+                str.substring(str.length() - 133));
+
+        List<GPXEntry> list = rsp.getInstructions().createGPXList();
+        assertEquals(60, list.size());
+        final long lastEntryMillis = list.get(list.size() - 1).getMillis();
+        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
+        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+
+        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
+        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
+        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+    }
+
+    @Test
+    public void testKremsCyclewayInstructionsWithWayTypeInfo()
+    {
+        String tmpOsmFile = "files/krems.osm.gz";
+        String tmpGraphFile = "target/graph-krems";
+        String tmpVehicle = "BIKE";
+        String tmpImportVehicles = "CAR,BIKE";
+        String tmpWeightCalcStr = "fastest";
+
+        try
+        {
+            // make sure we are using fresh graphhopper files with correct vehicle
+            Helper.removeDir(new File(tmpGraphFile));
+            GraphHopper hopper = new GraphHopper().
+                    setStoreOnFlush(true).
+                    setOSMFile(tmpOsmFile).
+                    setCHEnable(false).
+                    setGraphHopperLocation(tmpGraphFile).
+                    setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                    importOrLoad();
+
+            GHResponse rsp = hopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                    setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+            assertEquals(6932.24, rsp.getDistance(), .1);
+            assertEquals(110, rsp.getPoints().getSize());
+
+            InstructionList il = rsp.getInstructions();
+            assertEquals(19, il.size());
+            List<Map<String, Object>> resultJson = il.createJson();
+
+            assertEquals("Continue onto Obere Landstrae", resultJson.get(0).get("text"));
+            assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
+            assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
+            assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
+
+            assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
+            assertEquals("Turn right onto Margarethenstrae", resultJson.get(3).get("text"));
+            assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
+            assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
+            assertEquals("Turn slight left onto Untere Landstrae", resultJson.get(6).get("text"));
+            assertEquals("Turn right onto Ringstrae, L73", resultJson.get(7).get("text"));
+            assertEquals("Continue onto Eyblparkstrae", resultJson.get(8).get("text"));
+            assertEquals("Continue onto Austrae", resultJson.get(9).get("text"));
+            assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+            //..
+            assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+            assertEquals("cycleway", resultJson.get(15).get("annotationText"));
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException("cannot handle osm file " + tmpOsmFile, ex);
+        } finally
+        {
+            Helper.removeDir(new File(tmpGraphFile));
+        }
     }
 
     @Test
     public void testMonacoVia()
     {
         GraphHopper hopper = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
                 setOSMFile(osmFile).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(graphFile).
                 setEncodingManager(new EncodingManager(importVehicles)).
                 importOrLoad();
 
         GHResponse rsp = hopper.route(new GHRequest().
-                addPlace(new GHPlace(43.727687, 7.418737)).
-                addPlace(new GHPlace(43.74958, 7.436566)).
-                addPlace(new GHPlace(43.727687, 7.418737)).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(6875.1, rsp.getDistance(), .1);
         assertEquals(179, rsp.getPoints().getSize());
 
         InstructionList il = rsp.getInstructions();
         assertEquals(26, il.size());
-        List<Map<String, Object>> resultJson = il.createJson(tr);
+        List<Map<String, Object>> resultJson = il.createJson();
         assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
         assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
         assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left onto road", resultJson.get(3).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
 
         assertEquals("Stopover 1", resultJson.get(12).get("text"));
 
         assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
-        assertEquals("Turn left onto road", resultJson.get(21).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
         assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
         assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
         assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
@@ -197,5 +265,29 @@ public void testMonacoVia()
         assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
         assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
         assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+        
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index a7d62bdefd..ecf8faec01 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -40,10 +37,11 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
-    private final TranslationMap.Translation tr = trMap.getWithFallBack(Locale.US);
+    private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testFound()
@@ -91,12 +89,12 @@ public void testWayList()
         path.extract();
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
-        InstructionList instr = path.calcInstructions();
-        List<Map<String, Object>> res = instr.createJson(tr);
+        InstructionList instr = path.calcInstructions(tr);
+        List<Map<String, Object>> res = instr.createJson();
         Map<String, Object> tmp = res.get(0);
         assertEquals(3000.0, tmp.get("distance"));
         assertEquals(504000L, tmp.get("time"));
-        assertEquals("Continue onto road", tmp.get("text"));
+        assertEquals("Continue", tmp.get("text"));
         assertEquals("[0, 6]", tmp.get("interval").toString());
 
         tmp = res.get(1);
@@ -115,13 +113,13 @@ public void testWayList()
         e1.parent.parent = new EdgeEntry(-1, 0, 1);
         path.setEdgeEntry(e1);
         path.extract();
-        instr = path.calcInstructions();
-        res = instr.createJson(tr);
+        instr = path.calcInstructions(tr);
+        res = instr.createJson();
 
         tmp = res.get(0);
         assertEquals(1000.0, tmp.get("distance"));
         assertEquals(360000L, tmp.get("time"));
-        assertEquals("Continue onto road", tmp.get("text"));
+        assertEquals("Continue", tmp.get("text"));
         assertEquals("[0, 3]", tmp.get("interval").toString());
 
         tmp = res.get(1);
@@ -141,9 +139,9 @@ public void testWayList()
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
-        instr = path.calcInstructions();
 
-        res = instr.createJson(tr);
+        instr = path.calcInstructions(tr);
+        res = instr.createJson();
         tmp = res.get(0);
         assertEquals(2000.0, tmp.get("distance"));
         assertEquals(144000L, tmp.get("time"));
@@ -153,7 +151,7 @@ public void testWayList()
         tmp = res.get(1);
         assertEquals(1000.0, tmp.get("distance"));
         assertEquals(360000L, tmp.get("time"));
-        assertEquals("Turn sharp left onto road", tmp.get("text"));
+        assertEquals("Turn sharp left", tmp.get("text"));
         assertEquals("[3, 6]", tmp.get("interval").toString());
         lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
         assertEquals(path.calcPoints().size() - 1, lastIndex);
@@ -192,16 +190,186 @@ public void testFindInstruction()
         path.setEdgeEntry(e1);
         path.extract();
 
-        path.calcInstructions();
-        Instruction nextInstr1 = path.findInstruction(0.0, 0.1);
-        Instruction nextInstr2 = path.findInstruction(5.0, 0.4);
-        Instruction nextInstr3 = path.findInstruction(9.0, 0.53);
-        Instruction nextInstr4 = path.findInstruction(7.8, 0.25);
-
+        InstructionList il = path.calcInstructions(tr);
+        Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
+        assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
+        
+        Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
+
+        Instruction nextInstr2 = il.find(5.0, 0.004, 1000);
         assertEquals(Instruction.TURN_LEFT, nextInstr2.getSign());
+
+        Instruction nextInstr3 = il.find(9.99, 0.503, 1000);
         assertEquals(Instruction.TURN_SHARP_LEFT, nextInstr3.getSign());
+
+        // a bit far away ...
+        Instruction nextInstr4 = il.find(7.40, 0.25, 20000);
         assertEquals(Instruction.FINISH, nextInstr4.getSign());
+
+        // too far away
+        assertNull(il.find(50.8, 50.25, 1000));
+    }
+
+    private class RoundaboutGraph
+    {
+        public EdgeIteratorState edge2change;
+        boolean clockwise;
+        final public Graph g = new GraphBuilder(carManager).create();
+        final public NodeAccess na = g.getNodeAccess();
+
+        private RoundaboutGraph(boolean clockwise)
+        {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        |
+            //        6
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.351);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge2change = tmpEdge.detach(false);
+            this.clockwise = clockwise;
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto MainStreet",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        delta = rg.getAngle(1, 2, 4, 7);
+        instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        RoundaboutGraph rg = new RoundaboutGraph(true);
+        System.out.println(rg.clockwise);
+
+        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index afd46f539e..c8607c1f5e 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -17,13 +17,8 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import static com.graphhopper.storage.index.QueryResult.Position.*;
 import com.graphhopper.util.*;
@@ -158,7 +153,7 @@ public void testFillVirtualEdges()
         {
 
             @Override
-            void fillVirtualEdges( TIntObjectMap<QueryGraph.VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
+            void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
             {
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
@@ -258,7 +253,7 @@ public void testVirtEdges()
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(0);
         iter.next();
 
-        QueryGraph.VirtualEdgeIterator vi = new QueryGraph.VirtualEdgeIterator(2);
+        VirtualEdgeIterator vi = new VirtualEdgeIterator(2);
         vi.add(iter.detach(false));
 
         assertTrue(vi.next());
@@ -311,7 +306,7 @@ public void testLoopStreet_Issue151()
 
         QueryResult qr = new QueryResult(-0.0005, 0.001);
         qr.setClosestEdge(edge);
-        qr.setWayIndex(0);
+        qr.setWayIndex(1);
         qr.calcSnappedPoint(new DistanceCalc2D());
 
         QueryGraph qg = new QueryGraph(g);
@@ -354,12 +349,12 @@ public void testOneWayLoop_Issue162()
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
         EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
         iter.next();
-        assertFalse(iter.toString(), carEncoder.isBackward(iter.getFlags()));
-        assertTrue(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
 
         iter.next();
-        assertTrue(iter.toString(), carEncoder.isBackward(iter.getFlags()));
-        assertFalse(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertFalse(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(iter.toString(), carEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
     }
 
     @Test
@@ -379,6 +374,49 @@ public void testEdgesShareOneNode()
         assertNotNull(GHUtility.getEdge(queryGraph, 0, 3));
     }
 
+    @Test
+    public void testAvoidDuplicateVirtualNodesIfIdentical()
+    {
+        initGraph(g);
+
+        EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
+        QueryResult res1 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryResult res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
+        assertEquals(new GHPoint(0.5, 0), res2.getSnappedPoint());
+        assertEquals(3, res1.getClosestNode());
+        assertEquals(3, res2.getClosestNode());
+
+        // force skip due to **tower** node snapping in phase 2, but no virtual edges should be created for res1
+        edgeState = GHUtility.getEdge(g, 0, 1);
+        res1 = createLocationResult(1, 0, edgeState, 0, EDGE);
+        // now create virtual edges
+        edgeState = GHUtility.getEdge(g, 0, 2);
+        res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        // make sure only one virtual node was created
+        assertEquals(queryGraph.getNodes(), g.getNodes() + 1);
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(0);
+        assertEquals(GHUtility.asSet(1, 3), GHUtility.getNeighbors(iter));
+    }
+
+    @Test
+    public void testGetEdgeProps()
+    {
+        initGraph(g);
+        EdgeIteratorState e1 = GHUtility.getEdge(g, 0, 2);
+        QueryGraph queryGraph = new QueryGraph(g);
+        QueryResult res1 = createLocationResult(0.5, 0, e1, 0, EDGE);
+        queryGraph.lookup(Arrays.asList(res1));
+        // get virtual edge
+        e1 = GHUtility.getEdge(queryGraph, res1.getClosestNode(), 0);
+        EdgeIteratorState e2 = queryGraph.getEdgeProps(e1.getEdge(), Integer.MIN_VALUE);
+        assertEquals(e1.getEdge(), e2.getEdge());
+    }
+
     PointList getPoints( Graph g, int base, int adj )
     {
         EdgeIteratorState edge = GHUtility.getEdge(g, base, adj);
@@ -399,4 +437,106 @@ public QueryResult createLocationResult( double lat, double lon,
         tmp.calcSnappedPoint(new DistanceCalcEarth());
         return tmp;
     }
+
+    @Test
+    public void testIteration_Issue163()
+    {
+        EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), false, true);
+        EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), true, false);
+        EdgeExplorer inExplorer = g.createEdgeExplorer(inEdgeFilter);
+        EdgeExplorer outExplorer = g.createEdgeExplorer(outEdgeFilter);
+
+        int nodeA = 0;
+        int nodeB = 1;
+
+        /* init test graph: one directional edge going from A to B, via virtual nodes C and D
+         * 
+         *   (C)-(D)
+         *  /       \
+         * A         B
+         */
+        g.getNodeAccess().setNode(nodeA, 1, 0);
+        g.getNodeAccess().setNode(nodeB, 1, 10);
+        g.edge(nodeA, nodeB, 10, false).setWayGeometry(Helper.createPointList(1.5, 3, 1.5, 7));
+
+        // assert the behavior for classic edgeIterator        
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeB);
+
+        // setup query results
+        EdgeIteratorState it = GHUtility.getEdge(g, nodeA, nodeB);
+        QueryResult res1 = createLocationResult(1.5, 3, it, 1, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(1.5, 7, it, 2, QueryResult.Position.EDGE);
+
+        QueryGraph q = new QueryGraph(g);
+        q.lookup(Arrays.asList(res1, res2));
+        int nodeC = res1.getClosestNode();
+        int nodeD = res2.getClosestNode();
+
+        inExplorer = q.createEdgeExplorer(inEdgeFilter);
+        outExplorer = q.createEdgeExplorer(outEdgeFilter);
+
+        // assert the same behavior for queryGraph
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeC);
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeC, nodeD);
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeD, nodeB);
+    }
+
+    private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer outExplorer, int startNode, int endNode )
+    {
+        EdgeIterator it = outExplorer.setBaseNode(startNode);
+        it.next();
+        assertEquals(startNode, it.getBaseNode());
+        assertEquals(endNode, it.getAdjNode());
+        // we expect the edge id to be the same when exploring in backward direction
+        int expectedEdgeId = it.getEdge();
+        assertFalse(it.next());
+
+        // backward iteration, edge id should remain the same!!
+        it = inExplorer.setBaseNode(endNode);
+        it.next();
+        assertEquals(endNode, it.getBaseNode());
+        assertEquals(startNode, it.getAdjNode());
+        assertEquals("The edge id is not the same,", expectedEdgeId, it.getEdge());
+        assertFalse(it.next());
+    }
+
+    @Test
+    public void testTurnCostsProperlyPropagated_Issue282()
+    {
+        TurnCostExtension turnExt = new TurnCostExtension();
+        FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
+
+        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+                new EncodingManager(encoder), false, turnExt).
+                create(100);
+        NodeAccess na = graphWithTurnCosts.getNodeAccess();
+        na.setNode(0, .00, .00);
+        na.setNode(1, .00, .01);
+        na.setNode(2, .01, .01);
+
+        EdgeIteratorState edge0 = graphWithTurnCosts.edge(0, 1, 10, true);
+        EdgeIteratorState edge1 = graphWithTurnCosts.edge(2, 1, 10, true);
+
+        QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
+        FastestWeighting weighting = new FastestWeighting(encoder);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
+        
+        assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        // now use turn costs and QueryGraph
+        turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
+        assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+        
+        QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
+
+        qGraph.lookup(Arrays.asList(res1, res2));
+
+        int fromQueryEdge = GHUtility.getEdge(qGraph, res1.getClosestNode(), 1).getEdge();
+        int toQueryEdge = GHUtility.getEdge(qGraph, res2.getClosestNode(), 1).getEdge();
+
+        assertEquals(10, turnWeighting.calcTurnWeight(fromQueryEdge, 1, toQueryEdge), .1);
+
+        graphWithTurnCosts.close();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 2b9b0b8a13..74cc852f3b 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -21,22 +21,21 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.Random;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
 import static org.junit.Assert.*;
@@ -61,29 +60,38 @@ public void setUp()
     List<OneRun> createMonacoCar()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2581, 102));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3586, 162));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 2560, 131));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2227, 128));
-        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2101, 110));
+        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2580, 110));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 2561, 133));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2230, 137));
+        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2100, 116));
         list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.419333, 0, 1));
 
         // same special cases where GPS-exact routing could have problems (same edge and neighbor edges)
         list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.41934, 0, 1));
         // on the same edge and very release
-        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.4193, 2, 2));
+        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.4193, 3, 2));
         // one way stuff
-        list.add(new OneRun(43.729445, 7.415063, 43.728856, 7.41472, 107, 4));
-        list.add(new OneRun(43.728856, 7.41472, 43.729445, 7.415063, 316, 11));
+        list.add(new OneRun(43.729445, 7.415063, 43.728856, 7.41472, 103, 4));
+        list.add(new OneRun(43.728856, 7.41472, 43.729445, 7.415063, 320, 11));
         return list;
     }
 
     @Test
     public void testMonaco()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoCar(), "CAR", true, "CAR", "shortest", false);
+
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // When OSM file stays unchanged make static edge and node IDs a requirement
+        assertEquals(GHUtility.asSet(9, 111, 182), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(19, 21), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(20)));
+        assertEquals(GHUtility.asSet(478, 84, 83), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(480)));
+
+        assertEquals(43.736989, g.getNodeAccess().getLat(10), 1e-6);
+        assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
     @Test
@@ -92,11 +100,11 @@ public void testOneWayCircleBug()
         // export from http://www.openstreetmap.org/export#map=19/51.37605/-0.53155
         List<OneRun> list = new ArrayList<OneRun>();
         // going the bit longer way out of the circle
-        list.add(new OneRun(51.376197, -0.531576, 51.376509, -0.530863, 153, 19));
+        list.add(new OneRun(51.376197, -0.531576, 51.376509, -0.530863, 153, 18));
         // now exacle the opposite direction: going into the circle (shorter)
-        list.add(new OneRun(51.376509, -0.530863, 51.376197, -0.531576, 75, 13));
+        list.add(new OneRun(51.376509, -0.530863, 51.376197, -0.531576, 75, 15));
 
-        runAlgo(testCollector, "files/circle-bug.osm.gz", "target/graph-circle-bug",
+        runAlgo(testCollector, "files/circle-bug.osm.gz", "target/circle-bug-gh",
                 list, "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -115,21 +123,36 @@ public void testMoscow()
         // respect one way!
         // http://localhost:8989/?point=55.819066%2C37.596374&point=55.818898%2C37.59661
         list.add(new OneRun(55.819066, 37.596374, 55.818898, 37.59661, 1114, 23));
-        runAlgo(testCollector, "files/moscow.osm.gz", "target/graph-moscow",
+        runAlgo(testCollector, "files/moscow.osm.gz", "target/moscow-gh",
                 list, "CAR", true, "CAR", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testMoscowTurnCosts()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
+        list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
+        // TODO include CH
+        boolean testAlsoCH = false, is3D = false;
+        runAlgo(testCollector, "files/moscow.osm.gz", "target/graph-moscow",
+                list, "CAR|turnCosts=true", testAlsoCH, "CAR", "fastest", is3D);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoFastest()
     {
         List<OneRun> list = createMonacoCar();
-        list.get(0).setLocs(1, 105);
-        list.get(3).setDistance(1, 2276);
-        list.get(3).setLocs(1, 133);
+        list.get(0).setLocs(1, 117);
+        list.get(0).setDistance(1, 2584);
+        list.get(3).setDistance(1, 2279);
+        list.get(3).setLocs(1, 141);
         list.get(4).setDistance(1, 2149);
-        list.get(4).setLocs(1, 115);
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        list.get(4).setLocs(1, 120);
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "CAR", true, "CAR", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -140,13 +163,13 @@ public void testMonacoMixed()
         // Additional locations are inserted because of new crossings from foot to highway paths!
         // Distance is the same.
         List<OneRun> list = createMonacoCar();
-        list.get(0).setLocs(1, 107);
-        list.get(1).setLocs(1, 165);
+        list.get(0).setLocs(1, 110);
+        list.get(1).setLocs(1, 170);
         list.get(2).setLocs(1, 132);
-        list.get(3).setLocs(1, 132);
-        list.get(4).setLocs(1, 114);
+        list.get(3).setLocs(1, 137);
+        list.get(4).setLocs(1, 116);
 
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "CAR,FOOT", false, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -155,8 +178,8 @@ public void testMonacoMixed()
     {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(43.730729, 7.421288, 43.727697, 7.419199, 1566, 92));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3435, 132));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2085, 111));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3438, 136));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2085, 112));
         list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1425, 89));
         return list;
     }
@@ -164,41 +187,71 @@ public void testMonacoMixed()
     @Test
     public void testMonacoFoot()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoFoot(), "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // see testMonaco for similar ID test
+        assertEquals(GHUtility.asSet(2, 906, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(443, 952, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
+        assertEquals(GHUtility.asSet(909, 580, 912), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
+
+        assertEquals(43.743705, g.getNodeAccess().getLat(100), 1e-6);
+        assertEquals(7.426362, g.getNodeAccess().getLon(701), 1e-6);
     }
 
     @Test
     public void testMonacoFoot3D()
     {
-        // same number of points as testMonaceFoot results but longer distance due to elevation difference
+        // most routes have same number of points as testMonaceFoot results but longer distance due to elevation difference
         List<OneRun> list = createMonacoFoot();
-        list.get(0).setDistance(1, 1634);
-        list.get(1).setDistance(1, 3610);
-        list.get(2).setDistance(1, 2182);
-        list.get(3).setDistance(1, 1498);
+        list.get(0).setDistance(1, 1627);
+        list.get(2).setDistance(1, 2258);
+        list.get(3).setDistance(1, 1482);
+
+        // or slightly longer tour with less nodes: list.get(1).setDistance(1, 3610);
+        list.get(1).setDistance(1, 3595);
+        list.get(1).setLocs(1, 149);
 
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "FOOT", true, "FOOT", "shortest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testNorthBayreuthFootFastestAnd3D()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
+        list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
+        // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach'
+        list.add(new OneRun(49.986111, 11.550407, 50.023182, 11.555386, 5165, 133));
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "FOOT", true, "FOOT", "fastest", true);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testMonacoBike3D_twoSpeedsPerEdge()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1724, 85));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3835, 171));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2425, 122));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1610, 85));
+        // 1. alternative: go over steps 'Rampe Major' => 1.7km vs. around 2.7km
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2710, 118));
+        // 2.
+        list.add(new OneRun(43.728499, 7.417907, 43.74958, 7.436566, 3777, 194));
+        // 3.
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2776, 167));
+        // 4.
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1544, 84));
 
         // try reverse direction
-        list.add(new OneRun(43.727687, 7.418737, 43.730864, 7.420771, 2624, 116));
-        list.add(new OneRun(43.74958, 7.436566, 43.727687, 7.418737, 4255, 159));
-        list.add(new OneRun(43.739213, 7.427806, 43.728677, 7.41016, 2852, 149));
-        list.add(new OneRun(43.739662, 7.424355, 43.733802, 7.413433, 1869, 110));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        // 1.
+        list.add(new OneRun(43.727687, 7.418737, 43.730864, 7.420771, 2599, 115));
+        list.add(new OneRun(43.74958, 7.436566, 43.728499, 7.417907, 4199, 165));
+        list.add(new OneRun(43.739213, 7.427806, 43.728677, 7.41016, 3261, 177));
+        // 4. avoid tunnel(s)!
+        list.add(new OneRun(43.739662, 7.424355, 43.733802, 7.413433, 2452, 112));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "BIKE2", true, "BIKE2", "fastest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -207,11 +260,11 @@ public void testMonacoBike3D_twoSpeedsPerEdge()
     public void testMonacoBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1641, 85));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3580, 163));
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1642, 87));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3580, 168));
         list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 121));
         list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1434, 89));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "BIKE", true, "BIKE", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -220,16 +273,17 @@ public void testMonacoBike()
     public void testMonacoMountainBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2332, 107));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 165));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 121));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1475, 88));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2322, 110));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3613, 178));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2331, 121));
+        // hard to select between secondard and primary (both are AVOID for mtb)
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1459, 88));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "MTB", true, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
 
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "BIKE,MTB,RACINGBIKE", false, "MTB", "fastest", false);
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "MTB,RACINGBIKE", false, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -237,16 +291,16 @@ public void testMonacoMountainBike()
     public void testMonacoRacingBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2597, 115));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3615, 179));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 121));
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2594, 111));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2572, 135));
         list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1490, 84));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "RACINGBIKE", true, "RACINGBIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
 
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "CAR,BIKE,RACINGBIKE", false, "RACINGBIKE", "fastest", false);
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "BIKE,RACINGBIKE", false, "RACINGBIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -254,16 +308,16 @@ public void testMonacoRacingBike()
     public void testKremsBikeRelation()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12489, 155));
-        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3077, 81));
-        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 93));
+        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12491, 159));
+        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3113, 87));
+        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 94));
 
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
                 list, "BIKE", true, "BIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
 
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "CAR,BIKE,MTB", false, "BIKE", "fastest", false);
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "CAR,BIKE", false, "BIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -271,31 +325,31 @@ public void testKremsBikeRelation()
     public void testKremsMountainBikeRelation()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12479, 153));
-        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3164, 91));
-        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 93));
+        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12574, 169));
+        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3101, 94));
+        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 95));
 
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
                 list, "MTB", true, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
 
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "CAR,BIKE,MTB", false, "MTB", "fastest", false);
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "BIKE,MTB", false, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
     List<OneRun> createAndorra()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(42.56819, 1.603231, 42.571034, 1.520662, 17710, 498));
-        list.add(new OneRun(42.529176, 1.571302, 42.571034, 1.520662, 11408, 287));
+        list.add(new OneRun(42.56819, 1.603231, 42.571034, 1.520662, 17708, 524));
+        list.add(new OneRun(42.529176, 1.571302, 42.571034, 1.520662, 11408, 305));
         return list;
     }
 
     @Test
     public void testAndorra()
     {
-        runAlgo(testCollector, "files/andorra.osm.gz", "target/graph-andorra",
+        runAlgo(testCollector, "files/andorra.osm.gz", "target/andorra-gh",
                 createAndorra(), "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -303,7 +357,7 @@ public void testAndorra()
     @Test
     public void testAndorraPbf()
     {
-        runAlgo(testCollector, "files/andorra.osm.pbf", "target/graph-andorra",
+        runAlgo(testCollector, "files/andorra.osm.pbf", "target/andorra-gh",
                 createAndorra(), "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -313,11 +367,11 @@ public void testAndorraFoot()
     {
         List<OneRun> list = createAndorra();
         list.get(0).setDistance(1, 16354);
-        list.get(0).setLocs(1, 633);
+        list.get(0).setLocs(1, 648);
         list.get(1).setDistance(1, 12701);
-        list.get(1).setLocs(1, 427);
+        list.get(1).setLocs(1, 431);
 
-        runAlgo(testCollector, "files/andorra.osm.gz", "target/graph-andorra",
+        runAlgo(testCollector, "files/andorra.osm.gz", "target/andorra-gh",
                 list, "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -331,9 +385,9 @@ public void testCampoGrande()
         //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=- 
         //   | bzip2 > campo-grande.extracted.osm.bz2
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25515, 267));
-        list.add(new OneRun(-20.43, -54.54, -20.537, -54.674, 18009, 234));
-        runAlgo(testCollector, "files/campo-grande.osm.gz", "target/graph-campo-grande", list,
+        list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25516, 271));
+        list.add(new OneRun(-20.43, -54.54, -20.537, -54.674, 18009, 237));
+        runAlgo(testCollector, "files/campo-grande.osm.gz", "target/campo-grande-gh", list,
                 "CAR", false, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
@@ -343,32 +397,62 @@ public void testMonacoVia()
     {
         OneRun oneRun = new OneRun();
         oneRun.add(43.730729, 7.42135, 0, 0);
-        oneRun.add(43.727697, 7.419199, 2581, 102);
-        oneRun.add(43.726387, 7.4, 3001, 89);
+        oneRun.add(43.727697, 7.419199, 2581, 110);
+        oneRun.add(43.726387, 7.4, 3001, 90);
 
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(oneRun);
 
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 list, "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
-    void runAlgo( TestAlgoCollector testCollector, String osmFile,
+    @Test
+    public void testHarsdorf()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // choose Unterloher Weg and the following residential + cycleway
+        list.add(new OneRun(50.004333, 11.600254, 50.044449, 11.543434, 6931, 184));
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike", true, "bike", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testNeudrossenfeld()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // choose cycleway (Dreschenauer Strae)
+        list.add(new OneRun(49.987132, 11.510496, 50.018839, 11.505024, 3985, 106));
+
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike", true, "bike", "fastest", true);
+
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike2", true, "bike2", "fastest", true);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    /**
+     * @param testAlsoCH if true also the CH algorithms will be tested which needs preparation and
+     * takes a bit longer
+     */
+    Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean ch, String vehicle, String weightCalcStr, boolean is3D )
+            boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
-        AlgorithmPreparation tmpPrepare = null;
+        AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
         try
         {
             Helper.removeDir(new File(graphFile));
             GraphHopper hopper = new GraphHopper().
-                    setInMemory(true).
+                    setStoreOnFlush(true).
                     // avoid that path.getDistance is too different to path.getPoint.calcDistance
-                    setWayPointMaxDistance(0.1).
+                    setWayPointMaxDistance(0).
                     setOSMFile(osmFile).
-                    disableCHShortcuts().
+                    setCHEnable(false).
                     setGraphHopperLocation(graphFile).
                     setEncodingManager(new EncodingManager(importVehicles));
             if (is3D)
@@ -376,32 +460,34 @@ void runAlgo( TestAlgoCollector testCollector, String osmFile,
 
             hopper.importOrLoad();
 
+            TraversalMode tMode = importVehicles.toLowerCase().contains("turncosts=true")
+                    ? TraversalMode.EDGE_BASED_1DIR : TraversalMode.NODE_BASED;
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
-            Weighting weighting = new ShortestWeighting();
-            if ("fastest".equalsIgnoreCase(weightCalcStr))
-                weighting = new FastestWeighting(encoder);
+            Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                    createAlgos(hopper.getGraph(), hopper.getLocationIndex(), encoder, ch, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-            for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+            for (AlgoHelperEntry entry : prepares)
             {
-                tmpPrepare = entry.getKey();
-                LocationIndex idx = entry.getValue();
+                algoEntry = entry;
+                LocationIndex idx = entry.getIdx();
                 for (OneRun oneRun : forEveryAlgo)
                 {
                     tmpOneRun = oneRun;
                     List<QueryResult> list = oneRun.getList(idx, edgeFilter);
-                    testCollector.assertDistance(tmpPrepare, list, oneRun);
+                    testCollector.assertDistance(algoEntry, list, oneRun);
                 }
             }
+
+            return hopper.getGraph();
         } catch (Exception ex)
         {
-            if (tmpPrepare == null)
-                throw new RuntimeException("cannot handle file " + osmFile, ex);
+            if (algoEntry == null)
+                throw new RuntimeException("cannot handle file " + osmFile + ", " + ex.getMessage(), ex);
 
-            throw new RuntimeException("cannot handle " + tmpPrepare.toString() + ", for " + tmpOneRun
-                    + ", file " + osmFile, ex);
+            throw new RuntimeException("cannot handle " + algoEntry.toString() + ", for " + tmpOneRun
+                    + ", file " + osmFile + ", " + ex.getMessage(), ex);
         } finally
         {
             // Helper.removeDir(new File(graphFile));
@@ -420,18 +506,17 @@ public void testPerformance() throws IOException
         Graph graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile), 8 * (1 << 10))).read();
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                createAlgos(graph, null, encoder, false, new ShortestWeighting(), eManager);
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+                new ShortestWeighting(), eManager);
+        for (AlgoHelperEntry entry : prepares)
         {
-            AlgorithmPreparation prepare = entry.getKey();
             StopWatch sw = new StopWatch();
             for (int i = 0; i < N; i++)
             {
                 int node1 = Math.abs(rand.nextInt(graph.getNodes()));
                 int node2 = Math.abs(rand.nextInt(graph.getNodes()));
-                RoutingAlgorithm d = prepare.createAlgo();
+                RoutingAlgorithm d = entry.createAlgo(graph);
                 if (i >= noJvmWarming)
                     sw.start();
 
@@ -444,7 +529,7 @@ public void testPerformance() throws IOException
             }
 
             float perRun = sw.stop().getSeconds() / ((float) (N - noJvmWarming));
-            System.out.println("# " + getClass().getSimpleName() + " " + prepare.createAlgo().getName()
+            System.out.println("# " + getClass().getSimpleName() + " " + entry
                     + ":" + sw.stop().getSeconds() + ", per run:" + perRun);
             assertTrue("speed to low!? " + perRun + " per run", perRun < 0.08);
         }
@@ -454,15 +539,16 @@ public void testPerformance() throws IOException
     public void testMonacoParallel() throws IOException
     {
         System.out.println("testMonacoParallel takes a bit time...");
-        String graphFile = "target/graph-monaco";
+        String graphFile = "target/monaco-gh";
         Helper.removeDir(new File(graphFile));
         final EncodingManager encodingManager = new EncodingManager("CAR");
         GraphHopper hopper = new GraphHopper().
-                setInMemory(true).
+                setStoreOnFlush(true).
                 setEncodingManager(encodingManager).
-                disableCHShortcuts().
-                setWayPointMaxDistance(0.1).
-                setOSMFile("files/monaco.osm.gz").setGraphHopperLocation(graphFile).
+                setCHEnable(false).
+                setWayPointMaxDistance(0).
+                setOSMFile("files/monaco.osm.gz").
+                setGraphHopperLocation(graphFile).
                 importOrLoad();
         final Graph g = hopper.getGraph();
         final LocationIndex idx = hopper.getLocationIndex();
@@ -470,23 +556,22 @@ public void testMonacoParallel() throws IOException
         List<Thread> threads = new ArrayList<Thread>();
         final AtomicInteger integ = new AtomicInteger(0);
         int MAX = 100;
-        FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
+        final FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
 
         // testing if algorithms are independent. should be. so test only two algorithms. 
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
-        Weighting weighting = new ShortestWeighting();
+        final Weighting weighting = new ShortestWeighting();
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
         for (int no = 0; no < MAX; no++)
         {
             for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++)
             {
-                RoutingAlgorithm[] algos = new RoutingAlgorithm[]
+                String[] algos = new String[]
                 {
-                    new AStar(g, carEncoder, weighting),
-                    new DijkstraBidirectionRef(g, carEncoder, weighting)
+                    "astar", "dijkstrabi"
                 };
-                for (final RoutingAlgorithm algo : algos)
+                for (final String algoStr : algos)
                 {
                     // an algorithm is not thread safe! reuse via clear() is ONLY appropriated if used from same thread!
                     final int instanceIndex = instanceNo;
@@ -496,14 +581,9 @@ public void testMonacoParallel() throws IOException
                         public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
-                            testCollector.assertDistance(new NoOpAlgorithmPreparation()
-                            {
-                                @Override
-                                public RoutingAlgorithm createAlgo()
-                                {
-                                    return algo;
-                                }
-                            }, oneRun.getList(idx, filter), oneRun);
+                            AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
+                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                                    oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
                     };
@@ -528,4 +608,47 @@ public RoutingAlgorithm createAlgo()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
         hopper.close();
     }
+
+    public static Collection<AlgoHelperEntry> createAlgos( Graph g,
+            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+    {
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        // later: include dijkstraOneToMany        
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+
+        if (withCh)
+        {
+            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
+                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(graphCH, encoder, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
+
+            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
+        }
+        return prepare;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 7a2cd5e0cf..b086da8b50 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -17,14 +17,13 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.Path;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
@@ -43,7 +42,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
@@ -53,7 +52,7 @@ public Graph getMatrixGraph()
         {
             LevelGraph lg = (LevelGraph) createGraph(false);
             getMatrixAlikeGraph().copyTo(lg);
-            prepareGraph(lg);
+            createFactory(lg, defaultOpts);
             preparedMatrixGraph = lg;
         }
         return preparedMatrixGraph;
@@ -66,10 +65,17 @@ protected LevelGraph createGraph( EncodingManager em, boolean is3D )
     }
 
     @Override
-    public PrepareContractionHierarchies prepareGraph( Graph g, FlagEncoder encoder, Weighting w )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(encoder, w).setGraph(g);
-        // hack: prepare matrixgraph only once
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
+    {
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies((LevelGraph) g,
+                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        // hack: prepare matrixGraph only once
         if (g != preparedMatrixGraph)
             ch.doWork();
 
@@ -114,8 +120,10 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        Path p = new PrepareContractionHierarchies(encoder, new ShortestWeighting()).
-                setGraph(g2).createAlgo().calcPath(0, 7);
+        ShortestWeighting weighting = new ShortestWeighting();
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
+        Path p = new PrepareContractionHierarchies(g2, encoder, weighting, TraversalMode.NODE_BASED).
+                createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
         assertEquals(1064, p.getMillis());
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 1121b46942..2f58c974ec 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -17,10 +17,7 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
@@ -38,9 +35,10 @@
  */
 public class PrepareContractionHierarchiesTest
 {
-    private final Weighting weighting = new ShortestWeighting();
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+    private final Weighting weighting = new ShortestWeighting();
+    private TraversalMode tMode = TraversalMode.NODE_BASED;
 
     LevelGraph createGraph()
     {
@@ -71,10 +69,11 @@ LevelGraph createExampleGraph()
     public void testShortestPathSkipNode()
     {
         LevelGraph g = createExampleGraph();
-        double normalDist = new Dijkstra(g, carEncoder, weighting).calcPath(4, 2).getDistance();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
+        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -86,14 +85,15 @@ public void testShortestPathSkipNode()
     public void testShortestPathSkipNode2()
     {
         LevelGraph g = createExampleGraph();
-        double normalDist = new Dijkstra(g, carEncoder, weighting).calcPath(4, 2).getDistance();
+        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -101,9 +101,10 @@ public void testShortestPathSkipNode2()
     public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
         algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
@@ -112,20 +113,20 @@ public void testShortestPathLimit()
     public void testAddShortcuts()
     {
         LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getMaxId());
+        assertEquals(old + 1, g.getAllEdges().getCount());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
         LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 10, g.getAllEdges().getMaxId());
+        assertEquals(old + 10, g.getAllEdges().getCount());
     }
 
     @Test
@@ -139,10 +140,10 @@ public void testDirectedGraph()
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -154,11 +155,11 @@ public void testDirectedGraph2()
         LevelGraph g = createGraph();
         initDirected2(g);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -187,7 +188,7 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
@@ -204,11 +205,12 @@ public void testDirectedGraph3()
 
         // both dirs
         assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
+        assertTrue(sc1.toString(), carEncoder.isBool(sc1.flags, FlagEncoder.K_FORWARD)
+                && carEncoder.isBool(sc1.flags, FlagEncoder.K_BACKWARD));
 
         // directed
         assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
-        assertTrue(sc2.toString(), carEncoder.isForward(sc2.flags));
+        assertTrue(sc2.toString(), carEncoder.isBool(sc2.flags, FlagEncoder.K_FORWARD));
 
         assertEquals(sc1.toString(), 4, sc1.weight, 1e-4);
         assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
@@ -271,11 +273,11 @@ public void testRoundaboutUnpacking()
     {
         LevelGraph g = createGraph();
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 23, g.getAllEdges().getMaxId());
-        RoutingAlgorithm algo = prepare.createAlgo();
+        assertEquals(old + 22, g.getAllEdges().getCount());
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -296,7 +298,7 @@ public void testFindShortcuts_Roundabout()
         g.setLevel(7, 7);
         g.setLevel(8, 8);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
@@ -333,23 +335,24 @@ void initUnpackingGraph( LevelGraphStorage g, Weighting w )
 
         int tmp = iterTmp1.getEdge();
         EdgeSkipIterState sc1 = g.shortcut(0, 2);
-        sc1.setWeight(w.calcWeight(iterTmp1, false) + w.calcWeight(iter2, false)).setDistance(2 * dist).setFlags(oneDirFlags);
+        int x = EdgeIterator.NO_EDGE;
+        sc1.setWeight(w.calcWeight(iterTmp1, false, x) + w.calcWeight(iter2, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
         sc1.setSkippedEdges(tmp, iter2.getEdge());
         tmp = sc1.getEdge();
         EdgeSkipIterState sc2 = g.shortcut(0, 3);
-        sc2.setWeight(w.calcWeight(sc1, false) + w.calcWeight(iter3, false)).setDistance(3 * dist).setFlags(oneDirFlags);
+        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter3, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
         sc2.setSkippedEdges(tmp, iter3.getEdge());
         tmp = sc2.getEdge();
         sc1 = g.shortcut(0, 4);
-        sc1.setWeight(w.calcWeight(sc2, false) + w.calcWeight(iter4, false)).setDistance(4).setFlags(oneDirFlags);
+        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter4, false, x)).setDistance(4).setFlags(oneDirFlags);
         sc1.setSkippedEdges(tmp, iter4.getEdge());
         tmp = sc1.getEdge();
         sc2 = g.shortcut(0, 5);
-        sc2.setWeight(w.calcWeight(sc1, false) + w.calcWeight(iter5, false)).setDistance(5).setFlags(oneDirFlags);
+        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter5, false, x)).setDistance(5).setFlags(oneDirFlags);
         sc2.setSkippedEdges(tmp, iter5.getEdge());
         tmp = sc2.getEdge();
         sc1 = g.shortcut(0, 6);
-        sc1.setWeight(w.calcWeight(sc2, false) + w.calcWeight(iter6, false)).setDistance(6).setFlags(oneDirFlags);
+        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter6, false, x)).setDistance(6).setFlags(oneDirFlags);
         sc1.setSkippedEdges(tmp, iter6.getEdge());
         g.setLevel(0, 10);
         g.setLevel(6, 9);
@@ -366,8 +369,8 @@ public void testUnpackingOrder()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
         initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -380,8 +383,8 @@ public void testUnpackingOrder_Fastest()
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, w).setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -398,11 +401,35 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
 
+    @Test
+    public void testBug178()
+    {
+        // 5--------6__
+        // |        |  \
+        // 0-1->-2--3--4
+        //   \-<-/
+        //
+        LevelGraph g = createGraph();
+        g.edge(1, 2, 1, false);
+        g.edge(2, 1, 1, false);
+
+        g.edge(5, 0, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(0, 1, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(6, 3, 1, true);
+
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.doWork();
+        assertEquals(2, prepare.getShortcuts());
+    }
+
     // 0-1-2-3-4
     // |     / |
     // |    8  |
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 8d5c0e0bfc..5485a7a5bd 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -17,17 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.TranslationMap;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import com.graphhopper.util.Translation;
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
-import java.util.HashMap;
 import java.util.Locale;
-import java.util.Map;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -37,7 +33,7 @@
  */
 public abstract class AbstractBikeFlagEncoderTester
 {
-    protected BikeFlagCommonEncoder encoder;
+    protected BikeCommonFlagEncoder encoder;
 
     @Before
     public void setUp()
@@ -45,24 +41,36 @@ public void setUp()
         encoder = createBikeEncoder();
     }
 
-    abstract BikeFlagCommonEncoder createBikeEncoder();
+    protected abstract BikeCommonFlagEncoder createBikeEncoder();
 
-    public double getEncodedDecodedSpeed( OSMWay way )
+    protected void assertPriority( int expectedPrio, OSMWay way )
+    {
+        assertPriority(expectedPrio, way, 0);
+    }
+
+    protected void assertPriority( int expectedPrio, OSMWay way, long relationFlags )
+    {
+        assertEquals(expectedPrio, encoder.handlePriority(way, (int) encoder.relationCodeEncoder.getValue(relationFlags)));
+    }
+
+    protected double getSpeedFromFlags( OSMWay way )
     {
         long allowed = encoder.acceptBit;
         long flags = encoder.handleWayTags(way, allowed, 0);
         return encoder.getSpeed(flags);
     }
 
-    public String encodeDecodeWayType( String name, OSMWay way )
+    protected String getWayTypeFromFlags( OSMWay way )
     {
-        long allowed = encoder.acceptBit;
-        long flags = encoder.handleWayTags(way, allowed, 0);
-        int pavement = encoder.getPavementType(flags);
-        int wayType = encoder.getWayType(flags);
+        return getWayTypeFromFlags(way, 0);
+    }
 
-        TranslationMap.Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
-        return InstructionList.getWayName(name, pavement, wayType, enMap);
+    protected String getWayTypeFromFlags( OSMWay way, long relationFlags )
+    {
+        long allowed = encoder.acceptBit;
+        long flags = encoder.handleWayTags(way, allowed, relationFlags);
+        Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
+        return encoder.getAnnotation(flags, enMap).getMessage();
     }
 
     @Test
@@ -73,6 +81,10 @@ public void testAccess()
         way.setTag("highway", "motorway");
         assertFalse(encoder.acceptWay(way) > 0);
 
+        way.setTag("highway", "motorway");
+        way.setTag("bicycle", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
         way.setTag("highway", "footway");
         assertTrue(encoder.acceptWay(way) > 0);
 
@@ -150,6 +162,12 @@ public void testAccess()
         way.setTag("route", "ferry");
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "cycleway");
+        way.setTag("cycleway", "track");
+        way.setTag("railway", "abandoned");
+        assertTrue(encoder.acceptWay(way) > 0);
     }
 
     @Test
@@ -182,6 +200,38 @@ public void testTramStations()
         assertEquals(0, encoder.acceptWay(way));
     }
 
+    @Test
+    public void testAvoidTunnel()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "residential");
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "secondary");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), osmWay);
+    }
+
+    @Test
+    public void testTram()
+    {
+        OSMWay way = new OSMWay(1);
+        // very dangerous
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "tram");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), way);
+
+        // should be safe now
+        way.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), way);
+    }
+
     @Test
     public void testHandleCommonWayTags()
     {
@@ -189,50 +239,170 @@ public void testHandleCommonWayTags()
         String wayType;
 
         way.setTag("highway", "steps");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
-
-        way.setTag("highway", "steps");
-        wayType = encodeDecodeWayType("Famous steps", way);
-        assertEquals("Famous steps, pushing section", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
         way.setTag("highway", "footway");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
         way.setTag("highway", "footway");
         way.setTag("surface", "pebblestone");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
         way.setTag("highway", "residential");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("road", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
+        assertPriority(PREFER.getValue(), way);
 
+        way.clearTags();
         way.setTag("highway", "cycleway");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway", wayType);
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.setTag("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway, unpaved", wayType);
 
         way.setTag("surface", "asphalt");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway", wayType);
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.setTag("highway", "footway");
         way.setTag("bicycle", "yes");
         way.setTag("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
+
+        way.setTag("bicycle", "designated");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("bicycle", "yes");
         way.setTag("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("cycleway, unpaved", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
     }
 
+    @Test
+    public void testService()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        assertEquals(14, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.setTag("service", "parking_aisle");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+    }
+
+    @Test
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("sac_scale", "alpine_hiking");
+        assertTrue(encoder.acceptWay(way) == 0);
+    }
+
+    @Test
+    public void testReduceToMaxSpeed()
+    {
+        OSMWay way = new OSMWay(12);
+        way.setTag("maxspeed", "90");
+        assertEquals(12, encoder.applyMaxSpeed(way, 12, false), 1e-2);
+    }
+
+    @Test
+    public void testMaxAndMinSpeed()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "tertiary");
+        assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("highway", "tertiary");
+        osmWay.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(REACH_DEST.getValue(), osmWay);
+    }
+
+    @Test
+    public void testHandleWayTagsCallsHandlePriority()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "cycleway");
+        long encoded = encoder.handleWayTags(osmWay, encoder.acceptBit, 0);
+        assertEquals((double) VERY_NICE.getValue() / BEST.getValue(), encoder.getDouble(encoded, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testAvoidMotorway()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("bicycle", "yes");
+        assertPriority(REACH_DEST.getValue(), osmWay);
+    }
+
+    @Test
+    public void testPriority()
+    {
+        long flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.BEST.getValue());
+        assertEquals(1, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+
+        flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.AVOID_IF_POSSIBLE.getValue());
+        assertEquals(3d / 7d, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testBarrierAccess()
+    {
+        // by default allow access through the gate for bike & foot!
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node.setTag("bicycle", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "yes");
+        node.setTag("bicycle", "no");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("foot", "yes");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("bicycle", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index 33d838e9c8..2fc14399fb 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -51,4 +51,11 @@ public void testParseDuration()
         assertEquals(60 * 20, AbstractFlagEncoder.parseDuration("0:20:00"));
         assertEquals(60 * 24 * 2 + 60 * 20 + 2, AbstractFlagEncoder.parseDuration("02:20:02"));
     }
+    
+    @Test
+    public void testParseProperties()
+    {
+        assertEquals(10, AbstractFlagEncoder.parseDouble("car|x", "prop", 10), .1);
+        assertEquals(12.2, AbstractFlagEncoder.parseDouble("car|x|prop=12.2", "prop", 10), .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index 2088078bd5..51894b72b3 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -30,7 +30,7 @@
  *
  * @author Peter Karich
  */
-public class Bike2WeightFlagEncoderTest
+public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
 {
     private Graph initExampleGraph( FlagEncoder instance )
     {
@@ -42,6 +42,7 @@ private Graph initExampleGraph( FlagEncoder instance )
         na.setNode(1, 51.1, 12.002, 60);
         EdgeIteratorState edge = gs.edge(0, 1).
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
+        edge.setDistance(100);
 
         edge.setFlags(instance.setReverseSpeed(instance.setProperties(10, true, true), 15));
         return gs;
@@ -58,25 +59,22 @@ public void testApplyWayTags()
 
         long flags = edge.getFlags();
         // decrease speed
-        assertEquals(6, instance.getSpeed(flags), 1e-1);
+        assertEquals(2, instance.getSpeed(flags), 1e-1);
         // increase speed but use maximum speed (calculated was 24)
         assertEquals(18, instance.getReverseSpeed(flags), 1e-1);
     }
-
+        
     @Test
-    public void testSteps()
+    public void testUnchangedForStepsBridgeAndTunnel()
     {
         Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
         Graph graph = initExampleGraph(instance);
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
+        long oldFlags = edge.getFlags();
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "steps");
         instance.applyWayTags(way, edge);
 
-        long flags = edge.getFlags();
-        // steps speed for both directions although upwards is probably harder
-        double stepSpeed = Bike2WeightFlagEncoder.PUSHING_SECTION_SPEED / 2;
-        assertEquals(stepSpeed, instance.getSpeed(flags), 1e-1);
-        assertEquals(stepSpeed, instance.getReverseSpeed(flags), 1e-1);
+        assertEquals(oldFlags, edge.getFlags());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index a94b0af218..ebe46f48cc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -19,22 +19,21 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
 
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
+ * @author ratrun
  */
 public class BikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB,RACINGBIKE").getEncoder("BIKE");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,MTB").getEncoder("BIKE");
     }
 
     @Test
@@ -45,41 +44,45 @@ public void testGetSpeed()
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
         assertEquals(18, encoder.getSpeed(way));
+        assertPriority(REACH_DEST.getValue(), way);
 
-        way.setTag("highway", "residential");
-        assertEquals(20, encoder.getSpeed(way));
-        // Test pushing section speeds
         way.setTag("highway", "footway");
         assertEquals(4, encoder.getSpeed(way));
-        way.setTag("highway", "track");
-        assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
-        way.setTag("highway", "steps");
-        assertEquals(2, encoder.getSpeed(way));
+        way.setTag("highway", "track");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
-        way.setTag("highway", "service");
-        assertEquals(20, encoder.getSpeed(way));
-        way.setTag("service", "parking_aisle");
-        assertEquals(15, encoder.getSpeed(way));
-        way.clearTags();
+        way.setTag("tracktype", "grade1");
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
-        // test speed for allowed pushing section types
         way.setTag("highway", "track");
-        way.setTag("bicycle", "yes");
-        assertEquals(20, encoder.getSpeed(way));
+        way.setTag("tracktype", "grade2");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
+        // test speed for allowed get off the bike types
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
-        way.setTag("tracktype", "grade3");
         assertEquals(12, encoder.getSpeed(way));
 
+        way.clearTags();
+        way.setTag("highway", "steps");
+        assertEquals(2, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "track");
         way.setTag("surface", "paved");
-        assertEquals(20, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "ground");
         assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "track");
@@ -87,12 +90,18 @@ public void testGetSpeed()
         way.setTag("surface", "fine_gravel");
         assertEquals(18, encoder.getSpeed(way));
 
-        way.clearTags();
-        way.setTag("highway", "track");
-        way.setTag("bicycle", "yes");
         way.setTag("surface", "unknown_surface");
         assertEquals(4, encoder.getSpeed(way));
 
+        way.clearTags();
+        way.setTag("highway", "residential");
+        way.setTag("surface", "asphalt");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "motorway");
+        way.setTag("bicycle", "yes");
+        assertEquals(18, encoder.getSpeed(way));
     }
 
     @Test
@@ -100,182 +109,205 @@ public void testHandleWayTags()
     {
         OSMWay way = new OSMWay(1);
         String wayType;
-
         way.setTag("highway", "track");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "concrete");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("foot", "yes");
         way.setTag("surface", "paved");
         way.setTag("tracktype", "grade1");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
 
-        way.clearTags();
-        way.setTag("highway", "track");
-        way.setTag("foot", "yes");
-        way.setTag("surface", "paved");
         way.setTag("tracktype", "grade2");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
-
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
     }
 
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
         OSMWay osmWay = new OSMWay(1);
-        osmWay.setTag("highway", "track");
+        osmWay.setTag("highway", "road");
         long allowed = encoder.acceptBit;
 
         OSMRelation osmRel = new OSMRelation(1);
-
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         // unchanged
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(16, encoder.getSpeed(flags), 1e-1);
-        assertEquals(1, encoder.getWayType(flags));
-        assertEquals(1, encoder.getPavementType(flags));
+        assertEquals(12, encoder.getSpeed(flags), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay, relFlags);
 
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(20, encoder.getSpeed(flags), 1e-1);
-        assertEquals(1, encoder.getWayType(flags));
-        assertEquals(1, encoder.getPavementType(flags));
+        assertEquals(12, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
 
         // relation code is VERY_NICE
         osmRel.setTag("network", "rcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(24, encoder.getSpeed(flags), 1e-1);
+        assertPriority(VERY_NICE.getValue(), osmWay, relFlags);
 
-        // relation code is OUTSTANDING_NICE
+        // relation code is BEST
         osmRel.setTag("network", "ncn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags), 1e-1);
+        assertPriority(BEST.getValue(), osmWay, relFlags);
 
-        // PREFER relation, but tertiary road
-        // => no pushing section but road wayTypeCode and faster
+        // PREFER relation, but tertiary road => no get off the bike but road wayTypeCode and faster
         osmWay.clearTags();
         osmWay.setTag("highway", "tertiary");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
+
+        // A footway is not of waytype get off the bike in case that it is part of a cycle route
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "footway");
+        osmWay.setTag("surface", "grass");
+
+        // First tests without a cycle route relation, this is a get off the bike
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        String wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", wayType);
 
+        // now as part of a cycle route relation
+        osmRel.setTag("type", "route");
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(22, encoder.getSpeed(flags), 1e-1);
-        assertEquals(0, encoder.getWayType(flags));
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("way, unpaved", wayType);
 
-        // test max and min speed
-        final AtomicInteger fakeSpeed = new AtomicInteger(40);
-        BikeFlagEncoder fakeEncoder = new BikeFlagEncoder()
-        {
-            @Override
-            int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
-            {
-                return fakeSpeed.get();
-            }
-        };
-        // call necessary register
-        new EncodingManager(fakeEncoder);
-        allowed = fakeEncoder.acceptBit;
-
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(30, fakeEncoder.getSpeed(flags), 1e-1);
-
-        fakeSpeed.set(-2);
-        try
-        {
-            flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-            assertTrue(false);
-        } catch (IllegalArgumentException ex)
-        {
-        }
+        // steps are still shown as get off the bike
+        osmWay.clearTags();
+        osmWay.setTag("highway", "steps");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike", wayType);
+    }
 
-        fakeSpeed.set(0);
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(0, fakeEncoder.getSpeed(flags), 1e-1);
+    @Test
+    public void testUnchangedRelationShouldNotInfluencePriority()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "secondary");
 
+        OSMRelation osmRel = new OSMRelation(1);
+        osmRel.setTag("description", "something");
+        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        assertPriority(REACH_DEST.getValue(), osmWay, relFlags);
     }
 
     @Test
-    public void testTurnFlagEncoding_noCosts()
+    public void testCalcPriority()
     {
-        encoder.defineTurnBits(0, 0, 0);
+        long allowed = encoder.acceptBit;
+        OSMWay osmWay = new OSMWay(1);
+        OSMRelation osmRel = new OSMRelation(1);
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "icn");
+        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals((double) BEST.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
 
+        // important: UNCHANGED should not get 0 priority!
+        osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "somethingelse");
+        flags = encoder.handleWayTags(osmWay, allowed, 0);
+        assertEquals((double) UNCHANGED.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testMaxSpeed()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("maxspeed", "10");
+        long allowed = encoder.acceptWay(way);
+        long encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+    }
+
+    @Test
+    public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts()
+    {
+        // default is disabled turn costs and no restrictions
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
 
         long flags_r20 = encoder.getTurnFlags(true, 20);
         long flags_20 = encoder.getTurnFlags(false, 20);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
+        assertEquals(0, encoder.getTurnCost(flags_r0), .1);
+        assertEquals(0, encoder.getTurnCost(flags_0), .1);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r20));
-        assertEquals(0, encoder.getTurnCosts(flags_20));
+        assertEquals(0, encoder.getTurnCost(flags_r20), .1);
+        assertEquals(0, encoder.getTurnCost(flags_20), .1);
 
-        assertTrue(encoder.isTurnRestricted(flags_r0));
+        assertFalse(encoder.isTurnRestricted(flags_r0));
         assertFalse(encoder.isTurnRestricted(flags_0));
 
-        assertTrue(encoder.isTurnRestricted(flags_r20));
+        assertFalse(encoder.isTurnRestricted(flags_r20));
         assertFalse(encoder.isTurnRestricted(flags_20));
     }
 
     @Test
     public void testTurnFlagEncoding_withCosts()
     {
-        //arbitrary shift, 7 turn cost bits: [0,127]
-        encoder.defineTurnBits(0, 2, 7);
+        encoder = new BikeFlagEncoder(4, 2, 127);
+        new EncodingManager(encoder);
 
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
-
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
-
-        long flags_r220 = encoder.getTurnFlags(true, 220);
-        long flags_220 = encoder.getTurnFlags(false, 220);
-
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
-
-        assertEquals(20, encoder.getTurnCosts(flags_r20));
-        assertEquals(20, encoder.getTurnCosts(flags_20));
-
-        assertEquals(127, encoder.getTurnCosts(flags_r220));
-        assertEquals(127, encoder.getTurnCosts(flags_220));
-
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r0)));
+        assertEquals(0, encoder.getTurnCost(flags_0), .1);
         assertTrue(encoder.isTurnRestricted(flags_r0));
         assertFalse(encoder.isTurnRestricted(flags_0));
 
+        long flags_r20 = encoder.getTurnFlags(true, 0);
+        long flags_20 = encoder.getTurnFlags(false, 20);
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r20)));
+        assertEquals(20, encoder.getTurnCost(flags_20), .1);
         assertTrue(encoder.isTurnRestricted(flags_r20));
         assertFalse(encoder.isTurnRestricted(flags_20));
 
+        long flags_r220 = encoder.getTurnFlags(true, 0);
+        try
+        {
+            encoder.getTurnFlags(false, 220);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+        long flags_126 = encoder.getTurnFlags(false, 126);
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r220)));
+
+        assertEquals(126, encoder.getTurnCost(flags_126), .1);
         assertTrue(encoder.isTurnRestricted(flags_r220));
-        assertFalse(encoder.isTurnRestricted(flags_220));
+        assertFalse(encoder.isTurnRestricted(flags_126));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 5af8a86c52..c4d697d037 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -43,9 +43,30 @@ public void testAccess()
 
         way.clearTags();
         way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
         way.setTag("motorcar", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
+        // for now allow grade1+2+3 for every country, see #253
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade2");        
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("tracktype", "grade4");        
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "delivery");
+        assertFalse(encoder.acceptWay(way) > 0);
+
         way.clearTags();
         way.setTag("highway", "unclassified");
         way.setTag("ford", "yes");
@@ -56,6 +77,7 @@ public void testAccess()
         way.clearTags();
         way.setTag("route", "ferry");
         assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
         way.setTag("motorcar", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
@@ -63,29 +85,41 @@ public void testAccess()
         way.setTag("route", "ferry");
         way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
+        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
 
         way.clearTags();
         way.setTag("highway", "primary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
         way.setTag("oneway", "yes");
         flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
     }
 
     @Test
     public void testSetAccess()
     {
-        assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
-        assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
+        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(encoder.setProperties(0, true, true), FlagEncoder.K_BACKWARD));
+
+        assertTrue(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(encoder.setProperties(0, true, false), FlagEncoder.K_BACKWARD));
 
-        assertTrue(encoder.isForward(encoder.setProperties(0, true, false)));
-        assertFalse(encoder.isBackward(encoder.setProperties(0, true, false)));
+        assertFalse(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(encoder.setProperties(0, false, true), FlagEncoder.K_BACKWARD));
 
-        assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
-        assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
+        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(encoder.flagsDefault(true, true), FlagEncoder.K_BACKWARD));
+
+        assertTrue(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(encoder.flagsDefault(true, false), FlagEncoder.K_BACKWARD));
+
+        long flags = encoder.flagsDefault(true, true);
+        // disable access
+        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(encoder.setAccess(flags, false, false), FlagEncoder.K_BACKWARD));
     }
 
     @Test
@@ -104,13 +138,13 @@ public void testMaxSpeed()
         way.setTag("maxspeed:forward", "20");
         encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertEquals(10, encoder.getSpeed(encoded), 1e-1);
-        
+
         way = new OSMWay(1);
         way.setTag("highway", "primary");
         way.setTag("maxspeed:forward", "20");
         encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
-        
+
         way = new OSMWay(1);
         way.setTag("highway", "primary");
         way.setTag("maxspeed:backward", "20");
@@ -149,13 +183,6 @@ public void testSpeed()
         encoded = encoder.handleWayTags(way, allowed, 0);
         assertEquals(20, encoder.getSpeed(encoded), 1e-1);
 
-        way.clearTags();
-        way.setTag("highway", "track");
-        way.setTag("tracktype", "grade5");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(5, encoder.getSpeed(encoded), 1e-1);
-
         try
         {
             encoder.setSpeed(0, -1);
@@ -171,6 +198,34 @@ public void testSetSpeed()
         assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
     }
 
+    @Test
+    public void testRoundabout()
+    {
+        long flags = encoder.setAccess(0, true, true);
+        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+
+        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
+        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_BACKWARD));
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.setTag("junction", "roundabout");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_FORWARD));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
     @Test
     public void testRailway()
     {
@@ -178,13 +233,30 @@ public void testRailway()
         way.setTag("highway", "secondary");
         way.setTag("railway", "rail");
         // disallow rail
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("railway", "abandoned");
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        // on disallowed highway, railway is allowed, sometimes incorrectly mapped
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);        
+        
+        // this is fully okay as sometimes old rails are on the road
+        way.setTag("highway", "primary");
+        way.setTag("railway", "historic");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
+        assertTrue(encoder.acceptWay(way) == 0);
 
         way = new OSMWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "tram");
         // but allow tram to be on the same way
-        assertNotSame(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
 
         way = new OSMWay(1);
         way.setTag("route", "shuttle_train");
@@ -193,32 +265,22 @@ public void testRailway()
         way.setTag("duration", "35");
         way.setTag("estimated_distance", 50000);
         // accept
-        assertNotSame(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
         // calculate speed from estimated_distance and duration
         assertEquals(60, encoder.getSpeed(encoder.handleFerryTags(way, 20, 30, 40)), 1e-1);
     }
 
-    @Test
-    public void testBasics()
-    {
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
-        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
-
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
-        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
-    }
-
     @Test
     public void testSwapDir()
     {
         long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
-        assertTrue(encoder.isForward(swappedFlags));
-        assertTrue(encoder.isBackward(swappedFlags));
+        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
 
         swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
 
-        assertFalse(encoder.isForward(swappedFlags));
-        assertTrue(encoder.isBackward(swappedFlags));
+        assertFalse(encoder.isBool(swappedFlags, FlagEncoder.K_FORWARD));
+        assertTrue(encoder.isBool(swappedFlags, FlagEncoder.K_BACKWARD));
 
         assertEquals(0, encoder.reverseFlags(0));
     }
@@ -251,70 +313,79 @@ public void testBarrierAccess()
         node.setTag("motorcar", "yes");
         // no barrier!
         assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "bollard");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        // ignore other access tags for absolute barriers!
+        node.setTag("motorcar", "yes");
+        // still barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
     }
 
     @Test
     public void testTurnFlagEncoding_noCosts()
     {
-        encoder.defineTurnBits(0, 0, 0);
+        FlagEncoder tmpEnc = new CarFlagEncoder(8, 5, 0);
+        EncodingManager em = new EncodingManager(tmpEnc);
 
-        long flags_r0 = encoder.getTurnFlags(true, 0);
-        long flags_0 = encoder.getTurnFlags(false, 0);
+        long flags_r0 = tmpEnc.getTurnFlags(true, 0);
+        long flags_0 = tmpEnc.getTurnFlags(false, 0);
 
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
+        long flags_r20 = tmpEnc.getTurnFlags(true, 0);
+        long flags_20 = tmpEnc.getTurnFlags(false, 20);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
+        assertEquals(0, tmpEnc.getTurnCost(flags_r0), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_0), 1e-1);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r20));
-        assertEquals(0, encoder.getTurnCosts(flags_20));
+        assertEquals(0, tmpEnc.getTurnCost(flags_r20), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_20), 1e-1);
 
-        assertTrue(encoder.isTurnRestricted(flags_r0));
-        assertFalse(encoder.isTurnRestricted(flags_0));
+        assertFalse(tmpEnc.isTurnRestricted(flags_r0));
+        assertFalse(tmpEnc.isTurnRestricted(flags_0));
 
-        assertTrue(encoder.isTurnRestricted(flags_r20));
-        assertFalse(encoder.isTurnRestricted(flags_20));
+        assertFalse(tmpEnc.isTurnRestricted(flags_r20));
+        assertFalse(tmpEnc.isTurnRestricted(flags_20));
     }
 
     @Test
     public void testTurnFlagEncoding_withCosts()
     {
-        //arbitrary shift, 7 turn cost bits: [0,127]
-        encoder.defineTurnBits(0, 2, 7);
-
-        long flags_r0 = encoder.getTurnFlags(true, 0);
-        long flags_0 = encoder.getTurnFlags(false, 0);
-
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
-
-        long flags_r220 = encoder.getTurnFlags(true, 220);
-        long flags_220 = encoder.getTurnFlags(false, 220);
-
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
-
-        assertEquals(20, encoder.getTurnCosts(flags_r20));
-        assertEquals(20, encoder.getTurnCosts(flags_20));
-
-        assertEquals(127, encoder.getTurnCosts(flags_r220)); // max costs is 2^7-1 = 127
-        assertEquals(127, encoder.getTurnCosts(flags_220));
-
-        assertTrue(encoder.isTurnRestricted(flags_r0));
-        assertFalse(encoder.isTurnRestricted(flags_0));
-
-        assertTrue(encoder.isTurnRestricted(flags_r20));
-        assertFalse(encoder.isTurnRestricted(flags_20));
-
-        assertTrue(encoder.isTurnRestricted(flags_r220));
-        assertFalse(encoder.isTurnRestricted(flags_220));
+        FlagEncoder tmpEncoder = new CarFlagEncoder(8, 5, 127);
+        EncodingManager em = new EncodingManager(tmpEncoder);
+
+        long flags_r0 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_0 = tmpEncoder.getTurnFlags(false, 0);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r0)));
+        assertEquals(0, tmpEncoder.getTurnCost(flags_0), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r0));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_0));
+
+        long flags_r20 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_20 = tmpEncoder.getTurnFlags(false, 20);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r20)));
+        assertEquals(20, tmpEncoder.getTurnCost(flags_20), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r20));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_20));
+
+        long flags_r220 = tmpEncoder.getTurnFlags(true, 0);
+        try
+        {
+            tmpEncoder.getTurnFlags(false, 220);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r220)));
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r220));
     }
 
     @Test
     public void testMaxValue()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5);
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
@@ -330,7 +401,7 @@ public void testMaxValue()
     @Test
     public void testRegisterOnlyOnceAllowed()
     {
-        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5);
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
         EncodingManager em = new EncodingManager(instance);
         try
         {
@@ -338,7 +409,40 @@ public void testRegisterOnlyOnceAllowed()
             assertTrue(false);
         } catch (IllegalStateException ex)
         {
+        }
+    }
+
+    @Test
+    public void testSetToMaxSpeed()
+    {
+        OSMWay way = new OSMWay(12);
+        way.setTag("maxspeed", "90");
+        assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
+    }
 
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        try {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally {
+            encoder.setBlockFords(true);
         }
     }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
index 3c041efa03..220a204e0f 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -53,7 +53,7 @@ public void testMaxValueAndSwap()
         long swappedFlags = instance1.swap(flags, instance2);
         assertEquals(expectedFlags, swappedFlags);
 
-        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5);
+        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5, 0);
         new EncodingManager(carEncoder);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "motorway_link");
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index c492adf212..1b45cb56ac 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -27,7 +27,6 @@
 
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation;
@@ -123,9 +122,9 @@ public long handleRelationTags( OSMRelation relation, long oldRelFlags )
             }
 
             @Override
-            int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
+            protected int handlePriority( OSMWay way, int priorityFromRelation )
             {
-                return highwaySpeed;
+                return priorityFromRelation;
             }
 
             @Override
@@ -143,8 +142,8 @@ public String toString()
         long allow = defaultBike.acceptBit | lessRelationCodes.acceptBit;
         long flags = manager.handleWayTags(osmWay, allow, relFlags);
 
-        assertEquals(20, defaultBike.getSpeed(flags), 1e-1);
-        assertEquals(4, lessRelationCodes.getSpeed(flags), 1e-1);
+        assertTrue(defaultBike.getDouble(flags, PriorityWeighting.KEY)
+                > lessRelationCodes.getDouble(flags, PriorityWeighting.KEY));
     }
 
     @Test
@@ -167,10 +166,10 @@ public void testMixBikeTypesAndRelationCombination()
         long allow = bikeEncoder.acceptBit | mtbEncoder.acceptBit;
         long flags = manager.handleWayTags(osmWay, allow, relFlags);
 
-        // uninfluenced speed for grade1 bikeencoder = 4 (pushing section) -> smaller than 15 -> VERYNICE -> 22
-        assertEquals(24, bikeEncoder.getSpeed(flags), 1e-1);
-        // uninfluenced speed for grade1 bikeencoder = 12 -> smaller than 15 -> PREFER -> 18
-        assertEquals(20, mtbEncoder.getSpeed(flags), 1e-1);
+        // bike: uninfluenced speed for grade but via network => VERY_NICE                
+        // mtb: uninfluenced speed only PREFER
+        assertTrue(bikeEncoder.getDouble(flags, PriorityWeighting.KEY)
+                > mtbEncoder.getDouble(flags, PriorityWeighting.KEY));
     }
 
     public void testFullBitMask()
@@ -185,155 +184,36 @@ public void testFullBitMask()
     }
 
     @Test
-    public void testApplyNodeTags()
-    {
-        CarFlagEncoder car = new CarFlagEncoder();
-        CarFlagEncoder car2 = new CarFlagEncoder(7, 1)
-        {
-            protected EncodedValue nodeEncoder;
-
-            @Override
-            public int defineNodeBits( int index, int shift )
-            {
-                shift = super.defineNodeBits(index, shift);
-                nodeEncoder = new EncodedValue("nodeEnc", shift, 2, 1, 0, 3);
-                return shift + 2;
-            }
-
-            @Override
-            public long handleNodeTags( OSMNode node )
-            {
-                String tmp = node.getTag("test");
-                // return negative value to indicate that this is not a barrier
-                if (tmp == null)
-                    return -nodeEncoder.setValue(0, 1);
-                return -nodeEncoder.setValue(0, 2);
-            }
-
-            @Override
-            public long applyNodeFlags( long wayFlags, long nodeFlags )
-            {
-                double speed = speedEncoder.getDoubleValue(wayFlags);
-                double speedDecrease = nodeEncoder.getValue(nodeFlags);
-                return setSpeed(wayFlags, speed - speedDecrease);
-            }
-        };
-        EncodingManager manager = new EncodingManager(car, car2);
-
-        OSMNode node = new OSMNode(1, Double.NaN, Double.NaN);
-        OSMWay way = new OSMWay(2);
-        way.setTag("highway", "secondary");
-
-        long wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        long nodeFlags = manager.handleNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(60, car.getSpeed(wayFlags), 1e-1);
-        assertEquals(59, car2.getSpeed(wayFlags), 1e-1);
-
-        node.setTag("test", "something");
-        wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        nodeFlags = manager.handleNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(58, car2.getSpeed(wayFlags), 1e-1);
-        assertEquals(60, car.getSpeed(wayFlags), 1e-1);
-
-        way.setTag("maxspeed", "130");
-        wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        assertEquals(car.getMaxSpeed(), car2.getSpeed(wayFlags), 1e-1);
-        nodeFlags = manager.handleNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(98, car2.getSpeed(wayFlags), 1e-1);
-        assertEquals(100, car.getSpeed(wayFlags), 1e-1);
-    }
-
-    /**
-     * Tests the combination of different turn cost flags by different encoders.
-     */
-    @Test
-    public void testTurnFlagCombination()
+    public void testFixWayName()
     {
-        final TurnCostTableEntry turnCostEntry_car = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_foot = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_bike = new TurnCostTableEntry();
-
-        CarFlagEncoder car = new CarFlagEncoder()
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_car); //simulate by returning one turn cost entry directly
-            }
-        };
-        FootFlagEncoder foot = new FootFlagEncoder()
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_foot); //simulate by returning one turn cost entry directly
-            }
-        };
-        BikeFlagEncoder bike = new BikeFlagEncoder()
-        {
-            @Override
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_bike); //simulate by returning one turn cost entry directly
-            }
-        };
-
-        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4, 127);
-
-        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), turn cost entry for bike is for another relation (different viaNode) 
-        turnCostEntry_car.edgeFrom = 1;
-        turnCostEntry_foot.edgeFrom = 1;
-        turnCostEntry_bike.edgeFrom = 2;
-
-        // calculating arbitrary flags using the encoders
-        turnCostEntry_car.flags = car.getTurnFlags(true, 20);
-        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
-        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
-
-        // we expect two different entries: the first one is a combination of turn flags of car and foot, since they provide the same relation, the other one is for bike only
-        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
-        long assertFlag2 = turnCostEntry_bike.flags;
-
-        // RUN: analyze = combine flags of all encoders
-        Collection<TurnCostTableEntry> entries = manager.analyzeTurnRelation(null, null);
-
-        assertEquals(2, entries.size()); //we expect two different turnCost entries
-
-        for (TurnCostTableEntry entry : entries)
-        {
-            if (entry.edgeFrom == 1)
-            {
-                // the first entry provides turn flags for car and foot only 
-                assertEquals(assertFlag1, entry.flags);
-                assertTrue(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertEquals(20, car.getTurnCosts(entry.flags));
-                assertEquals(0, foot.getTurnCosts(entry.flags));
-                assertEquals(0, bike.getTurnCosts(entry.flags));
-            } else if (entry.edgeFrom == 2)
-            {
-                // the 2nd entry provides turn flags for bike only
-                assertEquals(assertFlag2, entry.flags);
-                assertFalse(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertEquals(0, car.getTurnCosts(entry.flags));
-                assertEquals(0, foot.getTurnCosts(entry.flags));
-                assertEquals(10, bike.getTurnCosts(entry.flags));
-            }
-        }
+        assertEquals("B8, B12", EncodingManager.fixWayName("B8;B12"));
+        assertEquals("B8, B12", EncodingManager.fixWayName("B8; B12"));
     }
 
     @Test
-    public void testFixWayName()
+    public void testCompatibilityBug()
     {
-        assertEquals("B8, B12", EncodingManager.fixWayName("B8;B12"));
-        assertEquals("B8, B12", EncodingManager.fixWayName("B8; B12"));
+        EncodingManager manager2 = new EncodingManager("bike2", 8);
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "footway");
+        osmWay.setTag("name", "test");
+
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
+        double singleSpeed = singleBikeEnc.getSpeed(flags);
+        assertEquals(4, singleSpeed, 1e-3);
+        assertEquals(singleSpeed, singleBikeEnc.getReverseSpeed(flags), 1e-3);
+
+        EncodingManager manager = new EncodingManager("bike2,bike,foot", 8);
+        FootFlagEncoder foot = (FootFlagEncoder) manager.getEncoder("foot");
+        BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike2");
+
+        long acceptBits = foot.acceptBit | bike.acceptBit;
+        flags = manager.handleWayTags(osmWay, acceptBits, 0);
+        assertEquals(singleSpeed, bike.getSpeed(flags), 1e-2);
+        assertEquals(singleSpeed, bike.getReverseSpeed(flags), 1e-2);
+
+        assertEquals(5, foot.getSpeed(flags), 1e-2);
+        assertEquals(5, foot.getReverseSpeed(flags), 1e-2);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index d84ed992d8..816310c551 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -34,7 +34,7 @@ public void testMinWeightHasSameUnitAs_getWeight()
     {
         FastestWeighting instance = new FastestWeighting(encoder);
         long flags = encoder.setProperties(encoder.getMaxSpeed(), true, true);
-        assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false), 1e-8);
+        assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     @Test
@@ -42,10 +42,10 @@ public void testSpeed0()
     {
         FastestWeighting instance = new FastestWeighting(encoder);
 
-        assertEquals(1.0 / 0, instance.calcWeight(createEdge(10, encoder.setProperties(0, true, true)), false), 1e-8);
+        assertEquals(1.0 / 0, instance.calcWeight(createEdge(10, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
 
         // 0 / 0 returns NaN but calcWeight should not return NaN!
-        assertEquals(1.0 / 0, instance.calcWeight(createEdge(0, encoder.setProperties(0, true, true)), false), 1e-8);
+        assertEquals(1.0 / 0, instance.calcWeight(createEdge(0, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     EdgeIterator createEdge( final double distance, final long flags )
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 538ecccf2a..ce145c8b57 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -17,18 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
 
-import java.util.HashMap;
-import java.util.Map;
-
 import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
@@ -51,7 +47,7 @@ public void testGetSpeed()
     public void testBasics()
     {
         long fl = footEncoder.flagsDefault(true, true);
-        assertEquals(FootFlagEncoder.MEAN, footEncoder.getSpeed(fl), 1e-1);
+        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(fl), 1e-1);
 
         long fl1 = footEncoder.flagsDefault(true, false);
         long fl2 = footEncoder.reverseFlags(fl1);
@@ -64,12 +60,12 @@ public void testCombined()
         FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
         long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
-        assertTrue(footEncoder.isForward(fl));
-        assertTrue(footEncoder.isBackward(fl));
+        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_FORWARD));
+        assertTrue(footEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
 
         assertEquals(100, carEncoder.getSpeed(fl), 1e-1);
-        assertTrue(carEncoder.isForward(fl));
-        assertFalse(carEncoder.isBackward(fl));
+        assertTrue(carEncoder.isBool(fl, FlagEncoder.K_FORWARD));
+        assertFalse(carEncoder.isBool(fl, FlagEncoder.K_BACKWARD));
 
         assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)), 1e-1);
     }
@@ -115,6 +111,8 @@ public void testAccess()
         assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.setTag("bicycle", "official");
+        assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
         way.setTag("foot", "official");
@@ -132,9 +130,9 @@ public void testAccess()
 
         way.clearTags();
         way.setTag("highway", "cycleway");
-        assertFalse(footEncoder.acceptWay(way) > 0);
-        way.setTag("foot", "yes");
         assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
+        assertFalse(footEncoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "track");
@@ -154,7 +152,6 @@ public void testAccess()
     public void testMixSpeedAndSafe()
     {
         OSMWay way = new OSMWay(1);
-
         way.setTag("highway", "motorway");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
         assertEquals(0, flags);
@@ -169,6 +166,18 @@ public void testMixSpeedAndSafe()
         assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
     }
 
+    @Test
+    public void testPriority()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "cycleway");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "official");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+    }
+
     @Test
     public void testSlowHiking()
     {
@@ -176,12 +185,12 @@ public void testSlowHiking()
         way.setTag("highway", "track");
         way.setTag("sac_scale", "hiking");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(FootFlagEncoder.MEAN, footEncoder.getSpeed(flags), 1e-1);
+        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(flags), 1e-1);
 
         way.setTag("highway", "track");
         way.setTag("sac_scale", "mountain_hiking");
         flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(FootFlagEncoder.SLOW, footEncoder.getSpeed(flags), 1e-1);
+        assertEquals(FootFlagEncoder.SLOW_SPEED, footEncoder.getSpeed(flags), 1e-1);
     }
 
     @Test
@@ -193,11 +202,11 @@ public void testTurnFlagEncoding_noCostsAndRestrictions()
         long flags_r20 = footEncoder.getTurnFlags(true, 20);
         long flags_20 = footEncoder.getTurnFlags(false, 20);
 
-        assertEquals(0, footEncoder.getTurnCosts(flags_r0));
-        assertEquals(0, footEncoder.getTurnCosts(flags_0));
+        assertEquals(0, footEncoder.getTurnCost(flags_r0), 1e-1);
+        assertEquals(0, footEncoder.getTurnCost(flags_0), 1e-1);
 
-        assertEquals(0, footEncoder.getTurnCosts(flags_r20));
-        assertEquals(0, footEncoder.getTurnCosts(flags_20));
+        assertEquals(0, footEncoder.getTurnCost(flags_r20), 1e-1);
+        assertEquals(0, footEncoder.getTurnCost(flags_20), 1e-1);
 
         assertFalse(footEncoder.isTurnRestricted(flags_r0));
         assertFalse(footEncoder.isTurnRestricted(flags_0));
@@ -205,4 +214,41 @@ public void testTurnFlagEncoding_noCostsAndRestrictions()
         assertFalse(footEncoder.isTurnRestricted(flags_r20));
         assertFalse(footEncoder.isTurnRestricted(flags_20));
     }
+
+    @Test
+    public void testBarrierAccess()
+    {
+        // by default allow access through the gate for bike & foot!
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "yes");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        // barrier!
+        assertTrue(footEncoder.handleNodeTags(node) > 0);
+
+        node.setTag("bicycle", "yes");
+        // no barrier!?
+        // assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("foot", "yes");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node.setTag("locked", "yes");
+        // barrier!
+        assertTrue(footEncoder.handleNodeTags(node) > 0);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
similarity index 55%
rename from core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
rename to core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 2eb5a9e664..81df2aac3c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -2,13 +2,13 @@
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
  *  license agreements. See the NOTICE file distributed with this work for 
  *  additional information regarding copyright ownership.
- * 
+ *
  *  GraphHopper licenses this file to you under the Apache License, 
  *  Version 2.0 (the "License"); you may not use this file except in 
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,27 +17,28 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.storage.Graph;
+import com.graphhopper.reader.OSMWay;
+import org.junit.Test;
+import static org.junit.Assert.*;
 
 /**
- * Holds an algorithm which can be prepared and created.
- * <p/>
+ *
  * @author Peter Karich
  */
-public interface AlgorithmPreparation
+public class MotorcycleFlagEncoderTest
 {
-    /**
-     * Prepares the underlying graph to be used by a specialized algorithm.
-     */
-    AlgorithmPreparation doWork();
+    private final EncodingManager em = new EncodingManager("CAR,BIKE,FOOT");
+    private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("CAR");
 
-    /**
-     * @return true if doWork was already called.
-     */
-    boolean isPrepared();
-
-    AlgorithmPreparation setGraph( Graph g );
-
-    RoutingAlgorithm createAlgo();
+    @Test
+    public void testHandleWayTags()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        long flags = encoder.acceptWay(way);
+        assertTrue(flags > 0);
+        long result = encoder.handleWayTags(way, flags, 0);
+        assertEquals(20, encoder.getSpeed(result), .1);
+        assertEquals(20, encoder.getReverseSpeed(result), .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index e9efbb1baf..cc4bc85b83 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -1,34 +1,35 @@
 /*
- * Copyright 2013 User.
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *       http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.routing.util.PriorityCode;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static org.junit.Assert.*;
 
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB").getEncoder("MTB");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,MTB").getEncoder("MTB");
     }
 
     @Test
@@ -38,42 +39,64 @@ public void testGetSpeed()
         assertEquals(10, encoder.getSpeed(result), 1e-1);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
-        assertEquals(10, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(REACH_DEST.getValue(), way);
 
         way.setTag("highway", "residential");
-        assertEquals(15, encoder.getSpeed(way));
+        assertEquals(16, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
         // Test pushing section speeds
         way.setTag("highway", "footway");
         assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
         way.setTag("highway", "track");
-        assertEquals(24, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
 
         way.setTag("highway", "steps");
-        assertEquals(2, encoder.getSpeed(way));
-
-        way.setTag("highway", "service");
-        assertEquals(15, encoder.getSpeed(way));
-        way.setTag("service", "parking_aisle");
-        assertEquals(15, encoder.getSpeed(way));
+        assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
         way.clearTags();
 
         // test speed for allowed pushing section types
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
-        assertEquals(24, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
 
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
         way.setTag("tracktype", "grade3");
-        assertEquals(20, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.setTag("surface", "paved");
-        assertEquals(12, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "ground");
-        assertEquals(20, encoder.getSpeed(way));
+        assertEquals(16, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+    }
+
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("sac_scale", "alpine_hiking");
+        assertTrue(encoder.acceptWay(way) > 0);
+        
+        way.setTag("sac_scale", "demanding_alpine_hiking");
+        assertTrue(encoder.acceptWay(way) == 0);
     }
 
     @Test
@@ -83,42 +106,46 @@ public void testHandleWayTags()
         String wayType;
 
         way.setTag("highway", "track");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "concrete");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("way", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("foot", "yes");
         way.setTag("surface", "paved");
         way.setTag("tracktype", "grade1");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("way", wayType);
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("foot", "yes");
         way.setTag("surface", "paved");
         way.setTag("tracktype", "grade2");
-        wayType = encodeDecodeWayType("", way);
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
+        way.clearTags();
+        way.setTag("highway", "pedestrian");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
     }
 
     @Test
@@ -129,34 +156,35 @@ public void testHandleWayTagsInfluencedByRelation()
         long allowed = encoder.acceptBit;
 
         OSMRelation osmRel = new OSMRelation(1);
-
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         // unchanged
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(24, encoder.getSpeed(flags), 1e-1);
-        assertEquals(3, encoder.getWayType(flags));
-        assertEquals(1, encoder.getPavementType(flags));
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay));
 
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags), 1e-1);
-        assertEquals(3, encoder.getWayType(flags));
-        assertEquals(1, encoder.getPavementType(flags));
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay));
 
         // relation code is PREFER
         osmRel.setTag("network", "rcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
         // relation code is PREFER
         osmRel.setTag("network", "ncn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
         // PREFER relation, but tertiary road
         // => no pushing section but road wayTypeCode and faster
@@ -167,7 +195,8 @@ public void testHandleWayTagsInfluencedByRelation()
         osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(20, encoder.getSpeed(flags), 1e-1);
-        assertEquals(0, encoder.getWayType(flags));
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("", getWayTypeFromFlags(osmWay));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index f172436b74..9bd116a678 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -17,17 +17,17 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
+
+import gnu.trove.list.array.TIntArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
-
 /**
  *
  * @author Peter Karich
@@ -148,4 +148,96 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         g.optimize();
         assertEquals(7, g.getNodes());
     }
+
+    GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
+    {
+        GraphStorage g = createGraph(em);
+        // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(5, 4, 1, false);
+        g.edge(5, 6, 1, true);
+
+        // 7 -> 8 <-> 9 <-> 10
+        g.edge(7, 8, 1, false);
+        g.edge(8, 9, 1, true);
+        g.edge(9, 10, 1, true);
+
+        return g;
+    }
+
+    GraphStorage createTarjanTestGraph()
+    {
+        GraphStorage g = createGraph(em);
+
+        g.edge(1, 2, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(3, 1, 1, false);
+
+        g.edge(4, 2, 1, false);
+        g.edge(4, 3, 1, false);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, false);
+
+        g.edge(6, 3, 1, false);
+        g.edge(6, 7, 1, true);
+
+        g.edge(8, 5, 1, false);
+        g.edge(8, 7, 1, false);
+        g.edge(8, 8, 1, false);
+
+        return g;
+    }
+
+    @Test
+    public void testRemoveDeadEndUnvisitedNetworks()
+    {
+        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        assertEquals(11, g.getNodes());
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+
+        assertEquals(3, removed);
+
+        g.optimize();
+        assertEquals(8, g.getNodes());
+    }
+
+    @Test
+    public void testTarjan()
+    {
+        GraphStorage g = createSubnetworkTestGraph();
+
+        // Requires a single vehicle type, otherwise we throw.
+        final FlagEncoder flagEncoder = em.getSingle();
+        final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
+
+        TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
+
+        List<TIntArrayList> components = tarjan.findComponents();
+
+        assertEquals(4, components.size());
+        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
+        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
+        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+    }
+
+    // Previous two-pass implementation failed on 1 -> 2 -> 0
+    @Test
+    public void testNodeOrderingRegression() {
+        // 1 -> 2 -> 0
+        GraphStorage g = createGraph(em);
+        g.edge(1, 2, 1, false);
+        g.edge(2, 0, 1, false);
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        
+        assertEquals(3, removed);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index 0cc304222d..b7b00c2ff5 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,9 +19,8 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import static com.graphhopper.routing.util.BikeFlagCommonEncoder.PUSHING_SECTION_SPEED;
-import java.util.HashMap;
-import java.util.Map;
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -32,9 +31,52 @@
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB,RACINGBIKE").getEncoder("RACINGBIKE");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,RACINGBIKE").getEncoder("RACINGBIKE");
+    }
+
+    @Test
+    @Override
+    public void testAvoidTunnel()
+    {
+        // tunnel is not that bad for racing bike
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "residential");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "secondary");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), osmWay);
+    }
+
+    @Test
+    @Override
+    public void testService()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.setTag("service", "parking_aisle");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+    }
+
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
     }
 
     @Test
@@ -45,17 +87,16 @@ public void testGetSpeed()
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade3");
-        // Pushing section speed/2
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(way), 1e-1);
+        // Pushing section
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
 
-        // Even if it is part of a cycle way PUSHING_SECTION_SPEED/2
+        // Even if it is part of a cycle way
         way.setTag("bicycle", "yes");
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(way), 1e-1);
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "steps");
-        assertEquals(2, getEncodedDecodedSpeed(way), 1e-1);
-
+        assertEquals(2, getSpeedFromFlags(way), 1e-1);
     }
 
     @Test
@@ -63,37 +104,70 @@ public void testHandleWayTagsInfluencedByRelation()
     {
         OSMWay osmWay = new OSMWay(1);
         osmWay.setTag("highway", "track");
-        long allowed = encoder.acceptBit;
-
-        OSMRelation osmRel = new OSMRelation(1);
-
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(osmWay), 1e-1);
+        assertEquals(PUSHING_SECTION_SPEED / 2, getSpeedFromFlags(osmWay), 1e-1);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, 0));
 
         // relation code is PREFER
+        long allowed = encoder.acceptBit;
+        OSMRelation osmRel = new OSMRelation(1);
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
-        assertEquals(1, encoder.getWayType(flags)); // Pushing section
-        assertEquals(1, encoder.getPavementType(flags)); //  Unpaved
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
 
         // relation code is OUTSTANDING NICE but as unpaved, the speed is still PUSHING_SECTION_SPEED/2
         osmRel.setTag("network", "icn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
         // Now we assume bicycle=yes, anyhow still unpaved
         osmWay.setTag("bicycle", "yes");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
-        // Now we assume bicycle=yes, and paved -> The speed is pushed!
+        // Now we assume bicycle=yes, and paved
         osmWay.setTag("tracktype", "grade1");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(30, encoder.getSpeed(flags), 1e-1);
+        assertEquals(20, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
+        assertEquals("", getWayTypeFromFlags(osmWay, relFlags));
+
+        // Now we assume bicycle=yes, and unpaved as part of a cycle relation
+        osmWay.setTag("tracktype", "grade2");
+        osmWay.setTag("bicycle", "yes");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(10, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
+
+        // Now we assume bicycle=yes, and unpaved not part of a cycle relation
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "track");
+        osmWay.setTag("tracktype", "grade3");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(4, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
+
+        // Now we assume bicycle=yes, and tracktype = null
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "track");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index c990ad6065..746d286993 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -37,7 +37,7 @@ public void testNoErrorOnLargeName()
         {
             str += "";
         }
-        int result = index.put(str);
+        long result = index.put(str);
         assertEquals(127, index.get(result).length());
     }
 
@@ -45,10 +45,10 @@ public void testNoErrorOnLargeName()
     public void testPut()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
-        int result = index.put("Something Street");
+        long result = index.put("Something Street");
         assertEquals("Something Street", index.get(result));
 
-        int existing = index.put("Something Street");
+        long existing = index.put("Something Street");
         assertEquals(result, existing);
 
         result = index.put("testing");
@@ -65,10 +65,10 @@ public void testCreate()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         String str1 = "nice";
-        int pointer1 = index.put(str1);
+        long pointer1 = index.put(str1);
 
         String str2 = "nice work ";
-        int pointer2 = index.put(str2);
+        long pointer2 = index.put(str2);
 
         assertEquals(str2, index.get(pointer2));
         assertEquals(str1, index.get(pointer1));
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index 7c719e78eb..8850b1c893 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -52,10 +52,10 @@ public void setUp()
     public void testRequestedDataAccessHasToBeTheIdenticalType()
     {
         Directory dir = createDir();
-        da = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false));
+        da = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, false));
         try
         {
-            dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, true));
+            dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, true));
             assertFalse(true);
         } catch (Exception ex)
         {
@@ -66,8 +66,8 @@ public void testRequestedDataAccessHasToBeTheIdenticalType()
     public void testSynched()
     {
         Directory dir = createDir();
-        DataAccess da1 = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false));
-        da = dir.find("testing_synched", new DAType(DAType.MemRef.HEAP, false, false, true));
+        DataAccess da1 = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, true, false));
+        da = dir.find("testing_synched", new DAType(DAType.MemRef.HEAP, false, false, true, true));
         assertFalse(da.getClass() == da1.getClass());
         da1.close();
     }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index c9ad7d2618..beba510ca5 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -800,14 +800,14 @@ public void testCreateDuplicateEdges()
         EdgeIteratorState oneIter = graph.getEdgeProps(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
-        assertTrue(carEncoder.isForward(oneIter.getFlags()));
-        assertFalse(carEncoder.isBackward(oneIter.getFlags()));
+        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
+        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
 
         oneIter = graph.getEdgeProps(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
-        assertTrue(carEncoder.isBackward(oneIter.getFlags()));
-        assertFalse(carEncoder.isForward(oneIter.getFlags()));
+        assertFalse(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(carEncoder.isBool(oneIter.getFlags(), FlagEncoder.K_BACKWARD));
 
         graph.edge(3, 2, 14, true);
         assertEquals(4, GHUtility.count(carOutExplorer.setBaseNode(2)));
@@ -947,14 +947,14 @@ public void testGetAllEdgesWithDelete()
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         iter = graph.getAllEdges();
         iter.next();
@@ -1004,7 +1004,7 @@ public static int getIdOf( Graph g, double latitude, double longitude )
                 return i;
             }
         }
-        return -1;
+        throw new IllegalArgumentException("did not find node with location " + (float) latitude + "," + (float) longitude);
     }
 
     @Test
@@ -1026,9 +1026,9 @@ public void test8BytesFlags()
     {
         Directory dir = new RAMDirectory();
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
-        list.add(new TmpCarFlagEncoder(30, 0.001));
-        list.add(new TmpCarFlagEncoder(30, 0.001));
-        EncodingManager manager = new EncodingManager(list, 8, 0);
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0));
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0));
+        EncodingManager manager = new EncodingManager(list, 8);
         graph = new GraphHopperStorage(dir, manager, false).create(defaultSize);
 
         EdgeIteratorState edge = graph.edge(0, 1);
@@ -1044,15 +1044,17 @@ public void test8BytesFlags()
         assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
         long flags = GHUtility.getEdge(graph, 1, 0).getFlags();
         assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
-        assertTrue(list.get(0).isForward(flags));
-        assertTrue(list.get(0).isBackward(flags));
+        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_FORWARD));
+        assertTrue(list.get(0).isBool(flags, FlagEncoder.K_BACKWARD));
         edge = graph.edge(2, 3);
         edge.setFlags(list.get(1).setProperties(44.123, true, false));
         assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
+
         flags = GHUtility.getEdge(graph, 3, 2).getFlags();
         assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
-        assertTrue(list.get(1).isForward(flags));
-        assertFalse(list.get(1).isBackward(flags));
+        assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
+        assertFalse(list.get(1).isBool(flags, FlagEncoder.K_FORWARD));
+        assertTrue(list.get(1).isBool(flags, FlagEncoder.K_BACKWARD));
     }
 
     @Test
@@ -1096,13 +1098,13 @@ public void testDetachEdge()
         assertEquals(2, iter.getAdjNode());
         assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
         assertEquals(2, edgeState2.getAdjNode());
-        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
+        assertTrue(carEncoder.isBool(edgeState2.getFlags(), FlagEncoder.K_FORWARD));
 
         EdgeIteratorState edgeState3 = iter.detach(true);
         assertEquals(0, edgeState3.getAdjNode());
         assertEquals(2, edgeState3.getBaseNode());
         assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
+        assertFalse(carEncoder.isBool(edgeState3.getFlags(), FlagEncoder.K_FORWARD));
         assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
         assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
 
@@ -1125,9 +1127,9 @@ public void testDetachEdge()
 
     static class TmpCarFlagEncoder extends CarFlagEncoder
     {
-        public TmpCarFlagEncoder( int speedBits, double speedFactor )
+        public TmpCarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         {
-            super(speedBits, speedFactor);
+            super(speedBits, speedFactor, maxTurnCosts);
         }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
new file mode 100644
index 0000000000..6e73952da5
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.junit.After;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * @author Peter Karich
+ */
+public abstract class AbstractLockFactoryTester
+{
+    protected final File lockDir = new File("./target/lockingtest/");
+
+    protected abstract LockFactory createLockFactory();
+
+    @Before
+    public void setUp()
+    {
+        lockDir.mkdirs();
+    }
+
+    @After
+    public void tearDown()
+    {
+        Helper.removeDir(lockDir);
+    }
+
+    @Test
+    public void testObtain()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock lock = instance.create("test", true);
+        assertTrue(lock.tryLock());
+        assertTrue(lock.isLocked());
+        assertFalse(lock.tryLock());
+        assertTrue(lock.isLocked());
+
+        Lock lock2 = instance.create("test", true);
+        assertFalse(lock2.tryLock());
+        assertTrue(lock2.isLocked());
+
+        // fails for SimpleFSLockFactory:
+        // although it is locked do not allow release:
+        // lock2.release();
+        // assertTrue(lock.isLocked());
+
+        lock.release();
+        assertFalse(lock.isLocked());
+    }
+
+    @Test
+    public void testForceDelete()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock lock = instance.create("testlock", true);
+        assertTrue(lock.tryLock());
+        assertTrue(lock.isLocked());
+
+        // on windows we cannot forcefully remove an unreleased lock
+        if (Constants.WINDOWS)
+            lock.release();
+        
+        instance.forceRemove(lock.getName(), true);
+        assertFalse(lock.isLocked());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index aedacce9ba..f5ae8eb1d9 100644
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -75,7 +75,14 @@ public void testLoadFlush()
         da.close();
 
         // cannot load data if already closed
-        assertFalse(da.loadExisting());
+        try
+        {
+            da.loadExisting();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("already closed", ex.getMessage());
+        }
 
         da = createDataAccess(name);
         assertTrue(da.loadExisting());
@@ -88,7 +95,7 @@ public void testExceptionIfNoEnsureCapacityWasCalled()
     {
         DataAccess da = createDataAccess(name);
         assertFalse(da.loadExisting());
-        // throw some undefined exception if no incCapacity was called
+        // throw some undefined exception if no ensureCapacity was called
         try
         {
             da.setInt(2 * 4, 321);
@@ -142,7 +149,7 @@ public void testEnsureCapacity()
         da.setInt(31 * 4, 200);
 
         assertEquals(200, da.getInt(31 * 4));
-        da.incCapacity(2 * 128);
+        da.ensureCapacity(2 * 128);
         assertEquals(200, da.getInt(31 * 4));
         // now it shouldn't fail
         da.setInt(32 * 4, 220);
@@ -152,7 +159,7 @@ public void testEnsureCapacity()
         // ensure some bigger area
         da = createDataAccess(name);
         da.create(200 * 4);
-        da.incCapacity(600 * 4);
+        da.ensureCapacity(600 * 4);
         da.close();
     }
 
@@ -191,7 +198,7 @@ public void testSegments()
         da.setSegmentSize(128);
         da.create(10);
         assertEquals(1, da.getSegments());
-        da.incCapacity(500);
+        da.ensureCapacity(500);
         int olds = da.getSegments();
         assertTrue(olds > 3);
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index f02e479d25..f58cd0ed11 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -17,15 +17,15 @@
  */
 package com.graphhopper.storage;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
-
-import org.junit.Test;
+import java.util.Random;
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  *
@@ -33,12 +33,12 @@
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
 {
-    private TurnCostStorage turnCostStorage;
+    private TurnCostExtension turnCostStorage;
 
     @Override
     protected GraphStorage newGraph( Directory dir, boolean is3D )
     {
-        turnCostStorage = new TurnCostStorage();
+        turnCostStorage = new TurnCostExtension();
         return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
@@ -65,9 +65,9 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
 
-        turnCostStorage.setTurnCosts(0, iter1.getEdge(), iter2.getEdge(), 1337);
-        turnCostStorage.setTurnCosts(0, iter2.getEdge(), iter1.getEdge(), 666);
-        turnCostStorage.setTurnCosts(1, iter1.getEdge(), iter2.getEdge(), 815);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 0, iter2.getEdge(), 1337);
+        turnCostStorage.addTurnInfo(iter2.getEdge(), 0, iter1.getEdge(), 666);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 1, iter2.getEdge(), 815);
 
         iter1.setName("named street1");
         iter2.setName("named street2");
@@ -85,12 +85,53 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
 
-        assertEquals(1337, turnCostStorage.getTurnCosts(0, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(666, turnCostStorage.getTurnCosts(0, iter2.getEdge(), iter1.getEdge()));
-        assertEquals(815, turnCostStorage.getTurnCosts(1, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(0, turnCostStorage.getTurnCosts(3, iter1.getEdge(), iter2.getEdge()));
+        assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
+        assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
+        assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
+        assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
         graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
         checkGraph(graph);
     }
+
+    @Test
+    public void testEnsureCapacity() throws IOException {
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph.setSegmentSize(128);
+        graph.create(100); // 100 is the minimum size
+
+        // assert that turnCostStorage can hold 104 turn cost entries at the beginning
+        assertEquals(104, turnCostStorage.getCapacity() / 16);
+
+        Random r = new Random();
+
+        NodeAccess na = graph.getNodeAccess();
+        for (int i = 0; i < 100; i++) {
+            double randomLat = 90 * r.nextDouble();
+            double randomLon = 180 * r.nextDouble();
+
+            na.setNode(i, randomLat, randomLon);
+        }
+
+        // Make node 50 the 'center' node
+        for (int nodeId = 51; nodeId < 100; nodeId++) {
+            graph.edge(50, nodeId, r.nextDouble(), true);
+        }
+        for (int nodeId = 0; nodeId < 50; nodeId++) {
+            graph.edge(nodeId, 50, r.nextDouble(), true);
+        }
+
+        // add 100 turn cost entries around node 50
+        for (int edgeId = 0; edgeId < 50; edgeId++) {
+            turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
+            turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
+        }
+
+        turnCostStorage.addTurnInfo(0, 50, 1, 1337);
+        assertEquals(104, turnCostStorage.getCapacity() / 16); // we are still good here
+
+        turnCostStorage.addTurnInfo(0, 50, 2, 1337);
+        // A new segment should be added, which will support 128 / 16 = 8 more entries.
+        assertEquals(112, turnCostStorage.getCapacity() / 16);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index 413f1538b9..cad468fb81 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -174,15 +174,15 @@ public void testGetWeight()
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
         assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-        assertTrue(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
 
         flags = carEncoder.setProperties(10, false, true);
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(carEncoder.isBackward(sc1.getFlags()));
-        assertFalse(carEncoder.isForward(sc1.getFlags()));
+        assertEquals(100.123, sc1.getWeight(), 1e-3);        
+        assertFalse(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
+        assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index f7f7f1c74f..941d81b485 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -28,7 +28,7 @@
     @Override
     public DataAccess createDataAccess( String name )
     {
-        return new MMapDataAccess(name, directory, defaultOrder).setSegmentSize(128);
+        return new MMapDataAccess(name, directory, defaultOrder, true).setSegmentSize(128);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
new file mode 100644
index 0000000000..ddeaa9e012
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -0,0 +1,70 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.nio.channels.OverlappingFileLockException;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
+{
+    @Override
+    protected LockFactory createLockFactory()
+    {
+        return new NativeFSLockFactory(lockDir);
+    }
+
+    @Test
+    public void testMultiReadObtain()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock writeLock1 = instance.create("test", true);
+        assertTrue(writeLock1.tryLock());
+
+        // BUT disallow more than one write lock!
+        Lock lock2 = instance.create("test", false);
+        assertFalse(lock2.tryLock());
+
+        writeLock1.release();
+
+        assertTrue(lock2.tryLock());
+
+        // http://stackoverflow.com/q/24367887/194609
+        // we cannot test 'allow multiple read locks' as multiple reads are only allowed for different processes        
+        // Lock lock3 = instance.create("test", false);
+        // assertFalse(lock3.tryLock());
+        // lock3.release();
+        // still the lock should be valid
+        assertTrue(lock2.isLocked());
+
+        // disallow write lock if currently reading
+        Lock writeLock4 = instance.create("test", true);
+        assertFalse(writeLock4.tryLock());
+        assertEquals(OverlappingFileLockException.class, writeLock4.getObtainFailedReason().getClass());
+        writeLock4.release();
+
+        assertTrue(lock2.isLocked());
+        lock2.release();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/Graph3D.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
similarity index 54%
rename from core/src/main/java/com/graphhopper/storage/Graph3D.java
rename to core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index 9f077d3ac3..1f9badefe4 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph3D.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -1,14 +1,15 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,11 +19,14 @@
 package com.graphhopper.storage;
 
 /**
+ *
  * @author Peter Karich
  */
-public interface Graph3D extends Graph
+public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
 {
-    void setNode( int index, double lat, double lon, double height );
-
-    double getHeight( int index );
+    @Override
+    protected LockFactory createLockFactory()
+    {
+        return new SimpleFSLockFactory(lockDir);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 3def5e0395..50d76f5d68 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -39,7 +39,7 @@
         @Override
         public void set( double lat, double lon )
         {
-            points.add(lat, lon, Double.NaN);
+            points.add(lat, lon);
         }
     };
 
@@ -52,39 +52,63 @@ public void setUp()
     @Test
     public void testBresenhamLineLeftDown()
     {
-        BresenhamLine.calcPoints(2, 1, -3, -1, emitter);
-        assertEquals(Helper.createPointList(2, 1, 1, 1, 0, 0, -1, 0, -2, 0, -3, -1), points);
+        BresenhamLine.calcPoints(5, 2, 0, 0, emitter);
+        // 5,2, 4,2, 3,2, 3,1, 2,1, 1,1, 0,0
+        assertEquals(Helper.createPointList(5, 2, 4, 2, 3, 1, 2, 1, 1, 0, 0, 0), points);
+    }
+
+    @Test
+    public void testLineRightDown2()
+    {
+        // example http://stackoverflow.com/a/12370474/194609
+        BresenhamLine.voxelTraversal(0.25, 0.25, 2.75, 5.25, emitter);
+        assertEquals(Helper.createPointList(0, 0, 0, 1, 1, 1, 1, 2, 1, 3, 2, 3, 2, 4, 2, 5), points);
+    }
+
+    @Test
+    public void testBresenhamLineRightDown()
+    {
+        BresenhamLine.calcPoints(3, 1, 0, 3, emitter);
+        // 3,1, 2,1, 1,1, 1,2, 0,2, 0,3
+        assertEquals(Helper.createPointList(3, 1, 2, 2, 1, 2, 0, 3), points);
     }
 
     @Test
     public void testBresenhamLineLeftUp()
     {
-        BresenhamLine.calcPoints(2, 1, 3, -1, emitter);
-        assertEquals(Helper.createPointList(2, 1, 2, 0, 3, -1), points);
+        BresenhamLine.calcPoints(2, 2, 3, 0, emitter);
+        // 2,2, 2,1, 2,0, 3,0
+
+        assertEquals(Helper.createPointList(2, 2, 2, 1, 3, 0), points);
+    }
+
+    @Test
+    public void testBresenhamLineRightUp()
+    {
+        BresenhamLine.calcPoints(0, 0, 2, 3, emitter);
+        // 0,0, 0,1, 1,1, 1,2, 2,2, 2,3
+        assertEquals(Helper.createPointList(0, 0, 1, 1, 1, 2, 2, 3), points);
     }
 
     @Test
     public void testBresenhamBug()
     {
         BresenhamLine.calcPoints(0.5, -0.5, -0.6, 1.6, emitter, -1, -1, 0.75, 1.3);
-//        assertEquals(Helper.createPointList(0.875, -0.35, 0.125, 0.95, -0.625, 2.25), points);
-        assertEquals(Helper.createPointList(0.5, -1, 0.5, 0.3, -0.25, 1.6), points);
+        assertEquals(Helper.createPointList(0.575, -0.87, -0.175, 0.43, -0.925, 1.73), points);
     }
 
     @Test
     public void testBresenhamHorizontal()
     {
         BresenhamLine.calcPoints(.5, -.5, .5, 1, emitter, -1, -1, 0.6, 0.4);
-        // assertEquals(Helper.createPointList(.5, -.4, .5, 0, .5, .4, .5, .8, .5, 1.2), points);
-        assertEquals(Helper.createPointList(.8, -.6, .8, -0.2, .8, .2, .8, .6, .8, 1.0), points);
+        assertEquals(Helper.createPointList(.26, -.56, .26, -0.16, .26, .24, .26, .64, .26, 1.04), points);
     }
 
     @Test
     public void testBresenhamVertical()
     {
         BresenhamLine.calcPoints(-.5, .5, 1, 0.5, emitter, 0, 0, 0.4, 0.6);
-//        assertEquals(Helper.createPointList(-.2, .3, 0.2, .3, 0.6, 0.3, 1.0, 0.3), points);
-        assertEquals(Helper.createPointList(-.4, .6, 0, .6, 0.4, 0.6, .8, .6, 1.2, 0.6), points);
+        assertEquals(Helper.createPointList(-0.36, .06, 0.04, 0.06, 0.44, 0.06, 0.84, 0.06), points);
     }
 
     @Test
@@ -106,11 +130,23 @@ public void set( double lat, double lon )
                 keys.add(keyAlgo.encode(lat, lon));
             }
         };
+        keys.clear();
+        BresenhamLine.calcPoints(.3, -.3, -0.2, 0.2, tmpEmitter, minLat, minLon,
+                deltaLat, deltaLon);
+        assertEquals(Arrays.asList(11L, 9L), keys);
+
+        keys.clear();
+        BresenhamLine.calcPoints(.3, -.1, -0.2, 0.4, tmpEmitter, minLat, minLon,
+                deltaLat, deltaLon);
+
+        // 11, 9, 12
+        assertEquals(Arrays.asList(11L, 12L), keys);
+
+        keys.clear();
         BresenhamLine.calcPoints(.5, -.5, -0.1, 0.9, tmpEmitter, minLat, minLon,
                 deltaLat, deltaLon);
-        // TODO Either 10, 11, 12 or 11, 12, 7 is correct but 10,9,7 is a minor incorrect encoding
-        assertEquals(Arrays.asList(10L, 9L, 7L), keys);
-//        assertEquals(Arrays.asList(11L, 12L, 7L), keys);
+        // precise: 10, 11, 14, 12
+        assertEquals(Arrays.asList(10L, 11L, 12L), keys);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
index 18259f4463..0b59bcb6c9 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
@@ -151,7 +151,7 @@ public void testLevelGraphBug()
         index.setResolution(100000);
         index.prepareIndex();
         // very close to 2, but should match the edge 0--1
-        TIntHashSet set = index.findNetworkEntries(0.51, 0.2);
+        TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
         TIntSet expectedSet = new TIntHashSet();
         expectedSet.add(1);
         expectedSet.add(2);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 863278f7a5..8fcb543aad 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -23,11 +23,10 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+import java.util.Arrays;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -49,9 +48,9 @@ public LocationIndexTree createIndex( Graph g, int resolution )
     public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTree idx = new LocationIndexTree(g, dir);
-        idx.setResolution(minMeter).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
+        tmpIDX.setResolution(minMeter).prepareIndex();
+        return tmpIDX;
     }
 
     @Override
@@ -109,8 +108,8 @@ public void testInMemIndex()
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
-        assertEquals(3, inMemIndex.getEntriesOf(0).size());
-        assertEquals(8, inMemIndex.getEntriesOf(1).size());
+        assertEquals(4, inMemIndex.getEntriesOf(0).size());
+        assertEquals(10, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
         // [LEAF 0 {} {0, 2}, LEAF 2 {} {0, 1}, LEAF 1 {} {2}, LEAF 3 {} {1}, LEAF 8 {} {0}, LEAF 10 {} {0}, LEAF 9 {} {0}, LEAF 4 {} {2}, LEAF 6 {} {0, 1, 2, 3}, LEAF 5 {} {0, 2, 3}, LEAF 7 {} {1, 2, 3}, LEAF 13 {} {1}]        
         // System.out.println(inMemIndex.getLayer(2));
@@ -120,11 +119,12 @@ public void testInMemIndex()
         // [LEAF 0 {2} {},    LEAF 2 {1} {},    LEAF 1 {2} {}, LEAF 3 {1} {}, LEAF 8 {0} {}, LEAF 10 {0} {}, LEAF 9 {0} {}, LEAF 4 {2} {}, LEAF 6 {0, 3} {},       LEAF 5 {0, 2, 3} {}, LEAF 7 {1, 2, 3} {}, LEAF 13 {1} {}]
         // System.out.println(inMemIndex.getLayer(2));
 
-        index.setSearchRegion(false);
         TIntHashSet set = new TIntHashSet();
         set.add(0);
-        assertEquals(set, index.findNetworkEntries(0.5, -0.5));
-        assertEquals(set, index.findNetworkEntries(-0.5, -0.9));
+        assertEquals(set, index.findNetworkEntries(0.5, -0.5, 2));
+        set.add(1);
+        set.add(2);
+        assertEquals(set, index.findNetworkEntries(-0.5, -0.9, 2));
         assertEquals(2, index.findID(-0.5, -0.9));
 
         // The optimization if(dist > normedHalf) => feed nodeA or nodeB
@@ -148,26 +148,25 @@ public void testInMemIndex2()
         index.setMinResolutionInMeter(500).prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
-        assertEquals(1, inMemIndex.getEntriesOf(0).size());
-        assertEquals(4, inMemIndex.getEntriesOf(1).size());
+        assertEquals(3, inMemIndex.getEntriesOf(0).size());
+        assertEquals(5, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
 
         index.dataAccess.create(10);
         inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
-        index.setSearchRegion(false);
 
         // 0
         assertEquals(2L, index.keyAlgo.encode(49.94653, 11.57114));
         // 1
         assertEquals(3L, index.keyAlgo.encode(49.94653, 11.57214));
         // 28
-        assertEquals(3L, index.keyAlgo.encode(49.95053, 11.57714));
+        assertEquals(6L, index.keyAlgo.encode(49.95053, 11.57714));
         // 29
         assertEquals(6L, index.keyAlgo.encode(49.95053, 11.57814));
         // 8
         assertEquals(1L, index.keyAlgo.encode(49.94553, 11.57214));
         // 34
-        assertEquals(9L, index.keyAlgo.encode(49.95153, 11.57714));
+        assertEquals(12L, index.keyAlgo.encode(49.95153, 11.57714));
 
         // Query near point 25 (49.95053, 11.57314).
         // If we would have a perfect compaction (takes a lot longer) we would
@@ -175,11 +174,8 @@ public void testInMemIndex2()
         // The other subnetwork is already perfect {26}.
         // For compaction see: https://github.com/graphhopper/graphhopper/blob/5594f7f9d98d932f365557dc37b4b2d3b7abf698/core/src/main/java/com/graphhopper/storage/index/Location2NodesNtree.java#L277
         TIntHashSet set = new TIntHashSet();
-        set.add(16);
-        set.add(26);
-        set.add(27);
-        set.add(28);
-        assertEquals(set, index.findNetworkEntries(49.950, 11.5732));
+        set.addAll(Arrays.asList(28, 27, 26, 24, 23, 21, 19, 18, 16, 14, 6, 5, 4, 3, 2, 1, 0));
+        assertEquals(set, index.findNetworkEntries(49.950, 11.5732, 1));
     }
 
     @Test
@@ -192,7 +188,7 @@ public void testInMemIndex3()
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
         assertEquals(33, inMemIndex.getEntriesOf(0).size());
-        assertEquals(59, inMemIndex.getEntriesOf(1).size());
+        assertEquals(69, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
 
         index.dataAccess.create(1024);
@@ -357,8 +353,8 @@ Graph createTestGraph2()
 
         // to create correct bounds
         // bottom left
-        na.setNode(100, 49.94053, 11.56614);
-        // bottom right
+        na.setNode(100, 49.941, 11.56614);
+        // top right
         na.setNode(101, 49.96053, 11.58814);
 
         graph.edge(0, 1, 10, true);
@@ -401,4 +397,38 @@ Graph createTestGraph2()
         graph.edge(28, 34, 10, true);
         return graph;
     }
+
+    @Test
+    public void testRMin()
+    {
+        Graph graph = createTestGraph();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.setMaxRegionSearch(1);
+        index.setMinResolutionInMeter(50000).prepareAlgo();
+
+        //query: 0.05 | -0.3
+        DistanceCalc distCalc = new DistancePlaneProjection();
+
+        double rmin = index.calculateRMin(0.05, -0.3);
+        double check = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLon(2)) - index.getDeltaLon(), -0.3, -0.3);
+
+        assertTrue((rmin - check) < 0.0001);
+
+        double rmin2 = index.calculateRMin(0.05, -0.3, 1);
+        double check2 = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLat(0)), -0.3, -0.3);
+
+        assertTrue((rmin2 - check2) < 0.0001);
+
+        TIntHashSet points = new TIntHashSet();
+        assertEquals(Double.MAX_VALUE, index.calcMinDistance(0.05, -0.3, points), 1e-1);
+
+        points.add(0);
+        points.add(1);
+        assertEquals(54757.03, index.calcMinDistance(0.05, -0.3, points), 1e-1);
+
+        /*GraphVisualizer gv = new GraphVisualizer(graph, index.getDeltaLat(), index.getDeltaLon(), index.getCenter(0, 0).lat, index.getCenter(0, 0).lon);
+         try {
+         Thread.sleep(4000);
+         } catch(InterruptedException ie) {}*/
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index 2291fa22f7..e47b52da9d 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -26,48 +26,45 @@
  */
 public class AngleCalcTest
 {
-    private final AngleCalc2D ac = new AngleCalc2D();
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testOrientation()
     {
-        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.0001);
-        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.0001);
-        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.0001);
-        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.0001);
-    }
-
-    @Test
-    public void testOrientationNorth()
-    {
-        assertEquals(0.0, Math.toDegrees(ac.calcOrientationNorth(0, 0, 10, 0)), 0.0001);
-        assertEquals(45.0, Math.toDegrees(ac.calcOrientationNorth(0, 0, 10, 10)), 0.0001);
-        assertEquals(90.0, Math.toDegrees(ac.calcOrientationNorth(0, 0, 0, 10)), 0.0001);
-        assertEquals(-135.0, Math.toDegrees(ac.calcOrientationNorth(0, 0, -10, -10)), 0.0001);
+        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.001);
+        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.001);
+        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.001);
+        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, 10)), 0.001);
+        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.001);
     }
 
     @Test
     public void testAlignOrientation()
     {
-        assertEquals(90.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(90))), 0.0001);
-        assertEquals(225.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(-135))), 0.0001);
-        assertEquals(-45.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(-45))), 0.0001);
-        assertEquals(-270.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(90))), 0.0001);
+        assertEquals(90.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(90))), 0.001);
+        assertEquals(225.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(-135))), 0.001);
+        assertEquals(-45.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(-45))), 0.001);
+        assertEquals(-270.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(90))), 0.001);
     }
 
     @Test
     public void testCombined()
     {
         double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
-        assertEquals(146.458, Math.toDegrees(ac.alignOrientation(0, orientation)), 0.001);
+        assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+
+        orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
+        assertEquals(-149.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
     }
 
     @Test
     public void testCalcAzimuth()
     {
-        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.0001);
-        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.0001);
-        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.0001);
+        assertEquals(45.0, ac.calcAzimuth(0, 0, 10, 10), 0.001);
+        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.001);
+        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.001);
+        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.001);
+        assertEquals(0.0, ac.calcAzimuth(49.942, 11.580, 49.944, 11.580), 0.001);
     }
 
     @Test
@@ -75,4 +72,19 @@ public void testAzimuthCompassPoint()
     {
         assertEquals("S", ac.azimuth2compassPoint(199));
     }
+
+    @Test
+    public void testAtan2()
+    {
+        // assertEquals(0, AngleCalc.atan2(0, 0), 1e-4);
+        // assertEquals(0, AngleCalc.atan2(-0.002, 0), 1e-4);
+        assertEquals(45, AngleCalc.atan2(5, 5) * 180 / Math.PI, 1e-2);
+        assertEquals(-45, AngleCalc.atan2(-5, 5) * 180 / Math.PI, 1e-2);
+        assertEquals(11.14, AngleCalc.atan2(1, 5) * 180 / Math.PI, 1);
+        assertEquals(180, AngleCalc.atan2(0, -5) * 180 / Math.PI, 1e-2);
+        assertEquals(-90, AngleCalc.atan2(-5, 0) * 180 / Math.PI, 1e-2);
+
+        assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
+        assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/XFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
similarity index 63%
rename from core/src/test/java/com/graphhopper/util/XFirstSearchTest.java
rename to core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index cb5b7fe1d6..80d48d7f28 100644
--- a/core/src/test/java/com/graphhopper/util/XFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -20,6 +20,8 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.Graph;
+import gnu.trove.list.TIntList;
+import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
@@ -29,10 +31,11 @@
  *
  * @author Peter Karich
  */
-public class XFirstSearchTest
+public class BreadthFirstSearchTest
 {
     int counter;
     TIntHashSet set = new TIntHashSet();
+    TIntList list = new TIntArrayList();
 
     @Before
     public void setup()
@@ -43,7 +46,7 @@ public void setup()
     @Test
     public void testBFS()
     {
-        XFirstSearch bfs = new XFirstSearch()
+        BreadthFirstSearch bfs = new BreadthFirstSearch()
         {
             @Override
             public boolean goFurther( int v )
@@ -51,6 +54,7 @@ public boolean goFurther( int v )
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
+                list.add(v);
                 return super.goFurther(v);
             }
         };
@@ -69,9 +73,42 @@ public boolean goFurther( int v )
         g.edge(9, 10, 8, true);
         g.edge(5, 10, 1, true);
 
-        bfs.start(g.createEdgeExplorer(), 0, false);
+        bfs.start(g.createEdgeExplorer(), 0);
 
         assertTrue(counter > 0);
         assertEquals(g.getNodes(), counter);
+        assertEquals("{0, 5, 3, 2, 1, 10, 8, 7, 6, 9, 4}", list.toString());
     }
+    
+    @Test
+    public void testBFS2()
+    {
+        BreadthFirstSearch bfs = new BreadthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+
+        Graph g = new GraphBuilder(new EncodingManager("CAR")).create();
+        g.edge(1, 2, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(3, 4, 1, false);
+        g.edge(1, 5, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 4, 1, false);
+
+        bfs.start(g.createEdgeExplorer(), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
+    }
+
+    
 }
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
new file mode 100644
index 0000000000..9aa311807b
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2014 jan.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import gnu.trove.list.TIntList;
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.set.hash.TIntHashSet;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author jan
+ */
+public class DepthFirstSearchTest {
+    
+    int counter;
+    TIntHashSet set = new TIntHashSet();
+    TIntList list = new TIntArrayList();
+
+    @Before
+    public void setup()
+    {
+        counter = 0;
+    }
+    
+    @Test
+    public void testDFS1()
+    {
+        DepthFirstSearch dfs = new DepthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+        
+        EncodingManager em = new EncodingManager("CAR");
+        FlagEncoder fe = em.getEncoder("CAR");
+        Graph g = new GraphBuilder(em).create();
+        g.edge(1, 2, 1, false);
+        g.edge(1, 5, 1, false);
+        g.edge(1, 4, 1, false);       
+        g.edge(2, 3, 1, false);
+        g.edge(3, 4, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 4, 1, false);
+
+        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 2, 3, 4, 5, 6}", list.toString());
+    }
+    
+    @Test
+    public void testDFS2()
+    {
+        DepthFirstSearch dfs = new DepthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+        
+        EncodingManager em = new EncodingManager("CAR");
+        FlagEncoder fe = em.getEncoder("CAR");
+        Graph g = new GraphBuilder(em).create();
+        g.edge(1, 2, 1, false);
+        g.edge(1, 4, 1, true);
+        g.edge(1, 3, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(4, 3, 1, true);
+
+        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 2, 3, 4}", list.toString());
+    }
+    
+}
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 3f12d3d8e3..4c8f3b0928 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -130,6 +130,9 @@ public void testValidEdgeDistance()
         assertFalse(dc.validEdgeDistance(49.944482, 11.555446, 49.937964, 11.541824, 49.942272, 11.555643));
         // right bottom of the edge
         assertFalse(dc.validEdgeDistance(49.94085, 11.557356, 49.937964, 11.541824, 49.942272, 11.555643));
+
+        // rounding error
+        // assertFalse(dc.validEdgeDistance(0.001, 0.001, 0.001, 0.002, 0.00099987, 0.00099987));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 88b4702d2e..a9a8e09991 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -68,8 +68,8 @@ public void testSort()
         NodeAccess na = newG.getNodeAccess();
         assertEquals(0, na.getLatitude(0), 1e-4); // 0
         assertEquals(2.5, na.getLatitude(1), 1e-4); // 1
-        assertEquals(4.6, na.getLatitude(2), 1e-4); // 8
-        assertEquals(4.5, na.getLatitude(3), 1e-4); // 2                
+        assertEquals(4.5, na.getLatitude(2), 1e-4); // 2
+        assertEquals(4.6, na.getLatitude(3), 1e-4); // 8                
         assertEquals(3.0, na.getLatitude(4), 1e-4); // 3
         assertEquals(5.0, na.getLatitude(5), 1e-4); // 7
         assertEquals(4.2, na.getLatitude(6), 1e-4); // 5
@@ -85,8 +85,8 @@ public void testSort2()
         NodeAccess na = newG.getNodeAccess();
         assertEquals(0, na.getLatitude(0), 1e-4); // 0
         assertEquals(2.5, na.getLatitude(1), 1e-4); // 1
-        assertEquals(4.6, na.getLatitude(2), 1e-4); // 8
-        assertEquals(4.5, na.getLatitude(3), 1e-4); // 2        
+        assertEquals(4.5, na.getLatitude(2), 1e-4); // 2
+        assertEquals(4.6, na.getLatitude(3), 1e-4); // 8        
     }
 
     @Test
@@ -111,7 +111,7 @@ public void testCopyWithSelfRef()
         LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().getMaxId(), lg.getAllEdges().getMaxId());
+        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
     }
 
     @Test
@@ -151,4 +151,20 @@ public void testCopy()
         assertEquals("01", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
         assertFalse(iter.next());
     }
+
+    @Test
+    public void testEdgeStuff()
+    {
+        assertEquals(6, GHUtility.createEdgeKey(1, 2, 3, false));
+        assertEquals(7, GHUtility.createEdgeKey(2, 1, 3, false));
+        assertEquals(7, GHUtility.createEdgeKey(1, 2, 3, true));
+        assertEquals(6, GHUtility.createEdgeKey(2, 1, 3, true));
+
+        assertEquals(8, GHUtility.createEdgeKey(1, 2, 4, false));
+        assertEquals(9, GHUtility.createEdgeKey(2, 1, 4, false));
+
+        assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
+        assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(2, 1, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
+        assertFalse(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 5, false)));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 74538a6243..26c942a3db 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -42,6 +42,13 @@ public void tearDown()
         Helper.removeDir(new File("test"));
     }
 
+    @Test
+    public void testCountBitValue() throws Exception
+    {
+        assertEquals(2, Helper.countBitValue(4));
+        assertEquals(5, Helper.countBitValue(20));
+    }
+
     @Test
     public void testUnzip() throws Exception
     {
@@ -63,4 +70,20 @@ public void testGetLocale() throws Exception
         assertEquals(Locale.ENGLISH, Helper.getLocale("en"));
         assertEquals(Locale.US, Helper.getLocale("en_US"));
     }
+
+    @Test
+    public void testRound()
+    {
+        assertEquals(100.94, Helper.round(100.94, 2), 1e-7);
+        assertEquals(100.9, Helper.round(100.94, 1), 1e-7);
+        assertEquals(101.0, Helper.round(100.95, 1), 1e-7);
+    }
+
+    @Test
+    public void testKeepIn()
+    {
+        assertEquals(2, Helper.keepIn(2, 1, 4), 1e-2);
+        assertEquals(3, Helper.keepIn(2, 3, 4), 1e-2);
+        assertEquals(3, Helper.keepIn(-2, 3, 4), 1e-2);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 2fff266992..37a8897487 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -17,21 +17,29 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.NodeAccess;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+import java.io.*;
 import java.util.*;
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.xml.sax.SAXException;
 
 /**
  *
@@ -39,8 +47,11 @@
  */
 public class InstructionListTest
 {
-    TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final Translation usTR = trMap.getWithFallBack(Locale.US);
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
 
+    @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
     {
@@ -90,25 +101,21 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions();
-        List<String> tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.CANADA)));
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
-                "Turn left onto 7-8", "Continue onto 8-9", "Turn right onto road", "Finish!"),
+                "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
-        tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.GERMAN)));
+        wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
-                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen auf Strasse", "Ziel erreicht!"),
+                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
-        List<String> distStrings = wayList.createDistances(trMap.get("de"), false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"),
-                distStrings);
-        distStrings = wayList.createDistances(trMap.get("en_US"), true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"),
-                distStrings);
+
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
         // check order of tower nodes        
@@ -124,18 +131,24 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(6, 2);
+        FlagEncoder carEncoder = carManager.getSingle();
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
-        wayList = p.calcInstructions();
-        tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.CANADA)));
+
+        wayList = p.calcInstructions(usTR);
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 6-7", "Continue onto 7-8", "Turn left onto 5-8", "Continue onto 5-2", "Finish!"),
                 tmpList);
 
-        // assertEquals(Arrays.asList(0, 1, 4, 5, 6), wayList.createPointIndices());
-        // tmpList = createList(p.calcPoints(), wayList.createPointIndices());
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.1), asL(1d, 1.2), asL(1.1, 1.2), asL(1.2, 1.2)),
                 wayList.createStartPoints());
+
+        // special case of identical start and end
+        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 0);
+        wayList = p.calcInstructions(usTR);
+        assertEquals(1, wayList.size());
+        assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
@@ -215,15 +228,16 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(2, 3);
-        InstructionList wayList = p.calcInstructions();
-        List<String> tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.CANADA)));
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(3, 5);
-        wayList = p.calcInstructions();
-        tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.CANADA)));
+        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        wayList = p.calcInstructions(usTR);
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
                 tmpList);
     }
@@ -254,9 +268,9 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(2, 3);
-        InstructionList wayList = p.calcInstructions();
-        List<String> tmpList = pick("text", wayList.createJson(trMap.getWithFallBack(Locale.CANADA)));
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
     }
 
@@ -282,8 +296,8 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions();
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
         List<GPXEntry> gpxList = wayList.createGPXList();
@@ -310,34 +324,116 @@ public void testInstructionsWithTimeAndPlace()
         assertEquals(9.9, wayList.get(3).getFirstLon(), 1e-3);
 
         String gpxStr = wayList.createGPX("test", 0, "GMT+1");
+        verifyGPX(gpxStr);
 
         assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T01:00:00+01:00</time>"));
         assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
         assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<distance>8000</distance>"));
-        assertTrue(gpxStr, gpxStr.contains("<desc>left 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
+
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+    }
+
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
 
-        // assertTrue(gpxStr, gpxStr.contains("<direction>W</direction>"));
-        // assertTrue(gpxStr, gpxStr.contains("<turn-angle>-90</turn-angle>"));
-        // assertTrue(gpxStr, gpxStr.contains("<azimuth>270</azimuth/>"));
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                                                                 new InstructionAnnotation(0, ""), pl)
+                                          .setDirOfRotation(-0.1)
+                                          .setRadian(-Math.PI+1)
+                                          .setExitNumber(2)
+                                          .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);        
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135,13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals("null", json.get("turn_angle").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+    
+    @Test
+    public void testCreateGPXWithEle()
+    {
+        final List<GPXEntry> fakeList = new ArrayList<GPXEntry>();
+        fakeList.add(new GPXEntry(12, 13, 0));
+        fakeList.add(new GPXEntry(12.5, 13, 1000));
+        InstructionList il = new InstructionList(usTR)
+        {
+            @Override
+            public List<GPXEntry> createGPXList()
+            {
+                return fakeList;
+            }
+        };
+        String gpxStr = il.createGPX("test", 0, "GMT");
+        verifyGPX(gpxStr);
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+        assertFalse(gpxStr, gpxStr.contains("<ele>"));
+
+        fakeList.clear();
+        fakeList.add(new GPXEntry(12, 13, 11, 0));
+        fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
+        gpxStr = il.createGPX("test", 0, "GMT", true);
+
+        assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
     @Test
     public void testCreateGPX()
     {
-        InstructionList instructions = new InstructionList();
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        InstructionList instructions = new InstructionList(usTR);
         PointList pl = new PointList();
         pl.add(49.942576, 11.580384);
         pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, pl).setDistance(240).setTime(15000));
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
 
         pl = new PointList();
         pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", 0, 0, pl).setDistance(25).setTime(4000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
 
         pl = new PointList();
         pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", 0, 0, pl).setDistance(25).setTime(3000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
         instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
 
         List<GPXEntry> result = instructions.createGPXList();
@@ -348,6 +444,8 @@ public void testCreateGPX()
         assertEquals(15000, result.get(2).getMillis());
         assertEquals(19000, result.get(3).getMillis());
         assertEquals(22000, result.get(4).getMillis());
+
+        verifyGPX(instructions.createGPX());
     }
 
     private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour )
@@ -363,17 +461,33 @@ public void testEmptyList()
     {
         EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting()).calcPath(0, 1);
-        InstructionList il = p.calcInstructions();
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
     }
 
-    @Test
-    public void testRound()
+    public void verifyGPX( String gpx )
     {
-        assertEquals(100.94, InstructionList.round(100.94, 2), 1e-7);
-        assertEquals(100.9, InstructionList.round(100.94, 1), 1e-7);
-        assertEquals(101.0, InstructionList.round(100.95, 1), 1e-7);
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Schema schema = null;
+        try
+        {
+            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
+            schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
+        } catch (SAXException e1)
+        {
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
+        }
+        Validator validator = schema.newValidator();
+        try
+        {
+            validator.validate(new StreamSource(new StringReader(gpx)));
+        } catch (Exception e)
+        {
+            throw new RuntimeException(e);
+        }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index f34b17f4bb..f65170813b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -25,53 +25,50 @@
  * @author Johannes Pelzer
  */
 public class InstructionTest
-{   
+{
     @Test
-    public void testGetAzimuthAndGetDirection() {
+    public void testCalcAzimuthAndGetDirection()
+    {
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
-        pl.add(49.942, 11.582);
-        Instruction i1 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, pl).setDistance(240).setTime(15000);
         
-        assertEquals("270", i1.getAzimuth(null));
-        assertEquals("W", i1.getDirection(null));
+        PointList nextPl = new PointList();
+        nextPl.add(49.942, 11.582);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
+
+        assertEquals(270, currI.calcAzimuth(nextI), .1);
+        assertEquals("W", currI.calcDirection(nextI));
 
-        
         PointList p2 = new PointList();
         p2.add(49.942, 11.580);
         p2.add(49.944, 11.582);
-        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, p2).setDistance(240).setTime(15000);
-        
-        assertEquals("45", i2.getAzimuth(null));
-        assertEquals("NE", i2.getDirection(null));
-        
-        
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
+
+        assertEquals(45, i2.calcAzimuth(null), .1);
+        assertEquals("NE", i2.calcDirection(null));
+
         PointList p3 = new PointList();
         p3.add(49.942, 11.580);
         p3.add(49.944, 11.580);
-        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, p3).setDistance(240).setTime(15000);
-        
-        
-        assertEquals("0", i3.getAzimuth(null));
-        assertEquals("N", i3.getDirection(null));
-        
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
+
+        assertEquals(0, i3.calcAzimuth(null), .1);
+        assertEquals("N", i3.calcDirection(null));
+
         PointList p4 = new PointList();
         p4.add(49.940, 11.580);
         p4.add(49.920, 11.586);
-        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, p4).setDistance(240).setTime(15000);
-        
-        
-        
-        assertEquals("S", i4.getDirection(null));
- 
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
+
+        assertEquals("S", i4.calcDirection(null));
+
         PointList p5 = new PointList();
         p5.add(49.940, 11.580);
-        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, p5).setDistance(240).setTime(15000);
-        
-        assertEquals(null, i5.getAzimuth(null));
-        assertEquals(null, i5.getDirection(null));
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
+
+        assertTrue(Double.isNaN(i5.calcAzimuth(null)));
+        assertEquals("", i5.calcDirection(null));
     }
-    
-    
-    
 }
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index f3187631cd..f5314e557f 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -80,7 +80,7 @@ public void testAddPL()
         instance.add(toAdd);
 
         assertEquals(12, instance.getSize());
-        assertEquals(20, instance.getCapacity());
+        assertEquals(24, instance.getCapacity());
 
         for (int i = 0; i < toAdd.size(); i++)
         {
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 0e66e5fc8d..8103d03698 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.util.TranslationMap.Translation;
 import java.util.Locale;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -37,19 +36,26 @@ public void testToString()
         Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
         assertEquals("continue onto blp street", enMap.tr("continue_onto", "blp street"));
 
-        Translation deMap = SINGLETON.getWithFallBack(Locale.GERMANY);
-        assertEquals("Zu Fu", deMap.tr("web.FOOT"));
+        Translation trMap = SINGLETON.getWithFallBack(Locale.GERMANY);
+        assertEquals("Zu Fu", trMap.tr("web.FOOT"));
 
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("", ruMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de_DE");
-        assertEquals("Zu Fu", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de_DE");
+        assertEquals("Zu Fu", trMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de");
-        assertEquals("Zu Fu", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de");
+        assertEquals("Zu Fu", trMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de_AT");
-        assertEquals("Zu Fu", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de_AT");
+        assertEquals("Zu Fu", trMap.tr("web.FOOT"));
+
+        trMap = SINGLETON.get("he");
+        assertEquals("", trMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("iw");
+        assertEquals("", trMap.tr("web.FOOT"));
+
+        // indonesia assertEquals("in", new Locale("id").getLanguage());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index 3c08212aa1..e8847d47fd 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -27,15 +27,5 @@
  */
 public class CoordTrigTest
 {
-    @Test
-    public void testIsValid()
-    {
-        CoordTrig instance = new CoordTrig();
-        assertFalse(instance.isValid());
-        instance.lat = 1;
-        assertFalse(instance.isValid());
-        instance.lon = 1;
-        assertTrue(instance.isValid());
-    }
 
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
new file mode 100644
index 0000000000..aa8c97562e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -0,0 +1,49 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.shapes;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GHPoint3DTest
+{
+    @Test
+    public void testEquals()
+    {
+        GHPoint3D point1 = new GHPoint3D(1, 2, Double.NaN);
+        GHPoint3D point2 = new GHPoint3D(1, 2, Double.NaN);
+        assertEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2, 0);
+        point2 = new GHPoint3D(1, 2, 1);
+        assertNotEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2, 0);
+        point2 = new GHPoint3D(1, 2.1, 0);
+        assertNotEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2.1, 0);
+        point2 = new GHPoint3D(1, 2.1, 0);
+        assertEquals(point1, point2);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
new file mode 100644
index 0000000000..6adac39794
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.shapes;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GHPointTest
+{
+    @Test
+    public void testIsValid()
+    {
+        GHPoint instance = new GHPoint();
+        assertFalse(instance.isValid());
+        instance.lat = 1;
+        assertFalse(instance.isValid());
+        instance.lon = 1;
+        assertTrue(instance.isValid());
+    }
+}
diff --git a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
index c049547376..0b27af2da6 100644
--- a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
+++ b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
@@ -11,29 +11,36 @@
       (2,3)->(3,4): straight_only
       (4,3)->(3,8): no_right_turn
       (4,5)->(5,6): right_turn_only
-      (6,1)->(1,5): no_u_turn
+      (6,1)->(1,6): no_u_turn
+    -->
+    
+   <!-- 
+       bike only
+       
+       10~~11~~12
+       |   |   |
+       13~~14~~15
+       
+       
+      (10,11)->(11,14): no_right_turn
     -->
 
-
-    <node id="1" lat="50" lon="10">
-    </node>
-    <node id="2" lat="52" lon="10">
-    </node>
-    <node id="3" lat="52" lon="11">
-    </node>
-    <node id="4" lat="52" lon="12">
-    </node>
-    <node id="5" lat="50" lon="12">
-    </node>
-    <node id="6" lat="51" lon="11">
-    </node>
-    <node id="7" lat="54" lon="12">
-    </node>
-    <node id="8" lat="54" lon="11">
-    </node>
-    <node id="9" lat="54" lon="10">
-    </node>
+    <node id="1" lat="50" lon="10"> </node>
+    <node id="2" lat="52" lon="10"> </node>
+    <node id="3" lat="52" lon="11"> </node>
+    <node id="4" lat="52" lon="12"> </node>
+    <node id="5" lat="50" lon="12"> </node>
+    <node id="6" lat="51" lon="11"> </node>
+    <node id="7" lat="54" lon="12"> </node>
+    <node id="8" lat="54" lon="11"> </node>
+    <node id="9" lat="54" lon="10"> </node>
     
+    <node id="10" lat="40" lon="10"></node>    
+    <node id="11" lat="40" lon="11"></node>    
+    <node id="12" lat="40" lon="12"></node>
+    <node id="13" lat="39" lon="10"></node>
+    <node id="14" lat="39" lon="11"></node>
+    <node id="15" lat="39" lon="12"></node>    
                       
     <!-- 1-2 -->
     <way id="12">
@@ -105,6 +112,54 @@
         <tag k="highway" v="motorway" />
     </way>
     
+    <way id="510">
+        <nd ref="5"/>     
+        <nd ref="10"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1011">
+        <nd ref="10"/>     
+        <nd ref="11"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1112">
+        <nd ref="11"/>     
+        <nd ref="12"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1013">
+        <nd ref="10"/>     
+        <nd ref="13"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1114">
+        <nd ref="11"/>     
+        <nd ref="14"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1215">
+        <nd ref="12"/>     
+        <nd ref="15"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1314">
+        <nd ref="13"/>     
+        <nd ref="14"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1415">
+        <nd ref="14"/>     
+        <nd ref="15"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+        
     <relation id="1001">
         <member type="way" ref="23" role="from"/>
         <member type="way" ref="34" role="to"/>
@@ -112,7 +167,7 @@
         <tag k="restriction" v="only_straight_on"/>
         <tag k="type" v="restriction"/>
     </relation>
-    
+        
     <relation id="1002">
         <member type="way" ref="34" role="from"/>
         <member type="way" ref="38" role="to"/>
@@ -131,10 +186,18 @@
     
     <relation id="1004">
         <member type="way" ref="61" role="from"/>
-        <member type="way" ref="51" role="to"/>
+        <member type="way" ref="61" role="to"/>
         <member type="node" ref="1" role="via"/>
         <tag k="restriction" v="no_u_turn"/>
         <tag k="type" v="restriction"/>
     </relation>
     
+    <relation id="1005">
+        <member type="way" ref="1011" role="from"/>
+        <member type="way" ref="1114" role="to"/>
+        <member type="node" ref="11" role="via"/>
+        <tag k="restriction" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+    
 </osm>
diff --git a/core/src/test/resources/com/graphhopper/routing/test-graph.svg b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
index b08e85183c..c9c1adc45e 100644
--- a/core/src/test/resources/com/graphhopper/routing/test-graph.svg
+++ b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
@@ -2,184 +2,338 @@
 <!-- Created with Inkscape (http://www.inkscape.org/) -->
 
 <svg
-    xmlns:dc="http://purl.org/dc/elements/1.1/"
-    xmlns:cc="http://creativecommons.org/ns#"
-    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-    xmlns:svg="http://www.w3.org/2000/svg"
-    xmlns="http://www.w3.org/2000/svg"
-    xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-    xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-    width="210mm"
-    height="297mm"
-    id="svg2"
-    version="1.1"
-    inkscape:version="0.48.0 r9654"
-    sodipodi:docname="wikipedia-graph.svg">
-    <defs
-        id="defs4" />
-    <sodipodi:namedview
-        id="base"
-        pagecolor="#ffffff"
-        bordercolor="#666666"
-        borderopacity="1.0"
-        inkscape:pageopacity="0.0"
-        inkscape:pageshadow="2"
-        inkscape:zoom="1.4"
-        inkscape:cx="176.76414"
-        inkscape:cy="898.21698"
-        inkscape:document-units="px"
-        inkscape:current-layer="layer1"
-        showgrid="false"
-        inkscape:window-width="789"
-        inkscape:window-height="678"
-        inkscape:window-x="740"
-        inkscape:window-y="60"
-        inkscape:window-maximized="0" />
-    <metadata
-        id="metadata7">
-        <rdf:RDF>
-            <cc:Work
-                rdf:about="">
-                <dc:format>image/svg+xml</dc:format>
-                <dc:type
-                    rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-                <dc:title></dc:title>
-            </cc:Work>
-        </rdf:RDF>
-    </metadata>
-    <g
-        inkscape:label="Ebene 1"
-        inkscape:groupmode="layer"
-        id="layer1">
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 49.684603,95.607751 39.395949,40.189332 178.797,75.544671"
-            id="path2985"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 50.507627,95.747722 179.80715,74.534519"
-            id="path2987"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="32.324883"
-            y="33.118263"
-            id="text2989"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2991"
-            x="32.324883"
-            y="33.118263">0</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="25.766541"
-            y="114.74118"
-            id="text2993"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2995"
-            x="25.766541"
-            y="114.74118">1</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="176.82745"
-            y="65.768753"
-            id="text2997"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2999"
-            x="176.82745"
-            y="65.768753">4</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="180.27634"
-            y="163.46999"
-            id="text3001"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3003"
-            x="180.27634"
-            y="163.46999">5</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="149.85793"
-            y="212.35471"
-            id="text3005"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3007"
-            x="149.85793"
-            y="212.35471">2</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 179.80715,127.06245 c 0,0 -125.258913,-30.304575 -129.299523,-30.304575 L 176.7767,183.63099 z"
-            id="path3009"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 174.75639,182.62084 278.8021,145.2452"
-            id="path3011"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="272.74118"
-            y="176.55992"
-            id="text3013"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3015"
-            x="272.74118"
-            y="176.55992">3</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 180.81731,127.06245 95.96449,19.1929 81.82235,-50.507628"
-            id="path3017"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 178.797,126.0523 0,-50.507629 96.97464,-7.071068"
-            id="path3019"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="267.69043"
-            y="56.351772"
-            id="text3021"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3023"
-            x="267.69043"
-            y="56.351772">6</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="361.63461"
-            y="82.615738"
-            id="text3025"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3027"
-            x="361.63461"
-            y="82.615738">7</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 276.7818,68.473603 178.61317,127.18501 356.58385,95.747722"
-            id="path3029"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 275.71429,68.790753 81.42857,26.428571"
-            id="path3031"
-            inkscape:connector-curvature="0" />
-    </g>
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="test-graph.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="0.98994949"
+     inkscape:cx="186.32012"
+     inkscape:cy="855.76121"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="1600"
+     inkscape:window-height="1136"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 49.684603,95.607751 39.395949,40.189332 178.797,75.544671"
+       id="path2985"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 50.507627,95.747722 179.80715,74.534519"
+       id="path2987"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="32.324883"
+       y="33.118263"
+       id="text2989"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2991"
+         x="32.324883"
+         y="33.118263">0</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="25.766541"
+       y="114.74118"
+       id="text2993"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2995"
+         x="25.766541"
+         y="114.74118">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="176.82745"
+       y="65.768753"
+       id="text2997"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2999"
+         x="176.82745"
+         y="65.768753">4</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="181.28648"
+       y="156.39893"
+       id="text3001"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3003"
+         x="181.28648"
+         y="156.39893">5</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="149.85793"
+       y="212.35471"
+       id="text3005"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3007"
+         x="149.85793"
+         y="212.35471">2</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 179.80715,127.06245 c 0,0 -125.258913,-30.304575 -129.299523,-30.304575 L 176.7767,183.63099 z"
+       id="path3009"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 174.75639,182.62084 278.8021,145.2452"
+       id="path3011"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="272.74118"
+       y="176.55992"
+       id="text3013"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3015"
+         x="272.74118"
+         y="176.55992">3</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 180.81731,127.06245 95.96449,19.1929 81.82235,-50.507628"
+       id="path3017"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 178.797,126.0523 0,-50.507629 96.97464,-7.071068"
+       id="path3019"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="267.69043"
+       y="56.351772"
+       id="text3021"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3023"
+         x="267.69043"
+         y="56.351772">6</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="361.63461"
+       y="82.615738"
+       id="text3025"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3027"
+         x="361.63461"
+         y="82.615738">7</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 276.7818,68.473603 178.61317,127.18501 356.58385,95.747722"
+       id="path3029"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 275.71429,68.790753 81.42857,26.428571"
+       id="path3031"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="104.04571"
+       y="51.30101"
+       id="text3006"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3008"
+         x="104.04571"
+         y="51.30101">(111)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="47.477169"
+       y="67.463455"
+       id="text3010"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3012"
+         x="47.477169"
+         y="67.463455">(111)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="97.984795"
+       y="81.605591"
+       id="text3014"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3016"
+         x="97.984795"
+         y="81.605591">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="119.19799"
+       y="111.91016"
+       id="text3018"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3020"
+         x="119.19799"
+         y="111.91016">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="86.873123"
+       y="153.32642"
+       id="text3022"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3024"
+         x="86.873123"
+         y="153.32642">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="147.48227"
+       y="157.36703"
+       id="text3026"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3028"
+         x="147.48227"
+         y="157.36703">(22)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="215.16249"
+       y="180.60054"
+       id="text3030"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3032"
+         x="215.16249"
+         y="180.60054">(57)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="228.29448"
+       y="136.15382"
+       id="text3034"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3036"
+         x="228.29448"
+         y="136.15382">(70)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="309.10669"
+       y="137.16399"
+       id="text3038"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3040"
+         x="309.10669"
+         y="137.16399">(70)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="268.70059"
+       y="105.84925"
+       id="text3042"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3044"
+         x="268.70059"
+         y="105.84925">(79)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="208.09143"
+       y="95.747719"
+       id="text3046"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3048"
+         x="208.09143"
+         y="95.747719">(79)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="153.54318"
+       y="102.81879"
+       id="text3050"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3052"
+         x="153.54318"
+         y="102.81879">(101)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="221.2234"
+       y="66.4533"
+       id="text3054"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3056"
+         x="221.2234"
+         y="66.4533">(101)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="307.08636"
+       y="75.544678"
+       id="text3058"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3060"
+         x="307.08636"
+         y="75.544678">(103)</tspan></text>
+  </g>
 </svg>
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
new file mode 100644
index 0000000000..58cfdeb1ba
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
@@ -0,0 +1,789 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xsd:schema
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+    xmlns="http://www.topografix.com/GPX/1/1"
+    targetNamespace="http://www.topografix.com/GPX/1/1"    
+    elementFormDefault="qualified">
+
+    <xsd:annotation>
+        <xsd:documentation>
+            GPX schema version 1.1 - For more information on GPX and this schema, visit http://www.topografix.com/gpx.asp
+
+            GPX uses the following conventions: all coordinates are relative to the WGS84 datum.  All measurements are in metric units.
+        </xsd:documentation>
+    </xsd:annotation>
+
+    <xsd:element name="gpx"	type="gpxType">
+        <xsd:annotation>
+            <xsd:documentation>
+                GPX is the root element in the XML file.
+            </xsd:documentation>
+        </xsd:annotation>
+    </xsd:element>
+
+    <xsd:complexType name="gpxType">
+        <xsd:annotation>
+            <xsd:documentation>
+                GPX documents contain a metadata header, followed by waypoints, routes, and tracks.  You can add your own elements
+                to the extensions section of the GPX document.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="metadata"	type="metadataType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Metadata about the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="wpt"			type="wptType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of waypoints.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="rte"			type="rteType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of routes.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="trk"			type="trkType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of tracks.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+
+        <xsd:attribute name="version" type="xsd:string" use="required" fixed="1.1">
+            <xsd:annotation>
+                <xsd:documentation>
+                    You must include the version number in your GPX document.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="creator" type="xsd:string" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    You must include the name or URL of the software that created your GPX document.  This allows others to
+                    inform the creator of a GPX instance document that fails to validate.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="metadataType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Information about the GPX file, author, and copyright restrictions goes in the metadata section.  Providing rich,
+                meaningful information about your GPX files allows others to search for and use your GPS data.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The name of the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A description of the contents of the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="author"		type="personType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The person or organization who created the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="copyright"	type="copyrightType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Copyright and license information governing use of the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"		type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        URLs associated with the location described in the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The creation date of the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="keywords"	type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Keywords associated with the file.  Search engines or databases can use this information to classify the data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="bounds"		type="boundsType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Minimum and maximum coordinates which describe the extent of the coordinates in the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="wptType">
+        <xsd:annotation>
+            <xsd:documentation>
+                wpt represents a waypoint, point of interest, or named feature on a map.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <!-- Position info -->
+            <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Elevation (in meters) of the point.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"			type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Creation/modification timestamp for element. Date and time in are in Univeral Coordinated Time (UTC), not local time! Conforms to ISO 8601 specification for date/time representation. Fractional seconds are allowed for millisecond timing in tracklogs. 
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="magvar"		type="degreesType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Magnetic variation (in degrees) at the point
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="geoidheight"	type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Height (in meters) of geoid (mean sea level) above WGS84 earth ellipsoid.  As defined in NMEA GGA message.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <!-- Description info -->
+            <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The GPS name of the waypoint. This field will be transferred to and from the GPS. GPX does not place restrictions on the length of this field or the characters contained in it. It is up to the receiving application to validate the field before sending it to the GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS waypoint comment. Sent to GPS as comment. 
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A text description of the element. Holds additional information about the element intended for the user, not the GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.  "Garmin eTrex", "USGS quad Boston North", e.g.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to additional information about the waypoint.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="sym"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text of GPS symbol name. For interchange with other programs, use the exact spelling of the symbol as displayed on the GPS.  If the GPS abbreviates words, spell them out.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of the waypoint.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <!-- Accuracy info -->
+            <xsd:element name="fix"			type="fixType"			minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type of GPX fix.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="sat"			type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Number of satellites used to calculate the GPX fix.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="hdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Horizontal dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="vdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Vertical dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="pdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Position dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="ageofdgpsdata"	type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Number of seconds since last DGPS update.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="dgpsid"		type="dgpsStationType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        ID of DGPS station used in differential correction.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+
+        <xsd:attribute name="lat"			type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="lon"			type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The longitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="rteType">
+        <xsd:annotation>
+            <xsd:documentation>
+                rte represents route - an ordered list of waypoints representing a series of turn points leading to a destination.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="name"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS name of route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS comment for route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text description of route for user.  Not sent to GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"		minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Links to external information about the route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS route number.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+ 
+            <xsd:element name="rtept"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of route points.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="trkType">
+        <xsd:annotation>
+            <xsd:documentation>
+                trk represents a track - an ordered list of points describing a path.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS name of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS comment for track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        User description of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Links to external information about track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS track number.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+  
+            <xsd:element name="trkseg"		type="trksegType"		minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+ 
+    <xsd:complexType name="extensionsType">
+        <xsd:annotation>
+            <xsd:documentation>
+                You can add extend GPX by adding your own elements from another schema here.
+            </xsd:documentation>
+        </xsd:annotation>
+        <!-- as we need separate namespace 'gh' could not get it working with proper validation :( so ignoring this for now-->
+        <xsd:sequence>
+            <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:any>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="trksegType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="trkpt"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A Track Point holds the coordinates, elevation, timestamp, and metadata for a single point in a track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="copyrightType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Information about the copyright holder and any license governing use of this file.  By linking to an appropriate license,
+                you may place your data into the public domain or grant additional usage rights.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="year"		type="xsd:gYear"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Year of copyright.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="license"		type="xsd:anyURI"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to external file containing license text.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="author" type="xsd:string" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    Copyright holder (TopoSoft, Inc.)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="linkType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A link to an external resource (Web page, digital photo, video clip, etc) with additional information.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="text"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text of hyperlink.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Mime type of content (image/jpeg)
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="href" type="xsd:anyURI" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    URL of hyperlink.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="emailType">
+        <xsd:annotation>
+            <xsd:documentation>
+                An email address.  Broken into two parts (id and domain) to help prevent email harvesting.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:attribute name="id"			type="xsd:string"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    id half of email address (billgates2004)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="domain"		type="xsd:string"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    domain half of email address (hotmail.com)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="personType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A person or organization.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Name of person or organization.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="email"		type="emailType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Email address.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"		type="linkType"			minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to Web site or other external information about person.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="ptType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A geographic point with optional elevation and time.  Available for use by other schemas.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The elevation (in meters) of the point.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The time that the point was recorded.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="lat"			type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  Decimal degrees, WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="lon"			type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  Decimal degrees, WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="ptsegType">
+        <xsd:annotation>
+            <xsd:documentation>
+                An ordered sequence of points.  (for polygons or polylines, e.g.)
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="pt"	type="ptType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Ordered list of geographic points.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="boundsType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Two lat/lon pairs defining the extent of an element.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:attribute name="minlat"		type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The minimum latitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="minlon"		type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The minimum longitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="maxlat"		type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The maximum latitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="maxlon"		type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The maximum longitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+
+    <xsd:simpleType name="latitudeType">
+        <xsd:annotation>
+            <xsd:documentation>
+                The latitude of the point.  Decimal degrees, WGS84 datum.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="-90.0"/>
+            <xsd:maxInclusive value="90.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="longitudeType">
+        <xsd:annotation>
+            <xsd:documentation>
+                The longitude of the point.  Decimal degrees, WGS84 datum.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="-180.0"/>
+            <xsd:maxExclusive value="180.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="degreesType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Used for bearing, heading, course.  Units are decimal degrees, true (not magnetic).
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="0.0"/>
+            <xsd:maxExclusive value="360.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="fixType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Type of GPS fix.  none means GPS had no fix.  To signify "the fix info is unknown, leave out fixType entirely. pps = military signal used
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:string">
+            <xsd:enumeration value="none"/>
+            <xsd:enumeration value="2d"/>
+            <xsd:enumeration value="3d"/>
+            <xsd:enumeration value="dgps"/>
+            <xsd:enumeration value="pps"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="dgpsStationType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Represents a differential GPS station.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:integer">
+            <xsd:minInclusive value="0"/>
+            <xsd:maxInclusive value="1023"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+</xsd:schema>
diff --git a/core/src/test/resources/log4j.properties b/core/src/test/resources/log4j.properties
deleted file mode 100644
index 0a4d4c5e06..0000000000
--- a/core/src/test/resources/log4j.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-# separate logging config to disable INFO
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %c - %m%n
-
-log4j.rootLogger=WARN
-
-log4j.logger.com.graphhopper=WARN, StdoutApp
diff --git a/core/src/test/resources/log4j.xml b/core/src/test/resources/log4j.xml
new file mode 100644
index 0000000000..a9bb71c09f
--- /dev/null
+++ b/core/src/test/resources/log4j.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>    
+    <logger name="com.graphhopper" additivity="false">
+        <level value="warn" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/docs/android/index.md b/docs/android/index.md
index 414c258f78..ae02db1b3a 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -13,12 +13,11 @@ $ cd graphhopper
 $ ./graphhopper.sh import your-area.pbf
 ```
 
-And go to the Android SDK Manager and install at least 2.2 (API 8)
+And go to the Android SDK Manager and install at least 2.3 (API 9)
 
 **Either via Maven and Command line -> use this for NetBeans**
- 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.2` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
- 2. Install Mapsforge in your local repository via the provided script `scripts/maven-install-mapsforge.sh` - see some [explanations/issues](https://github.com/graphhopper/graphhopper/issues/122)
- 3. Now do `./graphhopper.sh android`
+ 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
+ 2. Now do `./graphhopper.sh android`
 
 **Or Eclipse**
 
@@ -36,14 +35,41 @@ Now that you have a running android app you need to copy somehow the routing and
  2. Execute `./graphhopper.sh import <your-osm-file>`. This creates the routing data
  3. [Download a map](http://download.mapsforge.org/maps/) e.g. berlin.map
  4. Copy berlin.map into the created berlin-gh folder
- 5. Optional Compression Step: Bundle a graphhopper zip file via cd berlin-gh;zip -r berlin.ghz *
- 6. Now copy the berlin-gh folder from step 4 (or the .ghz file from step 5) to android /sdcard/graphhopper/maps - e.g. use [SSHDroid](https://play.google.com/store/apps/details?id=berserker.android.apps.sshdroid): scp -P 2222 berlin.ghz  root@$URL:/sdcard/graphhopper/maps/
+ 5. Optional Compression Step: Bundle a graphhopper zip file via `cd berlin-gh; zip -r berlin.ghz *`
+ 6. Now copy the berlin-gh folder from step 4 (or the .ghz file from step 5) to your Android device. /[download-folder]/graphhopper/maps, where the download-folder can e.g. be /mnt/sdcard/download or /storage/sdcard/Download/ - e.g. use [SSHDroid](https://play.google.com/store/apps/details?id=berserker.android.apps.sshdroid): `scp -P 2222 berlin.ghz root@$URL:/mnt/sdcard/download/graphhopper/maps/`
 
 ## Limitations
 
- * For now OSMReader does not work on Android due to some javax.xml dependencies. But you can simply create the graphhopper folder on your desktop and copy them to the Android storage.
+ * You have to create the graphhopper folder on your desktop and copy it to the Android storage.
+
+ * [A memory bound a* algoritm](http://en.wikipedia.org/wiki/SMA*) is not yet implemented so you can use disableShortcuts only for small routes.
+
+## Problems
+
+If you encounter problems like 'trouble writing output: Too many methods: 72332; max is 65536.' or you 
+want to reduce the size of the jar/apk size you can try to apply autojar on trove4j:
+
+```bash
+java -jar autojar-2.1/autojar.jar -o trove4j-stripped.jar -c $TROVE_SRC/target/classes @trove-class.list
+```
+
+where trove-class.list is a file with the required classes for GraphHopper as content:
+
+```text
+gnu.trove.list.TDoubleList.class
+gnu.trove.list.TIntList.class
+gnu.trove.list.array.TDoubleArrayList.class
+gnu.trove.list.array.TIntArrayList.class
+gnu.trove.map.TIntObjectMap.class
+gnu.trove.map.hash.TIntObjectHashMap.class
+gnu.trove.map.hash.TIntIntHashMap.class
+gnu.trove.set.hash.TIntHashSet.class
+gnu.trove.iterator.TIntIterator.class
+gnu.trove.procedure.TIntProcedure.class
+gnu.trove.procedure.TObjectProcedure.class
+gnu.trove.stack.array.TIntArrayStack.class
+```
 
- * [A memory bound a* algoritm](http://en.wikipedia.org/wiki/SMA*) is not yet implemented so you can use disableShortcuts only for small routes. Let me know if you need this!
 
 ## Example
 
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
new file mode 100644
index 0000000000..ff93ae5036
--- /dev/null
+++ b/docs/core/create-new-flagencoder.md
@@ -0,0 +1,29 @@
+# How to create new routing profile aka a new FlagEncoder?
+
+Copy e.g. a simple FlagEncoder like CarFlagEncoder or extend from it. Then change the toString method to a 
+different desired name.
+
+Make sure that it supports the required speed resolution via calling the appropriate (super) constructor. 
+E.g. speedBits means how many bits should reserved for the speed information, 
+the speedFactor means by which factor the speed should be devided before storing 
+(e.g. 5 for car and 1 for bikes for more precision).
+
+As a third step you need to tune the speeds for the different road types and surfaces. Maybe
+now it is time to write a first test for your new FlagEncoder.
+
+If you need to support two different speed values for one street (one edge) you need to create
+a separate EncodedDoubleValue instance (reverseSpeedEncoder) managing the reverse speed, 
+see Bike2WeightFlagEncoder for an example. You'll have to overwrite the following methods:
+
+ * setReverseSpeed, getReverseSpeed to use the reverseSpeedEncoder
+ * handleSpeed, to handle oneway tags correctly
+ * flagsDefault 
+ * setProperties
+ * reverseFlags
+
+To incorporate or precalculate values based on the elevation data you can hook into applyWayTags
+and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
+
+If you want to include your FlagEncoder in GraphHopper you have to add the creation in
+EncodingManager.parseEncoderString to let the EncodingManager pick the correct class when faced
+with the string. The convention is that encoder.toString is identical to the string.
\ No newline at end of file
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index f4f37617b2..b552261124 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -4,6 +4,21 @@ If you just start to use GraphHopper please refer to [routing docs](./routing.md
 or [the quickstart for developers](./quickstart-from-source.md)
 and come back here later if the higher level API does not suit your needs.
 
+### What are pillar and tower nodes?
+
+From road network sources like OpenStreetMap we fetch all nodes and create the routing graph but 
+only a sub-set of them are actual junctions, which are the ones we are interested in while routing.
+
+Those junction nodes (and end-standing nodes of dead alleys) we call *tower nodes* which also 
+have a graphhopper node ID associated, going from 0 to graph.getNodes(). 
+The helper nodes between the junctions we call 'pillar nodes' which can be fetched via
+`edgeIteratorState.fetchWayGeometry(0)`. Avoiding the traversal of pillar nodes while routing makes 
+routing a lot faster (~8 times).
+
+That splitting into pillar and tower nodes is also the reason why there can't be a unique mapping from 
+one OSM node ID to exactly one GraphHopper node ID. And as one OSM Way is often splitted into multiple 
+edges the same applies for edge IDs too.
+
 ### Create and save the graph
 
 ```java
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index fa3e52aa00..f6cab16714 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -1,20 +1,23 @@
+# GraphHopper - Quick Start Guide for Developers
+
 ## Try out
 
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
-Windows user can find a quick guide [here](https://github.com/graphhopper/graphhopper/wiki/Windows). 
+Windows user can find a quick guide [here](./windows-setup.md). 
 
 Now, before you proceed install git and jdk6, 7 or 8. Then do:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git
-$ cd graphhopper; ./graphhopper.sh web europe_germany_berlin.pbf
+$ cd graphhopper; git checkout master
+$ ./graphhopper.sh web europe_germany_berlin.pbf
 now go to http://localhost:8989/
 ```
 
   1. These steps make the Berlin area routable. It'll download and unzip the osm file for you.
   2. It builds the graphhopper jars. If Maven is not available it will automatically download it.
   3. Then it creates routable files for graphhopper in the folder europe_germany_berlin-gh. It'll skip this step if files are already present.
-  4. Also check the instructions for [Android](https://github.com/graphhopper/graphhopper/wiki/Android)
+  4. Also check the instructions for [Android](../android/index.md)
 
 For you favourite area do
 
@@ -30,112 +33,99 @@ Open the project with NetBeans or enable Maven in your IDE.
 [Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
 installed when executing graphhopper.sh.
 
-Have a look into the [Java API documentation](./) 
-for further details.
-
-For more details on Android-usage have a look into this [Android site](https://github.com/graphhopper/graphhopper/wiki/Android)
-
-### Debug
-
-No special setup is required since the core and the web module can be started via a main method now.
-
-### Create your UI
-
- * For an example of how to use graphhopper in a web application see the [web subfolder](https://github.com/graphhopper/graphhopper/tree/master/web)
- * For an Android example see [the android folder](https://github.com/graphhopper/graphhopper/tree/master/android)
- * You can use graphhopper on the Desktop with the help of the yet outdated [mapsforge swing library](http://osm4j.svn.sourceforge.net/viewvc/osm4j/trunk/lib/). The new 'rewrite' branch of mapsforge will help here soon.
+### Java, Embedded Usage
+
+Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
+be embedded](./routing.md) into your application and like a [custom weighting](./weighting.md) 
+can be implemented.
+
+Look [here](http://graphhopper.com/#community) for the maven snippet to use GraphHopper in your
+application. To use an unreleased snapshot version of GraphHopper you need the following snippet in your pom.xml
+as those versions are not in maven central:
+
+```xml
+    <repositories>
+        <repository>
+            <id>sonatype-oss-public</id>
+            <url>https://oss.sonatype.org/content/groups/public/</url>
+            <releases>
+                <enabled>true</enabled>
+            </releases>
+            <snapshots>
+                <enabled>true</enabled>
+            </snapshots>
+        </repository>
+    </repositories>
+```
 
-### Notes
+### Java, Routing Server Usage
 
-If you develop for Android have a look into the android subfolder. For smallish graph (e.g. size of Berlin) use
- a RAMDataAccess driven GraphStorage (loads all into memory). For larger ones use the ContractionHierarchies 
-preparation class and MMapDataAccess to avoid OutOfMemoryErrors. 
+The Web API documentation is [here](../web). 
+We provide Java client code [here](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java#L43)
+to query the routing server.
 
-If you develop a web application have a look into the web demo ('web' subfolder). The simple API 
-(json,jsonp) in this demo is optimized regarding several aspects:
+The routing API (json,jsonp,gpx) is optimized regarding several aspects:
  * It tries to return a smallish data set (encoded polyline, gzip filter)
- * It enables cross-site scripting on the server- and client-site (jQuery, header setting)
- * To make things simple it uses the GeoCoder called Nominatim to get the name for a latitude+longitude point or vice versa.
- * Where it utilizes the jquery Deferred object to chain ajax requests and avoids browser UI blocking when resolving locations in parallel.
+ * It enables cross-site scripting on the server- and client-site
+ * The JavaScript client utilizes the jquery Deferred object to chain ajax requests and avoids browser UI blocking when resolving locations in parallel.
 
-## Web Service Deployment
+#### Routing Service Deployment
 
 For simplicity you could just start jetty from maven and schedule it as background job: 
 `export GH_FOREGROUND=false && export JETTY_PORT=11111 && ./graphhopper.sh web europe_germany_berlin.pbf`. 
 Then the service will be accessible on port 11111.
 
-The Web API documentation is [here](../web)
-
 For production usage you can install the latest jetty (8 or 9) as a service but we prefer to have it bundled as a 
-simple jar. Tomcat should work too. To create a war file do `mvn clean war:war` and copy it from the target/ 
+simple jar. Tomcat should work too. To create a war file do `mvn clean install war:war` and copy it from the target/ 
 folder to your jetty installation. Then copy web/config.properties also there and change this properties 
 file to point to the required graphhopper folder. Increase the Xmx/Xms values of your jetty server e.g. 
 for world wide coverage with a hierarchical graph I do the following in bin/jetty.sh
 ```bash
 export JAVA=java-home/bin/java
-export JAVA_OPTIONS="-server -Xconcurrentio -Xmx15000m -Xms15000m"
+export JAVA_OPTIONS="-server -Xconcurrentio -Xmx17000m -Xms17000m"
 ```
 
-For [World-Wide-Road-Network](https://github.com/graphhopper/graphhopper/wiki/World-Wide-Road-Network) we have a separate wiki page.
+For [World-Wide-Road-Network](./world-wide.md) we have a separate information page.
 
 Important notes:
- * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See https://github.com/graphhopper/graphhopper/issues/104
+ * jsonp support needs to be enabled in the config.properties
+ * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/104)
  * if you have strange speed problems which could be related to low memory you can try to [entire disable swap](http://askubuntu.com/questions/103915/how-do-i-configure-swappiness). Or just try it out via `sudo swapoff -a`. Swapping out is very harmful to Java programs especially when the GC kicks in.
 
-## Technical Overview
-
-To get a better understanding also take a look in the source code, especially in the unit tests and in 
-some resources we [published](http://karussell.wordpress.com/2014/01/23/graphhopper-news-article-in-java-magazine-and-fosdem-2014/). 
-
-There are mainly three parts:
-
-### 1. Data Import
-
-The default import is done via OSMReader which imports OpenStreetMap data. You can configure it via API 
-or use the graphhopper.sh script which utilizes the config.properties where you can specify if it should 
-read CAR, FOOT etc or all at once. You'll have to make sure that you allocate enough memory for your 
-specific graph (E.g. ~1GB for Germany) e.g. `export JAVA_OPTS="-Xmx1g"`. The import process is fast e.g. 
-complete germany takes about 10 minutes on my oldish laptop. Additionally it will take time if you choose 
-osmreader.chShortcuts=fastest in the config.properties which will dramatically improve query time.
-
-### 2. The Graph
+### JavaScript Usage
 
-To process algorithms you need a _Graph_. At the moment there is one main implementation GraphHopperStorage 
-which can be used: 
-  * in-memory with a safe/flush option (RAMDataAccess) and 
-  * a memory mapped (MMapDataAccess).
+For an example of how to use graphhopper in a web application see the 
+[web subfolder](https://github.com/graphhopper/graphhopper/tree/master/web)
 
-The interface _Graph_ is developed in the sense that the implementation can be as much efficient as possible
- - i.e. node ids and edge ids are successive (and so are just _indices_) and in the range of 0 to MAX-1. 
-This design could be used to have an array-like structure in the underlying DataAccess implementation like 
-it is currently the case.
+The routing server can be queried from [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js)
+as well. You can see this in action at [GraphHopper Maps](https://graphhopper.com/maps/).
 
-The data layout for the DataAccess objects in GraphHopperStorage called 'nodes' and 'edges' is the following:
+If you need **offline** routing in the browser like for smaller areas or hybrid routing solution
+then there is a highly experimental version of GraphHopper using TeaVM. 
+Have a look into this [blog post](http://karussell.wordpress.com/2014/05/04/graphhopper-in-the-browser-teavm-makes-offline-routing-via-openstreetmap-possible-in-javascript/) 
+for a demo and more information.
 
-![storage layout](http://karussell.files.wordpress.com/2013/08/wiki-graph.png)
+### Android Usage
+ 
+For details on Android-usage have a look into this [Android site](../android/index.md) or at the
+[Android example](https://github.com/graphhopper/graphhopper/tree/master/android)
 
-Some explanations:
- * One 'node row' consists of latitude,longitude (not shown) and an edgeID
- * One 'edge row' consists of two edgeIDs: nextA and nextB, then two nodeIDs nodeA and nodeB, and finally some properties like the distance and the flags.
- * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
- * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
+### Swing and Desktop Usage
 
-For some algorithms there are special implementations of the Graph. E.g. there is a LevelGraphStorage which is a Graph with the possibility to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. For this the graph needs also some preprocessing (which can take several hours for bigger areas like Europe) which is done in the OSMReader when configured (osmreader.chShortcuts=fastest) or via API in PrepareContractionHierarchies. In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from createAlgo() in the preparation class.
+You can use graphhopper on the Desktop with the help of the latest mapsforge swing library too. No example code
+yet but with the Android example combined with the Desktop example of the mapsforge project it should not be
+that hard.
 
-A LevelGraphStorage (and all subclasses of GraphStorage) cannot read files created with GraphStorage and vice versa. Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+For smallish graph (e.g. size of Berlin) use a RAMDataAccess driven GraphStorage (loads all into memory).
+For larger ones use the ContractionHierarchies preparation class and MMapDataAccess to avoid OutOfMemoryErrors. 
 
-### 3. The Algorithms
+Raspberry Pi usage is also possible. Have a look into this [blog post](https://karussell.wordpress.com/2014/01/09/road-routing-on-raspberry-pi-with-graphhopper/).
 
-In the routing package you'll find some shortest path algorithms like Dijkstra or A* etc. For those 
-algorithms you need a _Graph_.
+## Technical Details
 
-An algorithm needs a kind of path extraction: from the shortest-path-tree one needs to determine the route 
-(list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
-can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
-For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
- one needs to additionally find the shortcutted edges and process them recursivly - this is done in Path4CH.
+Have a look in the more [technical documentation](./technical.md) or the [low level API](./low-level-api.md).
 
 Further Links
 ---------------
  * [Spatial Key](http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/)
- * [Author@Twitter](https://twitter.com/timetabling)
\ No newline at end of file
+ * [Author@Twitter](https://twitter.com/timetabling)
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 0e17633cc4..dcdaf693c1 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -12,7 +12,10 @@ hopper.setEncodingManager(new EncodingManager("car"));
 // of course this is dependent on the area you import
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("car");
+// simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setWeighting("fastest").
+    setVehicle("car");
 GHResponse rsp = hopper.route(req);
 
 // first check for errors
@@ -57,7 +60,7 @@ hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm("astar");
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
 GHResponse res = hopper.route(req);
 ```
 
diff --git a/docs/core/technical.md b/docs/core/technical.md
new file mode 100644
index 0000000000..5cc0ea1372
--- /dev/null
+++ b/docs/core/technical.md
@@ -0,0 +1,85 @@
+## Technical Overview of GraphHopper
+
+To get a better understanding also take a look in the source code, especially in the unit tests and in 
+some resources we [published](http://karussell.wordpress.com/2014/01/23/graphhopper-news-article-in-java-magazine-and-fosdem-2014/)
+or [here](http://graphhopper.com/public/slides/).
+
+There are mainly three parts:
+
+### 1. Data Import
+
+The default import is done via OSMReader which imports OpenStreetMap data. You can configure it via API 
+or use the graphhopper.sh script which utilizes the config.properties where you can specify if it should 
+read CAR, FOOT etc or all at once. You'll have to make sure that you allocate enough memory for your 
+specific graph (E.g. ~1GB for Germany) e.g. `export JAVA_OPTS="-Xmx1g"`. The import process is fast e.g. 
+complete germany takes about 10 minutes on my oldish laptop. Additionally it will take time if you choose 
+prepare.chWeighting=fastest in the config.properties which will dramatically improve query time
+but requires more RAM on import.
+
+### 2. The Graph
+
+To process algorithms you need a _Graph_. At the moment there is one main implementation GraphHopperStorage 
+which can be used: 
+  * in-memory with a safe/flush option (RAMDataAccess) and 
+  * a memory mapped (MMapDataAccess).
+
+The interface _Graph_ is developed in the sense that the implementation can be as much efficient as possible
+ - i.e. node ids and edge ids are successive (and so are just _indices_) and in the range of 0 to MAX-1. 
+This design could be used to have an array-like structure in the underlying DataAccess implementation like 
+it is currently the case.
+
+The data layout for the DataAccess objects in GraphHopperStorage called 'nodes' and 'edges' is the following:
+
+![storage layout](http://karussell.files.wordpress.com/2013/08/wiki-graph.png)
+
+Some explanations:
+ * One 'node row' consists of latitude,longitude (not shown) and the first edgeID
+ * One 'edge row' consists of two edgeIDs: nextA and nextB, then two nodeIDs nodeA and nodeB, and finally some properties like the distance and the flags.
+ * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
+ * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
+
+For some algorithms there are special implementations of the Graph. E.g. there is a LevelGraphStorage which is a Graph with the possibility to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. For this the graph needs also some preprocessing (which can take several hours for bigger areas like Europe) which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from createAlgo() in the preparation class.
+
+A LevelGraphStorage (and all subclasses of GraphStorage) cannot read files created with GraphStorage and vice versa. Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+
+### 3. The Algorithms
+
+In the routing package you'll find some shortest path algorithms like Dijkstra or A* etc. For those 
+algorithms you need a _Graph_.
+
+An algorithm needs a kind of path extraction: from the shortest-path-tree one needs to determine the route 
+(list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
+can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
+For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
+ we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
+ shortcuts and get the edges recursivly, this is done in Path4CH.
+
+## 3.1 OriginalGraph
+
+See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
+
+In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
+is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
+_LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
+or similar. See #116 for more information.
+
+
+### 4. Connecting the Real World to the Graph
+
+## 4.1 LocationIndex
+
+In real world we have addresses and/or coordinates for the start and end point. 
+To get the coordinate from an address you will need a geocoding solution not part of GraphHopper,
+e.g. have a look into our [Routing Web API](http://graphhopper.com/#enterprise) for more information about this topic.
+
+To get the closest node or edge id from a coordinate we provide you with an efficient lookup concept:
+the LocationIndex. There are multiple implementations
+where the LocationIndexTree is the most precise and scalable one and used in almost all places.
+See [here](./location-index.md) for more information. See #17 and #221.
+
+
+## 4.2 QueryGraph
+
+In order to route not only from junctions (which are nodes) we introduced the _QueryGraph_ in issue #27,
+which creates virtual nodes and edges at the query coordinates. It provides a lightweight wrapper around
+the _Graph_ and is created per query so that queries do not influence each other.
diff --git a/docs/core/translations.md b/docs/core/translations.md
new file mode 100644
index 0000000000..4f7d6eb502
--- /dev/null
+++ b/docs/core/translations.md
@@ -0,0 +1,40 @@
+# Translation
+
+You can help improve GraphHopper by adding your language!
+
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
+
+## Questions
+
+ 1. **What does the string after the language name mean ala 'Spanish: es'?**
+    This is the language its ISO code (639-1) with two characters. E.g. look up your language on wikipedia to get this code. 
+    See [Spanish](http://en.wikipedia.org/wiki/Spanish_language) as an example again.
+ 2. **What does the strange characters ala '%1$s' in the items means?**
+    This is a placeholder which is filled by GraphHopper. It is important to have as in some languages the position
+    is different than in other languages or the translation is completely different. 
+    Example: "Enter roundabout and use exit %1$s". In German language you have to add the word 'nehmen' after the
+    exit-number parameter: "In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen". 
+    It is very important that you do not forget about these parameter placeholders, please ask if you are unsure.
+
+## Integrate into GraphHopper
+
+We'll regularly update GraphHopper with new translations or fixes so no need to do this work for you. But if you still
+want to try your changes or want to speed up the integration you can do the following:
+
+ * Make GraphHopper working on your computer, where you need to git clone the repository - see [here](./quickstart-from-source.md) for more information.
+ * If you created a new language then add it in lexicographical order to TranslationMap.LOCALES (core/src/main/java/com/graphhopper/util) and to the script: core/files/update-translations.sh
+ * Do `cd graphhopper/core; curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv`
+ * Then `./files/update-translations.sh tmp.tsv && rm tmp.tsv`
+ * Now you can see your changes via `git diff`. Make sure that is the only one with `git status`
+ * Now execute `mvn clean test` to see if you did not miss arguments in your translation (see point 2 in the questions above)
+ * You can start a simple GraphHopper instance via './graphhopper.sh web europe_germany_berlin.pbf' and go to localhost:8989 append e.g. &locale=de if your translation does not show up automatically
+ * Read the [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) to submit your changes
+
+## License Agreement
+
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
index d628f42b7a..0cfe351f42 100644
--- a/docs/core/weighting.md
+++ b/docs/core/weighting.md
@@ -15,7 +15,7 @@ class BlockingWeighting implements Weighting
     private final double maxSpeed;
     private Set<Integer> forbiddenEdges;
 
-    public FastestWeighting( FlagEncoder encoder, Set<Integer> forbiddenEdges)
+    public BlockingWeighting( FlagEncoder encoder, Set<Integer> forbiddenEdges)
     {
         this.encoder = encoder;
         this.maxSpeed = encoder.getMaxSpeed();
@@ -29,7 +29,7 @@ class BlockingWeighting implements Weighting
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge, boolean reverse )
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         if(forbiddenEdges.contains(edge.getEdge()))
             return Double.POSITIVE_INFINITY;
@@ -59,7 +59,9 @@ class MyGraphHopper extends GraphHopper {
     }
 
     @Override
-    public Weighting createWeighting(String weighting, FlagEncoder encoder) {        
+    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    {
+        String weighting = wMap.getWeighting();
         if ("BLOCKING".equalsIgnoreCase(weighting))
             return new BlockingWeighting(encoder, forbiddenEdges);
         else
@@ -69,4 +71,4 @@ class MyGraphHopper extends GraphHopper {
 ```
 
 For forbiddenEdges you need to determine the edges from some GPS coordinates. 
-Have a look into the [location index docs](./location-index.md).
\ No newline at end of file
+Have a look into the [location index docs](./location-index.md).
diff --git a/docs/index.md b/docs/index.md
index 873261e962..5bf7d4223c 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,16 +1,39 @@
-Users
----------------
+# Users
+
  * [Read Overview](http://graphhopper.com/#overview)
- * [Add GraphHopper Maps to your Browser](./web/open-search.md)
- * [GraphHopper on Twitter](https://twitter.com/graphhopp)
  * [Quickstart](./web/quickstart.md) for users
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md)
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper)
+
+# Translators
+
+* [Translations](./core/translations.md)
+
+
+# Developers
 
-Developers
---------------- 
  * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
-   * [Android](./android/index.md)
-   * [Windows](./core/windows-setup.md)
- * [Slides from FOSDEM 2014](http://graphhopper.com/public/slides/)
+ * [Android](./android/index.md)
+ * [Windows](./core/windows-setup.md)
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/)
+
+## Core
+
+ * [Simple routing](./core/routing.md) to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md)
+ * [Elevation](./core/elevation.md)
+ * [Technical overview](./core/technical.md)
+ * [Slides from 2014](http://graphhopper.com/public/slides/)
+ * [Contraction Hierarchies](./core/ch.md)
+
+## Web
+
+ * [Routing API](./web/api-doc.md)
+ 
+## Advanced Topics
+
+ * [Low level API](./core/low-level-api.md)
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md)
+ * [LocationIndex](./core/location-index.md)
  * [World-Wide-Road-Network](./core/world-wide.md)
  * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
-
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 802155819d..328585b83d 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -15,25 +15,24 @@ All official parameters are shown in the following table
 Parameter   | Default | Description
 :-----------|:--------|:-----------
 point       | -       | Specifiy multiple points for which the route should be calculated. The order is important. Specify at least two points.
-locale      | en      | The locale of the result. E.g. pt_PT for Portuguese or de for German
-instructions| true  | If instruction should be calculated and returned
+locale      | en      | The locale of the result. E.g. `pt_PT` for Portuguese or `de` for German
+instructions| true    | If instruction should be calculated and returned
 vehicle     | car     | The vehicle for which the route should be calculated. Other vehicles are foot and bike
-weighting   | fastest | Which kind of 'best' route calculation you need. Other option is 'shortest', currently not available in the public service.
-algorithm   | dijkstrabi | The algorithm to calculate the route. Other options are dijkstra, astar and astarbi. For the public service only dijkstrabi is supported.
-points_encoded     | true | If the resulting route should be 'compressed' using a special algorithm leading to massive bandwith reduction. You'll need a special handling on the client, if enabled. We provide Open Source code in Java and JavaScript.
+weighting   | fastest | Which kind of 'best' route calculation you need. Other option is 'shortest', currently not available in the WEB API.
+elevation   | false   | If `true` a third dimension - the elevation - is included in the polyline or in the GeoJson. IMPORTANT: If enabled you have to use a modified version of the decoding method or set points_encoded to `false`. See the points_encoded attribute for more details. Additionally a request can fail if the vehicle does not support elevation. See the features object for every vehicle.
+algorithm   | dijkstrabi     | The algorithm to calculate the route. Other options are dijkstra, astar and astarbi. The WEB API supports only dijkstrabi.
+points_encoded     | true    | If `false` a GeoJson array in `point` is returned. If `true` the resulting route will be encoded leading to big bandwith reduction. You'll need a special handling for the decoding of this string on the client-side. We provide Open Source code in [Java](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/WebHelper.java#L43) and [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js#L139). It is especially important to use our decoding methods if you set `elevation=true`!
 debug              | false   | If true, the output will be formated.
 calc_points        | true    | If the points for the route should be calculated at all. Sometimes only the distance and time is necessary.
 type               | json    | Specifies the resulting format of the route, for json the content type will be application/json. Other possible format options: <br> jsonp you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> gpx, the content type will be application/xml
-min_path_precision | 1  | Not recommended to change. Increase this number if you want to further reduce bandwith.
 
 ## Example output for the case type=json
 
-Keep in mind that some attributes which are not documented here can be removed in the future - 
-so you should not rely on them!
+Keep in mind that some attributes which are not documented here can be removed in the future - you should not rely on them!
 
 ```json
 {
-  "info": {"took": 0.00414920412003994},
+  "info": {"took": 4},
   "paths": [{
     "bbox": [
       13.362853824187303,
@@ -111,40 +110,44 @@ paths[0].distance          | The overall distance of the route, in meter
 paths[0].time              | The overall time of the route, in ms
 paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
 paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
-paths[0].points_dimension  | The dimension of the points field. Can be 2 or 3.
 paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
 paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
-paths[0].instructions[0].description | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
-paths[0].instructions[0].distance    | The distance for this instruction, in meter
-paths[0].instructions[0].time        | The duration for this instruction, in ms
-paths[0].instructions[0].interval    | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction
-paths[0].instructions[0].sign        | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
+paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
+paths[0].instructions[0].distance             | The distance for this instruction, in meter
+paths[0].instructions[0].time                 | The duration for this instruction, in ms
+paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
+paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
+paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
 
 
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
 ### Example output:
 ```json
 { "build_date":"2014-02-21T16:52",
-  "bbox":[13.0726237909337,52.33350773901,13.7639719344073,52.679616459003],
+  "bbox":[13.072624,52.333508,13.763972,52.679616],
   "version":"0.3",
-  "supported_vehicles": ["foot"]
+  "features": { "foot" : { "elevation" : true  }, 
+                "car"  : { "elevation" : false } }
 }
 ```
 
 JSON path/attribute | Description
 :-------------------|:------------
-build_date          | The GraphHopper build date
 version             | The GraphHopper version
-supported_vehicles  | An array of strings indicating the supported vehicles
 bbox                | The maximum bounding box of the area, format: <br> minLon, minLat, maxLon, maxLat
+features            | A json object per supported vehicles with name and supported features like elevation
+build_date          | [optional] The GraphHopper build date
 import_date         | [optional] The date time at which the OSM import was done
 prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
-prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
+supported_vehicles  | [deprecated] An array of strings for all supported vehicles
 
 ### Output if expected error(s) while routing:
 ```json
@@ -152,18 +155,17 @@ prepare_date        | [optional] The date time at which the preparation (contrac
   "info": {"errors": [{
     "details": "java.lang.IllegalArgumentException",
     "message": "Cannot find point 2: 2248.224673, 3.867187"
-  }]},
-  "paths": [{}]
+  }]}
 }
 ```
 
-Sometimes a point can be too offroad and you'll get 'cannot find point', this normally does not
-indicate a bug in the routing engine and is expected to a certain degree.
+Sometimes a point can be "off the road" and you'll get 'cannot find point', this normally does not
+indicate a bug in the routing engine and is expected to a certain degree if too far away.
 
 JSON path/attribute    | Description
 :----------------------|:------------
 info.errors            | A list of error messages
-info.errors[0].defails | E.g. to see the underlying exception, if any
+info.errors[0].details | E.g. to see the underlying exception, if any
 info.errors[0].message | Not intended to be displayed to the user as it is currently not translated
 
 
@@ -171,6 +173,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index 957f81daa6..30ae92802c 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -3,10 +3,10 @@
 If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
 The following steps are simpler and only need the JRE, a jar file and an OSM file.
 
- 1. Install the latest JRE and get [graphhopper](https://oss.sonatype.org/content/repositories/snapshots/com/graphhopper/graphhopper-web/0.3-SNAPSHOT/) (a zip file, ~7MB)
+ 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.4-SNAPSHOT/) (~7MB)
  2. Unzip it and copy an OSM file into the created directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
- 3. Start GraphHopper Maps via: java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf
- 4. Go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
+ 3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf`
+ 4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
 
 
 ## Troubleshooting
diff --git a/graphhopper.sh b/graphhopper.sh
index a5b0e24425..fbd089a4b2 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-GH_CLASS=com.graphhopper.GraphHopper
+GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
 if [ "x$JAVA_HOME" = "x" ]; then
@@ -22,9 +22,25 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
 if [ "x$ACTION" = "x" ]; then
- echo -e "## action $ACTION not found. try \n$USAGE"
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
@@ -70,8 +86,8 @@ function ensureMaven {
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
         echo "No Maven found in the PATH. Now downloading+installing it to $MAVEN_HOME"
         cd "$GH_HOME"
-        MVN_PACKAGE=apache-maven-3.2.1
-        wget -O maven.zip http://www.eu.apache.org/dist/maven/maven-3/3.2.1/binaries/$MVN_PACKAGE-bin.zip
+        MVN_PACKAGE=apache-maven-3.2.5
+        wget -O maven.zip http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
         unzip maven.zip
         mv $MVN_PACKAGE maven
         rm maven.zip
@@ -96,7 +112,7 @@ function packageCoreJar {
     echo "## now building graphhopper jar: $JAR"
     echo "## using maven at $MAVEN_HOME"
     #mvn clean
-    "$MAVEN_HOME/bin/mvn" --projects core -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
+    "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
     returncode=$?
     if [[ $returncode != 0 ]] ; then
         echo "## compilation of core failed"
@@ -137,12 +153,13 @@ elif [ "x$ACTION" = "xextract" ]; then
  
 elif [ "x$ACTION" = "xandroid" ]; then
  prepareEclipse
- "$MAVEN_HOME/bin/mvn" --projects android install android:deploy android:run
+ "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
  exit
 fi
 
 if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
@@ -172,7 +189,7 @@ fi
 
 GRAPH=$NAME-gh
 VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1)
-JAR=core/target/graphhopper-$VERSION-jar-with-dependencies.jar
+JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
 LINK=$(echo $NAME | tr '_' '/')
 if [ "x$FILE" == "x-" ]; then
@@ -189,7 +206,7 @@ else
 fi
 
 if [ "x$JAVA_OPTS" = "x" ]; then
-  JAVA_OPTS="-XX:PermSize=60m -XX:MaxPermSize=60m -Xmx1000m -Xms1000m -server"
+  JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
 
@@ -218,12 +235,14 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
   RC_BASE=./web/src/main/webapp
 
   if [ "x$GH_FOREGROUND" = "x" ]; then
-    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE jetty.port=$JETTY_PORT config=$CONFIG \
-         $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
+    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
+	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
+    	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
     # foreground => we never reach this here
   else
-    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE jetty.port=$JETTY_PORT config=$CONFIG \
-         $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
+    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
+    	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
+    	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
     if [ "x$GH_PID_FILE" != "x" ]; then
        echo $! > $GH_PID_FILE
     fi
@@ -236,14 +255,8 @@ elif [ "x$ACTION" = "ximport" ]; then
       $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtest" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true config=$CONFIG \
-       graph.location="$GRAPH" osmreader.osm="$OSM_FILE" prepare.chShortcuts=false \
-       graph.testIT=true
-
-
 elif [ "x$ACTION" = "xtorture" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.util.QueryTorture $3 $4 $5 $6 $7 $8 $9
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
 elif [ "x$ACTION" = "xminiui" ]; then
@@ -254,11 +267,11 @@ elif [ "x$ACTION" = "xminiui" ]; then
 
 
 elif [ "x$ACTION" = "xmeasurement" ]; then
- ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chShortcuts=fastest osmreader.acceptWay=CAR"
- # graph.doSort=true"
+ ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false
+ # avoid islands for measurement at all costs
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false prepare.minNetworkSize=10000 prepare.minOnewayNetworkSize=10000
  END=$(date +%s)
  IMPORT_TIME=$(($END - $START))
 
@@ -266,7 +279,7 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
     COUNT=5000
     commit_info=$(git log -n 1 --pretty=oneline)
     echo -e "\nperform measurement via jar=> $JAR and ARGS=> $ARGS"
-    "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.util.Measurement $ARGS measurement.count=$COUNT measurement.location="$M_FILE_NAME" \
+    "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.Measurement $ARGS measurement.count=$COUNT measurement.location="$M_FILE_NAME" \
             graph.importTime=$IMPORT_TIME measurement.gitinfo="$commit_info"
  }
  
diff --git a/index.html b/index.html
deleted file mode 100644
index 347a3312b4..0000000000
--- a/index.html
+++ /dev/null
@@ -1,80 +0,0 @@
-<!DOCTYPE html>
-<html>
-    <head>        
-        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
-        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
-        <meta name="keywords" content="road routing,shortest path,maps,openstreetmap,android,navigation,routenplaner,gis"/>
-        <link type="image/png" rel="icon" href="/favicon.ico"/>        
-        <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
-        <title>GraphHopper Maps</title>
-
-        <link rel="stylesheet" href="css/leaflet.css" />
-        <!--[if lte IE 8]>
-            <link rel="stylesheet" href="css/leaflet.ie.css" />
-        <![endif]-->
-        <script type="text/javascript" src="js/leaflet.js?v=0.6.4"></script>
-        <script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
-        <script type="text/javascript" src="js/jquery.history.js"></script>
-<!--        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>-->
-        <script type="text/javascript" src="js/jquery.autocomplete.js"></script>
-        <script type="text/javascript" src="js/ghrequest.js?v=3"></script>
-        <script type="text/javascript" src="js/main.js?v=14"></script>
-        <link rel="stylesheet" type="text/css" href="css/style.css" />
-    </head>
-    <body>
-        <div id="input">
-            <div id="header_img">
-                <a class="no_link" href="http://graphhopper.com">
-                    <img alt="GraphHopper" src="http://graphhopper.com/img/header.png"/>                    
-                </a>
-            </div>
-            <div id="options">
-                <span id="vehicles">
-
-                </span>
-            </div>
-            <form id="locationform">
-                <div id="fromDiv">
-                    <img id="fromIndicator" class="hidden" src="img/indicator.gif"/>
-                    <img id="fromFlag" src="img/marker-small-green.png"/>
-                    <input id="fromInput" type="text" placeholder="From"/>
-                    <div id="fromFound"></div>
-                </div>
-                <div id="toDiv">
-                    <img id="toIndicator" class="hidden" src="img/indicator.gif"/>
-                    <img id="toFlag" src="img/marker-small-red.png"/>                    
-                    <input id="toInput" type="text" placeholder="To"/>
-                    <div id="toFound"></div>
-                </div>
-                <div id="exportLink" class="left"><a href="/maps"><img src='img/link.png'></a></div>
-                <input id="searchButton" type="submit" value="Search">
-            </form>      
-            <div class="clear"> </div>
-            <div id="info" class="small_text">
-            </div>
-            <div id="error" class="error">
-            </div>
-        </div>
-
-        <div id="map">
-        </div>
-        <!-- Piwik -->
-        <script type="text/javascript">
-            PIWIK=false;
-            if(PIWIK) {
-                var pkBaseURL = (("https:" == document.location.protocol) ? "https://www.pannous.info/piwik/" : "http://www.pannous.info/piwik/");
-                document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
-            }
-        </script>
-        <script type="text/javascript">
-            if(PIWIK)
-                try { 
-                    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 7);
-                    piwikTracker.trackPageView();
-                    piwikTracker.enableLinkTracking();
-                } catch( err ) {}
-        </script>
-        <noscript><p><img src="http://www.pannous.info/piwik/piwik.php?idsite=7" style="border:0" alt="" /></p></noscript>
-        <!-- End Piwik Tracking Code -->
-    </body>
-</html>
diff --git a/pom.xml b/pom.xml
index f5fac47862..5042897e07 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.4-SNAPSHOT</version>
     <packaging>pom</packaging> 
     <url>http://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.5</slf4j.version>
+        <slf4j.version>1.7.7</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -53,7 +53,7 @@
     </scm>
     <developers>
         <developer>
-            <id>peterka</id>
+            <id>karussell</id>
             <name>Peter Karich</name>
             <email>my.name@graphhopper.com</email>
         </developer>
@@ -77,7 +77,6 @@
         <module>core</module>
         <module>tools</module>
         <module>web</module>
-        <module>android</module>
     </modules>
         
     <build>        
@@ -92,7 +91,8 @@
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
-                    
+                    <compilerArgument>-XDignore.symbol.file</compilerArgument>
+                    <fork>true</fork>
                     <source>1.6</source>
                     <target>1.6</target>
                 </configuration>
@@ -102,7 +102,7 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.15</version>
+                <version>2.17</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -111,7 +111,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.15</version>
+                <version>2.17</version>
                 <executions>
                     <execution>
                         <goals>
@@ -125,17 +125,17 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-deploy-plugin</artifactId>
-                <version>2.7</version>
+                <version>2.8.2</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.9.1</version>
+                <version>2.10</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
-                <version>2.2.1</version>
+                <version>2.3</version>
             </plugin>
         </plugins>
     </build>    
@@ -164,7 +164,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.4</version>
+                        <version>1.5</version>
                         <executions>
                             <execution>
                                 <id>sign-artifacts</id>
@@ -178,6 +178,16 @@
                 </plugins>
             </build>
         </profile>
+        
+        <profile>
+            <id>include-android</id>
+            <activation>
+                <activeByDefault>false</activeByDefault>
+            </activation>
+            <modules>
+                <module>android</module>
+            </modules>
+        </profile>
     </profiles>
     
 </project>
diff --git a/tools/pom.xml b/tools/pom.xml
index 40f6ae364f..44f0ebd1ed 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.4-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.4-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -41,22 +41,22 @@
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
-            <version>1.5</version>
+            <version>1.8.1</version>
         </dependency>
     </dependencies>
     <build>
-        <plugins>   
-            <plugin> 
+        <plugins>
+            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4</version>
+                <version>2.4.1</version>
                 <configuration>
-                    <archive>  
-                        <manifest> 
-                            <mainClass>com.graphhopper.ui.MiniGraphUI</mainClass>
+                    <archive>
+                        <manifest>
+                            <mainClass>com.graphhopper.tools.Import</mainClass>
                         </manifest>
                     </archive>
-                     
+                        	                    
                     <!-- for standalone usage -->
                     <descriptorRefs>
                         <descriptorRef>jar-with-dependencies</descriptorRef>
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index 1c615e7858..1627869017 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -1,14 +1,18 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.util.CmdArgs;
 
 /**
  * @author Peter Karich
  */
 public class Import
 {
-    public static void main( String[] args ) throws Exception
+    public static void main( String[] strs ) throws Exception
     {
-        GraphHopper.main(args);
+        CmdArgs args = CmdArgs.read(strs);
+        GraphHopper hopper = new GraphHopper().init(args);
+        hopper.importOrLoad();
+        hopper.close();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/util/Measurement.java
rename to tools/src/main/java/com/graphhopper/tools/Measurement.java
index 5a6ccf0d58..ae932d78b7 100644
--- a/core/src/main/java/com/graphhopper/util/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
@@ -25,6 +25,14 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.MiniPerfTest;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
 import java.io.FileWriter;
 import java.io.IOException;
@@ -69,12 +77,14 @@ protected void ensureNotLoaded()
 
         public void doPostProcessing()
         {
+            // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getMaxId();
-            initCHPrepare();
+            int edges = getGraph().getAllEdges().getCount();
+            setAlgorithmFactory(createPrepare());
             super.prepare();
+            setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getMaxId() - edges);
+            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
         }
     }
 
@@ -98,15 +108,15 @@ void start( CmdArgs args )
         int count = args.getInt("measurement.count", 5000);
 
         MeasureHopper hopper = new MeasureHopper();
-        hopper.forDesktop().setEnableInstructions(false);
+        hopper.forDesktop();
         if (!hopper.load(graphLocation))
             throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
 
-        GraphStorage g = (GraphStorage) hopper.getGraph();
+        GraphStorage g = hopper.getGraph();
         if ("true".equals(g.getProperties().get("prepare.done")))
             throw new IllegalStateException("Graph has to be unprepared but wasn't!");
 
-        String vehicleStr = args.get("osmreader.acceptWay");
+        String vehicleStr = args.get("graph.flagEncoders", "");
         StopWatch sw = new StopWatch().start();
         try
         {
@@ -116,15 +126,16 @@ void start( CmdArgs args )
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
-            hopper.disableCHShortcuts();
-            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr);
+            hopper.setCHEnable(false);
+            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
-            hopper.setCHShortcuts("fastest");
+            hopper.setCHEnable(true);
             hopper.doPostProcessing();
-            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr);
+            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
+            printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
         } catch (Exception ex)
         {
@@ -154,7 +165,7 @@ private void printGraphDetails( GraphStorage g )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getMaxId());
+        put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
         put("graph.encoder", g.getEncodingManager().getSingle().toString());
     }
@@ -184,7 +195,8 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix, final String vehicle )
+    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
+            final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
@@ -211,19 +223,35 @@ public int doCalc( boolean warmup, int run )
                 double fromLon = na.getLongitude(from);
                 double toLat = na.getLatitude(to);
                 double toLon = na.getLongitude(to);
-                GHResponse res = hopper.route(new GHRequest(fromLat, fromLon, toLat, toLon).setWeighting("fastest").setVehicle(vehicle));
+                GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
+                        setWeighting("fastest").
+                        setVehicle(vehicle);
+                req.getHints().put("instructions", withInstructions);
+                GHResponse res;
+                try
+                {
+                    res = hopper.route(req);
+                } catch (Exception ex)
+                {
+                    // 'not found' can happen if import creates more than one subnetwork
+                    throw new RuntimeException("Error while calculating route! "
+                            + "nodes:" + from + " -> " + to + ", request:" + req, ex);
+                }
+
                 if (res.hasErrors())
-                    throw new IllegalStateException("errors should NOT happen in Measurement! " + res.getErrors());
+                {
+                    if (!warmup)
+                        failedCount.incrementAndGet();
+
+                    if (!res.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                        logger.error("errors should NOT happen in Measurement! " + req + " => " + res.getErrors());
+
+                    return 0;
+                }
 
                 if (!warmup)
                 {
                     long dist = (long) res.getDistance();
-                    if (dist < 1)
-                    {
-                        failedCount.incrementAndGet();
-                        return 0;
-                    }
-
                     distSum.addAndGet(dist);
 
                     airDistSum.addAndGet((long) distCalc.calcDist(fromLat, fromLon, toLat, toLon));
diff --git a/core/src/main/java/com/graphhopper/util/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
similarity index 74%
rename from core/src/main/java/com/graphhopper/util/QueryTorture.java
rename to tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index cc2761c388..521d7cd83c 100644
--- a/core/src/main/java/com/graphhopper/util/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -15,18 +15,24 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import sun.security.x509.CRLDistributionPointsExtension;
 
 /**
  * Reads log files and queries the live service
@@ -53,6 +59,7 @@ public static void main( String[] args )
     private int readQueries;
     private int maxQueries;
     private int timeout;
+    private int statusUpdateCnt;
 
     public QueryTorture()
     {
@@ -60,18 +67,19 @@ public QueryTorture()
 
     public void start( CmdArgs read )
     {
-        String logfile = read.get("logfile");
+        String logfile = read.get("logfile", "");
         int workers = read.getInt("workers", 1);
-        baseUrl = read.get("baseurl");
+        baseUrl = read.get("baseurl", "");
         maxQueries = read.getInt("maxqueries", 1000);
         timeout = read.getInt("timeout", 3000);
+        statusUpdateCnt = maxQueries / 10;
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
-        if (baseUrl.endsWith("/"))
-            baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
-        if (!baseUrl.endsWith("/route"))
-            baseUrl += "/route";
+        if (!baseUrl.endsWith("/"))
+            baseUrl += "/";
+        if (!baseUrl.endsWith("route/"))
+            baseUrl += "route/";
         if (!baseUrl.endsWith("?"))
             baseUrl += "?";
 
@@ -167,11 +175,17 @@ void execute( int workerNo ) throws InterruptedException
         Query query = queryQueue.take();
         try
         {
-            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(baseUrl + query.queryString);
+            String url = baseUrl + query.createQueryString();
+            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
                 successfullQueries.incrementAndGet();
+
+            if (successfullQueries.get() % statusUpdateCnt == 0)
+            {
+                logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
+            }
         } catch (IOException ex)
         {
             // logger.error("Error while querying " + query.queryString, ex);
@@ -189,14 +203,12 @@ public void run()
             {
                 try
                 {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), "UTF-8"));
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), Helper.UTF_CS));
                     try
                     {
-                        int logLineNo = 0;
                         String logLine;
                         while ((logLine = reader.readLine()) != null)
                         {
-                            logLineNo++;
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
@@ -227,7 +239,8 @@ public void run()
                 {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
-                    service.shutdownNow();
+                    if (service != null)
+                        service.shutdownNow();
                 }
             }
         }.start();
@@ -235,9 +248,10 @@ public void run()
 
     static class Query
     {
-        String queryString;
-        GHPlace start;
-        GHPlace end;
+        GHPoint start;
+        GHPoint end;
+        List<String> points = new ArrayList<String>();
+        Map<String, String> params = new HashMap<String, String>();
 
         static Query parse( String logLine )
         {
@@ -252,24 +266,32 @@ static Query parse( String logLine )
                 return null;
 
             Query q = new Query();
-            q.queryString = logLine.substring(0, index);
-
-            for (String param : q.queryString.split("\\&"))
+            String queryString = logLine.substring(0, index);
+            String[] tmpStrings = queryString.split("\\&");
+            for (String paramStr : tmpStrings)
             {
-                if (!param.startsWith("point="))
+                int equalIndex = paramStr.indexOf("=");
+                if (equalIndex <= 0)
                     continue;
 
-                GHPlace place = GHPlace.parse(param.substring(6));
-                if (place == null)
+                String key = paramStr.substring(0, equalIndex);
+                String value = paramStr.substring(equalIndex + 1);
+                if (!paramStr.startsWith("point="))
+                {
+                    q.params.put(key, value);
                     continue;
+                }
 
+                value = value.replace("%2C", ",");
+                GHPoint point = GHPoint.parse(value);
+                if (point == null)
+                    continue;
+
+                q.points.add(value);
                 if (q.start == null)
-                    q.start = place;
+                    q.start = point;
                 else if (q.end == null)
-                {
-                    q.end = place;
-                    break;
-                }
+                    q.end = point;
             }
             if (q.start != null && q.end != null)
                 return q;
@@ -277,31 +299,47 @@ else if (q.end == null)
             return null;
         }
 
-        @Override
-        public int hashCode()
+        public void put( String key, String value )
         {
-            int hash = 5;
-            hash = 47 * hash + (this.queryString != null ? this.queryString.hashCode() : 0);
-            return hash;
+            params.put(key, value);
         }
 
-        @Override
-        public boolean equals( Object obj )
+        public String createQueryString()
         {
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            final Query other = (Query) obj;
-            if ((this.queryString == null) ? (other.queryString != null) : !this.queryString.equals(other.queryString))
-                return false;
-            return true;
+            String qStr = "";
+            for (String pointStr : points)
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += "point=" + pointStr;
+            }
+            for (Entry<String, String> e : params.entrySet())
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += e.getKey() + "=" + encodeURL(e.getValue());
+            }
+
+            return qStr;
+        }
+
+        static String encodeURL( String str )
+        {
+            try
+            {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore)
+            {
+                return str;
+            }
         }
 
         @Override
         public String toString()
         {
-            return queryString;
+            return createQueryString();
         }
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 23b5bbe438..94afcf8e3d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.AStar;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStar( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugAStar( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index 77df456145..f7872e7bcf 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.AStarBidirection;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStarBi( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugAStarBi( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index c53ee5ffb3..0ee0376450 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.DijkstraBidirectionRef;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugDijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,13 +48,13 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.BLUE);
         }
         // System.out.println("new node:" + currLoc);
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index ff91a22c38..3b6e1264fa 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.EdgeEntry;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraSimple( Graph graph, FlagEncoder encoder, Weighting weighting, GraphicsWrapper mg )
+    public DebugDijkstraSimple( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java b/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java
deleted file mode 100644
index 546a2d3229..0000000000
--- a/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.ui;
-
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.Location2IDQuadtree;
-import java.awt.Color;
-import java.awt.Graphics2D;
-
-/**
- * @author Peter Karich
- */
-class DebugLocation2IDQuadtree extends Location2IDQuadtree
-{
-    private GraphicsWrapper mg;
-    private Graphics2D g2;
-
-    public DebugLocation2IDQuadtree( Graph g, GraphicsWrapper mg, Directory dir )
-    {
-        super(g, dir);
-        this.mg = mg;
-    }
-
-    public void setGraphics( Graphics2D g2 )
-    {
-        this.g2 = g2;
-        double w = getMaxRasterWidthMeter();
-        // System.out.println("w:" + w);
-        double startLon = mg.getLon(0);
-        double lat1 = mg.getLat(0);
-        double lat2 = mg.getLat(500);
-        g2.setColor(Color.ORANGE);
-        int lines = 1000;
-        for (int i = 0; i < lines; i++)
-        {
-            double c1 = distCalc.calcCircumference(lat1);
-            double addLon1 = 360 * i * w / c1;
-            double c2 = distCalc.calcCircumference(lat1);
-            double addLon2 = 360 * i * w / c2;
-            int x1 = (int) mg.getX(startLon + addLon1);
-            int x2 = (int) mg.getX(startLon + addLon2);
-            g2.drawLine(x1, (int) mg.getY(lat1), x2, (int) mg.getY(lat2));
-        }
-    }
-
-    @Override
-    public int findID( double lat, double lon )
-    {
-        int ret = super.findID(lat, lon);
-        mg.plotNode(g2, ret, Color.GREEN);
-        return ret;
-    }
-
-    @Override
-    public void goFurtherHook( int n )
-    {
-        if (g2 != null)
-        {
-            mg.plotNode(g2, n, Color.RED);
-        }
-    }
-}
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 3daefdf17d..6d8038ee2c 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -20,17 +20,11 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FastestWeighting;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -53,7 +47,6 @@
  */
 public class MiniGraphUI
 {
-
     public static void main( String[] strs ) throws Exception
     {
         CmdArgs args = CmdArgs.read(strs);
@@ -63,10 +56,10 @@ public static void main( String[] strs ) throws Exception
     }
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
-    private AlgorithmPreparation prepare;
+    private RoutingAlgorithmFactory algoFactory;
     private final Graph graph;
     private final NodeAccess na;
-    private LocationIndex index;
+    private LocationIndexTree index;
     private String latLon = "";
     private GraphicsWrapper mg;
     private JPanel infoPanel;
@@ -75,23 +68,24 @@ public static void main( String[] strs ) throws Exception
     private final MapLayer pathLayer;
     private boolean fastPaint = false;
     private final Weighting weighting;
+    private final FlagEncoder encoder;
+    private AlgorithmOptions algoOpts;
 
     public MiniGraphUI( GraphHopper hopper, boolean debug )
     {
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
-        prepare = hopper.getPreparation();
-        FlagEncoder encoder = hopper.getEncodingManager().getSingle();
-        weighting = new FastestWeighting(encoder);
-        if (prepare == null)
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, "dijkstrabi", encoder, weighting);
+        algoFactory = hopper.getAlgorithmFactory();
+        encoder = hopper.getEncodingManager().getSingle();
+        weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
+        algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
-        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algo:" + prepare.createAlgo().getName());
+        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
 
         // prepare node quadtree to 'enter' the graph. create a 313*313 grid => <3km
 //         this.index = new DebugLocation2IDQuadtree(roadGraph, mg);
-        this.index = hopper.getLocationIndex();
+        this.index = (LocationIndexTree) hopper.getLocationIndex();
 //        this.algo = new DebugDijkstraBidirection(graph, mg);
         // this.algo = new DijkstraBidirection(graph);
 //        this.algo = new DebugAStar(graph, mg);
@@ -177,7 +171,12 @@ public void paintComponent( Graphics2D g2 )
                         }
                         double lat2 = na.getLatitude(nodeId);
                         double lon2 = na.getLongitude(nodeId);
+
+                        // mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, iter.getName());
+                        //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
+                        //g2.setColor(Color.BLACK);                        
                         mg.plotEdge(g2, lat, lon, lat2, lon2);
+                        g2.setColor(Color.BLACK);
                     }
                 }
             }
@@ -192,20 +191,31 @@ public void paintComponent( Graphics2D g2 )
                     return;
 
                 makeTransparent(g2);
-                RoutingAlgorithm algo = prepare.createAlgo();
+                QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
+                RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
                 if (algo instanceof DebugAlgo)
                 {
                     ((DebugAlgo) algo).setGraphics2D(g2);
                 }
 
                 StopWatch sw = new StopWatch().start();
-                fromRes = index.findClosest(49.973878, 11.604132, EdgeFilter.ALL_EDGES);
-                toRes = index.findClosest(49.973896, 11.604363, EdgeFilter.ALL_EDGES);
-
                 logger.info("start searching from:" + fromRes + " to:" + toRes + " " + weighting);
-                path = algo.calcPath(fromRes, toRes);
-//                mg.plotNode(g2, dijkstraFromId, Color.red);
-//                mg.plotNode(g2, dijkstraToId, Color.BLUE);
+
+//                GHPoint qp = fromRes.getQueryPoint();
+//                TIntHashSet set = index.findNetworkEntries(qp.lat, qp.lon, 1);
+//                TIntIterator nodeIter = set.iterator();
+//                DistanceCalc distCalc = new DistancePlaneProjection();
+//                System.out.println("set:" + set.size());
+//                while (nodeIter.hasNext())
+//                {
+//                    int nodeId = nodeIter.next();
+//                    double lat = graph.getNodeAccess().getLat(nodeId);
+//                    double lon = graph.getNodeAccess().getLon(nodeId);
+//                    int dist = (int) Math.round(distCalc.calcDist(qp.lat, qp.lon, lat, lon));
+//                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
+//                    mg.plotNode(g2, nodeId, Color.red);
+//                }
+                path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
                 // if directed edges
@@ -262,7 +272,7 @@ private Path plotPath( Path tmpPath, Graphics2D g2, int w )
 
         double prevLat = Double.NaN;
         double prevLon = Double.NaN;
-        boolean plotNodes = true;
+        boolean plotNodes = false;
         TIntList nodes = tmpPath.calcNodes();
         if (plotNodes)
         {
diff --git a/tools/src/main/resources/log4j.xml b/tools/src/main/resources/log4j.xml
new file mode 100644
index 0000000000..01cc086902
--- /dev/null
+++ b/tools/src/main/resources/log4j.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>   
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <!-- order important otherwise we'll get a warning -->
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/util/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
similarity index 92%
rename from core/src/test/java/com/graphhopper/util/QueryTortureTest.java
rename to tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index bb5bee81be..fa5d018259 100644
--- a/core/src/test/java/com/graphhopper/util/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -15,9 +15,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
-import com.graphhopper.util.QueryTorture.Query;
+import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -31,7 +31,7 @@
     public void testGetQuery()
     {
         Query result = Query.parse("2013-08-07 18:06:50,905 [qtp1329318374-81] INFO  graphhopper.http.GraphHopperServlet - point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp 46.4.67.134 en_US Wget/1.13.4 (linux-gnu) 51.076329, 13.738409->52.517037, 13.38886, distance: 189.4806800000001, time:123min, points:907, took:0.007393159, debug - idLookup:0.002483692s, algoInit:1.20837E-4s, dijkstraCH-routing:0.003138361s, extract time:1.66755E-4, simplify (1219->907):0.001040086s, instructions:2.26986E-4s, dijkstrabi, fastest, CAR");
-        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.queryString);
+        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.createQueryString());
         assertEquals(51.076329, result.start.lat, 1e-5);
         assertEquals(13.38886, result.end.lon, 1e-5);
     }
diff --git a/web/Readme.md b/web/Readme.md
deleted file mode 100644
index 498ba0e605..0000000000
--- a/web/Readme.md
+++ /dev/null
@@ -1,6 +0,0 @@
-This application uses jQuery and Leaflet to display the calculated route from GraphHopper.
-Execute `./graphhopper.sh web europe_germany_berlin.osm` in the parent folder. 
-Then go to [http://localhost:8989/](http://localhost:8989/).
-Get the raw json query [here](http://localhost:8989/route?from=52.439688,13.276863&to=52.532932,13.479424)
-
-[![GraphHopper Maps image](http://karussell.files.wordpress.com/2013/07/maps-preview1.png)](http://graphhopper.com/maps/?point=new%20york&point=los%20angeles)
\ No newline at end of file
diff --git a/web/nbactions.xml b/web/nbactions.xml
index 1f42dc1f31..53ff82d694 100644
--- a/web/nbactions.xml
+++ b/web/nbactions.xml
@@ -1,5 +1,15 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <actions>
+    <action>
+        <actionName>CUSTOM-install</actionName>
+        <displayName>install</displayName>
+        <goals>
+            <goal>install</goal>
+        </goals>
+        <properties>
+            <skipTests>true</skipTests>
+        </properties>
+    </action>
     <action>
         <actionName>CUSTOM-failsafe verify</actionName>
         <displayName>failsafe verify</displayName>
@@ -9,46 +19,46 @@
         </goals>
     </action>
     <action>
-            <actionName>run</actionName>
-            <packagings>
-                <packaging>jar</packaging>
-            </packagings>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
-            </goals>
-            <properties>
-                <exec.args>-classpath %classpath com.graphhopper.http.GHServer jetty.port=8900 config=../config.properties osmreader.osm=/media/SAMSUNG/maps/berlin.pbf</exec.args>
-                <exec.executable>java</exec.executable>
-            </properties>
-        </action>
+        <actionName>run</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+        </goals>
+        <properties>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
+        </properties>
+    </action>
     <action>
-            <actionName>debug</actionName>
-            <packagings>
-                <packaging>jar</packaging>
-            </packagings>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
-            </goals>
-            <properties>
-                <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.http.GHServer jetty.port=8900 config=../config.properties osmreader.osm=/media/SAMSUNG/maps/berlin.pbf</exec.args>
-                <exec.executable>java</exec.executable>
-                <jpda.listen>true</jpda.listen>
-            </properties>
-        </action>
+        <actionName>debug</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+        </goals>
+        <properties>
+            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
+            <jpda.listen>true</jpda.listen>
+        </properties>
+    </action>
     <action>
-            <actionName>profile</actionName>
-            <packagings>
-                <packaging>jar</packaging>
-            </packagings>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
-            </goals>
-            <properties>
-                <exec.args>-classpath %classpath com.graphhopper.http.GHServer jetty.port=8900 config=../config.properties osmreader.osm=/media/SAMSUNG/maps/berlin.pbf</exec.args>
-                <exec.executable>java</exec.executable>
-            </properties>
-        </action>
+        <actionName>profile</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+        </goals>
+        <properties>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
+        </properties>
+    </action>
 </actions>
diff --git a/web/pom.xml b/web/pom.xml
index 7712da1abf..e324010ffa 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,17 +6,17 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.4-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
         
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.4-SNAPSHOT</version>
     </parent>
     <properties>
-        <jetty.version>8.1.10.v20130312</jetty.version>
+        <jetty.version>8.1.16.v20140903</jetty.version>
     </properties>
     
     <dependencies>
@@ -25,21 +25,13 @@
             <artifactId>graphhopper</artifactId>
             <version>${project.parent.version}</version>            
         </dependency>
-        <!--  TODO <dependency>
-            <groupId>org.codehaus.jackson</groupId>
-            <artifactId>jackson-core-asl</artifactId>
-            <version>1.9.12</version>
-        </dependency>       
-        <dependency>
-            <groupId>org.codehaus.jackson</groupId>
-            <artifactId>jackson-mapper-asl</artifactId>
-            <version>1.9.12</version>
-        </dependency>-->
+        
         <dependency>
             <groupId>org.json</groupId>
             <artifactId>json</artifactId>
-            <version>20090211</version>            
-        </dependency>        
+            <version>20140107</version>            
+        </dependency>    
+        
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
@@ -52,11 +44,11 @@
             <artifactId>guice-servlet</artifactId>
             <version>3.0</version>
         </dependency>
-        
+                
         <dependency>
             <groupId>javax.servlet</groupId>
             <artifactId>javax.servlet-api</artifactId>
-            <version>3.0.1</version>
+            <version>3.1.0</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
@@ -117,7 +109,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.14</version>
+                <version>2.17</version>
             </plugin>
             <!-- create a jar file too, so others can use it more easily -->
             <plugin>
@@ -129,7 +121,7 @@
             </plugin>            
             <plugin>
                 <artifactId>maven-assembly-plugin</artifactId>
-                
+                <version>2.4.1</version>
                 <configuration>
                     <archive>
                         <manifest>
@@ -145,8 +137,9 @@
                 <executions>
                     <execution>
                         <id>make-assembly</id>
-                        <phase>package</phase>
-                        <goals>
+                        <!-- bind to verify and not package to pass integration tests before creating assemblies -->
+                        <phase>integration-test</phase> 
+                       <goals>
                             <goal>single</goal>
                         </goals>
                     </execution>
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
similarity index 52%
rename from core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java
rename to web/src/main/java/com/graphhopper/http/CORSFilter.java
index 726885a637..c29d7c55f9 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -1,40 +1,45 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing;
+package com.graphhopper.http;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
+import java.io.IOException;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletResponse;
+import org.eclipse.jetty.servlets.UserAgentFilter;
 
 /**
  * @author Peter Karich
  */
-public class DijkstraBidirectionTest extends AbstractRoutingAlgorithmTester
+public class CORSFilter extends UserAgentFilter
 {
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
     {
-        return new NoOpAlgorithmPreparation()
+        if (!"jsonp".equals(request.getParameter("type")))
         {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                return new DijkstraBidirection(_graph, encoder, w);
-            }
-        }.setGraph(defaultGraph);
+            HttpServletResponse rsp = (HttpServletResponse) response;
+            rsp.setHeader("Access-Control-Allow-Origin", "*");
+        }
+
+        super.doFilter(request, response, chain);
     }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index d265218196..7829d78286 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.search.Geocoding;
 import com.google.inject.AbstractModule;
 import com.google.inject.name.Names;
 import com.graphhopper.GraphHopper;
@@ -32,11 +31,34 @@
 public class DefaultModule extends AbstractModule
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final CmdArgs args;
+    protected final CmdArgs args;
+    private GraphHopper graphHopper;
 
     public DefaultModule( CmdArgs args )
     {
-        this.args = args;
+        this.args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+    }
+
+    public GraphHopper getGraphHopper()
+    {
+        if (graphHopper == null)
+            throw new IllegalStateException("createGraphHopper not called");
+
+        return graphHopper;
+    }
+
+    /**
+     * @return an initialized GraphHopper instance
+     */
+    protected GraphHopper createGraphHopper( CmdArgs args )
+    {
+        GraphHopper tmp = new GraphHopper().forServer().init(args);
+        tmp.importOrLoad();
+        logger.info("loaded graph at:" + tmp.getGraphHopperLocation()
+                + ", source:" + tmp.getOSMFile()
+                + ", flagEncoders:" + tmp.getEncodingManager()
+                + ", class:" + tmp.getGraph().getClass().getSimpleName());
+        return tmp;
     }
 
     @Override
@@ -44,21 +66,17 @@ protected void configure()
     {
         try
         {
-            GraphHopper hopper = new GraphHopper().forServer().init(args);
-            hopper.importOrLoad();
-            logger.info("loaded graph at:" + hopper.getGraphHopperLocation()
-                    + ", source:" + hopper.getOSMFile()
-                    + ", acceptWay:" + hopper.getEncodingManager()
-                    + ", class:" + hopper.getGraph().getClass().getSimpleName());
-
-            bind(GraphHopper.class).toInstance(hopper);
-
-            String algo = args.get("routing.defaultAlgorithm", "dijkstrabi");
-            bind(String.class).annotatedWith(Names.named("defaultAlgorithm")).toInstance(algo);
+            graphHopper = createGraphHopper(args);
+            bind(GraphHopper.class).toInstance(graphHopper);
+            bind(TranslationMap.class).toInstance(graphHopper.getTranslationMap());
 
             long timeout = args.getLong("web.timeout", 3000);
             bind(Long.class).annotatedWith(Names.named("timeout")).toInstance(timeout);
-            bind(TranslationMap.class).toInstance(new TranslationMap().doImport());
+            boolean jsonpAllowed = args.getBool("web.jsonpAllowed", false);
+            if (!jsonpAllowed)
+                logger.info("jsonp disabled");
+
+            bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index df0029a185..07fe5d9f38 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -18,6 +18,8 @@
 package com.graphhopper.http;
 
 import java.io.IOException;
+import javax.inject.Named;
+import javax.inject.Inject;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -33,6 +35,9 @@
 public class GHBaseServlet extends HttpServlet
 {
     protected Logger logger = LoggerFactory.getLogger(getClass());
+    @Inject
+    @Named("jsonpAllowed")
+    private boolean jsonpAllowed;
 
     protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException, IOException
     {
@@ -42,6 +47,12 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
         if ("jsonp".equals(type))
         {
             res.setContentType("application/javascript");
+            if (!jsonpAllowed)
+            {
+                res.sendError(SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+                return;
+            }
+
             String callbackName = getParam(req, "callback", null);
             if (callbackName == null)
             {
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 56b5be9d73..4a749c50ad 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -23,6 +23,7 @@
 import com.google.inject.Module;
 import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
+import java.net.InetSocketAddress;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.servlet.ServletHolder;
 
@@ -82,11 +83,13 @@ public void start( Injector injector ) throws Exception
         FilterHolder guiceFilter = new FilterHolder(injector.getInstance(GuiceFilter.class));
         servHandler.addFilter(guiceFilter, "/*", EnumSet.allOf(DispatcherType.class));
 
-        int httpPort = args.getInt("jetty.port", 8989);
         SelectChannelConnector connector0 = new SelectChannelConnector();
-        // don't allow access from outside!
-        // connector0.setHost("127.0.0.1");
+        int httpPort = args.getInt("jetty.port", 8989);
+        String host = args.get("jetty.host", "");
         connector0.setPort(httpPort);
+        if (!host.isEmpty())
+            connector0.setHost(host);
+
         server.addConnector(connector0);
 
         HandlerList handlers = new HandlerList();
@@ -96,10 +99,10 @@ public void start( Injector injector ) throws Exception
         });
         server.setHandler(handlers);
         server.start();
-        logger.info("Started server at HTTP " + httpPort);
+        logger.info("Started server at HTTP " + host + ":" + httpPort);
     }
 
-    private Module createModule()
+    protected Module createModule()
     {
         return new AbstractModule()
         {
@@ -109,7 +112,7 @@ protected void configure()
                 binder().requireExplicitBindings();
 
                 install(new DefaultModule(args));
-                install(new GHServletModule());
+                install(new GHServletModule(args));
 
                 bind(GuiceFilter.class);
             }
@@ -118,6 +121,9 @@ protected void configure()
 
     public void stop()
     {
+        if (server == null)
+            return;
+
         try
         {
             server.stop();
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 59b09da320..76c04d1493 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -1,24 +1,39 @@
 /*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 package com.graphhopper.http;
 
-import com.google.inject.Singleton;
 import com.google.inject.servlet.ServletModule;
+import com.graphhopper.util.CmdArgs;
 import java.util.HashMap;
 import java.util.Map;
+import javax.inject.Singleton;
 
 /**
  * @author Peter Karich
  */
 public class GHServletModule extends ServletModule
 {
-    @Override
-    protected void configureServlets()
+    protected Map<String, String> params = new HashMap<String, String>();
+    protected final CmdArgs args;
+
+    public GHServletModule( CmdArgs args )
     {
-        Map<String, String> params = new HashMap<String, String>();
+        this.args = args;
         params.put("mimeTypes", "text/html,"
                 + "text/plain,"
                 + "text/xml,"
@@ -27,14 +42,27 @@ protected void configureServlets()
                 + "application/json,"
                 + "application/javascript,"
                 + "image/svg+xml");
+    }
 
+    @Override
+    protected void configureServlets()
+    {
         filter("*").through(GHGZIPHook.class, params);
         bind(GHGZIPHook.class).in(Singleton.class);
 
+        filter("*").through(CORSFilter.class, params);
+        bind(CORSFilter.class).in(Singleton.class);
+
+        filter("*").through(IPFilter.class);
+        bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+
         serve("/i18n*").with(I18NServlet.class);
         bind(I18NServlet.class).in(Singleton.class);
 
-        serve("*").with(GraphHopperServlet.class);
+        serve("/info*").with(InfoServlet.class);
+        bind(InfoServlet.class).in(Singleton.class);
+
+        serve("/route*").with(GraphHopperServlet.class);
         bind(GraphHopperServlet.class).in(Singleton.class);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 7a68bd559d..8bda91cef0 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -21,21 +21,28 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.StorableProperties;
+import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.*;
-import com.graphhopper.util.TranslationMap.Translation;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.IOException;
+import java.io.StringWriter;
 import java.util.*;
+import java.util.Map.Entry;
 import javax.inject.Inject;
-import javax.inject.Named;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import static javax.servlet.http.HttpServletResponse.*;
-import org.json.JSONException;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
 import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
 
 /**
  * Servlet to use GraphHopper in a remote application (mobile or browser). Attention: If type is
@@ -46,27 +53,15 @@
  */
 public class GraphHopperServlet extends GHBaseServlet
 {
-
     @Inject
     private GraphHopper hopper;
-    @Inject
-    @Named("defaultAlgorithm")
-    private String defaultAlgorithm;
-    @Inject
-    private TranslationMap trMap;
 
     @Override
     public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
         try
         {
-            if ("/info".equals(req.getPathInfo()))
-            {
-                writeInfos(req, res);
-            } else if ("/route".equals(req.getPathInfo()))
-            {
-                writePath(req, res);
-            }
+            writePath(req, res);
         } catch (IllegalArgumentException ex)
         {
             writeError(res, SC_BAD_REQUEST, ex.getMessage());
@@ -77,105 +72,121 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         }
     }
 
-    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
     {
-        BBox bb = hopper.getGraph().getBounds();
-        List<Double> list = new ArrayList<Double>(4);
-        list.add(bb.minLon);
-        list.add(bb.minLat);
-        list.add(bb.maxLon);
-        list.add(bb.maxLat);
-
-        JSONObject json = new JSONObject();
-        json.put("bbox", list);
-        json.put("supported_vehicles", hopper.getGraph().getEncodingManager().toString().split(","));
-        json.put("version", Constants.VERSION);
-        json.put("build_date", Constants.BUILD_DATE);
-
-        StorableProperties props = hopper.getGraph().getProperties();
-        json.put("import_date", props.get("osmreader.import.date"));
-
-        if (!Helper.isEmpty(props.get("prepare.date")))
-            json.put("prepare_date", props.get("prepare.date"));
-
-        writeJson(req, res, json);
-    }
-
-    void writePath( HttpServletRequest req, HttpServletResponse res ) throws Exception
-    {
-        List<GHPlace> infoPoints = getPoints(req);
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
 
         // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(req, "min_path_precision", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-        String weighting = getParam(req, "weighting", "fastest");
-        String algoStr = getParam(req, "algorithm", defaultAlgorithm);
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        String vehicleStr = getParam(httpReq, "vehicle", "CAR").toUpperCase();
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
 
         StopWatch sw = new StopWatch().start();
-        GHResponse rsp;
-        if (hopper.getEncodingManager().supports(vehicleStr))
+        GHResponse ghRsp;
+        if (!hopper.getEncodingManager().supports(vehicleStr))
+        {
+            ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+        } else if (elevation && !hopper.hasElevation())
+        {
+            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
+        } else
         {
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-            rsp = hopper.route(new GHRequest(infoPoints).
-                    setVehicle(algoVehicle.toString()).
+            GHRequest request = new GHRequest(infoPoints);
+
+            initHints(request, httpReq.getParameterMap());
+            request.setVehicle(algoVehicle.toString()).
                     setWeighting(weighting).
                     setAlgorithm(algoStr).
-                    putHint("calcPoints", calcPoints).
-                    putHint("instructions", enableInstructions).
-                    putHint("douglas.minprecision", minPathPrecision));
-        } else
-        {
-            rsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+                    setLocale(localeStr).
+                    getHints().
+                    put("calcPoints", calcPoints).
+                    put("instructions", enableInstructions).
+                    put("wayPointMaxDistance", minPathPrecision);
+
+            ghRsp = hopper.route(request);
         }
 
         float took = sw.stop().getSeconds();
-        String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-        PointList points = rsp.getPoints();
-        String logStr = req.getQueryString() + " " + infoStr + " " + infoPoints
-                + ", distance: " + rsp.getDistance() + ", time:" + Math.round(rsp.getMillis() / 60000f)
-                + "min, points:" + points.getSize() + ", took:" + took
-                + ", debug - " + rsp.getDebugInfo() + ", " + algoStr + ", "
-                + weighting + ", " + vehicleStr;
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
-        if (rsp.hasErrors())
-            logger.error(logStr + ", errors:" + rsp.getErrors());
+        if (ghRsp.hasErrors())
+            logger.error(logStr + ", errors:" + ghRsp.getErrors());
         else
-            logger.info(logStr);
+            logger.info(logStr + ", distance: " + ghRsp.getDistance()
+                    + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
+                    + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
-            writeGPX(req, res, rsp);
+            writeResponse(res, createGPXString(httpReq, res, ghRsp));
         else
-            writeJson(req, res, rsp, took);
+            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
     }
 
-    private void writeGPX( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
+    protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
+            throws Exception
     {
+        boolean includeElevation = getBooleanParam(req, "elevation", false);
         res.setCharacterEncoding("UTF-8");
         res.setContentType("application/xml");
         String trackName = getParam(req, "track", "GraphHopper Track");
         res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
         String timeZone = getParam(req, "timezone", "GMT");
         long time = getLongParam(req, "millis", System.currentTimeMillis());
-        writeResponse(res, rsp.getInstructions().createGPX(trackName, time, timeZone));
+        if (rsp.hasErrors())
+            return errorsToXML(rsp.getErrors());
+        else
+            return rsp.getInstructions().createGPX(trackName, time, timeZone, includeElevation);
     }
 
-    private void writeJson( HttpServletRequest req, HttpServletResponse res,
-            GHResponse rsp, float took ) throws JSONException, IOException
+    String errorsToXML( List<Throwable> list ) throws Exception
+    {
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        DocumentBuilder builder = factory.newDocumentBuilder();
+        Document doc = builder.newDocument();
+        Element gpxElement = doc.createElement("gpx");
+        gpxElement.setAttribute("creator", "GraphHopper");
+        gpxElement.setAttribute("version", "1.1");
+        doc.appendChild(gpxElement);
+
+        Element mdElement = doc.createElement("metadata");
+        gpxElement.appendChild(mdElement);
+
+        Element errorsElement = doc.createElement("extensions");
+        mdElement.appendChild(errorsElement);
+
+        for (Throwable t : list)
+        {
+            Element error = doc.createElement("error");
+            errorsElement.appendChild(error);
+            error.setAttribute("message", t.getMessage());
+            error.setAttribute("details", t.getClass().getName());
+        }
+        TransformerFactory transformerFactory = TransformerFactory.newInstance();
+        Transformer transformer = transformerFactory.newTransformer();
+        StringWriter writer = new StringWriter();
+        transformer.transform(new DOMSource(doc), new StreamResult(writer));
+        return writer.toString();
+    }
+
+    protected Map<String, Object> createJson( HttpServletRequest req, GHResponse rsp, float took )
     {
         boolean enableInstructions = getBooleanParam(req, "instructions", true);
-        Locale locale = Helper.getLocale(getParam(req, "locale", "en"));
         boolean pointsEncoded = getBooleanParam(req, "points_encoded", true);
         boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        JSONObject json = new JSONObject();
-
-        JSONObject jsonPath = new JSONObject();
-        json.put("paths", Collections.singletonList(jsonPath));
-
-        JSONObject jsonInfo = new JSONObject();
+        boolean includeElevation = getBooleanParam(req, "elevation", false);
+        Map<String, Object> json = new HashMap<String, Object>();
+        Map<String, Object> jsonInfo = new HashMap<String, Object>();
         json.put("info", jsonInfo);
+        jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
 
         if (rsp.hasErrors())
         {
@@ -188,16 +199,12 @@ private void writeJson( HttpServletRequest req, HttpServletResponse res,
                 list.add(map);
             }
             jsonInfo.put("errors", list);
-        } else if (!rsp.isFound())
-        {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put("message", "Not found");
-            map.put("details", "");
-            jsonInfo.put("errors", Collections.singletonList(map));
         } else
         {
-            jsonInfo.put("took", took);
-            jsonPath.put("distance", rsp.getDistance());
+            jsonInfo.put("took", Math.round(took * 1000));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
             jsonPath.put("time", rsp.getMillis());
 
             if (calcPoints)
@@ -208,48 +215,57 @@ private void writeJson( HttpServletRequest req, HttpServletResponse res,
                 if (points.getSize() >= 2)
                     jsonPath.put("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
 
-                jsonPath.put("points", createPoints(points, pointsEncoded));
-                jsonPath.put("points_dimension", points.getDimension());
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
                 if (enableInstructions)
                 {
-                    Translation tr = trMap.getWithFallBack(locale);
                     InstructionList instructions = rsp.getInstructions();
-                    jsonPath.put("instructions", instructions.createJson(tr));
+                    jsonPath.put("instructions", instructions.createJson());
                 }
             }
+            json.put("paths", Collections.singletonList(jsonPath));
         }
-
-        writeJson(req, res, json);
+        return json;
     }
 
-    Object createPoints( PointList points, boolean pointsEncoded ) throws JSONException
+    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
     {
         if (pointsEncoded)
-            return WebHelper.encodePolyline(points);
+            return WebHelper.encodePolyline(points, includeElevation);
 
-        JSONObject jsonPoints = new JSONObject();
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
         jsonPoints.put("type", "LineString");
-        jsonPoints.put("coordinates", points.toGeoJson());
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
         return jsonPoints;
     }
 
-    private List<GHPlace> getPoints( HttpServletRequest req ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
     {
-        String[] pointsAsStr = getParams(req, "point");
-        final List<GHPlace> infoPoints = new ArrayList<GHPlace>();
-        for (int pointNo = 0; pointNo < pointsAsStr.length; pointNo++)
+        String[] pointsAsStr = getParams(req, key);
+        final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
+        for (String str : pointsAsStr)
         {
-            final String str = pointsAsStr[pointNo];
             String[] fromStrs = str.split(",");
             if (fromStrs.length == 2)
             {
-                GHPlace place = GHPlace.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                {
+                    infoPoints.add(point);
+                }
             }
         }
 
         return infoPoints;
     }
+
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    {
+        WeightingMap m = request.getHints();
+        for (Entry<String, String[]> e : parameterMap.entrySet())
+        {
+            if (e.getValue().length == 1)
+                m.put(e.getKey(), e.getValue()[0]);
+        }
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 9e114a2a57..c1445d9616 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -20,12 +20,9 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
-import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -40,17 +37,24 @@
 {
     public static void main( String[] args )
     {
-        GraphHopperAPI gh = new GraphHopperWeb();
-        gh.load("http://localhost:8989/route");
+        GraphHopperWeb gh = new GraphHopperWeb();
+        gh.setKey("<your-key>");
+
+        // for local server: gh.load("http://localhost:8989/route");        
+        gh.load("https://graphhopper.com/api/1/route");
+
         //GHResponse ph = gh.route(new GHRequest(53.080827, 9.074707, 50.597186, 11.184082));
         GHResponse ph = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180));
         System.out.println(ph);
     }
-    private Logger logger = LoggerFactory.getLogger(getClass());
+    private final Logger logger = LoggerFactory.getLogger(getClass());
     private String serviceUrl;
     private boolean pointsEncoded = true;
     private Downloader downloader = new Downloader("GraphHopperWeb");
     private boolean instructions = true;
+    private String key = "";
+    private boolean withElevation = false;
+    private final TranslationMap trMap = new TranslationMap().doImport();
 
     public GraphHopperWeb()
     {
@@ -83,6 +87,18 @@ public GraphHopperWeb setInstructions( boolean b )
         return this;
     }
 
+    public GraphHopperWeb setElevation( boolean withElevation )
+    {
+        this.withElevation = withElevation;
+        return this;
+    }
+
+    public GraphHopperWeb setKey( String key )
+    {
+        this.key = key;
+        return this;
+    }
+
     @Override
     public GHResponse route( GHRequest request )
     {
@@ -91,80 +107,122 @@ public GHResponse route( GHRequest request )
         try
         {
             String places = "";
-            for (GHPlace p : request.getPlaces())
+            for (GHPoint p : request.getPoints())
             {
                 places += "point=" + p.lat + "," + p.lon + "&";
             }
+
             String url = serviceUrl
                     + "?"
                     + places
                     + "&type=json"
                     + "&points_encoded=" + pointsEncoded
-                    + "&min_path_precision=" + request.getHint("douglas.minprecision", 1)
-                    + "&algo=" + request.getAlgorithm();
+                    + "&way_point_max_distance=" + request.getHints().getDouble("wayPointMaxDistance", 1)
+                    + "&algo=" + request.getAlgorithm()
+                    + "&locale=" + request.getLocale().toString()
+                    + "&elevation=" + withElevation;
+
+            if (!request.getVehicle().isEmpty())
+                url += "&vehicle=" + request.getVehicle();
+
+            if (!key.isEmpty())
+                url += "&key=" + key;
+
             String str = downloader.downloadAsString(url);
             JSONObject json = new JSONObject(str);
-            took = json.getJSONObject("info").getDouble("took");
-            JSONArray paths = json.getJSONArray("paths");
-            JSONObject firstPath = paths.getJSONObject(0);
-
-            boolean is3D = false;
-            if (firstPath.has("points_dim"))
-                is3D = "3".equals(firstPath.getString("points_dim"));
-            double distance = firstPath.getDouble("distance");
-            int time = firstPath.getInt("time");
-            PointList pointList;
-            if (pointsEncoded)
+            GHResponse res = new GHResponse();
+
+            if (json.getJSONObject("info").has("errors"))
             {
-                pointList = WebHelper.decodePolyline(firstPath.getString("points"), 100, is3D);
+                JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
+
+                for (int i = 0; i < errors.length(); i++)
+                {
+                    JSONObject error = errors.getJSONObject(i);
+                    String exClass = error.getString("details");
+                    String exMessage = error.getString("message");
+
+                    if (exClass.equals(UnsupportedOperationException.class.getName()))
+                    {
+                        res.addError(new UnsupportedOperationException(exMessage));
+                    } else if (exClass.equals(IllegalStateException.class.getName()))
+                    {
+                        res.addError(new IllegalStateException(exMessage));
+                    } else if (exClass.equals(RuntimeException.class.getName()))
+                    {
+                        res.addError(new RuntimeException(exMessage));
+                    } else if (exClass.equals(IllegalArgumentException.class.getName()))
+                    {
+                        res.addError(new IllegalArgumentException(exMessage));
+                    } else
+                    {
+                        res.addError(new Exception(exClass + " " + exMessage));
+                    }
+                }
+
+                return res;
+
             } else
             {
-                JSONArray coords = firstPath.getJSONObject("points").getJSONArray("coordinates");
-                pointList = new PointList(coords.length(), is3D);
-                for (int i = 0; i < coords.length(); i++)
+                took = json.getJSONObject("info").getDouble("took");
+                JSONArray paths = json.getJSONArray("paths");
+                JSONObject firstPath = paths.getJSONObject(0);
+                double distance = firstPath.getDouble("distance");
+                int time = firstPath.getInt("time");
+                PointList pointList;
+                if (pointsEncoded)
                 {
-                    JSONArray arr = coords.getJSONArray(i);
-                    double lon = arr.getDouble(0);
-                    double lat = arr.getDouble(1);
-                    if (is3D)
-                        pointList.add(lat, lon, arr.getDouble(2));
-                    else
-                        pointList.add(lat, lon);
+                    String pointStr = firstPath.getString("points");
+                    pointList = WebHelper.decodePolyline(pointStr, 100, withElevation);
+                } else
+                {
+                    JSONArray coords = firstPath.getJSONObject("points").getJSONArray("coordinates");
+                    pointList = new PointList(coords.length(), withElevation);
+                    for (int i = 0; i < coords.length(); i++)
+                    {
+                        JSONArray arr = coords.getJSONArray(i);
+                        double lon = arr.getDouble(0);
+                        double lat = arr.getDouble(1);
+                        if (withElevation)
+                            pointList.add(lat, lon, arr.getDouble(2));
+                        else
+                            pointList.add(lat, lon);
+                    }
                 }
-            }
-            GHResponse res = new GHResponse();
-            if (instructions)
-            {
-                JSONArray instrArr = firstPath.getJSONArray("instructions");
 
-                InstructionList il = new InstructionList();
-                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
+                if (instructions)
                 {
-                    JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
-                    double instDist = jsonObj.getDouble("distance");
-                    String text = jsonObj.getString("text");
-                    long instTime = jsonObj.getLong("time");
-                    int sign = jsonObj.getInt("sign");
-                    JSONArray iv = jsonObj.getJSONArray("interval");
-                    int from = iv.getInt(0);
-                    int to = iv.getInt(1);
-                    PointList instPL = new PointList(to - from, is3D);
-                    for (int j = from; j <= to; j++)
+                    JSONArray instrArr = firstPath.getJSONArray("instructions");
+
+                    InstructionList il = new InstructionList(trMap.getWithFallBack(request.getLocale()));
+                    for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
                     {
-                        instPL.add(pointList, j);
-                    }
+                        JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
+                        double instDist = jsonObj.getDouble("distance");
+                        String text = jsonObj.getString("text");
+                        long instTime = jsonObj.getLong("time");
+                        int sign = jsonObj.getInt("sign");
+                        JSONArray iv = jsonObj.getJSONArray("interval");
+                        int from = iv.getInt(0);
+                        int to = iv.getInt(1);
+                        PointList instPL = new PointList(to - from, withElevation);
+                        for (int j = from; j <= to; j++)
+                        {
+                            instPL.add(pointList, j);
+                        }
 
-                    // TODO way and payment type
-                    Instruction instr = new Instruction(sign, text, -1, -1, instPL).
-                            setDistance(instDist).setTime(instTime);
-                    il.add(instr);
+                        // TODO way and payment type
+                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
+                                setDistance(instDist).setTime(instTime);
+                        il.add(instr);
+                    }
+                    res.setInstructions(il);
                 }
-                res.setInstructions(il);
+                return res.setPoints(pointList).setDistance(distance).setMillis(time);
             }
-            return res.setPoints(pointList).setDistance(distance).setMillis(time);
         } catch (Exception ex)
         {
-            throw new RuntimeException("Problem while fetching path " + request.getPlaces(), ex);
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
         } finally
         {
             logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
diff --git a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
index 118f2fa147..830e6e03cd 100644
--- a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
+++ b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
@@ -24,7 +24,7 @@
 import com.graphhopper.util.CmdArgs;
 
 /**
- * Replacement of web.xml
+ * Replacement of web.xml used only for container deployment. Preferred method is to use GHServer.
  * <p/>
  * http://code.google.com/p/google-guice/wiki/ServletModule
  * <p/>
@@ -32,6 +32,19 @@
  */
 public class GuiceServletConfig extends GuiceServletContextListener
 {
+    private final CmdArgs args;
+
+    public GuiceServletConfig()
+    {
+        try
+        {
+            args = CmdArgs.readFromConfig("config.properties", "graphhopper.config");
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+
     @Override
     protected Injector getInjector()
     {
@@ -40,11 +53,11 @@ protected Injector getInjector()
 
     protected Module createDefaultModule()
     {
-        return new DefaultModule(new CmdArgs());
+        return new DefaultModule(args);
     }
 
     protected Module createServletModule()
     {
-        return new GHServletModule();
+        return new GHServletModule(args);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 714ae86582..833246508a 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -19,7 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.TranslationMap;
-import com.graphhopper.util.TranslationMap.Translation;
+import com.graphhopper.util.Translation;
 import java.io.IOException;
 import java.util.Locale;
 import javax.inject.Inject;
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
new file mode 100644
index 0000000000..9b40dd4c02
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -0,0 +1,116 @@
+package com.graphhopper.http;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+import javax.servlet.*;
+import javax.servlet.http.HttpServletResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
+ * <p>
+ * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
+ * <p>
+ * The internal ip filter from jetty did not work (NP exceptions)
+ * <p>
+ * @author Peter Karich
+ */
+public class IPFilter implements Filter
+{
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Set<String> whites;
+    private final Set<String> blacks;
+
+    public IPFilter( String whiteList, String blackList )
+    {
+        whites = createSet(whiteList.split(","));
+        blacks = createSet(blackList.split(","));
+        if (!whites.isEmpty())
+            logger.debug("whitelist:" + whites);
+        if (!blackList.isEmpty())
+            logger.debug("blacklist:" + blacks);
+
+        if (!blacks.isEmpty() && !whites.isEmpty())
+            throw new IllegalArgumentException("blacklist and whitelist at the same time?");
+    }
+
+    @Override
+    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
+    {
+        String ip = request.getRemoteAddr();
+        if (accept(ip))
+        {
+            chain.doFilter(request, response);
+        } else
+        {
+            logger.warn("Did not accept IP " + ip);
+            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_FORBIDDEN);
+        }
+    }
+
+    public boolean accept( String ip )
+    {
+        if (whites.isEmpty() && blacks.isEmpty())
+            return true;
+
+        if (!whites.isEmpty())
+        {
+            for (String w : whites)
+            {
+                if (simpleMatch(ip, w))
+                    return true;
+            }
+            return false;
+        }
+
+        if (blacks.isEmpty())
+            throw new IllegalStateException("cannot happen");
+
+        for (String b : blacks)
+        {
+            if (simpleMatch(ip, b))
+                return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public void init( FilterConfig filterConfig ) throws ServletException
+    {
+    }
+
+    @Override
+    public void destroy()
+    {
+    }
+
+    private Set<String> createSet( String[] split )
+    {
+        Set<String> set = new HashSet<String>(split.length);
+        for (String str : split)
+        {
+            str = str.trim();
+            if (!str.isEmpty())
+                set.add(str);
+        }
+        return set;
+    }
+
+    public boolean simpleMatch( String ip, String pattern )
+    {
+        String[] ipParts = pattern.split("\\*");
+        for (String ipPart : ipParts)
+        {
+            int idx = ip.indexOf(ipPart);
+            if (idx == -1)
+                return false;
+
+            ip = ip.substring(idx + ipPart.length());
+        }
+
+        return true;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
new file mode 100644
index 0000000000..824d5c3ee1
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -0,0 +1,94 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.storage.StorableProperties;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.json.JSONObject;
+
+/**
+ * @author Peter Karich
+ */
+public class InfoServlet extends GHBaseServlet
+{
+    @Inject
+    private GraphHopper hopper;
+
+    @Override
+    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    {
+        try
+        {
+            writeInfos(req, res);
+        } catch (IllegalArgumentException ex)
+        {
+            writeError(res, SC_BAD_REQUEST, ex.getMessage());
+        } catch (Exception ex)
+        {
+            logger.error("Error while executing request: " + req.getQueryString(), ex);
+            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+        }
+    }
+
+    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    {
+        BBox bb = hopper.getGraph().getBounds();
+        List<Double> list = new ArrayList<Double>(4);
+        list.add(bb.minLon);
+        list.add(bb.minLat);
+        list.add(bb.maxLon);
+        list.add(bb.maxLat);
+
+        JSONObject json = new JSONObject();
+        json.put("bbox", list);
+
+        String[] vehicles = hopper.getGraph().getEncodingManager().toString().split(",");
+        json.put("supported_vehicles", vehicles);
+        JSONObject features = new JSONObject();
+        for (String v : vehicles)
+        {
+            JSONObject perVehicleJson = new JSONObject();
+            perVehicleJson.put("elevation", hopper.hasElevation());
+            features.put(v, perVehicleJson);
+        }
+        json.put("features", features);
+
+        json.put("version", Constants.VERSION);
+        json.put("build_date", Constants.BUILD_DATE);
+
+        StorableProperties props = hopper.getGraph().getProperties();
+        json.put("import_date", props.get("osmreader.import.date"));
+
+        if (!Helper.isEmpty(props.get("prepare.date")))
+            json.put("prepare_date", props.get("prepare.date"));
+
+        writeJson(req, res, json);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index 28829bb68e..b320b38854 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -16,20 +16,21 @@
 package com.graphhopper.http;
 
 import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
+import org.json.JSONObject;
 
-public class InvalidRequestServlet extends HttpServlet
+public class InvalidRequestServlet extends GHBaseServlet
 {
-
     @Override
-    protected void service( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException
+    protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
-        resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
-        resp.setContentType("text/plain");
-        resp.setContentType("UTF-8");
-        resp.getWriter().append("404");
+        res.setStatus(HttpServletResponse.SC_NOT_FOUND);
+        res.setContentType("text/plain");
+        res.setContentType("UTF-8");
+        JSONObject json = new JSONObject();
+        json.put("error_code", "404");
+        writeJson(req, res, json);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index 28631f4ca6..f9cc20ae9a 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -40,9 +40,9 @@
 {
     public static void main( String[] args )
     {
-        System.out.println("search " + new NominatimGeocoder().name2point(new GHPlace("bayreuth"), new GHPlace("berlin")));
+        System.out.println("search " + new NominatimGeocoder().names2places(new GHPlace("bayreuth"), new GHPlace("berlin")));
 
-        System.out.println("reverse " + new NominatimGeocoder().point2name(new GHPlace(49.9027606, 11.577197),
+        System.out.println("reverse " + new NominatimGeocoder().places2names(new GHPlace(49.9027606, 11.577197),
                 new GHPlace(52.5198535, 13.4385964)));
     }
     private String nominatimUrl;
@@ -71,7 +71,7 @@ public NominatimGeocoder setBounds( BBox bounds )
     }
 
     @Override
-    public List<GHPlace> name2point( GHPlace... places )
+    public List<GHPlace> names2places( GHPlace... places )
     {
         List<GHPlace> resList = new ArrayList<GHPlace>();
         for (GHPlace place : places)
@@ -105,7 +105,7 @@ public NominatimGeocoder setBounds( BBox bounds )
     }
 
     @Override
-    public List<GHPlace> point2name( GHPlace... points )
+    public List<GHPlace> places2names( GHPlace... points )
     {
         List<GHPlace> resList = new ArrayList<GHPlace>();
         for (GHPlace point : points)
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 3767f34904..02e515b8e9 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -25,6 +25,12 @@
 import java.net.URLEncoder;
 
 /**
+ * Code which handles polyline encoding and other web stuff.
+ * <p>
+ * The necessary information for polyline encoding is in this answer:
+ * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
+ * good explanation.
+ * <p>
  * @author Peter Karich
  */
 public class WebHelper
@@ -91,8 +97,15 @@ public static PointList decodePolyline( String encoded, int initCap, boolean is3
         return poly;
     }
 
-    // https://developers.google.com/maps/documentation/utilities/polylinealgorithm?hl=de
     public static String encodePolyline( PointList poly )
+    {
+        if (poly.isEmpty())
+            return "";
+
+        return encodePolyline(poly, poly.is3D());
+    }
+
+    public static String encodePolyline( PointList poly, boolean includeElevation )
     {
         StringBuilder sb = new StringBuilder();
         int size = poly.getSize();
@@ -107,7 +120,7 @@ public static String encodePolyline( PointList poly )
             num = (int) Math.floor(poly.getLongitude(i) * 1e5);
             encodeNumber(sb, num - prevLon);
             prevLon = num;
-            if (poly.is3D())
+            if (includeElevation)
             {
                 num = (int) Math.floor(poly.getElevation(i) * 100);
                 encodeNumber(sb, num - prevEle);
diff --git a/web/src/main/resources/log4j.xml b/web/src/main/resources/log4j.xml
new file mode 100644
index 0000000000..01cc086902
--- /dev/null
+++ b/web/src/main/resources/log4j.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>   
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <!-- order important otherwise we'll get a warning -->
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/web/src/main/webapp/css/images/loading.gif b/web/src/main/webapp/css/images/loading.gif
new file mode 100644
index 0000000000..ed65b705af
Binary files /dev/null and b/web/src/main/webapp/css/images/loading.gif differ
diff --git a/web/src/main/webapp/css/leaflet.contextmenu.css b/web/src/main/webapp/css/leaflet.contextmenu.css
new file mode 100644
index 0000000000..568e1a889a
--- /dev/null
+++ b/web/src/main/webapp/css/leaflet.contextmenu.css
@@ -0,0 +1,62 @@
+.leaflet-contextmenu {
+    display: none;
+	box-shadow: 0 1px 7px rgba(0,0,0,0.4);
+	-webkit-border-radius: 4px;
+	border-radius: 4px;
+    padding: 4px 0;
+    background-color: #fff;
+    cursor: default;
+	-webkit-user-select: none;
+	-moz-user-select: none;
+	user-select: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item {
+    display: block;
+    color: #222;
+    font-size: 12px;
+    line-height: 20px;
+    text-decoration: none;
+    padding: 0 12px;
+    border-top: 1px solid transparent;
+    border-bottom: 1px solid transparent;
+    cursor: default;
+    outline: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-disabled {
+    opacity: 0.5;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-hidden {
+    display: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item.over {
+    background-color: #f4f4f4;
+    border-top: 1px solid #f0f0f0;
+    border-bottom: 1px solid #f0f0f0;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-disabled.over {
+    background-color: inherit;
+    border-top: 1px solid transparent;
+    border-bottom: 1px solid transparent;
+}
+
+.leaflet-contextmenu-icon {
+    margin: 2px 8px 0 0;
+    width: 16px;
+    height: 16px;
+    float: left;
+    border: 0;
+}
+
+.leaflet-contextmenu-separator {
+    border-bottom: 1px solid #ccc;
+    margin: 5px 0;
+}
+
+.leaflet-contextmenu-separator-hidden {
+    display: none;
+}
\ No newline at end of file
diff --git a/web/src/main/webapp/css/leaflet.loading.css b/web/src/main/webapp/css/leaflet.loading.css
new file mode 100644
index 0000000000..79657a4741
--- /dev/null
+++ b/web/src/main/webapp/css/leaflet.loading.css
@@ -0,0 +1,22 @@
+.leaflet-control-loading {
+    background: url(images/loading.gif);
+}
+
+.leaflet-control-loading,
+.leaflet-control-zoom a.leaflet-control-loading ,
+.leaflet-control-zoomslider a.leaflet-control-loading {
+    display: none;
+}
+
+.leaflet-control-loading.is-loading,
+.leaflet-control-zoom a.leaflet-control-loading.is-loading,
+.leaflet-control-zoomslider a.leaflet-control-loading.is-loading  {
+    display: block;
+}
+
+/* Necessary for display consistency in Leaflet >= 0.6 */
+.leaflet-bar-part-bottom {
+    border-bottom: medium none;
+    border-bottom-left-radius: 4px;
+    border-bottom-right-radius: 4px;
+}
diff --git a/web/src/main/webapp/css/style.css b/web/src/main/webapp/css/style.css
index 2b682424f9..0d796d4261 100644
--- a/web/src/main/webapp/css/style.css
+++ b/web/src/main/webapp/css/style.css
@@ -5,17 +5,17 @@ body {
     color: #111111;
     background-color: white;
     margin: 0;
+    min-width: 600px;
 }
-#map {
-    /*    float: right;*/
-    width: 800px;
-    height: 600px;
+#map {    
+    /* set size via JS */
     cursor: default;
 }
+
 #input {
     float: left;                
-    padding-left: 10px; 
-    padding-right: 15px; 
+    margin-left: 10px; 
+    /*padding-right: 15px; */
 }
 
 #info {
@@ -29,19 +29,19 @@ body {
     padding-right: 5px;
 }
 #input, #instructions {
-    width: 255px;
+    width: 280px;
 }
-#fromInput, #toInput {
-    width: 225px;
-    float: right;    
+.pointInput {
+    width: 235px;
+    float: left;
 }
 
-#fromResolveFound a, #toResolveFound a {
+.pointResolveFound a {
     background-color: white;
     padding-left: 4px;
     padding-right: 3px;    
 }
-#fromResolveFound, #toResolveFound {
+.pointResolveFound {
     overflow: hidden;
     max-height: 24px;
     font-size: 10px;
@@ -52,10 +52,12 @@ body {
     margin-right: 2px;    
 }
 
-#fromResolveError, #toResolveError {
-    float: right;
+.pointResolveError {
+    float: left;
     font-size: 12px;
     padding-bottom: 4px;
+    width: 100%;
+    text-align: right;
 }
 
 .boxSizingBorder {
@@ -66,7 +68,7 @@ body {
 .warn {
     color: orange;
 }
-.error, #fromResolveError, #toResolveError {
+.error, .pointResolveError {
     color: red;
 }
 #moreattribution a {
@@ -79,9 +81,13 @@ body {
 }
 #locationpoints {
     padding-bottom: 10px;
+    float: left;
 }
-#fromDiv img, #toDiv img {
-    margin-top: 6px;
+.pointDiv { 
+    margin: 6px 0;
+}
+.pointDiv > img {
+    margin-top: 4px;
     padding-left: 3px;
     padding-right: 3px;
     float: left;
@@ -89,6 +95,9 @@ body {
 .left {
     float: left;
 }
+.right {
+    float: right;
+}
 #routeDetails {
     padding: 20px;
     font-size: 12px;
@@ -131,6 +140,10 @@ body {
     float: right;
     margin-bottom: 5px;
 }
+
+#searchButton:hover { 
+    cursor: pointer; 
+}
 .clear {
     clear: both;
 }
@@ -142,20 +155,32 @@ body {
     /* color: #666666; */
     font-size: smaller;
     opacity: 0.8;
+    width: 200px;
+}
+
+#footer {
+    position: fixed;
+    bottom: 5px;
+    left: 45px;
 }
-#hosting a {
+
+#hosting a, .footer-link {
     text-decoration: none;
     color: #00cc33;
 }
-#exportLink {
+.footer-link {    
+    padding-right: 12px;    
+    font-size: 12px;    
+}
+
+#export-link {
+    padding-left: 3px;
+    padding-top: 3px;
     float: left;
 }
-.instruction {    
+
+tr.instruction {
     cursor: pointer;
-    padding-top: 5px;
-    padding-bottom: 5px;
-}
-tr.instruction td {    
     border-bottom: #dadada dashed thin;
 }
 #instructions {
@@ -165,9 +190,11 @@ tr.instruction td {
     width: 100%;
     font-size: smaller;
 }
+
 #instructions th, #instructions td {
-    padding: 3px;
+    padding: 6px 3px;
 }
+
 td.instr_title {
     width: 130px;
 }
@@ -208,8 +235,15 @@ td img.pic {
     background-image: linear-gradient(to bottom, #9f9f9f, #e7e7e7);    
 }
 
-.complete-1, .complete-2 { border: 1px solid #999; background: #FFF; overflow: auto; }
-.complete-1 strong, .complete-2 strong { font-weight: normal; color: #04B431; }
+.autocomplete {
+    border: 1px solid #999; 
+    background: #FFF; 
+    overflow: auto; 
+}
+.autocomplete strong { 
+    font-weight: normal;
+    color: #04B431; 
+}
 .autocomplete-suggestion { 
     padding: 5px 5px; 
     white-space: nowrap; 
@@ -218,7 +252,8 @@ td img.pic {
     background-image: linear-gradient(to bottom, white, #e7e7e7);
 }
 .autocomplete-selected { 
-    padding: 5px 5px; background: #e7e7e7; 
+    padding: 5px 5px; 
+    background: #e7e7e7; 
     background-image: linear-gradient(to bottom, #9f9f9f, #e7e7e7);
 }
 .light { font-weight: lighter; color: #9f9f9f; font-size: smaller }
@@ -229,6 +264,20 @@ td img.pic {
 .cityseg { float: left; font-size: 10px; }
 .moreseg { float: right; font-size: 9px; }
 
+.pointFlag {
+    width: 16px;
+    height: 16px;
+}
+.pointFlag:hover { cursor: n-resize; }
+.pointAdd {
+    padding-left: 3px;
+}
+.pointDelete {
+    float: left;    
+    padding-left: 2px;
+}
+.pointDelete:hover, .pointAdd:hover { cursor: pointer; }
+
 #expandDetails {
     color: gray;
     font-size:14px; 
@@ -241,4 +290,4 @@ td img.pic {
 }
 #moreButton {
     background-image: linear-gradient(to bottom, white, #e7e7e7);
-}
\ No newline at end of file
+}
diff --git a/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif b/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif
new file mode 100644
index 0000000000..d441f75ebf
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png
new file mode 100644
index 0000000000..4e691deaa0
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png
new file mode 100644
index 0000000000..7bc8a92833
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png
new file mode 100644
index 0000000000..c5d10e6570
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png
new file mode 100644
index 0000000000..ae8f555ac4
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png
new file mode 100644
index 0000000000..c2c57063a1
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png
new file mode 100644
index 0000000000..b559b14a93
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png
new file mode 100644
index 0000000000..f8b3d68025
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png
new file mode 100644
index 0000000000..c121135c6d
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png
new file mode 100644
index 0000000000..9c7d2f6b6b
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png
new file mode 100644
index 0000000000..1106eef30c
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png
new file mode 100644
index 0000000000..8c64a89499
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png
new file mode 100644
index 0000000000..760f14a327
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png
new file mode 100644
index 0000000000..21fd40e9c6
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png
new file mode 100644
index 0000000000..7cfcb5c95f
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css
new file mode 100644
index 0000000000..5ce18d9e9c
--- /dev/null
+++ b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css
@@ -0,0 +1,1178 @@
+/*! jQuery UI - v1.10.4 - 2014-04-02
+* http://jqueryui.com
+* Includes: jquery.ui.core.css, jquery.ui.accordion.css, jquery.ui.autocomplete.css, jquery.ui.button.css, jquery.ui.datepicker.css, jquery.ui.dialog.css, jquery.ui.menu.css, jquery.ui.progressbar.css, jquery.ui.resizable.css, jquery.ui.selectable.css, jquery.ui.slider.css, jquery.ui.spinner.css, jquery.ui.tabs.css, jquery.ui.tooltip.css, jquery.ui.theme.css
+* To view and modify this theme, visit http://jqueryui.com/themeroller/?ffDefault=Trebuchet%20MS%2CTahoma%2CVerdana%2CArial%2Csans-serif&fwDefault=bold&fsDefault=1.1em&cornerRadius=4px&bgColorHeader=f6a828&bgTextureHeader=gloss_wave&bgImgOpacityHeader=35&borderColorHeader=e78f08&fcHeader=ffffff&iconColorHeader=ffffff&bgColorContent=eeeeee&bgTextureContent=highlight_soft&bgImgOpacityContent=100&borderColorContent=dddddd&fcContent=333333&iconColorContent=222222&bgColorDefault=f6f6f6&bgTextureDefault=glass&bgImgOpacityDefault=100&borderColorDefault=cccccc&fcDefault=1c94c4&iconColorDefault=ef8c08&bgColorHover=fdf5ce&bgTextureHover=glass&bgImgOpacityHover=100&borderColorHover=fbcb09&fcHover=c77405&iconColorHover=ef8c08&bgColorActive=ffffff&bgTextureActive=glass&bgImgOpacityActive=65&borderColorActive=fbd850&fcActive=eb8f00&iconColorActive=ef8c08&bgColorHighlight=ffe45c&bgTextureHighlight=highlight_soft&bgImgOpacityHighlight=75&borderColorHighlight=fed22f&fcHighlight=363636&iconColorHighlight=228ef1&bgColorError=b81900&bgTextureError=diagonals_thick&bgImgOpacityError=18&borderColorError=cd0a0a&fcError=ffffff&iconColorError=ffd27a&bgColorOverlay=666666&bgTextureOverlay=diagonals_thick&bgImgOpacityOverlay=20&opacityOverlay=50&bgColorShadow=000000&bgTextureShadow=flat&bgImgOpacityShadow=10&opacityShadow=20&thicknessShadow=5px&offsetTopShadow=-5px&offsetLeftShadow=-5px&cornerRadiusShadow=5px
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+/* Layout helpers
+----------------------------------*/
+.ui-helper-hidden {
+	display: none;
+}
+.ui-helper-hidden-accessible {
+	border: 0;
+	clip: rect(0 0 0 0);
+	height: 1px;
+	margin: -1px;
+	overflow: hidden;
+	padding: 0;
+	position: absolute;
+	width: 1px;
+}
+.ui-helper-reset {
+	margin: 0;
+	padding: 0;
+	border: 0;
+	outline: 0;
+	line-height: 1.3;
+	text-decoration: none;
+	font-size: 100%;
+	list-style: none;
+}
+.ui-helper-clearfix:before,
+.ui-helper-clearfix:after {
+	content: "";
+	display: table;
+	border-collapse: collapse;
+}
+.ui-helper-clearfix:after {
+	clear: both;
+}
+.ui-helper-clearfix {
+	min-height: 0; /* support: IE7 */
+}
+.ui-helper-zfix {
+	width: 100%;
+	height: 100%;
+	top: 0;
+	left: 0;
+	position: absolute;
+	opacity: 0;
+	filter:Alpha(Opacity=0);
+}
+
+.ui-front {
+	z-index: 100;
+}
+
+
+/* Interaction Cues
+----------------------------------*/
+.ui-state-disabled {
+	cursor: default !important;
+}
+
+
+/* Icons
+----------------------------------*/
+
+/* states and images */
+.ui-icon {
+	display: block;
+	text-indent: -99999px;
+	overflow: hidden;
+	background-repeat: no-repeat;
+}
+
+
+/* Misc visuals
+----------------------------------*/
+
+/* Overlays */
+.ui-widget-overlay {
+	position: fixed;
+	top: 0;
+	left: 0;
+	width: 100%;
+	height: 100%;
+}
+.ui-accordion .ui-accordion-header {
+	display: block;
+	cursor: pointer;
+	position: relative;
+	margin-top: 2px;
+	padding: .5em .5em .5em .7em;
+	min-height: 0; /* support: IE7 */
+}
+.ui-accordion .ui-accordion-icons {
+	padding-left: 2.2em;
+}
+.ui-accordion .ui-accordion-noicons {
+	padding-left: .7em;
+}
+.ui-accordion .ui-accordion-icons .ui-accordion-icons {
+	padding-left: 2.2em;
+}
+.ui-accordion .ui-accordion-header .ui-accordion-header-icon {
+	position: absolute;
+	left: .5em;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-accordion .ui-accordion-content {
+	padding: 1em 2.2em;
+	border-top: 0;
+	overflow: auto;
+}
+.ui-autocomplete {
+	position: absolute;
+	top: 0;
+	left: 0;
+	cursor: default;
+}
+.ui-button {
+	display: inline-block;
+	position: relative;
+	padding: 0;
+	line-height: normal;
+	margin-right: .1em;
+	cursor: pointer;
+	vertical-align: middle;
+	text-align: center;
+	overflow: visible; /* removes extra width in IE */
+}
+.ui-button,
+.ui-button:link,
+.ui-button:visited,
+.ui-button:hover,
+.ui-button:active {
+	text-decoration: none;
+}
+/* to make room for the icon, a width needs to be set here */
+.ui-button-icon-only {
+	width: 2.2em;
+}
+/* button elements seem to need a little more width */
+button.ui-button-icon-only {
+	width: 2.4em;
+}
+.ui-button-icons-only {
+	width: 3.4em;
+}
+button.ui-button-icons-only {
+	width: 3.7em;
+}
+
+/* button text element */
+.ui-button .ui-button-text {
+	display: block;
+	line-height: normal;
+}
+.ui-button-text-only .ui-button-text {
+	padding: .4em 1em;
+}
+.ui-button-icon-only .ui-button-text,
+.ui-button-icons-only .ui-button-text {
+	padding: .4em;
+	text-indent: -9999999px;
+}
+.ui-button-text-icon-primary .ui-button-text,
+.ui-button-text-icons .ui-button-text {
+	padding: .4em 1em .4em 2.1em;
+}
+.ui-button-text-icon-secondary .ui-button-text,
+.ui-button-text-icons .ui-button-text {
+	padding: .4em 2.1em .4em 1em;
+}
+.ui-button-text-icons .ui-button-text {
+	padding-left: 2.1em;
+	padding-right: 2.1em;
+}
+/* no icon support for input elements, provide padding by default */
+input.ui-button {
+	padding: .4em 1em;
+}
+
+/* button icon element(s) */
+.ui-button-icon-only .ui-icon,
+.ui-button-text-icon-primary .ui-icon,
+.ui-button-text-icon-secondary .ui-icon,
+.ui-button-text-icons .ui-icon,
+.ui-button-icons-only .ui-icon {
+	position: absolute;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-button-icon-only .ui-icon {
+	left: 50%;
+	margin-left: -8px;
+}
+.ui-button-text-icon-primary .ui-button-icon-primary,
+.ui-button-text-icons .ui-button-icon-primary,
+.ui-button-icons-only .ui-button-icon-primary {
+	left: .5em;
+}
+.ui-button-text-icon-secondary .ui-button-icon-secondary,
+.ui-button-text-icons .ui-button-icon-secondary,
+.ui-button-icons-only .ui-button-icon-secondary {
+	right: .5em;
+}
+
+/* button sets */
+.ui-buttonset {
+	margin-right: 7px;
+}
+.ui-buttonset .ui-button {
+	margin-left: 0;
+	margin-right: -.3em;
+}
+
+/* workarounds */
+/* reset extra padding in Firefox, see h5bp.com/l */
+input.ui-button::-moz-focus-inner,
+button.ui-button::-moz-focus-inner {
+	border: 0;
+	padding: 0;
+}
+.ui-datepicker {
+	width: 17em;
+	padding: .2em .2em 0;
+	display: none;
+}
+.ui-datepicker .ui-datepicker-header {
+	position: relative;
+	padding: .2em 0;
+}
+.ui-datepicker .ui-datepicker-prev,
+.ui-datepicker .ui-datepicker-next {
+	position: absolute;
+	top: 2px;
+	width: 1.8em;
+	height: 1.8em;
+}
+.ui-datepicker .ui-datepicker-prev-hover,
+.ui-datepicker .ui-datepicker-next-hover {
+	top: 1px;
+}
+.ui-datepicker .ui-datepicker-prev {
+	left: 2px;
+}
+.ui-datepicker .ui-datepicker-next {
+	right: 2px;
+}
+.ui-datepicker .ui-datepicker-prev-hover {
+	left: 1px;
+}
+.ui-datepicker .ui-datepicker-next-hover {
+	right: 1px;
+}
+.ui-datepicker .ui-datepicker-prev span,
+.ui-datepicker .ui-datepicker-next span {
+	display: block;
+	position: absolute;
+	left: 50%;
+	margin-left: -8px;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-datepicker .ui-datepicker-title {
+	margin: 0 2.3em;
+	line-height: 1.8em;
+	text-align: center;
+}
+.ui-datepicker .ui-datepicker-title select {
+	font-size: 1em;
+	margin: 1px 0;
+}
+.ui-datepicker select.ui-datepicker-month,
+.ui-datepicker select.ui-datepicker-year {
+	width: 49%;
+}
+.ui-datepicker table {
+	width: 100%;
+	font-size: .9em;
+	border-collapse: collapse;
+	margin: 0 0 .4em;
+}
+.ui-datepicker th {
+	padding: .7em .3em;
+	text-align: center;
+	font-weight: bold;
+	border: 0;
+}
+.ui-datepicker td {
+	border: 0;
+	padding: 1px;
+}
+.ui-datepicker td span,
+.ui-datepicker td a {
+	display: block;
+	padding: .2em;
+	text-align: right;
+	text-decoration: none;
+}
+.ui-datepicker .ui-datepicker-buttonpane {
+	background-image: none;
+	margin: .7em 0 0 0;
+	padding: 0 .2em;
+	border-left: 0;
+	border-right: 0;
+	border-bottom: 0;
+}
+.ui-datepicker .ui-datepicker-buttonpane button {
+	float: right;
+	margin: .5em .2em .4em;
+	cursor: pointer;
+	padding: .2em .6em .3em .6em;
+	width: auto;
+	overflow: visible;
+}
+.ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current {
+	float: left;
+}
+
+/* with multiple calendars */
+.ui-datepicker.ui-datepicker-multi {
+	width: auto;
+}
+.ui-datepicker-multi .ui-datepicker-group {
+	float: left;
+}
+.ui-datepicker-multi .ui-datepicker-group table {
+	width: 95%;
+	margin: 0 auto .4em;
+}
+.ui-datepicker-multi-2 .ui-datepicker-group {
+	width: 50%;
+}
+.ui-datepicker-multi-3 .ui-datepicker-group {
+	width: 33.3%;
+}
+.ui-datepicker-multi-4 .ui-datepicker-group {
+	width: 25%;
+}
+.ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header,
+.ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header {
+	border-left-width: 0;
+}
+.ui-datepicker-multi .ui-datepicker-buttonpane {
+	clear: left;
+}
+.ui-datepicker-row-break {
+	clear: both;
+	width: 100%;
+	font-size: 0;
+}
+
+/* RTL support */
+.ui-datepicker-rtl {
+	direction: rtl;
+}
+.ui-datepicker-rtl .ui-datepicker-prev {
+	right: 2px;
+	left: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-next {
+	left: 2px;
+	right: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-prev:hover {
+	right: 1px;
+	left: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-next:hover {
+	left: 1px;
+	right: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane {
+	clear: right;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane button {
+	float: left;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current,
+.ui-datepicker-rtl .ui-datepicker-group {
+	float: right;
+}
+.ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header,
+.ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header {
+	border-right-width: 0;
+	border-left-width: 1px;
+}
+.ui-dialog {
+	overflow: hidden;
+	position: absolute;
+	top: 0;
+	left: 0;
+	padding: .2em;
+	outline: 0;
+}
+.ui-dialog .ui-dialog-titlebar {
+	padding: .4em 1em;
+	position: relative;
+}
+.ui-dialog .ui-dialog-title {
+	float: left;
+	margin: .1em 0;
+	white-space: nowrap;
+	width: 90%;
+	overflow: hidden;
+	text-overflow: ellipsis;
+}
+.ui-dialog .ui-dialog-titlebar-close {
+	position: absolute;
+	right: .3em;
+	top: 50%;
+	width: 20px;
+	margin: -10px 0 0 0;
+	padding: 1px;
+	height: 20px;
+}
+.ui-dialog .ui-dialog-content {
+	position: relative;
+	border: 0;
+	padding: .5em 1em;
+	background: none;
+	overflow: auto;
+}
+.ui-dialog .ui-dialog-buttonpane {
+	text-align: left;
+	border-width: 1px 0 0 0;
+	background-image: none;
+	margin-top: .5em;
+	padding: .3em 1em .5em .4em;
+}
+.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset {
+	float: right;
+}
+.ui-dialog .ui-dialog-buttonpane button {
+	margin: .5em .4em .5em 0;
+	cursor: pointer;
+}
+.ui-dialog .ui-resizable-se {
+	width: 12px;
+	height: 12px;
+	right: -5px;
+	bottom: -5px;
+	background-position: 16px 16px;
+}
+.ui-draggable .ui-dialog-titlebar {
+	cursor: move;
+}
+.ui-menu {
+	list-style: none;
+	padding: 2px;
+	margin: 0;
+	display: block;
+	outline: none;
+}
+.ui-menu .ui-menu {
+	margin-top: -3px;
+	position: absolute;
+}
+.ui-menu .ui-menu-item {
+	margin: 0;
+	padding: 0;
+	width: 100%;
+	/* support: IE10, see #8844 */
+	list-style-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);
+}
+.ui-menu .ui-menu-divider {
+	margin: 5px -2px 5px -2px;
+	height: 0;
+	font-size: 0;
+	line-height: 0;
+	border-width: 1px 0 0 0;
+}
+.ui-menu .ui-menu-item a {
+	text-decoration: none;
+	display: block;
+	padding: 2px .4em;
+	line-height: 1.5;
+	min-height: 0; /* support: IE7 */
+	font-weight: normal;
+}
+.ui-menu .ui-menu-item a.ui-state-focus,
+.ui-menu .ui-menu-item a.ui-state-active {
+	font-weight: normal;
+	margin: -1px;
+}
+
+.ui-menu .ui-state-disabled {
+	font-weight: normal;
+	margin: .4em 0 .2em;
+	line-height: 1.5;
+}
+.ui-menu .ui-state-disabled a {
+	cursor: default;
+}
+
+/* icon support */
+.ui-menu-icons {
+	position: relative;
+}
+.ui-menu-icons .ui-menu-item a {
+	position: relative;
+	padding-left: 2em;
+}
+
+/* left-aligned */
+.ui-menu .ui-icon {
+	position: absolute;
+	top: .2em;
+	left: .2em;
+}
+
+/* right-aligned */
+.ui-menu .ui-menu-icon {
+	position: static;
+	float: right;
+}
+.ui-progressbar {
+	height: 2em;
+	text-align: left;
+	overflow: hidden;
+}
+.ui-progressbar .ui-progressbar-value {
+	margin: -1px;
+	height: 100%;
+}
+.ui-progressbar .ui-progressbar-overlay {
+	background: url("images/animated-overlay.gif");
+	height: 100%;
+	filter: alpha(opacity=25);
+	opacity: 0.25;
+}
+.ui-progressbar-indeterminate .ui-progressbar-value {
+	background-image: none;
+}
+.ui-resizable {
+	position: relative;
+}
+.ui-resizable-handle {
+	position: absolute;
+	font-size: 0.1px;
+	display: block;
+}
+.ui-resizable-disabled .ui-resizable-handle,
+.ui-resizable-autohide .ui-resizable-handle {
+	display: none;
+}
+.ui-resizable-n {
+	cursor: n-resize;
+	height: 7px;
+	width: 100%;
+	top: -5px;
+	left: 0;
+}
+.ui-resizable-s {
+	cursor: s-resize;
+	height: 7px;
+	width: 100%;
+	bottom: -5px;
+	left: 0;
+}
+.ui-resizable-e {
+	cursor: e-resize;
+	width: 7px;
+	right: -5px;
+	top: 0;
+	height: 100%;
+}
+.ui-resizable-w {
+	cursor: w-resize;
+	width: 7px;
+	left: -5px;
+	top: 0;
+	height: 100%;
+}
+.ui-resizable-se {
+	cursor: se-resize;
+	width: 12px;
+	height: 12px;
+	right: 1px;
+	bottom: 1px;
+}
+.ui-resizable-sw {
+	cursor: sw-resize;
+	width: 9px;
+	height: 9px;
+	left: -5px;
+	bottom: -5px;
+}
+.ui-resizable-nw {
+	cursor: nw-resize;
+	width: 9px;
+	height: 9px;
+	left: -5px;
+	top: -5px;
+}
+.ui-resizable-ne {
+	cursor: ne-resize;
+	width: 9px;
+	height: 9px;
+	right: -5px;
+	top: -5px;
+}
+.ui-selectable-helper {
+	position: absolute;
+	z-index: 100;
+	border: 1px dotted black;
+}
+.ui-slider {
+	position: relative;
+	text-align: left;
+}
+.ui-slider .ui-slider-handle {
+	position: absolute;
+	z-index: 2;
+	width: 1.2em;
+	height: 1.2em;
+	cursor: default;
+}
+.ui-slider .ui-slider-range {
+	position: absolute;
+	z-index: 1;
+	font-size: .7em;
+	display: block;
+	border: 0;
+	background-position: 0 0;
+}
+
+/* For IE8 - See #6727 */
+.ui-slider.ui-state-disabled .ui-slider-handle,
+.ui-slider.ui-state-disabled .ui-slider-range {
+	filter: inherit;
+}
+
+.ui-slider-horizontal {
+	height: .8em;
+}
+.ui-slider-horizontal .ui-slider-handle {
+	top: -.3em;
+	margin-left: -.6em;
+}
+.ui-slider-horizontal .ui-slider-range {
+	top: 0;
+	height: 100%;
+}
+.ui-slider-horizontal .ui-slider-range-min {
+	left: 0;
+}
+.ui-slider-horizontal .ui-slider-range-max {
+	right: 0;
+}
+
+.ui-slider-vertical {
+	width: .8em;
+	height: 100px;
+}
+.ui-slider-vertical .ui-slider-handle {
+	left: -.3em;
+	margin-left: 0;
+	margin-bottom: -.6em;
+}
+.ui-slider-vertical .ui-slider-range {
+	left: 0;
+	width: 100%;
+}
+.ui-slider-vertical .ui-slider-range-min {
+	bottom: 0;
+}
+.ui-slider-vertical .ui-slider-range-max {
+	top: 0;
+}
+.ui-spinner {
+	position: relative;
+	display: inline-block;
+	overflow: hidden;
+	padding: 0;
+	vertical-align: middle;
+}
+.ui-spinner-input {
+	border: none;
+	background: none;
+	color: inherit;
+	padding: 0;
+	margin: .2em 0;
+	vertical-align: middle;
+	margin-left: .4em;
+	margin-right: 22px;
+}
+.ui-spinner-button {
+	width: 16px;
+	height: 50%;
+	font-size: .5em;
+	padding: 0;
+	margin: 0;
+	text-align: center;
+	position: absolute;
+	cursor: default;
+	display: block;
+	overflow: hidden;
+	right: 0;
+}
+/* more specificity required here to override default borders */
+.ui-spinner a.ui-spinner-button {
+	border-top: none;
+	border-bottom: none;
+	border-right: none;
+}
+/* vertically center icon */
+.ui-spinner .ui-icon {
+	position: absolute;
+	margin-top: -8px;
+	top: 50%;
+	left: 0;
+}
+.ui-spinner-up {
+	top: 0;
+}
+.ui-spinner-down {
+	bottom: 0;
+}
+
+/* TR overrides */
+.ui-spinner .ui-icon-triangle-1-s {
+	/* need to fix icons sprite */
+	background-position: -65px -16px;
+}
+.ui-tabs {
+	position: relative;/* position: relative prevents IE scroll bug (element with position: relative inside container with overflow: auto appear as "fixed") */
+	padding: .2em;
+}
+.ui-tabs .ui-tabs-nav {
+	margin: 0;
+	padding: .2em .2em 0;
+}
+.ui-tabs .ui-tabs-nav li {
+	list-style: none;
+	float: left;
+	position: relative;
+	top: 0;
+	margin: 1px .2em 0 0;
+	border-bottom-width: 0;
+	padding: 0;
+	white-space: nowrap;
+}
+.ui-tabs .ui-tabs-nav .ui-tabs-anchor {
+	float: left;
+	padding: .5em 1em;
+	text-decoration: none;
+}
+.ui-tabs .ui-tabs-nav li.ui-tabs-active {
+	margin-bottom: -1px;
+	padding-bottom: 1px;
+}
+.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,
+.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,
+.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor {
+	cursor: text;
+}
+.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor {
+	cursor: pointer;
+}
+.ui-tabs .ui-tabs-panel {
+	display: block;
+	border-width: 0;
+	padding: 1em 1.4em;
+	background: none;
+}
+.ui-tooltip {
+	padding: 8px;
+	position: absolute;
+	z-index: 9999;
+	max-width: 300px;
+	-webkit-box-shadow: 0 0 5px #aaa;
+	box-shadow: 0 0 5px #aaa;
+}
+body .ui-tooltip {
+	border-width: 2px;
+}
+
+/* Component containers
+----------------------------------*/
+.ui-widget {
+	font-family: Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;
+	font-size: 1.1em;
+}
+.ui-widget .ui-widget {
+	font-size: 1em;
+}
+.ui-widget input,
+.ui-widget select,
+.ui-widget textarea,
+.ui-widget button {
+	font-family: Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;
+	font-size: 1em;
+}
+.ui-widget-content {
+	border: 1px solid #dddddd;
+	background: #eeeeee url("images/ui-bg_highlight-soft_100_eeeeee_1x100.png") 50% top repeat-x;
+	color: #333333;
+}
+.ui-widget-content a {
+	color: #333333;
+}
+.ui-widget-header {
+	border: 1px solid #e78f08;
+	background: #f6a828 url("images/ui-bg_gloss-wave_35_f6a828_500x100.png") 50% 50% repeat-x;
+	color: #ffffff;
+	font-weight: bold;
+}
+.ui-widget-header a {
+	color: #ffffff;
+}
+
+/* Interaction states
+----------------------------------*/
+.ui-state-default,
+.ui-widget-content .ui-state-default,
+.ui-widget-header .ui-state-default {
+	border: 1px solid #cccccc;
+	background: #f6f6f6 url("images/ui-bg_glass_100_f6f6f6_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #1c94c4;
+}
+.ui-state-default a,
+.ui-state-default a:link,
+.ui-state-default a:visited {
+	color: #1c94c4;
+	text-decoration: none;
+}
+.ui-state-hover,
+.ui-widget-content .ui-state-hover,
+.ui-widget-header .ui-state-hover,
+.ui-state-focus,
+.ui-widget-content .ui-state-focus,
+.ui-widget-header .ui-state-focus {
+	border: 1px solid #fbcb09;
+	background: #fdf5ce url("images/ui-bg_glass_100_fdf5ce_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #c77405;
+}
+.ui-state-hover a,
+.ui-state-hover a:hover,
+.ui-state-hover a:link,
+.ui-state-hover a:visited,
+.ui-state-focus a,
+.ui-state-focus a:hover,
+.ui-state-focus a:link,
+.ui-state-focus a:visited {
+	color: #c77405;
+	text-decoration: none;
+}
+.ui-state-active,
+.ui-widget-content .ui-state-active,
+.ui-widget-header .ui-state-active {
+	border: 1px solid #fbd850;
+	background: #ffffff url("images/ui-bg_glass_65_ffffff_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #eb8f00;
+}
+.ui-state-active a,
+.ui-state-active a:link,
+.ui-state-active a:visited {
+	color: #eb8f00;
+	text-decoration: none;
+}
+
+/* Interaction Cues
+----------------------------------*/
+.ui-state-highlight,
+.ui-widget-content .ui-state-highlight,
+.ui-widget-header .ui-state-highlight {
+	border: 1px solid #fed22f;
+	background: #ffe45c url("images/ui-bg_highlight-soft_75_ffe45c_1x100.png") 50% top repeat-x;
+	color: #363636;
+}
+.ui-state-highlight a,
+.ui-widget-content .ui-state-highlight a,
+.ui-widget-header .ui-state-highlight a {
+	color: #363636;
+}
+.ui-state-error,
+.ui-widget-content .ui-state-error,
+.ui-widget-header .ui-state-error {
+	border: 1px solid #cd0a0a;
+	background: #b81900 url("images/ui-bg_diagonals-thick_18_b81900_40x40.png") 50% 50% repeat;
+	color: #ffffff;
+}
+.ui-state-error a,
+.ui-widget-content .ui-state-error a,
+.ui-widget-header .ui-state-error a {
+	color: #ffffff;
+}
+.ui-state-error-text,
+.ui-widget-content .ui-state-error-text,
+.ui-widget-header .ui-state-error-text {
+	color: #ffffff;
+}
+.ui-priority-primary,
+.ui-widget-content .ui-priority-primary,
+.ui-widget-header .ui-priority-primary {
+	font-weight: bold;
+}
+.ui-priority-secondary,
+.ui-widget-content .ui-priority-secondary,
+.ui-widget-header .ui-priority-secondary {
+	opacity: .7;
+	filter:Alpha(Opacity=70);
+	font-weight: normal;
+}
+.ui-state-disabled,
+.ui-widget-content .ui-state-disabled,
+.ui-widget-header .ui-state-disabled {
+	opacity: .35;
+	filter:Alpha(Opacity=35);
+	background-image: none;
+}
+.ui-state-disabled .ui-icon {
+	filter:Alpha(Opacity=35); /* For IE8 - See #6059 */
+}
+
+/* Icons
+----------------------------------*/
+
+/* states and images */
+.ui-icon {
+	width: 16px;
+	height: 16px;
+}
+.ui-icon,
+.ui-widget-content .ui-icon {
+	background-image: url("images/ui-icons_222222_256x240.png");
+}
+.ui-widget-header .ui-icon {
+	background-image: url("images/ui-icons_ffffff_256x240.png");
+}
+.ui-state-default .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-hover .ui-icon,
+.ui-state-focus .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-active .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-highlight .ui-icon {
+	background-image: url("images/ui-icons_228ef1_256x240.png");
+}
+.ui-state-error .ui-icon,
+.ui-state-error-text .ui-icon {
+	background-image: url("images/ui-icons_ffd27a_256x240.png");
+}
+
+/* positioning */
+.ui-icon-blank { background-position: 16px 16px; }
+.ui-icon-carat-1-n { background-position: 0 0; }
+.ui-icon-carat-1-ne { background-position: -16px 0; }
+.ui-icon-carat-1-e { background-position: -32px 0; }
+.ui-icon-carat-1-se { background-position: -48px 0; }
+.ui-icon-carat-1-s { background-position: -64px 0; }
+.ui-icon-carat-1-sw { background-position: -80px 0; }
+.ui-icon-carat-1-w { background-position: -96px 0; }
+.ui-icon-carat-1-nw { background-position: -112px 0; }
+.ui-icon-carat-2-n-s { background-position: -128px 0; }
+.ui-icon-carat-2-e-w { background-position: -144px 0; }
+.ui-icon-triangle-1-n { background-position: 0 -16px; }
+.ui-icon-triangle-1-ne { background-position: -16px -16px; }
+.ui-icon-triangle-1-e { background-position: -32px -16px; }
+.ui-icon-triangle-1-se { background-position: -48px -16px; }
+.ui-icon-triangle-1-s { background-position: -64px -16px; }
+.ui-icon-triangle-1-sw { background-position: -80px -16px; }
+.ui-icon-triangle-1-w { background-position: -96px -16px; }
+.ui-icon-triangle-1-nw { background-position: -112px -16px; }
+.ui-icon-triangle-2-n-s { background-position: -128px -16px; }
+.ui-icon-triangle-2-e-w { background-position: -144px -16px; }
+.ui-icon-arrow-1-n { background-position: 0 -32px; }
+.ui-icon-arrow-1-ne { background-position: -16px -32px; }
+.ui-icon-arrow-1-e { background-position: -32px -32px; }
+.ui-icon-arrow-1-se { background-position: -48px -32px; }
+.ui-icon-arrow-1-s { background-position: -64px -32px; }
+.ui-icon-arrow-1-sw { background-position: -80px -32px; }
+.ui-icon-arrow-1-w { background-position: -96px -32px; }
+.ui-icon-arrow-1-nw { background-position: -112px -32px; }
+.ui-icon-arrow-2-n-s { background-position: -128px -32px; }
+.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
+.ui-icon-arrow-2-e-w { background-position: -160px -32px; }
+.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
+.ui-icon-arrowstop-1-n { background-position: -192px -32px; }
+.ui-icon-arrowstop-1-e { background-position: -208px -32px; }
+.ui-icon-arrowstop-1-s { background-position: -224px -32px; }
+.ui-icon-arrowstop-1-w { background-position: -240px -32px; }
+.ui-icon-arrowthick-1-n { background-position: 0 -48px; }
+.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
+.ui-icon-arrowthick-1-e { background-position: -32px -48px; }
+.ui-icon-arrowthick-1-se { background-position: -48px -48px; }
+.ui-icon-arrowthick-1-s { background-position: -64px -48px; }
+.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
+.ui-icon-arrowthick-1-w { background-position: -96px -48px; }
+.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
+.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
+.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
+.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
+.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
+.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
+.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
+.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
+.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
+.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
+.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
+.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
+.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
+.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
+.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
+.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
+.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
+.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
+.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
+.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
+.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
+.ui-icon-arrow-4 { background-position: 0 -80px; }
+.ui-icon-arrow-4-diag { background-position: -16px -80px; }
+.ui-icon-extlink { background-position: -32px -80px; }
+.ui-icon-newwin { background-position: -48px -80px; }
+.ui-icon-refresh { background-position: -64px -80px; }
+.ui-icon-shuffle { background-position: -80px -80px; }
+.ui-icon-transfer-e-w { background-position: -96px -80px; }
+.ui-icon-transferthick-e-w { background-position: -112px -80px; }
+.ui-icon-folder-collapsed { background-position: 0 -96px; }
+.ui-icon-folder-open { background-position: -16px -96px; }
+.ui-icon-document { background-position: -32px -96px; }
+.ui-icon-document-b { background-position: -48px -96px; }
+.ui-icon-note { background-position: -64px -96px; }
+.ui-icon-mail-closed { background-position: -80px -96px; }
+.ui-icon-mail-open { background-position: -96px -96px; }
+.ui-icon-suitcase { background-position: -112px -96px; }
+.ui-icon-comment { background-position: -128px -96px; }
+.ui-icon-person { background-position: -144px -96px; }
+.ui-icon-print { background-position: -160px -96px; }
+.ui-icon-trash { background-position: -176px -96px; }
+.ui-icon-locked { background-position: -192px -96px; }
+.ui-icon-unlocked { background-position: -208px -96px; }
+.ui-icon-bookmark { background-position: -224px -96px; }
+.ui-icon-tag { background-position: -240px -96px; }
+.ui-icon-home { background-position: 0 -112px; }
+.ui-icon-flag { background-position: -16px -112px; }
+.ui-icon-calendar { background-position: -32px -112px; }
+.ui-icon-cart { background-position: -48px -112px; }
+.ui-icon-pencil { background-position: -64px -112px; }
+.ui-icon-clock { background-position: -80px -112px; }
+.ui-icon-disk { background-position: -96px -112px; }
+.ui-icon-calculator { background-position: -112px -112px; }
+.ui-icon-zoomin { background-position: -128px -112px; }
+.ui-icon-zoomout { background-position: -144px -112px; }
+.ui-icon-search { background-position: -160px -112px; }
+.ui-icon-wrench { background-position: -176px -112px; }
+.ui-icon-gear { background-position: -192px -112px; }
+.ui-icon-heart { background-position: -208px -112px; }
+.ui-icon-star { background-position: -224px -112px; }
+.ui-icon-link { background-position: -240px -112px; }
+.ui-icon-cancel { background-position: 0 -128px; }
+.ui-icon-plus { background-position: -16px -128px; }
+.ui-icon-plusthick { background-position: -32px -128px; }
+.ui-icon-minus { background-position: -48px -128px; }
+.ui-icon-minusthick { background-position: -64px -128px; }
+.ui-icon-close { background-position: -80px -128px; }
+.ui-icon-closethick { background-position: -96px -128px; }
+.ui-icon-key { background-position: -112px -128px; }
+.ui-icon-lightbulb { background-position: -128px -128px; }
+.ui-icon-scissors { background-position: -144px -128px; }
+.ui-icon-clipboard { background-position: -160px -128px; }
+.ui-icon-copy { background-position: -176px -128px; }
+.ui-icon-contact { background-position: -192px -128px; }
+.ui-icon-image { background-position: -208px -128px; }
+.ui-icon-video { background-position: -224px -128px; }
+.ui-icon-script { background-position: -240px -128px; }
+.ui-icon-alert { background-position: 0 -144px; }
+.ui-icon-info { background-position: -16px -144px; }
+.ui-icon-notice { background-position: -32px -144px; }
+.ui-icon-help { background-position: -48px -144px; }
+.ui-icon-check { background-position: -64px -144px; }
+.ui-icon-bullet { background-position: -80px -144px; }
+.ui-icon-radio-on { background-position: -96px -144px; }
+.ui-icon-radio-off { background-position: -112px -144px; }
+.ui-icon-pin-w { background-position: -128px -144px; }
+.ui-icon-pin-s { background-position: -144px -144px; }
+.ui-icon-play { background-position: 0 -160px; }
+.ui-icon-pause { background-position: -16px -160px; }
+.ui-icon-seek-next { background-position: -32px -160px; }
+.ui-icon-seek-prev { background-position: -48px -160px; }
+.ui-icon-seek-end { background-position: -64px -160px; }
+.ui-icon-seek-start { background-position: -80px -160px; }
+/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
+.ui-icon-seek-first { background-position: -80px -160px; }
+.ui-icon-stop { background-position: -96px -160px; }
+.ui-icon-eject { background-position: -112px -160px; }
+.ui-icon-volume-off { background-position: -128px -160px; }
+.ui-icon-volume-on { background-position: -144px -160px; }
+.ui-icon-power { background-position: 0 -176px; }
+.ui-icon-signal-diag { background-position: -16px -176px; }
+.ui-icon-signal { background-position: -32px -176px; }
+.ui-icon-battery-0 { background-position: -48px -176px; }
+.ui-icon-battery-1 { background-position: -64px -176px; }
+.ui-icon-battery-2 { background-position: -80px -176px; }
+.ui-icon-battery-3 { background-position: -96px -176px; }
+.ui-icon-circle-plus { background-position: 0 -192px; }
+.ui-icon-circle-minus { background-position: -16px -192px; }
+.ui-icon-circle-close { background-position: -32px -192px; }
+.ui-icon-circle-triangle-e { background-position: -48px -192px; }
+.ui-icon-circle-triangle-s { background-position: -64px -192px; }
+.ui-icon-circle-triangle-w { background-position: -80px -192px; }
+.ui-icon-circle-triangle-n { background-position: -96px -192px; }
+.ui-icon-circle-arrow-e { background-position: -112px -192px; }
+.ui-icon-circle-arrow-s { background-position: -128px -192px; }
+.ui-icon-circle-arrow-w { background-position: -144px -192px; }
+.ui-icon-circle-arrow-n { background-position: -160px -192px; }
+.ui-icon-circle-zoomin { background-position: -176px -192px; }
+.ui-icon-circle-zoomout { background-position: -192px -192px; }
+.ui-icon-circle-check { background-position: -208px -192px; }
+.ui-icon-circlesmall-plus { background-position: 0 -208px; }
+.ui-icon-circlesmall-minus { background-position: -16px -208px; }
+.ui-icon-circlesmall-close { background-position: -32px -208px; }
+.ui-icon-squaresmall-plus { background-position: -48px -208px; }
+.ui-icon-squaresmall-minus { background-position: -64px -208px; }
+.ui-icon-squaresmall-close { background-position: -80px -208px; }
+.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
+.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
+.ui-icon-grip-solid-vertical { background-position: -32px -224px; }
+.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
+.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
+.ui-icon-grip-diagonal-se { background-position: -80px -224px; }
+
+
+/* Misc visuals
+----------------------------------*/
+
+/* Corner radius */
+.ui-corner-all,
+.ui-corner-top,
+.ui-corner-left,
+.ui-corner-tl {
+	border-top-left-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-top,
+.ui-corner-right,
+.ui-corner-tr {
+	border-top-right-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-bottom,
+.ui-corner-left,
+.ui-corner-bl {
+	border-bottom-left-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-bottom,
+.ui-corner-right,
+.ui-corner-br {
+	border-bottom-right-radius: 4px;
+}
+
+/* Overlays */
+.ui-widget-overlay {
+	background: #666666 url("images/ui-bg_diagonals-thick_20_666666_40x40.png") 50% 50% repeat;
+	opacity: .5;
+	filter: Alpha(Opacity=50);
+}
+.ui-widget-shadow {
+	margin: -5px 0 0 -5px;
+	padding: 5px;
+	background: #000000 url("images/ui-bg_flat_10_000000_40x100.png") 50% 50% repeat-x;
+	opacity: .2;
+	filter: Alpha(Opacity=20);
+	border-radius: 5px;
+}
diff --git a/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css
new file mode 100644
index 0000000000..3c6d34c0bf
--- /dev/null
+++ b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css
@@ -0,0 +1,7 @@
+/*! jQuery UI - v1.10.4 - 2014-04-02
+* http://jqueryui.com
+* Includes: jquery.ui.core.css, jquery.ui.accordion.css, jquery.ui.autocomplete.css, jquery.ui.button.css, jquery.ui.datepicker.css, jquery.ui.dialog.css, jquery.ui.menu.css, jquery.ui.progressbar.css, jquery.ui.resizable.css, jquery.ui.selectable.css, jquery.ui.slider.css, jquery.ui.spinner.css, jquery.ui.tabs.css, jquery.ui.tooltip.css, jquery.ui.theme.css
+* To view and modify this theme, visit http://jqueryui.com/themeroller/?ffDefault=Trebuchet%20MS%2CTahoma%2CVerdana%2CArial%2Csans-serif&fwDefault=bold&fsDefault=1.1em&cornerRadius=4px&bgColorHeader=f6a828&bgTextureHeader=gloss_wave&bgImgOpacityHeader=35&borderColorHeader=e78f08&fcHeader=ffffff&iconColorHeader=ffffff&bgColorContent=eeeeee&bgTextureContent=highlight_soft&bgImgOpacityContent=100&borderColorContent=dddddd&fcContent=333333&iconColorContent=222222&bgColorDefault=f6f6f6&bgTextureDefault=glass&bgImgOpacityDefault=100&borderColorDefault=cccccc&fcDefault=1c94c4&iconColorDefault=ef8c08&bgColorHover=fdf5ce&bgTextureHover=glass&bgImgOpacityHover=100&borderColorHover=fbcb09&fcHover=c77405&iconColorHover=ef8c08&bgColorActive=ffffff&bgTextureActive=glass&bgImgOpacityActive=65&borderColorActive=fbd850&fcActive=eb8f00&iconColorActive=ef8c08&bgColorHighlight=ffe45c&bgTextureHighlight=highlight_soft&bgImgOpacityHighlight=75&borderColorHighlight=fed22f&fcHighlight=363636&iconColorHighlight=228ef1&bgColorError=b81900&bgTextureError=diagonals_thick&bgImgOpacityError=18&borderColorError=cd0a0a&fcError=ffffff&iconColorError=ffd27a&bgColorOverlay=666666&bgTextureOverlay=diagonals_thick&bgImgOpacityOverlay=20&opacityOverlay=50&bgColorShadow=000000&bgTextureShadow=flat&bgImgOpacityShadow=10&opacityShadow=20&thicknessShadow=5px&offsetTopShadow=-5px&offsetLeftShadow=-5px&cornerRadiusShadow=5px
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:"";display:table;border-collapse:collapse}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{min-height:0}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)}.ui-front{z-index:100}.ui-state-disabled{cursor:default!important}.ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}.ui-widget-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ui-accordion .ui-accordion-header{display:block;cursor:pointer;position:relative;margin-top:2px;padding:.5em .5em .5em .7em;min-height:0}.ui-accordion .ui-accordion-icons{padding-left:2.2em}.ui-accordion .ui-accordion-noicons{padding-left:.7em}.ui-accordion .ui-accordion-icons .ui-accordion-icons{padding-left:2.2em}.ui-accordion .ui-accordion-header .ui-accordion-header-icon{position:absolute;left:.5em;top:50%;margin-top:-8px}.ui-accordion .ui-accordion-content{padding:1em 2.2em;border-top:0;overflow:auto}.ui-autocomplete{position:absolute;top:0;left:0;cursor:default}.ui-button{display:inline-block;position:relative;padding:0;line-height:normal;margin-right:.1em;cursor:pointer;vertical-align:middle;text-align:center;overflow:visible}.ui-button,.ui-button:link,.ui-button:visited,.ui-button:hover,.ui-button:active{text-decoration:none}.ui-button-icon-only{width:2.2em}button.ui-button-icon-only{width:2.4em}.ui-button-icons-only{width:3.4em}button.ui-button-icons-only{width:3.7em}.ui-button .ui-button-text{display:block;line-height:normal}.ui-button-text-only .ui-button-text{padding:.4em 1em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:.4em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 1em .4em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 2.1em .4em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em}input.ui-button{padding:.4em 1em}.ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-8px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:.5em}.ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.3em}input.ui-button::-moz-focus-inner,button.ui-button::-moz-focus-inner{border:0;padding:0}.ui-datepicker{width:17em;padding:.2em .2em 0;display:none}.ui-datepicker .ui-datepicker-header{position:relative;padding:.2em 0}.ui-datepicker .ui-datepicker-prev,.ui-datepicker .ui-datepicker-next{position:absolute;top:2px;width:1.8em;height:1.8em}.ui-datepicker .ui-datepicker-prev-hover,.ui-datepicker .ui-datepicker-next-hover{top:1px}.ui-datepicker .ui-datepicker-prev{left:2px}.ui-datepicker .ui-datepicker-next{right:2px}.ui-datepicker .ui-datepicker-prev-hover{left:1px}.ui-datepicker .ui-datepicker-next-hover{right:1px}.ui-datepicker .ui-datepicker-prev span,.ui-datepicker .ui-datepicker-next span{display:block;position:absolute;left:50%;margin-left:-8px;top:50%;margin-top:-8px}.ui-datepicker .ui-datepicker-title{margin:0 2.3em;line-height:1.8em;text-align:center}.ui-datepicker .ui-datepicker-title select{font-size:1em;margin:1px 0}.ui-datepicker select.ui-datepicker-month,.ui-datepicker select.ui-datepicker-year{width:49%}.ui-datepicker table{width:100%;font-size:.9em;border-collapse:collapse;margin:0 0 .4em}.ui-datepicker th{padding:.7em .3em;text-align:center;font-weight:bold;border:0}.ui-datepicker td{border:0;padding:1px}.ui-datepicker td span,.ui-datepicker td a{display:block;padding:.2em;text-align:right;text-decoration:none}.ui-datepicker .ui-datepicker-buttonpane{background-image:none;margin:.7em 0 0 0;padding:0 .2em;border-left:0;border-right:0;border-bottom:0}.ui-datepicker .ui-datepicker-buttonpane button{float:right;margin:.5em .2em .4em;cursor:pointer;padding:.2em .6em .3em .6em;width:auto;overflow:visible}.ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current{float:left}.ui-datepicker.ui-datepicker-multi{width:auto}.ui-datepicker-multi .ui-datepicker-group{float:left}.ui-datepicker-multi .ui-datepicker-group table{width:95%;margin:0 auto .4em}.ui-datepicker-multi-2 .ui-datepicker-group{width:50%}.ui-datepicker-multi-3 .ui-datepicker-group{width:33.3%}.ui-datepicker-multi-4 .ui-datepicker-group{width:25%}.ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header,.ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header{border-left-width:0}.ui-datepicker-multi .ui-datepicker-buttonpane{clear:left}.ui-datepicker-row-break{clear:both;width:100%;font-size:0}.ui-datepicker-rtl{direction:rtl}.ui-datepicker-rtl .ui-datepicker-prev{right:2px;left:auto}.ui-datepicker-rtl .ui-datepicker-next{left:2px;right:auto}.ui-datepicker-rtl .ui-datepicker-prev:hover{right:1px;left:auto}.ui-datepicker-rtl .ui-datepicker-next:hover{left:1px;right:auto}.ui-datepicker-rtl .ui-datepicker-buttonpane{clear:right}.ui-datepicker-rtl .ui-datepicker-buttonpane button{float:left}.ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current,.ui-datepicker-rtl .ui-datepicker-group{float:right}.ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header,.ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header{border-right-width:0;border-left-width:1px}.ui-dialog{overflow:hidden;position:absolute;top:0;left:0;padding:.2em;outline:0}.ui-dialog .ui-dialog-titlebar{padding:.4em 1em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:.1em 0;white-space:nowrap;width:90%;overflow:hidden;text-overflow:ellipsis}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.3em;top:50%;width:20px;margin:-10px 0 0 0;padding:1px;height:20px}.ui-dialog .ui-dialog-content{position:relative;border:0;padding:.5em 1em;background:none;overflow:auto}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0 0;background-image:none;margin-top:.5em;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-dialog-buttonpane button{margin:.5em .4em .5em 0;cursor:pointer}.ui-dialog .ui-resizable-se{width:12px;height:12px;right:-5px;bottom:-5px;background-position:16px 16px}.ui-draggable .ui-dialog-titlebar{cursor:move}.ui-menu{list-style:none;padding:2px;margin:0;display:block;outline:none}.ui-menu .ui-menu{margin-top:-3px;position:absolute}.ui-menu .ui-menu-item{margin:0;padding:0;width:100%;list-style-image:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)}.ui-menu .ui-menu-divider{margin:5px -2px 5px -2px;height:0;font-size:0;line-height:0;border-width:1px 0 0 0}.ui-menu .ui-menu-item a{text-decoration:none;display:block;padding:2px .4em;line-height:1.5;min-height:0;font-weight:normal}.ui-menu .ui-menu-item a.ui-state-focus,.ui-menu .ui-menu-item a.ui-state-active{font-weight:normal;margin:-1px}.ui-menu .ui-state-disabled{font-weight:normal;margin:.4em 0 .2em;line-height:1.5}.ui-menu .ui-state-disabled a{cursor:default}.ui-menu-icons{position:relative}.ui-menu-icons .ui-menu-item a{position:relative;padding-left:2em}.ui-menu .ui-icon{position:absolute;top:.2em;left:.2em}.ui-menu .ui-menu-icon{position:static;float:right}.ui-progressbar{height:2em;text-align:left;overflow:hidden}.ui-progressbar .ui-progressbar-value{margin:-1px;height:100%}.ui-progressbar .ui-progressbar-overlay{background:url("images/animated-overlay.gif");height:100%;filter:alpha(opacity=25);opacity:0.25}.ui-progressbar-indeterminate .ui-progressbar-value{background-image:none}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:0.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.ui-selectable-helper{position:absolute;z-index:100;border:1px dotted black}.ui-slider{position:relative;text-align:left}.ui-slider .ui-slider-handle{position:absolute;z-index:2;width:1.2em;height:1.2em;cursor:default}.ui-slider .ui-slider-range{position:absolute;z-index:1;font-size:.7em;display:block;border:0;background-position:0 0}.ui-slider.ui-state-disabled .ui-slider-handle,.ui-slider.ui-state-disabled .ui-slider-range{filter:inherit}.ui-slider-horizontal{height:.8em}.ui-slider-horizontal .ui-slider-handle{top:-.3em;margin-left:-.6em}.ui-slider-horizontal .ui-slider-range{top:0;height:100%}.ui-slider-horizontal .ui-slider-range-min{left:0}.ui-slider-horizontal .ui-slider-range-max{right:0}.ui-slider-vertical{width:.8em;height:100px}.ui-slider-vertical .ui-slider-handle{left:-.3em;margin-left:0;margin-bottom:-.6em}.ui-slider-vertical .ui-slider-range{left:0;width:100%}.ui-slider-vertical .ui-slider-range-min{bottom:0}.ui-slider-vertical .ui-slider-range-max{top:0}.ui-spinner{position:relative;display:inline-block;overflow:hidden;padding:0;vertical-align:middle}.ui-spinner-input{border:none;background:none;color:inherit;padding:0;margin:.2em 0;vertical-align:middle;margin-left:.4em;margin-right:22px}.ui-spinner-button{width:16px;height:50%;font-size:.5em;padding:0;margin:0;text-align:center;position:absolute;cursor:default;display:block;overflow:hidden;right:0}.ui-spinner a.ui-spinner-button{border-top:none;border-bottom:none;border-right:none}.ui-spinner .ui-icon{position:absolute;margin-top:-8px;top:50%;left:0}.ui-spinner-up{top:0}.ui-spinner-down{bottom:0}.ui-spinner .ui-icon-triangle-1-s{background-position:-65px -16px}.ui-tabs{position:relative;padding:.2em}.ui-tabs .ui-tabs-nav{margin:0;padding:.2em .2em 0}.ui-tabs .ui-tabs-nav li{list-style:none;float:left;position:relative;top:0;margin:1px .2em 0 0;border-bottom-width:0;padding:0;white-space:nowrap}.ui-tabs .ui-tabs-nav .ui-tabs-anchor{float:left;padding:.5em 1em;text-decoration:none}.ui-tabs .ui-tabs-nav li.ui-tabs-active{margin-bottom:-1px;padding-bottom:1px}.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor{cursor:text}.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor{cursor:pointer}.ui-tabs .ui-tabs-panel{display:block;border-width:0;padding:1em 1.4em;background:none}.ui-tooltip{padding:8px;position:absolute;z-index:9999;max-width:300px;-webkit-box-shadow:0 0 5px #aaa;box-shadow:0 0 5px #aaa}body .ui-tooltip{border-width:2px}.ui-widget{font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;font-size:1.1em}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid #ddd;background:#eee url("images/ui-bg_highlight-soft_100_eeeeee_1x100.png") 50% top repeat-x;color:#333}.ui-widget-content a{color:#333}.ui-widget-header{border:1px solid #e78f08;background:#f6a828 url("images/ui-bg_gloss-wave_35_f6a828_500x100.png") 50% 50% repeat-x;color:#fff;font-weight:bold}.ui-widget-header a{color:#fff}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #ccc;background:#f6f6f6 url("images/ui-bg_glass_100_f6f6f6_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#1c94c4}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#1c94c4;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #fbcb09;background:#fdf5ce url("images/ui-bg_glass_100_fdf5ce_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#c77405}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited,.ui-state-focus a,.ui-state-focus a:hover,.ui-state-focus a:link,.ui-state-focus a:visited{color:#c77405;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #fbd850;background:#fff url("images/ui-bg_glass_65_ffffff_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#eb8f00}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#eb8f00;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #fed22f;background:#ffe45c url("images/ui-bg_highlight-soft_75_ffe45c_1x100.png") 50% top repeat-x;color:#363636}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#363636}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#b81900 url("images/ui-bg_diagonals-thick_18_b81900_40x40.png") 50% 50% repeat;color:#fff}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#fff}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#fff}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url("images/ui-icons_222222_256x240.png")}.ui-widget-header .ui-icon{background-image:url("images/ui-icons_ffffff_256x240.png")}.ui-state-default .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-active .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-highlight .ui-icon{background-image:url("images/ui-icons_228ef1_256x240.png")}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url("images/ui-icons_ffd27a_256x240.png")}.ui-icon-blank{background-position:16px 16px}.ui-icon-carat-1-n{background-position:0 0}.ui-icon-carat-1-ne{background-position:-16px 0}.ui-icon-carat-1-e{background-position:-32px 0}.ui-icon-carat-1-se{background-position:-48px 0}.ui-icon-carat-1-s{background-position:-64px 0}.ui-icon-carat-1-sw{background-position:-80px 0}.ui-icon-carat-1-w{background-position:-96px 0}.ui-icon-carat-1-nw{background-position:-112px 0}.ui-icon-carat-2-n-s{background-position:-128px 0}.ui-icon-carat-2-e-w{background-position:-144px 0}.ui-icon-triangle-1-n{background-position:0 -16px}.ui-icon-triangle-1-ne{background-position:-16px -16px}.ui-icon-triangle-1-e{background-position:-32px -16px}.ui-icon-triangle-1-se{background-position:-48px -16px}.ui-icon-triangle-1-s{background-position:-64px -16px}.ui-icon-triangle-1-sw{background-position:-80px -16px}.ui-icon-triangle-1-w{background-position:-96px -16px}.ui-icon-triangle-1-nw{background-position:-112px -16px}.ui-icon-triangle-2-n-s{background-position:-128px -16px}.ui-icon-triangle-2-e-w{background-position:-144px -16px}.ui-icon-arrow-1-n{background-position:0 -32px}.ui-icon-arrow-1-ne{background-position:-16px -32px}.ui-icon-arrow-1-e{background-position:-32px -32px}.ui-icon-arrow-1-se{background-position:-48px -32px}.ui-icon-arrow-1-s{background-position:-64px -32px}.ui-icon-arrow-1-sw{background-position:-80px -32px}.ui-icon-arrow-1-w{background-position:-96px -32px}.ui-icon-arrow-1-nw{background-position:-112px -32px}.ui-icon-arrow-2-n-s{background-position:-128px -32px}.ui-icon-arrow-2-ne-sw{background-position:-144px -32px}.ui-icon-arrow-2-e-w{background-position:-160px -32px}.ui-icon-arrow-2-se-nw{background-position:-176px -32px}.ui-icon-arrowstop-1-n{background-position:-192px -32px}.ui-icon-arrowstop-1-e{background-position:-208px -32px}.ui-icon-arrowstop-1-s{background-position:-224px -32px}.ui-icon-arrowstop-1-w{background-position:-240px -32px}.ui-icon-arrowthick-1-n{background-position:0 -48px}.ui-icon-arrowthick-1-ne{background-position:-16px -48px}.ui-icon-arrowthick-1-e{background-position:-32px -48px}.ui-icon-arrowthick-1-se{background-position:-48px -48px}.ui-icon-arrowthick-1-s{background-position:-64px -48px}.ui-icon-arrowthick-1-sw{background-position:-80px -48px}.ui-icon-arrowthick-1-w{background-position:-96px -48px}.ui-icon-arrowthick-1-nw{background-position:-112px -48px}.ui-icon-arrowthick-2-n-s{background-position:-128px -48px}.ui-icon-arrowthick-2-ne-sw{background-position:-144px -48px}.ui-icon-arrowthick-2-e-w{background-position:-160px -48px}.ui-icon-arrowthick-2-se-nw{background-position:-176px -48px}.ui-icon-arrowthickstop-1-n{background-position:-192px -48px}.ui-icon-arrowthickstop-1-e{background-position:-208px -48px}.ui-icon-arrowthickstop-1-s{background-position:-224px -48px}.ui-icon-arrowthickstop-1-w{background-position:-240px -48px}.ui-icon-arrowreturnthick-1-w{background-position:0 -64px}.ui-icon-arrowreturnthick-1-n{background-position:-16px -64px}.ui-icon-arrowreturnthick-1-e{background-position:-32px -64px}.ui-icon-arrowreturnthick-1-s{background-position:-48px -64px}.ui-icon-arrowreturn-1-w{background-position:-64px -64px}.ui-icon-arrowreturn-1-n{background-position:-80px -64px}.ui-icon-arrowreturn-1-e{background-position:-96px -64px}.ui-icon-arrowreturn-1-s{background-position:-112px -64px}.ui-icon-arrowrefresh-1-w{background-position:-128px -64px}.ui-icon-arrowrefresh-1-n{background-position:-144px -64px}.ui-icon-arrowrefresh-1-e{background-position:-160px -64px}.ui-icon-arrowrefresh-1-s{background-position:-176px -64px}.ui-icon-arrow-4{background-position:0 -80px}.ui-icon-arrow-4-diag{background-position:-16px -80px}.ui-icon-extlink{background-position:-32px -80px}.ui-icon-newwin{background-position:-48px -80px}.ui-icon-refresh{background-position:-64px -80px}.ui-icon-shuffle{background-position:-80px -80px}.ui-icon-transfer-e-w{background-position:-96px -80px}.ui-icon-transferthick-e-w{background-position:-112px -80px}.ui-icon-folder-collapsed{background-position:0 -96px}.ui-icon-folder-open{background-position:-16px -96px}.ui-icon-document{background-position:-32px -96px}.ui-icon-document-b{background-position:-48px -96px}.ui-icon-note{background-position:-64px -96px}.ui-icon-mail-closed{background-position:-80px -96px}.ui-icon-mail-open{background-position:-96px -96px}.ui-icon-suitcase{background-position:-112px -96px}.ui-icon-comment{background-position:-128px -96px}.ui-icon-person{background-position:-144px -96px}.ui-icon-print{background-position:-160px -96px}.ui-icon-trash{background-position:-176px -96px}.ui-icon-locked{background-position:-192px -96px}.ui-icon-unlocked{background-position:-208px -96px}.ui-icon-bookmark{background-position:-224px -96px}.ui-icon-tag{background-position:-240px -96px}.ui-icon-home{background-position:0 -112px}.ui-icon-flag{background-position:-16px -112px}.ui-icon-calendar{background-position:-32px -112px}.ui-icon-cart{background-position:-48px -112px}.ui-icon-pencil{background-position:-64px -112px}.ui-icon-clock{background-position:-80px -112px}.ui-icon-disk{background-position:-96px -112px}.ui-icon-calculator{background-position:-112px -112px}.ui-icon-zoomin{background-position:-128px -112px}.ui-icon-zoomout{background-position:-144px -112px}.ui-icon-search{background-position:-160px -112px}.ui-icon-wrench{background-position:-176px -112px}.ui-icon-gear{background-position:-192px -112px}.ui-icon-heart{background-position:-208px -112px}.ui-icon-star{background-position:-224px -112px}.ui-icon-link{background-position:-240px -112px}.ui-icon-cancel{background-position:0 -128px}.ui-icon-plus{background-position:-16px -128px}.ui-icon-plusthick{background-position:-32px -128px}.ui-icon-minus{background-position:-48px -128px}.ui-icon-minusthick{background-position:-64px -128px}.ui-icon-close{background-position:-80px -128px}.ui-icon-closethick{background-position:-96px -128px}.ui-icon-key{background-position:-112px -128px}.ui-icon-lightbulb{background-position:-128px -128px}.ui-icon-scissors{background-position:-144px -128px}.ui-icon-clipboard{background-position:-160px -128px}.ui-icon-copy{background-position:-176px -128px}.ui-icon-contact{background-position:-192px -128px}.ui-icon-image{background-position:-208px -128px}.ui-icon-video{background-position:-224px -128px}.ui-icon-script{background-position:-240px -128px}.ui-icon-alert{background-position:0 -144px}.ui-icon-info{background-position:-16px -144px}.ui-icon-notice{background-position:-32px -144px}.ui-icon-help{background-position:-48px -144px}.ui-icon-check{background-position:-64px -144px}.ui-icon-bullet{background-position:-80px -144px}.ui-icon-radio-on{background-position:-96px -144px}.ui-icon-radio-off{background-position:-112px -144px}.ui-icon-pin-w{background-position:-128px -144px}.ui-icon-pin-s{background-position:-144px -144px}.ui-icon-play{background-position:0 -160px}.ui-icon-pause{background-position:-16px -160px}.ui-icon-seek-next{background-position:-32px -160px}.ui-icon-seek-prev{background-position:-48px -160px}.ui-icon-seek-end{background-position:-64px -160px}.ui-icon-seek-start{background-position:-80px -160px}.ui-icon-seek-first{background-position:-80px -160px}.ui-icon-stop{background-position:-96px -160px}.ui-icon-eject{background-position:-112px -160px}.ui-icon-volume-off{background-position:-128px -160px}.ui-icon-volume-on{background-position:-144px -160px}.ui-icon-power{background-position:0 -176px}.ui-icon-signal-diag{background-position:-16px -176px}.ui-icon-signal{background-position:-32px -176px}.ui-icon-battery-0{background-position:-48px -176px}.ui-icon-battery-1{background-position:-64px -176px}.ui-icon-battery-2{background-position:-80px -176px}.ui-icon-battery-3{background-position:-96px -176px}.ui-icon-circle-plus{background-position:0 -192px}.ui-icon-circle-minus{background-position:-16px -192px}.ui-icon-circle-close{background-position:-32px -192px}.ui-icon-circle-triangle-e{background-position:-48px -192px}.ui-icon-circle-triangle-s{background-position:-64px -192px}.ui-icon-circle-triangle-w{background-position:-80px -192px}.ui-icon-circle-triangle-n{background-position:-96px -192px}.ui-icon-circle-arrow-e{background-position:-112px -192px}.ui-icon-circle-arrow-s{background-position:-128px -192px}.ui-icon-circle-arrow-w{background-position:-144px -192px}.ui-icon-circle-arrow-n{background-position:-160px -192px}.ui-icon-circle-zoomin{background-position:-176px -192px}.ui-icon-circle-zoomout{background-position:-192px -192px}.ui-icon-circle-check{background-position:-208px -192px}.ui-icon-circlesmall-plus{background-position:0 -208px}.ui-icon-circlesmall-minus{background-position:-16px -208px}.ui-icon-circlesmall-close{background-position:-32px -208px}.ui-icon-squaresmall-plus{background-position:-48px -208px}.ui-icon-squaresmall-minus{background-position:-64px -208px}.ui-icon-squaresmall-close{background-position:-80px -208px}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:4px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:4px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:4px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:4px}.ui-widget-overlay{background:#666 url("images/ui-bg_diagonals-thick_20_666666_40x40.png") 50% 50% repeat;opacity:.5;filter:Alpha(Opacity=50)}.ui-widget-shadow{margin:-5px 0 0 -5px;padding:5px;background:#000 url("images/ui-bg_flat_10_000000_40x100.png") 50% 50% repeat-x;opacity:.2;filter:Alpha(Opacity=20);border-radius:5px}
\ No newline at end of file
diff --git a/web/src/main/webapp/img/bike2.png b/web/src/main/webapp/img/bike2.png
index 2bc450e6c1..54a802bb12 100644
Binary files a/web/src/main/webapp/img/bike2.png and b/web/src/main/webapp/img/bike2.png differ
diff --git a/web/src/main/webapp/img/delete.png b/web/src/main/webapp/img/delete.png
new file mode 100644
index 0000000000..4b7ad6f739
Binary files /dev/null and b/web/src/main/webapp/img/delete.png differ
diff --git a/web/src/main/webapp/img/header.png b/web/src/main/webapp/img/header.png
index 2b613463b5..e89b782da1 100644
Binary files a/web/src/main/webapp/img/header.png and b/web/src/main/webapp/img/header.png differ
diff --git a/web/src/main/webapp/img/loading.gif b/web/src/main/webapp/img/loading.gif
new file mode 100644
index 0000000000..ed65b705af
Binary files /dev/null and b/web/src/main/webapp/img/loading.gif differ
diff --git a/web/src/main/webapp/img/marker-icon-blue.png b/web/src/main/webapp/img/marker-icon-blue.png
new file mode 100644
index 0000000000..d0a81621aa
Binary files /dev/null and b/web/src/main/webapp/img/marker-icon-blue.png differ
diff --git a/web/src/main/webapp/img/marker-small-blue.png b/web/src/main/webapp/img/marker-small-blue.png
new file mode 100644
index 0000000000..73b0845b40
Binary files /dev/null and b/web/src/main/webapp/img/marker-small-blue.png differ
diff --git a/web/src/main/webapp/img/marker-small-green.png b/web/src/main/webapp/img/marker-small-green.png
index 201c284c7f..d4b959ebe1 100644
Binary files a/web/src/main/webapp/img/marker-small-green.png and b/web/src/main/webapp/img/marker-small-green.png differ
diff --git a/web/src/main/webapp/img/marker-small-red.png b/web/src/main/webapp/img/marker-small-red.png
index 2591eba024..ea5f6ef162 100644
Binary files a/web/src/main/webapp/img/marker-small-red.png and b/web/src/main/webapp/img/marker-small-red.png differ
diff --git a/web/src/main/webapp/img/motorcycle.png b/web/src/main/webapp/img/motorcycle.png
new file mode 100644
index 0000000000..552a98a587
Binary files /dev/null and b/web/src/main/webapp/img/motorcycle.png differ
diff --git a/web/src/main/webapp/img/motorcycle.svg b/web/src/main/webapp/img/motorcycle.svg
new file mode 100644
index 0000000000..cdfe16e184
--- /dev/null
+++ b/web/src/main/webapp/img/motorcycle.svg
@@ -0,0 +1,149 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="24"
+   height="24"
+   id="svg4460"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="motorcycle.svg"
+   inkscape:export-filename="/home/peterk/Dokumente/quell/graphhopper/web/src/main/webapp/img/motorcycle.png"
+   inkscape:export-xdpi="180"
+   inkscape:export-ydpi="180">
+  <defs
+     id="defs4462" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.627416"
+     inkscape:cx="11.038288"
+     inkscape:cy="15.468485"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1220"
+     inkscape:window-height="833"
+     inkscape:window-x="56"
+     inkscape:window-y="20"
+     inkscape:window-maximized="0"
+     inkscape:snap-global="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4468"
+       empspacing="5"
+       visible="true"
+       enabled="true"
+       snapvisiblegridlinesonly="true" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="0,20"
+       id="guide4470" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="4,24"
+       id="guide4472" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="24,13"
+       id="guide4474" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="15,0"
+       id="guide4476" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="23,20"
+       id="guide4478" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="20,23"
+       id="guide4480" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="2,5"
+       id="guide4482" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="7,2"
+       id="guide4484" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata4465">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1028.3622)">
+    <path
+       style="fill:#474747;fill-opacity:1;stroke:none"
+       d="m 5.5817124,1045.2742 c -0.3707456,-0.1255 -0.5945126,-0.347 -0.7457974,-0.7394 -0.1516823,-0.3932 -0.1770529,-0.6892 -0.088482,-1.0324 0.082921,-0.3212 0.2200926,-0.5065 0.4467092,-0.6031 0.1431593,-0.061 0.729899,0 2.1462326,0.2047 0.3836523,0.057 1.0095616,0.096 1.6087456,0.098 l 0.9807671,0 0.2633805,-0.1904 c 2.201779,-2.0387 5.224231,-4.2928 6.687617,-5.3185 0.05478,-0.2562 -0.184514,-1.0406 -0.394684,-1.4309 -0.106364,-0.1976 -0.185787,-0.3682 -0.176497,-0.3791 0.03469,-0.042 0.660756,0.2251 0.913104,0.3881 0.816153,0.5273 1.638487,1.8371 1.709855,2.7235 0.0311,0.3862 0.0088,0.4083 -0.668791,0.6615 -0.73483,0.2745 -1.449842,0.8289 -2.310729,1.7918 -0.707156,0.7908 -1.192179,1.7324 -1.584625,3.0759 l -0.220867,0.7561 -0.30143,-0.035 c -0.736677,-0.085 -3.214402,-0.103 -5.5010819,-0.04 -1.3677354,0.038 -2.520702,0.078 -2.5621485,0.089 -0.041446,0.013 -0.1320216,-1e-4 -0.2012779,-0.024 l 0,0 z"
+       id="path3936"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="csscccccccccsccsccccccc" />
+    <path
+       sodipodi:type="arc"
+       style="fill:none;stroke:#474747;stroke-width:1.9586767;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       id="path3037"
+       sodipodi:cx="-10.915961"
+       sodipodi:cy="15.558912"
+       sodipodi:rx="4.6403885"
+       sodipodi:ry="4.6403885"
+       d="m -6.2755728,15.558912 a 4.6403885,4.6403885 0 1 1 -9.2807772,0 4.6403885,4.6403885 0 1 1 9.2807772,0 z"
+       transform="matrix(0.67343727,0,0,0.67343727,26.251218,1033.6233)" />
+    <path
+       style="fill:none;stroke:#474747;stroke-width:1.58841085;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       d="m 16.762928,1040.327 2.071883,3.714"
+       id="path3847"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       sodipodi:type="arc"
+       style="fill:none;stroke:#474747;stroke-width:1.9586767;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       id="path3037-4"
+       sodipodi:cx="-10.915961"
+       sodipodi:cy="15.558912"
+       sodipodi:rx="4.6403885"
+       sodipodi:ry="4.6403885"
+       d="m -6.2755728,15.558912 a 4.6403885,4.6403885 0 1 1 -9.2807772,0 4.6403885,4.6403885 0 1 1 9.2807772,0 z"
+       transform="matrix(0.67343727,0,0,0.67343727,13.245847,1033.5599)" />
+    <rect
+       style="opacity:0.98999999;fill:#474747;fill-opacity:1;stroke:none"
+       id="rect3908"
+       width="6.7141528"
+       height="1.0771544"
+       x="235.49338"
+       y="1003.391"
+       transform="matrix(0.96338557,0.26811982,-0.22085123,0.97530751,0,0)"
+       ry="0" />
+    <path
+       style="fill:#474747;fill-opacity:1;stroke:none"
+       d="m 5.3594489,1039.4518 c -1.3832608,-0.7953 -1.5267081,-1.3337 -1.1944296,-1.7131 0.026329,-0.03 2.600895,-0.024 3.3742271,0.1991 1.1573295,0.3344 1.3778264,0.4569 2.7889386,1.5513 0.324467,0.2516 0.6842,0.3995 0.972399,0.3997 0.157152,0 0.927646,-0.2302 2.28237,-0.6825 1.124822,-0.3755 2.055889,-0.6705 2.06904,-0.6557 0.01315,0.015 -0.432145,0.4129 -0.989543,0.8846 -1.634219,1.3827 -3.403891,3.067 -3.685785,3.0667 -1.1624689,-1.7137 -3.7863209,-2.5155 -5.6172171,-3.0501 z"
+       id="path3930"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccccccccc" />
+  </g>
+</svg>
diff --git a/web/src/main/webapp/img/point_add.png b/web/src/main/webapp/img/point_add.png
new file mode 100644
index 0000000000..a7424380d6
Binary files /dev/null and b/web/src/main/webapp/img/point_add.png differ
diff --git a/web/src/main/webapp/img/point_delete.png b/web/src/main/webapp/img/point_delete.png
new file mode 100644
index 0000000000..d1898cd4ef
Binary files /dev/null and b/web/src/main/webapp/img/point_delete.png differ
diff --git a/web/src/main/webapp/img/race-bicycle.svg b/web/src/main/webapp/img/racingbike.svg
similarity index 100%
rename from web/src/main/webapp/img/race-bicycle.svg
rename to web/src/main/webapp/img/racingbike.svg
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index d4e81eaa1d..0cf58995bd 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -4,73 +4,82 @@
         <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
         <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
         <meta name="keywords" content="road routing,shortest path,maps,openstreetmap,android,navigation,routenplaner,gis"/>
-        <link type="image/png" rel="icon" href="/favicon.ico"/>        
+        <link type="image/png" rel="icon" href="/favicon.ico"/>
         <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
         <title>Driving Directions - GraphHopper Maps</title>
-
-        <link rel="stylesheet" href="css/leaflet.css" />        
-        <script type="text/javascript" src="js/leaflet.js?v=0.7.2"></script>
+        <meta name="description" content="A fast route planner for biking, hiking and more! Based on OpenStreetMap including elevation data. Try out for free!"/>
+        <link rel="stylesheet" href="css/leaflet.css?v=0.7.3" />
+        <script type="text/javascript" src="js/leaflet.js?v=0.7.3"></script>
         <link rel="stylesheet" href="css/Leaflet.Elevation-0.0.2.css" />
         <script type="text/javascript" src="js/d3.min.js"></script>
         <script type="text/javascript" src="js/Leaflet.Elevation-0.0.2.min.js"></script>        
 
+        <link rel="stylesheet" href="css/leaflet.contextmenu.css" />
+        <link rel="stylesheet" href="css/leaflet.loading.css" />
+        <link rel="stylesheet" href="css/ui-lightness/jquery-ui-1.10.4.css" />
+        <script type="text/javascript" src="js/leaflet.contextmenu.js"></script>
+        <script type="text/javascript" src="js/leaflet.loading.js"></script>
         <script type="text/javascript" src="js/jquery-2.1.0.min.js"></script>        
+        <script type="text/javascript" src="js/jquery-ui-1.10.4.custom.min.js"></script>      
+        <script type="text/javascript" src="js/jquery.history.js"></script>
         <!--
-        <script type="text/javascript" src="http://code.jquery.com/jquery-2.1.0.min.js"></script>        
+        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>
         -->
-        <script type="text/javascript" src="js/jquery.history.js"></script>
-        <!--        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>-->
         <script type="text/javascript" src="js/jquery.autocomplete.js"></script>
-        <script type="text/javascript" src="js/ghrequest.js"></script>
-        <script type="text/javascript" src="js/main.js"></script>         
+        <script type="text/javascript" src="js/ghrequest.js?v=0.4.4"></script>
+        <script type="text/javascript" src="js/main.js?v=0.4.4"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
     </head>
     <body>
         <div id="input">
             <div id="input_header">
-            <div id="header_img">
-                <a class="no_link" href="http://graphhopper.com">
-                    <img alt="GraphHopper" src="./img/header.png"/>                    
-                </a>
-            </div>
-            <div id="options">
-                <span id="vehicles">
+                <div id="header_img">
+                    <a class="no_link" href="https://graphhopper.com">
+                        <img alt="GraphHopper" src="./img/header.png"/>                    
+                    </a>
+                </div>
+                <div id="options">
+                    <span id="vehicles">
 
-                </span>
-            </div>
-            <form id="locationform">
-                <div id="locationpoints">
-                    <div id="fromDiv">
-                        <img id="fromIndicator" class="hidden" src="img/indicator.gif"/>
-                        <img id="fromFlag" src="img/marker-small-green.png"/>
-                        <input id="fromInput" type="text" placeholder="From"/>
-                        <div class="clear"> </div>
-                        <div id="fromResolveFound"></div>
-                        <div id="fromResolveError"></div>
-                    </div>
-                    <div class="clear"> </div>
-                    <div id="toDiv">
-                        <img id="toIndicator" class="hidden" src="img/indicator.gif"/>
-                        <img id="toFlag" src="img/marker-small-red.png"/>                    
-                        <input id="toInput" type="text" placeholder="To"/>
-                        <div class="clear"> </div>
-                        <div id="toResolveFound"></div>
-                        <div id="toResolveError"></div>
-                    </div>
+                    </span>
                 </div>
-                <div class="clear"> </div>                
-                <input id="searchButton" type="submit" value="Search">                
-            </form>      
-            <div id="exportLink" title="Static Link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
-            <div id="gpxExportButton" title="GPX Download"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
-            <div id="hosting">Powered by <a href='http://graphhopper.com/#enterprise'>GraphHopper API</a></div>            
+                <form id="locationform">
+                    <div id="locationpoints">
+                        <div id="x_pointAdd" class="pointAdd"><img src="./img/point_add.png"/></div>
+                    </div>
+                    <div class="clear"> </div>                
+                    <input id="searchButton" type="submit" value="Search">                
+                </form>      
+                <div id="export-link" title="Static Link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
+                <div id="gpxExportButton" title="GPX Download"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
+                <div id="hosting">Powered by <a href='https://graphhopper.com/#directions-api'>GraphHopper API</a></div>                
             </div>
             <div class="clear"> </div>
             <div id="info" class="small_text">
             </div>
             <div id="error" class="error">
             </div>
-        </div>        
+
+            <div id="footer">
+                <div id="link_line">
+                    <a class="footer-link" href='https://graphhopper.com/#contact'>Contact</a>
+                    <a class="footer-link" href='https://graphhopper.com/terms.html'>Terms</a>
+                    <a class="footer-link" href='https://graphhopper.com/privacy.html'>Privacy</a>
+                </div>
+            </div>  
+
+            <div id="pointTemplate" class="hidden">
+                <div id="{id}_Div" class="pointDiv">
+                    <img id="{id}_Indicator" class="hidden pointIndicator" src="img/loading.gif"/>
+                    <img id="{id}_Flag" class="pointFlag" src="img/marker-small-green.png"/>
+                    <input id="{id}_Input" class="pointInput" type="text" placeholder=""/>
+                    <div class="pointDelete"><img src="./img/point_delete.png"></div>
+                    <div class="clear"> </div>
+                    <div id="{id}_ResolveFound" class="pointResolveFound"></div>
+                    <div id="{id}_ResolveError" class="pointResolveError"></div>
+                </div>
+            </div>   
+        </div>
 
         <div id="map">
         </div>
@@ -78,20 +87,23 @@
         <script type="text/javascript">
             PIWIK = false;
             if (PIWIK) {
-                var pkBaseURL = (("https:" == document.location.protocol) ? "https://www.pannous.info/piwik/" : "http://www.pannous.info/piwik/");
-                document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
+                var _paq = _paq || [];
+                _paq.push(['trackPageView']);
+                _paq.push(['enableLinkTracking']);
+                (function () {
+                    var u = (("https:" == document.location.protocol) ? "https" : "http") + "://graphhopper.com/piwik/";
+                    _paq.push(['setTrackerUrl', u + 'piwik.php']);
+                    _paq.push(['setSiteId', 1]);
+                    var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
+                    g.type = 'text/javascript';
+                    g.defer = true;
+                    g.async = true;
+                    g.src = u + 'piwik.js';
+                    s.parentNode.insertBefore(g, s);
+                })();
             }
         </script>
-        <script type="text/javascript">
-            if (PIWIK)
-                try {
-                    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 7);
-                    piwikTracker.trackPageView();
-                    piwikTracker.enableLinkTracking();
-                } catch (err) {
-                }
-        </script>
-        <noscript><p><img src="http://www.pannous.info/piwik/piwik.php?idsite=7" style="border:0" alt="" /></p></noscript>
-        <!-- End Piwik Tracking Code -->
+        <noscript><p><img src="https://graphhopper.com/piwik/piwik.php?idsite=1" style="border:0;" alt="" /></p></noscript>
+        <!-- End Piwik Code -->
     </body>
 </html>
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 6a78c27a99..a8f092946e 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -1,37 +1,310 @@
-// IE fix
-if (!window.console) {
-    var console = {
-        log: function() {
-        },
-        warn: function() {
-        },
-        error: function() {
-        },
-        time: function() {
-        },
-        timeEnd: function() {
+// usage: log('inside coolFunc',this,arguments);
+// http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/
+var debug = false;
+window.log = function () {
+    log.history = log.history || [];   // store logs to an array for reference
+    log.history.push(arguments);
+    if (this.console && debug) {
+        console.log(Array.prototype.slice.call(arguments));
+    }
+};
+
+// compatiblity script taken from http://stackoverflow.com/a/11054570/194609
+if (!Function.prototype.bind) {
+    Function.prototype.bind = function (oThis) {
+        if (typeof this !== 'function') {
+            // closest thing possible to the ECMAScript 5
+            // internal IsCallable function
+            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
         }
+
+        var aArgs = Array.prototype.slice.call(arguments, 1),
+                fToBind = this,
+                fNOP = function () {
+                },
+                fBound = function () {
+                    return fToBind.apply(this instanceof fNOP && oThis
+                            ? this
+                            : oThis,
+                            aArgs.concat(Array.prototype.slice.call(arguments)));
+                };
+
+        fNOP.prototype = this.prototype;
+        fBound.prototype = new fNOP();
+
+        return fBound;
     };
 }
 
-GHRequest = function(host) {
-    this.min_path_precision = 1;
+GHRequest = function (host) {
+    this.way_point_max_distance = 1;
     this.host = host;
-    this.from = new GHInput("");
-    this.to = new GHInput("");
+    this.route = new GHroute(new GHInput(), new GHInput());
+    this.from = this.route.first();
+    this.to = this.route.last();
     this.vehicle = "car";
     this.weighting = "fastest";
     this.points_encoded = true;
     this.instructions = true;
+    this.elevation = false;
+    this.features = {};
     this.debug = false;
     this.locale = "en";
     this.do_zoom = true;
     // use jsonp here if host allows CORS
-    this.dataType = "jsonp";
-    this.key = "tcV28oCCNIzu4GD1Hsp8dYGAHqFBXvYrBvBwthGE";
+    this.dataType = "json";
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
+    // Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
+    // https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    this.key = "Cmmtvx01R56rdHcQQo7VjI6rgPgxuFLvqI8cR31u";
+
+    // register events
+    this.route.addListener('route.add', function (evt) {
+        this.to = this.route.last();
+        log("Foo just added.");
+    }.bind(this));
+    this.route.addListener('route.remove', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just removed.");
+    }.bind(this));
+    this.route.addListener('route.move', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just moved.");
+    }.bind(this));
+//    this.route.addListener('route.set', function (evt) {
+//        this.from = this.route.first();
+//        this.to = this.route.last();
+//        log("Foo just moved.");
+//    }.bind(this));
+    this.route.addListener('route.reverse', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just reversed.");
+    }.bind(this));
 };
 
-GHRequest.prototype.init = function(params) {
+GHroute = function () {
+    var route = Object.create(Array.prototype);
+    route = (Array.apply(route, arguments) || route);
+    GHroute.injectClassMethods(route);
+    route._listeners = {};
+    return (route);
+};
+
+GHroute.injectClassMethods = function (route) {
+    for (var method in GHroute.prototype) {
+        if (GHroute.prototype.hasOwnProperty(method)) {
+            route[method] = GHroute.prototype[method];
+        }
+    }
+    return (route);
+};
+
+GHroute.fromArray = function (array) {
+    var route = GHroute.apply(null, array);
+    return (route);
+};
+
+GHroute.isArray = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object array]");
+};
+
+GHroute.prototype = {
+    first: function () {
+        return this.getIndex(0);
+    },
+    last: function () {
+        return this.getIndex((this.length - 1));
+    },
+    getIndex: function (index) {
+        var index = (isNaN(index)) ? 0 : index;
+        if (this[index] instanceof GHInput) {
+            return this[index];
+        } else
+            return false;
+    },
+    getIndexByCoord: function (value) {
+        var point,
+                index = false,
+                coord = new GHInput(value),
+                i,
+                l;
+
+        for (i = 0, l = this.length; i < l; i++) {
+            point = this[i];
+            if (point.toString() === coord.toString()) {
+                index = i;
+                break;
+            }
+        }
+        return index;
+    },
+    getIndexFromCoord: function (value) {
+        return this.getIndex(this.getIndexByCoord(value));
+    },
+    size: function () {
+        return this.length;
+    },
+    add: function (value, to) {
+        if (GHroute.isArray(value)) {
+            for (var i = 0; i < value.length; i++) {
+                Array.prototype.push.call(this, (value[i] instanceof GHInput) ? value[i] : new GHInput(value[i]));
+                if (to !== undefined) {
+                    this.move(-1, to, true);
+                    to++;
+                } else
+                    to = this.lenght - 1;
+                this.fire('route.add', {
+                    point: this[to],
+                    to: to
+                });
+            }
+            return (this);
+        } else {
+            Array.prototype.push.call(this, (value instanceof GHInput) ? value : new GHInput(value));
+            if (to !== undefined)
+                this.move(-1, to, true);
+            else
+                to = this.lenght - 1;
+            this.fire('route.add', {
+                point: this[to],
+                to: to
+            });
+        }
+        return (this[to]);
+    },
+    removeSingle: function (value) {
+        var index = false;
+        if (!(isNaN(value) || value >= this.length) && this[value] !== undefined) {
+            index = value;
+        } else {
+            if (value instanceof GHInput) {
+                value = value.toString();
+            }
+            index = this.getIndexByCoord(value);
+        }
+        if (index !== false) {
+            this.remove(index);
+        }
+        return (this);
+    },
+    remove: function (from, to) {
+        var tmpTo = to || 1;
+        Array.prototype.splice.call(this, from, tmpTo);
+        if (this.length === 1)
+            Array.prototype.push.call(this, new GHInput());
+        this.fire('route.remove', {
+            from: from,
+            to: tmpTo
+        });
+        return (this);
+    },
+    addAll: function () {
+        for (var i = 0; i < arguments.length; i++) {
+            this.add(arguments[i]);
+        }
+        return (this);
+    },
+    set: function (value, to, create) {
+        if (value instanceof GHInput)
+            this[to] = value;
+        else if (this[to] instanceof GHInput) {
+            this[to].set(value);
+        } else if (create)
+            return this.add(value, to);
+        else
+            return false;
+        this.fire('route.set', {
+            point: this[to],
+            to: to
+        });
+        return (this[to]);
+    },
+    move: function (old_index, new_index, supress_event) {
+        while (old_index < 0) {
+            old_index += this.length;
+        }
+        while (new_index < 0) {
+            new_index += this.length;
+        }
+        if (new_index >= this.length) {
+            var k = new_index - this.length;
+            while ((k--) + 1) {
+                Array.prototype.push.call(this, undefined);
+            }
+        }
+        Array.prototype.splice.call(this, new_index, 0, Array.prototype.splice.call(this, old_index, 1)[0]);
+        if (!supress_event)
+            this.fire('route.move', {
+                old_index: old_index,
+                new_index: new_index
+            });
+        return (this);
+    },
+    reverse: function () {
+        Array.prototype.reverse.call(this);
+        this.fire('route.reverse', {});
+        return (this);
+    },
+    isResolved: function () {
+        for (var i = 0, l = this.length; i < l; i++) {
+            var point = this[i];
+            if (!point.isResolved()) {
+                return false;
+            }
+        }
+        return true;
+    },
+    addListener: function (type, listener) {
+        if (typeof this._listeners[type] === "undefined") {
+            this._listeners[type] = [];
+        }
+        this._listeners[type].push(listener);
+        return this;
+    },
+    fire: function (event, options) {
+        if (typeof event === "string") {
+            event = {type: event};
+        }
+        if (typeof options === "object") {
+            for (var attrname in options) {
+                event[attrname] = options[attrname];
+            }
+        }
+        if (!event.route) {
+            event.route = this;
+        }
+        if (!event.type) {  //falsy
+            throw new Error("Event object missing 'type' property.");
+        }
+        if (this._listeners[event.type] instanceof Array) {
+            var listeners = this._listeners[event.type];
+            for (var i = 0, len = listeners.length; i < len; i++) {
+                listeners[i].call(this, event);
+            }
+        }
+    },
+    removeListener: function (type, listener) {
+        if (this._listeners[type] instanceof Array) {
+            var listeners = this._listeners[type];
+            for (var i = 0, len = listeners.length; i < len; i++) {
+                if (listeners[i] === listener) {
+                    listeners.splice(i, 1);
+                    break;
+                }
+            }
+        }
+    }
+};
+
+// todo
+GHRequest.prototype.init = function (params) {
     //    for(var key in params) {
     //        var val = params[key];
     //        if(val === "false")
@@ -55,9 +328,21 @@ GHRequest.prototype.init = function(params) {
     if (params.locale)
         this.locale = params.locale;
 
-    this.handleBoolean("do_zoom", params);
-    this.handleBoolean("instructions", params);
-    this.handleBoolean("points_encoded", params);
+    if ('do_zoom' in params)
+        this.do_zoom = params.do_zoom;
+    if ('instructions' in params)
+        this.instructions = params.instructions;
+    if ('points_encoded' in params)
+        this.points_encoded = params.points_encoded;
+
+    this.elevation = false;
+    var featureSet = this.features[this.vehicle];
+    if (featureSet && featureSet.elevation) {
+        if ('elevation' in params)
+            this.elevation = params.elevation;
+        else
+            this.elevation = true;
+    }
 
     if (params.q) {
         var qStr = params.q;
@@ -87,51 +372,91 @@ GHRequest.prototype.init = function(params) {
     }
 };
 
-GHRequest.prototype.handleBoolean = function(key, params) {
-    if (key in params)
-        this[key] = params[key] === "true" || params[key] === true;
+GHRequest.prototype.initVehicle = function (vehicle) {
+    this.vehicle = vehicle;
+    var featureSet = this.features[this.vehicle];
+    if (featureSet && featureSet.elevation)
+        this.elevation = true;
+    else
+        this.elevation = false;
 };
 
-GHRequest.prototype.createGeocodeURL = function() {
-    return this.createPath(this.host + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key);
+GHRequest.prototype.hasElevation = function () {
+    return this.elevation;
 };
 
-GHRequest.prototype.createURL = function(demoUrl) {
-    return this.createPath(this.host + "/route?" + demoUrl + "&type=" + this.dataType + "&key=" + this.key);
+GHRequest.prototype.createGeocodeURL = function (host) {
+    var tmpHost = this.host;
+    if (host)
+        tmpHost = host;
+    return this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key + "&locale=" + this.locale);
 };
 
-GHRequest.prototype.createGPXURL = function() {
+GHRequest.prototype.createURL = function () {
+    return this.createPath(this.host + "/route?" + this.createParams() + "&type=" + this.dataType + "&key=" + this.key);
+};
+
+GHRequest.prototype.createGPXURL = function () {
     // use points instead of strings
-    var str = "point=" + encodeURIComponent(this.from.toString()) + "&point=" + encodeURIComponent(this.to.toString());
+    var str = "", point, i, l;
+
+    for (i = 0, l = this.route.size(); i < l; i++) {
+        point = this.route.getIndex(i);
+        if (i > 0)
+            str += "&";
+        str += "point=" + encodeURIComponent(point.toString());
+    }
     return this.createPath(this.host + "/route?" + str + "&type=gpx&key=" + this.key);
 };
 
-GHRequest.prototype.createFullURL = function() {
-    var str = "?point=" + encodeURIComponent(this.from.input) + "&point=" + encodeURIComponent(this.to.input);
+GHRequest.prototype.createHistoryURL = function () {
+    var str = "?", point, i, l;
+
+    for (i = 0, l = this.route.size(); i < l; i++) {
+        point = this.route.getIndex(i);
+        if (i > 0)
+            str += "&";
+        str += "point=" + encodeURIComponent(point.input);
+    }
     return this.createPath(str);
 };
 
-GHRequest.prototype.createPath = function(url) {
-    if (this.vehicle && this.vehicle != "car")
+GHRequest.prototype.createParams = function () {
+    var str = "", point, i, l;
+
+    for (i = 0, l = this.route.size(); i < l; i++) {
+        point = this.route.getIndex(i);
+        if (i > 0)
+            str += "&";
+        str += "point=" + encodeURIComponent(point.toString());
+    }
+    return (str);
+};
+
+GHRequest.prototype.createPath = function (url) {
+    if (this.vehicle && this.vehicle !== "car")
         url += "&vehicle=" + this.vehicle;
     // fastest or shortest
-    if (this.weighting && this.weighting != "fastest")
+    if (this.weighting && this.weighting !== "fastest")
         url += "&weighting=" + this.weighting;
-    if (this.locale && this.locale != "en")
+    if (this.locale && this.locale !== "en")
         url += "&locale=" + this.locale;
     // dijkstra, dijkstrabi, astar, astarbi
-    if (this.algorithm && this.algorithm != "dijkstrabi")
+    if (this.algorithm && this.algorithm !== "dijkstrabi")
         url += "&algorithm=" + this.algorithm;
+    if (this.way_point_max_distance !== 1)
+        url += "&way_point_max_distance=" + this.way_point_max_distance;
     if (!this.instructions)
         url += "&instructions=false";
     if (!this.points_encoded)
         url += "&points_encoded=false";
-    if (this.min_path_precision !== 1)
-        url += "&min_path_precision=" + this.min_path_precision;
+
+    if (this.elevation)
+        url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
     return url;
-}
+};
 
 function decodePath(encoded, is3D) {
     // var start = new Date().getTime();
@@ -185,17 +510,18 @@ function decodePath(encoded, is3D) {
     return array;
 }
 
-GHRequest.prototype.doRequest = function(url, callback) {
+GHRequest.prototype.doRequest = function (url, callback) {
+    var that = this;
     $.ajax({
-        "timeout": 30000,
-        "url": url,
-        "success": function(json) {
+        timeout: 30000,
+        url: url,
+        success: function (json) {
             if (json.paths) {
                 for (var i = 0; i < json.paths.length; i++) {
                     var path = json.paths[i];
                     // convert encoded polyline to geo json
                     if (path.points_encoded) {
-                        var tmpArray = decodePath(path.points, path.points_dimension === 3);
+                        var tmpArray = decodePath(path.points, that.hasElevation());
                         path.points = {
                             "type": "LineString",
                             "coordinates": tmpArray
@@ -205,14 +531,17 @@ GHRequest.prototype.doRequest = function(url, callback) {
             }
             callback(json);
         },
-        "error": function(err) {
+        error: function (err) {
             // problematic: this callback is not invoked when using JSONP!
             // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
-            if (err && err.statusText && err.statusText != "OK")
+            if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
+                var jsonError = JSON.parse(err.responseText);
+                msg += jsonError.message;
+            } else if (err && err.statusText && err.statusText !== "OK")
                 msg += err.statusText;
 
-            console.log(msg + " " + JSON.stringify(err));
+            log(msg + " " + JSON.stringify(err));
             var details = "Error for " + url;
             var json = {
                 "info": {
@@ -224,72 +553,100 @@ GHRequest.prototype.doRequest = function(url, callback) {
             };
             callback(json);
         },
-        "type": "GET",
-        "dataType": this.dataType
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
 
-GHRequest.prototype.getInfo = function() {
+GHRequest.prototype.getInfo = function () {
     var url = this.host + "/info?type=" + this.dataType + "&key=" + this.key;
-    console.log(url);
+    log(url);
     return $.ajax({
-        "url": url,
-        "timeout": 3000,
-        "type": "GET",
-        "dataType": this.dataType
+        url: url,
+        timeout: 3000,
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
 
-GHInput = function(str) {
-    // either text or coordinates
-    this.input = str;
-    try {
-        var index = str.indexOf(",");
-        if (index >= 0) {
-            this.lat = round(parseFloat(str.substr(0, index)));
-            this.lng = round(parseFloat(str.substr(index + 1)));
-            if (!isNaN(this.lat) && !isNaN(this.lng)) {
-                this.input = this.toString();
-            } else {
-                this.lat = undefined;
-                this.lng = undefined;
-            }
-        }
-    } catch (ex) {
-    }
+GHInput = function (input) {
+    this.set(input);
+};
+
+GHInput.isObject = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object object]");
+};
+
+GHInput.isString = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object string]");
 };
 
-GHInput.prototype.isResolved = function() {
-    return this.lat && this.lng;
+GHInput.prototype.isResolved = function () {
+    return !isNaN(this.lat) && !isNaN(this.lng);
 };
 
-GHInput.prototype.setCoord = function(lat, lng) {
+GHInput.prototype.setCoord = function (lat, lng) {
     this.lat = round(lat);
     this.lng = round(lng);
-    this.input = this.lat + "," + this.lng;
+    this.input = this.toString();
+};
+
+GHInput.prototype.setUnresolved = function () {
+    this.lat = undefined;
+    this.lng = undefined;
+};
+
+GHInput.prototype.set = function (strOrObject) {
+    // either text or coordinates or object
+    this.input = strOrObject;
+    // reset to unresolved
+
+
+    if (GHInput.isObject(strOrObject)) {
+        this.setCoord(strOrObject.lat, strOrObject.lng);
+    } else if (GHInput.isString(strOrObject)) {
+        var index = strOrObject.indexOf(",");
+        if (index >= 0) {
+            this.lat = round(parseFloat(strOrObject.substr(0, index)));
+            this.lng = round(parseFloat(strOrObject.substr(index + 1)));
+
+            if (this.isResolved()) {
+                this.input = this.toString();
+            } else {
+                this.setUnresolved();
+            }
+        } else {
+            this.setUnresolved();
+        }
+    }
 };
 
-GHInput.prototype.toString = function() {
+GHInput.prototype.toString = function () {
     if (this.lat !== undefined && this.lng !== undefined)
         return this.lat + "," + this.lng;
     return undefined;
 };
 
-GHRequest.prototype.setLocale = function(locale) {
+GHRequest.prototype.setLocale = function (locale) {
     if (locale)
         this.locale = locale;
 };
 
-GHRequest.prototype.fetchTranslationMap = function(urlLocaleParam) {
+GHRequest.prototype.fetchTranslationMap = function (urlLocaleParam) {
     if (!urlLocaleParam)
         // let servlet figure out the locale from the Accept-Language header
         urlLocaleParam = "";
     var url = this.host + "/i18n/" + urlLocaleParam + "?type=" + this.dataType + "&key=" + this.key;
-    console.log(url);
+    log(url);
     return $.ajax({
-        "url": url,
-        "timeout": 3000,
-        "type": "GET",
-        "dataType": this.dataType
+        url: url,
+        timeout: 3000,
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
\ No newline at end of file
diff --git a/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js
new file mode 100644
index 0000000000..c005b73831
--- /dev/null
+++ b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js
@@ -0,0 +1,2747 @@
+/*! jQuery UI - v1.10.4 - 2014-06-27
+* http://jqueryui.com
+* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.sortable.js
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+(function( $, undefined ) {
+
+var uuid = 0,
+	runiqueId = /^ui-id-\d+$/;
+
+// $.ui might exist from components with no dependencies, e.g., $.ui.position
+$.ui = $.ui || {};
+
+$.extend( $.ui, {
+	version: "1.10.4",
+
+	keyCode: {
+		BACKSPACE: 8,
+		COMMA: 188,
+		DELETE: 46,
+		DOWN: 40,
+		END: 35,
+		ENTER: 13,
+		ESCAPE: 27,
+		HOME: 36,
+		LEFT: 37,
+		NUMPAD_ADD: 107,
+		NUMPAD_DECIMAL: 110,
+		NUMPAD_DIVIDE: 111,
+		NUMPAD_ENTER: 108,
+		NUMPAD_MULTIPLY: 106,
+		NUMPAD_SUBTRACT: 109,
+		PAGE_DOWN: 34,
+		PAGE_UP: 33,
+		PERIOD: 190,
+		RIGHT: 39,
+		SPACE: 32,
+		TAB: 9,
+		UP: 38
+	}
+});
+
+// plugins
+$.fn.extend({
+	focus: (function( orig ) {
+		return function( delay, fn ) {
+			return typeof delay === "number" ?
+				this.each(function() {
+					var elem = this;
+					setTimeout(function() {
+						$( elem ).focus();
+						if ( fn ) {
+							fn.call( elem );
+						}
+					}, delay );
+				}) :
+				orig.apply( this, arguments );
+		};
+	})( $.fn.focus ),
+
+	scrollParent: function() {
+		var scrollParent;
+		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
+			scrollParent = this.parents().filter(function() {
+				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
+			}).eq(0);
+		} else {
+			scrollParent = this.parents().filter(function() {
+				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
+			}).eq(0);
+		}
+
+		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
+	},
+
+	zIndex: function( zIndex ) {
+		if ( zIndex !== undefined ) {
+			return this.css( "zIndex", zIndex );
+		}
+
+		if ( this.length ) {
+			var elem = $( this[ 0 ] ), position, value;
+			while ( elem.length && elem[ 0 ] !== document ) {
+				// Ignore z-index if position is set to a value where z-index is ignored by the browser
+				// This makes behavior of this function consistent across browsers
+				// WebKit always returns auto if the element is positioned
+				position = elem.css( "position" );
+				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
+					// IE returns 0 when zIndex is not specified
+					// other browsers return a string
+					// we ignore the case of nested elements with an explicit value of 0
+					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
+					value = parseInt( elem.css( "zIndex" ), 10 );
+					if ( !isNaN( value ) && value !== 0 ) {
+						return value;
+					}
+				}
+				elem = elem.parent();
+			}
+		}
+
+		return 0;
+	},
+
+	uniqueId: function() {
+		return this.each(function() {
+			if ( !this.id ) {
+				this.id = "ui-id-" + (++uuid);
+			}
+		});
+	},
+
+	removeUniqueId: function() {
+		return this.each(function() {
+			if ( runiqueId.test( this.id ) ) {
+				$( this ).removeAttr( "id" );
+			}
+		});
+	}
+});
+
+// selectors
+function focusable( element, isTabIndexNotNaN ) {
+	var map, mapName, img,
+		nodeName = element.nodeName.toLowerCase();
+	if ( "area" === nodeName ) {
+		map = element.parentNode;
+		mapName = map.name;
+		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
+			return false;
+		}
+		img = $( "img[usemap=#" + mapName + "]" )[0];
+		return !!img && visible( img );
+	}
+	return ( /input|select|textarea|button|object/.test( nodeName ) ?
+		!element.disabled :
+		"a" === nodeName ?
+			element.href || isTabIndexNotNaN :
+			isTabIndexNotNaN) &&
+		// the element and all of its ancestors must be visible
+		visible( element );
+}
+
+function visible( element ) {
+	return $.expr.filters.visible( element ) &&
+		!$( element ).parents().addBack().filter(function() {
+			return $.css( this, "visibility" ) === "hidden";
+		}).length;
+}
+
+$.extend( $.expr[ ":" ], {
+	data: $.expr.createPseudo ?
+		$.expr.createPseudo(function( dataName ) {
+			return function( elem ) {
+				return !!$.data( elem, dataName );
+			};
+		}) :
+		// support: jQuery <1.8
+		function( elem, i, match ) {
+			return !!$.data( elem, match[ 3 ] );
+		},
+
+	focusable: function( element ) {
+		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
+	},
+
+	tabbable: function( element ) {
+		var tabIndex = $.attr( element, "tabindex" ),
+			isTabIndexNaN = isNaN( tabIndex );
+		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
+	}
+});
+
+// support: jQuery <1.8
+if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
+	$.each( [ "Width", "Height" ], function( i, name ) {
+		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
+			type = name.toLowerCase(),
+			orig = {
+				innerWidth: $.fn.innerWidth,
+				innerHeight: $.fn.innerHeight,
+				outerWidth: $.fn.outerWidth,
+				outerHeight: $.fn.outerHeight
+			};
+
+		function reduce( elem, size, border, margin ) {
+			$.each( side, function() {
+				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
+				if ( border ) {
+					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
+				}
+				if ( margin ) {
+					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
+				}
+			});
+			return size;
+		}
+
+		$.fn[ "inner" + name ] = function( size ) {
+			if ( size === undefined ) {
+				return orig[ "inner" + name ].call( this );
+			}
+
+			return this.each(function() {
+				$( this ).css( type, reduce( this, size ) + "px" );
+			});
+		};
+
+		$.fn[ "outer" + name] = function( size, margin ) {
+			if ( typeof size !== "number" ) {
+				return orig[ "outer" + name ].call( this, size );
+			}
+
+			return this.each(function() {
+				$( this).css( type, reduce( this, size, true, margin ) + "px" );
+			});
+		};
+	});
+}
+
+// support: jQuery <1.8
+if ( !$.fn.addBack ) {
+	$.fn.addBack = function( selector ) {
+		return this.add( selector == null ?
+			this.prevObject : this.prevObject.filter( selector )
+		);
+	};
+}
+
+// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
+if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
+	$.fn.removeData = (function( removeData ) {
+		return function( key ) {
+			if ( arguments.length ) {
+				return removeData.call( this, $.camelCase( key ) );
+			} else {
+				return removeData.call( this );
+			}
+		};
+	})( $.fn.removeData );
+}
+
+
+
+
+
+// deprecated
+$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
+
+$.support.selectstart = "onselectstart" in document.createElement( "div" );
+$.fn.extend({
+	disableSelection: function() {
+		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
+			".ui-disableSelection", function( event ) {
+				event.preventDefault();
+			});
+	},
+
+	enableSelection: function() {
+		return this.unbind( ".ui-disableSelection" );
+	}
+});
+
+$.extend( $.ui, {
+	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
+	plugin: {
+		add: function( module, option, set ) {
+			var i,
+				proto = $.ui[ module ].prototype;
+			for ( i in set ) {
+				proto.plugins[ i ] = proto.plugins[ i ] || [];
+				proto.plugins[ i ].push( [ option, set[ i ] ] );
+			}
+		},
+		call: function( instance, name, args ) {
+			var i,
+				set = instance.plugins[ name ];
+			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
+				return;
+			}
+
+			for ( i = 0; i < set.length; i++ ) {
+				if ( instance.options[ set[ i ][ 0 ] ] ) {
+					set[ i ][ 1 ].apply( instance.element, args );
+				}
+			}
+		}
+	},
+
+	// only used by resizable
+	hasScroll: function( el, a ) {
+
+		//If overflow is hidden, the element might have extra content, but the user wants to hide it
+		if ( $( el ).css( "overflow" ) === "hidden") {
+			return false;
+		}
+
+		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
+			has = false;
+
+		if ( el[ scroll ] > 0 ) {
+			return true;
+		}
+
+		// TODO: determine which cases actually cause this to happen
+		// if the element doesn't have the scroll set, see if it's possible to
+		// set the scroll
+		el[ scroll ] = 1;
+		has = ( el[ scroll ] > 0 );
+		el[ scroll ] = 0;
+		return has;
+	}
+});
+
+})( jQuery );
+(function( $, undefined ) {
+
+var uuid = 0,
+	slice = Array.prototype.slice,
+	_cleanData = $.cleanData;
+$.cleanData = function( elems ) {
+	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+		try {
+			$( elem ).triggerHandler( "remove" );
+		// http://bugs.jquery.com/ticket/8235
+		} catch( e ) {}
+	}
+	_cleanData( elems );
+};
+
+$.widget = function( name, base, prototype ) {
+	var fullName, existingConstructor, constructor, basePrototype,
+		// proxiedPrototype allows the provided prototype to remain unmodified
+		// so that it can be used as a mixin for multiple widgets (#8876)
+		proxiedPrototype = {},
+		namespace = name.split( "." )[ 0 ];
+
+	name = name.split( "." )[ 1 ];
+	fullName = namespace + "-" + name;
+
+	if ( !prototype ) {
+		prototype = base;
+		base = $.Widget;
+	}
+
+	// create selector for plugin
+	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
+		return !!$.data( elem, fullName );
+	};
+
+	$[ namespace ] = $[ namespace ] || {};
+	existingConstructor = $[ namespace ][ name ];
+	constructor = $[ namespace ][ name ] = function( options, element ) {
+		// allow instantiation without "new" keyword
+		if ( !this._createWidget ) {
+			return new constructor( options, element );
+		}
+
+		// allow instantiation without initializing for simple inheritance
+		// must use "new" keyword (the code above always passes args)
+		if ( arguments.length ) {
+			this._createWidget( options, element );
+		}
+	};
+	// extend with the existing constructor to carry over any static properties
+	$.extend( constructor, existingConstructor, {
+		version: prototype.version,
+		// copy the object used to create the prototype in case we need to
+		// redefine the widget later
+		_proto: $.extend( {}, prototype ),
+		// track widgets that inherit from this widget in case this widget is
+		// redefined after a widget inherits from it
+		_childConstructors: []
+	});
+
+	basePrototype = new base();
+	// we need to make the options hash a property directly on the new instance
+	// otherwise we'll modify the options hash on the prototype that we're
+	// inheriting from
+	basePrototype.options = $.widget.extend( {}, basePrototype.options );
+	$.each( prototype, function( prop, value ) {
+		if ( !$.isFunction( value ) ) {
+			proxiedPrototype[ prop ] = value;
+			return;
+		}
+		proxiedPrototype[ prop ] = (function() {
+			var _super = function() {
+					return base.prototype[ prop ].apply( this, arguments );
+				},
+				_superApply = function( args ) {
+					return base.prototype[ prop ].apply( this, args );
+				};
+			return function() {
+				var __super = this._super,
+					__superApply = this._superApply,
+					returnValue;
+
+				this._super = _super;
+				this._superApply = _superApply;
+
+				returnValue = value.apply( this, arguments );
+
+				this._super = __super;
+				this._superApply = __superApply;
+
+				return returnValue;
+			};
+		})();
+	});
+	constructor.prototype = $.widget.extend( basePrototype, {
+		// TODO: remove support for widgetEventPrefix
+		// always use the name + a colon as the prefix, e.g., draggable:start
+		// don't prefix for widgets that aren't DOM-based
+		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
+	}, proxiedPrototype, {
+		constructor: constructor,
+		namespace: namespace,
+		widgetName: name,
+		widgetFullName: fullName
+	});
+
+	// If this widget is being redefined then we need to find all widgets that
+	// are inheriting from it and redefine all of them so that they inherit from
+	// the new version of this widget. We're essentially trying to replace one
+	// level in the prototype chain.
+	if ( existingConstructor ) {
+		$.each( existingConstructor._childConstructors, function( i, child ) {
+			var childPrototype = child.prototype;
+
+			// redefine the child widget using the same prototype that was
+			// originally used, but inherit from the new version of the base
+			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
+		});
+		// remove the list of existing child constructors from the old constructor
+		// so the old child constructors can be garbage collected
+		delete existingConstructor._childConstructors;
+	} else {
+		base._childConstructors.push( constructor );
+	}
+
+	$.widget.bridge( name, constructor );
+};
+
+$.widget.extend = function( target ) {
+	var input = slice.call( arguments, 1 ),
+		inputIndex = 0,
+		inputLength = input.length,
+		key,
+		value;
+	for ( ; inputIndex < inputLength; inputIndex++ ) {
+		for ( key in input[ inputIndex ] ) {
+			value = input[ inputIndex ][ key ];
+			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
+				// Clone objects
+				if ( $.isPlainObject( value ) ) {
+					target[ key ] = $.isPlainObject( target[ key ] ) ?
+						$.widget.extend( {}, target[ key ], value ) :
+						// Don't extend strings, arrays, etc. with objects
+						$.widget.extend( {}, value );
+				// Copy everything else by reference
+				} else {
+					target[ key ] = value;
+				}
+			}
+		}
+	}
+	return target;
+};
+
+$.widget.bridge = function( name, object ) {
+	var fullName = object.prototype.widgetFullName || name;
+	$.fn[ name ] = function( options ) {
+		var isMethodCall = typeof options === "string",
+			args = slice.call( arguments, 1 ),
+			returnValue = this;
+
+		// allow multiple hashes to be passed on init
+		options = !isMethodCall && args.length ?
+			$.widget.extend.apply( null, [ options ].concat(args) ) :
+			options;
+
+		if ( isMethodCall ) {
+			this.each(function() {
+				var methodValue,
+					instance = $.data( this, fullName );
+				if ( !instance ) {
+					return $.error( "cannot call methods on " + name + " prior to initialization; " +
+						"attempted to call method '" + options + "'" );
+				}
+				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
+					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
+				}
+				methodValue = instance[ options ].apply( instance, args );
+				if ( methodValue !== instance && methodValue !== undefined ) {
+					returnValue = methodValue && methodValue.jquery ?
+						returnValue.pushStack( methodValue.get() ) :
+						methodValue;
+					return false;
+				}
+			});
+		} else {
+			this.each(function() {
+				var instance = $.data( this, fullName );
+				if ( instance ) {
+					instance.option( options || {} )._init();
+				} else {
+					$.data( this, fullName, new object( options, this ) );
+				}
+			});
+		}
+
+		return returnValue;
+	};
+};
+
+$.Widget = function( /* options, element */ ) {};
+$.Widget._childConstructors = [];
+
+$.Widget.prototype = {
+	widgetName: "widget",
+	widgetEventPrefix: "",
+	defaultElement: "<div>",
+	options: {
+		disabled: false,
+
+		// callbacks
+		create: null
+	},
+	_createWidget: function( options, element ) {
+		element = $( element || this.defaultElement || this )[ 0 ];
+		this.element = $( element );
+		this.uuid = uuid++;
+		this.eventNamespace = "." + this.widgetName + this.uuid;
+		this.options = $.widget.extend( {},
+			this.options,
+			this._getCreateOptions(),
+			options );
+
+		this.bindings = $();
+		this.hoverable = $();
+		this.focusable = $();
+
+		if ( element !== this ) {
+			$.data( element, this.widgetFullName, this );
+			this._on( true, this.element, {
+				remove: function( event ) {
+					if ( event.target === element ) {
+						this.destroy();
+					}
+				}
+			});
+			this.document = $( element.style ?
+				// element within the document
+				element.ownerDocument :
+				// element is window or document
+				element.document || element );
+			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
+		}
+
+		this._create();
+		this._trigger( "create", null, this._getCreateEventData() );
+		this._init();
+	},
+	_getCreateOptions: $.noop,
+	_getCreateEventData: $.noop,
+	_create: $.noop,
+	_init: $.noop,
+
+	destroy: function() {
+		this._destroy();
+		// we can probably remove the unbind calls in 2.0
+		// all event bindings should go through this._on()
+		this.element
+			.unbind( this.eventNamespace )
+			// 1.9 BC for #7810
+			// TODO remove dual storage
+			.removeData( this.widgetName )
+			.removeData( this.widgetFullName )
+			// support: jquery <1.6.3
+			// http://bugs.jquery.com/ticket/9413
+			.removeData( $.camelCase( this.widgetFullName ) );
+		this.widget()
+			.unbind( this.eventNamespace )
+			.removeAttr( "aria-disabled" )
+			.removeClass(
+				this.widgetFullName + "-disabled " +
+				"ui-state-disabled" );
+
+		// clean up events and states
+		this.bindings.unbind( this.eventNamespace );
+		this.hoverable.removeClass( "ui-state-hover" );
+		this.focusable.removeClass( "ui-state-focus" );
+	},
+	_destroy: $.noop,
+
+	widget: function() {
+		return this.element;
+	},
+
+	option: function( key, value ) {
+		var options = key,
+			parts,
+			curOption,
+			i;
+
+		if ( arguments.length === 0 ) {
+			// don't return a reference to the internal hash
+			return $.widget.extend( {}, this.options );
+		}
+
+		if ( typeof key === "string" ) {
+			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
+			options = {};
+			parts = key.split( "." );
+			key = parts.shift();
+			if ( parts.length ) {
+				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
+				for ( i = 0; i < parts.length - 1; i++ ) {
+					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
+					curOption = curOption[ parts[ i ] ];
+				}
+				key = parts.pop();
+				if ( arguments.length === 1 ) {
+					return curOption[ key ] === undefined ? null : curOption[ key ];
+				}
+				curOption[ key ] = value;
+			} else {
+				if ( arguments.length === 1 ) {
+					return this.options[ key ] === undefined ? null : this.options[ key ];
+				}
+				options[ key ] = value;
+			}
+		}
+
+		this._setOptions( options );
+
+		return this;
+	},
+	_setOptions: function( options ) {
+		var key;
+
+		for ( key in options ) {
+			this._setOption( key, options[ key ] );
+		}
+
+		return this;
+	},
+	_setOption: function( key, value ) {
+		this.options[ key ] = value;
+
+		if ( key === "disabled" ) {
+			this.widget()
+				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
+				.attr( "aria-disabled", value );
+			this.hoverable.removeClass( "ui-state-hover" );
+			this.focusable.removeClass( "ui-state-focus" );
+		}
+
+		return this;
+	},
+
+	enable: function() {
+		return this._setOption( "disabled", false );
+	},
+	disable: function() {
+		return this._setOption( "disabled", true );
+	},
+
+	_on: function( suppressDisabledCheck, element, handlers ) {
+		var delegateElement,
+			instance = this;
+
+		// no suppressDisabledCheck flag, shuffle arguments
+		if ( typeof suppressDisabledCheck !== "boolean" ) {
+			handlers = element;
+			element = suppressDisabledCheck;
+			suppressDisabledCheck = false;
+		}
+
+		// no element argument, shuffle and use this.element
+		if ( !handlers ) {
+			handlers = element;
+			element = this.element;
+			delegateElement = this.widget();
+		} else {
+			// accept selectors, DOM elements
+			element = delegateElement = $( element );
+			this.bindings = this.bindings.add( element );
+		}
+
+		$.each( handlers, function( event, handler ) {
+			function handlerProxy() {
+				// allow widgets to customize the disabled handling
+				// - disabled as an array instead of boolean
+				// - disabled class as method for disabling individual parts
+				if ( !suppressDisabledCheck &&
+						( instance.options.disabled === true ||
+							$( this ).hasClass( "ui-state-disabled" ) ) ) {
+					return;
+				}
+				return ( typeof handler === "string" ? instance[ handler ] : handler )
+					.apply( instance, arguments );
+			}
+
+			// copy the guid so direct unbinding works
+			if ( typeof handler !== "string" ) {
+				handlerProxy.guid = handler.guid =
+					handler.guid || handlerProxy.guid || $.guid++;
+			}
+
+			var match = event.match( /^(\w+)\s*(.*)$/ ),
+				eventName = match[1] + instance.eventNamespace,
+				selector = match[2];
+			if ( selector ) {
+				delegateElement.delegate( selector, eventName, handlerProxy );
+			} else {
+				element.bind( eventName, handlerProxy );
+			}
+		});
+	},
+
+	_off: function( element, eventName ) {
+		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
+		element.unbind( eventName ).undelegate( eventName );
+	},
+
+	_delay: function( handler, delay ) {
+		function handlerProxy() {
+			return ( typeof handler === "string" ? instance[ handler ] : handler )
+				.apply( instance, arguments );
+		}
+		var instance = this;
+		return setTimeout( handlerProxy, delay || 0 );
+	},
+
+	_hoverable: function( element ) {
+		this.hoverable = this.hoverable.add( element );
+		this._on( element, {
+			mouseenter: function( event ) {
+				$( event.currentTarget ).addClass( "ui-state-hover" );
+			},
+			mouseleave: function( event ) {
+				$( event.currentTarget ).removeClass( "ui-state-hover" );
+			}
+		});
+	},
+
+	_focusable: function( element ) {
+		this.focusable = this.focusable.add( element );
+		this._on( element, {
+			focusin: function( event ) {
+				$( event.currentTarget ).addClass( "ui-state-focus" );
+			},
+			focusout: function( event ) {
+				$( event.currentTarget ).removeClass( "ui-state-focus" );
+			}
+		});
+	},
+
+	_trigger: function( type, event, data ) {
+		var prop, orig,
+			callback = this.options[ type ];
+
+		data = data || {};
+		event = $.Event( event );
+		event.type = ( type === this.widgetEventPrefix ?
+			type :
+			this.widgetEventPrefix + type ).toLowerCase();
+		// the original event may come from any element
+		// so we need to reset the target on the new event
+		event.target = this.element[ 0 ];
+
+		// copy original event properties over to the new event
+		orig = event.originalEvent;
+		if ( orig ) {
+			for ( prop in orig ) {
+				if ( !( prop in event ) ) {
+					event[ prop ] = orig[ prop ];
+				}
+			}
+		}
+
+		this.element.trigger( event, data );
+		return !( $.isFunction( callback ) &&
+			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
+			event.isDefaultPrevented() );
+	}
+};
+
+$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
+	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
+		if ( typeof options === "string" ) {
+			options = { effect: options };
+		}
+		var hasOptions,
+			effectName = !options ?
+				method :
+				options === true || typeof options === "number" ?
+					defaultEffect :
+					options.effect || defaultEffect;
+		options = options || {};
+		if ( typeof options === "number" ) {
+			options = { duration: options };
+		}
+		hasOptions = !$.isEmptyObject( options );
+		options.complete = callback;
+		if ( options.delay ) {
+			element.delay( options.delay );
+		}
+		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
+			element[ method ]( options );
+		} else if ( effectName !== method && element[ effectName ] ) {
+			element[ effectName ]( options.duration, options.easing, callback );
+		} else {
+			element.queue(function( next ) {
+				$( this )[ method ]();
+				if ( callback ) {
+					callback.call( element[ 0 ] );
+				}
+				next();
+			});
+		}
+	};
+});
+
+})( jQuery );
+(function( $, undefined ) {
+
+var mouseHandled = false;
+$( document ).mouseup( function() {
+	mouseHandled = false;
+});
+
+$.widget("ui.mouse", {
+	version: "1.10.4",
+	options: {
+		cancel: "input,textarea,button,select,option",
+		distance: 1,
+		delay: 0
+	},
+	_mouseInit: function() {
+		var that = this;
+
+		this.element
+			.bind("mousedown."+this.widgetName, function(event) {
+				return that._mouseDown(event);
+			})
+			.bind("click."+this.widgetName, function(event) {
+				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
+					$.removeData(event.target, that.widgetName + ".preventClickEvent");
+					event.stopImmediatePropagation();
+					return false;
+				}
+			});
+
+		this.started = false;
+	},
+
+	// TODO: make sure destroying one instance of mouse doesn't mess with
+	// other instances of mouse
+	_mouseDestroy: function() {
+		this.element.unbind("."+this.widgetName);
+		if ( this._mouseMoveDelegate ) {
+			$(document)
+				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
+		}
+	},
+
+	_mouseDown: function(event) {
+		// don't let more than one widget handle mouseStart
+		if( mouseHandled ) { return; }
+
+		// we may have missed mouseup (out of window)
+		(this._mouseStarted && this._mouseUp(event));
+
+		this._mouseDownEvent = event;
+
+		var that = this,
+			btnIsLeft = (event.which === 1),
+			// event.target.nodeName works around a bug in IE 8 with
+			// disabled inputs (#7620)
+			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
+		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
+			return true;
+		}
+
+		this.mouseDelayMet = !this.options.delay;
+		if (!this.mouseDelayMet) {
+			this._mouseDelayTimer = setTimeout(function() {
+				that.mouseDelayMet = true;
+			}, this.options.delay);
+		}
+
+		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
+			this._mouseStarted = (this._mouseStart(event) !== false);
+			if (!this._mouseStarted) {
+				event.preventDefault();
+				return true;
+			}
+		}
+
+		// Click event may never have fired (Gecko & Opera)
+		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
+			$.removeData(event.target, this.widgetName + ".preventClickEvent");
+		}
+
+		// these delegates are required to keep context
+		this._mouseMoveDelegate = function(event) {
+			return that._mouseMove(event);
+		};
+		this._mouseUpDelegate = function(event) {
+			return that._mouseUp(event);
+		};
+		$(document)
+			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);
+
+		event.preventDefault();
+
+		mouseHandled = true;
+		return true;
+	},
+
+	_mouseMove: function(event) {
+		// IE mouseup check - mouseup happened when mouse was out of window
+		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
+			return this._mouseUp(event);
+		}
+
+		if (this._mouseStarted) {
+			this._mouseDrag(event);
+			return event.preventDefault();
+		}
+
+		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
+			this._mouseStarted =
+				(this._mouseStart(this._mouseDownEvent, event) !== false);
+			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
+		}
+
+		return !this._mouseStarted;
+	},
+
+	_mouseUp: function(event) {
+		$(document)
+			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
+
+		if (this._mouseStarted) {
+			this._mouseStarted = false;
+
+			if (event.target === this._mouseDownEvent.target) {
+				$.data(event.target, this.widgetName + ".preventClickEvent", true);
+			}
+
+			this._mouseStop(event);
+		}
+
+		return false;
+	},
+
+	_mouseDistanceMet: function(event) {
+		return (Math.max(
+				Math.abs(this._mouseDownEvent.pageX - event.pageX),
+				Math.abs(this._mouseDownEvent.pageY - event.pageY)
+			) >= this.options.distance
+		);
+	},
+
+	_mouseDelayMet: function(/* event */) {
+		return this.mouseDelayMet;
+	},
+
+	// These are placeholder methods, to be overriden by extending plugin
+	_mouseStart: function(/* event */) {},
+	_mouseDrag: function(/* event */) {},
+	_mouseStop: function(/* event */) {},
+	_mouseCapture: function(/* event */) { return true; }
+});
+
+})(jQuery);
+(function( $, undefined ) {
+
+$.ui = $.ui || {};
+
+var cachedScrollbarWidth,
+	max = Math.max,
+	abs = Math.abs,
+	round = Math.round,
+	rhorizontal = /left|center|right/,
+	rvertical = /top|center|bottom/,
+	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
+	rposition = /^\w+/,
+	rpercent = /%$/,
+	_position = $.fn.position;
+
+function getOffsets( offsets, width, height ) {
+	return [
+		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
+		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
+	];
+}
+
+function parseCss( element, property ) {
+	return parseInt( $.css( element, property ), 10 ) || 0;
+}
+
+function getDimensions( elem ) {
+	var raw = elem[0];
+	if ( raw.nodeType === 9 ) {
+		return {
+			width: elem.width(),
+			height: elem.height(),
+			offset: { top: 0, left: 0 }
+		};
+	}
+	if ( $.isWindow( raw ) ) {
+		return {
+			width: elem.width(),
+			height: elem.height(),
+			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
+		};
+	}
+	if ( raw.preventDefault ) {
+		return {
+			width: 0,
+			height: 0,
+			offset: { top: raw.pageY, left: raw.pageX }
+		};
+	}
+	return {
+		width: elem.outerWidth(),
+		height: elem.outerHeight(),
+		offset: elem.offset()
+	};
+}
+
+$.position = {
+	scrollbarWidth: function() {
+		if ( cachedScrollbarWidth !== undefined ) {
+			return cachedScrollbarWidth;
+		}
+		var w1, w2,
+			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
+			innerDiv = div.children()[0];
+
+		$( "body" ).append( div );
+		w1 = innerDiv.offsetWidth;
+		div.css( "overflow", "scroll" );
+
+		w2 = innerDiv.offsetWidth;
+
+		if ( w1 === w2 ) {
+			w2 = div[0].clientWidth;
+		}
+
+		div.remove();
+
+		return (cachedScrollbarWidth = w1 - w2);
+	},
+	getScrollInfo: function( within ) {
+		var overflowX = within.isWindow || within.isDocument ? "" :
+				within.element.css( "overflow-x" ),
+			overflowY = within.isWindow || within.isDocument ? "" :
+				within.element.css( "overflow-y" ),
+			hasOverflowX = overflowX === "scroll" ||
+				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
+			hasOverflowY = overflowY === "scroll" ||
+				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
+		return {
+			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
+			height: hasOverflowX ? $.position.scrollbarWidth() : 0
+		};
+	},
+	getWithinInfo: function( element ) {
+		var withinElement = $( element || window ),
+			isWindow = $.isWindow( withinElement[0] ),
+			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
+		return {
+			element: withinElement,
+			isWindow: isWindow,
+			isDocument: isDocument,
+			offset: withinElement.offset() || { left: 0, top: 0 },
+			scrollLeft: withinElement.scrollLeft(),
+			scrollTop: withinElement.scrollTop(),
+			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
+			height: isWindow ? withinElement.height() : withinElement.outerHeight()
+		};
+	}
+};
+
+$.fn.position = function( options ) {
+	if ( !options || !options.of ) {
+		return _position.apply( this, arguments );
+	}
+
+	// make a copy, we don't want to modify arguments
+	options = $.extend( {}, options );
+
+	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
+		target = $( options.of ),
+		within = $.position.getWithinInfo( options.within ),
+		scrollInfo = $.position.getScrollInfo( within ),
+		collision = ( options.collision || "flip" ).split( " " ),
+		offsets = {};
+
+	dimensions = getDimensions( target );
+	if ( target[0].preventDefault ) {
+		// force left top to allow flipping
+		options.at = "left top";
+	}
+	targetWidth = dimensions.width;
+	targetHeight = dimensions.height;
+	targetOffset = dimensions.offset;
+	// clone to reuse original targetOffset later
+	basePosition = $.extend( {}, targetOffset );
+
+	// force my and at to have valid horizontal and vertical positions
+	// if a value is missing or invalid, it will be converted to center
+	$.each( [ "my", "at" ], function() {
+		var pos = ( options[ this ] || "" ).split( " " ),
+			horizontalOffset,
+			verticalOffset;
+
+		if ( pos.length === 1) {
+			pos = rhorizontal.test( pos[ 0 ] ) ?
+				pos.concat( [ "center" ] ) :
+				rvertical.test( pos[ 0 ] ) ?
+					[ "center" ].concat( pos ) :
+					[ "center", "center" ];
+		}
+		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
+		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
+
+		// calculate offsets
+		horizontalOffset = roffset.exec( pos[ 0 ] );
+		verticalOffset = roffset.exec( pos[ 1 ] );
+		offsets[ this ] = [
+			horizontalOffset ? horizontalOffset[ 0 ] : 0,
+			verticalOffset ? verticalOffset[ 0 ] : 0
+		];
+
+		// reduce to just the positions without the offsets
+		options[ this ] = [
+			rposition.exec( pos[ 0 ] )[ 0 ],
+			rposition.exec( pos[ 1 ] )[ 0 ]
+		];
+	});
+
+	// normalize collision option
+	if ( collision.length === 1 ) {
+		collision[ 1 ] = collision[ 0 ];
+	}
+
+	if ( options.at[ 0 ] === "right" ) {
+		basePosition.left += targetWidth;
+	} else if ( options.at[ 0 ] === "center" ) {
+		basePosition.left += targetWidth / 2;
+	}
+
+	if ( options.at[ 1 ] === "bottom" ) {
+		basePosition.top += targetHeight;
+	} else if ( options.at[ 1 ] === "center" ) {
+		basePosition.top += targetHeight / 2;
+	}
+
+	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
+	basePosition.left += atOffset[ 0 ];
+	basePosition.top += atOffset[ 1 ];
+
+	return this.each(function() {
+		var collisionPosition, using,
+			elem = $( this ),
+			elemWidth = elem.outerWidth(),
+			elemHeight = elem.outerHeight(),
+			marginLeft = parseCss( this, "marginLeft" ),
+			marginTop = parseCss( this, "marginTop" ),
+			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
+			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
+			position = $.extend( {}, basePosition ),
+			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
+
+		if ( options.my[ 0 ] === "right" ) {
+			position.left -= elemWidth;
+		} else if ( options.my[ 0 ] === "center" ) {
+			position.left -= elemWidth / 2;
+		}
+
+		if ( options.my[ 1 ] === "bottom" ) {
+			position.top -= elemHeight;
+		} else if ( options.my[ 1 ] === "center" ) {
+			position.top -= elemHeight / 2;
+		}
+
+		position.left += myOffset[ 0 ];
+		position.top += myOffset[ 1 ];
+
+		// if the browser doesn't support fractions, then round for consistent results
+		if ( !$.support.offsetFractions ) {
+			position.left = round( position.left );
+			position.top = round( position.top );
+		}
+
+		collisionPosition = {
+			marginLeft: marginLeft,
+			marginTop: marginTop
+		};
+
+		$.each( [ "left", "top" ], function( i, dir ) {
+			if ( $.ui.position[ collision[ i ] ] ) {
+				$.ui.position[ collision[ i ] ][ dir ]( position, {
+					targetWidth: targetWidth,
+					targetHeight: targetHeight,
+					elemWidth: elemWidth,
+					elemHeight: elemHeight,
+					collisionPosition: collisionPosition,
+					collisionWidth: collisionWidth,
+					collisionHeight: collisionHeight,
+					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
+					my: options.my,
+					at: options.at,
+					within: within,
+					elem : elem
+				});
+			}
+		});
+
+		if ( options.using ) {
+			// adds feedback as second argument to using callback, if present
+			using = function( props ) {
+				var left = targetOffset.left - position.left,
+					right = left + targetWidth - elemWidth,
+					top = targetOffset.top - position.top,
+					bottom = top + targetHeight - elemHeight,
+					feedback = {
+						target: {
+							element: target,
+							left: targetOffset.left,
+							top: targetOffset.top,
+							width: targetWidth,
+							height: targetHeight
+						},
+						element: {
+							element: elem,
+							left: position.left,
+							top: position.top,
+							width: elemWidth,
+							height: elemHeight
+						},
+						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
+						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
+					};
+				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
+					feedback.horizontal = "center";
+				}
+				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
+					feedback.vertical = "middle";
+				}
+				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
+					feedback.important = "horizontal";
+				} else {
+					feedback.important = "vertical";
+				}
+				options.using.call( this, props, feedback );
+			};
+		}
+
+		elem.offset( $.extend( position, { using: using } ) );
+	});
+};
+
+$.ui.position = {
+	fit: {
+		left: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
+				outerWidth = within.width,
+				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
+				overLeft = withinOffset - collisionPosLeft,
+				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
+				newOverRight;
+
+			// element is wider than within
+			if ( data.collisionWidth > outerWidth ) {
+				// element is initially over the left side of within
+				if ( overLeft > 0 && overRight <= 0 ) {
+					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
+					position.left += overLeft - newOverRight;
+				// element is initially over right side of within
+				} else if ( overRight > 0 && overLeft <= 0 ) {
+					position.left = withinOffset;
+				// element is initially over both left and right sides of within
+				} else {
+					if ( overLeft > overRight ) {
+						position.left = withinOffset + outerWidth - data.collisionWidth;
+					} else {
+						position.left = withinOffset;
+					}
+				}
+			// too far left -> align with left edge
+			} else if ( overLeft > 0 ) {
+				position.left += overLeft;
+			// too far right -> align with right edge
+			} else if ( overRight > 0 ) {
+				position.left -= overRight;
+			// adjust based on position and margin
+			} else {
+				position.left = max( position.left - collisionPosLeft, position.left );
+			}
+		},
+		top: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
+				outerHeight = data.within.height,
+				collisionPosTop = position.top - data.collisionPosition.marginTop,
+				overTop = withinOffset - collisionPosTop,
+				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
+				newOverBottom;
+
+			// element is taller than within
+			if ( data.collisionHeight > outerHeight ) {
+				// element is initially over the top of within
+				if ( overTop > 0 && overBottom <= 0 ) {
+					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
+					position.top += overTop - newOverBottom;
+				// element is initially over bottom of within
+				} else if ( overBottom > 0 && overTop <= 0 ) {
+					position.top = withinOffset;
+				// element is initially over both top and bottom of within
+				} else {
+					if ( overTop > overBottom ) {
+						position.top = withinOffset + outerHeight - data.collisionHeight;
+					} else {
+						position.top = withinOffset;
+					}
+				}
+			// too far up -> align with top
+			} else if ( overTop > 0 ) {
+				position.top += overTop;
+			// too far down -> align with bottom edge
+			} else if ( overBottom > 0 ) {
+				position.top -= overBottom;
+			// adjust based on position and margin
+			} else {
+				position.top = max( position.top - collisionPosTop, position.top );
+			}
+		}
+	},
+	flip: {
+		left: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.offset.left + within.scrollLeft,
+				outerWidth = within.width,
+				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
+				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
+				overLeft = collisionPosLeft - offsetLeft,
+				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
+				myOffset = data.my[ 0 ] === "left" ?
+					-data.elemWidth :
+					data.my[ 0 ] === "right" ?
+						data.elemWidth :
+						0,
+				atOffset = data.at[ 0 ] === "left" ?
+					data.targetWidth :
+					data.at[ 0 ] === "right" ?
+						-data.targetWidth :
+						0,
+				offset = -2 * data.offset[ 0 ],
+				newOverRight,
+				newOverLeft;
+
+			if ( overLeft < 0 ) {
+				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
+				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
+					position.left += myOffset + atOffset + offset;
+				}
+			}
+			else if ( overRight > 0 ) {
+				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
+				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
+					position.left += myOffset + atOffset + offset;
+				}
+			}
+		},
+		top: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.offset.top + within.scrollTop,
+				outerHeight = within.height,
+				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
+				collisionPosTop = position.top - data.collisionPosition.marginTop,
+				overTop = collisionPosTop - offsetTop,
+				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
+				top = data.my[ 1 ] === "top",
+				myOffset = top ?
+					-data.elemHeight :
+					data.my[ 1 ] === "bottom" ?
+						data.elemHeight :
+						0,
+				atOffset = data.at[ 1 ] === "top" ?
+					data.targetHeight :
+					data.at[ 1 ] === "bottom" ?
+						-data.targetHeight :
+						0,
+				offset = -2 * data.offset[ 1 ],
+				newOverTop,
+				newOverBottom;
+			if ( overTop < 0 ) {
+				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
+				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
+					position.top += myOffset + atOffset + offset;
+				}
+			}
+			else if ( overBottom > 0 ) {
+				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
+				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
+					position.top += myOffset + atOffset + offset;
+				}
+			}
+		}
+	},
+	flipfit: {
+		left: function() {
+			$.ui.position.flip.left.apply( this, arguments );
+			$.ui.position.fit.left.apply( this, arguments );
+		},
+		top: function() {
+			$.ui.position.flip.top.apply( this, arguments );
+			$.ui.position.fit.top.apply( this, arguments );
+		}
+	}
+};
+
+// fraction support test
+(function () {
+	var testElement, testElementParent, testElementStyle, offsetLeft, i,
+		body = document.getElementsByTagName( "body" )[ 0 ],
+		div = document.createElement( "div" );
+
+	//Create a "fake body" for testing based on method used in jQuery.support
+	testElement = document.createElement( body ? "div" : "body" );
+	testElementStyle = {
+		visibility: "hidden",
+		width: 0,
+		height: 0,
+		border: 0,
+		margin: 0,
+		background: "none"
+	};
+	if ( body ) {
+		$.extend( testElementStyle, {
+			position: "absolute",
+			left: "-1000px",
+			top: "-1000px"
+		});
+	}
+	for ( i in testElementStyle ) {
+		testElement.style[ i ] = testElementStyle[ i ];
+	}
+	testElement.appendChild( div );
+	testElementParent = body || document.documentElement;
+	testElementParent.insertBefore( testElement, testElementParent.firstChild );
+
+	div.style.cssText = "position: absolute; left: 10.7432222px;";
+
+	offsetLeft = $( div ).offset().left;
+	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
+
+	testElement.innerHTML = "";
+	testElementParent.removeChild( testElement );
+})();
+
+}( jQuery ) );
+(function( $, undefined ) {
+
+function isOverAxis( x, reference, size ) {
+	return ( x > reference ) && ( x < ( reference + size ) );
+}
+
+function isFloating(item) {
+	return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
+}
+
+$.widget("ui.sortable", $.ui.mouse, {
+	version: "1.10.4",
+	widgetEventPrefix: "sort",
+	ready: false,
+	options: {
+		appendTo: "parent",
+		axis: false,
+		connectWith: false,
+		containment: false,
+		cursor: "auto",
+		cursorAt: false,
+		dropOnEmpty: true,
+		forcePlaceholderSize: false,
+		forceHelperSize: false,
+		grid: false,
+		handle: false,
+		helper: "original",
+		items: "> *",
+		opacity: false,
+		placeholder: false,
+		revert: false,
+		scroll: true,
+		scrollSensitivity: 20,
+		scrollSpeed: 20,
+		scope: "default",
+		tolerance: "intersect",
+		zIndex: 1000,
+
+		// callbacks
+		activate: null,
+		beforeStop: null,
+		change: null,
+		deactivate: null,
+		out: null,
+		over: null,
+		receive: null,
+		remove: null,
+		sort: null,
+		start: null,
+		stop: null,
+		update: null
+	},
+	_create: function() {
+
+		var o = this.options;
+		this.containerCache = {};
+		this.element.addClass("ui-sortable");
+
+		//Get the items
+		this.refresh();
+
+		//Let's determine if the items are being displayed horizontally
+		this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
+
+		//Let's determine the parent's offset
+		this.offset = this.element.offset();
+
+		//Initialize mouse events for interaction
+		this._mouseInit();
+
+		//We're ready to go
+		this.ready = true;
+
+	},
+
+	_destroy: function() {
+		this.element
+			.removeClass("ui-sortable ui-sortable-disabled");
+		this._mouseDestroy();
+
+		for ( var i = this.items.length - 1; i >= 0; i-- ) {
+			this.items[i].item.removeData(this.widgetName + "-item");
+		}
+
+		return this;
+	},
+
+	_setOption: function(key, value){
+		if ( key === "disabled" ) {
+			this.options[ key ] = value;
+
+			this.widget().toggleClass( "ui-sortable-disabled", !!value );
+		} else {
+			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
+			$.Widget.prototype._setOption.apply(this, arguments);
+		}
+	},
+
+	_mouseCapture: function(event, overrideHandle) {
+		var currentItem = null,
+			validHandle = false,
+			that = this;
+
+		if (this.reverting) {
+			return false;
+		}
+
+		if(this.options.disabled || this.options.type === "static") {
+			return false;
+		}
+
+		//We have to refresh the items data once first
+		this._refreshItems(event);
+
+		//Find out if the clicked node (or one of its parents) is a actual item in this.items
+		$(event.target).parents().each(function() {
+			if($.data(this, that.widgetName + "-item") === that) {
+				currentItem = $(this);
+				return false;
+			}
+		});
+		if($.data(event.target, that.widgetName + "-item") === that) {
+			currentItem = $(event.target);
+		}
+
+		if(!currentItem) {
+			return false;
+		}
+		if(this.options.handle && !overrideHandle) {
+			$(this.options.handle, currentItem).find("*").addBack().each(function() {
+				if(this === event.target) {
+					validHandle = true;
+				}
+			});
+			if(!validHandle) {
+				return false;
+			}
+		}
+
+		this.currentItem = currentItem;
+		this._removeCurrentsFromItems();
+		return true;
+
+	},
+
+	_mouseStart: function(event, overrideHandle, noActivation) {
+
+		var i, body,
+			o = this.options;
+
+		this.currentContainer = this;
+
+		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
+		this.refreshPositions();
+
+		//Create and append the visible helper
+		this.helper = this._createHelper(event);
+
+		//Cache the helper size
+		this._cacheHelperProportions();
+
+		/*
+		 * - Position generation -
+		 * This block generates everything position related - it's the core of draggables.
+		 */
+
+		//Cache the margins of the original element
+		this._cacheMargins();
+
+		//Get the next scrolling parent
+		this.scrollParent = this.helper.scrollParent();
+
+		//The element's absolute position on the page minus margins
+		this.offset = this.currentItem.offset();
+		this.offset = {
+			top: this.offset.top - this.margins.top,
+			left: this.offset.left - this.margins.left
+		};
+
+		$.extend(this.offset, {
+			click: { //Where the click happened, relative to the element
+				left: event.pageX - this.offset.left,
+				top: event.pageY - this.offset.top
+			},
+			parent: this._getParentOffset(),
+			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
+		});
+
+		// Only after we got the offset, we can change the helper's position to absolute
+		// TODO: Still need to figure out a way to make relative sorting possible
+		this.helper.css("position", "absolute");
+		this.cssPosition = this.helper.css("position");
+
+		//Generate the original position
+		this.originalPosition = this._generatePosition(event);
+		this.originalPageX = event.pageX;
+		this.originalPageY = event.pageY;
+
+		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
+		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
+
+		//Cache the former DOM position
+		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
+
+		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
+		if(this.helper[0] !== this.currentItem[0]) {
+			this.currentItem.hide();
+		}
+
+		//Create the placeholder
+		this._createPlaceholder();
+
+		//Set a containment if given in the options
+		if(o.containment) {
+			this._setContainment();
+		}
+
+		if( o.cursor && o.cursor !== "auto" ) { // cursor option
+			body = this.document.find( "body" );
+
+			// support: IE
+			this.storedCursor = body.css( "cursor" );
+			body.css( "cursor", o.cursor );
+
+			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
+		}
+
+		if(o.opacity) { // opacity option
+			if (this.helper.css("opacity")) {
+				this._storedOpacity = this.helper.css("opacity");
+			}
+			this.helper.css("opacity", o.opacity);
+		}
+
+		if(o.zIndex) { // zIndex option
+			if (this.helper.css("zIndex")) {
+				this._storedZIndex = this.helper.css("zIndex");
+			}
+			this.helper.css("zIndex", o.zIndex);
+		}
+
+		//Prepare scrolling
+		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
+			this.overflowOffset = this.scrollParent.offset();
+		}
+
+		//Call callbacks
+		this._trigger("start", event, this._uiHash());
+
+		//Recache the helper size
+		if(!this._preserveHelperProportions) {
+			this._cacheHelperProportions();
+		}
+
+
+		//Post "activate" events to possible containers
+		if( !noActivation ) {
+			for ( i = this.containers.length - 1; i >= 0; i-- ) {
+				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
+			}
+		}
+
+		//Prepare possible droppables
+		if($.ui.ddmanager) {
+			$.ui.ddmanager.current = this;
+		}
+
+		if ($.ui.ddmanager && !o.dropBehaviour) {
+			$.ui.ddmanager.prepareOffsets(this, event);
+		}
+
+		this.dragging = true;
+
+		this.helper.addClass("ui-sortable-helper");
+		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
+		return true;
+
+	},
+
+	_mouseDrag: function(event) {
+		var i, item, itemElement, intersection,
+			o = this.options,
+			scrolled = false;
+
+		//Compute the helpers position
+		this.position = this._generatePosition(event);
+		this.positionAbs = this._convertPositionTo("absolute");
+
+		if (!this.lastPositionAbs) {
+			this.lastPositionAbs = this.positionAbs;
+		}
+
+		//Do scrolling
+		if(this.options.scroll) {
+			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
+
+				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
+					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
+				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
+					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
+				}
+
+				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
+					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
+				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
+					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
+				}
+
+			} else {
+
+				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
+					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
+				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
+					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
+				}
+
+				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
+					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
+				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
+					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
+				}
+
+			}
+
+			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
+				$.ui.ddmanager.prepareOffsets(this, event);
+			}
+		}
+
+		//Regenerate the absolute position used for position checks
+		this.positionAbs = this._convertPositionTo("absolute");
+
+		//Set the helper position
+		if(!this.options.axis || this.options.axis !== "y") {
+			this.helper[0].style.left = this.position.left+"px";
+		}
+		if(!this.options.axis || this.options.axis !== "x") {
+			this.helper[0].style.top = this.position.top+"px";
+		}
+
+		//Rearrange
+		for (i = this.items.length - 1; i >= 0; i--) {
+
+			//Cache variables and intersection, continue if no intersection
+			item = this.items[i];
+			itemElement = item.item[0];
+			intersection = this._intersectsWithPointer(item);
+			if (!intersection) {
+				continue;
+			}
+
+			// Only put the placeholder inside the current Container, skip all
+			// items from other containers. This works because when moving
+			// an item from one container to another the
+			// currentContainer is switched before the placeholder is moved.
+			//
+			// Without this, moving items in "sub-sortables" can cause
+			// the placeholder to jitter beetween the outer and inner container.
+			if (item.instance !== this.currentContainer) {
+				continue;
+			}
+
+			// cannot intersect with itself
+			// no useless actions that have been done before
+			// no action if the item moved is the parent of the item checked
+			if (itemElement !== this.currentItem[0] &&
+				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
+				!$.contains(this.placeholder[0], itemElement) &&
+				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
+			) {
+
+				this.direction = intersection === 1 ? "down" : "up";
+
+				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
+					this._rearrange(event, item);
+				} else {
+					break;
+				}
+
+				this._trigger("change", event, this._uiHash());
+				break;
+			}
+		}
+
+		//Post events to containers
+		this._contactContainers(event);
+
+		//Interconnect with droppables
+		if($.ui.ddmanager) {
+			$.ui.ddmanager.drag(this, event);
+		}
+
+		//Call callbacks
+		this._trigger("sort", event, this._uiHash());
+
+		this.lastPositionAbs = this.positionAbs;
+		return false;
+
+	},
+
+	_mouseStop: function(event, noPropagation) {
+
+		if(!event) {
+			return;
+		}
+
+		//If we are using droppables, inform the manager about the drop
+		if ($.ui.ddmanager && !this.options.dropBehaviour) {
+			$.ui.ddmanager.drop(this, event);
+		}
+
+		if(this.options.revert) {
+			var that = this,
+				cur = this.placeholder.offset(),
+				axis = this.options.axis,
+				animation = {};
+
+			if ( !axis || axis === "x" ) {
+				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
+			}
+			if ( !axis || axis === "y" ) {
+				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
+			}
+			this.reverting = true;
+			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
+				that._clear(event);
+			});
+		} else {
+			this._clear(event, noPropagation);
+		}
+
+		return false;
+
+	},
+
+	cancel: function() {
+
+		if(this.dragging) {
+
+			this._mouseUp({ target: null });
+
+			if(this.options.helper === "original") {
+				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
+			} else {
+				this.currentItem.show();
+			}
+
+			//Post deactivating events to containers
+			for (var i = this.containers.length - 1; i >= 0; i--){
+				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
+				if(this.containers[i].containerCache.over) {
+					this.containers[i]._trigger("out", null, this._uiHash(this));
+					this.containers[i].containerCache.over = 0;
+				}
+			}
+
+		}
+
+		if (this.placeholder) {
+			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
+			if(this.placeholder[0].parentNode) {
+				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
+			}
+			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
+				this.helper.remove();
+			}
+
+			$.extend(this, {
+				helper: null,
+				dragging: false,
+				reverting: false,
+				_noFinalSort: null
+			});
+
+			if(this.domPosition.prev) {
+				$(this.domPosition.prev).after(this.currentItem);
+			} else {
+				$(this.domPosition.parent).prepend(this.currentItem);
+			}
+		}
+
+		return this;
+
+	},
+
+	serialize: function(o) {
+
+		var items = this._getItemsAsjQuery(o && o.connected),
+			str = [];
+		o = o || {};
+
+		$(items).each(function() {
+			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
+			if (res) {
+				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
+			}
+		});
+
+		if(!str.length && o.key) {
+			str.push(o.key + "=");
+		}
+
+		return str.join("&");
+
+	},
+
+	toArray: function(o) {
+
+		var items = this._getItemsAsjQuery(o && o.connected),
+			ret = [];
+
+		o = o || {};
+
+		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
+		return ret;
+
+	},
+
+	/* Be careful with the following core functions */
+	_intersectsWith: function(item) {
+
+		var x1 = this.positionAbs.left,
+			x2 = x1 + this.helperProportions.width,
+			y1 = this.positionAbs.top,
+			y2 = y1 + this.helperProportions.height,
+			l = item.left,
+			r = l + item.width,
+			t = item.top,
+			b = t + item.height,
+			dyClick = this.offset.click.top,
+			dxClick = this.offset.click.left,
+			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
+			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
+			isOverElement = isOverElementHeight && isOverElementWidth;
+
+		if ( this.options.tolerance === "pointer" ||
+			this.options.forcePointerForContainers ||
+			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
+		) {
+			return isOverElement;
+		} else {
+
+			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
+				x2 - (this.helperProportions.width / 2) < r && // Left Half
+				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
+				y2 - (this.helperProportions.height / 2) < b ); // Top Half
+
+		}
+	},
+
+	_intersectsWithPointer: function(item) {
+
+		var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
+			isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
+			isOverElement = isOverElementHeight && isOverElementWidth,
+			verticalDirection = this._getDragVerticalDirection(),
+			horizontalDirection = this._getDragHorizontalDirection();
+
+		if (!isOverElement) {
+			return false;
+		}
+
+		return this.floating ?
+			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
+			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
+
+	},
+
+	_intersectsWithSides: function(item) {
+
+		var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
+			isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
+			verticalDirection = this._getDragVerticalDirection(),
+			horizontalDirection = this._getDragHorizontalDirection();
+
+		if (this.floating && horizontalDirection) {
+			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
+		} else {
+			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
+		}
+
+	},
+
+	_getDragVerticalDirection: function() {
+		var delta = this.positionAbs.top - this.lastPositionAbs.top;
+		return delta !== 0 && (delta > 0 ? "down" : "up");
+	},
+
+	_getDragHorizontalDirection: function() {
+		var delta = this.positionAbs.left - this.lastPositionAbs.left;
+		return delta !== 0 && (delta > 0 ? "right" : "left");
+	},
+
+	refresh: function(event) {
+		this._refreshItems(event);
+		this.refreshPositions();
+		return this;
+	},
+
+	_connectWith: function() {
+		var options = this.options;
+		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
+	},
+
+	_getItemsAsjQuery: function(connected) {
+
+		var i, j, cur, inst,
+			items = [],
+			queries = [],
+			connectWith = this._connectWith();
+
+		if(connectWith && connected) {
+			for (i = connectWith.length - 1; i >= 0; i--){
+				cur = $(connectWith[i]);
+				for ( j = cur.length - 1; j >= 0; j--){
+					inst = $.data(cur[j], this.widgetFullName);
+					if(inst && inst !== this && !inst.options.disabled) {
+						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
+					}
+				}
+			}
+		}
+
+		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
+
+		function addItems() {
+			items.push( this );
+		}
+		for (i = queries.length - 1; i >= 0; i--){
+			queries[i][0].each( addItems );
+		}
+
+		return $(items);
+
+	},
+
+	_removeCurrentsFromItems: function() {
+
+		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
+
+		this.items = $.grep(this.items, function (item) {
+			for (var j=0; j < list.length; j++) {
+				if(list[j] === item.item[0]) {
+					return false;
+				}
+			}
+			return true;
+		});
+
+	},
+
+	_refreshItems: function(event) {
+
+		this.items = [];
+		this.containers = [this];
+
+		var i, j, cur, inst, targetData, _queries, item, queriesLength,
+			items = this.items,
+			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
+			connectWith = this._connectWith();
+
+		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
+			for (i = connectWith.length - 1; i >= 0; i--){
+				cur = $(connectWith[i]);
+				for (j = cur.length - 1; j >= 0; j--){
+					inst = $.data(cur[j], this.widgetFullName);
+					if(inst && inst !== this && !inst.options.disabled) {
+						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
+						this.containers.push(inst);
+					}
+				}
+			}
+		}
+
+		for (i = queries.length - 1; i >= 0; i--) {
+			targetData = queries[i][1];
+			_queries = queries[i][0];
+
+			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
+				item = $(_queries[j]);
+
+				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
+
+				items.push({
+					item: item,
+					instance: targetData,
+					width: 0, height: 0,
+					left: 0, top: 0
+				});
+			}
+		}
+
+	},
+
+	refreshPositions: function(fast) {
+
+		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
+		if(this.offsetParent && this.helper) {
+			this.offset.parent = this._getParentOffset();
+		}
+
+		var i, item, t, p;
+
+		for (i = this.items.length - 1; i >= 0; i--){
+			item = this.items[i];
+
+			//We ignore calculating positions of all connected containers when we're not over them
+			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
+				continue;
+			}
+
+			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
+
+			if (!fast) {
+				item.width = t.outerWidth();
+				item.height = t.outerHeight();
+			}
+
+			p = t.offset();
+			item.left = p.left;
+			item.top = p.top;
+		}
+
+		if(this.options.custom && this.options.custom.refreshContainers) {
+			this.options.custom.refreshContainers.call(this);
+		} else {
+			for (i = this.containers.length - 1; i >= 0; i--){
+				p = this.containers[i].element.offset();
+				this.containers[i].containerCache.left = p.left;
+				this.containers[i].containerCache.top = p.top;
+				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
+				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
+			}
+		}
+
+		return this;
+	},
+
+	_createPlaceholder: function(that) {
+		that = that || this;
+		var className,
+			o = that.options;
+
+		if(!o.placeholder || o.placeholder.constructor === String) {
+			className = o.placeholder;
+			o.placeholder = {
+				element: function() {
+
+					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
+						element = $( "<" + nodeName + ">", that.document[0] )
+							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
+							.removeClass("ui-sortable-helper");
+
+					if ( nodeName === "tr" ) {
+						that.currentItem.children().each(function() {
+							$( "<td>&#160;</td>", that.document[0] )
+								.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
+								.appendTo( element );
+						});
+					} else if ( nodeName === "img" ) {
+						element.attr( "src", that.currentItem.attr( "src" ) );
+					}
+
+					if ( !className ) {
+						element.css( "visibility", "hidden" );
+					}
+
+					return element;
+				},
+				update: function(container, p) {
+
+					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
+					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
+					if(className && !o.forcePlaceholderSize) {
+						return;
+					}
+
+					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
+					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
+					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
+				}
+			};
+		}
+
+		//Create the placeholder
+		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
+
+		//Append it after the actual current item
+		that.currentItem.after(that.placeholder);
+
+		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
+		o.placeholder.update(that, that.placeholder);
+
+	},
+
+	_contactContainers: function(event) {
+		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
+			innermostContainer = null,
+			innermostIndex = null;
+
+		// get innermost container that intersects with item
+		for (i = this.containers.length - 1; i >= 0; i--) {
+
+			// never consider a container that's located within the item itself
+			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
+				continue;
+			}
+
+			if(this._intersectsWith(this.containers[i].containerCache)) {
+
+				// if we've already found a container and it's more "inner" than this, then continue
+				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
+					continue;
+				}
+
+				innermostContainer = this.containers[i];
+				innermostIndex = i;
+
+			} else {
+				// container doesn't intersect. trigger "out" event if necessary
+				if(this.containers[i].containerCache.over) {
+					this.containers[i]._trigger("out", event, this._uiHash(this));
+					this.containers[i].containerCache.over = 0;
+				}
+			}
+
+		}
+
+		// if no intersecting containers found, return
+		if(!innermostContainer) {
+			return;
+		}
+
+		// move the item into the container if it's not there already
+		if(this.containers.length === 1) {
+			if (!this.containers[innermostIndex].containerCache.over) {
+				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
+				this.containers[innermostIndex].containerCache.over = 1;
+			}
+		} else {
+
+			//When entering a new container, we will find the item with the least distance and append our item near it
+			dist = 10000;
+			itemWithLeastDistance = null;
+			floating = innermostContainer.floating || isFloating(this.currentItem);
+			posProperty = floating ? "left" : "top";
+			sizeProperty = floating ? "width" : "height";
+			base = this.positionAbs[posProperty] + this.offset.click[posProperty];
+			for (j = this.items.length - 1; j >= 0; j--) {
+				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
+					continue;
+				}
+				if(this.items[j].item[0] === this.currentItem[0]) {
+					continue;
+				}
+				if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
+					continue;
+				}
+				cur = this.items[j].item.offset()[posProperty];
+				nearBottom = false;
+				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
+					nearBottom = true;
+					cur += this.items[j][sizeProperty];
+				}
+
+				if(Math.abs(cur - base) < dist) {
+					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
+					this.direction = nearBottom ? "up": "down";
+				}
+			}
+
+			//Check if dropOnEmpty is enabled
+			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
+				return;
+			}
+
+			if(this.currentContainer === this.containers[innermostIndex]) {
+				return;
+			}
+
+			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
+			this._trigger("change", event, this._uiHash());
+			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
+			this.currentContainer = this.containers[innermostIndex];
+
+			//Update the placeholder
+			this.options.placeholder.update(this.currentContainer, this.placeholder);
+
+			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
+			this.containers[innermostIndex].containerCache.over = 1;
+		}
+
+
+	},
+
+	_createHelper: function(event) {
+
+		var o = this.options,
+			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
+
+		//Add the helper to the DOM if that didn't happen already
+		if(!helper.parents("body").length) {
+			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
+		}
+
+		if(helper[0] === this.currentItem[0]) {
+			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
+		}
+
+		if(!helper[0].style.width || o.forceHelperSize) {
+			helper.width(this.currentItem.width());
+		}
+		if(!helper[0].style.height || o.forceHelperSize) {
+			helper.height(this.currentItem.height());
+		}
+
+		return helper;
+
+	},
+
+	_adjustOffsetFromHelper: function(obj) {
+		if (typeof obj === "string") {
+			obj = obj.split(" ");
+		}
+		if ($.isArray(obj)) {
+			obj = {left: +obj[0], top: +obj[1] || 0};
+		}
+		if ("left" in obj) {
+			this.offset.click.left = obj.left + this.margins.left;
+		}
+		if ("right" in obj) {
+			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
+		}
+		if ("top" in obj) {
+			this.offset.click.top = obj.top + this.margins.top;
+		}
+		if ("bottom" in obj) {
+			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
+		}
+	},
+
+	_getParentOffset: function() {
+
+
+		//Get the offsetParent and cache its position
+		this.offsetParent = this.helper.offsetParent();
+		var po = this.offsetParent.offset();
+
+		// This is a special case where we need to modify a offset calculated on start, since the following happened:
+		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
+		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
+		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
+		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
+			po.left += this.scrollParent.scrollLeft();
+			po.top += this.scrollParent.scrollTop();
+		}
+
+		// This needs to be actually done for all browsers, since pageX/pageY includes this information
+		// with an ugly IE fix
+		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
+			po = { top: 0, left: 0 };
+		}
+
+		return {
+			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
+			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
+		};
+
+	},
+
+	_getRelativeOffset: function() {
+
+		if(this.cssPosition === "relative") {
+			var p = this.currentItem.position();
+			return {
+				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
+				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
+			};
+		} else {
+			return { top: 0, left: 0 };
+		}
+
+	},
+
+	_cacheMargins: function() {
+		this.margins = {
+			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
+			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
+		};
+	},
+
+	_cacheHelperProportions: function() {
+		this.helperProportions = {
+			width: this.helper.outerWidth(),
+			height: this.helper.outerHeight()
+		};
+	},
+
+	_setContainment: function() {
+
+		var ce, co, over,
+			o = this.options;
+		if(o.containment === "parent") {
+			o.containment = this.helper[0].parentNode;
+		}
+		if(o.containment === "document" || o.containment === "window") {
+			this.containment = [
+				0 - this.offset.relative.left - this.offset.parent.left,
+				0 - this.offset.relative.top - this.offset.parent.top,
+				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
+				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
+			];
+		}
+
+		if(!(/^(document|window|parent)$/).test(o.containment)) {
+			ce = $(o.containment)[0];
+			co = $(o.containment).offset();
+			over = ($(ce).css("overflow") !== "hidden");
+
+			this.containment = [
+				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
+				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
+				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
+				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
+			];
+		}
+
+	},
+
+	_convertPositionTo: function(d, pos) {
+
+		if(!pos) {
+			pos = this.position;
+		}
+		var mod = d === "absolute" ? 1 : -1,
+			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
+			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
+
+		return {
+			top: (
+				pos.top	+																// The absolute mouse position
+				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
+			),
+			left: (
+				pos.left +																// The absolute mouse position
+				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
+			)
+		};
+
+	},
+
+	_generatePosition: function(event) {
+
+		var top, left,
+			o = this.options,
+			pageX = event.pageX,
+			pageY = event.pageY,
+			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
+
+		// This is another very weird special case that only happens for relative elements:
+		// 1. If the css position is relative
+		// 2. and the scroll parent is the document or similar to the offset parent
+		// we have to refresh the relative offset during the scroll so there are no jumps
+		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
+			this.offset.relative = this._getRelativeOffset();
+		}
+
+		/*
+		 * - Position constraining -
+		 * Constrain the position to a mix of grid, containment.
+		 */
+
+		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
+
+			if(this.containment) {
+				if(event.pageX - this.offset.click.left < this.containment[0]) {
+					pageX = this.containment[0] + this.offset.click.left;
+				}
+				if(event.pageY - this.offset.click.top < this.containment[1]) {
+					pageY = this.containment[1] + this.offset.click.top;
+				}
+				if(event.pageX - this.offset.click.left > this.containment[2]) {
+					pageX = this.containment[2] + this.offset.click.left;
+				}
+				if(event.pageY - this.offset.click.top > this.containment[3]) {
+					pageY = this.containment[3] + this.offset.click.top;
+				}
+			}
+
+			if(o.grid) {
+				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
+				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
+
+				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
+				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
+			}
+
+		}
+
+		return {
+			top: (
+				pageY -																// The absolute mouse position
+				this.offset.click.top -													// Click offset (relative to the element)
+				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
+			),
+			left: (
+				pageX -																// The absolute mouse position
+				this.offset.click.left -												// Click offset (relative to the element)
+				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
+			)
+		};
+
+	},
+
+	_rearrange: function(event, i, a, hardRefresh) {
+
+		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
+
+		//Various things done here to improve the performance:
+		// 1. we create a setTimeout, that calls refreshPositions
+		// 2. on the instance, we have a counter variable, that get's higher after every append
+		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
+		// 4. this lets only the last addition to the timeout stack through
+		this.counter = this.counter ? ++this.counter : 1;
+		var counter = this.counter;
+
+		this._delay(function() {
+			if(counter === this.counter) {
+				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
+			}
+		});
+
+	},
+
+	_clear: function(event, noPropagation) {
+
+		this.reverting = false;
+		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
+		// everything else normalized again
+		var i,
+			delayedTriggers = [];
+
+		// We first have to update the dom position of the actual currentItem
+		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
+		if(!this._noFinalSort && this.currentItem.parent().length) {
+			this.placeholder.before(this.currentItem);
+		}
+		this._noFinalSort = null;
+
+		if(this.helper[0] === this.currentItem[0]) {
+			for(i in this._storedCSS) {
+				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
+					this._storedCSS[i] = "";
+				}
+			}
+			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
+		} else {
+			this.currentItem.show();
+		}
+
+		if(this.fromOutside && !noPropagation) {
+			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
+		}
+		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
+			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
+		}
+
+		// Check if the items Container has Changed and trigger appropriate
+		// events.
+		if (this !== this.currentContainer) {
+			if(!noPropagation) {
+				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
+				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
+				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
+			}
+		}
+
+
+		//Post events to containers
+		function delayEvent( type, instance, container ) {
+			return function( event ) {
+				container._trigger( type, event, instance._uiHash( instance ) );
+			};
+		}
+		for (i = this.containers.length - 1; i >= 0; i--){
+			if (!noPropagation) {
+				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
+			}
+			if(this.containers[i].containerCache.over) {
+				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
+				this.containers[i].containerCache.over = 0;
+			}
+		}
+
+		//Do what was originally in plugins
+		if ( this.storedCursor ) {
+			this.document.find( "body" ).css( "cursor", this.storedCursor );
+			this.storedStylesheet.remove();
+		}
+		if(this._storedOpacity) {
+			this.helper.css("opacity", this._storedOpacity);
+		}
+		if(this._storedZIndex) {
+			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
+		}
+
+		this.dragging = false;
+		if(this.cancelHelperRemoval) {
+			if(!noPropagation) {
+				this._trigger("beforeStop", event, this._uiHash());
+				for (i=0; i < delayedTriggers.length; i++) {
+					delayedTriggers[i].call(this, event);
+				} //Trigger all delayed events
+				this._trigger("stop", event, this._uiHash());
+			}
+
+			this.fromOutside = false;
+			return false;
+		}
+
+		if(!noPropagation) {
+			this._trigger("beforeStop", event, this._uiHash());
+		}
+
+		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
+		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
+
+		if(this.helper[0] !== this.currentItem[0]) {
+			this.helper.remove();
+		}
+		this.helper = null;
+
+		if(!noPropagation) {
+			for (i=0; i < delayedTriggers.length; i++) {
+				delayedTriggers[i].call(this, event);
+			} //Trigger all delayed events
+			this._trigger("stop", event, this._uiHash());
+		}
+
+		this.fromOutside = false;
+		return true;
+
+	},
+
+	_trigger: function() {
+		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
+			this.cancel();
+		}
+	},
+
+	_uiHash: function(_inst) {
+		var inst = _inst || this;
+		return {
+			helper: inst.helper,
+			placeholder: inst.placeholder || $([]),
+			position: inst.position,
+			originalPosition: inst.originalPosition,
+			offset: inst.positionAbs,
+			item: inst.currentItem,
+			sender: _inst ? _inst.element : null
+		};
+	}
+
+});
+
+})(jQuery);
diff --git a/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js
new file mode 100644
index 0000000000..1f86518b67
--- /dev/null
+++ b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js
@@ -0,0 +1,6 @@
+/*! jQuery UI - v1.10.4 - 2014-06-27
+* http://jqueryui.com
+* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.sortable.js
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+(function(e,t){function i(t,i){var a,n,o,r=t.nodeName.toLowerCase();return"area"===r?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(o=e("img[usemap=#"+n+"]")[0],!!o&&s(o)):!1):(/input|select|textarea|button|object/.test(r)?!t.disabled:"a"===r?t.href||i:i)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var a=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var s,a,n=e(this[0]);n.length&&n[0]!==document;){if(s=n.css("position"),("absolute"===s||"relative"===s||"fixed"===s)&&(a=parseInt(n.css("zIndex"),10),!isNaN(a)&&0!==a))return a;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var s=e.attr(t,"tabindex"),a=isNaN(s);return(a||s>=0)&&i(t,!a)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,s){function a(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===s?["Left","Right"]:["Top","Bottom"],o=s.toLowerCase(),r={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+s]=function(i){return i===t?r["inner"+s].call(this):this.each(function(){e(this).css(o,a(this,i)+"px")})},e.fn["outer"+s]=function(t,i){return"number"!=typeof t?r["outer"+s].call(this,t):this.each(function(){e(this).css(o,a(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i){var s,a=e.plugins[t];if(a&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(s=0;a.length>s;s++)e.options[a[s][0]]&&a[s][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)}})})(jQuery);(function(e,t){var i=0,s=Array.prototype.slice,a=e.cleanData;e.cleanData=function(t){for(var i,s=0;null!=(i=t[s]);s++)try{e(i).triggerHandler("remove")}catch(n){}a(t)},e.widget=function(i,s,a){var n,r,o,h,l={},u=i.split(".")[0];i=i.split(".")[1],n=u+"-"+i,a||(a=s,s=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[u]=e[u]||{},r=e[u][i],o=e[u][i]=function(e,i){return this._createWidget?(arguments.length&&this._createWidget(e,i),t):new o(e,i)},e.extend(o,r,{version:a.version,_proto:e.extend({},a),_childConstructors:[]}),h=new s,h.options=e.widget.extend({},h.options),e.each(a,function(i,a){return e.isFunction(a)?(l[i]=function(){var e=function(){return s.prototype[i].apply(this,arguments)},t=function(e){return s.prototype[i].apply(this,e)};return function(){var i,s=this._super,n=this._superApply;return this._super=e,this._superApply=t,i=a.apply(this,arguments),this._super=s,this._superApply=n,i}}(),t):(l[i]=a,t)}),o.prototype=e.widget.extend(h,{widgetEventPrefix:r?h.widgetEventPrefix||i:i},l,{constructor:o,namespace:u,widgetName:i,widgetFullName:n}),r?(e.each(r._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete r._childConstructors):s._childConstructors.push(o),e.widget.bridge(i,o)},e.widget.extend=function(i){for(var a,n,r=s.call(arguments,1),o=0,h=r.length;h>o;o++)for(a in r[o])n=r[o][a],r[o].hasOwnProperty(a)&&n!==t&&(i[a]=e.isPlainObject(n)?e.isPlainObject(i[a])?e.widget.extend({},i[a],n):e.widget.extend({},n):n);return i},e.widget.bridge=function(i,a){var n=a.prototype.widgetFullName||i;e.fn[i]=function(r){var o="string"==typeof r,h=s.call(arguments,1),l=this;return r=!o&&h.length?e.widget.extend.apply(null,[r].concat(h)):r,o?this.each(function(){var s,a=e.data(this,n);return a?e.isFunction(a[r])&&"_"!==r.charAt(0)?(s=a[r].apply(a,h),s!==a&&s!==t?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):t):e.error("no such method '"+r+"' for "+i+" widget instance"):e.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+r+"'")}):this.each(function(){var t=e.data(this,n);t?t.option(r||{})._init():e.data(this,n,new a(r,this))}),l}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(i,s){var a,n,r,o=i;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof i)if(o={},a=i.split("."),i=a.shift(),a.length){for(n=o[i]=e.widget.extend({},this.options[i]),r=0;a.length-1>r;r++)n[a[r]]=n[a[r]]||{},n=n[a[r]];if(i=a.pop(),1===arguments.length)return n[i]===t?null:n[i];n[i]=s}else{if(1===arguments.length)return this.options[i]===t?null:this.options[i];o[i]=s}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,a){var n,r=this;"boolean"!=typeof i&&(a=s,s=i,i=!1),a?(s=n=e(s),this.bindings=this.bindings.add(s)):(a=s,s=this.element,n=this.widget()),e.each(a,function(a,o){function h(){return i||r.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?r[o]:o).apply(r,arguments):t}"string"!=typeof o&&(h.guid=o.guid=o.guid||h.guid||e.guid++);var l=a.match(/^(\w+)\s*(.*)$/),u=l[1]+r.eventNamespace,d=l[2];d?n.delegate(d,u,h):s.bind(u,h)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var a,n,r=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(a in n)a in i||(i[a]=n[a]);return this.element.trigger(i,s),!(e.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,a,n){"string"==typeof a&&(a={effect:a});var r,o=a?a===!0||"number"==typeof a?i:a.effect||i:t;a=a||{},"number"==typeof a&&(a={duration:a}),r=!e.isEmptyObject(a),a.complete=n,a.delay&&s.delay(a.delay),r&&e.effects&&e.effects.effect[o]?s[t](a):o!==t&&s[o]?s[o](a.duration,a.easing,n):s.queue(function(i){e(this)[t](),n&&n.call(s[0]),i()})}})})(jQuery);(function(e){var t=!1;e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.10.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):undefined}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,a=1===i.which,n="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return a&&!n&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){return e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button?this._mouseUp(t):this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})})(jQuery);(function(e,t){function i(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function s(t,i){return parseInt(e.css(t,i),10)||0}function a(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var n,r=Math.max,o=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,m=e.fn.position;e.position={scrollbarWidth:function(){if(n!==t)return n;var i,s,a=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),r=a.children()[0];return e("body").append(a),i=r.offsetWidth,a.css("overflow","scroll"),s=r.offsetWidth,i===s&&(s=a[0].clientWidth),a.remove(),n=i-s},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),a="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,n="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:n?e.position.scrollbarWidth():0,height:a?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),a=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:a,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},e.fn.position=function(t){if(!t||!t.of)return m.apply(this,arguments);t=e.extend({},t);var n,p,f,g,v,y,b=e(t.of),_=e.position.getWithinInfo(t.within),x=e.position.getScrollInfo(_),k=(t.collision||"flip").split(" "),w={};return y=a(b),b[0].preventDefault&&(t.at="left top"),p=y.width,f=y.height,g=y.offset,v=e.extend({},g),e.each(["my","at"],function(){var e,i,s=(t[this]||"").split(" ");1===s.length&&(s=l.test(s[0])?s.concat(["center"]):u.test(s[0])?["center"].concat(s):["center","center"]),s[0]=l.test(s[0])?s[0]:"center",s[1]=u.test(s[1])?s[1]:"center",e=d.exec(s[0]),i=d.exec(s[1]),w[this]=[e?e[0]:0,i?i[0]:0],t[this]=[c.exec(s[0])[0],c.exec(s[1])[0]]}),1===k.length&&(k[1]=k[0]),"right"===t.at[0]?v.left+=p:"center"===t.at[0]&&(v.left+=p/2),"bottom"===t.at[1]?v.top+=f:"center"===t.at[1]&&(v.top+=f/2),n=i(w.at,p,f),v.left+=n[0],v.top+=n[1],this.each(function(){var a,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),m=s(this,"marginLeft"),y=s(this,"marginTop"),T=d+m+s(this,"marginRight")+x.width,D=c+y+s(this,"marginBottom")+x.height,S=e.extend({},v),N=i(w.my,u.outerWidth(),u.outerHeight());"right"===t.my[0]?S.left-=d:"center"===t.my[0]&&(S.left-=d/2),"bottom"===t.my[1]?S.top-=c:"center"===t.my[1]&&(S.top-=c/2),S.left+=N[0],S.top+=N[1],e.support.offsetFractions||(S.left=h(S.left),S.top=h(S.top)),a={marginLeft:m,marginTop:y},e.each(["left","top"],function(i,s){e.ui.position[k[i]]&&e.ui.position[k[i]][s](S,{targetWidth:p,targetHeight:f,elemWidth:d,elemHeight:c,collisionPosition:a,collisionWidth:T,collisionHeight:D,offset:[n[0]+N[0],n[1]+N[1]],my:t.my,at:t.at,within:_,elem:u})}),t.using&&(l=function(e){var i=g.left-S.left,s=i+p-d,a=g.top-S.top,n=a+f-c,h={target:{element:b,left:g.left,top:g.top,width:p,height:f},element:{element:u,left:S.left,top:S.top,width:d,height:c},horizontal:0>s?"left":i>0?"right":"center",vertical:0>n?"top":a>0?"bottom":"middle"};d>p&&p>o(i+s)&&(h.horizontal="center"),c>f&&f>o(a+n)&&(h.vertical="middle"),h.important=r(o(i),o(s))>r(o(a),o(n))?"horizontal":"vertical",t.using.call(this,e,h)}),u.offset(e.extend(S,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollLeft:s.offset.left,n=s.width,o=e.left-t.collisionPosition.marginLeft,h=a-o,l=o+t.collisionWidth-n-a;t.collisionWidth>n?h>0&&0>=l?(i=e.left+h+t.collisionWidth-n-a,e.left+=h-i):e.left=l>0&&0>=h?a:h>l?a+n-t.collisionWidth:a:h>0?e.left+=h:l>0?e.left-=l:e.left=r(e.left-o,e.left)},top:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollTop:s.offset.top,n=t.within.height,o=e.top-t.collisionPosition.marginTop,h=a-o,l=o+t.collisionHeight-n-a;t.collisionHeight>n?h>0&&0>=l?(i=e.top+h+t.collisionHeight-n-a,e.top+=h-i):e.top=l>0&&0>=h?a:h>l?a+n-t.collisionHeight:a:h>0?e.top+=h:l>0?e.top-=l:e.top=r(e.top-o,e.top)}},flip:{left:function(e,t){var i,s,a=t.within,n=a.offset.left+a.scrollLeft,r=a.width,h=a.isWindow?a.scrollLeft:a.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-r-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,m=-2*t.offset[0];0>u?(i=e.left+c+p+m+t.collisionWidth-r-n,(0>i||o(u)>i)&&(e.left+=c+p+m)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+m-h,(s>0||d>o(s))&&(e.left+=c+p+m))},top:function(e,t){var i,s,a=t.within,n=a.offset.top+a.scrollTop,r=a.height,h=a.isWindow?a.scrollTop:a.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-r-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,m="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,f=-2*t.offset[1];0>u?(s=e.top+p+m+f+t.collisionHeight-r-n,e.top+p+m+f>u&&(0>s||o(u)>s)&&(e.top+=p+m+f)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+m+f-h,e.top+p+m+f>d&&(i>0||d>o(i))&&(e.top+=p+m+f))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,a,n,r=document.getElementsByTagName("body")[0],o=document.createElement("div");t=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(n in s)t.style[n]=s[n];t.appendChild(o),i=r||document.documentElement,i.insertBefore(t,i.firstChild),o.style.cssText="position: absolute; left: 10.7432222px;",a=e(o).offset().left,e.support.offsetFractions=a>10&&11>a,t.innerHTML="",i.removeChild(t)}()})(jQuery);(function(e){function t(e,t,i){return e>t&&t+i>e}function i(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))}e.widget("ui.sortable",e.ui.mouse,{version:"1.10.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_create:function(){var e=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?"x"===e.axis||i(this.items[0].item):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_setOption:function(t,i){"disabled"===t?(this.options[t]=i,this.widget().toggleClass("ui-sortable-disabled",!!i)):e.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(t,i){var s=null,a=!1,n=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,n.widgetName+"-item")===n?(s=e(this),!1):undefined}),e.data(t.target,n.widgetName+"-item")===n&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(a=!0)}),a)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var a,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=e("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(a=this.containers.length-1;a>=0;a--)this.containers[a]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,a,n,r=this.options,o=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop+r.scrollSpeed:t.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft+r.scrollSpeed:t.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(t.pageY-e(document).scrollTop()<r.scrollSensitivity?o=e(document).scrollTop(e(document).scrollTop()-r.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<r.scrollSensitivity&&(o=e(document).scrollTop(e(document).scrollTop()+r.scrollSpeed)),t.pageX-e(document).scrollLeft()<r.scrollSensitivity?o=e(document).scrollLeft(e(document).scrollLeft()-r.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<r.scrollSensitivity&&(o=e(document).scrollLeft(e(document).scrollLeft()+r.scrollSpeed))),o!==!1&&e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],a=s.item[0],n=this._intersectsWithPointer(s),n&&s.instance===this.currentContainer&&a!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==a&&!e.contains(this.placeholder[0],a)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],a):!0)){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,a=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=a.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=a.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,a=s+this.helperProportions.height,n=e.left,r=n+e.width,o=e.top,h=o+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>o&&h>s+l,c="y"===this.options.axis||t+u>n&&r>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>o&&h>a-this.helperProportions.height/2},_intersectsWithPointer:function(e){var i="x"===this.options.axis||t(this.positionAbs.top+this.offset.click.top,e.top,e.height),s="y"===this.options.axis||t(this.positionAbs.left+this.offset.click.left,e.left,e.width),a=i&&s,n=this._getDragVerticalDirection(),r=this._getDragHorizontalDirection();return a?this.floating?r&&"right"===r||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var i=t(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),s=t(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),a=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&s||"left"===n&&!s:a&&("down"===a&&i||"up"===a&&!i)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){o.push(this)}var s,a,n,r,o=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(n=e(l[s]),a=n.length-1;a>=0;a--)r=e.data(n[a],this.widgetFullName),r&&r!==this&&!r.options.disabled&&h.push([e.isFunction(r.options.items)?r.options.items.call(r.element):e(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(o)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,a,n,r,o,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(a=e(c[i]),s=a.length-1;s>=0;s--)n=e.data(a[s],this.widgetFullName),n&&n!==this&&!n.options.disabled&&(d.push([e.isFunction(n.options.items)?n.options.items.call(n.element[0],t,{item:this.currentItem}):e(n.options.items,n.element),n]),this.containers.push(n));for(i=d.length-1;i>=0;i--)for(r=d[i][1],o=d[i][0],s=0,l=o.length;l>s;s++)h=e(o[s]),h.data(this.widgetName+"-item",r),u.push({item:h,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,a,n;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(a=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=a.outerWidth(),s.height=a.outerHeight()),n=a.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),a=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tr"===s?t.currentItem.children().each(function(){e("<td>&#160;</td>",t.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(a)}):"img"===s&&a.attr("src",t.currentItem.attr("src")),i||a.css("visibility","hidden"),a},update:function(e,a){(!i||s.forcePlaceholderSize)&&(a.height()||a.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),a.width()||a.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_contactContainers:function(s){var a,n,r,o,h,l,u,d,c,p,m=null,f=null;for(a=this.containers.length-1;a>=0;a--)if(!e.contains(this.currentItem[0],this.containers[a].element[0]))if(this._intersectsWith(this.containers[a].containerCache)){if(m&&e.contains(this.containers[a].element[0],m.element[0]))continue;m=this.containers[a],f=a}else this.containers[a].containerCache.over&&(this.containers[a]._trigger("out",s,this._uiHash(this)),this.containers[a].containerCache.over=0);if(m)if(1===this.containers.length)this.containers[f].containerCache.over||(this.containers[f]._trigger("over",s,this._uiHash(this)),this.containers[f].containerCache.over=1);else{for(r=1e4,o=null,p=m.floating||i(this.currentItem),h=p?"left":"top",l=p?"width":"height",u=this.positionAbs[h]+this.offset.click[h],n=this.items.length-1;n>=0;n--)e.contains(this.containers[f].element[0],this.items[n].item[0])&&this.items[n].item[0]!==this.currentItem[0]&&(!p||t(this.positionAbs.top+this.offset.click.top,this.items[n].top,this.items[n].height))&&(d=this.items[n].item.offset()[h],c=!1,Math.abs(d-u)>Math.abs(d+this.items[n][l]-u)&&(c=!0,d+=this.items[n][l]),r>Math.abs(d-u)&&(r=Math.abs(d-u),o=this.items[n],this.direction=c?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[f])return;o?this._rearrange(s,o,null,!0):this._rearrange(s,null,this.containers[f].element,!0),this._trigger("change",s,this._uiHash()),this.containers[f]._trigger("change",s,this._uiHash(this)),this.currentContainer=this.containers[f],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[f]._trigger("over",s,this._uiHash(this)),this.containers[f].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===document.body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,a=this.options;"parent"===a.containment&&(a.containment=this.helper[0].parentNode),("document"===a.containment||"window"===a.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,e("document"===a.containment?document:window).width()-this.helperProportions.width-this.margins.left,(e("document"===a.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(a.containment)||(t=e(a.containment)[0],i=e(a.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,a="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(a[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:a.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:a.scrollLeft())*s}},_generatePosition:function(t){var i,s,a=this.options,n=t.pageX,r=t.pageY,o="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(o[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==document&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),a.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/a.grid[1])*a.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-a.grid[1]:i+a.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/a.grid[0])*a.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-a.grid[0]:s+a.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:o.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:o.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var a=this.counter;this._delay(function(){a===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,a=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&a.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||a.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(a.push(function(e){this._trigger("remove",e,this._uiHash())}),a.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),a.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||a.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(a.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,this.cancelHelperRemoval){if(!t){for(this._trigger("beforeStop",e,this._uiHash()),s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!1}if(t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null,!t){for(s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}})})(jQuery);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/jquery.autocomplete.js b/web/src/main/webapp/js/jquery.autocomplete.js
index 9dde944ab9..bbacf00c11 100644
--- a/web/src/main/webapp/js/jquery.autocomplete.js
+++ b/web/src/main/webapp/js/jquery.autocomplete.js
@@ -34,6 +34,7 @@
                     div.className = containerClass;
                     div.style.position = 'absolute';
                     div.style.display = 'none';
+					div.style.cursor = 'pointer';
                     return div;
                 }
             };
@@ -158,15 +159,15 @@
             // special on() plugin code for 'autocomplete'
             // http://api.jquery.com/on/#on-events-selector-data
             // Listen for mouse over event on suggestions list:
-            container.on('mouseenter.autocomplete', suggestionSelector, function () {
-                that.activate($(this).data('index'));
-            });
-
-            // Deselect active element when mouse leaves suggestions container:
-            container.on('mouseleave.autocomplete', suggestionSelector, function () {                
-                that.selectedIndex = -1;
-                container.children('.' + selected).removeClass(selected);
-            });
+//            container.on('mouseenter.autocomplete', suggestionSelector, function () {
+//                that.activate($(this).data('index'));
+//            });
+//
+//            // Deselect active element when mouse leaves suggestions container:
+//            container.on('mouseleave.autocomplete', suggestionSelector, function () {                
+//                that.selectedIndex = -1;
+//                container.children('.' + selected).removeClass(selected);
+//            });
 
             // Listen for click event on suggestions list:
             container.on('click.autocomplete', suggestionSelector, function () {
@@ -194,7 +195,7 @@
             var that = this;
             that.fixPosition();
             if (that.options.minChars <= that.el.val().length) {
-                that.onValueChange();
+                // that.onValueChange();
             }
         },
 
diff --git a/web/src/main/webapp/js/jquery.history.js b/web/src/main/webapp/js/jquery.history.js
index caeb7aa4b5..d16813e34f 100644
--- a/web/src/main/webapp/js/jquery.history.js
+++ b/web/src/main/webapp/js/jquery.history.js
@@ -1 +1 @@
-(function(e,t){"use strict";var n=e.History=e.History||{},r=e.jQuery;if(typeof n.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");n.Adapter={bind:function(e,t,n){r(e).bind(t,n)},trigger:function(e,t,n){r(e).trigger(t,n)},extractEventData:function(e,n,r){var i=n&&n.originalEvent&&n.originalEvent[e]||r&&r[e]||t;return i},onDomLoad:function(e){r(e)}},typeof n.init!="undefined"&&n.init()})(window),function(e,t){"use strict";var n=e.console||t,r=e.document,i=e.navigator,s=e.sessionStorage||!1,o=e.setTimeout,u=e.clearTimeout,a=e.setInterval,f=e.clearInterval,l=e.JSON,c=e.alert,h=e.History=e.History||{},p=e.history;try{s.setItem("TEST","1"),s.removeItem("TEST")}catch(d){s=!1}l.stringify=l.stringify||l.encode,l.parse=l.parse||l.decode;if(typeof h.init!="undefined")throw new Error("History.js Core has already been loaded...");h.init=function(e){return typeof h.Adapter=="undefined"?!1:(typeof h.initCore!="undefined"&&h.initCore(),typeof h.initHtml4!="undefined"&&h.initHtml4(),!0)},h.initCore=function(d){if(typeof h.initCore.initialized!="undefined")return!1;h.initCore.initialized=!0,h.options=h.options||{},h.options.hashChangeInterval=h.options.hashChangeInterval||100,h.options.safariPollInterval=h.options.safariPollInterval||500,h.options.doubleCheckInterval=h.options.doubleCheckInterval||500,h.options.disableSuid=h.options.disableSuid||!1,h.options.storeInterval=h.options.storeInterval||1e3,h.options.busyDelay=h.options.busyDelay||250,h.options.debug=h.options.debug||!1,h.options.initialTitle=h.options.initialTitle||r.title,h.options.html4Mode=h.options.html4Mode||!1,h.options.delayInit=h.options.delayInit||!1,h.intervalList=[],h.clearAllIntervals=function(){var e,t=h.intervalList;if(typeof t!="undefined"&&t!==null){for(e=0;e<t.length;e++)f(t[e]);h.intervalList=null}},h.debug=function(){(h.options.debug||!1)&&h.log.apply(h,arguments)},h.log=function(){var e=typeof n!="undefined"&&typeof n.log!="undefined"&&typeof n.log.apply!="undefined",t=r.getElementById("log"),i,s,o,u,a;e?(u=Array.prototype.slice.call(arguments),i=u.shift(),typeof n.debug!="undefined"?n.debug.apply(n,[i,u]):n.log.apply(n,[i,u])):i="\n"+arguments[0]+"\n";for(s=1,o=arguments.length;s<o;++s){a=arguments[s];if(typeof a=="object"&&typeof l!="undefined")try{a=l.stringify(a)}catch(f){}i+="\n"+a+"\n"}return t?(t.value+=i+"\n-----\n",t.scrollTop=t.scrollHeight-t.clientHeight):e||c(i),!0},h.getInternetExplorerMajorVersion=function(){var e=h.getInternetExplorerMajorVersion.cached=typeof h.getInternetExplorerMajorVersion.cached!="undefined"?h.getInternetExplorerMajorVersion.cached:function(){var e=3,t=r.createElement("div"),n=t.getElementsByTagName("i");while((t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&n[0]);return e>4?e:!1}();return e},h.isInternetExplorer=function(){var e=h.isInternetExplorer.cached=typeof h.isInternetExplorer.cached!="undefined"?h.isInternetExplorer.cached:Boolean(h.getInternetExplorerMajorVersion());return e},h.options.html4Mode?h.emulated={pushState:!0,hashChange:!0}:h.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(i.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(i.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in r)||h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8)},h.enabled=!h.emulated.pushState,h.bugs={setHash:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),safariPoll:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),ieDoubleCheck:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<7)},h.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},h.cloneObject=function(e){var t,n;return e?(t=l.stringify(e),n=l.parse(t)):n={},n},h.getRootUrl=function(){var e=r.location.protocol+"//"+(r.location.hostname||r.location.host);if(r.location.port||!1)e+=":"+r.location.port;return e+="/",e},h.getBaseHref=function(){var e=r.getElementsByTagName("base"),t=null,n="";return e.length===1&&(t=e[0],n=t.href.replace(/[^\/]+$/,"")),n=n.replace(/\/+$/,""),n&&(n+="/"),n},h.getBaseUrl=function(){var e=h.getBaseHref()||h.getBasePageUrl()||h.getRootUrl();return e},h.getPageUrl=function(){var e=h.getState(!1,!1),t=(e||{}).url||h.getLocationHref(),n;return n=t.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,n){return/\./.test(e)?e:e+"/"}),n},h.getBasePageUrl=function(){var e=h.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,n){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},h.getFullUrl=function(e,t){var n=e,r=e.substring(0,1);return t=typeof t=="undefined"?!0:t,/[a-z]+\:\/\//.test(e)||(r==="/"?n=h.getRootUrl()+e.replace(/^\/+/,""):r==="#"?n=h.getPageUrl().replace(/#.*/,"")+e:r==="?"?n=h.getPageUrl().replace(/[\?#].*/,"")+e:t?n=h.getBaseUrl()+e.replace(/^(\.\/)+/,""):n=h.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),n.replace(/\#$/,"")},h.getShortUrl=function(e){var t=e,n=h.getBaseUrl(),r=h.getRootUrl();return h.emulated.pushState&&(t=t.replace(n,"")),t=t.replace(r,"/"),h.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),t},h.getLocationHref=function(e){return e=e||r,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},h.store={},h.idToState=h.idToState||{},h.stateToId=h.stateToId||{},h.urlToId=h.urlToId||{},h.storedStates=h.storedStates||[],h.savedStates=h.savedStates||[],h.normalizeStore=function(){h.store.idToState=h.store.idToState||{},h.store.urlToId=h.store.urlToId||{},h.store.stateToId=h.store.stateToId||{}},h.getState=function(e,t){typeof e=="undefined"&&(e=!0),typeof t=="undefined"&&(t=!0);var n=h.getLastSavedState();return!n&&t&&(n=h.createStateObject()),e&&(n=h.cloneObject(n),n.url=n.cleanUrl||n.url),n},h.getIdByState=function(e){var t=h.extractId(e.url),n;if(!t){n=h.getStateString(e);if(typeof h.stateToId[n]!="undefined")t=h.stateToId[n];else if(typeof h.store.stateToId[n]!="undefined")t=h.store.stateToId[n];else{for(;;){t=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof h.idToState[t]=="undefined"&&typeof h.store.idToState[t]=="undefined")break}h.stateToId[n]=t,h.idToState[t]=e}}return t},h.normalizeState=function(e){var t,n;if(!e||typeof e!="object")e={};if(typeof e.normalized!="undefined")return e;if(!e.data||typeof e.data!="object")e.data={};return t={},t.normalized=!0,t.title=e.title||"",t.url=h.getFullUrl(e.url?e.url:h.getLocationHref()),t.hash=h.getShortUrl(t.url),t.data=h.cloneObject(e.data),t.id=h.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,n=!h.isEmptyObject(t.data),(t.title||n)&&h.options.disableSuid!==!0&&(t.hash=h.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=h.getFullUrl(t.hash),(h.emulated.pushState||h.bugs.safariPoll)&&h.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t},h.createStateObject=function(e,t,n){var r={data:e,title:t,url:n};return r=h.normalizeState(r),r},h.getStateById=function(e){e=String(e);var n=h.idToState[e]||h.store.idToState[e]||t;return n},h.getStateString=function(e){var t,n,r;return t=h.normalizeState(e),n={data:t.data,title:e.title,url:e.url},r=l.stringify(n),r},h.getStateId=function(e){var t,n;return t=h.normalizeState(e),n=t.id,n},h.getHashByState=function(e){var t,n;return t=h.normalizeState(e),n=t.hash,n},h.extractId=function(e){var t,n,r,i;return e.indexOf("#")!=-1?i=e.split("#")[0]:i=e,n=/(.*)\&_suid=([0-9]+)$/.exec(i),r=n?n[1]||e:e,t=n?String(n[2]||""):"",t||!1},h.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},h.extractState=function(e,t){var n=null,r,i;return t=t||!1,r=h.extractId(e),r&&(n=h.getStateById(r)),n||(i=h.getFullUrl(e),r=h.getIdByUrl(i)||!1,r&&(n=h.getStateById(r)),!n&&t&&!h.isTraditionalAnchor(e)&&(n=h.createStateObject(null,null,i))),n},h.getIdByUrl=function(e){var n=h.urlToId[e]||h.store.urlToId[e]||t;return n},h.getLastSavedState=function(){return h.savedStates[h.savedStates.length-1]||t},h.getLastStoredState=function(){return h.storedStates[h.storedStates.length-1]||t},h.hasUrlDuplicate=function(e){var t=!1,n;return n=h.extractState(e.url),t=n&&n.id!==e.id,t},h.storeState=function(e){return h.urlToId[e.url]=e.id,h.storedStates.push(h.cloneObject(e)),e},h.isLastSavedState=function(e){var t=!1,n,r,i;return h.savedStates.length&&(n=e.id,r=h.getLastSavedState(),i=r.id,t=n===i),t},h.saveState=function(e){return h.isLastSavedState(e)?!1:(h.savedStates.push(h.cloneObject(e)),!0)},h.getStateByIndex=function(e){var t=null;return typeof e=="undefined"?t=h.savedStates[h.savedStates.length-1]:e<0?t=h.savedStates[h.savedStates.length+e]:t=h.savedStates[e],t},h.getCurrentIndex=function(){var e=null;return h.savedStates.length<1?e=0:e=h.savedStates.length-1,e},h.getHash=function(e){var t=h.getLocationHref(e),n;return n=h.getHashByUrl(t),n},h.unescapeHash=function(e){var t=h.normalizeHash(e);return t=decodeURIComponent(t),t},h.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},h.setHash=function(e,t){var n,i;return t!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.setHash,args:arguments,queue:t}),!1):(h.busy(!0),n=h.extractState(e,!0),n&&!h.emulated.pushState?h.pushState(n.data,n.title,n.url,!1):h.getHash()!==e&&(h.bugs.setHash?(i=h.getPageUrl(),h.pushState(null,null,i+"#"+e,!1)):r.location.hash=e),h)},h.escapeHash=function(t){var n=h.normalizeHash(t);return n=e.encodeURIComponent(n),h.bugs.hashEscape||(n=n.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),n},h.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=h.unescapeHash(t),t},h.setTitle=function(e){var t=e.title,n;t||(n=h.getStateByIndex(0),n&&n.url===e.url&&(t=n.title||h.options.initialTitle));try{r.getElementsByTagName("title")[0].innerHTML=t.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(i){}return r.title=t,h},h.queues=[],h.busy=function(e){typeof e!="undefined"?h.busy.flag=e:typeof h.busy.flag=="undefined"&&(h.busy.flag=!1);if(!h.busy.flag){u(h.busy.timeout);var t=function(){var e,n,r;if(h.busy.flag)return;for(e=h.queues.length-1;e>=0;--e){n=h.queues[e];if(n.length===0)continue;r=n.shift(),h.fireQueueItem(r),h.busy.timeout=o(t,h.options.busyDelay)}};h.busy.timeout=o(t,h.options.busyDelay)}return h.busy.flag},h.busy.flag=!1,h.fireQueueItem=function(e){return e.callback.apply(e.scope||h,e.args||[])},h.pushQueue=function(e){return h.queues[e.queue||0]=h.queues[e.queue||0]||[],h.queues[e.queue||0].push(e),h},h.queue=function(e,t){return typeof e=="function"&&(e={callback:e}),typeof t!="undefined"&&(e.queue=t),h.busy()?h.pushQueue(e):h.fireQueueItem(e),h},h.clearQueue=function(){return h.busy.flag=!1,h.queues=[],h},h.stateChanged=!1,h.doubleChecker=!1,h.doubleCheckComplete=function(){return h.stateChanged=!0,h.doubleCheckClear(),h},h.doubleCheckClear=function(){return h.doubleChecker&&(u(h.doubleChecker),h.doubleChecker=!1),h},h.doubleCheck=function(e){return h.stateChanged=!1,h.doubleCheckClear(),h.bugs.ieDoubleCheck&&(h.doubleChecker=o(function(){return h.doubleCheckClear(),h.stateChanged||e(),!0},h.options.doubleCheckInterval)),h},h.safariStatePoll=function(){var t=h.extractState(h.getLocationHref()),n;if(!h.isLastSavedState(t))return n=t,n||(n=h.createStateObject()),h.Adapter.trigger(e,"popstate"),h;return},h.back=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.back,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.back(!1)}),p.go(-1),!0)},h.forward=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.forward,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.forward(!1)}),p.go(1),!0)},h.go=function(e,t){var n;if(e>0)for(n=1;n<=e;++n)h.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(n=-1;n>=e;--n)h.back(t)}return h};if(h.emulated.pushState){var v=function(){};h.pushState=h.pushState||v,h.replaceState=h.replaceState||v}else h.onPopState=function(t,n){var r=!1,i=!1,s,o;return h.doubleCheckComplete(),s=h.getHash(),s?(o=h.extractState(s||h.getLocationHref(),!0),o?h.replaceState(o.data,o.title,o.url,!1):(h.Adapter.trigger(e,"anchorchange"),h.busy(!1)),h.expectedStateId=!1,!1):(r=h.Adapter.extractEventData("state",t,n)||!1,r?i=h.getStateById(r):h.expectedStateId?i=h.getStateById(h.expectedStateId):i=h.extractState(h.getLocationHref()),i||(i=h.createStateObject(null,null,h.getLocationHref())),h.expectedStateId=!1,h.isLastSavedState(i)?(h.busy(!1),!1):(h.storeState(i),h.saveState(i),h.setTitle(i),h.Adapter.trigger(e,"statechange"),h.busy(!1),!0))},h.Adapter.bind(e,"popstate",h.onPopState),h.pushState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.pushState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.pushState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0},h.replaceState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.replaceState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.replaceState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0};if(s){try{h.store=l.parse(s.getItem("History.store"))||{}}catch(m){h.store={}}h.normalizeStore()}else h.store={},h.normalizeStore();h.Adapter.bind(e,"unload",h.clearAllIntervals),h.saveState(h.storeState(h.extractState(h.getLocationHref(),!0))),s&&(h.onUnload=function(){var e,t,n;try{e=l.parse(s.getItem("History.store"))||{}}catch(r){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in h.idToState){if(!h.idToState.hasOwnProperty(t))continue;e.idToState[t]=h.idToState[t]}for(t in h.urlToId){if(!h.urlToId.hasOwnProperty(t))continue;e.urlToId[t]=h.urlToId[t]}for(t in h.stateToId){if(!h.stateToId.hasOwnProperty(t))continue;e.stateToId[t]=h.stateToId[t]}h.store=e,h.normalizeStore(),n=l.stringify(e);try{s.setItem("History.store",n)}catch(i){if(i.code!==DOMException.QUOTA_EXCEEDED_ERR)throw i;s.length&&(s.removeItem("History.store"),s.setItem("History.store",n))}},h.intervalList.push(a(h.onUnload,h.options.storeInterval)),h.Adapter.bind(e,"beforeunload",h.onUnload),h.Adapter.bind(e,"unload",h.onUnload));if(!h.emulated.pushState){h.bugs.safariPoll&&h.intervalList.push(a(h.safariStatePoll,h.options.safariPollInterval));if(i.vendor==="Apple Computer, Inc."||(i.appCodeName||"")==="Mozilla")h.Adapter.bind(e,"hashchange",function(){h.Adapter.trigger(e,"popstate")}),h.getHash()&&h.Adapter.onDomLoad(function(){h.Adapter.trigger(e,"hashchange")})}},(!h.options||!h.options.delayInit)&&h.init()}(window)
\ No newline at end of file
+(function(e,t){"use strict";var n=e.History=e.History||{},r=e.jQuery;if(typeof n.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");n.Adapter={bind:function(e,t,n){r(e).bind(t,n)},trigger:function(e,t,n){r(e).trigger(t,n)},extractEventData:function(e,n,r){var i=n&&n.originalEvent&&n.originalEvent[e]||r&&r[e]||t;return i},onDomLoad:function(e){r(e)}},typeof n.init!="undefined"&&n.init()})(window),function(e,t){"use strict";var n=e.console||t,r=e.document,i=e.navigator,s=!1,o=e.setTimeout,u=e.clearTimeout,a=e.setInterval,f=e.clearInterval,l=e.JSON,c=e.alert,h=e.History=e.History||{},p=e.history;try{s=e.sessionStorage,s.setItem("TEST","1"),s.removeItem("TEST")}catch(d){s=!1}l.stringify=l.stringify||l.encode,l.parse=l.parse||l.decode;if(typeof h.init!="undefined")throw new Error("History.js Core has already been loaded...");h.init=function(e){return typeof h.Adapter=="undefined"?!1:(typeof h.initCore!="undefined"&&h.initCore(),typeof h.initHtml4!="undefined"&&h.initHtml4(),!0)},h.initCore=function(d){if(typeof h.initCore.initialized!="undefined")return!1;h.initCore.initialized=!0,h.options=h.options||{},h.options.hashChangeInterval=h.options.hashChangeInterval||100,h.options.safariPollInterval=h.options.safariPollInterval||500,h.options.doubleCheckInterval=h.options.doubleCheckInterval||500,h.options.disableSuid=h.options.disableSuid||!1,h.options.storeInterval=h.options.storeInterval||1e3,h.options.busyDelay=h.options.busyDelay||250,h.options.debug=h.options.debug||!1,h.options.initialTitle=h.options.initialTitle||r.title,h.options.html4Mode=h.options.html4Mode||!1,h.options.delayInit=h.options.delayInit||!1,h.intervalList=[],h.clearAllIntervals=function(){var e,t=h.intervalList;if(typeof t!="undefined"&&t!==null){for(e=0;e<t.length;e++)f(t[e]);h.intervalList=null}},h.debug=function(){(h.options.debug||!1)&&h.log.apply(h,arguments)},h.log=function(){var e=typeof n!="undefined"&&typeof n.log!="undefined"&&typeof n.log.apply!="undefined",t=r.getElementById("log"),i,s,o,u,a;e?(u=Array.prototype.slice.call(arguments),i=u.shift(),typeof n.debug!="undefined"?n.debug.apply(n,[i,u]):n.log.apply(n,[i,u])):i="\n"+arguments[0]+"\n";for(s=1,o=arguments.length;s<o;++s){a=arguments[s];if(typeof a=="object"&&typeof l!="undefined")try{a=l.stringify(a)}catch(f){}i+="\n"+a+"\n"}return t?(t.value+=i+"\n-----\n",t.scrollTop=t.scrollHeight-t.clientHeight):e||c(i),!0},h.getInternetExplorerMajorVersion=function(){var e=h.getInternetExplorerMajorVersion.cached=typeof h.getInternetExplorerMajorVersion.cached!="undefined"?h.getInternetExplorerMajorVersion.cached:function(){var e=3,t=r.createElement("div"),n=t.getElementsByTagName("i");while((t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&n[0]);return e>4?e:!1}();return e},h.isInternetExplorer=function(){var e=h.isInternetExplorer.cached=typeof h.isInternetExplorer.cached!="undefined"?h.isInternetExplorer.cached:Boolean(h.getInternetExplorerMajorVersion());return e},h.options.html4Mode?h.emulated={pushState:!0,hashChange:!0}:h.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(i.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(i.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in r)||h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8)},h.enabled=!h.emulated.pushState,h.bugs={setHash:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),safariPoll:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),ieDoubleCheck:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<7)},h.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},h.cloneObject=function(e){var t,n;return e?(t=l.stringify(e),n=l.parse(t)):n={},n},h.getRootUrl=function(){var e=r.location.protocol+"//"+(r.location.hostname||r.location.host);if(r.location.port||!1)e+=":"+r.location.port;return e+="/",e},h.getBaseHref=function(){var e=r.getElementsByTagName("base"),t=null,n="";return e.length===1&&(t=e[0],n=t.href.replace(/[^\/]+$/,"")),n=n.replace(/\/+$/,""),n&&(n+="/"),n},h.getBaseUrl=function(){var e=h.getBaseHref()||h.getBasePageUrl()||h.getRootUrl();return e},h.getPageUrl=function(){var e=h.getState(!1,!1),t=(e||{}).url||h.getLocationHref(),n;return n=t.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,n){return/\./.test(e)?e:e+"/"}),n},h.getBasePageUrl=function(){var e=h.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,n){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},h.getFullUrl=function(e,t){var n=e,r=e.substring(0,1);return t=typeof t=="undefined"?!0:t,/[a-z]+\:\/\//.test(e)||(r==="/"?n=h.getRootUrl()+e.replace(/^\/+/,""):r==="#"?n=h.getPageUrl().replace(/#.*/,"")+e:r==="?"?n=h.getPageUrl().replace(/[\?#].*/,"")+e:t?n=h.getBaseUrl()+e.replace(/^(\.\/)+/,""):n=h.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),n.replace(/\#$/,"")},h.getShortUrl=function(e){var t=e,n=h.getBaseUrl(),r=h.getRootUrl();return h.emulated.pushState&&(t=t.replace(n,"")),t=t.replace(r,"/"),h.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),t},h.getLocationHref=function(e){return e=e||r,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},h.store={},h.idToState=h.idToState||{},h.stateToId=h.stateToId||{},h.urlToId=h.urlToId||{},h.storedStates=h.storedStates||[],h.savedStates=h.savedStates||[],h.normalizeStore=function(){h.store.idToState=h.store.idToState||{},h.store.urlToId=h.store.urlToId||{},h.store.stateToId=h.store.stateToId||{}},h.getState=function(e,t){typeof e=="undefined"&&(e=!0),typeof t=="undefined"&&(t=!0);var n=h.getLastSavedState();return!n&&t&&(n=h.createStateObject()),e&&(n=h.cloneObject(n),n.url=n.cleanUrl||n.url),n},h.getIdByState=function(e){var t=h.extractId(e.url),n;if(!t){n=h.getStateString(e);if(typeof h.stateToId[n]!="undefined")t=h.stateToId[n];else if(typeof h.store.stateToId[n]!="undefined")t=h.store.stateToId[n];else{for(;;){t=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof h.idToState[t]=="undefined"&&typeof h.store.idToState[t]=="undefined")break}h.stateToId[n]=t,h.idToState[t]=e}}return t},h.normalizeState=function(e){var t,n;if(!e||typeof e!="object")e={};if(typeof e.normalized!="undefined")return e;if(!e.data||typeof e.data!="object")e.data={};return t={},t.normalized=!0,t.title=e.title||"",t.url=h.getFullUrl(e.url?e.url:h.getLocationHref()),t.hash=h.getShortUrl(t.url),t.data=h.cloneObject(e.data),t.id=h.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,n=!h.isEmptyObject(t.data),(t.title||n)&&h.options.disableSuid!==!0&&(t.hash=h.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=h.getFullUrl(t.hash),(h.emulated.pushState||h.bugs.safariPoll)&&h.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t},h.createStateObject=function(e,t,n){var r={data:e,title:t,url:n};return r=h.normalizeState(r),r},h.getStateById=function(e){e=String(e);var n=h.idToState[e]||h.store.idToState[e]||t;return n},h.getStateString=function(e){var t,n,r;return t=h.normalizeState(e),n={data:t.data,title:e.title,url:e.url},r=l.stringify(n),r},h.getStateId=function(e){var t,n;return t=h.normalizeState(e),n=t.id,n},h.getHashByState=function(e){var t,n;return t=h.normalizeState(e),n=t.hash,n},h.extractId=function(e){var t,n,r,i;return e.indexOf("#")!=-1?i=e.split("#")[0]:i=e,n=/(.*)\&_suid=([0-9]+)$/.exec(i),r=n?n[1]||e:e,t=n?String(n[2]||""):"",t||!1},h.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},h.extractState=function(e,t){var n=null,r,i;return t=t||!1,r=h.extractId(e),r&&(n=h.getStateById(r)),n||(i=h.getFullUrl(e),r=h.getIdByUrl(i)||!1,r&&(n=h.getStateById(r)),!n&&t&&!h.isTraditionalAnchor(e)&&(n=h.createStateObject(null,null,i))),n},h.getIdByUrl=function(e){var n=h.urlToId[e]||h.store.urlToId[e]||t;return n},h.getLastSavedState=function(){return h.savedStates[h.savedStates.length-1]||t},h.getLastStoredState=function(){return h.storedStates[h.storedStates.length-1]||t},h.hasUrlDuplicate=function(e){var t=!1,n;return n=h.extractState(e.url),t=n&&n.id!==e.id,t},h.storeState=function(e){return h.urlToId[e.url]=e.id,h.storedStates.push(h.cloneObject(e)),e},h.isLastSavedState=function(e){var t=!1,n,r,i;return h.savedStates.length&&(n=e.id,r=h.getLastSavedState(),i=r.id,t=n===i),t},h.saveState=function(e){return h.isLastSavedState(e)?!1:(h.savedStates.push(h.cloneObject(e)),!0)},h.getStateByIndex=function(e){var t=null;return typeof e=="undefined"?t=h.savedStates[h.savedStates.length-1]:e<0?t=h.savedStates[h.savedStates.length+e]:t=h.savedStates[e],t},h.getCurrentIndex=function(){var e=null;return h.savedStates.length<1?e=0:e=h.savedStates.length-1,e},h.getHash=function(e){var t=h.getLocationHref(e),n;return n=h.getHashByUrl(t),n},h.unescapeHash=function(e){var t=h.normalizeHash(e);return t=decodeURIComponent(t),t},h.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},h.setHash=function(e,t){var n,i;return t!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.setHash,args:arguments,queue:t}),!1):(h.busy(!0),n=h.extractState(e,!0),n&&!h.emulated.pushState?h.pushState(n.data,n.title,n.url,!1):h.getHash()!==e&&(h.bugs.setHash?(i=h.getPageUrl(),h.pushState(null,null,i+"#"+e,!1)):r.location.hash=e),h)},h.escapeHash=function(t){var n=h.normalizeHash(t);return n=e.encodeURIComponent(n),h.bugs.hashEscape||(n=n.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),n},h.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=h.unescapeHash(t),t},h.setTitle=function(e){var t=e.title,n;t||(n=h.getStateByIndex(0),n&&n.url===e.url&&(t=n.title||h.options.initialTitle));try{r.getElementsByTagName("title")[0].innerHTML=t.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(i){}return r.title=t,h},h.queues=[],h.busy=function(e){typeof e!="undefined"?h.busy.flag=e:typeof h.busy.flag=="undefined"&&(h.busy.flag=!1);if(!h.busy.flag){u(h.busy.timeout);var t=function(){var e,n,r;if(h.busy.flag)return;for(e=h.queues.length-1;e>=0;--e){n=h.queues[e];if(n.length===0)continue;r=n.shift(),h.fireQueueItem(r),h.busy.timeout=o(t,h.options.busyDelay)}};h.busy.timeout=o(t,h.options.busyDelay)}return h.busy.flag},h.busy.flag=!1,h.fireQueueItem=function(e){return e.callback.apply(e.scope||h,e.args||[])},h.pushQueue=function(e){return h.queues[e.queue||0]=h.queues[e.queue||0]||[],h.queues[e.queue||0].push(e),h},h.queue=function(e,t){return typeof e=="function"&&(e={callback:e}),typeof t!="undefined"&&(e.queue=t),h.busy()?h.pushQueue(e):h.fireQueueItem(e),h},h.clearQueue=function(){return h.busy.flag=!1,h.queues=[],h},h.stateChanged=!1,h.doubleChecker=!1,h.doubleCheckComplete=function(){return h.stateChanged=!0,h.doubleCheckClear(),h},h.doubleCheckClear=function(){return h.doubleChecker&&(u(h.doubleChecker),h.doubleChecker=!1),h},h.doubleCheck=function(e){return h.stateChanged=!1,h.doubleCheckClear(),h.bugs.ieDoubleCheck&&(h.doubleChecker=o(function(){return h.doubleCheckClear(),h.stateChanged||e(),!0},h.options.doubleCheckInterval)),h},h.safariStatePoll=function(){var t=h.extractState(h.getLocationHref()),n;if(!h.isLastSavedState(t))return n=t,n||(n=h.createStateObject()),h.Adapter.trigger(e,"popstate"),h;return},h.back=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.back,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.back(!1)}),p.go(-1),!0)},h.forward=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.forward,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.forward(!1)}),p.go(1),!0)},h.go=function(e,t){var n;if(e>0)for(n=1;n<=e;++n)h.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(n=-1;n>=e;--n)h.back(t)}return h};if(h.emulated.pushState){var v=function(){};h.pushState=h.pushState||v,h.replaceState=h.replaceState||v}else h.onPopState=function(t,n){var r=!1,i=!1,s,o;return h.doubleCheckComplete(),s=h.getHash(),s?(o=h.extractState(s||h.getLocationHref(),!0),o?h.replaceState(o.data,o.title,o.url,!1):(h.Adapter.trigger(e,"anchorchange"),h.busy(!1)),h.expectedStateId=!1,!1):(r=h.Adapter.extractEventData("state",t,n)||!1,r?i=h.getStateById(r):h.expectedStateId?i=h.getStateById(h.expectedStateId):i=h.extractState(h.getLocationHref()),i||(i=h.createStateObject(null,null,h.getLocationHref())),h.expectedStateId=!1,h.isLastSavedState(i)?(h.busy(!1),!1):(h.storeState(i),h.saveState(i),h.setTitle(i),h.Adapter.trigger(e,"statechange"),h.busy(!1),!0))},h.Adapter.bind(e,"popstate",h.onPopState),h.pushState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.pushState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.pushState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0},h.replaceState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.replaceState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.replaceState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0};if(s){try{h.store=l.parse(s.getItem("History.store"))||{}}catch(m){h.store={}}h.normalizeStore()}else h.store={},h.normalizeStore();h.Adapter.bind(e,"unload",h.clearAllIntervals),h.saveState(h.storeState(h.extractState(h.getLocationHref(),!0))),s&&(h.onUnload=function(){var e,t,n;try{e=l.parse(s.getItem("History.store"))||{}}catch(r){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in h.idToState){if(!h.idToState.hasOwnProperty(t))continue;e.idToState[t]=h.idToState[t]}for(t in h.urlToId){if(!h.urlToId.hasOwnProperty(t))continue;e.urlToId[t]=h.urlToId[t]}for(t in h.stateToId){if(!h.stateToId.hasOwnProperty(t))continue;e.stateToId[t]=h.stateToId[t]}h.store=e,h.normalizeStore(),n=l.stringify(e);try{s.setItem("History.store",n)}catch(i){if(i.code!==DOMException.QUOTA_EXCEEDED_ERR)throw i;s.length&&(s.removeItem("History.store"),s.setItem("History.store",n))}},h.intervalList.push(a(h.onUnload,h.options.storeInterval)),h.Adapter.bind(e,"beforeunload",h.onUnload),h.Adapter.bind(e,"unload",h.onUnload));if(!h.emulated.pushState){h.bugs.safariPoll&&h.intervalList.push(a(h.safariStatePoll,h.options.safariPollInterval));if(i.vendor==="Apple Computer, Inc."||(i.appCodeName||"")==="Mozilla")h.Adapter.bind(e,"hashchange",function(){h.Adapter.trigger(e,"popstate")}),h.getHash()&&h.Adapter.onDomLoad(function(){h.Adapter.trigger(e,"hashchange")})}},(!h.options||!h.options.delayInit)&&h.init()}(window)
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.contextmenu.js b/web/src/main/webapp/js/leaflet.contextmenu.js
new file mode 100644
index 0000000000..4cae713af9
--- /dev/null
+++ b/web/src/main/webapp/js/leaflet.contextmenu.js
@@ -0,0 +1,618 @@
+/*
+Leaflet.contextmenu, a context menu for Leaflet.
+(c) 2014, Adam Ratcliffe, GeoSmart Maps Limited
+contribute 2014, Roland Braband, NRC
+ */
+L.Map.mergeOptions({
+    contextmenuItems : []
+});
+
+L.Map.ContextMenu = L.Handler.extend({
+
+        statics : {
+            BASE_CLS : 'leaflet-contextmenu'
+        },
+
+        initialize : function (map) {
+            L.Handler.prototype.initialize.call(this, map);
+
+            this._items = [];
+            this._sets = [];
+            this._state = 0;
+            this._defaultState = map.options.contextmenuDefaultState || 1;
+            this._activeState = map.options.contextmenuAtiveState || 1;
+            this._visible = false;
+
+            var container = this._container = L.DomUtil.create('div', L.Map.ContextMenu.BASE_CLS, map._container);
+            container.style.zIndex = 1e4;
+            container.style.position = 'absolute';
+
+            if (map.options.contextmenuWidth) {
+                container.style.width = map.options.contextmenuWidth + 'px';
+            }
+            if (map.options.contextmenuSets === undefined || map.options.contextmenuSets.length === 0) {
+                map.options.contextmenuSets = [{
+                        name : 'set_default',
+                        state : this._defaultState
+                    }
+                ];
+            }
+
+            this._createItems();
+            this._createSets();
+            this._changeState();
+            L.DomEvent
+            .on(container, 'click', L.DomEvent.stop)
+            .on(container, 'mousedown', L.DomEvent.stop)
+            .on(container, 'dblclick', L.DomEvent.stop)
+            .on(container, 'contextmenu', L.DomEvent.stop);
+        },
+
+        addHooks : function () {
+            L.DomEvent
+            .on(document, ((L.Browser.touch) ? 'touchstart' : 'mousedown'), this._onMouseDown, this)
+            .on(document, 'keydown', this._onKeyDown, this);
+
+            this._map.on({
+                contextmenu : this._show,
+                mouseout : this._hide,
+                mousedown : this._hide,
+                movestart : this._hide,
+                zoomstart : this._hide
+            }, this);
+        },
+
+        removeHooks : function () {
+            L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
+
+            this._map.off({
+                contextmenu : this._show,
+                mouseout : this._hide,
+                mousedown : this._hide,
+                movestart : this._hide,
+                zoomstart : this._hide
+            }, this);
+
+        },
+
+        showAt : function (point, data, state) {
+            if (point instanceof L.LatLng) {
+                point = this._map.latLngToContainerPoint(point);
+            }
+            this._showAtPoint(point, data, state);
+        },
+
+        hide : function () {
+            this._hide();
+        },
+
+        setState : function (state) {
+            return this._changeState(state);
+        },
+
+        setActiveState : function (state) {
+            var set,
+            state = (state !== undefined) ? state : this._activeState,
+            el,
+            i,
+            l;
+
+            for (i = 0, l = this._sets.length; i < l; i++) {
+                set = this._sets[i];
+                if (set.state === state) {
+                    this._activeState = state;
+                    break;
+                }
+            }
+            return set;
+        },
+
+        getState : function () {
+            return this._state;
+        },
+
+        addSet : function (options) {
+            return this.insertSet(options);
+        },
+
+        insertSet : function (options, id) {
+            var id = (id !== undefined) ? id : this._sets.length,
+            set = this._createSet(options, id);
+
+            this._sets.push(set);
+            return set;
+        },
+
+        addItem : function (options) {
+            return this.insertItem(options);
+        },
+
+        insertItem : function (options, index) {
+            var index = (index !== undefined) ? index : this._items.length,
+            item = this._createItem(this._container, options, index);
+
+            this._items.push(item);
+            this._sizeChanged = true;
+            this._map.fire('contextmenu.additem', {
+                contextmenu : this,
+                el : item.el,
+                index : index
+            });
+
+            return item.el;
+        },
+
+        removeItem : function (item) {
+            var container = this._container;
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+
+            if (item !== undefined) {
+                this._removeItem(L.Util.stamp(item));
+
+                this._sizeChanged = true;
+
+                this._map.fire('contextmenu.removeitem', {
+                    contextmenu : this,
+                    el : item
+                });
+
+            }
+        },
+
+        removeAllItems : function () {
+            var item;
+            
+            while (this._container.children.length) {
+                item = this._container.children[0];
+                this._removeItem(L.Util.stamp(item));
+            }
+        },
+
+        setDisabled : function (item, disabled) {
+            var container = this._container,
+            itemCls = L.Map.ContextMenu.BASE_CLS + '-item';
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+
+            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
+                if (disabled) {
+                    L.DomUtil.addClass(item, itemCls + '-disabled');
+                    this._map.fire('contextmenu.disableitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                } else {
+                    L.DomUtil.removeClass(item, itemCls + '-disabled');
+                    this._map.fire('contextmenu.enableitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                }
+            }
+        },
+
+        setHidden : function (item, hidden) {
+            var container = this._container,
+            itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
+            separatorCls = L.Map.ContextMenu.BASE_CLS + '-separator';
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
+                if (hidden) {
+                    L.DomUtil.addClass(item, itemCls + '-hidden');
+                    this._map.fire('contextmenu.hideitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+
+                } else {
+                    L.DomUtil.removeClass(item, itemCls + '-hidden');
+                    this._map.fire('contextmenu.showitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                }
+            } else if (item !== undefined && L.DomUtil.hasClass(item, separatorCls)) {
+                if (hidden) {
+                    L.DomUtil.addClass(item, separatorCls + '-hidden');
+                } else {
+                    L.DomUtil.removeClass(item, separatorCls + '-hidden');
+                }
+            }
+        },
+
+        isVisible : function () {
+            return this._visible;
+        },
+
+        // private methods
+        _changeState : function (state) {
+            var set,
+            state = (state !== undefined) ? state : this._defaultState,
+            item,
+            el,
+            i,
+            l;
+            
+            if (state !== this._state) {
+                for (i = 0, l = this._sets.length; i < l; i++) {
+                    set = this._sets[i];
+                    if (set.state === state || (set.name === state && set.state !== this._state)) {
+                        this._map.fire('contextmenu.changestate', {
+                            contextmenu : this,
+                            set : set,
+                            state : state
+                        });
+                        for (i = 0, l = this._items.length; i < l; i++) {
+                            item = this._items[i];
+                            this.setHidden(this._items[i].el, (item.state.indexOf(set.state) === -1 && item.state.indexOf(set.name) === -1));
+                        }
+                        this._sizeChanged = true;
+                        this._state = state;
+                        break;
+                    }
+                }
+            }
+            return set;
+        },
+
+        _createSets : function () {
+            var setOptions = this._map.options.contextmenuSets,
+            set,
+            i,
+            l;
+
+            for (i = 0, l = setOptions.length; i < l; i++) {
+                this._sets.push(this._createSet(setOptions[i], this._sets.length));
+            }
+        },
+
+        _createSet : function (options, id) {
+            var name = (options.name !== undefined) ? options.name : 'set_' + id;
+            return {
+                id : id,
+                name : options.name,
+                state : options.state
+            };
+        },
+
+        _createItems : function () {
+            var itemOptions = this._map.options.contextmenuItems,
+            item,
+            i,
+            l;
+
+            for (i = 0, l = itemOptions.length; i < l; i++) {
+                this._items.push(this._createItem(this._container, itemOptions[i]));
+            }
+        },
+
+        _createItem : function (container, options, index) {
+            if (options.separator || options === '-') {
+                return this._createSeparator(container, index, options.state);
+            }
+
+            var itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
+            state = (options.state !== undefined) ? ((Array.isArray(options.state)) ? options.state : [options.state]) : [this._defaultState],
+            cls = (options.disabled) ? (itemCls + ' ' + itemCls + '-disabled') : ((options.hidden) ? (itemCls + ' ' + itemCls + '-hidden') : itemCls),
+            el = this._insertElementAt('a', cls, container, index),
+            callback = this._createEventHandler(el, options.callback, options.context, options.hideOnSelect),
+            html = '';
+
+            if (options.icon) {
+                html = '<img class="' + L.Map.ContextMenu.BASE_CLS + '-icon" src="' + options.icon + '"/>';
+            } else if (options.iconCls) {
+                html = '<span class="' + L.Map.ContextMenu.BASE_CLS + '- icon ' + options.iconCls + '"></span>';
+            }
+
+            el.innerHTML = html + options.text;
+            el.href = '#';
+            L.DomEvent
+            .on(el, 'mouseover', this._onItemMouseOver, this)
+            .on(el, 'mouseout', this._onItemMouseOut, this)
+            .on(el, 'mousedown', L.DomEvent.stopPropagation)
+            .on(el, 'click', callback);
+
+            return {
+                id : L.Util.stamp(el),
+                el : el,
+                callback : callback,
+                state : state
+            };
+        },
+
+        _removeItem : function (id) {
+            var item,
+            callback,
+            el,
+            i,
+            l;
+
+            for (i = 0, l = this._items.length; i < l; i++) {
+                item = this._items[i];
+
+                if (item.id === id) {
+                    el = item.el;
+                    callback = item.callback;
+
+                    if (callback) {
+                        L.DomEvent
+                        .off(el, 'mouseover', this._onItemMouseOver, this)
+                        .off(el, 'mouseover', this._onItemMouseOut, this)
+                        .off(el, 'mousedown', L.DomEvent.stopPropagation)
+                        .off(el, 'click', item.callback);
+
+                    }
+
+                    this._container.removeChild(el);
+                    this._items.splice(i, 1);
+                    return item;
+
+                }
+            }
+            return null;
+        },
+
+        _createSeparator : function (container, index, state) {
+            var el = this._insertElementAt('div', L.Map.ContextMenu.BASE_CLS + '-separator', container, index),
+            state = (state !== undefined) ? ((Array.isArray(state)) ? state : [state]) : [this._defaultState];
+
+            return {
+                id : L.Util.stamp(el),
+                el : el,
+                state : state
+            };
+        },
+
+        _createEventHandler : function (el, func, context, hideOnSelect) {
+            var me = this,
+            map = this._map,
+            disabledCls = L.Map.ContextMenu.BASE_CLS + '-item-disabled',
+            hideOnSelect = (hideOnSelect !== undefined) ? hideOnSelect : true;
+
+            return function (e) {
+                if (L.DomUtil.hasClass(el, disabledCls)) {
+                    return;
+
+                }
+
+                if (hideOnSelect) {
+                    me._hide();
+
+                }
+
+                if (func) {
+                    func.call(context || map, me._showLocation);
+                }
+
+                me._map.fire('contextmenu:select', {
+                    contextmenu : me,
+                    el : el
+                });
+            };
+        },
+
+        _insertElementAt : function (tagName, className, container, index) {
+            var refEl,
+            el = document.createElement(tagName);
+
+            el.className = className;
+
+            if (index !== undefined) {
+                refEl = container.children[index];
+            }
+
+            if (refEl) {
+                container.insertBefore(el, refEl);
+            } else {
+                container.appendChild(el);
+            }
+
+            return el;
+        },
+
+        _show : function (e) {
+            this._showAtPoint(e.containerPoint);
+        },
+
+        _showAtPoint : function (pt, data, state) {
+            if (this._items.length) {
+                var map = this._map,
+                layerPoint = map.containerPointToLayerPoint(pt),
+                latlng = map.layerPointToLatLng(layerPoint),
+                event = {
+                    contextmenu : this,
+                    state : state
+                },
+                state = (state !== undefined) ? state : this._activeState;
+
+                if (data) {
+                    event = L.extend(data, event);
+                }
+
+                this._showLocation = {
+                    state : state,
+                    target : (data) ? data.relatedTarget : null,
+                    latlng : latlng,
+                    layerPoint : layerPoint,
+                    containerPoint : pt
+                };
+
+                this._setPosition(pt);
+                this._changeState(state);
+                
+                if (!this._visible) {
+                    this._container.style.display = 'block';
+                    this._visible = true;
+                } else {
+                    this._setPosition(pt);
+                }
+                
+
+                this._map.fire('contextmenu.show', event);
+            }
+        },
+
+        _hide : function () {
+            if (this._visible) {
+                this.setState(this._defaultState);
+                this._visible = false;
+                this._container.style.display = 'none';
+                this._map.fire('contextmenu.hide', {
+                    contextmenu : this
+                });
+            }
+        },
+
+        _setPosition : function (pt) {
+            var mapSize = this._map.getSize(),
+            container = this._container,
+            containerSize = this._getElementSize(container),
+            anchor;
+
+            if (this._map.options.contextmenuAnchor) {
+                anchor = L.point(this._map.options.contextmenuAnchor);
+                pt = pt.add(anchor);
+            }
+
+            container._leaflet_pos = pt;
+
+            if (pt.x + containerSize.x > mapSize.x) {
+                container.style.left = 'auto';
+                container.style.right = Math.max(mapSize.x - pt.x, 0) + 'px';
+            } else {
+                container.style.left = Math.max(pt.x, 0) + 'px';
+                container.style.right = 'auto';
+            }
+
+            if (pt.y + containerSize.y > mapSize.y) {
+                container.style.top = 'auto';
+                container.style.bottom = Math.max(mapSize.y - pt.y, 0) + 'px';
+            } else {
+                container.style.top = Math.max(pt.y, 0) + 'px';
+                container.style.bottom = 'auto';
+            }
+        },
+
+        _getElementSize : function (el) {
+            var size = this._size,
+            initialDisplay = el.style.display;
+
+            if (!size || this._sizeChanged) {
+                size = {};
+
+                el.style.left = '-999999px';
+                el.style.right = 'auto';
+                el.style.display = 'block';
+
+                size.x = el.offsetWidth;
+                size.y = el.offsetHeight;
+
+                el.style.left = 'auto';
+                el.style.display = initialDisplay;
+
+                this._sizeChanged = false;
+            }
+
+            return size;
+        },
+
+        _onMouseDown : function (e) {
+            //console.log('_onMouseDown');
+            this._hide();
+        },
+
+        _onKeyDown : function (e) {
+            var key = e.keyCode;
+
+            // If ESC pressed and context menu is visible hide it
+            if (key === 27) {
+                this._hide();
+            }
+        },
+
+        _onItemMouseOver : function (e) {
+            L.DomUtil.addClass(e.target, 'over');
+        },
+
+        _onItemMouseOut : function (e) {
+            L.DomUtil.removeClass(e.target, 'over');
+        }
+    });
+
+L.Map.addInitHook('addHandler', 'contextmenu', L.Map.ContextMenu);
+L.Mixin.ContextMenu = {
+
+    // private methods
+    _initContextMenu : function () {
+        this._items = [];
+
+        this.on('contextmenu', this._showContextMenu, this);
+    },
+
+    _showContextMenu : function (e) {
+        var itemOptions,
+        pt,
+        i,
+        l;
+
+        if (this._map.contextmenu) {
+            pt = this._map.mouseEventToContainerPoint(e.originalEvent);
+
+            for (i = 0, l = this.options.contextmenuItems.length; i < l; i++) {
+                itemOptions = this.options.contextmenuItems[i];
+                this._items.push(this._map.contextmenu.insertItem(itemOptions, itemOptions.index));
+            }
+
+            this._map.once('contextmenu.hide', this._hideContextMenu, this);
+
+            this._map.contextmenu.showAt(pt, {
+                relatedTarget : this
+            },
+            this.options.contextmenuAtiveState);
+        }
+    },
+
+    _hideContextMenu : function () {
+        var i,
+        l;
+
+        for (i = 0, l = this._items.length; i < l; i++) {
+            this._map.contextmenu.removeItem(this._items[i]);
+        }
+        this._items.length = 0;
+    }
+};
+
+L.Marker.mergeOptions({
+    contextmenu : false,
+    contextmenuItems : []
+});
+
+L.Marker.addInitHook(function () {
+    if (this.options.contextmenu) {
+        this._initContextMenu();
+    }
+});
+
+L.Marker.include(L.Mixin.ContextMenu);
+
+L.Path.mergeOptions({
+    contextmenu : false,
+    contextmenuItems : []
+});
+
+L.Path.addInitHook(function () {
+    if (this.options.contextmenu) {
+        this._initContextMenu();
+    }
+});
+
+L.Path.include(L.Mixin.ContextMenu);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.js b/web/src/main/webapp/js/leaflet.js
index e7d2be1cc9..03434b77db 100644
--- a/web/src/main/webapp/js/leaflet.js
+++ b/web/src/main/webapp/js/leaflet.js
@@ -3,7 +3,7 @@
  (c) 2010-2013, Vladimir Agafonkin
  (c) 2010-2011, CloudMade
 */
-!function(t,e,i){var n=t.L,o={};o.version="0.7.2","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=t.navigator&&t.navigator.msPointerEnabled&&t.navigator.msMaxTouchPoints&&!t.PointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled&&t.navigator.maxTouchPoints||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&function(){var t="ontouchstart";if(m||t in g)return!0;var i=e.createElement("div"),n=!1;return i.setAttribute?(i.setAttribute(t,"return;"),"function"==typeof i[t]&&(n=!0),i.removeAttribute(t),i=null,n):!1}();o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n)),a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return s=e&&e.maxZoom?Math.min(e.maxZoom,s):s,this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("viewreset",{hard:!i}),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-1/0,o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;
+!function(t,e,i){var n=t.L,o={};o.version="0.7.3","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=t.navigator&&t.navigator.msPointerEnabled&&t.navigator.msMaxTouchPoints&&!t.PointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled&&t.navigator.maxTouchPoints||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&function(){var t="ontouchstart";if(m||t in g)return!0;var i=e.createElement("div"),n=!1;return i.setAttribute?(i.setAttribute(t,"return;"),"function"==typeof i[t]&&(n=!0),i.removeAttribute(t),i=null,n):!1}();o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n)),a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return s=e&&e.maxZoom?Math.min(e.maxZoom,s):s,this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,this.fire("viewreset",{hard:!i}),a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-1/0,o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;
 return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,-i,.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-1/0);for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=e.tileSize,o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;i.width=i.height=e.detectRetina&&o.Browser.retina?2*n:n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i=o.point("shadow"===e?n.shadowAnchor||n.iconAnchor:n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){if(this._icon){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return i.innerHTML=n.html!==!1?n.html:"",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())
-},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,t.dashStyle=i.dashArray?o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):"",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill()),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onClick,this))},_onClick:function(t){this._containsPoint(t.layerPoint)&&this.fire("click",t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&1e3>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!(t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(o.DomEvent.stopPropagation(t),o.Draggable._disabled||(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),this._moving)))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),o.DomUtil.addClass(t.target||t.srcElement,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(t){o.DomUtil.removeClass(e.body,"leaflet-dragging"),o.DomUtil.removeClass(t.target||t.srcElement,"leaflet-drag-target");for(var i in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[i],this._onMove).off(e,o.Draggable.END[i],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],s[a]="function"==typeof n?n.bind(h):n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);
-break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange).off("layerremove",this._onLayerChange)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a){this._animatingZoom=!0,o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a})},_onZoomTransitionEnd:function(){this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
\ No newline at end of file
+},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,t.dashStyle=i.dashArray?o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):"",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this.fire("remove"),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill()),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onClick,this))},_onClick:function(t){this._containsPoint(t.layerPoint)&&this.fire("click",t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&500>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!(t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(o.DomEvent.stopPropagation(t),o.Draggable._disabled||(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),this._moving)))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.Browser.touch&&Math.abs(s.x)+Math.abs(s.y)<3||(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget)))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],s[a]="function"==typeof n?n.bind(h):n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;
+break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta,!1,!0)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange,this).off("layerremove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a,r){r||(this._animatingZoom=!0),o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),o.Util.requestAnimFrame(function(){this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a})},this)},_onZoomTransitionEnd:function(){this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.loading.js b/web/src/main/webapp/js/leaflet.loading.js
new file mode 100644
index 0000000000..16683d26ef
--- /dev/null
+++ b/web/src/main/webapp/js/leaflet.loading.js
@@ -0,0 +1,262 @@
+/*
+ * L.Control.Loading is a control that shows a loading indicator when tiles are
+ * loading or when map-related AJAX requests are taking place.
+ */
+
+(function () {
+
+    function defineLeafletLoading(L) {
+        L.Control.Loading = L.Control.extend({
+            options: {
+                position: 'topleft',
+                separate: false,
+                zoomControl: null,
+                spinjs: false,
+                spin: { 
+                  lines: 7, 
+                  length: 3, 
+                  width: 3, 
+                  radius: 5, 
+                  rotate: 13, 
+                  top: "83%"
+                }
+            },
+
+            initialize: function(options) {
+                L.setOptions(this, options);
+                this._dataLoaders = {};
+
+                // Try to set the zoom control this control is attached to from the 
+                // options
+                if (this.options.zoomControl !== null) {
+                    this.zoomControl = this.options.zoomControl;
+                }
+            },
+
+            onAdd: function(map) {
+                if (this.options.spinjs && (typeof Spinner !== 'function')) {
+                    return console.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");
+                }
+                this._addLayerListeners(map);
+                this._addMapListeners(map);
+
+                // Try to set the zoom control this control is attached to from the map
+                // the control is being added to
+                if (!this.options.separate && !this.zoomControl) {
+                    if (map.zoomControl) {
+                        this.zoomControl = map.zoomControl;
+                    } else if (map.zoomsliderControl) {
+                        this.zoomControl = map.zoomsliderControl;
+                    }
+                }
+
+                // Create the loading indicator
+                var classes = 'leaflet-control-loading';
+                var container;
+                if (this.zoomControl && !this.options.separate) {
+                    // If there is a zoom control, hook into the bottom of it
+                    container = this.zoomControl._container;
+                    // These classes are no longer used as of Leaflet 0.6
+                    classes += ' leaflet-bar-part-bottom leaflet-bar-part last';
+                }
+                else {
+                    // Otherwise, create a container for the indicator
+                    container = L.DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');
+                }
+                this._indicator = L.DomUtil.create('a', classes, container);
+                if (this.options.spinjs) {
+                  this._spinner = new Spinner(this.options.spin).spin();
+                  this._indicator.appendChild(this._spinner.el);
+                }
+                return container;
+            },
+
+            onRemove: function(map) {
+                this._removeLayerListeners(map);
+                this._removeMapListeners(map);
+            },
+
+            removeFrom: function (map) {
+                if (this.zoomControl && !this.options.separate) {
+                    // Override Control.removeFrom() to avoid clobbering the entire
+                    // _container, which is the same as zoomControl's
+                    this._container.removeChild(this._indicator);
+                    this._map = null;
+                    this.onRemove(map);
+                    return this;
+                }
+                else {
+                    // If this control is separate from the zoomControl, call the
+                    // parent method so we don't leave behind an empty container
+                    return L.Control.prototype.removeFrom.call(this, map);
+                }
+            },
+
+            addLoader: function(id) {
+                this._dataLoaders[id] = true;
+                this.updateIndicator();
+            },
+
+            removeLoader: function(id) {
+                delete this._dataLoaders[id];
+                this.updateIndicator();
+            },
+
+            updateIndicator: function() {
+                if (this.isLoading()) {
+                    this._showIndicator();
+                }
+                else {
+                    this._hideIndicator();
+                }
+            },
+
+            isLoading: function() {
+                return this._countLoaders() > 0;
+            },
+
+            _countLoaders: function() {
+                var size = 0, key;
+                for (key in this._dataLoaders) {
+                    if (this._dataLoaders.hasOwnProperty(key)) size++;
+                }
+                return size;
+            },
+
+            _showIndicator: function() {
+                // Show loading indicator
+                L.DomUtil.addClass(this._indicator, 'is-loading');
+
+                // If zoomControl exists, make the zoom-out button not last
+                if (!this.options.separate) {
+                    if (this.zoomControl instanceof L.Control.Zoom) {
+                        L.DomUtil.removeClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');
+                    }
+                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
+                        L.DomUtil.removeClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
+                    }
+                }
+            },
+
+            _hideIndicator: function() {
+                // Hide loading indicator
+                L.DomUtil.removeClass(this._indicator, 'is-loading');
+
+                // If zoomControl exists, make the zoom-out button last
+                if (!this.options.separate) {
+                    if (this.zoomControl instanceof L.Control.Zoom) {
+                        L.DomUtil.addClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');
+                    }
+                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
+                        L.DomUtil.addClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
+                    }
+                }
+            },
+
+            _handleLoading: function(e) {
+                this.addLoader(this.getEventId(e));
+            },
+
+            _handleLoad: function(e) {
+                this.removeLoader(this.getEventId(e));
+            },
+
+            getEventId: function(e) {
+                if (e.id) {
+                    return e.id;
+                }
+                else if (e.layer) {
+                    return e.layer._leaflet_id;
+                }
+                return e.target._leaflet_id;
+            },
+
+            _layerAdd: function(e) {
+                if (!e.layer || !e.layer.on) return
+                try {
+                    e.layer.on({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }
+                catch (exception) {
+                    console.warn('L.Control.Loading: Tried and failed to add ' +
+                                 ' event handlers to layer', e.layer);
+                    console.warn('L.Control.Loading: Full details', exception);
+                }
+            },
+
+            _addLayerListeners: function(map) {
+                // Add listeners for begin and end of load to any layers already on the 
+                // map
+                map.eachLayer(function(layer) {
+                    if (!layer.on) return;
+                    layer.on({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }, this);
+
+                // When a layer is added to the map, add listeners for begin and end
+                // of load
+                map.on('layeradd', this._layerAdd, this);
+            },
+
+            _removeLayerListeners: function(map) {
+                // Remove listeners for begin and end of load from all layers
+                map.eachLayer(function(layer) {
+                    if (!layer.off) return;
+                    layer.off({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }, this);
+
+                // Remove layeradd listener from map
+                map.off('layeradd', this._layerAdd, this);
+            },
+
+            _addMapListeners: function(map) {
+                // Add listeners to the map for (custom) dataloading and dataload
+                // events, eg, for AJAX calls that affect the map but will not be
+                // reflected in the above layer events.
+                map.on({
+                    dataloading: this._handleLoading,
+                    dataload: this._handleLoad,
+                    layerremove: this._handleLoad
+                }, this);
+            },
+
+            _removeMapListeners: function(map) {
+                map.off({
+                    dataloading: this._handleLoading,
+                    dataload: this._handleLoad,
+                    layerremove: this._handleLoad
+                }, this);
+            }
+        });
+
+        L.Map.addInitHook(function () {
+            if (this.options.loadingControl) {
+                this.loadingControl = new L.Control.Loading();
+                this.addControl(this.loadingControl);
+            }
+        });
+
+        L.Control.loading = function(options) {
+            return new L.Control.Loading(options);
+        };
+    }
+
+    if (typeof define === 'function' && define.amd) {
+        // Try to add leaflet.loading to Leaflet using AMD
+        define(['leaflet'], function (L) {
+            defineLeafletLoading(L);
+        });
+    }
+    else {
+        // Else use the global L
+        defineLeafletLoading(L);
+    }
+
+})();
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 6bc35db9e0..dc1499d62e 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -1,12 +1,12 @@
-/*
- * If you want to query another API append this something like
- * &host=http://localhost:9000/
- * to the URL or overwrite the 'host' variable.
- */
-var tmpArgs = parseUrlWithHisto();
-var host = tmpArgs["host"];
-// var host = "http://graphhopper.com/api/1";
-if (host == null) {
+var host;
+
+// Deployment-scripts can insert host here.
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
+// Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
+// https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+if (!host) {
     if (location.port === '') {
         host = location.protocol + '//' + location.hostname;
     } else {
@@ -15,20 +15,23 @@ if (host == null) {
 }
 
 var ghRequest = new GHRequest(host);
+var tmpArgs = parseUrlWithHisto();
 var bounds = {};
 
-//var nominatim = "http://open.mapquestapi.com/nominatim/v1/search.php";
-//var nominatim_reverse = "http://open.mapquestapi.com/nominatim/v1/reverse.php";
-var nominatim = "http://nominatim.openstreetmap.org/search";
-var nominatim_reverse = "http://nominatim.openstreetmap.org/reverse";
+var nominatimURL = "https://nominatim.openstreetmap.org/search";
+var nominatimReverseURL = "https://nominatim.openstreetmap.org/reverse";
 var routingLayer;
 var map;
+var menuStart;
+var menuIntermediate;
+var menuEnd;
 var browserTitle = "GraphHopper Maps - Driving Directions";
-var firstClickToRoute;
 var defaultTranslationMap = null;
 var enTranslationMap = null;
 var routeSegmentPopup = null;
 var elevationControl = null;
+var activeLayer = 'Lyrk';
+var i18nIsInitialized;
 
 var iconFrom = L.icon({
     iconUrl: './img/marker-icon-green.png',
@@ -44,33 +47,40 @@ var iconTo = L.icon({
     iconAnchor: [12, 40]
 });
 
-$(document).ready(function(e) {
+var iconInt = L.icon({
+    iconUrl: './img/marker-icon-blue.png',
+    shadowSize: [50, 64],
+    shadowAnchor: [4, 62],
+    iconAnchor: [12, 40]
+});
+
+$(document).ready(function (e) {
     // fixing cross domain support e.g in Opera
     jQuery.support.cors = true;
 
-    if (host.indexOf("graphhopper.com") > 0)
+    if (isProduction())
         $('#hosting').show();
 
     var History = window.History;
     if (History.enabled) {
-        History.Adapter.bind(window, 'statechange', function() {
+        History.Adapter.bind(window, 'statechange', function () {
             // No need for workaround?
             // Chrome and Safari always emit a popstate event on page load, but Firefox doesnt
             // https://github.com/defunkt/jquery-pjax/issues/143#issuecomment-6194330
 
             var state = History.getState();
-            console.log(state);
+            log(state);
             initFromParams(state.data, true);
         });
     }
 
-    $('#locationform').submit(function(e) {
+    $('#locationform').submit(function (e) {
         // no page reload
         e.preventDefault();
         mySubmit();
     });
 
-    $('#gpxExportButton a').click(function(e) {
+    $('#gpxExportButton a').click(function (e) {
         // no page reload
         e.preventDefault();
         exportGPX();
@@ -78,7 +88,7 @@ $(document).ready(function(e) {
 
     var urlParams = parseUrlWithHisto();
     $.when(ghRequest.fetchTranslationMap(urlParams.locale), ghRequest.getInfo())
-            .then(function(arg1, arg2) {
+            .then(function (arg1, arg2) {
                 // init translation retrieved from first call (fetchTranslationMap)
                 var translations = arg1[0];
 
@@ -88,9 +98,10 @@ $(document).ready(function(e) {
                 ghRequest.setLocale(translations["locale"]);
                 defaultTranslationMap = translations["default"];
                 enTranslationMap = translations["en"];
-                if (defaultTranslationMap == null)
+                if (!defaultTranslationMap)
                     defaultTranslationMap = enTranslationMap;
 
+                i18nIsInitialized = true;
                 initI18N();
 
                 // init bounding box from getInfo result
@@ -103,36 +114,37 @@ $(document).ready(function(e) {
                 bounds.maxLat = tmp[3];
                 var vehiclesDiv = $("#vehicles");
                 function createButton(vehicle) {
-                    var vehicle = vehicle.toLowerCase();
-                    var button = $("<button class='vehicle-btn' title='" + tr(vehicle) + "'/>")
+                    var button = $("<button class='vehicle-btn' title='" + tr(vehicle) + "'/>");
                     button.attr('id', vehicle);
                     button.html("<img src='img/" + vehicle + ".png' alt='" + tr(vehicle) + "'></img>");
-                    button.click(function() {
-                        ghRequest.vehicle = vehicle;
-                        resolveFrom();
-                        resolveTo();
+                    button.click(function () {
+                        ghRequest.initVehicle(vehicle);
+                        resolveAll()
                         routeLatLng(ghRequest);
                     });
                     return button;
                 }
 
-                if (json.supported_vehicles) {
-                    var vehicles = json.supported_vehicles;
+                if (json.features) {
+                    ghRequest.features = json.features;
+
+                    var vehicles = Object.keys(json.features);
                     if (vehicles.length > 0)
-                        ghRequest.vehicle = vehicles[0];
+                        ghRequest.initVehicle(vehicles[0]);
 
-                    for (var i = 0; i < vehicles.length; i++) {
-                        vehiclesDiv.append(createButton(vehicles[i]));
+                    for (var key in json.features) {
+                        vehiclesDiv.append(createButton(key.toLowerCase()));
                     }
                 }
 
-                initMap();
+                initMap(urlParams.layer);
 
                 // execute query
                 initFromParams(urlParams, true);
-            }, function(err) {
-                console.log(err);
-                $('#error').html('GraphHopper API offline? ' + host);
+            }, function (err) {
+                log(err);
+                $('#error').html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a>'
+                        + '<br/>Status: ' + err.statusText + '<br/>' + host);
 
                 bounds = {
                     "minLon": -180,
@@ -143,120 +155,227 @@ $(document).ready(function(e) {
                 initMap();
             });
 
-    $(window).resize(function() {
+    $(window).resize(function () {
         adjustMapSize();
     });
+    $("#locationpoints").sortable({
+        items: ".pointDiv",
+        cursor: "n-resize",
+        containment: "parent",
+        handle: ".pointFlag",
+        update: function (event, ui) {
+            var origin_index = $(ui.item[0]).data('index');
+            sortable_items = $("#locationpoints > div.pointDiv");
+            $(sortable_items).each(function (index) {
+                var data_index = $(this).data('index');
+                if (origin_index === data_index) {
+                    //log(data_index +'>'+ index);
+                    ghRequest.route.move(data_index, index);
+                    if (!routeIfAllResolved())
+                        checkInput();
+                    return false;
+                }
+            });
+        }
+    });
 
-    setAutoCompleteList("from");
-    setAutoCompleteList("to");
+    $('#locationpoints > div.pointAdd').click(function () {
+        ghRequest.route.add(new GHInput());
+        checkInput();
+    });
+
+    checkInput();
 });
 
 function initFromParams(params, doQuery) {
     ghRequest.init(params);
-    var fromAndTo = params.from && params.to;
-    var routeNow = params.point && params.point.length === 2 || fromAndTo;
+    var fromAndTo = params.from && params.to,
+            routeNow = params.point && params.point.length >= 2 || fromAndTo;
+
     if (routeNow) {
         if (fromAndTo)
-            resolveCoords(params.from, params.to, doQuery);
+            resolveCoords([params.from, params.to], doQuery);
         else
-            resolveCoords(params.point[0], params.point[1], doQuery);
+            resolveCoords(params.point, doQuery);
+    } else if (params.point && params.point.length === 1) {
+        ghRequest.from = new GHInput(params.point[0]);
+        resolve("from", ghRequest.from);
+        focus(ghRequest.from, 15, true);
     }
 }
 
-function resolveCoords(fromStr, toStr, doQuery) {
-    if (fromStr !== ghRequest.from.input || !ghRequest.from.isResolved())
-        ghRequest.from = new GHInput(fromStr);
+function resolveCoords(pointsAsStr, doQuery) {
+    for (var i = 0, l = pointsAsStr.length; i < l; i++) {
+        var pointStr = pointsAsStr[i];
+        var coords = ghRequest.route.getIndex(i);
+        if (!coords || pointStr !== coords.input || !coords.isResolved())
+            ghRequest.route.set(pointStr, i, true);
+    }
 
-    if (toStr !== ghRequest.to.input || !ghRequest.to.isResolved())
-        ghRequest.to = new GHInput(toStr);
+    checkInput();
 
-    if (ghRequest.from.lat && ghRequest.to.lat) {
-        // two mouse clicks into the map -> do not wait for resolve
-        resolveFrom();
-        resolveTo();
+    if (ghRequest.route.isResolved()) {
+        resolveAll();
         routeLatLng(ghRequest, doQuery);
     } else {
         // at least one text input from user -> wait for resolve as we need the coord for routing     
-        $.when(resolveFrom(), resolveTo()).done(function(fromArgs, toArgs) {
+        $.when.apply($, resolveAll()).done(function () {
             routeLatLng(ghRequest, doQuery);
         });
     }
 }
 
+function checkInput() {
+    var template = $('#pointTemplate').html(),
+            len = ghRequest.route.size();
+
+    // remove deleted points
+    if ($('#locationpoints > div.pointDiv').length > len) {
+        $('#locationpoints > div.pointDiv:gt(' + (len - 1) + ')').remove();
+    }
+
+    // properly unbind previously click handlers
+    $("#locationpoints .pointDelete").off();
+
+    // console.log("## new checkInput");
+    for (var i = 0; i < len; i++) {
+        var div = $('#locationpoints > div.pointDiv').eq(i);
+        // console.log(div.length + ", index:" + i + ", len:" + len);
+        if (div.length === 0) {
+            $('#locationpoints > div.pointAdd').before(nanoTemplate(template, {id: i}));
+            div = $('#locationpoints > div.pointDiv').eq(i);
+        }
+
+        var toFrom = getToFrom(i);
+        div.data("index", i);
+        div.find(".pointFlag").attr("src",
+                (toFrom === FROM) ? 'img/marker-small-green.png' :
+                ((toFrom === TO) ? 'img/marker-small-red.png' : 'img/marker-small-blue.png'));
+        if (len > 2) {
+            div.find(".pointDelete").click(function () {
+                var index = $(this).parent().data('index');
+                ghRequest.route.removeSingle(index);
+                routingLayer.clearLayers();
+                routeLatLng(ghRequest, false);
+            }).show();
+        } else {
+            div.find(".pointDelete").hide();
+        }
+
+        setAutoCompleteList(i);
+        if (i18nIsInitialized) {
+            var input = div.find(".pointInput");
+            if (i === 0)
+                $(input).attr("placeholder", tr("fromHint"));
+            else if (i === (len - 1))
+                $(input).attr("placeholder", tr("toHint"));
+            else
+                $(input).attr("placeholder", tr("viaHint"));
+        }
+    }
+
+    adjustMapSize();
+}
+
+function nanoTemplate(template, data) {
+    return template.replace(/\{([\w\.]*)\}/g, function (str, key) {
+        var keys = key.split("."), v = data[keys.shift()];
+        for (i = 0, l = keys.length; i < l; _i++)
+            v = v[this];
+        return (typeof v !== "undefined" && v !== null) ? v : "";
+    });
+}
+
 function adjustMapSize() {
     var mapDiv = $("#map");
-    var width = $(window).width() - 280;
-    if (width < 100)
-        width = $(window).width();
+    var width = $(window).width() - 295;
+    if (width < 400) {
+        width = 290;
+        mapDiv.attr("style", "position: relative; float: right;");
+    } else {
+        mapDiv.attr("style", "position: absolute; right: 0;");
+    }
     var height = $(window).height();
     mapDiv.width(width).height(height);
     $("#input").height(height);
-    $("#info").css("max-height", height - $("#input_header").height() - 25);
+    // reduce info size depending on how heigh the input_header is and reserve space for footer
+    $("#info").css("max-height", height - $("#input_header").height() - 58);
 }
 
-function initMap() {
+function initMap(selectLayer) {
     adjustMapSize();
-    console.log("init map at " + JSON.stringify(bounds));
+    log("init map at " + JSON.stringify(bounds));
 
-    // mapquest provider
-    var osmAttr = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
+    var osmAttr = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
+    // provider
+    //@see http://leaflet-extras.github.io/leaflet-providers/preview/index.html
+    var osmAttr = '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors';
 
     var tp = "ls";
     if (L.Browser.retina)
         tp = "lr";
 
-    var lyrk = L.tileLayer('http://{s}.tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
-        attribution: osmAttr + ', <a href="http://geodienste.lyrk.de/">Lyrk</a>',
+    var lyrk = L.tileLayer('https://tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
+        attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk">MapQuest</a>',
+        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
     var mapquestAerial = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk">MapQuest</a>',
+        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
+    var openMapSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
+        attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
+    });
+
     var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/">Thunderforest Transport</a>',
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var thunderCycle = L.tileLayer('http://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://www.thunderforest.com/opencyclemap/">Thunderforest Cycle</a>',
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/opencyclemap/" target="_blank">Thunderforest Cycle</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var thunderOutdoors = L.tileLayer('http://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://www.thunderforest.com/outdoors/">Thunderforest Outdoors</a>',
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/outdoors/" target="_blank">Thunderforest Outdoors</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var wrk = L.tileLayer('http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png', {
-        attribution: osmAttr + ', <a href="http://wanderreitkarte.de">WanderReitKarte</a>',
+        attribution: osmAttr + ', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',
         subdomains: ['topo4', 'topo', 'topo2', 'topo3']
     });
 
-    var osm = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
+    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
         attribution: osmAttr
     });
 
     var osmde = L.tileLayer('http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
-        attribution: osmAttr
+        attribution: osmAttr,
+        subdomains: ['a', 'b', 'c']
     });
 
-    // default
-    map = L.map('map', {
-        layers: [mapquest]
+    var mapLink = '<a href="http://www.esri.com/">Esri</a>';
+    var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
+    var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
     });
 
     var baseMaps = {
         "Lyrk": lyrk,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
+        "Esri Aerial": esriAerial,
+        "OpenMapSurfer": openMapSurfer,
         "TF Transport": thunderTransport,
         "TF Cycle": thunderCycle,
         "TF Outdoors": thunderOutdoors,
@@ -265,20 +384,92 @@ function initMap() {
         "OpenStreetMap.de": osmde
     };
 
-    //    var overlays = {
-    //        "MapQuest Hybrid": mapquest
-    //    };
+    var defaultLayer = baseMaps[selectLayer];
+    if (!defaultLayer)
+        defaultLayer = lyrk;
 
-    // no layers for small browser windows
-    if ($(window).width() > 400) {
-        L.control.layers(baseMaps/*, overlays*/).addTo(map);
-    }
+    // default
+    map = L.map('map', {
+        layers: [defaultLayer],
+        contextmenu: true,
+        contextmenuWidth: 145,
+        contextmenuItems: [{
+                separator: true,
+                index: 3,
+                state: ['set_default']
+            }, {
+                text: 'Show coordinates',
+                callback: function (e) {
+                    alert(e.latlng.lat + "," + e.latlng.lng);
+                },
+                index: 4,
+                state: [1, 2, 3]
+            }, {
+                text: 'Center map here',
+                callback: function (e) {
+                    map.panTo(e.latlng);
+                },
+                index: 5,
+                state: [1, 2, 3]
+            }],
+        zoomControl: false,
+        loadingControl: false
+    });
+
+
+    var _startItem = {
+        text: 'Set as start',
+        callback: setStartCoord,
+        disabled: false,
+        index: 0
+    };
+    var _intItem = {
+        text: 'Set intermediate',
+        callback: setIntermediateCoord,
+        disabled: true,
+        index: 1
+    };
+    var _endItem = {
+        text: 'Set as end',
+        callback: setEndCoord,
+        disabled: false,
+        index: 2
+    };
+    menuStart = map.contextmenu.insertItem(_startItem, _startItem.index);
+    menuIntermediate = map.contextmenu.insertItem(_intItem, _intItem.index);
+    menuEnd = map.contextmenu.insertItem(_endItem, _endItem.index);
+
+    var zoomControl = new L.Control.Zoom({position: 'topleft'}).addTo(map);
+
+    new L.Control.loading({
+        zoomControl: zoomControl
+    }).addTo(map);
+
+    map.contextmenu.addSet({
+        name: 'markers',
+        state: 2
+    });
+
+    map.contextmenu.addSet({
+        name: 'path',
+        state: 3
+    });
+
+    L.control.layers(baseMaps/*, overlays*/).addTo(map);
+
+    map.on('baselayerchange', function (a) {
+        if (a.name)
+            activeLayer = a.name;
+    });
 
     L.control.scale().addTo(map);
 
     map.fitBounds(new L.LatLngBounds(new L.LatLng(bounds.minLat, bounds.minLon),
             new L.LatLng(bounds.maxLat, bounds.maxLon)));
 
+    if (isProduction())
+        map.setView(new L.LatLng(0, 0), 2);
+
     map.attributionControl.setPrefix('');
 
     var myStyle = {
@@ -305,29 +496,82 @@ function initMap() {
         }).addTo(map);
 
     routingLayer = L.geoJson().addTo(map);
-    routingLayer.options = {style: {color: "#00cc33", "weight": 5, "opacity": 0.6}};
-
-    firstClickToRoute = true;
-    function onMapClick(e) {
-        var latlng = e.latlng;
-        latlng.lng = makeValidLng(latlng.lng);
-        if (firstClickToRoute) {
-            // set start point
-            routingLayer.clearLayers();
-            firstClickToRoute = false;
-            ghRequest.from.setCoord(latlng.lat, latlng.lng);
-            resolveFrom();
-        } else {
-            // set end point
-            ghRequest.to.setCoord(latlng.lat, latlng.lng);
-            resolveTo();
-            // do not wait for resolving
-            routeLatLng(ghRequest);
-            firstClickToRoute = true;
-        }
-    }
+    routingLayer.options = {
+        style: {color: "#00cc33", "weight": 5, "opacity": 0.6}, // route color and style
+        contextmenu: true,
+        contextmenuItems: [{
+                text: 'Route ',
+                disabled: true,
+                index: 0,
+                state: 3
+            }, {
+                text: 'Set intermediate',
+                callback: setIntermediateCoord,
+                index: 1,
+                state: 3
+            }, {
+                separator: true,
+                index: 2,
+                state: 3
+            }],
+        contextmenuAtiveState: 3
+    };
+    /*
+     routingLayer.options = {style: {color: "#1F40C4", "weight": 5, "opacity": 0.6}, onEachFeature: function (feature, layer) {
+     layer.on('contextmenu', function (e) {
+     alert('The GeoJSON layer has been clicked');
+     });
+     }}; // route color and style
+     */
+}
+
+function setToStart(e) {
+    var latlng = e.target.getLatLng(),
+            index = ghRequest.route.getIndexByCoord(latlng);
+    ghRequest.route.move(index, 0);
+    routeIfAllResolved();
+}
+
+function setToEnd(e) {
+    var latlng = e.target.getLatLng(),
+            index = ghRequest.route.getIndexByCoord(latlng);
+    ghRequest.route.move(index, -1);
+    routeIfAllResolved();
+}
+
+function setStartCoord(e) {
+    ghRequest.route.set(e.latlng, 0);
+    resolveFrom();
+    routeIfAllResolved();
+}
 
-    map.on('click', onMapClick);
+function setIntermediateCoord(e) {
+    var index = ghRequest.route.size() - 1;
+    ghRequest.route.add(e.latlng, index);
+    resolveIndex(index);
+    routeIfAllResolved();
+}
+
+function deleteCoord(e) {
+    var latlng = e.target.getLatLng();
+    ghRequest.route.removeSingle(latlng);
+    routingLayer.clearLayers();
+    routeLatLng(ghRequest, false);
+}
+
+function setEndCoord(e) {
+    var index = ghRequest.route.size() - 1;
+    ghRequest.route.set(e.latlng, index);
+    resolveTo();
+    routeIfAllResolved();
+}
+
+function routeIfAllResolved(doQuery) {
+    if (ghRequest.route.isResolved()) {
+        routeLatLng(ghRequest, doQuery);
+        return true;
+    }
+    return false;
 }
 
 function makeValidLng(lon) {
@@ -338,23 +582,81 @@ function makeValidLng(lon) {
     return (lon - 180) % 360 + 180;
 }
 
-function setFlag(coord, isFrom) {
+var FROM = 'from', TO = 'to';
+function getToFrom(index) {
+    if (index === 0)
+        return FROM;
+    else if (index === (ghRequest.route.size() - 1))
+        return TO;
+    return -1;
+}
+
+function setFlag(coord, index) {
     if (coord.lat) {
-        var marker = L.marker([coord.lat, coord.lng], {
-            icon: (isFrom ? iconFrom : iconTo),
-            draggable: true
-        }).addTo(routingLayer).bindPopup(isFrom ? "Start" : "End");
-        marker.on('dragend', function(e) {
+        var toFrom = getToFrom(index),
+                marker = L.marker([coord.lat, coord.lng], {
+                    icon: ((toFrom === FROM) ? iconFrom : ((toFrom === TO) ? iconTo : iconInt)),
+                    draggable: true,
+                    contextmenu: true,
+                    contextmenuItems: [{
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
+                            disabled: true,
+                            index: 0,
+                            state: 2
+                        }, {
+                            text: 'Set as ' + ((toFrom !== TO) ? 'End' : 'Start'),
+                            callback: (toFrom !== TO) ? setToEnd : setToStart,
+                            index: 2,
+                            state: 2
+                        }, {
+                            text: 'Delete from Route',
+                            callback: deleteCoord,
+                            index: 3,
+                            state: 2,
+                            disabled: (toFrom !== -1 && ghRequest.route.size() === 2) ? true : false // prevent to and from
+                        }, {
+                            separator: true,
+                            index: 4,
+                            state: 2
+                        }],
+                    contextmenuAtiveState: 2
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
+        // intercept openPopup
+        marker._openPopup = marker.openPopup;
+        marker.openPopup = function () {
+            var latlng = this.getLatLng(),
+                    locCoord = ghRequest.route.getIndexFromCoord(latlng),
+                    content;
+            if (locCoord.resolvedList && locCoord.resolvedList[0] && locCoord.resolvedList[0].locationDetails) {
+                var address = locCoord.resolvedList[0].locationDetails;
+                content =
+                        ((address.road) ? address.road + ', ' : '') +
+                        ((address.postcode) ? address.postcode + ', ' : '') +
+                        ((address.city) ? address.city + ', ' : '') +
+                        ((address.country) ? address.country : '')
+                        ;
+                // at last update the content and update
+                this._popup.setContent(content).update();
+            }
+            this._openPopup();
+        };
+        var _tempItem = {
+            text: 'Set as Start',
+            callback: setToStart,
+            index: 1,
+            state: 2
+        };
+        if (toFrom === -1)
+            marker.options.contextmenuItems.push(_tempItem);// because the Mixin.ContextMenu isn't initialized
+        marker.on('dragend', function (e) {
             routingLayer.clearLayers();
             // inconsistent leaflet API: event.target.getLatLng vs. mouseEvent.latlng?
             var latlng = e.target.getLatLng();
-            if (isFrom) {
-                ghRequest.from.setCoord(latlng.lat, latlng.lng);
-                resolveFrom();
-            } else {
-                ghRequest.to.setCoord(latlng.lat, latlng.lng);
-                resolveTo();
-            }
+            hideAutoComplete();
+            ghRequest.route.getIndex(index).setCoord(latlng.lat, latlng.lng);
+            resolveIndex(index);
             // do not wait for resolving and avoid zooming when dragging
             ghRequest.do_zoom = false;
             routeLatLng(ghRequest, false);
@@ -363,29 +665,62 @@ function setFlag(coord, isFrom) {
 }
 
 function resolveFrom() {
-    setFlag(ghRequest.from, true);
-    return resolve("from", ghRequest.from);
+    return resolveIndex(0);
 }
 
 function resolveTo() {
-    setFlag(ghRequest.to, false);
-    return resolve("to", ghRequest.to);
+    return resolveIndex((ghRequest.route.size() - 1));
+}
+
+function resolveIndex(index) {
+    setFlag(ghRequest.route.getIndex(index), index);
+    if (index === 0) {
+        if (!ghRequest.to.isResolved())
+            map.contextmenu.setDisabled(menuStart, true);
+        else
+            map.contextmenu.setDisabled(menuStart, false);
+    } else if (index === (ghRequest.route.size() - 1)) {
+        if (!ghRequest.from.isResolved())
+            map.contextmenu.setDisabled(menuEnd, true);
+        else
+            map.contextmenu.setDisabled(menuEnd, false);
+    }
+
+    return resolve(index, ghRequest.route.getIndex(index));
 }
 
-function resolve(fromOrTo, locCoord) {
-    $("#" + fromOrTo + "Flag").hide();
-    $("#" + fromOrTo + "Indicator").show();
-    $("#" + fromOrTo + "Input").val(locCoord.input);
+function resolveAll() {
+    var ret = [];
+    for (var i = 0, l = ghRequest.route.size(); i < l; i++) {
+        ret[i] = resolveIndex(i);
+    }
+    return ret;
+}
 
-    return createAmbiguityList(locCoord).done(function(arg1) {
-        var errorDiv = $("#" + fromOrTo + "ResolveError");
+function flagAll() {
+    for (var i = 0, l = ghRequest.route.size(); i < l; i++) {
+        setFlag(ghRequest.route.getIndex(i), i);
+    }
+}
+
+function resolve(index, locCoord) {
+    var div = $('#locationpoints > div.pointDiv').eq(index);
+    $(div).find(".pointFlag").hide();
+    $(div).find(".pointIndicator").show();
+    $(div).find(".pointInput").val(locCoord.input);
+
+    return createAmbiguityList(locCoord).always(function () {
+        var errorDiv = $(div).find(".pointResolveError");
         errorDiv.empty();
-        
-        if (locCoord.error)
-            errorDiv.text(locCoord.error);
 
-        $("#" + fromOrTo + "Indicator").hide();
-        $("#" + fromOrTo + "Flag").show();
+        if (locCoord.error) {
+            errorDiv.show();
+            errorDiv.text(locCoord.error).fadeOut(5000);
+            locCoord.error = '';
+        }
+
+        $(div).find(".pointIndicator").hide();
+        $(div).find(".pointFlag").show();
         return locCoord;
     });
 }
@@ -395,99 +730,94 @@ function resolve(fromOrTo, locCoord) {
  * coordinates.
  */
 function createAmbiguityList(locCoord) {
-    // make example working even if nominatim service is down
-    if (locCoord.input.toLowerCase() === "madrid") {
-        locCoord.lat = 40.416698;
-        locCoord.lng = -3.703551;
-        locCoord.locationDetails = formatLocationEntry({city: "Madrid", country: "Spain"});
-        locCoord.resolvedList = [locCoord];
-    }
-    if (locCoord.input.toLowerCase() === "moscow") {
-        locCoord.lat = 55.751608;
-        locCoord.lng = 37.618775;
-        locCoord.locationDetails = formatLocationEntry({road: "Borowizki-Strae", city: "Moscow", country: "Russian Federation"});
-        locCoord.resolvedList = [locCoord];
-    }
+    locCoord.error = "";
+    locCoord.resolvedList = [];
+    var timeout = 3000;
 
     if (locCoord.isResolved()) {
+        // if we changed only another location no need to look this up again
         var tmpDefer = $.Deferred();
         tmpDefer.resolve([locCoord]);
         return tmpDefer;
-    }
-
-    locCoord.error = "";
-    locCoord.resolvedList = [];
-    var timeout = 3000;
-    if (locCoord.lat && locCoord.lng) {
-        var url = nominatim_reverse + "?lat=" + locCoord.lat + "&lon="
+    } else if (locCoord.lat && locCoord.lng) {
+        var url = nominatimReverseURL + "?lat=" + locCoord.lat + "&lon="
                 + locCoord.lng + "&format=json&zoom=16";
         return $.ajax({
             url: url,
             type: "GET",
             dataType: "json",
             timeout: timeout
-        }).fail(function(err) {
-            // not critical => no alert
-            locCoord.error = "Error while looking up coordinate";
-            console.log(err);
-        }).pipe(function(json) {
-            if (!json) {
-                locCoord.error = "No description found for coordinate";
-                return [locCoord];
-            }
-            var address = json.address;
-            var point = {};
-            point.lat = locCoord.lat;
-            point.lng = locCoord.lng;
-            point.bbox = json.boundingbox;
-            point.positionType = json.type;
-            point.locationDetails = formatLocationEntry(address);
-            // point.address = json.address;
-            locCoord.resolvedList.push(point);
-            return [locCoord];
-        });
+        }).then(
+                function (json) {
+                    if (!json) {
+                        locCoord.error = "No description found for coordinate";
+                        return [locCoord];
+                    }
+                    var address = json.address;
+                    var point = {};
+                    point.lat = locCoord.lat;
+                    point.lng = locCoord.lng;
+                    point.bbox = json.boundingbox;
+                    point.positionType = json.type;
+                    point.locationDetails = formatLocationEntry(address);
+                    // point.address = json.address;
+                    locCoord.resolvedList.push(point);
+                    return [locCoord];
+                },
+                function (err) {
+                    log("[nominatim_reverse] Error while looking up coordinate lat=" + locCoord.lat + "&lon=" + locCoord.lng);
+                    locCoord.error = "Problem while looking up location.";
+                    return [locCoord];
+                }
+        );
     } else {
-        return doGeoCoding(locCoord.input, 10, timeout).pipe(function(jsonArgs) {
-            if (!jsonArgs || jsonArgs.length == 0) {
-                locCoord.error = "No area description found";
-                return [locCoord];
-            }
-            var prevImportance = jsonArgs[0].importance;
-            var address;
-            for (var index in jsonArgs) {
-                var json = jsonArgs[index];
-                // if we have already some results ignore unimportant
-                if (prevImportance - json.importance > 0.4)
-                    break;
-
-                // de-duplicate via ignoring boundary stuff => not perfect as 'Freiberg' would no longer be correct
-                // if (json.type === "administrative")
-                //    continue;
-
-                // if no different properties => skip!
-                if (address && JSON.stringify(address) === JSON.stringify(json.address))
-                    continue;
-
-                address = json.address;
-                prevImportance = json.importance;
-                var point = {};
-                point.lat = round(json.lat);
-                point.lng = round(json.lon);
-                point.locationDetails = formatLocationEntry(address);
-                point.bbox = json.boundingbox;
-                point.positionType = json.type;
-                locCoord.resolvedList.push(point);
-            }
-            if (locCoord.resolvedList.length === 0) {
-                locCoord.error = "No area description found";
-                return [locCoord];
-            }
-            var list = locCoord.resolvedList;
-            locCoord.lat = list[0].lat;
-            locCoord.lng = list[0].lng;
-            // locCoord.input = dataToText(list[0]);
-            return [locCoord];
-        });
+        return doGeoCoding(locCoord.input, 10, timeout).then(
+                function (jsonArgs) {
+                    if (!jsonArgs || jsonArgs.length === 0) {
+                        locCoord.error = "No area description found";
+                        return [locCoord];
+                    }
+                    var prevImportance = jsonArgs[0].importance;
+                    var address;
+                    for (var index in jsonArgs) {
+                        var json = jsonArgs[index];
+                        // if we have already some results ignore unimportant
+                        if (prevImportance - json.importance > 0.4)
+                            break;
+
+                        // de-duplicate via ignoring boundary stuff => not perfect as 'Freiberg' would no longer be correct
+                        // if (json.type === "administrative")
+                        //    continue;
+
+                        // if no different properties => skip!
+                        if (address && JSON.stringify(address) === JSON.stringify(json.address))
+                            continue;
+
+                        address = json.address;
+                        prevImportance = json.importance;
+                        var point = {};
+                        point.lat = round(json.lat);
+                        point.lng = round(json.lon);
+                        point.locationDetails = formatLocationEntry(address);
+                        point.bbox = json.boundingbox;
+                        point.positionType = json.type;
+                        locCoord.resolvedList.push(point);
+                    }
+                    if (locCoord.resolvedList.length === 0) {
+                        locCoord.error = "No area description found";
+                        return [locCoord];
+                    }
+                    var list = locCoord.resolvedList;
+                    locCoord.lat = list[0].lat;
+                    locCoord.lng = list[0].lng;
+                    // locCoord.input = dataToText(list[0]);
+                    return [locCoord];
+                },
+                function () {
+                    locCoord.error = "Problem while looking up address";
+                    return [locCoord];
+                }
+        );
     }
 }
 
@@ -500,6 +830,8 @@ function insComma(textA, textB) {
 function formatLocationEntry(address) {
     var locationDetails = {};
     var text = "";
+    if (!address)
+        return locationDetails;
     if (address.road) {
         text = address.road;
         if (address.house_number) {
@@ -510,7 +842,8 @@ function formatLocationEntry(address) {
         locationDetails.road = text;
     }
 
-    locationDetails.postcode = address.postcode;
+    if (address.postcode)
+        locationDetails.postcode = address.postcode;
     locationDetails.country = address.country;
 
     if (address.city || address.suburb || address.town
@@ -546,7 +879,7 @@ function doGeoCoding(input, limit, timeout) {
     // see https://trac.openstreetmap.org/ticket/4683 why limit=3 and not 1
     if (!limit)
         limit = 10;
-    var url = nominatim + "?format=json&addressdetails=1&q=" + encodeURIComponent(input) + "&limit=" + limit;
+    var url = nominatimURL + "?format=json&addressdetails=1&q=" + encodeURIComponent(input) + "&limit=" + limit;
     if (bounds.initialized) {
         // minLon, minLat, maxLon, maxLat => left, top, right, bottom
         url += "&bounded=1&viewbox=" + bounds.minLon + "," + bounds.maxLat + "," + bounds.maxLon + "," + bounds.minLat;
@@ -557,30 +890,32 @@ function doGeoCoding(input, limit, timeout) {
         type: "GET",
         dataType: "json",
         timeout: timeout
-    }).fail(createCallback("[nominatim] Problem while looking up location " + input));
+    }).fail(
+            createCallback("[nominatim] Problem while looking up location " + input)
+            );
 }
 
 function createCallback(errorFallback) {
-    return function(err) {
-        console.log(errorFallback + " " + JSON.stringify(err));
+    return function (err) {
+        log(errorFallback + " " + JSON.stringify(err));
     };
 }
 
-function focusWithBounds(coord, bbox, isFrom) {
+function focusWithBounds(coord, bbox, index) {
     routingLayer.clearLayers();
     // bbox needs to be in the none-geojson format!?
     // [[lat, lng], [lat2, lng2], ...]
     map.fitBounds(new L.LatLngBounds(bbox));
-    setFlag(coord, isFrom);
+    setFlag(coord, index);
 }
 
-function focus(coord, zoom, isFrom) {
+function focus(coord, zoom, index) {
     if (coord.lat && coord.lng) {
         if (!zoom)
             zoom = 11;
         routingLayer.clearLayers();
         map.setView(new L.LatLng(coord.lat, coord.lng), zoom);
-        setFlag(coord, isFrom);
+        setFlag(coord, index);
     }
 }
 function routeLatLng(request, doQuery) {
@@ -588,13 +923,14 @@ function routeLatLng(request, doQuery) {
     var doZoom = request.do_zoom;
     request.do_zoom = true;
 
-    var urlForHistory = request.createFullURL();
+    var urlForHistory = request.createHistoryURL() + "&layer=" + activeLayer;
+
     // not enabled e.g. if no cookies allowed (?)
     // if disabled we have to do the query and cannot rely on the statechange history event    
     if (!doQuery && History.enabled) {
         // 2. important workaround for encoding problems in history.js
         var params = parseUrl(urlForHistory);
-        console.log(params);
+        log(params);
         params.do_zoom = doZoom;
         // force a new request even if we have the same parameters
         params.mathRandom = Math.random();
@@ -607,30 +943,24 @@ function routeLatLng(request, doQuery) {
     var descriptionDiv = $("<div/>");
     $("#info").append(descriptionDiv);
 
-    var from = request.from.toString();
-    var to = request.to.toString();
-    if (!from || !to) {
-        descriptionDiv.html('<small>' + tr('locationsNotFound') + '</small>');
-        return;
-    }
-
     if (elevationControl)
         elevationControl.clear();
 
     routingLayer.clearLayers();
-    setFlag(request.from, true);
-    setFlag(request.to, false);
+    flagAll();
+
+    map.contextmenu.setDisabled(menuIntermediate, false);
 
     $("#vehicles button").removeClass("selectvehicle");
     $("button#" + request.vehicle.toLowerCase()).addClass("selectvehicle");
 
-    var urlForAPI = request.createURL("point=" + from + "&point=" + to);
+    var urlForAPI = request.createURL();
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
-    request.doRequest(urlForAPI, function(json) {
+    request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
         if (json.info.errors) {
             var tmpErrors = json.info.errors;
-            console.log(tmpErrors);
+            log(tmpErrors);
             for (var m = 0; m < tmpErrors.length; m++) {
                 descriptionDiv.append("<div class='error'>" + tmpErrors[m].message + "</div>");
             }
@@ -643,7 +973,7 @@ function routeLatLng(request, doQuery) {
             "geometry": path.points
         };
 
-        if (path.points_dimension === 3) {
+        if (request.hasElevation()) {
             if (elevationControl === null) {
                 elevationControl = L.control.elevation({
                     position: "bottomright",
@@ -690,7 +1020,7 @@ function routeLatLng(request, doQuery) {
         var tmpDist = createDistanceString(path.distance);
         descriptionDiv.append(tr("routeInfo", [tmpDist, tmpTime]));
 
-        $('.defaulting').each(function(index, element) {
+        $('.defaulting').each(function (index, element) {
             $(element).css("color", "black");
         });
 
@@ -707,8 +1037,8 @@ function routeLatLng(request, doQuery) {
             $("#info").append(instructionsElement);
 
             if (partialInstr) {
-                var moreDiv = $("<button id='moreButton'>More...</button>");
-                moreDiv.click(function() {
+                var moreDiv = $("<button id='moreButton'>" + tr("moreButton") + "..</button>");
+                moreDiv.click(function () {
                     moreDiv.remove();
                     for (var m = len; m < path.instructions.length; m++) {
                         var instr = path.instructions[m];
@@ -723,25 +1053,25 @@ function routeLatLng(request, doQuery) {
             hiddenDiv.hide();
 
             var toggly = $("<button id='expandDetails'>+</button>");
-            toggly.click(function() {
+            toggly.click(function () {
                 hiddenDiv.toggle();
             });
             $("#info").append(toggly);
-            var infoStr = "took: " + round(json.info.took, 1000) + "s"
+            var infoStr = "took: " + round(json.info.took / 1000, 1000) + "s"
                     + ", points: " + path.points.coordinates.length;
 
             hiddenDiv.append("<span>" + infoStr + "</span>");
 
-            var exportLink = $("#exportLink a");
+            var exportLink = $("#export-link a");
             exportLink.attr('href', urlForHistory);
             var startOsmLink = $("<a>start</a>");
-            startOsmLink.attr("href", "http://www.openstreetmap.org/?zoom=14&mlat=" + request.from.lat + "&mlon=" + request.from.lng);
+            startOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.from.lat + "&mlon=" + request.from.lng);
             var endOsmLink = $("<a>end</a>");
-            endOsmLink.attr("href", "http://www.openstreetmap.org/?zoom=14&mlat=" + request.to.lat + "&mlon=" + request.to.lng);
+            endOsmLink.attr("href", "https://www.openstreetmap.org/?zoom=14&mlat=" + request.to.lat + "&mlon=" + request.to.lng);
             hiddenDiv.append("<br/><span>View on OSM: </span>").append(startOsmLink).append(endOsmLink);
 
             var osrmLink = $("<a>OSRM</a>");
-            osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + from + "&loc=" + to);
+            osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + request.from + "&loc=" + request.to);
             hiddenDiv.append("<br/><span>Compare with: </span>");
             hiddenDiv.append(osrmLink);
             var googleLink = $("<a>Google</a> ");
@@ -750,16 +1080,16 @@ function routeLatLng(request, doQuery) {
             if (request.vehicle.toUpperCase() === "FOOT") {
                 addToGoogle = "&dirflg=w";
                 addToBing = "&mode=W";
-            } else if ((request.vehicle.toUpperCase() === "BIKE") ||
-                    (request.vehicle.toUpperCase() === "RACINGBIKE") ||
+            } else if ((request.vehicle.toUpperCase().indexOf("BIKE") >= 0) ||
                     (request.vehicle.toUpperCase() === "MTB")) {
                 addToGoogle = "&dirflg=b";
                 // ? addToBing = "&mode=B";
             }
-            googleLink.attr("href", "http://maps.google.com/?q=from:" + from + "+to:" + to + addToGoogle);
+
+            googleLink.attr("href", "https://maps.google.com/?saddr=" + request.from + "&daddr=" + request.to + addToGoogle);
             hiddenDiv.append(googleLink);
             var bingLink = $("<a>Bing</a> ");
-            bingLink.attr("href", "http://www.bing.com/maps/default.aspx?rtp=adr." + from + "~adr." + to + addToBing);
+            bingLink.attr("href", "https://www.bing.com/maps/default.aspx?rtp=adr." + request.from + "~adr." + request.to + addToBing);
             hiddenDiv.append(bingLink);
             $("#info").append(hiddenDiv);
         }
@@ -816,9 +1146,19 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "sharp_right";
     else if (sign === 4)
         sign = "marker-icon-red";
+    else if (sign === 5)
+        sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
+    if (instr.annotationText) {
+        if (!title)
+            title = instr.annotationText;
+        else
+            title = title + ", " + instr.annotationText;
+    }
     var distance = instr.distance;
     var str = "<td class='instr_title'>" + title + "</td>";
 
@@ -837,7 +1177,7 @@ function addInstruction(main, instr, instrIndex, lngLat) {
     var instructionDiv = $("<tr class='instruction'/>");
     instructionDiv.html(str);
     if (lngLat) {
-        instructionDiv.click(function() {
+        instructionDiv.click(function () {
             if (routeSegmentPopup)
                 map.removeLayer(routeSegmentPopup);
 
@@ -869,10 +1209,6 @@ function parseUrlWithHisto() {
     return parseUrl(window.location.search);
 }
 
-function parseUrlAndRequest() {
-    return parseUrl(window.location.search);
-}
-
 function parseUrl(query) {
     var index = query.indexOf('?');
     if (index >= 0)
@@ -887,40 +1223,81 @@ function parseUrl(query) {
         var key = vars[i].substring(0, indexPos);
         var value = vars[i].substring(indexPos + 1);
         value = decodeURIComponent(value.replace(/\+/g, ' '));
+        if (value === "")
+            continue;
 
-        if (typeof res[key] === "undefined")
-            res[key] = value;
-        else if (typeof res[key] === "string") {
+        if (key === "point" && !res[key]) {
+            res[key] = [value];
+        } else if (typeof res[key] === "string") {
             var arr = [res[key], value];
             res[key] = arr;
-        } else
+        } else if (typeof res[key] === "undefined") {
+            if (value === 'true') {
+                res[key] = true;
+            } else if (value === 'false') {
+                res[key] = false;
+            } else {
+                var tmp = Number(value);
+                if (isNaN(tmp))
+                    res[key] = value;
+                else
+                    res[key] = Number(value);
+            }
+        } else {
             res[key].push(value);
-
+        }
     }
     return res;
 }
 
 function mySubmit() {
-    var fromStr = $("#fromInput").val();
-    var toStr = $("#toInput").val();
-    if (toStr == "To" && fromStr == "From") {
+    var fromStr,
+            toStr,
+            viaStr,
+            allStr = [],
+            inputOk = true;
+    var location_points = $("#locationpoints > div.pointDiv > input.pointInput");
+    var len = location_points.size();
+    $.each(location_points, function (index) {
+        if (index === 0) {
+            fromStr = $(this).val();
+            if (fromStr !== tr("fromHint") && fromStr !== "")
+                allStr.push(fromStr);
+            else
+                inputOk = false;
+        } else if (index === (len - 1)) {
+            toStr = $(this).val();
+            if (toStr !== tr("toHint") && toStr !== "")
+                allStr.push(toStr);
+            else
+                inputOk = false;
+        } else {
+            viaStr = $(this).val();
+            if (viaStr !== tr("viaHint") && viaStr !== "")
+                allStr.push(viaStr);
+            else
+                inputOk = false;
+        }
+    });
+    if (!inputOk) {
         // TODO print warning
         return;
     }
-    if (fromStr == "From") {
+    if (fromStr === tr("fromHint")) {
         // no special function
         return;
     }
-    if (toStr == "To") {
+    if (toStr === tr("toHint")) {
         // lookup area
-        ghRequest.from = new GHInput(fromStr);
-        $.when(resolveFrom()).done(function() {
-            focus(ghRequest.from);
+        ghRequest.from.setStr(fromStr);
+        $.when(resolveFrom()).done(function () {
+            focus(ghRequest.from, null, 0);
         });
         return;
     }
     // route!
-    resolveCoords(fromStr, toStr);
+    if (inputOk)
+        resolveCoords(allStr);
 }
 
 function floor(val, precision) {
@@ -940,19 +1317,19 @@ function tr(key, args) {
 }
 
 function tr2(key, args) {
-    if (key == null) {
-        console.log("ERROR: key was null?");
+    if (key === null) {
+        log("ERROR: key was null?");
         return "";
     }
-    if (defaultTranslationMap == null) {
-        console.log("ERROR: defaultTranslationMap was not initialized?");
+    if (defaultTranslationMap === null) {
+        log("ERROR: defaultTranslationMap was not initialized?");
         return key;
     }
     key = key.toLowerCase();
     var val = defaultTranslationMap[key];
-    if (val == null && enTranslationMap)
+    if (!val && enTranslationMap)
         val = enTranslationMap[key];
-    if (val == null)
+    if (!val)
         return key;
 
     return stringFormat(val, args);
@@ -964,15 +1341,15 @@ function stringFormat(str, args) {
 
     if (str.indexOf("%1$s") >= 0) {
         // with position arguments ala %2$s
-        return str.replace(/\%(\d+)\$s/g, function(match, matchingNum) {
+        return str.replace(/\%(\d+)\$s/g, function (match, matchingNum) {
             matchingNum--;
-            return typeof args[matchingNum] != 'undefined' ? args[matchingNum] : match;
+            return typeof args[matchingNum] !== 'undefined' ? args[matchingNum] : match;
         });
     } else {
         // no position so only values ala %s
         var matchingNum = 0;
-        return str.replace(/\%s/g, function(match) {
-            var val = typeof args[matchingNum] != 'undefined' ? args[matchingNum] : match;
+        return str.replace(/\%s/g, function (match) {
+            var val = typeof args[matchingNum] !== 'undefined' ? args[matchingNum] : match;
             matchingNum++;
             return val;
         });
@@ -981,18 +1358,31 @@ function stringFormat(str, args) {
 
 function initI18N() {
     $('#searchButton').attr("value", tr("searchButton"));
-    $('#fromInput').attr("placeholder", tr("fromHint"));
-    $('#toInput').attr("placeholder", tr("toHint"));
+    location_points = $("#locationpoints > div.pointDiv > input.pointInput");
+    var l = location_points.size();
+    $(location_points).each(function (index) {
+        if (index === 0)
+            $(this).attr("placeholder", tr("fromHint"));
+        else if (index === (l - 1))
+            $(this).attr("placeholder", tr("toHint"));
+        else
+            $(this).attr("placeholder", tr("viaHint"));
+    });
+    $('#gpxExportButton').attr("title", tr("gpxExportButton"));
 }
 
 function exportGPX() {
-    if (ghRequest.from.isResolved() && ghRequest.to.isResolved())
+    if (ghRequest.route.isResolved())
         window.open(ghRequest.createGPXURL());
     return false;
 }
 
-function getAutoCompleteDiv(fromOrTo) {
-    return $('#' + fromOrTo + 'Input');
+function getAutoCompleteDiv(index) {
+    return $('#locationpoints > div.pointDiv').eq(index).find(".pointInput");
+}
+
+function hideAutoComplete() {
+    $(':input[id$="_Input"]').autocomplete().hide();
 }
 
 function formatValue(orig, query) {
@@ -1000,14 +1390,12 @@ function formatValue(orig, query) {
     return orig.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>');
 }
 
-function setAutoCompleteList(fromOrTo, ghRequestLoc) {
-    var isFrom = fromOrTo === "from";
-    var pointIndex = isFrom ? 1 : 2;
-    var myAutoDiv = getAutoCompleteDiv(fromOrTo);
-    
+function setAutoCompleteList(index) {
+    var myAutoDiv = getAutoCompleteDiv(index);
+
     var options = {
-        containerClass: "complete-" + pointIndex,
-        /* as we use jsonp we need to set the timeout to a small value */        
+        containerClass: "autocomplete",
+        /* as we use can potentially use jsonp we need to set the timeout to a small value */
         timeout: 1000,
         /* avoid too many requests when typing quickly */
         deferRequestBy: 5,
@@ -1018,49 +1406,61 @@ function setAutoCompleteList(fromOrTo, ghRequestLoc) {
         triggerSelectOnValidInput: false,
         autoSelectFirst: false,
         paramName: "q",
-        dataType: "jsonp",
-        serviceUrl: function() {
-            return ghRequest.createGeocodeURL();
+        dataType: ghRequest.dataType,
+        onSearchStart: function (params) {
+            // query server only if not a parsable point (i.e. format lat,lon)
+            var val = new GHInput(params.q).lat;
+            return val === undefined;
+        },
+        serviceUrl: function () {
+            // see https://graphhopper.com/#directions-api
+            return ghRequest.createGeocodeURL(host);
         },
-        transformResult: function(response, originalQuery) {
+        transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
-        onSearchError: function(element, q, jqXHR, textStatus, errorThrown) {
-            console.log(element + ", " + JSON.stringify(q) + ", textStatus " + textStatus + ", " + errorThrown);
+        onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
+            // too many errors if interrupted console.log(element + ", " + JSON.stringify(q) + ", textStatus " + textStatus + ", " + errorThrown);
         },
-        formatResult: function(suggestion, currInput) {
+        formatResult: function (suggestion, currInput) {
             // avoid highlighting for now as this breaks the html sometimes
             return dataToHtml(suggestion.data, currInput);
         },
-        onSelect: function(suggestion) {
+        onSelect: function (suggestion) {
             options.onPreSelect(suggestion);
         },
-        onPreSelect: function(suggestion) {
-            var req = ghRequest.to;
-            if (isFrom)
-                req = ghRequest.from;
+        onPreSelect: function (suggestion) {
+            var req = ghRequest.route.getIndex(index);
 
             myAutoDiv.autocomplete().disable();
-            
+
             var point = suggestion.data.point;
-            req.setCoord(point.lat, point.lng);            
-            
-            req.input = suggestion.value;            
-            if (ghRequest.from.isResolved() && ghRequest.to.isResolved())
-                routeLatLng(ghRequest);
-            else
-                focus(req, 15, isFrom);
-            
+            req.setCoord(point.lat, point.lng);
+
+            req.input = suggestion.value;
+            if (!routeIfAllResolved(true))
+                focus(req, 15, index);
+
             myAutoDiv.autocomplete().enable();
         }
     };
-    
+
     myAutoDiv.autocomplete(options);
+
+    // with the following more stable code we cannot click on suggestions anylonger
+//    $("#" + fromOrTo + "Input").focusout(function() {
+//        myAutoDiv.autocomplete().disable();
+//        myAutoDiv.autocomplete().hide();
+//    });
+//    $("#" + fromOrTo + "Input").focusin(function() {
+//        myAutoDiv.autocomplete().enable();
+//    });
 }
 
 function dataToHtml(data, query) {
@@ -1092,12 +1492,19 @@ function dataToText(data) {
     var text = "";
     if (data.name)
         text += data.name;
-    
+
+    if (data.postcode)
+        text = insComma(text, data.postcode);
+
     // make sure name won't be duplicated
     if (data.city && text.indexOf(data.city) < 0)
         text = insComma(text, data.city);
-    
+
     if (data.country && text.indexOf(data.country) < 0)
         text = insComma(text, data.country);
     return text;
 }
+
+function isProduction() {
+    return host.indexOf("graphhopper.com") > 0;
+}
\ No newline at end of file
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTest.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
similarity index 84%
rename from web/src/test/java/com/graphhopper/http/BaseServletTest.java
rename to web/src/test/java/com/graphhopper/http/BaseServletTester.java
index 12995eb1ce..b1c47148fe 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTest.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -20,7 +20,6 @@
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Module;
-import com.google.inject.servlet.GuiceFilter;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
 import org.json.JSONObject;
@@ -30,10 +29,10 @@
 /**
  * @author Peter Karich
  */
-public class BaseServletTest
+public class BaseServletTester
 {
     private static GHServer server;
-    protected static Logger logger = LoggerFactory.getLogger(GraphHopperServletIT.class);
+    protected static Logger logger = LoggerFactory.getLogger(BaseServletTester.class);
     protected static int port;
     protected Injector injector;
 
@@ -45,28 +44,23 @@ public void setUpGuice( Module... modules )
     /**
      * This method will start jetty with andorra area loaded as OSM.
      */
-    public void setUpJetty()
+    public void setUpJetty( CmdArgs args )
     {
         if (injector != null)
             throw new UnsupportedOperationException("do not call guice before");
 
-        bootJetty(3);
+        bootJetty(args, 3);
     }
 
-    private void bootJetty( int retryCount )
+    private void bootJetty( CmdArgs args, int retryCount )
     {
         if (server != null)
             return;
 
-        CmdArgs args = new CmdArgs().
-                put("config", "../config-example.properties").
-                put("osmreader.osm", "../core/files/andorra.osm.pbf").
-                put("graph.location", "./target/andorra-gh/");
-
         server = new GHServer(args);
 
         if (injector == null)
-            setUpGuice(new DefaultModule(args), new GHServletModule());
+            setUpGuice(new DefaultModule(args), new GHServletModule(args));
 
         for (int i = 0; i < retryCount; i++)
         {
@@ -86,7 +80,7 @@ private void bootJetty( int retryCount )
         }
     }
 
-    public void shutdownJetty( boolean force )
+    public static void shutdownJetty( boolean force )
     {
         // this is too slow so allow force == false. Then on setUpJetty a new server is created on a different port
         if (force && server != null)
@@ -98,9 +92,6 @@ public void shutdownJetty( boolean force )
                 logger.error("Cannot stop jetty", ex);
             }
 
-        if (injector != null)
-            new GuiceFilter().destroy();
-        injector = null;
         server = null;
     }
 
@@ -126,5 +117,5 @@ protected JSONObject query( String query ) throws Exception
         String url = getTestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
         return new JSONObject(downloader.downloadAsString(url));
-    }
+    }    
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 38ebeec518..10a09d601d 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -20,7 +20,11 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
 import org.json.JSONObject;
+import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -28,13 +32,25 @@
 /**
  * @author Peter Karich
  */
-public class GraphHopperServletIT extends BaseServletTest
+public class GraphHopperServletIT extends BaseServletTester
 {
+    private static final String dir = "./target/andorra-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
 
     @Before
     public void setUp()
     {
-        setUpJetty();
+        CmdArgs args = new CmdArgs().
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/andorra.osm.pbf").
+                put("graph.location", dir);
+        setUpJetty(args);
     }
 
     @Test
@@ -43,11 +59,29 @@ public void testBasicQuery() throws Exception
         JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128");
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
-        double distance = json.getJSONArray("paths").getJSONObject(0).getDouble("distance");
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
         assertTrue("distance wasn't correct:" + distance, distance > 9000);
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testJsonRounding() throws Exception
+    {
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
+        JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
+        assertTrue("unexpected precision!", cson.toString().indexOf("[1.536374,42.554839]") >= 0);
+    }
+
+    @Test
+    public void testFailIfElevationRequestedButNotIncluded() throws Exception
+    {
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertTrue(infoJson.has("errors"));
+        assertEquals("Elevation not supported!", infoJson.getJSONArray("errors").getJSONObject(0).getString("message"));
+    }
+
     @Test
     public void testGraphHopperWeb() throws Exception
     {
@@ -58,4 +92,42 @@ public void testGraphHopperWeb() throws Exception
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
     }
+
+    @Test
+    public void testGraphHopperWebRealExceptions()
+    {
+        GHResponse rsp;
+        Throwable ex;
+
+        GraphHopperAPI hopper = new GraphHopperWeb();
+        assertTrue(hopper.load(getTestAPIUrl()));
+
+        // IllegalStateException (Wrong Request)
+        rsp = hopper.route(new GHRequest());
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+            + ", IllegalStateException expected.", ex instanceof IllegalStateException);
+
+        // IllegalArgumentException (Wrong Points)
+        rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+                + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // IllegalArgumentException (Vehicle not supported)
+        rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128).setVehicle("SPACE-SHUTTLE"));
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+                + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // UnsupportedOperationException
+        // RuntimeException
+        // Exception
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
new file mode 100644
index 0000000000..faa0205ede
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperServletWithEleIT extends BaseServletTester
+{
+    private static final String dir = "./target/monaco-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("graph.elevation.provider", "srtm").
+                put("graph.elevation.cachedir", "../core/files/").
+                put("prepare.chWeighting", "no").
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/monaco.osm.gz").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testElevation() throws Exception
+    {
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 2500);
+        assertTrue("distance wasn't correct:" + distance, distance < 2700);
+
+        JSONObject cson = path.getJSONObject("points");
+        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+    }
+
+    @Test
+    public void testNoElevation() throws Exception
+    {
+        // default is elevation=false
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 2500);
+        assertTrue("distance wasn't correct:" + distance, distance < 2700);
+        JSONObject cson = path.getJSONObject("points");
+        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+
+        // disable elevation
+        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
+        infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        path = json.getJSONArray("paths").getJSONObject(0);
+        cson = path.getJSONObject("points");
+        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
new file mode 100644
index 0000000000..dc2470b6f2
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -0,0 +1,55 @@
+package com.graphhopper.http;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class IPFilterTest
+{
+    @Test
+    public void testAcceptWhite()
+    {
+        IPFilter instance = new IPFilter("1.2.3.4, 4.5.67.1", "");
+        assertTrue(instance.accept("1.2.3.4"));
+        assertTrue(instance.accept("4.5.67.1"));
+        assertFalse(instance.accept("1.2.3.5"));
+
+        instance = new IPFilter("1.2.3*, 4.5.67.1, 7.8.*.3", "");
+        assertTrue(instance.accept("1.2.3.4"));
+        assertTrue(instance.accept("4.5.67.1"));
+        assertTrue(instance.accept("1.2.3.5"));
+        assertFalse(instance.accept("1.3.5.7"));
+
+        assertTrue(instance.accept("7.8.5.3"));
+        assertFalse(instance.accept("7.88.5.3"));
+    }
+
+    @Test
+    public void testAcceptBlack()
+    {
+        IPFilter instance = new IPFilter("", "1.2.3.4, 4.5.67.1");
+
+        assertFalse(instance.accept("1.2.3.4"));
+        assertFalse(instance.accept("4.5.67.1"));
+        assertTrue(instance.accept("1.2.3.5"));
+    }
+
+    @Test
+    public void testFilterSpecialCases()
+    {
+        IPFilter instance = new IPFilter("", "");
+        assertTrue(instance.accept("1.2.3.4"));
+
+        try
+        {
+            new IPFilter("1.2.3.4, 4.5.67.1", "8.9.7.3");
+            assertFalse("black and white", true);
+        } catch (Exception ex)
+        {
+
+        }
+    }
+}
diff --git a/web/src/test/java/log4j.properties b/web/src/test/java/log4j.properties
deleted file mode 100644
index 32f66a18ad..0000000000
--- a/web/src/test/java/log4j.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-# separate logging config to disable INFO
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %c - %m%n
-
-log4j.rootLogger=INFO
-log4j.logger.com.graphhopper=INFO, StdoutApp
-log4j.logger.org.eclipse=INFO, StdoutApp
diff --git a/web/src/test/java/log4j.xml b/web/src/test/java/log4j.xml
new file mode 100644
index 0000000000..a226ebca8e
--- /dev/null
+++ b/web/src/test/java/log4j.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>    
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <logger name="org.eclipse" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <root>
+        <priority value="info"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index 0d660f2e1f..5babc0a48f 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -69,6 +69,51 @@ describe("utils", function() {
         expect(list).toEqual([[-120.2, 38.5, 10], [-120.95, 40.7, 1234], [-126.45300000000002, 43.252, 1234]]);
     });
 
+    it("should parse URL correctly", function() {
+        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1");
+        expect("pest").toEqual(params.test);
+        expect(true).toEqual(params.test2);
+        expect(false).toEqual(params.test3);
+        expect(2).toEqual(params.test4);
+        expect(1.1).toEqual(params.test5);
+        
+        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");        
+        expect(params.point).toEqual("49.946505,11.571232");        
+        
+        params = parseUrl("blup?point=&point=49.946505%2C11.571232");
+        expect(params.point).toEqual("49.946505,11.571232");
+    });
+
+    it("features should work", function() {
+        var ghRequest = new GHRequest("http://test.de?vehicle=car");
+        var params = {};
+        params.elevation = true;
+        ghRequest.features = {"car":{}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+        
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(true);
+        
+        var params = {};
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(true);
+        
+        var params = {};
+        params.elevation = false;
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+        
+        var params = {};
+        params.elevation = true;
+        ghRequest.features = {"car":{ elevation: false}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+    });
+    
     it("ghrequest should init correctly from params", function() {
         var ghRequest = new GHRequest("http://test.de");
         var params = {};
@@ -81,14 +126,31 @@ describe("utils", function() {
         expect(ghRequest.do_zoom).toEqual(params.do_zoom);
     });
 
-    it("input should accept 0", function() {        
+    it("input should accept 0 and no addresses", function() {
         var input = new GHInput("12,0");
         expect(input.toString()).toEqual("12,0");
         var input = new GHInput("bluo,0");
         expect(input.toString()).toEqual(undefined);
+        expect(input.lat).toEqual(undefined);
+        expect(input.lng).toEqual(undefined);
         var input = new GHInput("bluo");
         expect(input.toString()).toEqual(undefined);
         var input = new GHInput("");
         expect(input.toString()).toEqual(undefined);
     });
+    
+    it("GHInput should set to unresolved if new input string", function() {
+        var input = new GHInput("12.44, 68.44");
+        expect(input.isResolved()).toEqual(true);
+        input.set("blup");
+        expect(input.isResolved()).toEqual(false);
+    });
+
+    it("point should be parsable", function() {
+        expect(new GHInput("12.44, 68.44").lat).toEqual(12.44);
+        expect(new GHInput("12.44, 68.44").lng).toEqual(68.44);
+        expect(new GHInput("12.44,68.44").lat).toEqual(12.44);
+        expect(new GHInput("12.44,68.44").lng).toEqual(68.44);
+        expect(new GHInput("london").lon).toEqual(undefined);
+    });    
 });
\ No newline at end of file
