diff --git a/.codeclimate.yml b/.codeclimate.yml
deleted file mode 100644
index 4e548285b5..0000000000
--- a/.codeclimate.yml
+++ /dev/null
@@ -1,36 +0,0 @@
-engines:
-  checkstyle:
-    enabled: true
-    checks:
-      com.puppycrawl.tools.checkstyle.checks.imports.AvoidStarImportCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.naming.AbbreviationAsWordInNameCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.whitespace.SeparatorWrapCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck:
-        enabled: false
-      com.puppycrawl.tools.checkstyle.checks.naming.LocalVariableNameCheck:
-        enabled: false
-  duplication:
-    enabled: true
-    config:
-      languages:
-      # it's not yet available for Java :)
-      - java
-  pmd:
-    enabled: true
-ratings:
-  paths:
-  - "**.java"
-exclude_paths:
-- "web/src/main/resources/assets/"
-- "**.js"
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index 869b3a9fe9..0000000000
--- a/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,5 +0,0 @@
-For questions or discussion please always use our [forum](https://discuss.graphhopper.com) first and make sure you read our [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md). Please be friendly and avoid the hassle to close your issue without an answer.
-
-The best way to get help about an GraphHopper issue is to create a valid and detailed issue content, preferable with a unit or integration test reproducing the issue. Please include the version of GraphHopper, the JVM and the operating system are you using and in case of a routing problem include a link to [GraphHopper Maps](https://graphhopper.com/maps/). Also tell us your expected routing result via additional markers and screenshots.
-
-If you have an Android application using GraphHopper, please **always** post to the [forum](https://discuss.graphhopper.com/c/graphhopper/graphhopper-ios-and-android) before and include logs and the version of your Android.
diff --git a/.travis.yml b/.travis.yml
index 0d996be8e6..7000f8c210 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,10 +13,10 @@ env:
 matrix:
   include:
     - jdk: openjdk8
-    - env: JDK='OpenJDK 11'
-      install: . ./install-jdk.sh -F 11 -C
-    - env: JDK='OpenJDK 12'
-      install: . ./install-jdk.sh -F 12 -C
+    - env: JDK='OpenJDK 13'
+      install: . ./install-jdk.sh -F 13 -C
+    - env: JDK='OpenJDK 14' SKIP_EXT_TESTS=true
+      install: . ./install-jdk.sh -F 14 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
 install: true
@@ -42,9 +42,13 @@ before_script:
   - cd web && npm install && BROWSERIFYSWAP_ENV='development' npm run bundleProduction && cd ..
 
 script:
-  - "mvn -Dkey=$API_KEY clean test verify checkstyle:check spotbugs:check forbiddenapis:check -B"
+  - "mvn -Dkey=$API_KEY clean install -B"
 
 after_success:
+  # often spotbugs etc take long to be compatible with a future JDK version so skip them
+  - if [ "$SKIP_EXT_TESTS" != "true" ]; then
+        mvn checkstyle:check forbiddenapis:check;
+    fi
   # if tagged deploy then release to maven central or deploy snapshot artifacts to sonatype 
   - if [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_TAG" != "" ]; then
         echo "release to maven central";
@@ -62,4 +66,4 @@ notifications:
 
 cache:
   directories:
-  - $HOME/.m2
+    - $HOME/.m2
diff --git a/.github/CONTRIBUTING.md b/CONTRIBUTING.md
similarity index 100%
rename from .github/CONTRIBUTING.md
rename to CONTRIBUTING.md
diff --git a/README.md b/README.md
index 9beb1f045f..3f0e6cf633 100644
--- a/README.md
+++ b/README.md
@@ -13,7 +13,8 @@ We have a prospering community and welcome everyone. Let us know your problems,
 
 To get started, read through our documentation and install the GraphHopper Web Service locally.
 
- * unstable: [documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [web service jar](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.13-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.13-SNAPSHOT/)
+ * unstable: [documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [web service jar](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.14-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.14-SNAPSHOT/)
+ * 0.13.0: [announcement](https://www.graphhopper.com/blog/2019/09/18/graphhopper-routing-engine-0-13-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.13/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.13.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.13.0.apk)
  * 0.12.0: [announcement](https://www.graphhopper.com/blog/2019/03/26/graphhopper-routing-engine-0-12-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.12/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.12.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.12.0.apk)
  * 0.11.0: [announcement](https://www.graphhopper.com/blog/2018/09/17/graphhopper-routing-engine-0-11-release-open-sourcing-the-isochrone-module/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.11/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.11.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.11.0.apk)
  * 0.10.0: [announcement](https://www.graphhopper.com/blog/2018/03/08/graphhopper-routing-engine-0-10-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.10/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.10.3-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.10.3.apk)
@@ -42,7 +43,7 @@ All questions can go to our [forum](https://discuss.graphhopper.com/) where we a
 
 ## Contribute
 
-Read through [how to contribute](.github/CONTRIBUTING.md) for information on topics
+Read through [how to contribute](CONTRIBUTING.md) for information on topics
 like finding and fixing bugs and improving our documentation or translations!
 
 ## For the Web
@@ -64,12 +65,19 @@ where the default is [Omniscale](http://omniscale.com/). All of these are availa
 
 ## For Mobile Apps
 
-There are subprojects to make GraphHopper working offline
-on [Android](./android/README.md)
-and [iOS](http://github.com/graphhopper/graphhopper-ios)
+### Offline
+
+There are subprojects to make GraphHopper working offline on [Android](./android/README.md) and [iOS](http://github.com/graphhopper/graphhopper-ios)
 
 [![simple routing](https://www.graphhopper.com/wp-content/uploads/2016/10/android-demo-screenshot-2.png)](./android/README.md)
 
+### Online
+
+There is an extension that creates a [navigation endpoint](https://github.com/graphhopper/graphhopper-navigation) to feed a 
+[lightweight navigation Android client](https://github.com/graphhopper/graphhopper-navigation-example).
+
+[![android navigation demo app](https://raw.githubusercontent.com/graphhopper/graphhopper-navigation-example/master/files/graphhopper-navigation-example.png)](https://github.com/graphhopper/graphhopper-navigation-example)
+
 ## For Analysis
 
 There is the isochrone subproject to calculate and visualize the reachable area for a certain travel mode
@@ -172,9 +180,9 @@ visualize the routes.
 ### Desktop
 
 GraphHopper also runs on the Desktop in a Java application without internet access.
-E.g. you could use the rough user interface called MiniGraphUI provided in the tools module, see some
+For debugging purposes GraphHopper can produce vector tiles, i.e. a visualization of the road network in the browser (see #1572). Also a more low level Swing-based UI is provided via MiniGraphUI in the tools module, see some
 visualizations done with it [here](https://graphhopper.com/blog/2016/01/19/alternative-roads-to-rome/).
-A fast and production ready map visualization for the Desktop can be easily implemented via mapsforge.
+A fast and production ready map visualization for the Desktop can be implemented via [mapsforge](https://github.com/mapsforge/mapsforge) or [mapsforge vtm](https://github.com/mapsforge/vtm).
 
 # Features
 
@@ -182,24 +190,24 @@ Here is a list of the more detailed features including a link to the documentati
 
  * [Quick installation and start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
  * Works out of the box with OpenStreetMap (osm/xml and pbf) and can be adapted to custom data
- * OpenStreetMap integration: Takes care of the road type, speed limit, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
+ * OpenStreetMap integration: stores and considers road type, speed limit, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
  * GraphHopper is fast. And with the so called "Contraction Hierarchies" it can be even faster (enabled by default).
  * Memory efficient data structures, algorithms and [the low and high level API](./docs/core/low-level-api.md) is tuned towards ease of use and efficiency
  * Provides a simple [web API](./docs/web/api-doc.md) including JavaScript and Java clients
  * Multiple weightings (fastest/shortest/...) and pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
- * Support for public transit routing and [GTFS support](./reader-gtfs/README.md).
- * Offers turn instructions in more than 35 languages, contribute or improve [here](./docs/core/translations.md)
+ * Supports public transit routing and [GTFS](./reader-gtfs/README.md).
+ * Offers turn instructions in more than 42 languages, contribute or improve [here](./docs/core/translations.md)
  * Displays and takes into account [elevation data](./docs/core/elevation.md) (per default disabled)
  * Can apply [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexible and hybrid mode only)
- * Customize vehicle profiles per request (flexible and hybrid mode only)
+ * Customization of vehicle profiles per request are possible (flexible and hybrid mode only)
  * Possibility to specify a [heading parameter](./docs/core/routing.md) of the vehicle for start, end and via points for navigation applications via `pass_through` or `heading` parameters (flexible and hybrid mode only)
  * [Alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexible and hybrid mode only)
  * [Turn costs and restrictions](./docs/core/turn-restrictions.md)
  * Country specific routing via SpatialRules
  * The core uses only a few dependencies (hppc, jts and slf4j)
  * Scales from small indoor-sized to world-wide-sized graphs
- * Find nearest point on street e.g. to get elevation or 'snap to road' or being used as spatial index (see [#1485](https://github.com/graphhopper/graphhopper/pull/1485))
- * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
- * Calculate [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
- * Show path details [#1142](https://github.com/graphhopper/graphhopper/pull/1142)
- * GraphHopper can produce vector tiles for debugging purposes [#1572](https://github.com/graphhopper/graphhopper/pull/1572)
\ No newline at end of file
+ * Finds nearest point on street e.g. to get elevation or 'snap to road' or being used as spatial index (see [#1485](https://github.com/graphhopper/graphhopper/pull/1485))
+ * Does [map matching](https://github.com/graphhopper/map-matching)
+ * Calculates [isochrones](./docs/web/api-doc.md#isochrone) and [shortest path trees](https://github.com/graphhopper/graphhopper/pull/1577)
+ * Shows the whole road network in the browser for debugging purposes ("vector tile support") [#1572](https://github.com/graphhopper/graphhopper/pull/1572)
+ * Shows details along a route like road_class or max_speed ("path details") [#1142](https://github.com/graphhopper/graphhopper/pull/1142) or for the whole road network via the "vector tile support"
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 84be98bc17..f10f9fc304 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 28
-    buildToolsVersion "28.0.3"
+    compileSdkVersion 29
+    buildToolsVersion "29.0.2"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
@@ -36,20 +36,20 @@ configurations.all {
  **/
 
 dependencies {
-    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.13-SNAPSHOT') {
+    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.14-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.11.1'
-    implementation 'org.mapsforge:vtm-android:0.11.1'
-    implementation 'org.mapsforge:vtm-android:0.11.1:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.11.1:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86_64'
-    implementation 'org.mapsforge:vtm-jts:0.11.1'
-    implementation 'org.mapsforge:vtm-themes:0.11.1'
+    implementation 'org.mapsforge:vtm:0.12.0'
+    implementation 'org.mapsforge:vtm-android:0.12.0'
+    implementation 'org.mapsforge:vtm-android:0.12.0:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.12.0:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.12.0:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.12.0:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.12.0'
+    implementation 'org.mapsforge:vtm-themes:0.12.0'
     implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index de30b700e4..e08c1bf6ed 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -15,11 +15,11 @@
     <parent>
         <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.13-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.14-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.11.1</vtm.version>
+        <vtm.version>0.12.0</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
diff --git a/android/build.gradle b/android/build.gradle
index 6b199027f8..97f6041e64 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.4.0'
+        classpath 'com.android.tools.build:gradle:3.5.0'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index c4486d47dc..ee69dd68d1 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/api/pom.xml b/api/pom.xml
index f1c2cdde48..2f2a9a87ec 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-api</artifactId>
     <packaging>jar</packaging>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper API</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/api/src/main/java/com/graphhopper/PathWrapper.java b/api/src/main/java/com/graphhopper/PathWrapper.java
index 682a8e3eec..4b148a647d 100644
--- a/api/src/main/java/com/graphhopper/PathWrapper.java
+++ b/api/src/main/java/com/graphhopper/PathWrapper.java
@@ -44,8 +44,9 @@
     private PointList waypointList = PointList.EMPTY;
     private PointList pointList = PointList.EMPTY;
     private int numChanges;
-    private final List<Trip.Leg> legs = new ArrayList<>();
-    private Map<String, List<PathDetail>> pathDetails = new HashMap<>();
+    private final List<Trip.Leg> legs = new ArrayList<>(5);
+    private final List<Integer> pointsOrder = new ArrayList<>(5);
+    private final Map<String, List<PathDetail>> pathDetails = new HashMap<>();
     private BigDecimal fare;
     private boolean impossible = false;
 
@@ -79,6 +80,16 @@ public String getDebugInfo() {
         return debugInfo;
     }
 
+    public PathWrapper setPointsOrder(List<Integer> list) {
+        pointsOrder.clear();
+        pointsOrder.addAll(list);
+        return this;
+    }
+
+    public List<Integer> getPointsOrder() {
+        return pointsOrder;
+    }
+
     /**
      * This method returns all points on the path. Keep in mind that calculating the distance from
      * these points might yield different results compared to getDistance as points could have been
diff --git a/api/src/main/java/com/graphhopper/util/Helper.java b/api/src/main/java/com/graphhopper/util/Helper.java
index e7ed1df51e..45cb8cb222 100644
--- a/api/src/main/java/com/graphhopper/util/Helper.java
+++ b/api/src/main/java/com/graphhopper/util/Helper.java
@@ -339,15 +339,6 @@ public static final double intToEle(int integEle) {
         return integEle / ELE_FACTOR;
     }
 
-
-    /**
-     * Trying to force the release of the mapped ByteBuffer. See
-     * http://stackoverflow.com/q/2972986/194609 and use only if you know what you are doing.
-     */
-    public static void cleanHack() {
-        System.gc();
-    }
-
     public static String nf(long no) {
         // I like french localization the most: 123654 will be 123 654 instead
         // of comma vs. point confusion for English/German people.
diff --git a/api/src/main/java/com/graphhopper/util/Parameters.java b/api/src/main/java/com/graphhopper/util/Parameters.java
index 5692c988da..ffe88aa62c 100644
--- a/api/src/main/java/com/graphhopper/util/Parameters.java
+++ b/api/src/main/java/com/graphhopper/util/Parameters.java
@@ -92,6 +92,8 @@
      */
     public static final class Routing {
         public static final String EDGE_BASED = "edge_based";
+        public static final String TURN_COSTS = "turn_costs";
+        public static final String U_TURN_COSTS = "u_turn_costs";
         public static final String MAX_VISITED_NODES = "max_visited_nodes";
         public static final String INIT_MAX_VISITED_NODES = ROUTING_INIT_PREFIX + "max_visited_nodes";
         /**
diff --git a/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java b/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
index 5e01d77e27..40e62e4bfc 100644
--- a/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
+++ b/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
@@ -24,8 +24,8 @@
 
     private final Map<String, Object> details;
 
-    public DetailedIllegalArgumentException(String var1, Map<String, Object> details) {
-        super(var1);
+    public DetailedIllegalArgumentException(String message, Map<String, Object> details) {
+        super(message);
         this.details = details;
     }
 
diff --git a/appveyor.yml b/appveyor.yml
index 0348495fdc..9ba7307c01 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -24,7 +24,7 @@ install:
 build_script:
   - mvn clean install -DskipTests=true -B
 test_script:
-  - mvn test verify -B && mvn checkstyle:check spotbugs:check forbiddenapis:check -B
+  - mvn test verify -B && mvn checkstyle:check forbiddenapis:check -B
 cache:
   - C:\maven\
   - C:\Users\appveyor\.m2
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index 8bbc4b30d9..a3f7d3c091 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -23,14 +23,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>directions-api-client-hc</artifactId>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Directions API hand-crafted Java Client.</name>
      
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>  
     
     <dependencies>
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
index 469e460722..243c867e8e 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
@@ -1,5 +1,6 @@
 package com.graphhopper.api;
 
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.GHRequest;
 import com.graphhopper.util.shapes.GHPoint;
 
@@ -17,8 +18,10 @@
     private List<GHPoint> toPoints;
     private List<String> fromPointHints;
     private List<String> toPointHints;
+    private int called = 0;
     boolean identicalLists = true;
     private final Set<String> outArrays = new HashSet<>(5);
+    private boolean failFast = true;
 
     public GHMRequest() {
         this(10);
@@ -130,7 +133,6 @@ public GHRequest setToPointHints(List<String> pointHints) {
 
     @Override
     public GHRequest setPointHints(List<String> pointHints) {
-        super.setPointHints(pointHints);
         this.fromPointHints = pointHints;
         this.toPointHints = pointHints;
         return this;
@@ -146,4 +148,45 @@ public boolean hasPointHints() {
         return this.fromPointHints.size() == this.fromPoints.size() && !fromPoints.isEmpty() &&
                 this.toPointHints.size() == this.toPoints.size() && !toPoints.isEmpty();
     }
+
+    /**
+     * @param failFast if false the matrix calculation will be continued even when some points are not connected
+     */
+    @JsonProperty("fail_fast")
+    public void setFailFast(boolean failFast) {
+        this.failFast = failFast;
+    }
+
+    public boolean getFailFast() {
+        return failFast;
+    }
+
+    /**
+     * This method makes it more likely that hasPointHints returns true as often point hints are added although the
+     * strings are empty. But because they could be used as placeholder we do not know earlier if they are meaningless.
+     */
+    void compactPointHints() {
+        if (called > 0)
+            throw new IllegalStateException("cannot call more than once");
+        called++;
+        boolean clear = true;
+        for (String hint : toPointHints) {
+            if (!hint.isEmpty()) {
+                clear = false;
+                break;
+            }
+        }
+        if (clear)
+            toPointHints.clear();
+
+        clear = true;
+        for (String hint : fromPointHints) {
+            if (!hint.isEmpty()) {
+                clear = false;
+                break;
+            }
+        }
+        if (clear)
+            fromPointHints.clear();
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index b6983df46e..d87e5aeab8 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -20,7 +20,6 @@
  */
 public abstract class GHMatrixAbstractRequester {
 
-    private GraphHopperWeb web = new GraphHopperWeb();
     protected final ObjectMapper objectMapper;
     protected final Set<String> ignoreSet = new HashSet<>(10);
     protected final String serviceUrl;
@@ -101,11 +100,18 @@ protected JsonNode toJSON(String url, String str) {
         }
     }
 
-    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString) throws IOException {
-        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString));
+    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString, boolean failFast) throws IOException {
+        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString), failFast);
     }
 
-    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solution) {
+    /**
+     * @param failFast If false weights/distances/times that are null are interpreted as disconnected points and are
+     *                 thus set to their respective maximum values. Furthermore, the indices of the disconnected points
+     *                 are added to {@link MatrixResponse#getDisconnectedPoints()} and the indices of the points that
+     *                 could not be found are added to {@link MatrixResponse#getInvalidFromPoints()} and/or
+     *                 {@link MatrixResponse#getInvalidToPoints()}.
+     */
+    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solution, boolean failFast) {
         final boolean readWeights = solution.has("weights");
         final boolean readDistances = solution.has("distances");
         final boolean readTimes = solution.has("times");
@@ -155,15 +161,27 @@ protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solu
 
             for (int toIndex = 0; toIndex < toCount; toIndex++) {
                 if (readWeights) {
-                    weights[toIndex] = weightsFromArray.get(toIndex).asDouble();
+                    if (weightsFromArray.get(toIndex).isNull() && !failFast) {
+                        weights[toIndex] = Double.MAX_VALUE;
+                    } else {
+                        weights[toIndex] = weightsFromArray.get(toIndex).asDouble();
+                    }
                 }
 
                 if (readTimes) {
-                    times[toIndex] = timesFromArray.get(toIndex).asLong() * 1000;
+                    if (timesFromArray.get(toIndex).isNull() && !failFast) {
+                        times[toIndex] = Long.MAX_VALUE;
+                    } else {
+                        times[toIndex] = timesFromArray.get(toIndex).asLong() * 1000;
+                    }
                 }
 
                 if (readDistances) {
-                    distances[toIndex] = (int) Math.round(distancesFromArray.get(toIndex).asDouble());
+                    if (distancesFromArray.get(toIndex).isNull() && !failFast) {
+                        distances[toIndex] = Integer.MAX_VALUE;
+                    } else {
+                        distances[toIndex] = (int) Math.round(distancesFromArray.get(toIndex).asDouble());
+                    }
                 }
             }
 
@@ -179,6 +197,43 @@ protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solu
                 matrixResponse.setDistanceRow(fromIndex, distances);
             }
         }
+        if (!failFast && solution.has("hints")) {
+            addProblems(matrixResponse, solution.get("hints"));
+        }
+    }
+
+    private void addProblems(MatrixResponse matrixResponse, JsonNode hints) {
+        for (JsonNode hint : hints) {
+            if (hint.has("point_pairs")) {
+                matrixResponse.setDisconnectedPoints(readDisconnectedPoints(hint.get("point_pairs")));
+            }
+            if (hint.has("invalid_from_points")) {
+                matrixResponse.setInvalidFromPoints(readInvalidPoints(hint.get("invalid_from_points")));
+                matrixResponse.setInvalidToPoints(readInvalidPoints(hint.get("invalid_to_points")));
+            }
+        }
+    }
+
+    private List<MatrixResponse.PointPair> readDisconnectedPoints(JsonNode pointPairsArray) {
+        List<MatrixResponse.PointPair> disconnectedPoints = new ArrayList<>(pointPairsArray.size());
+        for (int i = 0; i < pointPairsArray.size(); i++) {
+            if (pointPairsArray.get(i).size() != 2) {
+                throw new IllegalArgumentException("all point_pairs are expected to contain two elements");
+            }
+            disconnectedPoints.add(new MatrixResponse.PointPair(
+                    pointPairsArray.get(i).get(0).asInt(),
+                    pointPairsArray.get(i).get(1).asInt()
+            ));
+        }
+        return disconnectedPoints;
+    }
+
+    private List<Integer> readInvalidPoints(JsonNode pointsArray) {
+        List<Integer> result = new ArrayList<>(pointsArray.size());
+        for (int i = 0; i < pointsArray.size(); i++) {
+            result.add(pointsArray.get(i).asInt());
+        }
+        return result;
     }
 
     private static int checkArraySizes(String msg, int len, JsonNode... arrays) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index d13d61a27b..6083ff2140 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -83,6 +83,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
         requestJson.putArray("out_arrays").addAll(outArrayListJson);
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
+        requestJson.put("fail_fast", ghRequest.getFailFast());
 
         Map<String, String> hintsMap = ghRequest.getHints().toMap();
         for (String hintKey : hintsMap.keySet()) {
@@ -154,7 +155,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
                     JsonNode solution = getResponseJson.get("solution");
                     matrixResponse.addErrors(readUsableEntityError(outArraysList, solution));
                     if (!matrixResponse.hasErrors())
-                        fillResponseFromJson(matrixResponse, solution);
+                        fillResponseFromJson(matrixResponse, solution, ghRequest.getFailFast());
 
                     break;
                 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index 38d56eaa72..b1ade00fab 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -87,7 +87,11 @@ public MatrixResponse route(GHMRequest ghRequest) {
         }
 
         String url = buildURL("", ghRequest);
-        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
+        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr;
+        if (!Helper.isEmpty(ghRequest.getVehicle())) {
+            url += "&vehicle=" + ghRequest.getVehicle();
+        }
+        url += "&fail_fast=" + ghRequest.getFailFast();
 
         boolean withTimes = outArraysList.contains("times");
         boolean withDistances = outArraysList.contains("distances");
@@ -106,7 +110,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
             }
 
             if (!matrixResponse.hasErrors())
-                fillResponseFromJson(matrixResponse, getResponseJson);
+                fillResponseFromJson(matrixResponse, getResponseJson, ghRequest.getFailFast());
 
         } catch (IOException ex) {
             throw new RuntimeException(ex);
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
index a72432c580..85117966e2 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
@@ -41,6 +41,7 @@ public MatrixResponse route(GHMRequest request) {
             request.getHints().put(KEY, key);
         }
 
+        request.compactPointHints();
         return requester.route(request);
     }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index fea4af35b2..cd2f8fb64b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -243,8 +243,14 @@ private Request createRequest(GHRequest request) {
             url += "&" + Parameters.Details.PATH_DETAILS + "=" + details;
         }
 
-        for (String hint : request.getPointHints()) {
-            url += "&" + Parameters.Routing.POINT_HINT + "=" + WebHelper.encodeURL(hint);
+        // append *all* point hints only if at least *one* is not empty
+        for (String checkEmptyHint : request.getPointHints()) {
+            if (!checkEmptyHint.isEmpty()) {
+                for (String hint : request.getPointHints()) {
+                    url += "&" + Parameters.Routing.POINT_HINT + "=" + WebHelper.encodeURL(hint);
+                }
+                break;
+            }
         }
 
         for (String snapPrevention : request.getSnapPreventions()) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
index c2ed446885..1e079fca4b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
+++ b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * This class defines the response for a M-to-N requests.
@@ -13,6 +14,9 @@
 
     private String debugInfo = "";
     private final List<Throwable> errors = new ArrayList<>(4);
+    private final List<PointPair> disconnectedPoints = new ArrayList<>(0);
+    private final List<Integer> invalidFromPoints = new ArrayList<>(0);
+    private final List<Integer> invalidToPoints = new ArrayList<>(0);
     private long[][] times = new long[0][];
     private int[][] distances = new int[0][];
     private double[][] weights = new double[0][];
@@ -45,7 +49,7 @@ public MatrixResponse(int fromCap, int toCap, boolean withTimes, boolean withDis
             throw new IllegalArgumentException("Please specify times, distances or weights that should be calculated by the matrix");
     }
 
-    public void setFromRow(int row, long timeRow[], int distanceRow[], double weightRow[]) {
+    public void setFromRow(int row, long[] timeRow, int[] distanceRow, double[] weightRow) {
         if (times.length > 0) {
             check(timeRow.length, toCount, "to times");
             times[row] = timeRow;
@@ -68,7 +72,7 @@ private void check(int currentLength, int expectedLength, String times) {
                     "Expected " + expectedLength + " was: " + currentLength + ". Matrix: " + fromCount + "x" + toCount);
     }
 
-    public void setTimeRow(int row, long timeRow[]) {
+    public void setTimeRow(int row, long[] timeRow) {
         if (times.length > 0) {
             check(timeRow.length, toCount, "to times");
             times[row] = timeRow;
@@ -77,7 +81,7 @@ public void setTimeRow(int row, long timeRow[]) {
         }
     }
 
-    public void setDistanceRow(int row, int distanceRow[]) {
+    public void setDistanceRow(int row, int[] distanceRow) {
         if (distances.length > 0) {
             check(distanceRow.length, toCount, "to distances");
             distances[row] = distanceRow;
@@ -86,7 +90,7 @@ public void setDistanceRow(int row, int distanceRow[]) {
         }
     }
 
-    public void setWeightRow(int row, double weightRow[]) {
+    public void setWeightRow(int row, double[] weightRow) {
         if (weights.length > 0) {
             check(weightRow.length, toCount, "to weights");
             weights[row] = weightRow;
@@ -95,12 +99,20 @@ public void setWeightRow(int row, double weightRow[]) {
         }
     }
 
+    public boolean isConnected(int from, int to) {
+        if (hasErrors()) {
+            return false;
+        }
+        return getWeight(from, to) < Double.MAX_VALUE;
+    }
+
     /**
-     * Returns the time for the specific entry (from -&gt; to) in milliseconds.
+     * Returns the time for the specific entry (from -&gt; to) in milliseconds or {@link Long#MAX_VALUE} in case
+     * no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set to true).
      */
     public long getTime(int from, int to) {
         if (hasErrors()) {
-            throw new IllegalStateException("Cannot return time (" + from + "," + to + ") if errors occured " + getErrors());
+            throw new IllegalStateException("Cannot return time (" + from + "," + to + ") if errors occurred " + getErrors());
         }
 
         if (from >= times.length) {
@@ -112,7 +124,8 @@ public long getTime(int from, int to) {
     }
 
     /**
-     * Returns the distance for the specific entry (from -&gt; to) in meter.
+     * Returns the distance for the specific entry (from -&gt; to) in meter or {@link Double#MAX_VALUE} in case
+     * no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set to true).
      */
     public double getDistance(int from, int to) {
         if (hasErrors()) {
@@ -124,12 +137,13 @@ public double getDistance(int from, int to) {
         } else if (to >= distances[from].length) {
             throw new IllegalStateException("Cannot get 'to' " + to + " from distances with size " + distances[from].length);
         }
-        return distances[from][to];
+        return distances[from][to] == Integer.MAX_VALUE ? Double.MAX_VALUE : distances[from][to];
     }
 
     /**
-     * Returns the weight for the specific entry (from -&gt; to) in arbitrary units
-     * ('costs').
+     * Returns the weight for the specific entry (from -&gt; to) in arbitrary units ('costs'), or
+     * {@link Double#MAX_VALUE} in case no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set
+     * to true).
      */
     public double getWeight(int from, int to) {
         if (hasErrors()) {
@@ -176,6 +190,44 @@ public MatrixResponse addErrors(Collection<Throwable> errorList) {
         return this;
     }
 
+    /**
+     * @return true if there are invalid or disconnected points (which both do not yield an error in case we do not fail fast).
+     * @see GHMRequest#setFailFast(boolean)
+     */
+    public boolean hasProblems() {
+        return !disconnectedPoints.isEmpty() || !invalidFromPoints.isEmpty() || !invalidToPoints.isEmpty();
+    }
+
+    public MatrixResponse setDisconnectedPoints(List<PointPair> disconnectedPoints) {
+        this.disconnectedPoints.clear();
+        this.disconnectedPoints.addAll(disconnectedPoints);
+        return this;
+    }
+
+    public List<PointPair> getDisconnectedPoints() {
+        return disconnectedPoints;
+    }
+
+    public MatrixResponse setInvalidFromPoints(List<Integer> invalidFromPoints) {
+        this.invalidFromPoints.clear();
+        this.invalidFromPoints.addAll(invalidFromPoints);
+        return this;
+    }
+
+    public MatrixResponse setInvalidToPoints(List<Integer> invalidToPoints) {
+        this.invalidToPoints.clear();
+        this.invalidToPoints.addAll(invalidToPoints);
+        return this;
+    }
+
+    public List<Integer> getInvalidFromPoints() {
+        return invalidFromPoints;
+    }
+
+    public List<Integer> getInvalidToPoints() {
+        return invalidToPoints;
+    }
+
     @Override
     public String toString() {
         String addInfo = "";
@@ -188,6 +240,45 @@ public String toString() {
             addInfo += ", distances: " + distances.length + "x" + distances[0].length;
         }
 
-        return "[" + addInfo + "] errors:" + errors.toString();
+        String result = "[" + addInfo + "] errors:" + errors.toString();
+        if (!disconnectedPoints.isEmpty()) {
+            result += ", disconnectedPoints: " + disconnectedPoints.size();
+        }
+        if (!invalidFromPoints.isEmpty()) {
+            result += ", invalidFromPoints: " + invalidFromPoints.size();
+        }
+        if (!invalidToPoints.isEmpty()) {
+            result += ", invalidToPoints: " + invalidToPoints.size();
+        }
+        return result;
+    }
+
+    public static class PointPair {
+        public final int sourceIndex;
+        public final int targetIndex;
+
+        public PointPair(int sourceIndex, int targetIndex) {
+            this.sourceIndex = sourceIndex;
+            this.targetIndex = targetIndex;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            PointPair pointPair = (PointPair) o;
+            return sourceIndex == pointPair.sourceIndex &&
+                    targetIndex == pointPair.targetIndex;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(sourceIndex, targetIndex);
+        }
+
+        @Override
+        public String toString() {
+            return "[" + sourceIndex + ", " + targetIndex + "]";
+        }
     }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
index 337cee9acf..7a80c34ac8 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
@@ -8,6 +8,7 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.util.Collections;
 
 import static org.junit.Assert.*;
 
@@ -59,6 +60,91 @@ public void testReadingWeights() throws IOException {
         }
     }
 
+    @Test
+    public void testReadingMatrixConnectionsNotFound_noFailFast() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix-connection-not-found-fail-fast.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(0, 1));
+        req.addPoint(new GHPoint(2, 3));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertFalse(rsp.hasErrors());
+        assertTrue(rsp.hasProblems());
+
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(0, 1), 1.e-3);
+        assertEquals(0, rsp.getWeight(0, 0), 1.e-3);
+
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(0, 1), 1.e-3);
+        assertEquals(1, rsp.getDistance(0, 0), 1.e-3);
+
+        assertEquals(Long.MAX_VALUE, rsp.getTime(0, 1));
+        assertEquals(2 * 1000, rsp.getTime(0, 0));
+
+        assertEquals("[[0, 1], [1, 0]]", rsp.getDisconnectedPoints().toString());
+    }
+
+    @Test
+    public void testReadingMatrixPointsNotFound_noFailFast() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix-point-not-found-fail-fast.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(0, 1));
+        req.addPoint(new GHPoint(2, 3));
+        req.addPoint(new GHPoint(4, 5));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertFalse(rsp.hasErrors());
+        assertTrue(rsp.hasProblems());
+
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 0), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 2), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(0, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(2, 1), 1.e-3);
+
+        assertEquals(0, rsp.getWeight(0, 0), 1.e-3);
+        assertEquals(1, rsp.getWeight(0, 2), 1.e-3);
+        assertEquals(2, rsp.getWeight(2, 0), 1.e-3);
+        assertEquals(3, rsp.getWeight(2, 2), 1.e-3);
+
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 0), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 2), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(0, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(2, 1), 1.e-3);
+
+        assertEquals(4, rsp.getDistance(0, 0), 1.e-3);
+        assertEquals(5, rsp.getDistance(0, 2), 1.e-3);
+        assertEquals(6, rsp.getDistance(2, 0), 1.e-3);
+        assertEquals(7, rsp.getDistance(2, 2), 1.e-3);
+
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 0));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 1));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 2));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(0, 1));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(2, 1));
+
+        assertEquals(8 * 1000, rsp.getTime(0, 0));
+        assertEquals(9 * 1000, rsp.getTime(0, 2));
+        assertEquals(10 * 1000, rsp.getTime(2, 0));
+        assertEquals(11 * 1000, rsp.getTime(2, 2));
+
+        assertEquals("[[0, 1], [1, 0], [1, 1], [1, 2], [2, 1]]", rsp.getDisconnectedPoints().toString());
+        assertEquals(Collections.singletonList(1), rsp.getInvalidFromPoints());
+        assertEquals(Collections.singletonList(1), rsp.getInvalidToPoints());
+    }
+
     @Test
     public void testReadingGoogleThrowsException() throws IOException {
         String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("google-matrix1.json")));
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 588166b2b9..b88526ff85 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -103,4 +103,173 @@ public void testPOSTMatrixQueryWithPointHints() {
         assertTrue(res.hasErrors());
         assertEquals("Array length of point_hints must match length of points (or from/to equivalent)", res.getErrors().get(0).getMessage());
     }
+
+    @Test
+    public void testConnectionNotFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(-7.126486, -34.833741));
+        req.addPoint(new GHPoint(9.657616, -13.565369));
+        req.addPoint(new GHPoint(18.928696, -70.400047));
+        req.addPoint(new GHPoint(-7.323564, -35.32774));
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertTrue(matrix.hasErrors());
+        assertEquals(1, matrix.getErrors().size());
+        assertTrue(matrix.getErrors().get(0).getMessage().contains("0->1"));
+        assertFalse(matrix.isConnected(0, 1));
+        try {
+            matrix.getWeight(0, 1);
+            fail("getWeight should throw an exception if errors were found");
+        } catch (Exception e) {
+            // ok
+        }
+    }
+
+    @Test
+    public void testConnectionNotFound_doNotFailFast() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(-7.126486, -34.833741));
+        req.addPoint(new GHPoint(9.657616, -13.565369));
+        req.addPoint(new GHPoint(18.928696, -70.400047));
+        req.addPoint(new GHPoint(-7.323564, -35.32774));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+
+        // if fail_fast is false we do not consider disconnected points to be errors and instead we expect the full
+        // matrix to be returned where disconnected points yield weight = Double.MAX_VALUE
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        for (int i = 0; i < 4; i++) {
+            for (int j = 0; j < 4; j++) {
+                double weight = matrix.getWeight(i, j);
+                double distance = matrix.getDistance(i, j);
+                long time = matrix.getTime(i, j);
+                boolean connected = matrix.isConnected(i, j);
+                if (i == j) {
+                    assertTrue(connected);
+                    assertEquals(0, weight, 1.e-3);
+                    assertEquals(0, distance, 1.e-3);
+                    assertEquals(0, time);
+                } else if (i == 0 && j == 3) {
+                    assertTrue(connected);
+                    assertEquals(4931, weight, 100);
+                    assertEquals(78643, distance, 100);
+                    assertEquals(3752000, time, 100000);
+                } else if (i == 3 && j == 0) {
+                    assertTrue(connected);
+                    assertEquals(4745, weight, 100);
+                    assertEquals(75480, distance, 100);
+                    assertEquals(3613000, time, 100000);
+                } else {
+                    assertFalse(connected);
+                    assertEquals("expected maximum weight for matrix element (" + i + ", " + j + "), but was: " + weight, Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals("expected maximum distance for matrix element (" + i + ", " + j + "), but was: " + distance, Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals("expected maximum time for matrix element (" + i + ", " + j + "), but was: " + time, Long.MAX_VALUE, time);
+                }
+            }
+        }
+        assertEquals(10, matrix.getDisconnectedPoints().size());
+        assertEquals("[[0, 1], [0, 2], [1, 0], [1, 2], [1, 3], [2, 0], [2, 1], [2, 3], [3, 1], [3, 2]]", matrix.getDisconnectedPoints().toString());
+    }
+
+    @Test
+    public void testPointsNotFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.541382, 1.516349));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.addPoint(new GHPoint(42.566293, 1.597867));
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertTrue(matrix.hasErrors());
+        assertEquals(2, matrix.getErrors().size());
+        assertTrue(matrix.getErrors().get(0).getMessage().contains("Cannot find from_points: 0, 2"));
+        assertTrue(matrix.getErrors().get(1).getMessage().contains("Cannot find to_points: 0, 2"));
+        assertFalse(matrix.isConnected(0, 1));
+        try {
+            matrix.getWeight(0, 1);
+            fail("getWeight should throw an exception if errors were found");
+        } catch (Exception e) {
+            // ok
+        }
+    }
+
+    @Test
+    public void testPointsNotFound_doNotFailFast() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.541382, 1.516349));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.addPoint(new GHPoint(42.566293, 1.597867));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        assertEquals(0, matrix.getErrors().size());
+        assertEquals(Arrays.asList(0, 2), matrix.getInvalidFromPoints());
+        assertEquals(Arrays.asList(0, 2), matrix.getInvalidToPoints());
+        assertEquals("[[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 2]]",
+                matrix.getDisconnectedPoints().toString());
+        for (int i = 0; i < 4; i++) {
+            for (int j = 0; j < 4; j++) {
+                double weight = matrix.getWeight(i, j);
+                double distance = matrix.getDistance(i, j);
+                long time = matrix.getTime(i, j);
+                boolean connected = matrix.isConnected(i, j);
+                if (i == 1 && j == 1 || i == 3 && j == 3) {
+                    assertEquals(0, weight, 1.e-3);
+                    assertEquals(0, distance, 1.e-3);
+                    assertEquals(0, time);
+                    assertTrue(connected);
+                } else if (i == 1 && j == 3) {
+                    assertEquals(1087, weight, 10);
+                    assertEquals(13926, distance, 100);
+                    assertEquals(878000, time, 10000);
+                    assertTrue(connected);
+                } else if (i == 3 && j == 1) {
+                    assertEquals(1083, weight, 10);
+                    assertEquals(13856, distance, 100);
+                    assertEquals(875000, time, 1000);
+                    assertTrue(connected);
+                } else {
+                    assertEquals(Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals(Double.MAX_VALUE, distance, 1.e-3);
+                    assertEquals(Long.MAX_VALUE, time);
+                    assertFalse(connected);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testPointsNotFound_doNotFailFast_noPointsFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        assertEquals(0, matrix.getErrors().size());
+        assertEquals(Arrays.asList(0, 1), matrix.getInvalidFromPoints());
+        assertEquals(Arrays.asList(0, 1), matrix.getInvalidToPoints());
+        assertEquals("[[0, 0], [0, 1], [1, 0], [1, 1]]", matrix.getDisconnectedPoints().toString());
+        for (int i = 0; i < 2; i++) {
+            for (int j = 0; j < 2; j++) {
+                double weight = matrix.getWeight(i, j);
+                assertFalse(matrix.isConnected(i, j));
+                assertEquals(Double.MAX_VALUE, weight, 1.e-3);
+            }
+        }
+    }
+
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java b/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java
new file mode 100644
index 0000000000..b993c9d697
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java
@@ -0,0 +1,41 @@
+package com.graphhopper.api;
+
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertFalse;
+
+public class GHMRequestTest {
+    @Test
+    public void testCompact() {
+        GHMRequest request = new GHMRequest();
+        for (int i = 0; i < 3; i++) {
+            request.addFromPoint(new GHPoint());
+            request.addFromPointHint("");
+        }
+
+        request.addToPoint(new GHPoint());
+        request.addToPointHint("");
+
+        request.compactPointHints();
+        assertTrue(request.getToPointHints().isEmpty());
+        assertTrue(request.getFromPointHints().isEmpty());
+    }
+
+    @Test
+    public void testCompact2() {
+        GHMRequest request = new GHMRequest();
+        for (int i = 0; i < 3; i++) {
+            request.addFromPoint(new GHPoint());
+            request.addFromPointHint("");
+        }
+
+        request.addToPoint(new GHPoint());
+        request.addToPointHint("x");
+
+        request.compactPointHints();
+        assertFalse(request.getToPointHints().isEmpty());
+        assertTrue(request.getFromPointHints().isEmpty());
+    }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
index 96e17a3fe6..e9071606ee 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
@@ -35,13 +35,13 @@ public void testForwardGeocoding() {
 
     @Test
     public void testExtent() {
-        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("new york", "en", 7));
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("seattle", "en", 7));
         BBox extent = response.getHits().get(0).getExtendBBox();
         assertTrue(extent.isValid());
-        assertTrue(extent.minLon < -79);
-        assertTrue(extent.maxLon > -72);
-        assertTrue(extent.minLat < 40.5);
-        assertTrue(extent.maxLat > 45);
+        assertTrue(extent.minLon > -123.00 && extent.minLon < -122.00);
+        assertTrue(extent.maxLon > -123.00 && extent.maxLon < -122.00);
+        assertTrue(extent.minLat > 47.00 && extent.minLat < 48.00);
+        assertTrue(extent.maxLat > 47.00 && extent.maxLat < 48.00);
     }
 
     @Test
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 8260167ea7..3f912aeb76 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -64,6 +64,8 @@ public void testSimpleRoute() {
         alt = res.getBest();
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         isBetween(9000, 9500, alt.getDistance());
+
+        assertEquals("[0, 1]", alt.getPointsOrder().toString());
     }
 
     @Test
@@ -242,6 +244,21 @@ void isBetween(double from, double to, double expected) {
         assertTrue("expected value " + expected + " was bigger than limit " + to, expected <= to);
     }
 
+    @Test
+    public void testOptimize() {
+        // https://graphhopper.com/maps/?point=49.664184%2C11.345444&point=49.661072%2C11.384068&point=49.670628%2C11.352997&point=49.667128%2C11.404753
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.664184, 11.345444)).
+                addPoint(new GHPoint(49.661072, 11.384068)).
+                addPoint(new GHPoint(49.670628, 11.352997)).
+                addPoint(new GHPoint(49.667128, 11.404753));
+        GHResponse res = gh.setOptimize("true").route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        PathWrapper alt = res.getBest();
+        isBetween(850, 1050, alt.getRouteWeight());
+        assertEquals("[0, 2, 1, 3]", alt.getPointsOrder().toString());
+    }
+
     @Test
     public void testMatrix() {
         GHMRequest req = AbstractGHMatrixWebTester.createRequest();
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json b/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json
new file mode 100644
index 0000000000..df8f76a614
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json
@@ -0,0 +1,34 @@
+{
+  "status": "finished",
+  "solution": {
+    "info": {
+      "took": 0.049935993,
+      "copyrights": [
+        "GraphHopper",
+        "OpenStreetMap contributors"
+      ]
+    },
+    "weights": [
+      [0, null],
+      [null, 0]
+    ],
+    "distances": [
+      [1, null],
+      [null, 1]
+    ],
+    "times": [
+      [2, null],
+      [null, 2]
+    ],
+    "hints": [
+      {
+        "message": "There were 2 connections that could not be found, see point_pairs for details",
+        "details": "com.graphhopper.util.exceptions.ConnectionNotFoundException",
+        "point_pairs": [
+          [0, 1],
+          [1, 0]
+        ]
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json b/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json
new file mode 100644
index 0000000000..4d6fec5ef6
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json
@@ -0,0 +1,42 @@
+{
+  "status": "finished",
+  "solution": {
+    "info": {
+      "took": 0.049935993,
+      "copyrights": [
+        "GraphHopper",
+        "OpenStreetMap contributors"
+      ]
+    },
+    "weights": [
+      [0, null, 1],
+      [null, null, null],
+      [2, null, 3]
+    ],
+    "distances": [
+      [4, null, 5],
+      [null, null, null],
+      [6, null, 7]
+    ],
+    "times": [
+      [8, null, 9],
+      [null, null, null],
+      [10, null, 11]
+    ],
+    "hints": [
+      {
+        "message": "There were 5 connections that could not be found, see point_pairs for details",
+        "details": "com.graphhopper.util.exceptions.ConnectionNotFoundException",
+        "point_pairs": [
+          [0, 1],[1, 0], [1, 1], [1, 2], [2, 1]
+        ]
+      },
+      {
+        "message": "There were 1 from_points and 1 to_points that could not be found, see invalid_from/to_points for details",
+        "details": "com.graphhopper.util.exceptions.PointsNotFoundException",
+        "invalid_from_points": [1],
+        "invalid_to_points": [1]
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/config-example.yml b/config-example.yml
index 37eaa99ee4..3b6273de56 100644
--- a/config-example.yml
+++ b/config-example.yml
@@ -15,7 +15,7 @@ graphhopper:
 
   # Add additional information to every edge. Used for path details.
   # If road_environment is added and elevation is enabled then also a tunnel and bridge interpolation is done, see #798.
-  # More options are: surface,max_width,max_height,max_weight,toll
+  # More options are: surface,max_width,max_height,max_weight,max_axle_load,max_length,toll,track_type
   graph.encoded_values: road_class,road_class_link,road_environment,max_speed,road_access
   # If many flag_encoders or encoded_values are used you need to increase bytes_for_flags to 8 or more (multiple of 4)
   graph.bytes_for_flags: 4
@@ -42,6 +42,9 @@ graphhopper:
   # By default the speed mode with the 'fastest' weighting is used. Internally a graph preparation via
   # contraction hierarchies (CH) is done to speed routing up. This requires more RAM/disc space for holding the
   # graph but less for every request. You can also setup multiple weightings, by providing a comma separated list.
+  # To enable finite u-turn costs use something like fastest|u_turn_costs=30, where 30 are the u-turn costs in seconds
+  # (given as integer). Note that since the u-turn costs are given in seconds the weighting you use should also
+  # calculate the weight in seconds. The u-turn costs will only be applied for edge_based, see below.
   prepare.ch.weightings: fastest
 
   # To enable turn-costs in speed mode (contraction hierarchies) edge-based graph traversal and a more elaborate
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index a6aaad155b..85b0be6ac3 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,3 +1,7 @@
+0.14
+    conditional turn restrictions now supported, #1683
+    removed PathNative,PathBidirRef,Path4CH,EdgeBasedPathCH and moved path extraction code out of Path class, added PathExtractor,BidirPathExtractor(+subclasses for CH) instead, #1730
+
 0.13
     removed docker compose file
     PathDetails return null instead of -1 for Infinity by default
@@ -13,6 +17,14 @@
     changed output format of result=pointlist and moved it into separate endpoint /spt
     removed TraversalMode.EDGE_BASED_1DIR and TraversalMode.EDGE_BASED_2DIR_UTURN, renamed TraversalMode.EDGE_BASED_2DIR to TraversalMode.EDGE_BASED
     to prevent u-turns when using edge-based algorithms it is now required to use TurnWeighting, #1640
+    GraphHopperStorage.getGraph(Class) was replaced by GraphHopperStorage.getBase/CHGraph(), #1669
+    CHGraph.shortcut(int, int) was removed (use .shortcut(int, int, ...) and/or .shortcutEdgeBased(int, int, ...) instead, #1693
+    CH graphs are now identified using CHProfile instead of Weighting, #1670
+    removed the 'traversal_mode` request parameter for /route, instead of 'traversal_mode=edge_based_2dir' use edge_based=true
+    removed GraphHopper.set/getTraversalMode() methods, #1705
+    edge-based CH is now chosen by default if it was prepared, #1706
+    it is now possible to specify finite u-turn costs for CH preparation, #1671
+    removed distances from CH shortcuts, reduces memory consumption per shortcut by 4 bytes (about 8-10%), #1719
 
 0.12
     renamed VirtualEdgeIteratorState.getOriginalEdgeKey to more precise getOriginalEdgeKey #1549
diff --git a/core/files/spotbugs-exclude.xml b/core/files/spotbugs-exclude.xml
deleted file mode 100644
index aaea34ce60..0000000000
--- a/core/files/spotbugs-exclude.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<FindBugsFilter>
-    <!-- documentation about findbug's rule match clauses can be found here:
-         http://findbugs.sourceforge.net/manual/filter.html -->
-         
-</FindBugsFilter>
\ No newline at end of file
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index 13663f9e64..550f28c812 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VI zh_CN zh_HK zh_TW"
+translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU in_ID it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VN zh_CN zh_HK zh_TW"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 97201d6b5b..aabccb89ff 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-core</artifactId>
     <name>GraphHopper Core</name>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>jar</packaging>
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <properties>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 148db32450..d98aa3e00f 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -65,6 +65,7 @@
 
 import static com.graphhopper.routing.ch.CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE;
 import static com.graphhopper.routing.ch.CHAlgoFactoryDecorator.EdgeBasedCHMode.OFF;
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.*;
 
@@ -96,7 +97,6 @@
     // for routing
     private int maxRoundTripRetries = 3;
     private boolean simplifyResponse = true;
-    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
     private int maxVisitedNodes = Integer.MAX_VALUE;
 
     private int nonChMaxWaypointDistance = Integer.MAX_VALUE;
@@ -166,9 +166,6 @@ public EncodingManager getEncodingManager() {
     public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
-        if (em.needsTurnCostsSupport())
-            traversalMode = TraversalMode.EDGE_BASED;
-
         return this;
     }
 
@@ -208,18 +205,6 @@ public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
         return this;
     }
 
-    public TraversalMode getTraversalMode() {
-        return traversalMode;
-    }
-
-    /**
-     * Sets the default traversal mode used for the algorithms and preparation.
-     */
-    public GraphHopper setTraversalMode(TraversalMode traversalMode) {
-        this.traversalMode = traversalMode;
-        return this;
-    }
-
     public GraphHopper setPathDetailsBuilderFactory(PathDetailsBuilderFactory pathBuilderFactory) {
         this.pathBuilderFactory = pathBuilderFactory;
         return this;
@@ -747,8 +732,7 @@ public boolean load(String graphHopperFolder) {
 
         if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
-            ghStorage = new GraphHopperStorage(chFactoryDecorator.getNodeBasedWeightings(), chFactoryDecorator.getEdgeBasedWeightings(),
-                    dir, encodingManager, hasElevation(), ext);
+            ghStorage = new GraphHopperStorage(chFactoryDecorator.getCHProfiles(), dir, encodingManager, hasElevation(), ext);
         } else {
             ghStorage = new GraphHopperStorage(dir, encodingManager, hasElevation(), ext);
         }
@@ -803,16 +787,26 @@ public final CHAlgoFactoryDecorator getCHFactoryDecorator() {
     }
 
     private void initCHAlgoFactoryDecorator() {
-        if (!chFactoryDecorator.hasWeightings()) {
+        if (!chFactoryDecorator.hasCHProfiles()) {
             for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
-                for (String chWeightingStr : chFactoryDecorator.getWeightingsAsStrings()) {
+                for (String chWeightingStr : chFactoryDecorator.getCHProfileStrings()) {
                     // ghStorage is null at this point
+
+                    // extract weighting string and u-turn-costs
+                    String configStr = "";
+                    if (chWeightingStr.contains("|")) {
+                        configStr = chWeightingStr;
+                        chWeightingStr = chWeightingStr.split("\\|")[0];
+                    }
+                    PMap config = new PMap(configStr);
+                    int uTurnCosts = config.getInt(Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);
+
                     CHAlgoFactoryDecorator.EdgeBasedCHMode edgeBasedCHMode = chFactoryDecorator.getEdgeBasedCHMode();
                     if (!(edgeBasedCHMode == EDGE_OR_NODE && encoder.supports(TurnWeighting.class))) {
-                        chFactoryDecorator.addNodeBasedWeighting(createWeighting(new HintsMap(chWeightingStr), encoder, null));
+                        chFactoryDecorator.addCHProfile(CHProfile.nodeBased(createWeighting(new HintsMap(chWeightingStr), encoder, null)));
                     }
                     if (edgeBasedCHMode != OFF && encoder.supports(TurnWeighting.class)) {
-                        chFactoryDecorator.addEdgeBasedWeighting(createWeighting(new HintsMap(chWeightingStr), encoder, null));
+                        chFactoryDecorator.addCHProfile(CHProfile.edgeBased(createWeighting(new HintsMap(chWeightingStr), encoder, null), uTurnCosts));
                     }
                 }
             }
@@ -936,10 +930,10 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
     /**
      * Potentially wraps the specified weighting into a TurnWeighting instance.
      */
-    public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
+    public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode, double uTurnCosts) {
         FlagEncoder encoder = weighting.getFlagEncoder();
         if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased())
-            return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
+            return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension(), uTurnCosts);
         return weighting;
     }
 
@@ -973,13 +967,18 @@ public GHResponse route(GHRequest request) {
             if (!encodingManager.hasEncoder(vehicle))
                 throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
 
+            FlagEncoder encoder = encodingManager.getEncoder(vehicle);
             HintsMap hints = request.getHints();
-            String tModeStr = hints.get("traversal_mode", traversalMode.toString());
-            TraversalMode tMode = TraversalMode.fromString(tModeStr);
+
+            // we use edge-based routing if the encoder supports turn-costs *unless* the edge_based parameter is set
+            // explicitly.
+            TraversalMode tMode = encoder.supports(TurnWeighting.class) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
             if (hints.has(Routing.EDGE_BASED))
                 tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
 
-            FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+            if (tMode.isEdgeBased() && !encoder.supports(TurnWeighting.class)) {
+                throw new IllegalArgumentException("You need a turn cost extension to make use of edge_based=true, e.g. use car|turn_costs=true");
+            }
 
             boolean disableCH = hints.getBool(CH.DISABLE, false);
             if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
@@ -1031,13 +1030,14 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                     if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
                         chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
 
-                    if (chAlgoFactory instanceof PrepareContractionHierarchies)
-                        weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
-                    else
+                    if (chAlgoFactory instanceof PrepareContractionHierarchies) {
+                        CHProfile chProfile = ((PrepareContractionHierarchies) chAlgoFactory).getCHProfile();
+                        queryGraph = new QueryGraph(ghStorage.getCHGraph(chProfile));
+                        queryGraph.lookup(qResults);
+                        weighting = chProfile.getWeighting();
+                    } else {
                         throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
-
-                    queryGraph = new QueryGraph(ghStorage.getGraph(CHGraph.class, weighting));
-                    queryGraph.lookup(qResults);
+                    }
                 } else {
                     checkNonChMaxWaypointDistance(points);
                     queryGraph = new QueryGraph(ghStorage);
@@ -1050,7 +1050,12 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                 if (maxVisitedNodesForRequest > maxVisitedNodes)
                     throw new IllegalArgumentException("The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
 
-                weighting = createTurnWeighting(queryGraph, weighting, tMode);
+                int uTurnCostInt = request.getHints().getInt(Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);
+                if (uTurnCostInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {
+                    throw new IllegalArgumentException("Finite u-turn costs can only be used for edge-based routing, use `" + Routing.EDGE_BASED + "=true'");
+                }
+                double uTurnCosts = uTurnCostInt == INFINITE_U_TURN_COSTS ? Double.POSITIVE_INFINITY : uTurnCostInt;
+                weighting = createTurnWeighting(queryGraph, weighting, tMode, uTurnCosts);
 
                 AlgorithmOptions algoOpts = AlgorithmOptions.start().
                         algorithm(algoStr).traversalMode(tMode).weighting(weighting).
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
new file mode 100644
index 0000000000..8ccdd1b33d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -0,0 +1,140 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader;
+
+import java.util.*;
+
+/**
+ * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
+ * <p>
+ *
+ * @author Karl Hbner
+ */
+public class OSMTurnRelation {
+    private final long fromOsmWayId;
+    private final long viaOsmNodeId;
+    private final long toOsmWayId;
+    private final Type restriction;
+    // vehicleTypeRestricted contains the dedicated vehicle type
+    // example: restriction:bus = no_left_turn => vehicleTypeRestricted = "bus";
+    private String vehicleTypeRestricted;
+    private List<String> vehicleTypesExcept;
+
+    public OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
+        this.fromOsmWayId = fromWayID;
+        this.viaOsmNodeId = viaNodeID;
+        this.toOsmWayId = toWayID;
+        this.restriction = restrictionType;
+        this.vehicleTypeRestricted = "";
+        this.vehicleTypesExcept = new ArrayList<>();
+    }
+
+    public long getOsmIdFrom() {
+        return fromOsmWayId;
+    }
+
+    public long getOsmIdTo() {
+        return toOsmWayId;
+    }
+
+    public long getViaOsmNodeId() {
+        return viaOsmNodeId;
+    }
+
+    public Type getRestriction() {
+        return restriction;
+    }
+
+    public String getVehicleTypeRestricted() {
+        return vehicleTypeRestricted;
+    }
+
+    public void setVehicleTypeRestricted(String vehicleTypeRestricted) {
+        this.vehicleTypeRestricted = vehicleTypeRestricted;
+    }
+
+    public List<String> getVehicleTypesExcept() {
+        return vehicleTypesExcept;
+    }
+
+    public void addVehicleTypesExcept(List<String> vehicleTypesExcept) {
+        this.vehicleTypesExcept = vehicleTypesExcept;
+    }
+
+    /**
+     * For a conditional turn restriction, test each vehicle type to verify if it is concerned.
+     * For a normal turn restriction (non conditional), the restriction is necessary considered.
+     * @param vehicleTypes
+     * @return
+     */
+    public boolean isVehicleTypeConcernedByTurnRestriction(List<String> vehicleTypes) {
+        if (vehicleTypeRestricted.isEmpty() && vehicleTypesExcept.isEmpty()) {
+            //normal turn restriction, not dedicated to a vehicle type
+            return true;
+        }
+        for (String vehicleType : vehicleTypes) {
+            if (!vehicleTypeRestricted.isEmpty()) {
+                if (vehicleTypeRestricted.equals(vehicleType)) {
+                    //turn restriction dedicated to vehicleType, for example: restriction:bus = no_left_turn
+                    return true;
+                }
+            }
+            if (!vehicleTypesExcept.isEmpty()) {
+                if (vehicleTypesExcept.contains(vehicleType)) {
+                    //turn restriction except for vehicleType
+                    return false;
+                }
+            }
+        }
+        if (!vehicleTypeRestricted.isEmpty()) {
+            //turn restriction dedicated to a vehicle type not found in vehicleTypes
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+    }
+
+    public enum Type {
+        UNSUPPORTED, NOT, ONLY;
+
+        private static final Map<String, Type> tags = new HashMap<>();
+
+        static {
+            tags.put("no_left_turn", NOT);
+            tags.put("no_right_turn", NOT);
+            tags.put("no_straight_on", NOT);
+            tags.put("no_u_turn", NOT);
+            tags.put("only_right_turn", ONLY);
+            tags.put("only_left_turn", ONLY);
+            tags.put("only_straight_on", ONLY);
+        }
+
+        public static Type getRestrictionType(String tag) {
+            Type result = null;
+            if (tag != null) {
+                result = tags.get(tag);
+            }
+            return (result != null) ? result : UNSUPPORTED;
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/ReaderElement.java b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
index 81dc5aa19e..50ca7ac13f 100644
--- a/core/src/main/java/com/graphhopper/reader/ReaderElement.java
+++ b/core/src/main/java/com/graphhopper/reader/ReaderElement.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.reader;
 
+import com.graphhopper.util.Helper;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -95,6 +97,24 @@ public String getTag(String name) {
         return val;
     }
 
+    public String getKeyStartsWith(String keyPrefix) {
+        int nbMatchedKeys = 0;
+        String matchedKey = null;
+        for (String key : properties.keySet()) {
+            if (key.startsWith(keyPrefix)) {
+                nbMatchedKeys++;
+                matchedKey = key;
+                if (nbMatchedKeys > 1) {
+                    throw new IllegalArgumentException("Several matched keys found for keyPrefix " + keyPrefix);
+                }
+            }
+        }
+        if (nbMatchedKeys == 1) {
+            return matchedKey;
+        }
+        return null;
+    }
+
     public void setTag(String name, Object value) {
         properties.put(name, value);
     }
@@ -145,6 +165,15 @@ public boolean hasTag(List<String> keyList, Set<String> values) {
         return false;
     }
 
+    public boolean hasTagStartsWith(String keyPrefix) {
+        for (String key : properties.keySet()) {
+            if (key.startsWith(keyPrefix)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     /**
      * Returns the first existing tag of the specified list where the order is important.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index b684795d21..28d936a493 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -38,12 +38,12 @@
  * @author Peter Karich
  */
 public class AStar extends AbstractRoutingAlgorithm {
-    private WeightApproximator weightApprox;
-    private int visitedCount;
     private GHIntObjectHashMap<AStarEntry> fromMap;
-    private PriorityQueue<AStarEntry> prioQueueOpenSet;
+    private PriorityQueue<AStarEntry> fromHeap;
     private AStarEntry currEdge;
-    private int to1 = -1;
+    private int visitedNodes;
+    private int to = -1;
+    private WeightApproximator weightApprox;
 
     public AStar(Graph graph, Weighting weighting, TraversalMode tMode) {
         super(graph, weighting, tMode);
@@ -64,97 +64,94 @@ public AStar setApproximation(WeightApproximator approx) {
 
     protected void initCollections(int size) {
         fromMap = new GHIntObjectHashMap<>();
-        prioQueueOpenSet = new PriorityQueue<>(size);
+        fromHeap = new PriorityQueue<>(size);
     }
 
     @Override
     public Path calcPath(int from, int to) {
         checkAlreadyRun();
-        to1 = to;
-
+        this.to = to;
         weightApprox.setTo(to);
         double weightToGoal = weightApprox.approximate(from);
         currEdge = new AStarEntry(EdgeIterator.NO_EDGE, from, 0 + weightToGoal, 0);
         if (!traversalMode.isEdgeBased()) {
             fromMap.put(from, currEdge);
         }
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo() {
+    private void runAlgo() {
         double currWeightToGoal, estimationFullWeight;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true) {
-            int currVertex = currEdge.adjNode;
-            visitedCount++;
-            if (isMaxVisitedNodesExceeded())
-                return createEmptyPath();
-
-            if (finished())
+            visitedNodes++;
+            if (isMaxVisitedNodesExceeded() || finished())
                 break;
 
-            EdgeIterator iter = explorer.setBaseNode(currVertex);
+            int currNode = currEdge.adjNode;
+            EdgeIterator iter = explorer.setBaseNode(currNode);
             while (iter.next()) {
                 if (!accept(iter, currEdge.edge))
                     continue;
 
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge)
-                        + currEdge.weightOfVisitedPath;
-                if (Double.isInfinite(alreadyVisitedWeight))
+                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;
+                if (Double.isInfinite(tmpWeight)) {
                     continue;
-
+                }
                 int traversalId = traversalMode.createTraversalId(iter, false);
+
                 AStarEntry ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight) {
+                if (ase == null || ase.weightOfVisitedPath > tmpWeight) {
                     int neighborNode = iter.getAdjNode();
                     currWeightToGoal = weightApprox.approximate(neighborNode);
-                    estimationFullWeight = alreadyVisitedWeight + currWeightToGoal;
+                    estimationFullWeight = tmpWeight + currWeightToGoal;
                     if (ase == null) {
-                        ase = new AStarEntry(iter.getEdge(), neighborNode, estimationFullWeight, alreadyVisitedWeight);
+                        ase = new AStarEntry(iter.getEdge(), neighborNode, estimationFullWeight, tmpWeight);
                         fromMap.put(traversalId, ase);
                     } else {
 //                        assert (ase.weight > 0.9999999 * estimationFullWeight) : "Inconsistent distance estimate. It is expected weight >= estimationFullWeight but was "
 //                                + ase.weight + " < " + estimationFullWeight + " (" + ase.weight / estimationFullWeight + "), and weightOfVisitedPath:"
 //                                + ase.weightOfVisitedPath + " vs. alreadyVisitedWeight:" + alreadyVisitedWeight + " (" + ase.weightOfVisitedPath / alreadyVisitedWeight + ")";
 
-                        prioQueueOpenSet.remove(ase);
+                        fromHeap.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = estimationFullWeight;
-                        ase.weightOfVisitedPath = alreadyVisitedWeight;
+                        ase.weightOfVisitedPath = tmpWeight;
                     }
 
                     ase.parent = currEdge;
-                    prioQueueOpenSet.add(ase);
+                    fromHeap.add(ase);
 
                     updateBestPath(iter, ase, traversalId);
                 }
             }
 
-            if (prioQueueOpenSet.isEmpty())
-                return createEmptyPath();
+            if (fromHeap.isEmpty())
+                break;
 
-            currEdge = prioQueueOpenSet.poll();
+            currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-
-        return extractPath();
     }
 
     @Override
-    protected Path extractPath() {
-        return new Path(graph, weighting).
-                setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
+    protected boolean finished() {
+        return currEdge.adjNode == to;
     }
 
     @Override
-    protected boolean finished() {
-        return currEdge.adjNode == to1;
+    protected Path extractPath() {
+        if (currEdge == null || !finished())
+            return createEmptyPath();
+
+        return PathExtractor.extractPath(graph, weighting, currEdge);
     }
 
     @Override
     public int getVisitedNodes() {
-        return visitedCount;
+        return visitedNodes;
     }
 
     protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry bestSPTEntry, int traversalId) {
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
index a2958b795c..11261afe7c 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.ch.Path4CH;
+import com.graphhopper.routing.ch.NodeBasedCHBidirPathExtractor;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
@@ -39,13 +39,12 @@ protected boolean finished() {
             return true;
 
         // changed finish condition for CH
-        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+        return currFrom.weight >= bestWeight && currTo.weight >= bestWeight;
     }
 
     @Override
-    protected Path createAndInitPath() {
-        bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
-        return bestPath;
+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {
+        return new NodeBasedCHBidirPathExtractor(graph, graph.getBaseGraph(), weighting);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java
index 4c712e9246..c5d3915f81 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java
@@ -45,12 +45,12 @@ public void init(int from, double fromWeight, int to, double toWeight) {
 
     @Override
     protected boolean fwdSearchCanBeStopped() {
-        return getMinCurrFromPathWeight() > bestPath.getWeight();
+        return getMinCurrFromPathWeight() > bestWeight;
     }
 
     @Override
     protected boolean bwdSearchCanBeStopped() {
-        return getMinCurrToPathWeight() > bestPath.getWeight();
+        return getMinCurrToPathWeight() > bestWeight;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index d97852661f..f07193037a 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -19,6 +19,7 @@
 
 import com.carrotsearch.hppc.IntObjectMap;
 import com.graphhopper.coll.GHIntObjectHashMap;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
@@ -30,21 +31,28 @@
 
 import java.util.PriorityQueue;
 
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+
 /**
  * Common subclass for bidirectional algorithms.
  * <p>
  *
  * @author Peter Karich
+ * @author easbar
  */
 public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm {
     protected int from;
     protected int to;
+    protected int fromOutEdge;
+    protected int toInEdge;
     protected IntObjectMap<SPTEntry> bestWeightMapFrom;
     protected IntObjectMap<SPTEntry> bestWeightMapTo;
     protected IntObjectMap<SPTEntry> bestWeightMapOther;
     protected SPTEntry currFrom;
     protected SPTEntry currTo;
-    protected PathBidirRef bestPath;
+    protected SPTEntry bestFwdEntry;
+    protected SPTEntry bestBwdEntry;
+    protected double bestWeight;
     PriorityQueue<SPTEntry> pqOpenSetFrom;
     PriorityQueue<SPTEntry> pqOpenSetTo;
     private boolean updateBestPath = true;
@@ -55,6 +63,9 @@
 
     public AbstractBidirAlgo(Graph graph, Weighting weighting, TraversalMode tMode) {
         super(graph, weighting, tMode);
+        fromOutEdge = ANY_EDGE;
+        toInEdge = ANY_EDGE;
+        bestWeight = Double.MAX_VALUE;
         int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);
         initCollections(size);
     }
@@ -88,16 +99,32 @@ protected void initCollections(int size) {
 
     @Override
     public Path calcPath(int from, int to) {
+        return calcPath(from, to, ANY_EDGE, ANY_EDGE);
+    }
+
+    /**
+     * like {@link #calcPath(int, int)}, but this method also allows to strictly restrict the edge the
+     * path will begin with and the edge it will end with.
+     *
+     * @param fromOutEdge the edge id of the first edge of the path. using {@link EdgeIterator#ANY_EDGE} means
+     *                    not enforcing the first edge of the path
+     * @param toInEdge    the edge id of the last edge of the path. using {@link EdgeIterator#ANY_EDGE} means
+     *                    not enforcing the last edge of the path
+     */
+    public Path calcPath(int from, int to, int fromOutEdge, int toInEdge) {
+        if ((fromOutEdge != ANY_EDGE || toInEdge != ANY_EDGE) && !traversalMode.isEdgeBased()) {
+            throw new IllegalArgumentException("Restricting the start/target edges is only possible for edge-based graph traversal");
+        }
+        this.fromOutEdge = fromOutEdge;
+        this.toInEdge = toInEdge;
         checkAlreadyRun();
-        createAndInitPath();
         init(from, 0, to, 0);
         runAlgo();
         return extractPath();
     }
 
-    protected Path createAndInitPath() {
-        bestPath = new PathBidirRef(graph, weighting);
-        return bestPath;
+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {
+        return new BidirPathExtractor(graph, weighting);
     }
 
     void init(int from, double fromWeight, int to, double toWeight) {
@@ -130,14 +157,15 @@ protected void postInit(int from, int to) {
                 bestWeightMapOther = bestWeightMapFrom;
                 updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to, true);
             }
-        } else if (from == to) {
-            // special case of identical start and end
+        } else if (from == to && fromOutEdge == ANY_EDGE && toInEdge == ANY_EDGE) {
+            // special handling if start and end are the same and no directions are restricted
+            // the resulting weight should be zero
             if (currFrom.weight != 0 || currTo.weight != 0) {
                 throw new IllegalStateException("If from=to, the starting weight must be zero for from and to");
             }
-            bestPath.sptEntry = currFrom;
-            bestPath.edgeTo = currTo;
-            bestPath.setWeight(0);
+            bestFwdEntry = currFrom;
+            bestBwdEntry = currTo;
+            bestWeight = 0;
             finishedFrom = true;
             finishedTo = true;
             return;
@@ -147,9 +175,55 @@ protected void postInit(int from, int to) {
     }
 
     protected void postInitFrom() {
+        if (fromOutEdge == ANY_EDGE) {
+            fillEdgesFromUsingFilter(additionalEdgeFilter);
+        } else {
+            // need to use a local reference here, because additionalEdgeFilter is modified when calling fillEdgesFromUsingFilter
+            final EdgeFilter tmpFilter = additionalEdgeFilter;
+            fillEdgesFromUsingFilter(new EdgeFilter() {
+                @Override
+                public boolean accept(EdgeIteratorState edgeState) {
+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeFirst() == fromOutEdge;
+                }
+            });
+        }
     }
 
     protected void postInitTo() {
+        if (toInEdge == ANY_EDGE) {
+            fillEdgesToUsingFilter(additionalEdgeFilter);
+        } else {
+            final EdgeFilter tmpFilter = additionalEdgeFilter;
+            fillEdgesToUsingFilter(new EdgeFilter() {
+                @Override
+                public boolean accept(EdgeIteratorState edgeState) {
+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeLast() == toInEdge;
+                }
+            });
+        }
+    }
+
+    /**
+     * @param edgeFilter edge filter used to fill edges. the {@link #additionalEdgeFilter} reference will be set to
+     *                   edgeFilter by this method, so make sure edgeFilter does not use it directly.
+     */
+    protected void fillEdgesFromUsingFilter(EdgeFilter edgeFilter) {
+        // we temporarily ignore the additionalEdgeFilter
+        EdgeFilter tmpFilter = additionalEdgeFilter;
+        additionalEdgeFilter = edgeFilter;
+        finishedFrom = !fillEdgesFrom();
+        additionalEdgeFilter = tmpFilter;
+    }
+
+    /**
+     * @see #fillEdgesFromUsingFilter(EdgeFilter)
+     */
+    protected void fillEdgesToUsingFilter(EdgeFilter edgeFilter) {
+        // we temporarily ignore the additionalEdgeFilter
+        EdgeFilter tmpFilter = additionalEdgeFilter;
+        additionalEdgeFilter = edgeFilter;
+        finishedTo = !fillEdgesTo();
+        additionalEdgeFilter = tmpFilter;
     }
 
     protected void runAlgo() {
@@ -171,7 +245,7 @@ protected boolean finished() {
         if (finishedFrom || finishedTo)
             return true;
 
-        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+        return currFrom.weight + currTo.weight >= bestWeight;
     }
 
     boolean fillEdgesFrom() {
@@ -254,11 +328,10 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
             weight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
         }
 
-        if (weight < bestPath.getWeight()) {
-            bestPath.setSwitchToFrom(reverse);
-            bestPath.setSPTEntry(entry);
-            bestPath.setSPTEntryTo(entryOther);
-            bestPath.setWeight(weight);
+        if (weight < bestWeight) {
+            bestFwdEntry = reverse ? entryOther : entry;
+            bestBwdEntry = reverse ? entry : entryOther;
+            bestWeight = weight;
         }
     }
 
@@ -291,9 +364,9 @@ protected double calcWeight(EdgeIteratorState iter, SPTEntry currEdge, boolean r
     @Override
     protected Path extractPath() {
         if (finished())
-            return bestPath.extract();
+            return createPathExtractor(graph, weighting).extract(bestFwdEntry, bestBwdEntry, bestWeight);
 
-        return bestPath;
+        return createEmptyPath();
     }
 
     protected boolean fromEntryCanBeSkipped() {
@@ -336,10 +409,6 @@ protected void setUpdateBestPath(boolean b) {
         updateBestPath = b;
     }
 
-    void setBestPath(PathBidirRef bestPath) {
-        this.bestPath = bestPath;
-    }
-
     @Override
     public int getVisitedNodes() {
         return visitedCountFrom + visitedCountTo;
@@ -347,6 +416,7 @@ public int getVisitedNodes() {
 
     void setFromDataStructures(AbstractBidirAlgo other) {
         from = other.from;
+        fromOutEdge = other.fromOutEdge;
         pqOpenSetFrom = other.pqOpenSetFrom;
         bestWeightMapFrom = other.bestWeightMapFrom;
         finishedFrom = other.finishedFrom;
@@ -357,6 +427,7 @@ void setFromDataStructures(AbstractBidirAlgo other) {
 
     void setToDataStructures(AbstractBidirAlgo other) {
         to = other.to;
+        toInEdge = other.toInEdge;
         pqOpenSetTo = other.pqOpenSetTo;
         bestWeightMapTo = other.bestWeightMapTo;
         finishedTo = other.finishedTo;
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
index 6e98c7cee6..7d4eab92a8 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
@@ -18,11 +18,12 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.ch.CHEntry;
-import com.graphhopper.routing.ch.EdgeBasedPathCH;
+import com.graphhopper.routing.ch.EdgeBasedCHBidirPathExtractor;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
@@ -30,6 +31,8 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+
 /**
  * @author easbar
  */
@@ -46,25 +49,37 @@ public AbstractBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
         // cache, see #1623.
         innerInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder).setFilterId(1));
         innerOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder).setFilterId(1));
-        if (!Double.isInfinite(turnWeighting.getUTurnCost())) {
-            throw new IllegalArgumentException("edge-based CH does not support finite u-turn costs at the moment");
-        }
     }
 
     @Override
     protected void postInitFrom() {
-        EdgeFilter filter = additionalEdgeFilter;
-        setEdgeFilter(EdgeFilter.ALL_EDGES);
-        fillEdgesFrom();
-        setEdgeFilter(filter);
+        // With CH the additionalEdgeFilter is the one that filters out edges leading or coming from higher rank nodes,
+        // i.e. LevelEdgeFilter, For the first step though we need all edges, so we need to ignore this filter.
+        // Using an arbitrary filter is not supported for CH anyway.
+        if (fromOutEdge == ANY_EDGE) {
+            fillEdgesFromUsingFilter(EdgeFilter.ALL_EDGES);
+        } else {
+            fillEdgesFromUsingFilter(new EdgeFilter() {
+                @Override
+                public boolean accept(EdgeIteratorState edgeState) {
+                    return edgeState.getOrigEdgeFirst() == fromOutEdge;
+                }
+            });
+        }
     }
 
     @Override
     protected void postInitTo() {
-        EdgeFilter filter = additionalEdgeFilter;
-        setEdgeFilter(EdgeFilter.ALL_EDGES);
-        fillEdgesTo();
-        setEdgeFilter(filter);
+        if (toInEdge == ANY_EDGE) {
+            fillEdgesToUsingFilter(EdgeFilter.ALL_EDGES);
+        } else {
+            fillEdgesToUsingFilter(new EdgeFilter() {
+                @Override
+                public boolean accept(EdgeIteratorState edgeState) {
+                    return edgeState.getOrigEdgeLast() == toInEdge;
+                }
+            });
+        }
     }
 
     @Override
@@ -79,7 +94,7 @@ public boolean finished() {
             return true;
 
         // changed also the final finish condition for CH
-        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+        return currFrom.weight >= bestWeight && currTo.weight >= bestWeight;
     }
 
     @Override
@@ -88,12 +103,13 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
         // node of the shortest path matches the source or target. in this case one of the searches does not contribute
         // anything to the shortest path.
         int oppositeNode = reverse ? from : to;
-        if (edgeState.getAdjNode() == oppositeNode) {
-            if (entry.getWeightOfVisitedPath() < bestPath.getWeight()) {
-                bestPath.setSwitchToFrom(reverse);
-                bestPath.setSPTEntry(entry);
-                bestPath.setSPTEntryTo(new CHEntry(oppositeNode, 0));
-                bestPath.setWeight(entry.getWeightOfVisitedPath());
+        int oppositeEdge = reverse ? fromOutEdge : toInEdge;
+        boolean oppositeEdgeRestricted = reverse ? (fromOutEdge != ANY_EDGE) : (toInEdge != ANY_EDGE);
+        if (edgeState.getAdjNode() == oppositeNode && (!oppositeEdgeRestricted || getOrigEdgeId(edgeState, reverse) == oppositeEdge)) {
+            if (entry.getWeightOfVisitedPath() < bestWeight) {
+                bestFwdEntry = reverse ? new CHEntry(oppositeNode, 0) : entry;
+                bestBwdEntry = reverse ? entry : new CHEntry(oppositeNode, 0);
+                bestWeight = entry.getWeightOfVisitedPath();
                 return;
             }
         }
@@ -119,19 +135,17 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
                     turnWeighting.calcTurnWeight(prevOrNextOrigEdgeId, iter.getBaseNode(), edgeId);
 
             double newWeight = entry.getWeightOfVisitedPath() + entryOther.getWeightOfVisitedPath() + turnCostsAtBridgeNode;
-            if (newWeight < bestPath.getWeight()) {
-                bestPath.setSwitchToFrom(reverse);
-                bestPath.setSPTEntry(entry);
-                bestPath.setSPTEntryTo(entryOther);
-                bestPath.setWeight(newWeight);
+            if (newWeight < bestWeight) {
+                bestFwdEntry = reverse ? entryOther : entry;
+                bestBwdEntry = reverse ? entry : entryOther;
+                bestWeight = newWeight;
             }
         }
     }
 
     @Override
-    protected Path createAndInitPath() {
-        bestPath = new EdgeBasedPathCH(graph, graph.getBaseGraph(), weighting);
-        return bestPath;
+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {
+        return new EdgeBasedCHBidirPathExtractor(graph, graph.getBaseGraph(), weighting);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 145fb56228..a7b238bdde 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -173,12 +173,11 @@ public void setMaxPaths(int maxPaths) {
             altBidirDijktra.setApproximation(weightApproximator);
         }
 
-        altBidirDijktra.searchBest(from, to);
+        Path bestPath = altBidirDijktra.searchBest(from, to);
         visitedNodes = altBidirDijktra.getVisitedNodes();
 
-        List<AlternativeInfo> alternatives = altBidirDijktra.
-                calcAlternatives(maxPaths, maxWeightFactor, 7, maxShareFactor, 0.8, minPlateauFactor, -0.2);
-        return alternatives;
+        return altBidirDijktra.
+                calcAlternatives(bestPath, maxPaths, maxWeightFactor, 7, maxShareFactor, 0.8, minPlateauFactor, -0.2);
     }
 
     @Override
@@ -273,18 +272,17 @@ public boolean finished() {
                 return true;
 
             // The following condition is necessary to avoid traversing the full graph if areas are disconnected
-            // but it is only valid for none-CH e.g. for CH it can happen that finishedTo is true but the from-SPT could still reach 'to'
-            if (!bestPath.isFound() && (finishedFrom || finishedTo))
+            // but it is only valid for non-CH e.g. for CH it can happen that finishedTo is true but the from-SPT could still reach 'to'
+            if (finishedFrom || finishedTo)
                 return true;
 
             // increase overlap of both searches:
-            return currFrom.weight + currTo.weight > explorationFactor * bestPath.getWeight();
-            // This is more precise but takes roughly 20% longer: return currFrom.weight > bestPath.getWeight() && currTo.weight > bestPath.getWeight();
+            return currFrom.weight + currTo.weight > explorationFactor * bestWeight;
+            // This is more precise but takes roughly 20% longer: return currFrom.weight > bestWeight && currTo.weight > bestWeight;
             // For bidir A* and AStarEdge.getWeightOfVisitedPath see comment in AStarBidirection.finished
         }
 
         public Path searchBest(int from, int to) {
-            createAndInitPath();
             init(from, 0, to, 0);
             // init collections and bestPath.getWeight properly
             runAlgo();
@@ -295,11 +293,11 @@ public Path searchBest(int from, int to) {
          * @return the information necessary to handle alternative paths. Note that the paths are
          * not yet extracted.
          */
-        public List<AlternativeInfo> calcAlternatives(final int maxPaths,
+        public List<AlternativeInfo> calcAlternatives(final Path bestPath, final int maxPaths,
                                                       double maxWeightFactor, final double weightInfluence,
                                                       final double maxShareFactor, final double shareInfluence,
                                                       final double minPlateauFactor, final double plateauInfluence) {
-            final double maxWeight = maxWeightFactor * bestPath.getWeight();
+            final double maxWeight = maxWeightFactor * bestWeight;
             final GHIntObjectHashMap<IntSet> traversalIdMap = new GHIntObjectHashMap<>();
             final AtomicInteger startTID = addToMap(traversalIdMap, bestPath);
 
@@ -308,14 +306,14 @@ public Path searchBest(int from, int to) {
             // only for plateau start candidates (2)
             final List<AlternativeInfo> alternatives = new ArrayList<>(maxPaths);
 
-            double bestPlateau = bestPath.getWeight();
+            double bestPlateau = bestWeight;
             double bestShare = 0;
-            double sortBy = calcSortBy(weightInfluence, bestPath.getWeight(),
+            double sortBy = calcSortBy(weightInfluence, bestWeight,
                     shareInfluence, bestShare,
                     plateauInfluence, bestPlateau);
 
             final AlternativeInfo bestAlt = new AlternativeInfo(sortBy, bestPath,
-                    bestPath.sptEntry, bestPath.edgeTo, bestShare, getAltNames(graph, bestPath.sptEntry));
+                    bestFwdEntry, bestBwdEntry, bestShare, getAltNames(graph, bestFwdEntry));
             alternatives.add(bestAlt);
             final List<SPTEntry> bestPathEntries = new ArrayList<>(2);
 
@@ -347,7 +345,7 @@ public boolean apply(final int traversalId, final SPTEntry fromSPTEntry) {
                     // Accept from-EdgeEntries only if such a start of a plateau
                     // i.e. discard if its parent has the same edgeId as the next to-SPTEntry.
                     // Ignore already added best path
-                    if (isBestPath(fromSPTEntry, bestPath))
+                    if (isBestPath(fromSPTEntry))
                         return true;
 
                     // For edge based traversal we need the next entry to find out the plateau start
@@ -412,7 +410,7 @@ public boolean apply(final int traversalId, final SPTEntry fromSPTEntry) {
                     SPTEntry fromEE = getFirstShareEE(fromSPTEntry.parent, true);
                     SPTEntry toEE = getFirstShareEE(toSPTEntry.parent, false);
                     double shareWeight = fromEE.getWeightOfVisitedPath() + toEE.getWeightOfVisitedPath();
-                    boolean smallShare = shareWeight / bestPath.getWeight() < maxShareFactor;
+                    boolean smallShare = shareWeight / bestWeight < maxShareFactor;
                     if (smallShare) {
                         List<String> altNames = getAltNames(graph, fromSPTEntry);
 
@@ -421,10 +419,7 @@ public boolean apply(final int traversalId, final SPTEntry fromSPTEntry) {
 
                         // plateaus.add(new PlateauInfo(altName, plateauEdges));
                         if (sortBy < worstSortBy || alternatives.size() < maxPaths) {
-                            Path path = new PathBidirRef(graph, weighting).
-                                    setSPTEntryTo(toSPTEntry).setSPTEntry(fromSPTEntry).
-                                    setWeight(weight);
-                            path.extract();
+                            Path path = BidirPathExtractor.extractPath(graph, weighting, fromSPTEntry, toSPTEntry, weight);
 
                             // for now do not add alternatives to set, if we do we need to remove then on alternatives.clear too (see below)
                             // AtomicInteger tid = addToMap(traversalIDMap, path);
@@ -489,7 +484,7 @@ public boolean apply(int key, IntSet set) {
                 }
 
                 // returns true if fromSPTEntry is identical to the specified best path
-                boolean isBestPath(SPTEntry fromSPTEntry, Path bestPath) {
+                boolean isBestPath(SPTEntry fromSPTEntry) {
                     if (traversalMode.isEdgeBased()) {
                         if (GHUtility.getEdgeFromEdgeKey(startTID.get()) == fromSPTEntry.edge) {
                             if (fromSPTEntry.parent == null)
diff --git a/core/src/main/java/com/graphhopper/routing/BidirPathExtractor.java b/core/src/main/java/com/graphhopper/routing/BidirPathExtractor.java
new file mode 100644
index 0000000000..58fdddaa23
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/BidirPathExtractor.java
@@ -0,0 +1,130 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.StopWatch;
+
+/**
+ * Builds a {@link Path} from the two fwd- and bwd-shortest path tree entries of a bidirectional search
+ *
+ * @author Peter Karich
+ * @author easbar
+ */
+public class BidirPathExtractor {
+    private final Graph graph;
+    private final Weighting weighting;
+    protected final Path path;
+
+    public static Path extractPath(Graph graph, Weighting weighting, SPTEntry fwdEntry, SPTEntry bwdEntry, double weight) {
+        return new BidirPathExtractor(graph, weighting).extract(fwdEntry, bwdEntry, weight);
+    }
+
+    protected BidirPathExtractor(Graph graph, Weighting weighting) {
+        this.graph = graph;
+        this.weighting = weighting;
+        this.path = new Path(graph, weighting);
+    }
+
+    protected Path extract(SPTEntry fwdEntry, SPTEntry bwdEntry, double weight) {
+        if (fwdEntry == null || bwdEntry == null) {
+            // path not found
+            return path;
+        }
+        if (fwdEntry.adjNode != bwdEntry.adjNode)
+            throw new IllegalStateException("forward and backward entries must have same adjacent nodes, fwdEntry:" + fwdEntry + ", bwdEntry:" + bwdEntry);
+
+        StopWatch sw = new StopWatch().start();
+        extractFwdPath(fwdEntry);
+        processMeetingPoint(fwdEntry, bwdEntry);
+        extractBwdPath(bwdEntry);
+        setExtractionTime(sw.stop().getNanos());
+        path.setFound(true);
+        path.setWeight(weight);
+        return path;
+    }
+
+    protected void extractFwdPath(SPTEntry sptEntry) {
+        SPTEntry fwdRoot = followParentsUntilRoot(sptEntry, false);
+        onFwdTreeRoot(fwdRoot.adjNode);
+        // since we followed the fwd path in backward direction we need to reverse the edge ids
+        path.reverseEdges();
+    }
+
+    protected void extractBwdPath(SPTEntry sptEntry) {
+        SPTEntry bwdRoot = followParentsUntilRoot(sptEntry, true);
+        onBwdTreeRoot(bwdRoot.adjNode);
+    }
+
+    protected void processMeetingPoint(SPTEntry fwdEntry, SPTEntry bwdEntry) {
+        int inEdge = getIncEdge(fwdEntry);
+        int outEdge = getIncEdge(bwdEntry);
+        onMeetingPoint(inEdge, fwdEntry.adjNode, outEdge);
+    }
+
+    protected SPTEntry followParentsUntilRoot(SPTEntry sptEntry, boolean reverse) {
+        SPTEntry currEntry = sptEntry;
+        SPTEntry parentEntry = currEntry.parent;
+        while (EdgeIterator.Edge.isValid(currEntry.edge)) {
+            onEdge(currEntry.edge, currEntry.adjNode, reverse, getIncEdge(parentEntry));
+            currEntry = parentEntry;
+            parentEntry = currEntry.parent;
+        }
+        return currEntry;
+    }
+
+    protected void setExtractionTime(long nanos) {
+        path.setDebugInfo("path extraction: " + nanos / 1000 + " micros");
+    }
+
+    protected int getIncEdge(SPTEntry entry) {
+        return entry.edge;
+    }
+
+    protected void onFwdTreeRoot(int node) {
+        path.setFromNode(node);
+    }
+
+    protected void onBwdTreeRoot(int node) {
+        path.setEndNode(node);
+    }
+
+    protected void onEdge(int edge, int adjNode, boolean reverse, int prevOrNextEdge) {
+        EdgeIteratorState edgeState = graph.getEdgeIteratorState(edge, adjNode);
+        path.addDistance(edgeState.getDistance());
+        path.addTime(weighting.calcMillis(edgeState, reverse, prevOrNextEdge));
+        path.addEdge(edge);
+    }
+
+    protected void onMeetingPoint(int inEdge, int viaNode, int outEdge) {
+        if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge)) {
+            return;
+        }
+        if (weighting instanceof TurnWeighting) {
+            double turnWeight = ((TurnWeighting) weighting).calcTurnWeight(inEdge, viaNode, outEdge);
+            path.addTime((long) (turnWeight * 1000));
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index a61eab1061..6ad277fed9 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -74,8 +74,8 @@ protected void runAlgo() {
             if (isMaxVisitedNodesExceeded() || finished())
                 break;
 
-            int startNode = currEdge.adjNode;
-            EdgeIterator iter = explorer.setBaseNode(startNode);
+            int currNode = currEdge.adjNode;
+            EdgeIterator iter = explorer.setBaseNode(currNode);
             while (iter.next()) {
                 if (!accept(iter, currEdge.edge))
                     continue;
@@ -123,8 +123,7 @@ protected Path extractPath() {
         if (currEdge == null || !finished())
             return createEmptyPath();
 
-        return new Path(graph, weighting).
-                setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
+        return PathExtractor.extractPath(graph, weighting, currEdge);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
index 307f1cfe5e..60684553eb 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.ch.Path4CH;
+import com.graphhopper.routing.ch.NodeBasedCHBidirPathExtractor;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
@@ -39,13 +39,12 @@ public boolean finished() {
             return true;
 
         // changed also the final finish condition for CH
-        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+        return currFrom.weight >= bestWeight && currTo.weight >= bestWeight;
     }
 
     @Override
-    protected Path createAndInitPath() {
-        bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
-        return bestPath;
+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {
+        return new NodeBasedCHBidirPathExtractor(graph, graph.getBaseGraph(), weighting);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 49bf5500b1..133e6bc4d2 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -23,6 +23,7 @@
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 
@@ -75,15 +76,32 @@ public Path calcPath(int from, int to) {
 
     @Override
     public Path extractPath() {
-        PathNative p = new PathNative(graph, weighting, parents, edgeIds);
-        if (endNode >= 0)
-            p.setWeight(weights[endNode]);
-        p.setFromNode(fromNode);
-        // return 'not found' if invalid endNode or limit reached
-        if (endNode < 0 || isWeightLimitExceeded())
-            return p;
-
-        return p.setEndNode(endNode).extract();
+        if (endNode < 0 || isWeightLimitExceeded()) {
+            Path path = createEmptyPath();
+            path.setFromNode(fromNode);
+            path.setEndNode(endNode);
+            return path;
+        }
+
+        Path path = new Path(graph, weighting);
+        int node = endNode;
+        while (true) {
+            int edge = edgeIds[node];
+            if (!EdgeIterator.Edge.isValid(edge)) {
+                break;
+            }
+            EdgeIteratorState edgeState = graph.getEdgeIteratorState(edge, node);
+            path.addDistance(edgeState.getDistance());
+            path.addTime(weighting.calcMillis(edgeState, false, EdgeIterator.NO_EDGE));
+            path.addEdge(edge);
+            node = parents[node];
+        }
+        path.reverseEdges();
+        path.setFromNode(fromNode);
+        path.setEndNode(endNode);
+        path.setFound(true);
+        path.setWeight(weights[endNode]);
+        return path;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index f3fe8c9855..f9ac21572c 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -37,28 +37,19 @@
 import java.util.*;
 
 /**
- * Stores the nodes for the found path of an algorithm. It additionally needs the edgeIds to make
- * edge determination faster and less complex as there could be several edges (u,v) especially for
- * graphs with shortcuts.
- * <p>
+ * This class represents the result of a shortest path calculation. It also provides methods to extract further
+ * information about the found path, like instructions etc.
  *
  * @author Peter Karich
  * @author Ottavio Campana
  * @author jan soe
+ * @author easbar
  */
 public class Path {
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-
-    final StopWatch extractSW = new StopWatch("extract");
     protected Graph graph;
     protected double distance;
-    // we go upwards (via SPTEntry.parent) from the goal node to the origin node
     protected boolean reverseOrder = true;
     protected long time;
-    /**
-     * Shortest path tree entry
-     */
-    protected SPTEntry sptEntry;
     protected int endNode = -1;
     private List<String> description;
     protected Weighting weighting;
@@ -68,6 +59,7 @@
     private GHIntArrayList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
+    private String debugInfo = "";
 
     public Path(Graph graph, Weighting weighting) {
         this.weight = Double.MAX_VALUE;
@@ -78,16 +70,6 @@ public Path(Graph graph, Weighting weighting) {
         this.edgeIds = new GHIntArrayList();
     }
 
-    /**
-     * Populates an unextracted path instances from the specified path p.
-     */
-    Path(Path p) {
-        this(p.graph, p.weighting);
-        weight = p.weight;
-        edgeIds = new GHIntArrayList(p.edgeIds);
-        sptEntry = p.sptEntry;
-    }
-
     /**
      * @return the description of this route alternative to make it meaningful for the user e.g. it
      * displays one or two main roads of the route.
@@ -103,12 +85,7 @@ public Path setDescription(List<String> description) {
         return this;
     }
 
-    public Path setSPTEntry(SPTEntry sptEntry) {
-        this.sptEntry = sptEntry;
-        return this;
-    }
-
-    protected void addEdge(int edge) {
+    public void addEdge(int edge) {
         edgeIds.add(edge);
     }
 
@@ -122,7 +99,7 @@ protected Path setEndNode(int end) {
      */
     private int getFromNode() {
         if (fromNode < 0)
-            throw new IllegalStateException("Call extract() before retrieving fromNode");
+            throw new IllegalStateException("fromNode < 0 should not happen");
 
         return fromNode;
     }
@@ -148,7 +125,7 @@ public Path setFound(boolean found) {
         return this;
     }
 
-    void reverseOrder() {
+    void reverseEdges() {
         if (!reverseOrder)
             throw new IllegalStateException("Switching order multiple times is not supported");
 
@@ -161,6 +138,11 @@ public Path setDistance(double distance) {
         return this;
     }
 
+    public Path addDistance(double distance) {
+        this.distance += distance;
+        return this;
+    }
+
     /**
      * @return distance in meter
      */
@@ -175,6 +157,11 @@ public long getTime() {
         return time;
     }
 
+    public Path addTime(long time) {
+        this.time += time;
+        return this;
+    }
+
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
@@ -187,32 +174,6 @@ public Path setWeight(double w) {
         return this;
     }
 
-    /**
-     * Extracts the Path from the shortest-path-tree determined by sptEntry.
-     */
-    public Path extract() {
-        if (isFound())
-            throw new IllegalStateException("Extract can only be called once");
-
-        extractSW.start();
-        SPTEntry currEdge = sptEntry;
-        setEndNode(currEdge.adjNode);
-        boolean nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.edge);
-        int nextEdge;
-        while (nextEdgeValid) {
-            // the reverse search needs the next edge
-            nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.parent.edge);
-            nextEdge = nextEdgeValid ? currEdge.parent.edge : EdgeIterator.NO_EDGE;
-            processEdge(currEdge.edge, currEdge.adjNode, nextEdge);
-            currEdge = currEdge.parent;
-        }
-
-        setFromNode(currEdge.adjNode);
-        reverseOrder();
-        extractSW.stop();
-        return setFound(true);
-    }
-
     /**
      * Yields the final edge of the path
      */
@@ -220,27 +181,12 @@ public EdgeIteratorState getFinalEdge() {
         return graph.getEdgeIteratorState(edgeIds.get(edgeIds.size() - 1), endNode);
     }
 
-    /**
-     * @return the time it took to extract the path in nano (!) seconds
-     */
-    public long getExtractTime() {
-        return extractSW.getNanos();
+    public void setDebugInfo(String debugInfo) {
+        this.debugInfo = debugInfo;
     }
 
     public String getDebugInfo() {
-        return extractSW.toString();
-    }
-
-    /**
-     * Calculates the distance and time of the specified edgeId. Also it adds the edgeId to the path list.
-     *
-     * @param prevEdgeId the edge that comes before edgeId: --prevEdgeId-x-edgeId-->adjNode
-     */
-    protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
-        EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
-        distance += iter.getDistance();
-        time += weighting.calcMillis(iter, false, prevEdgeId);
-        addEdge(edgeId);
+        return debugInfo;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
deleted file mode 100644
index cc5dc96c48..0000000000
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.routing.weighting.TurnWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-
-/**
- * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
- * <p>
- *
- * @author Peter Karich
- */
-public class PathBidirRef extends Path {
-    protected SPTEntry edgeTo;
-    private boolean switchFromAndToSPTEntry = false;
-
-    public PathBidirRef(Graph g, Weighting weighting) {
-        super(g, weighting);
-    }
-
-    PathBidirRef(PathBidirRef p) {
-        super(p);
-        edgeTo = p.edgeTo;
-        switchFromAndToSPTEntry = p.switchFromAndToSPTEntry;
-    }
-
-    public PathBidirRef setSwitchToFrom(boolean b) {
-        switchFromAndToSPTEntry = b;
-        return this;
-    }
-
-    public PathBidirRef setSPTEntryTo(SPTEntry edgeTo) {
-        this.edgeTo = edgeTo;
-        return this;
-    }
-
-    /**
-     * Extracts path from two shortest-path-tree
-     */
-    @Override
-    public Path extract() {
-        if (sptEntry == null || edgeTo == null)
-            return this;
-
-        if (sptEntry.adjNode != edgeTo.adjNode)
-            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge have to be the same. " + toString() + ", fromEntry:" + sptEntry + ", toEntry:" + edgeTo);
-
-        extractSW.start();
-        if (switchFromAndToSPTEntry) {
-            SPTEntry ee = sptEntry;
-            sptEntry = edgeTo;
-            edgeTo = ee;
-        }
-        extractFwdPath();
-        processTurnAtMeetingPoint();
-        extractBwdPath();
-        extractSW.stop();
-        return setFound(true);
-    }
-
-    private void extractFwdPath() {
-        // we take the 'edgeFrom'/sptEntry that points at the meeting node and follow its parent pointers back to
-        // the source
-        SPTEntry currEdge = sptEntry;
-        SPTEntry prevEdge = currEdge.parent;
-        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
-            processEdge(currEdge.edge, currEdge.adjNode, getIncEdge(prevEdge));
-            currEdge = prevEdge;
-            prevEdge = currEdge.parent;
-        }
-        setFromNode(currEdge.adjNode);
-        // since we followed the fwd path in backward direction we need to reverse the edge ids
-        reverseOrder();
-    }
-
-    private void extractBwdPath() {
-        // we take the edgeTo at the meeting node and follow its parent pointers to the target
-        SPTEntry currEdge = edgeTo;
-        SPTEntry nextEdge = currEdge.parent;
-        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
-            processEdgeBwd(currEdge.edge, currEdge.adjNode, getIncEdge(nextEdge));
-            currEdge = nextEdge;
-            nextEdge = nextEdge.parent;
-        }
-        setEndNode(currEdge.adjNode);
-    }
-
-    private void processTurnAtMeetingPoint() {
-        processTurn(getIncEdge(sptEntry), sptEntry.adjNode, getIncEdge(edgeTo));
-    }
-
-    /**
-     * Similar to {@link #processEdge(int, int, int)}, but with the situation we encounter when doing a backward
-     * search: nextEdgeId--x<--edgeId--adjNode
-     */
-    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
-        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
-        distance += edge.getDistance();
-        time += weighting.calcMillis(edge, true, nextEdgeId);
-        addEdge(edgeId);
-    }
-
-    private void processTurn(int inEdge, int viaNode, int outEdge) {
-        if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge)) {
-            return;
-        }
-        if (weighting instanceof TurnWeighting) {
-            time += ((TurnWeighting) weighting).calcTurnWeight(inEdge, viaNode, outEdge) * 1000;
-        }
-    }
-
-    protected int getIncEdge(SPTEntry entry) {
-        return entry.edge;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/PathExtractor.java b/core/src/main/java/com/graphhopper/routing/PathExtractor.java
new file mode 100644
index 0000000000..d92e9f542d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/PathExtractor.java
@@ -0,0 +1,85 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.StopWatch;
+
+public class PathExtractor {
+    private final Graph graph;
+    private final Weighting weighting;
+    protected final Path path;
+
+    public static Path extractPath(Graph graph, Weighting weighting, SPTEntry sptEntry) {
+        return new PathExtractor(graph, weighting).extract(sptEntry);
+    }
+
+    protected PathExtractor(Graph graph, Weighting weighting) {
+        this.graph = graph;
+        this.weighting = weighting;
+        path = new Path(graph, weighting);
+    }
+
+    protected Path extract(SPTEntry sptEntry) {
+        if (sptEntry == null) {
+            // path not found
+            return path;
+        }
+        StopWatch sw = new StopWatch().start();
+        extractPath(sptEntry);
+        path.setFound(true);
+        path.setWeight(sptEntry.weight);
+        setExtractionTime(sw.stop().getNanos());
+        return path;
+    }
+
+    private void extractPath(SPTEntry sptEntry) {
+        SPTEntry currEdge = followParentsUntilRoot(sptEntry);
+        path.reverseEdges();
+        path.setFromNode(currEdge.adjNode);
+        path.setEndNode(sptEntry.adjNode);
+    }
+
+    private SPTEntry followParentsUntilRoot(SPTEntry sptEntry) {
+        SPTEntry currEntry = sptEntry;
+        SPTEntry parentEntry = currEntry.parent;
+        while (EdgeIterator.Edge.isValid(currEntry.edge)) {
+            onEdge(currEntry.edge, currEntry.adjNode, parentEntry.edge);
+            currEntry = currEntry.parent;
+            parentEntry = currEntry.parent;
+        }
+        return currEntry;
+    }
+
+    private void setExtractionTime(long nanos) {
+        path.setDebugInfo("path extraction: " + nanos / 1000 + " micros");
+    }
+
+    protected void onEdge(int edge, int adjNode, int prevEdge) {
+        EdgeIteratorState edgeState = graph.getEdgeIteratorState(edge, adjNode);
+        path.addDistance(edgeState.getDistance());
+        path.addTime(weighting.calcMillis(edgeState, false, prevEdge));
+        path.addEdge(edge);
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
deleted file mode 100644
index 32a843c956..0000000000
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeIterator;
-
-/**
- * This class creates a Path from a DijkstraOneToMany algorithm
- *
- * @author Peter Karich
- */
-public class PathNative extends Path {
-    private final int[] parentNodes;
-    private final int[] parentEdges;
-
-    public PathNative(Graph g, Weighting weighting, int[] parentNodes, int[] parentEdges) {
-        super(g, weighting);
-        this.parentNodes = parentNodes;
-        this.parentEdges = parentEdges;
-    }
-
-    @Override
-    public Path extract() {
-        if (endNode < 0)
-            return this;
-
-        int prevEdge = EdgeIterator.NO_EDGE;
-        while (true) {
-            int edgeId = parentEdges[endNode];
-            if (!EdgeIterator.Edge.isValid(edgeId))
-                break;
-
-            processEdge(edgeId, endNode, prevEdge);
-            prevEdge = edgeId;
-            endNode = parentNodes[endNode];
-        }
-        reverseOrder();
-        return setFound(true);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 09f4ac8d93..2c1511405e 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -780,6 +780,13 @@ public boolean isUTurn(int edgeFrom, int edgeTo) {
             return mainTurnExtension.isUTurn(edgeFrom, edgeTo);
         }
 
+        @Override
+        public boolean isUTurnAllowed(int node) {
+            // do not allow u-turns at virtual nodes, otherwise the route depends on whether or not there are virtual
+            // via nodes, see #1672
+            return !isVirtualNode(node);
+        }
+
         private int getOriginalEdge(int edgeFrom) {
             return queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index 719d50deba..f623bbe731 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -20,15 +20,13 @@
 import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.RoutingAlgorithmFactoryDecorator;
 import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHProfile;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.PMap;
-import com.graphhopper.util.Parameters;
 import com.graphhopper.util.Parameters.CH;
+import com.graphhopper.util.Parameters.Routing;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,6 +34,7 @@
 import java.util.concurrent.ExecutorCompletionService;
 import java.util.concurrent.ExecutorService;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.CH.DISABLE;
 
@@ -48,11 +47,11 @@
 public class CHAlgoFactoryDecorator implements RoutingAlgorithmFactoryDecorator {
     private final Logger LOGGER = LoggerFactory.getLogger(getClass());
     private final List<PrepareContractionHierarchies> preparations = new ArrayList<>();
-    // we need to decouple weighting objects from the weighting list of strings 
-    // as we need the strings to create the GraphHopperStorage and the GraphHopperStorage to create the preparations from the Weighting objects currently requiring the encoders
-    private final List<Weighting> nodeBasedWeightings = new ArrayList<>();
-    private final List<Weighting> edgeBasedWeightings = new ArrayList<>();
-    private final Set<String> weightingsAsStrings = new LinkedHashSet<>();
+    // we need to decouple the CH profile objects from the list of CH profile strings
+    // as we need the strings to create the GraphHopperStorage and the GraphHopperStorage to create the preparations
+    // from the CHProfile objects currently requiring the encoders
+    private final List<CHProfile> chProfiles = new ArrayList<>();
+    private final Set<String> chProfileStrings = new LinkedHashSet<>();
     private boolean disablingAllowed = false;
     // for backward compatibility enable CH by default.
     private boolean enabled = true;
@@ -63,7 +62,7 @@
 
     public CHAlgoFactoryDecorator() {
         setPreparationThreads(1);
-        setWeightingsAsStrings(Arrays.asList(getDefaultWeighting()));
+        setCHProfilesAsStrings(Arrays.asList(getDefaultProfile()));
     }
 
     @Override
@@ -78,16 +77,18 @@ public void init(CmdArgs args) {
 
         // default is enabled & fastest
         String chWeightingsStr = args.get(CH.PREPARE + "weightings", "");
+        if (chWeightingsStr.contains("edge_based")) {
+            throw new IllegalArgumentException("Adding 'edge_based` to " + (CH.PREPARE + "weightings") + " is not allowed, to enable edge-based CH use " + (CH.PREPARE + "edge_based") + " instead.");
+        }
 
         if ("no".equals(chWeightingsStr) || "false".equals(chWeightingsStr)) {
             // default is fastest and we need to clear this explicitly
-            weightingsAsStrings.clear();
+            chProfileStrings.clear();
         } else if (!chWeightingsStr.isEmpty()) {
-            List<String> tmpCHWeightingList = Arrays.asList(chWeightingsStr.split(","));
-            setWeightingsAsStrings(tmpCHWeightingList);
+            setCHProfilesAsStrings(Arrays.asList(chWeightingsStr.split(",")));
         }
 
-        boolean enableThis = !weightingsAsStrings.isEmpty();
+        boolean enableThis = !chProfileStrings.isEmpty();
         setEnabled(enableThis);
         if (enableThis)
             setDisablingAllowed(args.getBool(CH.INIT_DISABLING_ALLOWED, isDisablingAllowed()));
@@ -135,95 +136,100 @@ public final CHAlgoFactoryDecorator setEdgeBasedCHMode(EdgeBasedCHMode edgeBased
     }
 
     /**
-     * Decouple weightings from PrepareContractionHierarchies as we need weightings for the
+     * Decouple CH profiles from PrepareContractionHierarchies as we need CH profiles for the
      * graphstorage and the graphstorage for the preparation.
      */
-    public CHAlgoFactoryDecorator addNodeBasedWeighting(Weighting weighting) {
-        nodeBasedWeightings.add(weighting);
-        return this;
-    }
-
-    public CHAlgoFactoryDecorator addEdgeBasedWeighting(Weighting weighting) {
-        edgeBasedWeightings.add(weighting);
-        return this;
-    }
-
-    public CHAlgoFactoryDecorator addWeighting(String weighting) {
-        weightingsAsStrings.add(weighting);
+    public CHAlgoFactoryDecorator addCHProfile(CHProfile chProfile) {
+        chProfiles.add(chProfile);
         return this;
     }
 
     public CHAlgoFactoryDecorator addPreparation(PrepareContractionHierarchies pch) {
-        // we want to make sure that edge- and node-based preparations are added in the same order as their corresponding
-        // weightings, but changing the order between edge- and node-based preparations is accepted
-        int index = 0;
-        for (PrepareContractionHierarchies p : preparations) {
-            if (p.isEdgeBased() == pch.isEdgeBased()) {
-                index++;
-            }
+        // we want to make sure that CH preparations are added in the same order as their corresponding profiles
+        if (preparations.size() >= chProfiles.size()) {
+            throw new IllegalStateException("You need to add the corresponding CH profiles before adding preparations.");
+        }
+        CHProfile expectedProfile = chProfiles.get(preparations.size());
+        if (!pch.getCHProfile().equals(expectedProfile)) {
+            throw new IllegalArgumentException("CH profile of preparation: " + pch + " needs to be identical to previously added CH profile: " + expectedProfile);
         }
-        List<Weighting> weightings = pch.isEdgeBased() ? edgeBasedWeightings : nodeBasedWeightings;
-        if (index >= weightings.size())
-            throw new IllegalStateException("Cannot access weighting for PrepareContractionHierarchies with " + pch.getWeighting()
-                    + ". Call add(Weighting) before");
-
-        Weighting expectedWeighting = weightings.get(index);
-        if (pch.getWeighting() != expectedWeighting)
-            throw new IllegalArgumentException("Weighting of PrepareContractionHierarchies " + pch
-                    + " needs to be identical to previously added " + expectedWeighting);
-
         preparations.add(pch);
         return this;
     }
 
-    public final boolean hasWeightings() {
-        return !nodeBasedWeightings.isEmpty() || !edgeBasedWeightings.isEmpty();
+    public final boolean hasCHProfiles() {
+        return !chProfiles.isEmpty();
     }
 
-    public final List<Weighting> getNodeBasedWeightings() {
-        return nodeBasedWeightings;
+    public List<CHProfile> getCHProfiles() {
+        return chProfiles;
     }
 
-    public final List<Weighting> getEdgeBasedWeightings() {
-        return edgeBasedWeightings;
+    public List<CHProfile> getNodeBasedCHProfiles() {
+        List<CHProfile> result = new ArrayList<>();
+        for (CHProfile chProfile : chProfiles) {
+            if (!chProfile.getTraversalMode().isEdgeBased()) {
+                result.add(chProfile);
+            }
+        }
+        return result;
+    }
+
+    public List<CHProfile> getEdgeBasedCHProfiles() {
+        List<CHProfile> result = new ArrayList<>();
+        for (CHProfile chProfile : chProfiles) {
+            if (chProfile.getTraversalMode().isEdgeBased()) {
+                result.add(chProfile);
+            }
+        }
+        return result;
     }
 
     public EdgeBasedCHMode getEdgeBasedCHMode() {
         return edgeBasedCHMode;
     }
 
-    public CHAlgoFactoryDecorator setWeightingsAsStrings(String... weightingNames) {
-        return setWeightingsAsStrings(Arrays.asList(weightingNames));
+    public List<String> getCHProfileStrings() {
+        if (chProfileStrings.isEmpty())
+            throw new IllegalStateException("Potential bug: chProfileStrings is empty");
+
+        return new ArrayList<>(chProfileStrings);
     }
 
-    public List<String> getWeightingsAsStrings() {
-        if (this.weightingsAsStrings.isEmpty())
-            throw new IllegalStateException("Potential bug: weightingsAsStrings is empty");
+    public CHAlgoFactoryDecorator setCHProfileStrings(String... profileStrings) {
+        return setCHProfilesAsStrings(Arrays.asList(profileStrings));
+    }
 
-        return new ArrayList<>(this.weightingsAsStrings);
+    /**
+     * @param profileStrings A list of multiple CH profile strings
+     * @see #addCHProfileAsString(String)
+     */
+    public CHAlgoFactoryDecorator setCHProfilesAsStrings(List<String> profileStrings) {
+        if (profileStrings.isEmpty())
+            throw new IllegalArgumentException("It is not allowed to pass an empty list of CH profile strings");
+
+        chProfileStrings.clear();
+        for (String profileString : profileStrings) {
+            profileString = toLowerCase(profileString);
+            profileString = profileString.trim();
+            addCHProfileAsString(profileString);
+        }
+        return this;
     }
 
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      *
-     * @param weightingList A list containing multiple weightings like: "fastest", "shortest" or
-     *                      your own weight-calculation type.
+     * @param profileString String representation of a CH profile like: "fastest", "shortest|edge_based=true",
+     *                      "fastest|u_turn_costs=30 or your own weight-calculation type.
      */
-    public CHAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList) {
-        if (weightingList.isEmpty())
-            throw new IllegalArgumentException("It is not allowed to pass an emtpy weightingList");
-
-        weightingsAsStrings.clear();
-        for (String strWeighting : weightingList) {
-            strWeighting = toLowerCase(strWeighting);
-            strWeighting = strWeighting.trim();
-            addWeighting(strWeighting);
-        }
+    public CHAlgoFactoryDecorator addCHProfileAsString(String profileString) {
+        chProfileStrings.add(profileString);
         return this;
     }
 
-    private String getDefaultWeighting() {
-        return weightingsAsStrings.isEmpty() ? "fastest" : weightingsAsStrings.iterator().next();
+    private String getDefaultProfile() {
+        return chProfileStrings.isEmpty() ? "fastest" : chProfileStrings.iterator().next();
     }
 
     public List<PrepareContractionHierarchies> getPreparations() {
@@ -236,34 +242,33 @@ public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFact
         if (!isEnabled() || disablingAllowed && disableCH)
             return defaultAlgoFactory;
 
-        List<PrepareContractionHierarchies> allPreparations = getPreparations();
-        if (allPreparations.isEmpty())
+        if (preparations.isEmpty())
             throw new IllegalStateException("No preparations added to this decorator");
 
         if (map.getWeighting().isEmpty())
-            map.setWeighting(getDefaultWeighting());
+            map.setWeighting(getDefaultProfile());
 
         return getPreparation(map);
     }
 
     public PrepareContractionHierarchies getPreparation(HintsMap map) {
-        boolean edgeBased = map.getBool(Parameters.Routing.EDGE_BASED, false);
-        List<String> entriesStrs = new ArrayList<>();
-        boolean weightingMatchesButNotEdgeBased = false;
+        Boolean edgeBased = map.has(Routing.EDGE_BASED) ? map.getBool(Routing.EDGE_BASED, false) : null;
+        Integer uTurnCosts = map.has(Routing.U_TURN_COSTS) ? map.getInt(Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS) : null;
+        CHProfile selectedProfile = selectProfile(map, edgeBased, uTurnCosts);
         for (PrepareContractionHierarchies p : getPreparations()) {
-            boolean weightingMatches = p.getWeighting().matches(map);
-            if (p.isEdgeBased() == edgeBased && weightingMatches)
+            if (p.getCHProfile().equals(selectedProfile)) {
                 return p;
-            else if (weightingMatches)
-                weightingMatchesButNotEdgeBased = true;
-
-            entriesStrs.add(p.getWeighting() + "|" + (p.isEdgeBased() ? "edge" : "node"));
+            }
         }
+        throw new IllegalStateException("Could not find CH preparation for selected profile: " + selectedProfile);
+    }
 
-        String hint = weightingMatchesButNotEdgeBased
-                ? " The '" + Parameters.Routing.EDGE_BASED + "' url parameter is missing or does not fit the weightings. Its value was: '" + edgeBased + "'"
-                : "";
-        throw new IllegalArgumentException("Cannot find CH RoutingAlgorithmFactory for weighting map " + map + " in entries: " + entriesStrs + "." + hint);
+    private CHProfile selectProfile(HintsMap map, Boolean edgeBased, Integer uTurnCosts) {
+        try {
+            return CHProfileSelector.select(chProfiles, map, edgeBased, uTurnCosts);
+        } catch (CHProfileSelectionException e) {
+            throw new IllegalArgumentException(e.getMessage());
+        }
     }
 
     public int getPreparationThreads() {
@@ -280,12 +285,12 @@ public void setPreparationThreads(int preparationThreads) {
     }
 
     public void prepare(final StorableProperties properties) {
-        ExecutorCompletionService completionService = new ExecutorCompletionService<>(threadPool);
+        ExecutorCompletionService<String> completionService = new ExecutorCompletionService<>(threadPool);
         int counter = 0;
         for (final PrepareContractionHierarchies prepare : getPreparations()) {
             LOGGER.info((++counter) + "/" + getPreparations().size() + " calling " +
-                    (prepare.isEdgeBased() ? "edge" : "node") + "-based CH prepare.doWork for " + prepare.getWeighting() + " ... (" + getMemInfo() + ")");
-            final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting(), prepare.isEdgeBased());
+                    "CH prepare.doWork for " + prepare.getCHProfile() + " ... (" + getMemInfo() + ")");
+            final String name = prepare.getCHProfile().toFileName();
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
@@ -295,7 +300,6 @@ public void run() {
                     properties.put(CH.PREPARE + "date." + name, createFormatter().format(new Date()));
                 }
             }, name);
-
         }
 
         threadPool.shutdown();
@@ -313,21 +317,16 @@ public void run() {
     public void createPreparations(GraphHopperStorage ghStorage) {
         if (!isEnabled() || !getPreparations().isEmpty())
             return;
-        if (!hasWeightings())
-            throw new IllegalStateException("No CH weightings found");
+        if (!hasCHProfiles())
+            throw new IllegalStateException("No CH profiles found");
 
-        for (Weighting weighting : nodeBasedWeightings) {
-            addPreparation(createCHPreparation(ghStorage, weighting, TraversalMode.NODE_BASED));
-        }
-        for (Weighting weighting : edgeBasedWeightings) {
-            addPreparation(createCHPreparation(ghStorage, weighting, TraversalMode.EDGE_BASED));
+        for (CHProfile chProfile : chProfiles) {
+            addPreparation(createCHPreparation(ghStorage, chProfile));
         }
     }
 
-    private PrepareContractionHierarchies createCHPreparation(GraphHopperStorage ghStorage, Weighting weighting,
-                                                              TraversalMode traversalMode) {
-        PrepareContractionHierarchies tmpPrepareCH = PrepareContractionHierarchies.fromGraphHopperStorage(
-                ghStorage, weighting, traversalMode);
+    private PrepareContractionHierarchies createCHPreparation(GraphHopperStorage ghStorage, CHProfile chProfile) {
+        PrepareContractionHierarchies tmpPrepareCH = PrepareContractionHierarchies.fromGraphHopperStorage(ghStorage, chProfile);
         tmpPrepareCH.setParams(pMap);
         return tmpPrepareCH;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelectionException.java b/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelectionException.java
new file mode 100644
index 0000000000..531b5bdb54
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelectionException.java
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.util.exceptions.DetailedIllegalArgumentException;
+
+import java.util.HashMap;
+
+public class CHProfileSelectionException extends DetailedIllegalArgumentException {
+    CHProfileSelectionException(final String message) {
+        super(message, new HashMap<String, Object>() {{
+            put("error", message);
+        }});
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelector.java b/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelector.java
new file mode 100644
index 0000000000..d9be615627
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHProfileSelector.java
@@ -0,0 +1,185 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.storage.CHProfile;
+import com.graphhopper.util.Parameters;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * This class is used to determine the appropriate CH profile given (or not given) some (request) parameters
+ */
+public class CHProfileSelector {
+    private final List<CHProfile> chProfiles;
+    private HintsMap weightingMap;
+    private IntObjectMap<CHProfile> edgeBasedCHProfilesByUTurnCosts;
+    private CHProfile nodeBasedCHProfile;
+    private List<String> entriesStrs;
+
+    private CHProfileSelector(List<CHProfile> chProfiles) {
+        this.chProfiles = chProfiles;
+    }
+
+    /**
+     * @param chProfiles   the CH profiles to choose from
+     * @param weightingMap a map used to specify the weighting that shall be used
+     * @param edgeBased    whether or not edge-based CH shall be used or null if not specified explicitly
+     * @param uTurnCosts   specifies which value the u-turn costs of the CH profile should have, or null
+     * @throws CHProfileSelectionException if no CH profile could be selected for the given parameters
+     */
+    public static CHProfile select(
+            List<CHProfile> chProfiles, HintsMap weightingMap, Boolean edgeBased, Integer uTurnCosts) {
+        return new CHProfileSelector(chProfiles).select(weightingMap, edgeBased, uTurnCosts);
+    }
+
+    private CHProfile select(HintsMap weightingMap, Boolean edgeBased, Integer uTurnCosts) {
+        this.weightingMap = weightingMap;
+        findCHProfilesMatchingWeighting();
+
+        if (!foundCHProfilesMatchingWeighting()) {
+            throw new CHProfileSelectionException("Cannot find CH profile for weighting map " + weightingMap + " in entries: " + entriesStrs + ".");
+        }
+
+        if (edgeBased != null && uTurnCosts != null) {
+            return selectUsingEdgeBasedAndUTurnCosts(edgeBased, uTurnCosts);
+        } else if (edgeBased != null) {
+            return selectUsingEdgeBased(edgeBased);
+        } else if (uTurnCosts != null) {
+            return selectUsingUTurnCosts(uTurnCosts);
+        } else {
+            return selectUsingWeightingOnly();
+        }
+    }
+
+    private CHProfile selectUsingEdgeBasedAndUTurnCosts(boolean edgeBased, int uTurnCosts) {
+        if (edgeBased) {
+            CHProfile edgeBasedCHProfile = edgeBasedCHProfilesByUTurnCosts.get(uTurnCosts);
+            if (edgeBasedCHProfile != null) {
+                return edgeBasedCHProfile;
+            } else if (!edgeBasedCHProfilesByUTurnCosts.isEmpty()) {
+                return throwFoundEdgeBasedButNotForRequestedUTurnCosts(uTurnCosts);
+            } else {
+                return throwRequestedEdgeBasedButOnlyFoundNodeBased();
+            }
+        } else {
+            if (nodeBasedCHProfile != null) {
+                return nodeBasedCHProfile;
+            } else {
+                return throwRequestedNodeBasedButOnlyFoundEdgeBased();
+            }
+        }
+    }
+
+    private CHProfile selectUsingEdgeBased(boolean edgeBased) {
+        if (edgeBased) {
+            // u-turn costs were not specified, so either there is only one edge-based profile and we take it
+            // or we throw an error
+            if (edgeBasedCHProfilesByUTurnCosts.size() == 1) {
+                return edgeBasedCHProfilesByUTurnCosts.iterator().next().value;
+            } else if (edgeBasedCHProfilesByUTurnCosts.isEmpty()) {
+                return throwRequestedEdgeBasedButOnlyFoundNodeBased();
+            } else {
+                return throwFoundEdgeBasedButUnclearWhichOneToTake();
+            }
+        } else {
+            if (nodeBasedCHProfile != null) {
+                return nodeBasedCHProfile;
+            } else {
+                return throwRequestedNodeBasedButOnlyFoundEdgeBased();
+            }
+        }
+    }
+
+    private CHProfile selectUsingUTurnCosts(int uTurnCosts) {
+        // no edge_based parameter was set, we determine the CH profile based on what is there (and prefer edge-based
+        // if we can choose)
+        CHProfile edgeBasedPCH = edgeBasedCHProfilesByUTurnCosts.get(uTurnCosts);
+        if (edgeBasedPCH != null) {
+            return edgeBasedPCH;
+        } else if (!edgeBasedCHProfilesByUTurnCosts.isEmpty()) {
+            return throwFoundEdgeBasedButNotForRequestedUTurnCosts(uTurnCosts);
+        } else {
+            return nodeBasedCHProfile;
+        }
+    }
+
+    private CHProfile selectUsingWeightingOnly() {
+        if (edgeBasedCHProfilesByUTurnCosts.size() == 1) {
+            return edgeBasedCHProfilesByUTurnCosts.iterator().next().value;
+        } else if (!edgeBasedCHProfilesByUTurnCosts.isEmpty()) {
+            return throwFoundEdgeBasedButUnclearWhichOneToTake();
+        } else {
+            return nodeBasedCHProfile;
+        }
+    }
+
+    private void findCHProfilesMatchingWeighting() {
+        entriesStrs = new ArrayList<>();
+        edgeBasedCHProfilesByUTurnCosts = new IntObjectHashMap<>(3);
+        nodeBasedCHProfile = null;
+        for (CHProfile p : chProfiles) {
+            boolean weightingMatches = p.getWeighting().matches(weightingMap);
+            if (weightingMatches) {
+                if (p.isEdgeBased()) {
+                    edgeBasedCHProfilesByUTurnCosts.put(p.getUTurnCostsInt(), p);
+                } else {
+                    nodeBasedCHProfile = p;
+                }
+            }
+            entriesStrs.add(p.toString());
+        }
+    }
+
+    private boolean foundCHProfilesMatchingWeighting() {
+        return !edgeBasedCHProfilesByUTurnCosts.isEmpty() || nodeBasedCHProfile != null;
+    }
+
+    private CHProfile throwFoundEdgeBasedButUnclearWhichOneToTake() {
+        int[] availableUTurnCosts = edgeBasedCHProfilesByUTurnCosts.keys().toArray();
+        Arrays.sort(availableUTurnCosts);
+        throw new CHProfileSelectionException("Found matching edge-based CH profiles for multiple values of u-turn costs: " + Arrays.toString(availableUTurnCosts) +
+                ". You need to specify which one to use using the `" + Parameters.Routing.U_TURN_COSTS + "' parameter");
+    }
+
+    private CHProfile throwRequestedNodeBasedButOnlyFoundEdgeBased() {
+        throw new CHProfileSelectionException("Found " + edgeBasedCHProfilesByUTurnCosts.size() + " edge-based CH profile(s) for weighting map " + weightingMap
+                + ", but requested node-based CH. You either need to configure a node-based CH profile or set the '" + Parameters.Routing.EDGE_BASED + "' " +
+                "request parameter to 'true' (was 'false'). all entries: " + entriesStrs);
+    }
+
+    private CHProfile throwRequestedEdgeBasedButOnlyFoundNodeBased() {
+        throw new CHProfileSelectionException("Found a node-based CH profile for weighting map " + weightingMap + ", but requested edge-based CH. " +
+                "You either need to configure an edge-based CH profile or set the '" + Parameters.Routing.EDGE_BASED + "' " +
+                "request parameter to 'false' (was 'true'). all entries: " + entriesStrs);
+    }
+
+    private CHProfile throwFoundEdgeBasedButNotForRequestedUTurnCosts(int uTurnCosts) {
+        int[] availableUTurnCosts = edgeBasedCHProfilesByUTurnCosts.keys().toArray();
+        Arrays.sort(availableUTurnCosts);
+        throw new CHProfileSelectionException("Found edge-based CH profiles for weighting map " + weightingMap + " but none for requested u-turn costs: " +
+                uTurnCosts + ", available: " + Arrays.toString(availableUTurnCosts) + ". You need to configure an edge-based CH profile for this value of u-turn costs or" +
+                " choose another value using the '" + Parameters.Routing.U_TURN_COSTS + "' request parameter.");
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedCHBidirPathExtractor.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedCHBidirPathExtractor.java
new file mode 100644
index 0000000000..2711b3d2fb
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedCHBidirPathExtractor.java
@@ -0,0 +1,68 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.BidirPathExtractor;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.ShortcutUnpacker;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * @author easbar
+ */
+public class EdgeBasedCHBidirPathExtractor extends BidirPathExtractor {
+    private final ShortcutUnpacker shortcutUnpacker;
+
+    public EdgeBasedCHBidirPathExtractor(Graph routingGraph, Graph baseGraph, Weighting weighting) {
+        super(baseGraph, weighting);
+        shortcutUnpacker = createShortcutUnpacker(routingGraph, weighting);
+        if (!(weighting instanceof TurnWeighting)) {
+            throw new IllegalArgumentException("Need a TurnWeighting for edge-based CH");
+        }
+    }
+
+    @Override
+    public void onEdge(int edge, int adjNode, boolean reverse, int prevOrNextEdge) {
+        if (reverse) {
+            shortcutUnpacker.visitOriginalEdgesBwd(edge, adjNode, true, prevOrNextEdge);
+        } else {
+            shortcutUnpacker.visitOriginalEdgesFwd(edge, adjNode, true, prevOrNextEdge);
+        }
+    }
+
+    private ShortcutUnpacker createShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                path.addDistance(edge.getDistance());
+                path.addTime(weighting.calcMillis(edge, reverse, prevOrNextEdgeId));
+                path.addEdge(edge.getEdge());
+            }
+        }, true);
+    }
+
+    @Override
+    public int getIncEdge(SPTEntry sptEntry) {
+        return ((CHEntry) sptEntry).incEdge;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
index 6c32d71a74..bd114fffc9 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
@@ -30,7 +30,6 @@
 
 import java.util.HashSet;
 import java.util.Locale;
-import java.util.Objects;
 import java.util.Set;
 
 import static com.graphhopper.routing.ch.CHParameters.*;
@@ -87,9 +86,6 @@ public EdgeBasedNodeContractor(CHGraph prepareGraph,
         this.encoder = turnWeighting.getFlagEncoder();
         this.pMap = pMap;
         extractParams(pMap);
-        if (!Double.isInfinite(turnWeighting.getUTurnCost())) {
-            throw new IllegalArgumentException("edge-based CH currently does not support finite u-turn costs");
-        }
     }
 
     private void extractParams(PMap pMap) {
@@ -300,10 +296,8 @@ private CHEntry doAddShortcut(CHEntry edgeFrom, CHEntry edgeTo) {
         int origFirst = edgeFrom.getParent().incEdge;
         LOGGER.trace("Adding shortcut from {} to {}, weight: {}, firstOrigEdge: {}, lastOrigEdge: {}",
                 from, adjNode, edgeTo.weight, edgeFrom.getParent().incEdge, edgeTo.incEdge);
-        // todo: so far we are not using the distance in edge based CH
-        double distance = 0.0;
         int accessFlags = PrepareEncoder.getScFwdDir();
-        int shortcutId = prepareGraph.shortcutEdgeBased(from, adjNode, accessFlags, edgeTo.weight, distance, edgeFrom.edge, edgeTo.edge, origFirst, edgeTo.incEdge);
+        int shortcutId = prepareGraph.shortcutEdgeBased(from, adjNode, accessFlags, edgeTo.weight, edgeFrom.edge, edgeTo.edge, origFirst, edgeTo.incEdge);
         final int origEdgeCount = getOrigEdgeCount(edgeFrom.edge) + getOrigEdgeCount(edgeTo.edge);
         setOrigEdgeCount(shortcutId, origEdgeCount);
         addedShortcutsCount++;
@@ -428,6 +422,9 @@ public String toString() {
     }
 
     private class AggressiveStrategy implements SearchStrategy {
+        private IntSet sourceNodes = new IntHashSet(10);
+        private IntSet toNodes = new IntHashSet(10);
+
         @Override
         public String getStatisticsString() {
             return witnessPathSearcher.getStatisticsString();
@@ -446,8 +443,7 @@ public void findAndHandleShortcuts(int node) {
             Set<AddedShortcut> addedShortcuts = new HashSet<>();
 
             // first we need to identify the possible source nodes from which we can reach the center node
-            // todo: optimize collection size
-            IntSet sourceNodes = new IntHashSet(100);
+            sourceNodes.clear();
             EdgeIterator incomingEdges = inEdgeExplorer.setBaseNode(node);
             while (incomingEdges.next()) {
                 int sourceNode = incomingEdges.getAdjNode();
@@ -467,8 +463,7 @@ public void findAndHandleShortcuts(int node) {
                     }
 
                     // now we need to identify all target nodes that can be reached from the center node
-                    // todo: optimize collection size
-                    IntSet toNodes = new IntHashSet(100);
+                    toNodes.clear();
                     EdgeIterator outgoingEdges = outEdgeExplorer.setBaseNode(node);
                     while (outgoingEdges.next()) {
                         int targetNode = outgoingEdges.getAdjNode();
@@ -491,7 +486,7 @@ public void findAndHandleShortcuts(int node) {
                                 continue;
                             }
                             CHEntry root = entry.getParent();
-                            while (root.parent.edge != EdgeIterator.NO_EDGE) {
+                            while (EdgeIterator.Edge.isValid(root.parent.edge)) {
                                 root = root.getParent();
                             }
                             // todo: removing this 'optimization' improves contraction time significantly, but introduces 
@@ -540,7 +535,7 @@ public boolean equals(Object o) {
 
         @Override
         public int hashCode() {
-            return Objects.hash(startNode, startEdge, endNode, targetEdge);
+            return 31 * startNode + endNode;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
deleted file mode 100644
index 0574ae359a..0000000000
--- a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.graphhopper.routing.ch;
-
-import com.graphhopper.routing.weighting.TurnWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.storage.ShortcutUnpacker;
-import com.graphhopper.util.EdgeIteratorState;
-
-
-public class EdgeBasedPathCH extends Path4CH {
-
-    private final TurnWeighting turnWeighting;
-
-    public EdgeBasedPathCH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
-        super(routingGraph, baseGraph, weighting);
-        if (!(weighting instanceof TurnWeighting)) {
-            throw new IllegalArgumentException("Need a TurnWeighting for edge-based CH");
-        }
-        turnWeighting = (TurnWeighting) weighting;
-    }
-
-    @Override
-    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
-        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
-            @Override
-            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-                distance += edge.getDistance();
-                time += turnWeighting.calcMillis(edge, reverse, prevOrNextEdgeId);
-                addEdge(edge.getEdge());
-            }
-        }, true);
-    }
-
-    @Override
-    protected int getIncEdge(SPTEntry entry) {
-        return ((CHEntry) entry).incEdge;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedCHBidirPathExtractor.java
similarity index 59%
rename from core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
rename to core/src/main/java/com/graphhopper/routing/ch/NodeBasedCHBidirPathExtractor.java
index e77cadf5d0..be8fc1adbb 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedCHBidirPathExtractor.java
@@ -15,9 +15,10 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
+
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.PathBidirRef;
+import com.graphhopper.routing.BidirPathExtractor;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.ShortcutUnpacker;
@@ -25,33 +26,30 @@
 
 import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 
-public class Path4CH extends PathBidirRef {
+public class NodeBasedCHBidirPathExtractor extends BidirPathExtractor {
     private final ShortcutUnpacker shortcutUnpacker;
 
-    public Path4CH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
+    public NodeBasedCHBidirPathExtractor(Graph routingGraph, Graph baseGraph, Weighting weighting) {
         super(baseGraph, weighting);
-        this.shortcutUnpacker = getShortcutUnpacker(routingGraph, weighting);
-    }
-
-    @Override
-    protected final void processEdge(int edgeId, int adjNode, int prevEdgeId) {
-        // Shortcuts do only contain valid weight so first expand before adding
-        // to distance and time
-        shortcutUnpacker.visitOriginalEdgesFwd(edgeId, adjNode, true, prevEdgeId);
+        shortcutUnpacker = createShortcutUnpacker(routingGraph, weighting);
     }
 
     @Override
-    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
-        shortcutUnpacker.visitOriginalEdgesBwd(edgeId, adjNode, true, nextEdgeId);
+    public void onEdge(int edge, int adjNode, boolean reverse, int prevOrNextEdge) {
+        if (reverse) {
+            shortcutUnpacker.visitOriginalEdgesBwd(edge, adjNode, true, prevOrNextEdge);
+        } else {
+            shortcutUnpacker.visitOriginalEdgesFwd(edge, adjNode, true, prevOrNextEdge);
+        }
     }
 
-    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+    private ShortcutUnpacker createShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
         return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
             @Override
             public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-                distance += edge.getDistance();
-                time += weighting.calcMillis(edge, reverse, NO_EDGE);
-                addEdge(edge.getEdge());
+                path.addDistance(edge.getDistance());
+                path.addTime(weighting.calcMillis(edge, reverse, NO_EDGE));
+                path.addEdge(edge.getEdge());
             }
         }, false);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
index cbefc3d8d1..d3102822f9 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -176,7 +176,6 @@ private long findShortcuts(ShortcutHandler sch) {
             if (Double.isInfinite(incomingEdgeWeight)) {
                 continue;
             }
-            final double incomingEdgeDistance = incomingEdges.getDistance();
             int incomingEdge = incomingEdges.getEdge();
             int inOrigEdgeCount = getOrigEdgeCount(incomingEdge);
             // collect outgoing nodes (goal-nodes) only once
@@ -202,7 +201,6 @@ private long findShortcuts(ShortcutHandler sch) {
                 if (Double.isInfinite(existingDirectWeight))
                     continue;
 
-                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
                 prepareAlgo.setWeightLimit(existingDirectWeight);
                 prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
                 prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
@@ -217,8 +215,7 @@ private long findShortcuts(ShortcutHandler sch) {
                     // FOUND witness path, so do not add shortcut
                     continue;
 
-                sch.foundShortcut(fromNode, toNode,
-                        existingDirectWeight, existingDistSum,
+                sch.foundShortcut(fromNode, toNode, existingDirectWeight,
                         outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
                         incomingEdge, inOrigEdgeCount);
             }
@@ -264,7 +261,6 @@ private int addShortcuts(Collection<Shortcut> shortcuts) {
                     }
 
                     iter.setFlagsAndWeight(sc.flags, sc.weight);
-                    iter.setDistance(sc.dist);
                     iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
                     setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
                     updatedInGraph = true;
@@ -273,7 +269,7 @@ private int addShortcuts(Collection<Shortcut> shortcuts) {
             }
 
             if (!updatedInGraph) {
-                int scId = prepareGraph.shortcut(sc.from, sc.to, sc.flags, sc.weight, sc.dist, sc.skippedEdge1, sc.skippedEdge2);
+                int scId = prepareGraph.shortcut(sc.from, sc.to, sc.flags, sc.weight, sc.skippedEdge1, sc.skippedEdge2);
                 setOrigEdgeCount(scId, sc.originalEdges);
 
                 tmpNewShortcuts++;
@@ -321,16 +317,14 @@ private int getMaxVisitedNodesEstimate() {
         int to;
         int skippedEdge1;
         int skippedEdge2;
-        double dist;
         double weight;
         int originalEdges;
         int flags = PrepareEncoder.getScFwdDir();
 
-        public Shortcut(int from, int to, double weight, double dist) {
+        public Shortcut(int from, int to, double weight) {
             this.from = from;
             this.to = to;
             this.weight = weight;
-            this.dist = dist;
         }
 
         @Override
@@ -361,13 +355,12 @@ public String toString() {
             else
                 str = from + "->";
 
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + "), dist: " + dist;
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
         }
     }
 
     private interface ShortcutHandler {
-        void foundShortcut(int fromNode, int toNode,
-                           double existingDirectWeight, double distance,
+        void foundShortcut(int fromNode, int toNode, double existingDirectWeight,
                            int outgoingEdge, int outOrigEdgeCount,
                            int incomingEdge, int inOrigEdgeCount);
 
@@ -391,8 +384,7 @@ public CalcShortcutHandler setNode(int node) {
         }
 
         @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double distance,
+        public void foundShortcut(int fromNode, int toNode, double existingDirectWeight,
                                   int outgoingEdge, int outOrigEdgeCount,
                                   int incomingEdge, int inOrigEdgeCount) {
             calcShortcutsResult.shortcutsCount++;
@@ -415,8 +407,7 @@ public AddShortcutHandler setNode(int node) {
         }
 
         @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double existingDistSum,
+        public void foundShortcut(int fromNode, int toNode, double existingDirectWeight,
                                   int outgoingEdge, int outOrigEdgeCount,
                                   int incomingEdge, int inOrigEdgeCount) {
             // FOUND shortcut
@@ -424,11 +415,11 @@ public void foundShortcut(int fromNode, int toNode,
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
+            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight);
             if (shortcuts.containsKey(sc))
                 return;
 
-            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight);
             Shortcut tmpRetSc = shortcuts.get(tmpSc);
             // overwrite flags only if skipped edges are identical
             if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 6af742cc72..df216f9968 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -52,11 +52,11 @@
  */
 public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory {
     private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final CHProfile chProfile;
     private final PreparationWeighting prepareWeighting;
-    private final Weighting weighting;
-    private final TraversalMode traversalMode;
     private final CHGraph prepareGraph;
     private final Random rand = new Random(123);
+    private final IntSet updatedNeighbors;
     private final StopWatch allSW = new StopWatch();
     private final StopWatch periodicUpdateSW = new StopWatch();
     private final StopWatch lazyUpdateSW = new StopWatch();
@@ -74,16 +74,16 @@
     private PMap pMap = new PMap();
     private int checkCounter;
 
-    public PrepareContractionHierarchies(CHGraph chGraph, Weighting weighting, TraversalMode traversalMode) {
+    public PrepareContractionHierarchies(CHGraph chGraph) {
         this.prepareGraph = chGraph;
-        this.traversalMode = traversalMode;
-        this.weighting = weighting;
-        prepareWeighting = new PreparationWeighting(weighting);
-        this.params = Params.forTraversalMode(traversalMode);
+        this.chProfile = chGraph.getCHProfile();
+        prepareWeighting = new PreparationWeighting(chProfile.getWeighting());
+        this.params = Params.forTraversalMode(chProfile.getTraversalMode());
+        updatedNeighbors = new IntHashSet(50);
     }
 
-    public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperStorage ghStorage, Weighting weighting, TraversalMode traversalMode) {
-        return new PrepareContractionHierarchies(ghStorage.getGraph(CHGraph.class, weighting), weighting, traversalMode);
+    public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperStorage ghStorage, CHProfile chProfile) {
+        return new PrepareContractionHierarchies(ghStorage.getCHGraph(chProfile));
     }
 
     public PrepareContractionHierarchies setParams(PMap pMap) {
@@ -150,7 +150,7 @@ public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
     }
 
     private AbstractBidirAlgo doCreateAlgo(Graph graph, AlgorithmOptions opts) {
-        if (traversalMode.isEdgeBased()) {
+        if (chProfile.isEdgeBased()) {
             return createAlgoEdgeBased(graph, opts);
         } else {
             return createAlgoNodeBased(graph, opts);
@@ -184,7 +184,7 @@ private AbstractBidirAlgo createAlgoNodeBased(Graph graph, AlgorithmOptions opts
     }
 
     public boolean isEdgeBased() {
-        return traversalMode.isEdgeBased();
+        return chProfile.isEdgeBased();
     }
 
     private void initFromGraph() {
@@ -201,7 +201,7 @@ private void initFromGraph() {
         //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
         oldPriorities = new float[prepareGraph.getNodes()];
-        nodeContractor = createNodeContractor(prepareGraph, traversalMode);
+        nodeContractor = createNodeContractor(prepareGraph, chProfile.getTraversalMode());
         nodeContractor.initFromGraph();
     }
 
@@ -230,39 +230,39 @@ private void contractNodesUsingHeuristicNodeOrdering() {
         // but has always been like that and changing it would possibly require retuning the contraction parameters
         updatePrioritiesOfRemainingNodes();
         nodeContractor.prepareContraction();
-        int initSize = sortedNodes.getSize();
+        final int initSize = sortedNodes.getSize();
         int level = 0;
         checkCounter = 0;
-        long logSize = Math.round(Math.max(10, initSize / 100d * params.getLogMessagesPercentage()));
-        if (params.getLogMessagesPercentage() == 0)
-            logSize = Integer.MAX_VALUE;
-
-        // preparation takes longer but queries are slightly faster with preparation
-        // => enable it but call not so often
-        boolean periodicUpdate = true;
+        final long logSize = params.getLogMessagesPercentage() == 0
+                ? Long.MAX_VALUE
+                : Math.round(Math.max(10, initSize * (params.getLogMessagesPercentage() / 100d)));
+
+        // specifies after how many contracted nodes the queue of remaining nodes is rebuilt. this takes time but the
+        // more often we do this the more up-to-date the node priorities will be
+        // todo: instead of using a fixed interval size maybe try adjusting it depending on the number of remaining
+        // nodes ?
+        final long periodicUpdatesCount = params.getPeriodicUpdatesPercentage() == 0
+                ? Long.MAX_VALUE
+                : Math.round(Math.max(10, initSize * (params.getPeriodicUpdatesPercentage() / 100d)));
         int updateCounter = 0;
-        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * params.getPeriodicUpdatesPercentage()));
-        if (params.getPeriodicUpdatesPercentage() == 0)
-            periodicUpdate = false;
 
-        // disable lazy updates for last x percentage of nodes as preparation is then a lot slower
-        // and query time does not really benefit
-        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * params.getLastNodesLazyUpdatePercentage());
+        // enable lazy updates for last x percentage of nodes. lazy updates make preparation slower but potentially
+        // keep node priorities more up to date, possibly resulting in a better preparation.
+        final long lastNodesLazyUpdates = Math.round(initSize * (params.getLastNodesLazyUpdatePercentage() / 100d));
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
-        long nodesToAvoidContract = Math.round((100 - params.getNodesContractedPercentage()) / 100d * sortedNodes.getSize());
+        final long nodesToAvoidContract = Math.round(initSize * ((100 - params.getNodesContractedPercentage()) / 100d));
 
-        // Recompute priority of uncontracted neighbors.
-        // Without neighbor updates preparation is faster but we need them
-        // to slightly improve query time. Also if not applied too often it decreases the shortcut number.
-        boolean neighborUpdate = true;
-        if (params.getNeighborUpdatePercentage() == 0)
-            neighborUpdate = false;
+        // Recompute priority of (the given percentage of) uncontracted neighbors. Doing neighbor updates takes additional
+        // time during preparation but keeps node priorities more up to date. this potentially improves query time and
+        // reduces number of shortcuts.
+        final boolean neighborUpdate = (params.getNeighborUpdatePercentage() != 0);
 
         while (!sortedNodes.isEmpty()) {
+            stopIfInterrupted();
             // periodically update priorities of ALL nodes
-            if (periodicUpdate && checkCounter > 0 && checkCounter % periodicUpdatesCount == 0) {
+            if (checkCounter > 0 && checkCounter % periodicUpdatesCount == 0) {
                 updatePrioritiesOfRemainingNodes();
                 updateCounter++;
                 if (sortedNodes.isEmpty())
@@ -297,25 +297,20 @@ private void contractNodesUsingHeuristicNodeOrdering() {
                 break;
 
             // there might be multiple edges going to the same neighbor nodes -> only calculate priority once per node
-            IntSet updatedNeighors = new IntHashSet(10);
+            updatedNeighbors.clear();
             CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next()) {
-
-                if (Thread.currentThread().isInterrupted()) {
-                    throw new RuntimeException("Thread was interrupted");
-                }
-
                 int nn = iter.getAdjNode();
                 if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
-                if (neighborUpdate && !updatedNeighors.contains(nn) && rand.nextInt(100) < params.getNeighborUpdatePercentage()) {
+                if (neighborUpdate && !updatedNeighbors.contains(nn) && rand.nextInt(100) < params.getNeighborUpdatePercentage()) {
                     neighborUpdateSW.start();
                     float oldPrio = oldPriorities[nn];
                     float priority = oldPriorities[nn] = calculatePriority(nn);
                     if (priority != oldPrio) {
                         sortedNodes.update(nn, oldPrio, priority);
-                        updatedNeighors.add(nn);
+                        updatedNeighbors.add(nn);
                     }
                     neighborUpdateSW.stop();
                 }
@@ -349,6 +344,7 @@ private void contractNodesUsingFixedNodeOrdering() {
         StopWatch stopWatch = new StopWatch();
         stopWatch.start();
         for (int i = 0; i < nodesToContract; ++i) {
+            stopIfInterrupted();
             int node = nodeOrderingProvider.getNodeIdForLevel(i);
             contractNode(node, i);
 
@@ -367,6 +363,12 @@ private void contractNodesUsingFixedNodeOrdering() {
         }
     }
 
+    private void stopIfInterrupted() {
+        if (Thread.currentThread().isInterrupted()) {
+            throw new RuntimeException("Thread was interrupted");
+        }
+    }
+
     private void contractNode(int node, int level) {
         contractionSW.start();
         nodeContractor.contractNode(node);
@@ -426,7 +428,11 @@ public double getNeighborTime() {
     }
 
     public Weighting getWeighting() {
-        return weighting;
+        return chProfile.getWeighting();
+    }
+
+    public CHProfile getCHProfile() {
+        return chProfile;
     }
 
     private String getTimesAsString() {
@@ -449,7 +455,7 @@ private float calculatePriority(int node) {
 
     @Override
     public String toString() {
-        return traversalMode.isEdgeBased() ? "prepare|dijkstrabi|edge|ch" : "prepare|dijkstrabi|ch";
+        return chProfile.isEdgeBased() ? "prepare|dijkstrabi|edge|ch" : "prepare|dijkstrabi|ch";
     }
 
     private NodeContractor createNodeContractor(Graph graph, TraversalMode traversalMode) {
@@ -457,7 +463,7 @@ private NodeContractor createNodeContractor(Graph graph, TraversalMode traversal
             TurnWeighting chTurnWeighting = createTurnWeightingForEdgeBased(graph);
             return new EdgeBasedNodeContractor(prepareGraph, chTurnWeighting, pMap);
         } else {
-            return new NodeBasedNodeContractor(prepareGraph, weighting, pMap);
+            return new NodeBasedNodeContractor(prepareGraph, chProfile.getWeighting(), pMap);
         }
     }
 
@@ -469,31 +475,41 @@ private TurnWeighting createTurnWeightingForEdgeBased(Graph graph) {
             throw new IllegalArgumentException("For edge-based CH you need a turn cost extension");
         }
         TurnCostExtension turnCostExtension = (TurnCostExtension) extension;
-        return new TurnWeighting(prepareWeighting, turnCostExtension);
+        return new TurnWeighting(prepareWeighting, turnCostExtension, chProfile.getUTurnCosts());
     }
 
     private static class Params {
         /**
-         * Specifies how often periodic updates will happen. The higher the value the longer the preparation takes
-         * but the less shortcuts are produced.
+         * Specifies after how many contracted nodes a full refresh of the queue of remaining/not contracted nodes
+         * is performed. For example for a graph with 1000 nodes a value of 20 means that a full refresh is performed
+         * after every 200 nodes (20% of the number of nodes of the graph). The more of these updates are performed
+         * the longer the preparation will take, but the more up-to-date the node priorities will be. Higher values
+         * here mean fewer updates!
          */
         private int periodicUpdatesPercentage;
         /**
-         * Specifies when lazy updates will happen, measured relative to all existing nodes. 100 means always.
+         * Specifies the fraction of nodes for which lazy updates will be performed. For example a value of 20 means
+         * that lazy updates will be performed for the last 20% of all nodes. A value of 100 means lazy updates will
+         * be performed for all nodes. Higher values here lead to a longer preparation time, but the node priorities
+         * will be more up-to-date (potentially leading to a better preparation (less shortcuts/faster queries)).
          */
         private int lastNodesLazyUpdatePercentage;
         /**
-         * Specifies how often neighbor updates will happen. 100 means always.
+         * Specifies the probability that the priority of a given neighbor of a contracted node will be updated after
+         * the node was contracted. For example a value of 20 means that on average 20% of the neighbor nodes will be
+         * updated / each neighbor will be updated with a chance of 20%. Higher values here lead to longer preparation
+         * times, but the node priorities will be more up-to-date.
          */
         private int neighborUpdatePercentage;
         /**
-         * Defines how many nodes (percentage) should be contracted. Less nodes means slower query but
-         * faster contraction.
+         * Defines how many nodes (percentage) should be contracted. A value of 20 means only the first 20% of all nodes
+         * will be contracted. Higher values here mean longer preparation times, but faster queries (because the
+         * graph will be fully contracted).
          */
         private int nodesContractedPercentage;
         /**
-         * Specifies how often a log message should be printed. Specify something around 20 (20% of the
-         * start nodes).
+         * Specifies how often a log message should be printed.
+         * @see #periodicUpdatesPercentage
          */
         private int logMessagesPercentage;
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java b/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java
index f7dd5cb577..f47a0175e7 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java
@@ -183,7 +183,7 @@ public CHEntry runSearch(int targetNode, int targetEdge) {
         while (inIter.next()) {
             final int incEdge = inIter.getOrigEdgeLast();
             final int edgeKey = getEdgeKey(incEdge, targetNode);
-            if (edges[edgeKey] != NO_EDGE) {
+            if (EdgeIterator.Edge.isValid(edges[edgeKey])) {
                 boolean isZeroWeightLoop = parents[edgeKey] >= 0 && targetNode == adjNodes[parents[edgeKey]] &&
                         weights[edgeKey] - weights[parents[edgeKey]] <= MAX_ZERO_WEIGHT_LOOP;
                 if (!isZeroWeightLoop) {
@@ -239,7 +239,7 @@ public CHEntry runSearch(int targetNode, int targetEdge) {
 
                 // dijkstra expansion: add or update current entries
                 int key = getEdgeKey(iter.getOrigEdgeLast(), iter.getAdjNode());
-                if (edges[key] == NO_EDGE) {
+                if (!EdgeIterator.Edge.isValid(edges[key])) {
                     setEntry(key, iter, weight, currKey, isPathToCenter);
                     changedEdges.add(key);
                     dijkstraHeap.insert_(weight, key);
@@ -348,7 +348,7 @@ private void setInitialEntries(int sourceNode, int sourceEdge, int centerNode) {
                     NO_EDGE,
                     outIter.getOrigEdgeFirst(),
                     sourceNode, turnWeight);
-            if (edges[key] == NO_EDGE) {
+            if (!EdgeIterator.Edge.isValid(edges[key])) {
                 // add new initial entry
                 edges[key] = outIter.getEdge();
                 incEdges[key] = incEdge;
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
index 505fccc6f2..12a2499c3e 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
@@ -31,7 +31,6 @@
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.Parameters.Landmark;
@@ -88,7 +87,7 @@ public void init(CmdArgs args) {
                 lmSuggestionsLocations.add(loc.trim());
         }
         String lmWeightingsStr = args.get(Landmark.PREPARE + "weightings", "");
-        if (!lmWeightingsStr.isEmpty() && !lmWeightingsStr.equalsIgnoreCase("no")) {
+        if (!lmWeightingsStr.isEmpty() && !lmWeightingsStr.equalsIgnoreCase("no") && !lmWeightingsStr.equalsIgnoreCase("false")) {
             List<String> tmpLMWeightingList = Arrays.asList(lmWeightingsStr.split(","));
             setWeightingsAsStrings(tmpLMWeightingList);
         }
@@ -271,13 +270,13 @@ public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
      * @see com.graphhopper.routing.ch.CHAlgoFactoryDecorator#prepare(StorableProperties) for a very similar method
      */
     public boolean loadOrDoWork(final StorableProperties properties) {
-        ExecutorCompletionService completionService = new ExecutorCompletionService<>(threadPool);
+        ExecutorCompletionService<String> completionService = new ExecutorCompletionService<>(threadPool);
         int counter = 0;
         final AtomicBoolean prepared = new AtomicBoolean(false);
         for (final PrepareLandmarks plm : preparations) {
             counter++;
             final int tmpCounter = counter;
-            final String name = AbstractWeighting.weightingToFileName(plm.getWeighting(), false);
+            final String name = AbstractWeighting.weightingToFileName(plm.getWeighting());
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
index 2ca516593d..793db907ee 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
@@ -57,7 +57,7 @@
     private static final Logger LOGGER = LoggerFactory.getLogger(LandmarkStorage.class);
     // This value is used to identify nodes where no subnetwork is associated
     private static final int UNSET_SUBNETWORK = -1;
-    // This value should only be used if subnetwork is too small to be explicitely stored
+    // This value should only be used if subnetwork is too small to be explicitly stored
     private static final int UNCLEAR_SUBNETWORK = 0;
     // one node has an associated landmark information ('one landmark row'): the forward and backward weight
     private long LM_ROW_LENGTH;
@@ -106,7 +106,7 @@ public String toString() {
         // Edge based is not really necessary because when adding turn costs while routing we can still
         // use the node based traversal as this is a smaller weight approximation and will still produce correct results
         this.traversalMode = TraversalMode.NODE_BASED;
-        final String name = AbstractWeighting.weightingToFileName(weighting, false);
+        final String name = AbstractWeighting.weightingToFileName(weighting);
         this.landmarkWeightDA = dir.find("landmarks_" + name);
 
         this.landmarks = landmarks;
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java b/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java
index a2a4dda666..e12b6b2a0a 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java
@@ -49,10 +49,16 @@ public EncodedValue create(String string) {
             enc = MaxHeight.create();
         } else if (MaxWidth.KEY.equals(name)) {
             enc = MaxWidth.create();
+        } else if (MaxAxleLoad.KEY.equals(name)) {
+            enc = MaxAxleLoad.create();
+        } else if (MaxLength.KEY.equals(name)) {
+            enc = MaxLength.create();
         } else if (Surface.KEY.equals(name)) {
             enc = new EnumEncodedValue<>(Surface.KEY, Surface.class);
         } else if (Toll.KEY.equals(name)) {
             enc = new EnumEncodedValue<>(Toll.KEY, Toll.class);
+        } else if (TrackType.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(TrackType.KEY, TrackType.class);
         } else {
             throw new IllegalArgumentException("DefaultEncodedValueFactory cannot find EncodedValue " + name);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java
index e0a2ea5fb1..6f689ae3ff 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.profiles;
 
 import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.Helper;
 
 import java.util.Arrays;
 
@@ -53,13 +54,8 @@ public boolean equals(Object o) {
         return Arrays.equals(arr, that.arr);
     }
 
-    @Override
-    public int hashCode() {
-        return 31 * super.hashCode() + Arrays.hashCode(arr);
-    }
-
     @Override
     public int getVersion() {
-        return hashCode();
+        return 31 * super.getVersion() + staticHashCode(arr);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxAxleLoad.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxAxleLoad.java
new file mode 100644
index 0000000000..2872c19473
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxAxleLoad.java
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * Defines the maximum weight per axle for an edge.
+ */
+public class MaxAxleLoad {
+    public static final String KEY = "max_axle_load";
+
+    /**
+     * Currently enables to store 0.5 to max=0.5*2 tons and infinity. If a value is between the maximum and infinity
+     * it is assumed to use the maximum value. To save bits it might make more sense to store only a few values like
+     * it was done with the MappedDecimalEncodedValue still handling (or rounding) of unknown values is unclear.
+     */
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 7, 0.5, Double.POSITIVE_INFINITY, false);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java
index bdaa46eb03..b245409bd1 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java
@@ -18,8 +18,9 @@
 package com.graphhopper.routing.profiles;
 
 /**
- * One of the three logistic attributes that can be stored per edge.
+ * One of the four logistic attributes that can be stored per edge.
  *
+ * @see MaxLength
  * @see MaxWidth
  * @see MaxWeight
  */
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxLength.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxLength.java
new file mode 100644
index 0000000000..72b7664cd1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxLength.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * One of the four logistic attributes that can be stored per edge.
+ *
+ * @see MaxHeight
+ * @see MaxWeight
+ * @see MaxWidth
+ */
+public class MaxLength {
+    public static final String KEY = "max_length";
+
+    /**
+     * Currently enables to store 0.1 to max=0.1*2m and infinity. If a value is
+     * between the maximum and infinity it is assumed to use the maximum value.
+     */
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 7, 0.1, Double.POSITIVE_INFINITY, false);
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java
index caad9a337e..3b24706104 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java
@@ -18,9 +18,10 @@
 package com.graphhopper.routing.profiles;
 
 /**
- * One of the three logistic attributes that can be stored per edge.
+ * One of the four logistic attributes that can be stored per edge.
  *
  * @see MaxHeight
+ * @see MaxLength
  * @see MaxWidth
  */
 public class MaxWeight {
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java
index 02d0c6a71e..b4d6175ec1 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java
@@ -18,9 +18,10 @@
 package com.graphhopper.routing.profiles;
 
 /**
- * One of the three logistic attributes that can be stored per edge.
+ * One of the four logistic attributes that can be stored per edge.
  *
  * @see MaxHeight
+ * @see MaxLength
  * @see MaxWeight
  */
 public class MaxWidth {
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/TrackType.java b/core/src/main/java/com/graphhopper/routing/profiles/TrackType.java
new file mode 100644
index 0000000000..a0f5fdb0a2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/TrackType.java
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * This enum defines the track type of an edge which describes how
+ * well-maintained a certain track is. All edges that do not fit get "other" as
+ * value.
+ * 
+ * @see https://wiki.openstreetmap.org/wiki/Tracktype
+ */
+public enum TrackType {
+    OTHER("other"), GRADE1("grade1"), GRADE2("grade2"), GRADE3("grade3"), GRADE4("grade4"),
+    GRADE5("grade5");
+
+    public static final String KEY = "track_type";
+
+    private final String name;
+
+    TrackType(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public static TrackType find(String name) {
+        if (name == null)
+            return OTHER;
+        try {
+            return TrackType.valueOf(Helper.toUpperCase(name));
+        } catch (IllegalArgumentException ex) {
+            return OTHER;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java
index e4cf249091..8fcc56a80d 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java
@@ -19,8 +19,6 @@
 
 import com.graphhopper.storage.IntsRef;
 
-import java.util.Objects;
-
 /**
  * This class holds a decimal value and stores it as an unsigned integer value via a conversion factor and a maximum number
  * of bits.
@@ -86,13 +84,8 @@ public boolean equals(Object o) {
         return Double.compare(that.factor, factor) == 0;
     }
 
-    @Override
-    public int hashCode() {
-        return Objects.hash(super.hashCode(), factor);
-    }
-
     @Override
     public int getVersion() {
-        return hashCode();
+        return 31 * (31 * super.getVersion() + staticHashCode(factor)) + staticHashCode(defaultValue);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java
index 94a75dd30e..e9a95ac8c6 100644
--- a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.storage.IntsRef;
 
+import java.util.Arrays;
 import java.util.Locale;
 import java.util.Objects;
 
@@ -171,12 +172,74 @@ public boolean equals(Object o) {
     }
 
     @Override
-    public int hashCode() {
-        return Objects.hash(name, fwdDataIndex, bwdDataIndex, bits, maxValue, fwdShift, bwdShift, fwdMask, bwdMask, storeTwoDirections);
+    public final int hashCode() {
+        return getVersion();
     }
 
     @Override
     public int getVersion() {
-        return hashCode();
+        int val = staticHashCode(name);
+        val = 31 * val + (storeTwoDirections ? 1231 : 1237);
+        return staticHashCode(val, fwdDataIndex, bwdDataIndex, bits, maxValue, fwdShift, bwdShift, fwdMask, bwdMask);
+    }
+
+    /**
+     * Produces a static hashcode for an integer arrays that is platform independent and still compatible to the default
+     * of openjdk.
+     *
+     * @see Arrays#hashCode(int[])
+     */
+    static int staticHashCode(int... vals) {
+        if (vals == null)
+            return 0;
+        int len = vals.length;
+        int val = 1;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + vals[idx];
+        }
+
+        return val;
+    }
+
+    /**
+     * Produces a static hashcode for an Enum arrays that is platform independent and still compatible to the default
+     * of openjdk.
+     */
+    static int staticHashCode(Enum... vals) {
+        if (vals == null)
+            return 0;
+        int len = vals.length;
+        int val = 1;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + vals[idx].ordinal();
+        }
+
+        return val;
+    }
+
+    /**
+     * Produces a static hashcode for an integer arrays that is platform independent and still compatible to the default
+     * of openjdk
+     *
+     * @see Double#hashCode
+     */
+    static int staticHashCode(double val) {
+        long var2 = Double.doubleToLongBits(val);
+        return (int) (var2 ^ var2 >>> 32);
+    }
+
+    /**
+     * Produces a static hashcode for a string that is platform independent and still compatible to the default
+     * of openjdk. Do not use for performance critical applications.
+     *
+     * @see String#hashCode()
+     */
+    static int staticHashCode(String str) {
+        int len = str.length();
+        int val = 0;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + str.charAt(idx);
+        }
+        return val;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 27ac7ebac3..863ffae5ba 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -17,10 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.ConditionalTagInspector;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderRelation;
-import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.reader.*;
 import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
 import com.graphhopper.reader.osm.conditional.DateRangeParser;
 import com.graphhopper.routing.profiles.*;
@@ -64,7 +61,7 @@
     protected BooleanEncodedValue roundaboutEnc;
     protected DecimalEncodedValue speedEncoder;
     protected PMap properties;
-    // This value determines the maximal possible speed of any road regardless the maxspeed value
+    // This value determines the maximal possible speed of any road regardless of the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
     /* Edge Flag Encoder fields */
@@ -181,6 +178,8 @@ public int defineRelationBits(int index, int shift) {
         return shift;
     }
 
+    public boolean acceptsTurnRelation(OSMTurnRelation relation) { return true; }
+
     /**
      * Analyze the properties of a relation and create the routing flags for the second read step.
      * In the pre-parsing step this method will be called to determine the useful relation tags.
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index cd4760a063..d2319b57d0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -45,7 +45,7 @@
      */
     public static final int K_UNPAVED = 100;
     protected static final int PUSHING_SECTION_SPEED = 4;
-    // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
+    // Pushing section highways are parts where you need to get off your bike and push it (German: Schiebestrecke)
     protected final HashSet<String> pushingSectionsHighways = new HashSet<>();
     protected final HashSet<String> oppositeLanes = new HashSet<>();
     protected final Set<String> preferHighwayTags = new HashSet<>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 9e4ed568b1..489a9f8638 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -36,8 +36,8 @@ public BikeFlagEncoder(String propertiesString) {
     }
 
     public BikeFlagEncoder(PMap properties) {
-        this((int) properties.getLong("speed_bits", 4),
-                properties.getLong("speed_factor", 2),
+        this(properties.getInt("speed_bits", 4),
+                properties.getInt("speed_factor", 2),
                 properties.getBool("turn_costs", false) ? 1 : 0);
         this.properties = properties;
         this.setBlockFords(properties.getBool("block_fords", true));
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 34ec013448..49f73f583a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.EncodedValue;
@@ -186,6 +187,14 @@ protected double getSpeed(ReaderWay way) {
         return speed;
     }
 
+    @Override
+    public boolean acceptsTurnRelation(OSMTurnRelation relation) {
+        if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
+            return true;
+        }
+        return false;
+    }
+
     @Override
     public EncodingManager.Access getAccess(ReaderWay way) {
         // TODO: Ferries have conditionals, like opening hours or are closed during some time in the year
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index 5d5ce97847..e7b36598dd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.*;
@@ -115,6 +116,14 @@ public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         return oldRelationFlags;
     }
 
+    @Override
+    public boolean acceptsTurnRelation(OSMTurnRelation relation) {
+        if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
+            return true;
+        }
+        return false;
+    }
+
     @Override
     public EncodingManager.Access getAccess(ReaderWay way) {
         // important to skip unsupported highways, otherwise too many have to be removed after graph creation
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 3d0b3fb4ee..f22885e73e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
@@ -124,8 +125,6 @@ public static EncodingManager create(EncodedValueFactory evFactory, FlagEncoderF
             throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
                     + dir.getLocation());
 
-        // check encoding for compatibility
-        properties.checkVersions(false);
         int bytesForFlags = 4;
         try {
             bytesForFlags = Integer.parseInt(properties.get("graph.bytes_for_flags"));
@@ -144,7 +143,6 @@ public static EncodingManager create(EncodedValueFactory evFactory, FlagEncoderF
             throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
                     + dir.getLocation());
 
-
         return builder.build();
     }
 
@@ -289,14 +287,7 @@ public EncodingManager build() {
                 entry = entry.split("\\|")[0];
             }
             PMap configuration = new PMap(entryVal);
-
-            FlagEncoder fe = factory.createFlagEncoder(entry, configuration);
-
-            if (configuration.has("version") && fe.getVersion() != configuration.getInt("version", -1))
-                throw new IllegalArgumentException("Encoder " + entry + " was used in version "
-                        + configuration.getLong("version", -1) + ", but current version is " + fe.getVersion());
-
-            resultEncoders.add(fe);
+            resultEncoders.add(factory.createFlagEncoder(entry, configuration));
         }
         return resultEncoders;
     }
@@ -315,11 +306,6 @@ private void add(Builder builder, EncodedValueFactory factory, String evList) {
             PMap map = new PMap(entry);
             if (!map.has("version"))
                 throw new IllegalArgumentException("encoded value must have a version specified but it was " + entry);
-
-            int version = map.getInt("version", Integer.MIN_VALUE);
-            int stored = evObject.getVersion();
-            if (stored != version)
-                throw new IllegalArgumentException("Version of EncodedValue " + evObject + " does not match " + entry + ". Stored " + stored + " vs. in code " + version);
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 3b56c8f19b..c5caf46f0a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.profiles.EncodedValueLookup;
@@ -53,6 +54,12 @@
      */
     DecimalEncodedValue getAverageSpeedEnc();
 
+    /**
+     * @return whether or not this encoder should apply the given turn restriction
+     * @see OSMTurnRelation
+     */
+    boolean acceptsTurnRelation(OSMTurnRelation relation);
+
     /**
      * Returns true if the feature class is supported like TurnWeighting or PriorityWeighting.
      * Use support(String) instead.
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 7252242861..71d5869b3d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
@@ -196,6 +197,11 @@ public long getTurnFlags(boolean restricted, double costs) {
         return 0;
     }
 
+    @Override
+    public boolean acceptsTurnRelation(OSMTurnRelation relation) {
+        return false;
+    }
+
     /**
      * Some ways are okay but not separate for pedestrians.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index d8f8a9463d..da691baaa4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -50,7 +50,7 @@ public MotorcycleFlagEncoder() {
     }
 
     public MotorcycleFlagEncoder(PMap properties) {
-        this((int) properties.getLong("speed_bits", 5),
+        this(properties.getInt("speed_bits", 5),
                 properties.getDouble("speed_factor", 5),
                 properties.getBool("turn_costs", false) ? 1 : 0
         );
diff --git a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
index 2e8d59375f..145388953f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/NameSimilarityEdgeFilter.java
@@ -21,33 +21,38 @@
 import com.graphhopper.debatty.java.stringsimilarity.JaroWinkler;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.*;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
- * This class defines the basis for NameSimilarity matching using an EdgeFilter.
+ * This class defines the basis for NameSimilarity matching using an EdgeFilter. It is not thread-safe.
  * The typical use-case is to match not the nearest edge in
  * {@link com.graphhopper.storage.index.LocationIndex#findClosest(double, double, EdgeFilter)}
- * but the match the edge which name is closest to the pointHint
+ * but the edge with the name that is similar to the specified pointHint and still close.
  * <p>
  * Names that are similar to each other are (n1 name1, n2 name2):
  * <ul>
  * <li>n1 == n2</li>
  * <li>n1 is significant substring of n2, e.g: n1="Main Road", n2="Main Road, New York"</li>
- * <li>n1 and n2 contain a reasonable longest common substring, e.g.: n1="Cape Point / Cape of Good Hope", n2="Cape Point Rd, Cape Peninsula, Cape Town, 8001, Afrique du Sud"</li>
+ * <li>n1 and n2 contain a reasonable longest common substring, e.g.: n1="Cape Point / Cape of Good Hope",
+ *     n2="Cape Point Rd, Cape Peninsula, Cape Town, 8001, Afrique du Sud"</li>
  * </ul>
  * <p>
- * We aim for allowing slight typos/differences of the substrings, without having too much false positives.
+ * The aim is to allow minor typos/differences of the substrings, without having too much false positives.
  *
  * @author Robin Boldt
+ * @author Peter Karich
  */
 public class NameSimilarityEdgeFilter implements EdgeFilter {
 
-
     private static final Map<String, String> DEFAULT_REWRITE_MAP = new HashMap<String, String>() {{
-        // two char words will be ignored but ignore certain longer phrases (or rename them)
+        // Words with 2 characters like "Dr" (Drive) will be ignored, so it is not required to list them here.
+        // Words with 3 and more characters should be listed here to remove or rename them.
         for (String remove : Arrays.asList(
                 "ally", "alley",
                 "arc", "arcade",
@@ -60,14 +65,20 @@
                 "ln.", "lane",
                 "pde.", "pde", "parade",
                 "pl.", "place", "plaza",
+                "rte", "route",
                 "str.", "str", "strae", "strasse", "st.", "street", "strada",
                 "sq.", "square",
                 "tr.", "track",
                 "via")) {
             put(remove, "");
         }
+        // expand instead of remove as significant part of the road name
+        put("n", "north");
+        put("s", "south");
+        put("w", "west");
+        put("e", "east");
     }};
-    private static final Pattern NON_WORD_CHAR = Pattern.compile("[^\\p{L}]+");
+    private static final Pattern WORD_CHAR = Pattern.compile("\\p{LD}+");
     private static final JaroWinkler jaroWinkler = new JaroWinkler();
     private static final double JARO_WINKLER_ACCEPT_FACTOR = .9;
     private final EdgeFilter edgeFilter;
@@ -79,7 +90,7 @@ public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint) {
     }
 
     /**
-     * @param rewriteMap maps abreviations to its longer form
+     * @param rewriteMap maps abbreviations to its longer form
      */
     public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint, Map<String, String> rewriteMap) {
         this.edgeFilter = edgeFilter;
@@ -87,32 +98,39 @@ public NameSimilarityEdgeFilter(EdgeFilter edgeFilter, String pointHint, Map<Str
         this.pointHint = prepareName(removeRelation(pointHint == null ? "" : pointHint));
     }
 
+    String getNormalizedPointHint() {
+        return pointHint;
+    }
+
     /**
      * Removes any characters in the String that we don't care about in the matching procedure
      * TODO Currently limited to certain 'western' languages
      */
     private String prepareName(String name) {
-        // \s = A whitespace character: [ \t\n\x0B\f\r]
-        String[] arr = name.split("\\s");
-        List<String> list = new ArrayList<>(arr.length);
-        for (int i = 0; i < arr.length; i++) {
-            String rewrite = NON_WORD_CHAR.matcher(toLowerCase(arr[i])).replaceAll("");
-            String tmp = rewriteMap.get(rewrite);
-            if (tmp != null)
-                rewrite = tmp;
-            // Ignore matching short frases like de, la, ...
-            if (!rewrite.isEmpty() && rewrite.length() > 2) {
-                list.add(rewrite);
+        StringBuilder sb = new StringBuilder(name.length());
+        Matcher wordCharMatcher = WORD_CHAR.matcher(name);
+        while (wordCharMatcher.find()) {
+            String normalizedToken = toLowerCase(wordCharMatcher.group());
+            String rewrite = rewriteMap.get(normalizedToken);
+            if (rewrite != null)
+                normalizedToken = rewrite;
+            if (normalizedToken.isEmpty())
+                continue;
+            // Ignore matching short phrases like de, la, ... except it is a number
+            if (normalizedToken.length() > 2) {
+                sb.append(normalizedToken);
+            } else {
+                if (Character.isDigit(normalizedToken.charAt(0)) && (normalizedToken.length() == 1 || Character.isDigit(normalizedToken.charAt(1)))) {
+                    sb.append(normalizedToken);
+                }
             }
         }
-        return listToString(list);
+        return sb.toString();
     }
 
     private String removeRelation(String edgeName) {
-        if (edgeName != null && edgeName.contains(", ")) {
-            edgeName = edgeName.substring(0, edgeName.lastIndexOf(','));
-        }
-        return edgeName;
+        int index = edgeName.lastIndexOf(", ");
+        return index >= 0 ? edgeName.substring(0, index) : edgeName;
     }
 
     @Override
@@ -132,7 +150,6 @@ public final boolean accept(EdgeIteratorState iter) {
 
         name = removeRelation(name);
         String edgeName = prepareName(name);
-
         return isJaroWinklerSimilar(pointHint, edgeName);
     }
 
@@ -142,14 +159,6 @@ private boolean isJaroWinklerSimilar(String str1, String str2) {
         return jwSimilarity > JARO_WINKLER_ACCEPT_FACTOR;
     }
 
-    private final String listToString(List<String> list) {
-        StringBuilder b = new StringBuilder();
-        for (int i = 0; i < list.size(); i++) {
-            b.append(list.get(i));
-        }
-        return b.toString();
-    }
-
     private boolean isLevenshteinSimilar(String hint, String name) {
         // too big length difference
         if (Math.min(name.length(), hint.length()) * 4 < Math.max(name.length(), hint.length()))
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java b/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java
index 370ba8e8fb..3dcb28530a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java
@@ -48,10 +48,16 @@ else if (name.equals(MaxHeight.KEY))
             return new OSMMaxHeightParser();
         else if (name.equals(MaxWidth.KEY))
             return new OSMMaxWidthParser();
+        else if (name.equals(MaxAxleLoad.KEY))
+            return new OSMMaxAxleLoadParser();
+        else if (name.equals(MaxLength.KEY))
+            return new OSMMaxLengthParser();
         else if (name.equals(Surface.KEY))
             return new OSMSurfaceParser();
         else if (name.equals(Toll.KEY))
             return new OSMTollParser();
+        else if (name.equals(TrackType.KEY))
+            return new OSMTrackTypeParser();
         throw new IllegalArgumentException("entry in encoder list not supported " + name);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParser.java
new file mode 100644
index 0000000000..0507c71871
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParser.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxAxleLoad;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMMaxAxleLoadParser implements TagParser {
+    
+    private final DecimalEncodedValue maxAxleLoadEncoder;
+    private final boolean enableLog;
+
+    public OSMMaxAxleLoadParser() {
+        this(MaxAxleLoad.create(), false);
+    }
+
+    public OSMMaxAxleLoadParser(DecimalEncodedValue maxAxleLoadEncoder, boolean enableLog) {
+        this.maxAxleLoadEncoder = maxAxleLoadEncoder;
+        this.enableLog = enableLog;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup,
+                    List<EncodedValue> registerNewEncodedValue) {
+        registerNewEncodedValue.add(maxAxleLoadEncoder);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access,
+                    long relationFlags) {
+        OSMValueExtractor.extractTons(edgeFlags, way, maxAxleLoadEncoder,
+                        Collections.singletonList("maxaxleload"), enableLog);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java
index 509d1c7021..53efaf0ad4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java
@@ -23,6 +23,7 @@
 import com.graphhopper.routing.profiles.EncodedValueLookup;
 import com.graphhopper.routing.profiles.MaxHeight;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
 import com.graphhopper.storage.IntsRef;
 
 import java.util.Arrays;
@@ -50,7 +51,7 @@ public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> re
     @Override
     public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
         List<String> heightTags = Arrays.asList("maxheight", "maxheight:physical"/*, the OSM tag "height" is not used for the height of a road, so omit it here! */);
-        OSMMaxWidthParser.extractMeter(edgeFlags, way, heightEncoder, heightTags, enableLog);
+        OSMValueExtractor.extractMeter(edgeFlags, way, heightEncoder, heightTags, enableLog);
         return edgeFlags;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxLengthParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxLengthParser.java
new file mode 100644
index 0000000000..47ee5e09a2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxLengthParser.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxLength;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMMaxLengthParser implements TagParser {
+
+    private final DecimalEncodedValue lengthEncoder;
+    private final boolean enableLog;
+
+    public OSMMaxLengthParser() {
+        this(MaxLength.create(), false);
+    }
+
+    public OSMMaxLengthParser(DecimalEncodedValue lengthEncoder, boolean enableLog) {
+        this.lengthEncoder = lengthEncoder;
+        this.enableLog = enableLog;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup,
+                    List<EncodedValue> registerNewEncodedValue) {
+        registerNewEncodedValue.add(lengthEncoder);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access,
+                    long relationFlags) {
+        OSMValueExtractor.extractMeter(edgeFlags, way, lengthEncoder,
+                        Collections.singletonList("maxlength"), enableLog);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java
index 41f2406467..bcf20522ad 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java
@@ -17,27 +17,22 @@
  */
 package com.graphhopper.routing.util.parsers;
 
+import java.util.Arrays;
+import java.util.List;
+
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.profiles.EncodedValue;
 import com.graphhopper.routing.profiles.EncodedValueLookup;
 import com.graphhopper.routing.profiles.MaxWeight;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
 import com.graphhopper.storage.IntsRef;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Arrays;
-import java.util.List;
-
-import static com.graphhopper.util.Helper.isEmpty;
-import static com.graphhopper.util.Helper.toLowerCase;
 
 public class OSMMaxWeightParser implements TagParser {
 
-    private static Logger LOG = LoggerFactory.getLogger(OSMMaxWeightParser.class);
-    private final DecimalEncodedValue weightEncoder;
-    private final boolean enableLog;
+    private DecimalEncodedValue weightEncoder;
+    private boolean enableLog;
 
     public OSMMaxWeightParser() {
         this(MaxWeight.create(), false);
@@ -57,38 +52,7 @@ public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> re
     public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
         // do not include OSM tag "height" here as it has completely different meaning (height of peak)
         List<String> weightTags = Arrays.asList("maxweight", "maxgcweight");
-        extractTons(edgeFlags, way, weightEncoder, weightTags, enableLog);
+        OSMValueExtractor.extractTons(edgeFlags, way, weightEncoder, weightTags, enableLog);
         return edgeFlags;
     }
-
-    static void extractTons(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
-        String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value))
-            return;
-        try {
-            double val = stringToTons(value);
-            if (val > valueEncoder.getMaxDecimal())
-                val = valueEncoder.getMaxDecimal();
-            valueEncoder.setDecimal(false, edgeFlags, val);
-        } catch (Exception ex) {
-            if (enableLog)
-                LOG.warn("Unable to extract tons from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
-        }
-    }
-
-    public static double stringToTons(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
-        value = value.replace("mgw", "").trim();
-        double factor = 1;
-        if (value.equals("default") || value.equals("none")) {
-            return -1;
-        } else if (value.endsWith("t")) {
-            value = value.substring(0, value.length() - 1);
-        } else if (value.endsWith("lbs")) {
-            value = value.substring(0, value.length() - 3);
-            factor = 0.00045359237;
-        }
-
-        return Double.parseDouble(value) * factor;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java
index a1da914777..28382f905a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java
@@ -17,25 +17,20 @@
  */
 package com.graphhopper.routing.util.parsers;
 
+import java.util.Arrays;
+import java.util.List;
+
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.profiles.EncodedValue;
 import com.graphhopper.routing.profiles.EncodedValueLookup;
 import com.graphhopper.routing.profiles.MaxWidth;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
 import com.graphhopper.storage.IntsRef;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Arrays;
-import java.util.List;
-
-import static com.graphhopper.util.Helper.isEmpty;
-import static com.graphhopper.util.Helper.toLowerCase;
 
 public class OSMMaxWidthParser implements TagParser {
 
-    private static Logger LOG = LoggerFactory.getLogger(OSMMaxWidthParser.class);
     private final DecimalEncodedValue widthEncoder;
     private final boolean enableLog;
 
@@ -56,63 +51,7 @@ public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> re
     @Override
     public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
         List<String> widthTags = Arrays.asList("maxwidth", "maxwidth:physical", "width");
-        extractMeter(edgeFlags, way, widthEncoder, widthTags, enableLog);
+        OSMValueExtractor.extractMeter(edgeFlags, way, widthEncoder, widthTags, enableLog);
         return edgeFlags;
     }
-
-    static void extractMeter(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
-        String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value))
-            return;
-        try {
-            double val = stringToMeter(value);
-            if (val > valueEncoder.getMaxDecimal())
-                val = valueEncoder.getMaxDecimal();
-            valueEncoder.setDecimal(false, edgeFlags, val);
-        } catch (Exception ex) {
-            if (enableLog)
-                LOG.warn("Unable to extract meter from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
-        }
-    }
-
-    public static double stringToMeter(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
-        double factor = 1;
-        double offset = 0;
-        value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
-        if (value.startsWith("~") || value.contains("approx")) {
-            value = value.replaceAll("(\\~|approx)", "").trim();
-            factor = 0.8;
-        }
-
-        if (value.equals("default") || value.equals("none") || value.equals("unsigned"))
-            return -1;
-
-        if (value.endsWith("in")) {
-            int startIndex = value.indexOf("ft");
-            String inchValue;
-            if (startIndex < 0) {
-                startIndex = 0;
-            } else {
-                startIndex += 2;
-            }
-
-            inchValue = value.substring(startIndex, value.length() - 2);
-            value = value.substring(0, startIndex);
-            offset = Double.parseDouble(inchValue) * 0.0254;
-        }
-
-        if (value.endsWith("ft")) {
-            value = value.substring(0, value.length() - 2);
-            factor *= 0.3048;
-        } else if (value.endsWith("m")) {
-            value = value.substring(0, value.length() - 1);
-        }
-
-        if (value.isEmpty()) {
-            return offset;
-        } else {
-            return Double.parseDouble(value) * factor + offset;
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java
index ad3167bb27..cf221007cd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java
@@ -46,6 +46,10 @@ public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingMan
             tollEnc.setEnum(false, edgeFlags, Toll.ALL);
         else if (readerWay.hasTag("toll:hgv", "yes"))
             tollEnc.setEnum(false, edgeFlags, Toll.HGV);
+        else if (readerWay.hasTag("toll:N2", "yes"))
+            tollEnc.setEnum(false, edgeFlags, Toll.HGV);
+        else if (readerWay.hasTag("toll:N3", "yes"))
+            tollEnc.setEnum(false, edgeFlags, Toll.HGV);
         return edgeFlags;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParser.java
new file mode 100644
index 0000000000..733d212f5d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParser.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import static com.graphhopper.routing.profiles.TrackType.OTHER;
+
+import java.util.List;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.TrackType;
+import com.graphhopper.routing.util.EncodingManager.Access;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMTrackTypeParser implements TagParser {
+
+    private final EnumEncodedValue<TrackType> trackTypeEnc;
+
+    public OSMTrackTypeParser() {
+        this.trackTypeEnc = new EnumEncodedValue<>(TrackType.KEY, TrackType.class);
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> link) {
+        link.add(trackTypeEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, Access access,
+                    long relationFlags) {
+        if (!access.isWay())
+            return edgeFlags;
+
+        String trackTypeTag = readerWay.getTag("tracktype");
+        if (trackTypeTag == null)
+            return edgeFlags;
+        TrackType trackType = TrackType.find(trackTypeTag);
+        if (trackType != OTHER)
+            trackTypeEnc.setEnum(false, edgeFlags, trackType);
+        return edgeFlags;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java b/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java
new file mode 100644
index 0000000000..ee0174c1d7
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/helpers/OSMValueExtractor.java
@@ -0,0 +1,109 @@
+package com.graphhopper.routing.util.parsers.helpers;
+
+import static com.graphhopper.util.Helper.isEmpty;
+import static com.graphhopper.util.Helper.toLowerCase;
+
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMValueExtractor {
+    
+    private static final Logger LOG = LoggerFactory.getLogger(OSMValueExtractor.class);
+
+    private OSMValueExtractor() {
+        // utility class
+    }
+
+    public static void extractTons(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
+        String value = way.getFirstPriorityTag(keys);
+        if (isEmpty(value))
+            return;
+        try {
+            double val = stringToTons(value);
+            if (val > valueEncoder.getMaxDecimal())
+                val = valueEncoder.getMaxDecimal();
+            valueEncoder.setDecimal(false, edgeFlags, val);
+        } catch (Exception ex) {
+            if (enableLog)
+                LOG.warn("Unable to extract tons from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
+        }
+    }
+
+    public static double stringToTons(String value) {
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
+        value = value.replace("mgw", "").trim();
+        double factor = 1;
+        if (value.equals("default") || value.equals("none")) {
+            return -1;
+        } else if (value.endsWith("t")) {
+            value = value.substring(0, value.length() - 1);
+        } else if (value.endsWith("lbs")) {
+            value = value.substring(0, value.length() - 3);
+            factor = 0.00045359237;
+        }
+    
+        return Double.parseDouble(value) * factor;
+    }
+
+    public static void extractMeter(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
+        String value = way.getFirstPriorityTag(keys);
+        if (isEmpty(value))
+            return;
+        try {
+            double val = stringToMeter(value);
+            if (val > valueEncoder.getMaxDecimal())
+                val = valueEncoder.getMaxDecimal();
+            valueEncoder.setDecimal(false, edgeFlags, val);
+        } catch (Exception ex) {
+            if (enableLog)
+                LOG.warn("Unable to extract meter from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
+        }
+    }
+
+    public static double stringToMeter(String value) {
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
+        double factor = 1;
+        double offset = 0;
+        value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
+        if (value.startsWith("~") || value.contains("approx")) {
+            value = value.replaceAll("(\\~|approx)", "").trim();
+            factor = 0.8;
+        }
+    
+        if (value.equals("default") || value.equals("none") || value.equals("unsigned"))
+            return -1;
+    
+        if (value.endsWith("in")) {
+            int startIndex = value.indexOf("ft");
+            String inchValue;
+            if (startIndex < 0) {
+                startIndex = 0;
+            } else {
+                startIndex += 2;
+            }
+    
+            inchValue = value.substring(startIndex, value.length() - 2);
+            value = value.substring(0, startIndex);
+            offset = Double.parseDouble(inchValue) * 0.0254;
+        }
+    
+        if (value.endsWith("ft")) {
+            value = value.substring(0, value.length() - 2);
+            factor *= 0.3048;
+        } else if (value.endsWith("m")) {
+            value = value.substring(0, value.length() - 1);
+        }
+    
+        if (value.isEmpty()) {
+            return offset;
+        } else {
+            return Double.parseDouble(value) * factor + offset;
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index 160921d85a..087fac389c 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -104,8 +104,8 @@ static final boolean isValidName(String name) {
     /**
      * Replaces all characters which are not numbers, characters or underscores with underscores
      */
-    public static String weightingToFileName(Weighting w, boolean edgeBased) {
-        return toLowerCase(w.toString()).replaceAll("\\|", "_") + (edgeBased ? "_edge" : "_node");
+    public static String weightingToFileName(Weighting w) {
+        return toLowerCase(w.toString()).replaceAll("\\|", "_");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
index a46c3f08be..d06e9a157a 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
@@ -32,40 +32,38 @@
  * @author Peter Karich
  */
 public class TurnWeighting implements Weighting {
+    public static final int INFINITE_U_TURN_COSTS = -1;
     /**
      * Encoder, which decodes the turn flags
      */
     private final TurnCostEncoder turnCostEncoder;
     private final TurnCostExtension turnCostExt;
     private final Weighting superWeighting;
-    private final double uTurnCost;
+    private final double uTurnCosts;
 
     public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
-        this(superWeighting, turnCostExt, Double.POSITIVE_INFINITY);
+        this(superWeighting, turnCostExt, INFINITE_U_TURN_COSTS);
     }
 
     /**
      * @param superWeighting the weighting that is wrapped by this {@link TurnWeighting} and used to calculate the
      *                       edge weights for example
      * @param turnCostExt    the turn cost storage to be used
-     * @param uTurnCost      the cost of a u-turn in seconds, this value will be applied to all u-turn costs no matter
+     * @param uTurnCosts     the cost of a u-turn in seconds, this value will be applied to all u-turn costs no matter
      *                       whether or not turnCostExt contains explicit values for these turns.
      */
-    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt, double uTurnCost) {
+    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt, double uTurnCosts) {
+        if (turnCostExt == null) {
+            throw new RuntimeException("No storage set to calculate turn weight");
+        }
         this.turnCostEncoder = superWeighting.getFlagEncoder();
         this.superWeighting = superWeighting;
         this.turnCostExt = turnCostExt;
-        this.uTurnCost = uTurnCost;
-
-        if (turnCostExt == null)
-            throw new RuntimeException("No storage set to calculate turn weight");
+        this.uTurnCosts = uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;
     }
 
-    /**
-     * @return the default u-turn cost in seconds
-     */
-    public double getUTurnCost() {
-        return uTurnCost;
+    public double getUTurnCosts() {
+        return uTurnCosts;
     }
 
     @Override
@@ -76,7 +74,7 @@ public double getMinWeight(double distance) {
     @Override
     public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
-        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(prevOrNextEdgeId))
             return weight;
 
         final int origEdgeId = reverse ? edgeState.getOrigEdgeLast() : edgeState.getOrigEdgeFirst();
@@ -111,7 +109,15 @@ public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
             return 0;
         }
         if (turnCostExt.isUTurn(edgeFrom, edgeTo)) {
-            return uTurnCost;
+            // note that the u-turn costs overwrite any turn costs set in TurnCostExtension
+            // todo:
+            // also this does not allow TurnCostEncoder to set the u-turn costs to zero explicitly, like FootFlagEncoder!
+            // this problem is a bit hidden, because if you do not apply any turn restrictions (like FootFlagEncoder)
+            // you never do a u-turn anyway.
+            if (!turnCostExt.isUTurnAllowed(nodeVia)) {
+                return Double.POSITIVE_INFINITY;
+            }
+            return uTurnCosts;
         }
         long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
         if (turnCostEncoder.isTurnRestricted(turnFlags))
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 7afcea9a1d..7de9936ba2 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -46,6 +46,11 @@
  * loadExisting, (4) usage, (5) flush, (6) close
  */
 class BaseGraph implements Graph {
+    // currently distances are stored as 4 byte integers. using a conversion factor of 1000 the minimum distance
+    // that is not considered zero is 0.0005m (=0.5mm) and the maximum distance per edge is about 2.147.483m=2147km
+    private static final double INT_DIST_FACTOR = 1000d;
+    static double MAX_DIST = Integer.MAX_VALUE / INT_DIST_FACTOR;
+
     final DataAccess edges;
     final DataAccess nodes;
     final BBox bounds;
@@ -68,7 +73,7 @@
     // node memory layout:
     protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
     // edge memory layout not found in EdgeAccess:
-    int E_GEO, E_NAME, E_ADDITIONAL;
+    int E_DIST, E_GEO, E_NAME, E_ADDITIONAL;
     /**
      * Specifies how many entries (integers) are used per edge.
      */
@@ -224,9 +229,9 @@ void initStorage() {
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
-                nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(encodingManager.getBytesForFlags()));
 
+        E_DIST = nextEdgeEntryIndex(4);
         E_GEO = nextEdgeEntryIndex(4);
         E_NAME = nextEdgeEntryIndex(4);
         if (extStorage.isRequireEdgeField())
@@ -391,7 +396,7 @@ public void debugPrint() {
         }
         System.out.println("edges:");
         String formatEdges = "%12s | %12s | %12s | %12s | %12s | %12s | %12s \n";
-        System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS");
+        System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_FLAGS", "E_DIST");
         IntsRef intsRef = new IntsRef(bytesForFlags / 4);
         for (int i = 0; i < Math.min(edgeCount, printMax); ++i) {
             long edgePointer = edgeAccess.toPointer(i);
@@ -401,8 +406,8 @@ public void debugPrint() {
                     edgeAccess.getNodeB(edgePointer),
                     edgeAccess.getLinkA(edgePointer),
                     edgeAccess.getLinkB(edgePointer),
-                    edgeAccess.getDist(edgePointer),
-                    intsRef);
+                    intsRef,
+                    getDist(edgePointer));
         }
         if (edgeCount > printMax) {
             System.out.printf(Locale.ROOT, " ... %d more edges", edgeCount - printMax);
@@ -806,6 +811,34 @@ public boolean isAdjacentToNode(int edge, int node) {
         return edgeAccess.isAdjacentToNode(node, edgePointer);
     }
 
+
+    private void setDist(long edgePointer, double distance) {
+        edges.setInt(edgePointer + E_DIST, distToInt(distance));
+    }
+
+    /**
+     * Translates double distance to integer in order to save it in a DataAccess object
+     */
+    private int distToInt(double distance) {
+        if (distance < 0)
+            throw new IllegalArgumentException("Distance cannot be negative: " + distance);
+        if (distance > MAX_DIST) {
+            distance = MAX_DIST;
+        }
+        int integ = (int) Math.round(distance * INT_DIST_FACTOR);
+        assert integ >= 0 : "distance out of range";
+        return integ;
+    }
+
+    /**
+     * returns distance (already translated from integer to double)
+     */
+    private double getDist(long pointer) {
+        int val = edges.getInt(pointer + E_DIST);
+        // do never return infinity even if INT MAX, see #435
+        return val / INT_DIST_FACTOR;
+    }
+
     public void setAdditionalEdgeField(long edgePointer, int value) {
         if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
             edges.setInt(edgePointer + E_ADDITIONAL, value);
@@ -841,7 +874,7 @@ private void setWayGeometry_(PointList pillarNodes, long edgePointer, boolean re
     private void setWayGeometryAtGeoRef(PointList pillarNodes, long edgePointer, boolean reverse, long geoRef) {
         int len = pillarNodes.getSize();
         int dim = nodeAccess.getDimension();
-        long geoRefPosition = (long) geoRef * 4;
+        long geoRefPosition = geoRef * 4;
         int totalLen = len * dim * 4 + 4;
         ensureGeometry(geoRefPosition, totalLen);
         byte[] wayGeometryBytes = createWayGeometryBytes(pillarNodes, reverse);
@@ -1012,7 +1045,7 @@ protected void selectEdgeAccess() {
         @Override
         public final boolean next() {
             while (true) {
-                if (nextEdgeId == EdgeIterator.NO_EDGE)
+                if (!EdgeIterator.Edge.isValid(nextEdgeId))
                     return false;
 
                 selectEdgeAccess();
@@ -1036,7 +1069,7 @@ public final boolean next() {
 
         @Override
         public EdgeIteratorState detach(boolean reverseArg) {
-            if (edgeId == nextEdgeId || edgeId == EdgeIterator.NO_EDGE)
+            if (edgeId == nextEdgeId || !EdgeIterator.Edge.isValid(edgeId))
                 throw new IllegalStateException("call next before detaching or setEdgeId (edgeId:" + edgeId + " vs. next " + nextEdgeId + ")");
 
             EdgeIterable iter = edgeAccess.createSingleEdge(filter);
@@ -1148,13 +1181,13 @@ public final int getAdjNode() {
         }
 
         @Override
-        public final double getDistance() {
-            return edgeAccess.getDist(edgePointer);
+        public double getDistance() {
+            return baseGraph.getDist(edgePointer);
         }
 
         @Override
-        public final EdgeIteratorState setDistance(double dist) {
-            edgeAccess.setDist(edgePointer, dist);
+        public EdgeIteratorState setDistance(double dist) {
+            baseGraph.setDist(edgePointer, dist);
             return this;
         }
 
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
index 6ef50906ce..832f01761d 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -45,17 +45,23 @@
      */
     int getLevel(int nodeId);
 
+    /**
+     * Returns the profile of this CH graph. This is used to identify the CH graph.
+     */
+    CHProfile getCHProfile();
+
     boolean isShortcut(int edgeId);
 
     /**
      * This method creates a shortcut between a to b which is nearly identical to creating an edge
      * except that it can be excluded or included for certain traversals or algorithms.
      */
-    CHEdgeIteratorState shortcut(int a, int b);
+    int shortcut(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2);
 
-    int shortcut(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2);
-
-    int shortcutEdgeBased(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2, int origFirst, int origLast);
+    /**
+     * like shortcut(), but for edge-based CH
+     */
+    int shortcutEdgeBased(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2, int origFirst, int origLast);
 
     @Override
     CHEdgeIteratorState getEdgeIteratorState(int edgeId, int endNode);
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index 78f7cd444c..0dbdc5714c 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -52,10 +52,9 @@
     final DataAccess shortcuts;
     final DataAccess nodesCH;
     final int scDirMask = PrepareEncoder.getScDirMask();
-    private final boolean edgeBased;
+    private final CHProfile chProfile;
     private final BaseGraph baseGraph;
     private final CHEdgeAccess chEdgeAccess;
-    private final Weighting weighting;
     int N_CH_REF;
     int shortcutEntryBytes;
     // the nodesCH storage is limited via baseGraph.nodeCount too
@@ -66,21 +65,20 @@
     private int shortcutCount = 0;
     private boolean isReadyForContraction;
 
-    CHGraphImpl(Weighting w, Directory dir, final BaseGraph baseGraph, boolean edgeBased) {
-        if (w == null)
+    CHGraphImpl(CHProfile chProfile, Directory dir, final BaseGraph baseGraph) {
+        if (chProfile.getWeighting() == null)
             throw new IllegalStateException("Weighting for CHGraph cannot be null");
-
-        this.weighting = w;
+        this.chProfile = chProfile;
         this.baseGraph = baseGraph;
-        final String name = AbstractWeighting.weightingToFileName(w, edgeBased);
-        this.edgeBased = edgeBased;
+        final String name = chProfile.toFileName();
         this.nodesCH = dir.find("nodes_ch_" + name, DAType.getPreferredInt(dir.getDefaultType()));
         this.shortcuts = dir.find("shortcuts_" + name, DAType.getPreferredInt(dir.getDefaultType()));
         this.chEdgeAccess = new CHEdgeAccess(name);
     }
 
-    public final Weighting getWeighting() {
-        return weighting;
+    @Override
+    public CHProfile getCHProfile() {
+        return chProfile;
     }
 
     @Override
@@ -106,23 +104,7 @@ final void checkNodeId(int nodeId) {
     }
 
     @Override
-    public CHEdgeIteratorState shortcut(int a, int b) {
-        if (!baseGraph.isFrozen())
-            throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
-
-        checkNodeId(a);
-        checkNodeId(b);
-
-        int scId = chEdgeAccess.internalEdgeAdd(nextShortcutId(), a, b);
-        CHEdgeIteratorImpl iter = new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, EdgeFilter.ALL_EDGES);
-        boolean ret = iter.init(scId, b);
-        assert ret;
-        iter.setSkippedEdges(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        return iter;
-    }
-
-    @Override
-    public int shortcut(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2) {
+    public int shortcut(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2) {
         if (!baseGraph.isFrozen())
             throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
 
@@ -133,15 +115,16 @@ public int shortcut(int a, int b, int accessFlags, double weight, double distanc
         // do not create CHEdgeIteratorImpl object
         long edgePointer = chEdgeAccess.toPointer(scId);
         chEdgeAccess.setAccessAndWeight(edgePointer, accessFlags & scDirMask, weight);
-        chEdgeAccess.setDist(edgePointer, distance);
         chEdgeAccess.setSkippedEdges(edgePointer, skippedEdge1, skippedEdge2);
         return scId;
     }
 
     @Override
-    public int shortcutEdgeBased(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2, int origFirst, int origLast) {
-        assert edgeBased : "Edge-based shortcuts should only be added when CHGraph is edge-based";
-        int scId = shortcut(a, b, accessFlags, weight, distance, skippedEdge1, skippedEdge2);
+    public int shortcutEdgeBased(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2, int origFirst, int origLast) {
+        if (!chProfile.isEdgeBased()) {
+            throw new IllegalStateException("Edge-based shortcuts should only be added when CHGraph is edge-based");
+        }
+        int scId = shortcut(a, b, accessFlags, weight, skippedEdge1, skippedEdge2);
         chEdgeAccess.setFirstAndLastOrigEdges(chEdgeAccess.toPointer(scId), origFirst, origLast);
         return scId;
     }
@@ -283,7 +266,7 @@ public void disconnect(CHEdgeExplorer explorer, EdgeIteratorState edgeState) {
             // even though this is not optimal from a speed performance point of view.
             if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge()) {
                 // TODO this is ugly, move this somehow into the underlying iteration logic
-                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
+                long edgePointer = !EdgeIterator.Edge.isValid(tmpPrevEdge) ? -1
                         : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
                 chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer, edgeState.getAdjNode());
                 break;
@@ -343,11 +326,11 @@ public Graph copyTo(Graph g) {
 
     void initStorage() {
         EdgeAccess ea = baseGraph.edgeAccess;
-        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS);
+        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_FLAGS);
         // shortcuts
         S_SKIP_EDGE1 = ea.E_FLAGS + 4;
         S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
-        if (edgeBased) {
+        if (chProfile.isEdgeBased()) {
             S_ORIG_FIRST = S_SKIP_EDGE2 + 4;
             S_ORIG_LAST = S_ORIG_FIRST + 4;
             shortcutEntryBytes = S_ORIG_LAST + 4;
@@ -407,7 +390,7 @@ public long getCapacity() {
 
     @Override
     public String toString() {
-        return "CHGraph|" + getWeighting().toString();
+        return "CHGraph|" + chProfile.toString();
     }
 
     public void debugPrint() {
@@ -425,7 +408,7 @@ public void debugPrint() {
         String formatShortcutsBase = "%12s | %12s | %12s | %12s | %12s | %12s | %12s | %12s | %12s";
         String formatShortcutExt = " | %12s | %12s";
         String header = String.format(Locale.ROOT, formatShortcutsBase, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS", "S_SKIP_EDGE1", "S_SKIP_EDGE2");
-        if (edgeBased) {
+        if (chProfile.isEdgeBased()) {
             header += String.format(Locale.ROOT, formatShortcutExt, "S_ORIG_FIRST", "S_ORIG_LAST");
         }
         System.out.println(header);
@@ -437,11 +420,10 @@ public void debugPrint() {
                     chEdgeAccess.getNodeB(edgePointer),
                     chEdgeAccess.getLinkA(edgePointer),
                     chEdgeAccess.getLinkB(edgePointer),
-                    chEdgeAccess.getDist(edgePointer),
                     chEdgeAccess.getShortcutFlags(edgePointer),
                     shortcuts.getInt(edgePointer + S_SKIP_EDGE1),
                     shortcuts.getInt(edgePointer + S_SKIP_EDGE2));
-            if (edgeBased) {
+            if (chProfile.isEdgeBased()) {
                 edgeString += String.format(Locale.ROOT, formatShortcutExt,
                         shortcuts.getInt(edgePointer + S_ORIG_FIRST),
                         shortcuts.getInt(edgePointer + S_ORIG_LAST));
@@ -481,6 +463,18 @@ public CHEdgeIteratorImpl(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter
             super(baseGraph, edgeAccess, filter);
         }
 
+        @Override
+        public double getDistance() {
+            checkShortcut(false, "getDistance");
+            return super.getDistance();
+        }
+
+        @Override
+        public EdgeIteratorState setDistance(double dist) {
+            checkShortcut(false, "setDistance");
+            return super.setDistance(dist);
+        }
+
         @Override
         public final IntsRef getFlags() {
             checkShortcut(false, "getFlags");
@@ -533,7 +527,7 @@ public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastO
 
         @Override
         public int getOrigEdgeFirst() {
-            if (!isShortcut() || !edgeBased) {
+            if (!isShortcut() || !chProfile.isEdgeBased()) {
                 return getEdge();
             }
             return shortcuts.getInt(edgePointer + S_ORIG_FIRST);
@@ -541,7 +535,7 @@ public int getOrigEdgeFirst() {
 
         @Override
         public int getOrigEdgeLast() {
-            if (!isShortcut() || !edgeBased) {
+            if (!isShortcut() || !chProfile.isEdgeBased()) {
                 return getEdge();
             }
             return shortcuts.getInt(edgePointer + S_ORIG_LAST);
@@ -607,7 +601,7 @@ public void checkShortcut(boolean shouldBeShortcut, String methodName) {
 
         private void checkShortcutAndEdgeBased(String method) {
             checkShortcut(true, method);
-            if (!edgeBased) {
+            if (!chProfile.isEdgeBased()) {
                 throw new IllegalStateException("Method " + method + " only allowed when CH graph is configured for edge based traversal");
             }
         }
@@ -787,7 +781,7 @@ void checkShortcut(boolean shouldBeShortcut, String methodName) {
 
         private void checkShortcutAndEdgeBased(String method) {
             checkShortcut(true, method);
-            if (!edgeBased) {
+            if (!chProfile.isEdgeBased()) {
                 throw new IllegalStateException("Method " + method + " not supported when turn costs are disabled");
             }
         }
@@ -882,6 +876,9 @@ void setSkippedEdges(long edgePointer, int edge1, int edge2) {
         }
 
         public void setFirstAndLastOrigEdges(long edgePointer, int origFirst, int origLast) {
+            if (!chProfile.isEdgeBased()) {
+                throw new IllegalStateException("Edge-based shortcuts should only be added when CHGraph is edge-based");
+            }
             shortcuts.setInt(edgePointer + S_ORIG_FIRST, origFirst);
             shortcuts.setInt(edgePointer + S_ORIG_LAST, origLast);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/CHProfile.java b/core/src/main/java/com/graphhopper/storage/CHProfile.java
new file mode 100644
index 0000000000..c17020b8cf
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/CHProfile.java
@@ -0,0 +1,96 @@
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+
+import java.util.Objects;
+
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+
+/**
+ * Specifies all properties of a CH routing profile. Generally these properties cannot be changed after the CH
+ * pre-processing is finished and are stored on disk along with the prepared graph data.
+ *
+ * @author easbar
+ */
+public class CHProfile {
+    private final Weighting weighting;
+    private final boolean edgeBased;
+    private final int uTurnCosts;
+
+    public static CHProfile nodeBased(Weighting weighting) {
+        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);
+    }
+
+    public static CHProfile edgeBased(Weighting weighting, int uTurnCosts) {
+        return new CHProfile(weighting, TraversalMode.EDGE_BASED, uTurnCosts);
+    }
+
+    public CHProfile(Weighting weighting, TraversalMode traversalMode, int uTurnCosts) {
+        this(weighting, traversalMode.isEdgeBased(), uTurnCosts);
+    }
+
+    /**
+     * @param uTurnCosts the costs of a u-turn in seconds, for {@link TurnWeighting#INFINITE_U_TURN_COSTS} the u-turn costs
+     *                   will be infinite
+     */
+    public CHProfile(Weighting weighting, boolean edgeBased, int uTurnCosts) {
+        if (!edgeBased && uTurnCosts != INFINITE_U_TURN_COSTS) {
+            throw new IllegalArgumentException("Finite u-turn costs are only allowed for edge-based CH");
+        }
+        this.weighting = weighting;
+        this.edgeBased = edgeBased;
+        if (uTurnCosts < 0 && uTurnCosts != INFINITE_U_TURN_COSTS) {
+            throw new IllegalArgumentException("u-turn costs must be positive, or equal to " + INFINITE_U_TURN_COSTS + " (=infinite costs)");
+        }
+        this.uTurnCosts = uTurnCosts < 0 ? INFINITE_U_TURN_COSTS : uTurnCosts;
+    }
+
+    public Weighting getWeighting() {
+        return weighting;
+    }
+
+    public boolean isEdgeBased() {
+        return edgeBased;
+    }
+
+    public double getUTurnCosts() {
+        return uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;
+    }
+
+    /**
+     * Use this method when u-turn costs are used to check CHProfile equality
+     */
+    public int getUTurnCostsInt() {
+        return uTurnCosts;
+    }
+
+    public TraversalMode getTraversalMode() {
+        return edgeBased ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
+    }
+
+    public String toFileName() {
+        return AbstractWeighting.weightingToFileName(weighting) + "_" + (edgeBased ? ("edge_utc" + uTurnCosts) : "node");
+    }
+
+    public String toString() {
+        return weighting + "|edge_based=" + edgeBased + "|u_turn_costs=" + uTurnCosts;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        CHProfile chProfile = (CHProfile) o;
+        return edgeBased == chProfile.edgeBased &&
+                uTurnCosts == chProfile.uTurnCosts &&
+                Objects.equals(weighting, chProfile.weighting);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(weighting, edgeBased, uTurnCosts);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 2231f73c41..fae79ca649 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -26,22 +26,18 @@
  */
 abstract class EdgeAccess {
     private static final int NO_NODE = -1;
-    // distance of around +-1000 000 meter are ok
-    private static final double INT_DIST_FACTOR = 1000d;
-    static double MAX_DIST = Integer.MAX_VALUE / INT_DIST_FACTOR;
     final DataAccess edges;
-    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
+    int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_FLAGS;
 
     EdgeAccess(DataAccess edges) {
         this.edges = edges;
     }
 
-    final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS) {
+    final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_FLAGS) {
         this.E_NODEA = E_NODEA;
         this.E_NODEB = E_NODEB;
         this.E_LINKA = E_LINKA;
         this.E_LINKB = E_LINKB;
-        this.E_DIST = E_DIST;
         this.E_FLAGS = E_FLAGS;
     }
 
@@ -61,37 +57,10 @@ final void invalidateEdge(long edgePointer) {
         edges.setInt(edgePointer + E_NODEB, NO_NODE);
     }
 
-    static final boolean isInvalidNodeB(int node) {
+    static boolean isInvalidNodeB(int node) {
         return node == EdgeAccess.NO_NODE;
     }
 
-    final void setDist(long edgePointer, double distance) {
-        edges.setInt(edgePointer + E_DIST, distToInt(distance));
-    }
-
-    /**
-     * Translates double distance to integer in order to save it in a DataAccess object
-     */
-    private int distToInt(double distance) {
-        if (distance < 0)
-            throw new IllegalArgumentException("Distance cannot be negative: " + distance);
-        if (distance > MAX_DIST) {
-            distance = MAX_DIST;
-        }
-        int integ = (int) Math.round(distance * INT_DIST_FACTOR);
-        assert integ >= 0 : "distance out of range";
-        return integ;
-    }
-
-    /**
-     * returns distance (already translated from integer to double)
-     */
-    final double getDist(long pointer) {
-        int val = edges.getInt(pointer + E_DIST);
-        // do never return infinity even if INT MAX, see #435
-        return val / INT_DIST_FACTOR;
-    }
-
     final void readFlags(long edgePointer, IntsRef edgeFlags) {
         int size = edgeFlags.ints.length;
         for (int i = 0; i < size; i++) {
@@ -156,7 +125,7 @@ final boolean isAdjacentToNode(int node, long edgePointer) {
      * Writes plain edge information to the edges index
      */
     final long writeEdge(int edgeId, int nodeA, int nodeB, int nextEdgeA, int nextEdgeB) {
-        if (edgeId < 0 || edgeId == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(edgeId))
             throw new IllegalStateException("Cannot write edge with illegal ID:" + edgeId + "; nodeA:" + nodeA + ", nodeB:" + nodeB);
 
         long edgePointer = toPointer(edgeId);
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 4aeb1879fe..76f9dd6a02 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -27,7 +27,6 @@
 
 /**
  * Implements some common methods for the subclasses.
- * <p>
  *
  * @author Peter Karich
  */
@@ -109,34 +108,20 @@ public DataAccess find(String name, DAType type) {
 
     @Override
     public void clear() {
-        // If there is at least one MMap DA then do not apply the cleanHack 
-        // for every single mmap DA as this is very slow if lots of DataAccess objects were collected 
-        // => forceClean == false
-
-        MMapDataAccess mmapDA = null;
         for (DataAccess da : map.values()) {
-            if (da instanceof MMapDataAccess)
-                mmapDA = (MMapDataAccess) da;
-
-            removeDA(da, da.getName(), false);
+            removeDA(da, da.getName());
         }
-        if (mmapDA != null)
-            cleanHack();
         map.clear();
     }
 
     @Override
     public void remove(DataAccess da) {
         removeFromMap(da.getName());
-        removeDA(da, da.getName(), true);
+        removeDA(da, da.getName());
     }
 
-    void removeDA(DataAccess da, String name, boolean forceClean) {
-        if (da instanceof MMapDataAccess)
-            ((MMapDataAccess) da).close(forceClean);
-        else
-            da.close();
-
+    void removeDA(DataAccess da, String name) {
+        da.close();
         if (da.getType().isStoring())
             removeDir(new File(location + name));
     }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index 7f03bd5d87..245baec86a 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -18,10 +18,11 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.weighting.Weighting;
 
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
 
 /**
  * For now this is just a helper class to quickly create a {@link GraphHopperStorage}
@@ -36,22 +37,28 @@
     private boolean store;
     private boolean elevation;
     private boolean turnCosts;
-    private boolean edgeBasedCH;
     private long byteCapacity = 100;
-    private Weighting singleCHWeighting;
+    private List<CHProfile> chProfiles = Collections.emptyList();
 
     public GraphBuilder(EncodingManager encodingManager) {
         this.encodingManager = encodingManager;
     }
 
     /**
-     * This method enables creating a CHGraph with the specified weighting.
+     * This method enables creating CHGraphs with the specified CHProfiles
      */
-    public GraphBuilder setCHGraph(Weighting singleCHWeighting) {
-        this.singleCHWeighting = singleCHWeighting;
+    public GraphBuilder setCHProfiles(List<CHProfile> chProfiles) {
+        if (chProfiles.size() != new HashSet<>(chProfiles).size()) {
+            throw new IllegalArgumentException("Given CH profiles contain duplicates, given: " + chProfiles);
+        }
+        this.chProfiles = chProfiles;
         return this;
     }
 
+    public GraphBuilder setCHProfiles(CHProfile... chProfiles) {
+        return setCHProfiles(Arrays.asList(chProfiles));
+    }
+
     public GraphBuilder setLocation(String location) {
         this.location = location;
         return this;
@@ -82,11 +89,6 @@ public GraphBuilder withTurnCosts(boolean turnCosts) {
         return this;
     }
 
-    public GraphBuilder setEdgeBasedCH(boolean edgeBasedCH) {
-        this.edgeBasedCH = edgeBasedCH;
-        return this;
-    }
-
     public boolean hasElevation() {
         return elevation;
     }
@@ -94,8 +96,8 @@ public boolean hasElevation() {
     /**
      * Creates a CHGraph
      */
-    public CHGraph chGraphCreate(Weighting singleCHWeighting) {
-        return setCHGraph(singleCHWeighting).create().getGraph(CHGraph.class, singleCHWeighting);
+    public CHGraph chGraphCreate(CHProfile chProfile) {
+        return setCHProfiles(chProfile).create().getCHGraph();
     }
 
     /**
@@ -112,11 +114,9 @@ public GraphHopperStorage build() {
                 new TurnCostExtension() :
                 new TurnCostExtension.NoOpExtension();
 
-        return singleCHWeighting == null ?
+        return chProfiles.isEmpty() ?
                 new GraphHopperStorage(dir, encodingManager, elevation, graphExtension) :
-                edgeBasedCH ?
-                        new GraphHopperStorage(Collections.<Weighting>emptyList(), Arrays.asList(singleCHWeighting), dir, encodingManager, elevation, graphExtension) :
-                        new GraphHopperStorage(Arrays.asList(singleCHWeighting), Collections.<Weighting>emptyList(), dir, encodingManager, elevation, graphExtension);
+                new GraphHopperStorage(chProfiles, dir, encodingManager, elevation, graphExtension);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index dcb453ecbd..4dc0f14bad 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -34,12 +34,11 @@
  * This class manages all storage related methods and delegates the calls to the associated graphs.
  * The associated graphs manage their own necessary data structures and are used to provide e.g.
  * different traversal methods. By default this class implements the graph interface and results in
- * identical behavior as the Graph instance from getGraph(Graph.class)
+ * identical behavior as the Graph instance from getBaseGraph()
  * <p>
  *
  * @author Peter Karich
  * @see GraphBuilder to create a (CH)Graph easier
- * @see #getGraph(java.lang.Class)
  */
 public final class GraphHopperStorage implements GraphStorage, Graph {
     private final Directory dir;
@@ -47,20 +46,17 @@
     private final StorableProperties properties;
     private final BaseGraph baseGraph;
     // same flush order etc
-    private final Collection<CHGraphImpl> nodeBasedCHGraphs = new ArrayList<>(5);
-    private final Collection<CHGraphImpl> edgeBasedCHGraphs = new ArrayList<>(5);
+    private final Collection<CHGraphImpl> chGraphs;
 
     public GraphHopperStorage(Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
-        this(Collections.<Weighting>emptyList(), Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
+        this(Collections.<CHProfile>emptyList(), dir, encodingManager, withElevation, extendedStorage);
     }
 
-    public GraphHopperStorage(List<? extends Weighting> nodeBasedCHWeightings, Directory dir, EncodingManager encodingManager,
-                              boolean withElevation, GraphExtension extendedStorage) {
-        this(nodeBasedCHWeightings, Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
+    public GraphHopperStorage(Collection<? extends Weighting> nodeBasedCHWeightings, Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
+        this(createProfilesForWeightings(nodeBasedCHWeightings), dir, encodingManager, withElevation, extendedStorage);
     }
 
-    public GraphHopperStorage(List<? extends Weighting> nodeBasedCHWeightings, List<? extends Weighting> edgeBasedCHWeightings,
-                              Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
+    public GraphHopperStorage(List<CHProfile> chProfiles, Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
         if (extendedStorage == null)
             throw new IllegalArgumentException("GraphExtension cannot be null, use NoOpExtension");
 
@@ -87,70 +83,65 @@ public void freeze() {
         };
 
         baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
-        for (Weighting w : nodeBasedCHWeightings) {
-            nodeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, false));
+        this.chGraphs = new ArrayList<>(chProfiles.size());
+        for (CHProfile chProfile : chProfiles) {
+            chGraphs.add(new CHGraphImpl(chProfile, dir, baseGraph));
         }
-        for (Weighting w : edgeBasedCHWeightings) {
-            edgeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, true));
+    }
+
+    public CHGraph getCHGraph() {
+        Collection<CHGraphImpl> chGraphs = getAllCHGraphs();
+        if (chGraphs.isEmpty()) {
+            throw new IllegalStateException("There is no CHGraph");
+        } else if (chGraphs.size() > 1) {
+            throw new IllegalStateException("There are multiple CHGraphs, use getCHGraph(CHProfile) to retrieve a specific one");
+        } else {
+            return chGraphs.iterator().next();
         }
     }
 
     /**
-     * This method returns the routing graph for the specified weighting, could be potentially
-     * filled with shortcuts.
+     * @return the {@link CHGraph} for the specified {@link CHProfile}
      */
-    public <T extends Graph> T getGraph(Class<T> clazz, Weighting weighting) {
-        if (clazz.equals(Graph.class))
-            return (T) baseGraph;
-
+    public CHGraph getCHGraph(CHProfile profile) {
         Collection<CHGraphImpl> chGraphs = getAllCHGraphs();
         if (chGraphs.isEmpty())
-            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
+            throw new IllegalStateException("There is no CHGraph");
 
-        if (weighting == null)
-            throw new IllegalStateException("Cannot find CHGraph with null weighting");
+        if (profile == null)
+            throw new IllegalStateException("Cannot find CHGraph with null CHProfile");
 
-        List<Weighting> existing = new ArrayList<>();
+        List<CHProfile> existing = new ArrayList<>();
         for (CHGraphImpl cg : chGraphs) {
-            if (cg.getWeighting() == weighting)
-                return (T) cg;
-
-            existing.add(cg.getWeighting());
+            if (cg.getCHProfile().equals(profile))
+                return cg;
+            existing.add(cg.getCHProfile());
         }
 
-        throw new IllegalStateException("Cannot find CHGraph for specified weighting: " + weighting + ", existing:" + existing);
-    }
-
-    public <T extends Graph> T getGraph(Class<T> clazz) {
-        if (clazz.equals(Graph.class))
-            return (T) baseGraph;
-
-        Collection<CHGraphImpl> chGraphs = getAllCHGraphs();
-        if (chGraphs.isEmpty())
-            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
-
-        CHGraph cg = chGraphs.iterator().next();
-        return (T) cg;
+        throw new IllegalStateException("Cannot find CHGraph for the specified profile: " + profile + ", existing:" + existing);
     }
 
     public boolean isCHPossible() {
         return !getAllCHGraphs().isEmpty();
     }
 
-    public List<Weighting> getNodeBasedCHWeightings() {
-        return getWeightingsFromGraphs(nodeBasedCHGraphs);
-    }
-
-    public List<Weighting> getEdgeBasedCHWeightings() {
-        return getWeightingsFromGraphs(edgeBasedCHGraphs);
+    public List<CHProfile> getCHProfiles() {
+        List<CHProfile> result = new ArrayList<>(chGraphs.size());
+        for (CHGraphImpl chGraph : chGraphs) {
+            result.add(chGraph.getCHProfile());
+        }
+        return result;
     }
 
-    private List<Weighting> getWeightingsFromGraphs(Collection<CHGraphImpl> graphs) {
-        List<Weighting> list = new ArrayList<>(graphs.size());
-        for (CHGraphImpl cg : graphs) {
-            list.add(cg.getWeighting());
+    public List<CHProfile> getCHProfiles(boolean edgeBased) {
+        List<CHProfile> result = new ArrayList<>();
+        List<CHProfile> chProfiles = getCHProfiles();
+        for (CHProfile profile : chProfiles) {
+            if (edgeBased == profile.isEdgeBased()) {
+                result.add(profile);
+            }
         }
-        return list;
+        return result;
     }
 
     /**
@@ -197,8 +188,7 @@ public GraphHopperStorage create(long byteCount) {
             cg.create(byteCount);
         }
 
-        properties.put("graph.ch.weightings", getNodeBasedCHWeightings().toString());
-        properties.put("graph.ch.edge.weightings", getEdgeBasedCHWeightings().toString());
+        properties.put("graph.ch.profiles", getCHProfiles().toString());
         return this;
     }
 
@@ -251,13 +241,21 @@ public boolean loadExisting() {
             // check encoding for compatibility
             String flagEncodersStr = properties.get("graph.flag_encoders");
 
-            if (!flagEncodersStr.isEmpty() && !encodingManager.toFlagEncodersAsString().equalsIgnoreCase(flagEncodersStr)) {
+            if (!encodingManager.toFlagEncodersAsString().equalsIgnoreCase(flagEncodersStr)) {
                 throw new IllegalStateException("Encoding does not match:"
                         + "\nGraphhopper config: " + encodingManager.toFlagEncodersAsString()
                         + "\nGraph: " + flagEncodersStr
                         + "\nChange configuration to match the graph or delete " + dir.getLocation());
             }
 
+            String encodedValueStr = properties.get("graph.encoded_values");
+            if (!encodingManager.toEncodedValuesAsString().equalsIgnoreCase(encodedValueStr)) {
+                throw new IllegalStateException("Encoded values do not match:"
+                        + "\nGraphhopper config: " + encodingManager.toEncodedValuesAsString()
+                        + "\nGraph: " + encodedValueStr
+                        + "\nChange configuration to match the graph or delete " + dir.getLocation());
+            }
+
             String byteOrder = properties.get("graph.byte_order");
             if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
                 throw new IllegalStateException("Configured graph.byte_order (" + dir.getByteOrder() + ") is not equal to loaded " + byteOrder + "");
@@ -282,28 +280,19 @@ public boolean loadExisting() {
     }
 
     private void checkIfConfiguredAndLoadedWeightingsCompatible() {
-        String loadedStrNode = properties.get("graph.ch.weightings");
-        List<String> loadedNode = parseList(loadedStrNode);
-        String loadedStrEdge = properties.get("graph.ch.edge.weightings");
-        List<String> loadedEdge = parseList(loadedStrEdge);
-        List<Weighting> configuredNode = getNodeBasedCHWeightings();
-        List<Weighting> configuredEdge = getEdgeBasedCHWeightings();
+        String loadedStr = properties.get("graph.ch.profiles");
+        List<String> loaded = parseList(loadedStr);
+        List<CHProfile> configured = getCHProfiles();
         // todo: not entirely sure here. when no ch is configured at all (neither edge nor node), but there are any
         // ch graphs (edge or node) we throw an error ? previously we threw an error when no ch weighting was configured
         // even though there was a ch graph.
-        if ((configuredNode.isEmpty() && configuredEdge.isEmpty()) && (!loadedNode.isEmpty() || !loadedEdge.isEmpty())) {
-            throw new IllegalStateException("You loaded a CH graph, but you did not specify graph.ch.weightings");
-        }
-        for (Weighting w : configuredNode) {
-            if (!loadedNode.contains(w.toString())) {
-                throw new IllegalStateException("Configured weighting: " + w.toString() + " is not contained in loaded weightings for CH" + loadedStrNode + ".\n" +
-                        "You configured graph.ch.weightings: " + configuredNode);
-            }
+        if (configured.isEmpty() && !loaded.isEmpty()) {
+            throw new IllegalStateException("You loaded a CH graph, but you did not specify any CH weightings in prepare.ch.weightings");
         }
-        for (Weighting w : configuredEdge) {
-            if (!loadedEdge.contains(w.toString())) {
-                throw new IllegalStateException("Configured weighting: " + w.toString() + " is not contained in loaded weightings for edge-based CH" + loadedStrEdge + ".\n" +
-                        "You configured graph.ch.edge.weightings: " + configuredEdge);
+        for (CHProfile chProfile : configured) {
+            if (!loaded.contains(chProfile.toString())) {
+                throw new IllegalStateException("Configured CH profile: " + chProfile.toString() + " is not contained in loaded weightings for CH" + loadedStr + ".\n" +
+                        "You configured: " + configured);
             }
         }
     }
@@ -313,6 +302,8 @@ private void checkIfConfiguredAndLoadedWeightingsCompatible() {
      */
     private List<String> parseList(String listStr) {
         String trimmed = listStr.trim();
+        if (trimmed.length() < 2)
+            return Collections.emptyList();
         String[] items = trimmed.substring(1, trimmed.length() - 1).split(",");
         List<String> result = new ArrayList<>();
         for (String item : items) {
@@ -394,9 +385,9 @@ public String toString() {
                 + "|" + getProperties().versionsToString();
     }
 
-    // now all delegation graph method to avoid ugly programming flow ala
+    // now delegate all Graph methods to BaseGraph to avoid ugly programming flow ala
     // GraphHopperStorage storage = ..;
-    // Graph g = storage.getGraph(Graph.class);
+    // Graph g = storage.getBaseGraph();
     // instead directly the storage can be used to traverse the base graph
     @Override
     public Graph getBaseGraph() {
@@ -474,12 +465,14 @@ public boolean isAdjacentToNode(int edge, int node) {
     }
 
     private Collection<CHGraphImpl> getAllCHGraphs() {
-        // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
-        // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
-        // the lists are in sync). another option would be something like guava concat.
-        List<CHGraphImpl> result = new ArrayList<>(nodeBasedCHGraphs.size() + edgeBasedCHGraphs.size());
-        result.addAll(nodeBasedCHGraphs);
-        result.addAll(edgeBasedCHGraphs);
+        return chGraphs;
+    }
+
+    private static List<CHProfile> createProfilesForWeightings(Collection<? extends Weighting> weightings) {
+        List<CHProfile> result = new ArrayList<>(weightings.size());
+        for (Weighting weighting : weightings) {
+            result.add(CHProfile.nodeBased(weighting));
+        }
         return result;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index ec52bcf005..d2bcd5368e 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -52,8 +52,6 @@
  *
  * The exact behavior of memory-mapping is reported to be wildly platform-dependent.
  *
- * <p>
- *
  * @author Peter Karich
  * @author Michael Zilske
  */
@@ -258,7 +256,6 @@ private ByteBuffer newByteBuffer(long offset, long byteCount) throws IOException
             } catch (IOException tmpex) {
                 ioex = tmpex;
                 trial++;
-                Helper.cleanHack();
                 try {
                     // mini sleep to let JVM do unmapping
                     Thread.sleep(5);
@@ -328,19 +325,9 @@ public void flush() {
     @Override
     public void close() {
         super.close();
-        close(true);
-    }
-
-    /**
-     * @param forceClean if true the clean hack (system.gc) will be executed and forces the system
-     *                   to cleanup the mmap resources. Set false if you need to close many MMapDataAccess objects.
-     */
-    void close(boolean forceClean) {
         clean(0, segments.size());
         segments.clear();
         Helper.close(raFile);
-        if (forceClean)
-            Helper.cleanHack();
     }
 
     @Override
@@ -476,7 +463,6 @@ public void trimTo(long capacity) {
         }
 
         clean(remainingSegNo, segments.size());
-        Helper.cleanHack();
         segments = new ArrayList<>(segments.subList(0, remainingSegNo));
 
         try {
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index e1d43c193d..3ba03f9c2e 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -189,7 +189,7 @@ public void mergeOrOverwriteTurnInfo(int fromEdge, int viaNode, int toEdge, long
      * @return turn flags of the specified node and edge properties.
      */
     public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
-        if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo))
             throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
         if (nodeVia < 0)
             throw new IllegalArgumentException("via node cannot be negative");
@@ -201,6 +201,10 @@ public boolean isUTurn(int edgeFrom, int edgeTo) {
         return edgeFrom == edgeTo;
     }
 
+    public boolean isUTurnAllowed(int node) {
+        return true;
+    }
+
     private long nextCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index fe8bd4baa5..f2695ad087 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -38,10 +38,11 @@
  * @author Peter Karich
  */
 public class QueryResult {
+    public static final int INVALID_NODE = -1;
     private final GHPoint queryPoint;
     private double queryDistance = Double.MAX_VALUE;
     private int wayIndex = -1;
-    private int closestNode = -1;
+    private int closestNode = INVALID_NODE;
     private EdgeIteratorState closestEdge;
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
@@ -54,7 +55,7 @@ public QueryResult(double queryLat, double queryLon) {
      * Returns the closest matching node. This is either a tower node of the base graph
      * or a virtual node (see also {@link com.graphhopper.routing.QueryGraph#lookup(List)}).
      *
-     * @return -1 if nothing found, this should be avoided via a call of 'isValid'
+     * @return {@link #INVALID_NODE} if nothing found, this should be avoided via a call of 'isValid'
      */
     public int getClosestNode() {
         return closestNode;
@@ -171,7 +172,7 @@ public String toString() {
     /**
      * Whether the query point is projected onto a tower node, pillar node or somewhere within
      * the closest edge.
-     *
+     * <p>
      * Due to precision differences it is hard to define when something is exactly 90 or "on-node"
      * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
      * "on-edge" even if it could be 90. To prefer "on-node" you could use e.g. GHPoint.equals with
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 1944b81ac4..cfeab365b8 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -34,7 +34,6 @@
      */
     public static final String JAVA_VERSION = System.getProperty("java.version");
 
-
     /**
      * The value of <tt>System.getProperty("os.name")</tt>. *
      */
@@ -68,8 +67,8 @@
     private static final int JVM_MINOR_VERSION;
 
     public static final int VERSION_NODE = 5;
-    public static final int VERSION_EDGE = 14;
-    public static final int VERSION_SHORTCUT = 2;
+    public static final int VERSION_EDGE = 15;
+    public static final int VERSION_SHORTCUT = 5;
     public static final int VERSION_GEOMETRY = 4;
     public static final int VERSION_LOCATION_IDX = 3;
     public static final int VERSION_NAME_IDX = 3;
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index 4fa6b3a3be..0359dedba1 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -40,11 +40,17 @@
  */
 public interface EdgeIterator extends EdgeIteratorState {
     /**
-     * integer value to indicate if an edge is valid or not which then would be initialized with
-     * this value
+     * Integer value used in places where normally an edge would be expected, but none is given. For example in the
+     * shortest path tree of route calculations every child element should have an incoming edge, but for the root item
+     * there is no parent so we would use this value instead.
      */
     int NO_EDGE = -1;
 
+    /**
+     * Integer value used in places where normally an edge would be expected, but no specific edge shall be specified.
+     */
+    int ANY_EDGE = -2;
+
     /**
      * To be called to go to the next edge state.
      * <p>
@@ -54,8 +60,13 @@
     boolean next();
 
     class Edge {
+        /**
+         * Checks if a given integer edge ID is valid or not. Edge IDs >= 0 are considered valid, while negative
+         * values are considered as invalid. However, some negative values are used as special values, e.g. {@link
+         * #NO_EDGE}.
+         */
         public static boolean isValid(int edgeId) {
-            return edgeId > NO_EDGE;
+            return edgeId >= 0;
         }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 6fff92e309..fd03380960 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -36,6 +36,8 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static com.graphhopper.util.Helper.DIST_EARTH;
+
 /**
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
  * methods are useful for unit tests or debugging only.
@@ -406,7 +408,7 @@ public static GraphHopperStorage newStorage(GraphHopperStorage store) {
         Directory outdir = guessDirectory(store);
         boolean is3D = store.getNodeAccess().is3D();
 
-        return new GraphHopperStorage(store.getNodeBasedCHWeightings(), store.getEdgeBasedCHWeightings(), outdir, store.getEncodingManager(),
+        return new GraphHopperStorage(store.getCHProfiles(), outdir, store.getEncodingManager(),
                 is3D, store.getExtension()).
                 create(store.getNodes());
     }
@@ -599,12 +601,22 @@ public static EdgeIteratorState setProperties(EdgeIteratorState edge, FlagEncode
         return edge;
     }
 
-    public static final EncodingManager.Builder addDefaultEncodedValues(EncodingManager.Builder builder) {
+    public static EncodingManager.Builder addDefaultEncodedValues(EncodingManager.Builder builder) {
         return builder.add(new OSMRoadClassParser()).add(new OSMRoadClassLinkParser()).
                 add(new OSMRoadEnvironmentParser()).add(new OSMMaxSpeedParser()).add(new OSMRoadAccessParser()).
                 add(new OSMSurfaceParser());
     }
 
+    public static void updateDistancesFor(Graph g, int node, double lat, double lon) {
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(node, lat, lon);
+        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
+        while (iter.next()) {
+            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(DIST_EARTH));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
+        }
+    }
+
     /**
      * This edge iterator can be used in tests to mock specific iterator behaviour via overloading
      * certain methods.
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 7d381c249c..bdf4856ca0 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -34,9 +34,9 @@
     // ISO codes (639-1), use 'en_US' as reference
     private static final List<String> LOCALES = Arrays.asList("ar", "ast", "bg", "ca",
             "cs_CZ", "da_DK", "de_DE", "el", "eo", "es", "en_US", "fa", "fil", "fi",
-            "fr_FR", "fr_CH", "gl", "he", "hr_HR", "hsb", "hu_HU", "it", "ja", "ko", "lt_LT", "ne",
+            "fr_FR", "fr_CH", "gl", "he", "hr_HR", "hsb", "hu_HU", "in_ID", "it", "ja", "ko", "lt_LT", "ne",
             "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "sk", "sl_SI", "sr_RS", "sv_SE", "tr", "uk",
-            "vi_VI", "zh_CN", "zh_HK", "zh_TW");
+            "vi_VN", "zh_CN", "zh_HK", "zh_TW");
     private final Map<String, Translation> translations = new HashMap<>();
 
     public static int countOccurence(String phrase, String splitter) {
diff --git a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
index 62e373256c..e50e4cdf8c 100644
--- a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
+++ b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
@@ -54,7 +54,8 @@
         if (requestedPathDetails.contains(DISTANCE))
             builders.add(new DistanceDetails());
 
-        for (String key : Arrays.asList(MaxSpeed.KEY, MaxWidth.KEY, MaxHeight.KEY, MaxWeight.KEY)) {
+        for (String key : Arrays.asList(MaxSpeed.KEY, MaxWidth.KEY, MaxHeight.KEY, MaxWeight.KEY,
+                        MaxAxleLoad.KEY, MaxLength.KEY)) {
             if (requestedPathDetails.contains(key) && encoder.hasEncodedValue(key))
                 builders.add(new DecimalDetails(key, encoder.getDecimalEncodedValue(key)));
         }
@@ -62,7 +63,7 @@
         for (Map.Entry entry : Arrays.asList(new MapEntry<>(RoadClass.KEY, RoadClass.class),
                 new MapEntry<>(RoadEnvironment.KEY, RoadEnvironment.class), new MapEntry<>(Surface.KEY, Surface.class),
                 new MapEntry<>(RoadAccess.KEY, RoadAccess.class), new MapEntry<>(Toll.KEY, Toll.class),
-                new MapEntry<>(Country.KEY, Country.class))) {
+                new MapEntry<>(TrackType.KEY, TrackType.class), new MapEntry<>(Country.KEY, Country.class))) {
             String key = (String) entry.getKey();
             if (requestedPathDetails.contains(key) && encoder.hasEncodedValue(key))
                 builders.add(new EnumDetails(key, encoder.getEnumEncodedValue(key, (Class<Enum>) entry.getValue())));
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
index d8bc4e4756..315d712d53 100644
--- a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -4,15 +4,15 @@ continue=pokraujte
 continue_onto=pokraujte na %1$s
 turn_left=odbote vlevo
 turn_right=odbote vpravo
-turn_slight_left=odbote mrn vpravo
+turn_slight_left=odbote mrn vlevo
 turn_slight_right=odbote mrn vpravo
-turn_sharp_left=odbote oste doleva
-turn_sharp_right=odbote oste doprava
-keep_left=
-keep_right=
+turn_sharp_left=odbote oste vlevo
+turn_sharp_right=odbote oste vpravo
+keep_left=drte se vlevo
+keep_right=drte se vpravo
 turn_onto=%1$s na %2$s
-u_turn=
-unknown=
+u_turn=otote se
+unknown=neznm pokyn %1$s
 web.search_button=Vyhledat
 web.from_hint=Z
 web.via_hint=Pes 
@@ -20,15 +20,15 @@ web.to_hint=Do
 web.more_button=vce
 web.gpx_export_button=Export do GPX
 web.route_info=%1$s bude trvat %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=doraz v %1$s, %2$s pestup(y) (%3$s) 
+web.pt_route_info_walking=doraz v %1$s (%2$s)
 web.locations_not_found=Navigovn nen dostupn. Pozice nenalezena v tto oblasti.
 web.bike=Kolo
 web.racingbike=Zvodn kolo
 web.mtb=Horsk kolo
 web.car=Automobil
 web.foot=Pky
-web.hike=
+web.hike=Turistika
 web.small_truck=Dodvka
 web.bus=Autobus
 web.truck=Nkladn automobil
@@ -47,7 +47,7 @@ road=silnice
 off_bike=sesednte z kola
 cycleway=cyklotrasa
 way=cesta
-small_way=
+small_way=peina
 paved=zpevnn
 unpaved=nezpevnn
 stopover=zastvka %1$s
@@ -56,10 +56,10 @@ roundabout_exit=Na kruhovm objezdu pouijte %1$s. vjezd
 roundabout_exit_onto=Na kruhovm objezdu pouijte %1$s. vjezd, smrem na %2$s
 total_ascend=Celkov stoupn %1$s
 total_descend=Celkov klesn %1$s
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=na cest je brod
+pt_start_trip=nastupte do %1$s
+pt_end_trip=vystupte z %1$s
+pt_transfer_to=pestupte na %1$s
 web.start_label=Start
 web.intermediate_label=Zastvka
 web.end_label=Cl
@@ -76,4 +76,4 @@ web.refresh_button=Obnovit strnku
 web.server_status=Stav
 web.zoom_in=Piblit
 web.zoom_out=Oddlit
-web.drag_to_reorder=
+web.drag_to_reorder=Petaenm zmnte poad
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 483f1f620d..6c5a4afcb9 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -54,9 +54,9 @@ stopover=waypoint %1$s
 roundabout_enter=Enter roundabout
 roundabout_exit=At roundabout, take exit %1$s
 roundabout_exit_onto=At roundabout, take exit %1$s onto %2$s
-total_ascend=%1$s total ascend
-total_descend=%1$s total descend
-way_contains_ford=there is ford along the way
+total_ascend=%1$s total ascent
+total_descend=%1$s total descent
+way_contains_ford=there is a ford along the way
 pt_start_trip=enter %1$s
 pt_end_trip=leave %1$s
 pt_transfer_to=change to %1$s
diff --git a/core/src/main/resources/com/graphhopper/util/in_ID.txt b/core/src/main/resources/com/graphhopper/util/in_ID.txt
new file mode 100644
index 0000000000..fe7f6e5bb2
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/in_ID.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=lanjut
+continue_onto=menuju pada %1$s
+turn_left=belok kiri
+turn_right=belok kanan
+turn_slight_left=belok kiri sedikit
+turn_slight_right=belok kanan sedikit
+turn_sharp_left=belok kiri tajam
+turn_sharp_right=belok kanan tajam
+keep_left=tetap berada jalur kiri
+keep_right=tetap berada jalur kiri
+turn_onto=%1$s belok menuju %2$s
+u_turn=putar balik
+unknown=petunjuk baru %1$s
+web.search_button=pencarian
+web.from_hint=dari
+web.via_hint=melalui
+web.to_hint=ke
+web.more_button=lebih lanjut
+web.gpx_export_button=Ekspor GPX
+web.route_info=%1$s berada dalam waktu %2$s
+web.pt_route_info=sampai pada %1$s dengan %2$s jarak (%3$s)
+web.pt_route_info_walking=sampai pada %1$s dengan berjalan kaki (%2$s)
+web.locations_not_found=Penentuan rute tidak dapat dilakukan. Lokasi tidak ditemukan
+web.bike=Sepeda
+web.racingbike=Sepeda Balap
+web.mtb=Sepeda Gunung
+web.car=Mobil
+web.foot=Jalan Kaki
+web.hike=Mendaki
+web.small_truck=Truk Kecil
+web.bus=Bus
+web.truck=Truk
+web.staticlink=Jalur tetap
+web.motorcycle=Motor
+via=melalui
+finish=Sampai pada tujuan akhir
+hour_abbr=jam
+day_abbr=hari
+min_abbr=menit
+km_abbr=km
+m_abbr=m
+mi_abbr=mil
+ft_abbr=foot
+road=jalan
+off_bike=turun dari sepeda
+cycleway=jalur sepeda
+way=jalan
+small_way=jalan kecil
+paved=beraspal
+unpaved=non-aspal
+stopover=titik hubung %1$s
+roundabout_enter=Masuk bundaran
+roundabout_exit=Pada bundaran, keluar melalui %1$s
+roundabout_exit_onto=At roundabout, take exit %1$s onto %2$s
+total_ascend=naik dengan jarak %1$s
+total_descend=turun dengan jarak %1$s
+way_contains_ford=terdapat jalan untuk dilewati
+pt_start_trip=masuk dalam %1$s
+pt_end_trip=keluar dalam %1$s
+pt_transfer_to=berpindah ke jalur %1$s
+web.start_label=Mulai
+web.intermediate_label=Antara
+web.end_label=Akhir
+web.set_start=Atur sebagai titik mulai
+web.set_intermediate=Atur sebagai titik antara
+web.set_end=Atur sebagai titik akhir
+web.center_map=Tengahkan Peta
+web.show_coords=Tampilkan koordinat
+web.route=Rute
+web.delete_from_route=Hapus dari rute
+web.marker=Titik
+web.gh_offline_info=Pelayanan API Graphhopper dalam kondisi offline
+web.refresh_button=Perbarui Halaman
+web.server_status=Status
+web.zoom_in=Perbesaran
+web.zoom_out=Pengecilan
+web.drag_to_reorder=Drag untuk mengatur urutan
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index 48997d93e4..34e536fd72 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=
-continue_onto=  %1$s
+continue_onto=  %1$s
 turn_left= 
 turn_right= 
 turn_slight_left=  
@@ -10,9 +10,9 @@ turn_sharp_left=  
 turn_sharp_right=  
 keep_left= 
 keep_right= 
-turn_onto=%1$s  %2$s
+turn_onto=%1$s  %2$s
 u_turn=
-unknown=  %1$s
+unknown=  %1$s
 web.search_button=
 web.from_hint=
 web.via_hint=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
deleted file mode 100644
index 6296833aae..0000000000
--- a/core/src/main/resources/com/graphhopper/util/vi_VI.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
-
-continue=tip tc
-continue_onto=tip tc theo %1$s
-turn_left=r tri
-turn_right=r phi
-turn_slight_left=r tri nh
-turn_slight_right=r phi nh
-turn_sharp_left=r tri ngay
-turn_sharp_right=r phi ngay
-keep_left=
-keep_right=
-turn_onto=%1$s theo %1$s
-u_turn=
-unknown=
-web.search_button=Tm
-web.from_hint=T
-web.via_hint=Qua
-web.to_hint=n
-web.more_button=thm
-web.gpx_export_button=Xut GPX
-web.route_info=%1$s mt %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
-web.locations_not_found=Khng tm thy l trnh! Cc im  chn khng tm thy trong vng ny.
-web.bike=Xe p
-web.racingbike=Xe ua
-web.mtb=Xe leo ni
-web.car= t
-web.foot=i b
-web.hike=
-web.small_truck=Xe ti nh
-web.bus=
-web.truck=
-web.staticlink=lin kt tnh
-web.motorcycle=M t
-via=qua
-finish=Kt thc!
-hour_abbr=g
-day_abbr=n
-min_abbr=p
-km_abbr=km
-m_abbr=m
-mi_abbr=dm
-ft_abbr=ft
-road=ng
-off_bike=xung khi xe p
-cycleway=ng xe p
-way=ng
-small_way=
-paved=ng lt
-unpaved=ng khng lt
-stopover=chng dng chn %1$s
-roundabout_enter=i vo vng xoay
-roundabout_exit=Ti vng xoay, r li r %1$s
-roundabout_exit_onto=Ti vng xoay, r li r %1$s vo ng %2$s
-total_ascend=i tip %1$s na
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
-web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VN.txt b/core/src/main/resources/com/graphhopper/util/vi_VN.txt
new file mode 100644
index 0000000000..659d4e1135
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VN.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tip tc
+continue_onto=tip tc theo %1$s
+turn_left=r tri
+turn_right=r phi
+turn_slight_left=r nh sang tri
+turn_slight_right=r nh sang phi
+turn_sharp_left=r tri ngay lp tc
+turn_sharp_right=r phi ngay lp tc
+keep_left= bn tri
+keep_right= bn phi
+turn_onto=%1$s vo %2$s
+u_turn=quay u xe
+unknown=khng xc nh %1$s
+web.search_button=Tm
+web.from_hint=T
+web.via_hint=Qua
+web.to_hint=n
+web.more_button=thm
+web.gpx_export_button=Xut GPX
+web.route_info=%1$s mt %2$s
+web.pt_route_info=n lc %1$s vi %2$s phng tin(tuyn) (%3$s )
+web.pt_route_info_walking=n lc %1$s ch bng cch i b (%2$s)
+web.locations_not_found=Khng tm thy l trnh! Cc im  chn khng tm thy trong vng ny.
+web.bike=Xe p
+web.racingbike=Xe p ua
+web.mtb=Xe leo ni
+web.car= t
+web.foot=i b
+web.hike=i b ng di
+web.small_truck=Xe ti nh
+web.bus=Xe but
+web.truck=Xe ti
+web.staticlink=lin kt tnh
+web.motorcycle=M t
+via=qua
+finish=Kt thc!
+hour_abbr=gi
+day_abbr=ngy
+min_abbr=pht
+km_abbr=km
+m_abbr=m
+mi_abbr=dm
+ft_abbr=ft
+road=ng
+off_bike=xung khi xe p
+cycleway=ng xe p
+way=ng
+small_way=ng nh
+paved=ng lt
+unpaved=ng khng lt
+stopover=chng dng chn %1$s
+roundabout_enter=i vo vng xoay
+roundabout_exit=Ti vng xoay, r li r %1$s
+roundabout_exit_onto=Ti vng xoay, r li r %1$s vo ng %2$s
+total_ascend=i tip %1$s na
+total_descend=
+way_contains_ford=c khc sng cn trn ng
+pt_start_trip=nhp tuyn %1$s
+pt_end_trip=ri tuyn %1$s
+pt_transfer_to=chuyn sang tuyn %1$s
+web.start_label=im bt u
+web.intermediate_label=im trung gian
+web.end_label=im kt thc
+web.set_start=Chn im bt u
+web.set_intermediate=Chn im trung gian
+web.set_end=Chn im kt thc
+web.center_map=Trung tm bn 
+web.show_coords=Xem ta 
+web.route=L trnh
+web.delete_from_route=Xa khi tuyn ng
+web.marker=nh du
+web.gh_offline_info=Mt kt ni vi GH API
+web.refresh_button=Lm mi li trang
+web.server_status=Tnh trng Server
+web.zoom_in=Phng to
+web.zoom_out=Thu nh
+web.drag_to_reorder=Ko  xp li
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java
index da6075e4a8..3a7012bbda 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java
@@ -19,18 +19,16 @@
 
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.Parameters;
 
-import java.util.Collections;
+import java.util.ArrayList;
 import java.util.List;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+
 public class AStarBidirectionEdgeCHTest extends AbstractRoutingAlgorithmTester {
     @Override
     protected AlgorithmOptions createAlgoOptions() {
@@ -41,20 +39,24 @@ protected AlgorithmOptions createAlgoOptions() {
 
     @Override
     protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(CHGraph.class, weighting);
+        return ghStorage.getCHGraph(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS));
     }
 
     @Override
     protected GraphHopperStorage createGHStorage(
             EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
-        return new GraphHopperStorage(Collections.<Weighting>emptyList(), weightings, new RAMDirectory(), em, is3D, new TurnCostExtension()).create(1000);
+        List<CHProfile> chProfiles = new ArrayList<>(weightings.size());
+        for (Weighting w : weightings) {
+            chProfiles.add(CHProfile.edgeBased(w, INFINITE_U_TURN_COSTS));
+        }
+        return new GraphHopperStorage(chProfiles, new RAMDirectory(), em, is3D, new TurnCostExtension()).create(1000);
     }
 
     @Override
     public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         ghStorage.freeze();
         PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
-                ghStorage, opts.getWeighting(), TraversalMode.EDGE_BASED);
+                ghStorage, CHProfile.edgeBased(opts.getWeighting(), INFINITE_U_TURN_COSTS));
         ch.doWork();
         return ch;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 1c1b63a3a1..8594b4ea61 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -34,6 +34,7 @@
 import java.util.Collection;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 
 /**
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 1851e6bf43..7985c2f808 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -37,6 +37,8 @@
 import java.util.List;
 import java.util.Random;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
+import static com.graphhopper.util.Helper.DIST_EARTH;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
@@ -45,7 +47,6 @@
  */
 public abstract class AbstractRoutingAlgorithmTester {
     protected static final EncodingManager encodingManager = EncodingManager.create("car,foot");
-    private static final DistanceCalc distCalc = new DistanceCalcEarth();
     protected FlagEncoder carEncoder;
     protected DecimalEncodedValue carAvSpeedEnc;
     protected BooleanEncodedValue carAccessEnc;
@@ -86,16 +87,6 @@ public static Graph initBiGraph(Graph graph) {
         return graph;
     }
 
-    public static void updateDistancesFor(Graph g, int node, double lat, double lon) {
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(node, lat, lon);
-        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
-        while (iter.next()) {
-            iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
-            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
-        }
-    }
-
     protected static GraphHopperStorage createMatrixAlikeGraph(GraphHopperStorage tmpGraph) {
         int WIDTH = 10;
         int HEIGHT = 15;
@@ -163,7 +154,7 @@ protected AlgorithmOptions createAlgoOptions() {
     }
 
     protected Graph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(Graph.class, weighting);
+        return ghStorage.getBaseGraph();
     }
 
     protected GraphHopperStorage createGHStorage(EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
@@ -238,8 +229,7 @@ public void testBidirectionalLinear() {
     public void testCalcFastestPath() {
         GraphHopperStorage graphShortest = createGHStorage(false);
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
-        Path p1 = createAlgo(graphShortest, defaultOpts).
-                calcPath(0, 3);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(IntArrayList.from(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
@@ -767,7 +757,7 @@ QueryResult newQR(Graph graph, int node1, int node2) {
         res.setClosestEdge(edge);
         res.setWayIndex(0);
         res.setSnappedPosition(QueryResult.Position.EDGE);
-        res.calcSnappedPoint(distCalc);
+        res.calcSnappedPoint(DIST_EARTH);
         return res;
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
index 3da0516de2..fcb632b541 100644
--- a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
@@ -35,7 +35,7 @@
 import java.util.Collection;
 import java.util.List;
 
-import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.*;
 
 @RunWith(Parameterized.class)
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/BidirPathExtractorTest.java
similarity index 78%
rename from core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
rename to core/src/test/java/com/graphhopper/routing/BidirPathExtractorTest.java
index 6ee7677a52..0c7e346a56 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/BidirPathExtractorTest.java
@@ -34,8 +34,9 @@
 
 /**
  * @author Peter Karich
+ * @author easbar
  */
-public class PathBidirRefTest {
+public class BidirPathExtractorTest {
     private FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 10);
     private final EncodingManager encodingManager = EncodingManager.create(carEncoder);
 
@@ -47,11 +48,10 @@ Graph createGraph() {
     public void testExtract() {
         Graph g = createGraph();
         g.edge(1, 2, 10, true);
-        PathBidirRef p = new PathBidirRef(g, new FastestWeighting(carEncoder));
-        p.sptEntry = new SPTEntry(0, 2, 0);
-        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
-        p.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
-        p.extract();
+        SPTEntry fwdEntry = new SPTEntry(0, 2, 0);
+        fwdEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
+        SPTEntry bwdEntry = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
+        Path p = BidirPathExtractor.extractPath(g, new FastestWeighting(carEncoder), fwdEntry, bwdEntry, 0);
         assertEquals(IntArrayList.from(1, 2), p.calcNodes());
         assertEquals(10, p.getDistance(), 1e-4);
     }
@@ -67,15 +67,15 @@ public void testExtract2() {
         TurnCostExtension turnCostExtension = (TurnCostExtension) g.getExtension();
         turnCostExtension.addTurnInfo(0, 2, 1, carEncoder.getTurnFlags(false, 5));
 
-        PathBidirRef p = new PathBidirRef(g, new TurnWeighting(new FastestWeighting(carEncoder), turnCostExtension));
-        p.sptEntry = new SPTEntry(0, 2, 0.6);
-        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+        SPTEntry fwdEntry = new SPTEntry(0, 2, 0.6);
+        fwdEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
 
-        p.edgeTo = new SPTEntry(1, 2, 1.2);
-        p.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
+        SPTEntry bwdEntry = new SPTEntry(1, 2, 1.2);
+        bwdEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
+
+        Path p = BidirPathExtractor.extractPath(g, new TurnWeighting(new FastestWeighting(carEncoder), turnCostExtension), fwdEntry, bwdEntry, 0);
         p.setWeight(5 + 1.8);
 
-        p.extract();
         assertEquals(IntArrayList.from(1, 2, 3), p.calcNodes());
         assertEquals(30, p.getDistance(), 1e-4);
         assertEquals(5 + 1.8, p.getWeight(), 1e-4);
diff --git a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
index f2024ba0b7..2d0b7255fa 100644
--- a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
@@ -29,7 +29,6 @@
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import org.junit.Test;
@@ -40,6 +39,7 @@
 import java.util.List;
 import java.util.Locale;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
@@ -54,9 +54,9 @@
     private final FlagEncoder encoder = new MotorcycleFlagEncoder(5, 5, maxCost);
     private final EncodingManager encodingManager = EncodingManager.create(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
-    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS)).create();
     private final TurnCostExtension turnCostExtension = (TurnCostExtension) graph.getExtension();
-    private final CHGraph chGraph = graph.getGraph(CHGraph.class);
+    private final CHGraph chGraph = graph.getCHGraph();
     private String algoString;
 
     @Parameterized.Parameters(name = "{0}")
@@ -718,10 +718,7 @@ private AbstractBidirectionEdgeCHNoSOD createAlgo() {
     }
 
     private void addShortcut(int from, int to, int firstOrigEdge, int lastOrigEdge, int skipped1, int skipped2, double weight) {
-        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
-        // we need to set flags first because they overwrite weight etc
-        shortcut.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), weight);
-        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge).setSkippedEdges(skipped1, skipped2);
+        chGraph.shortcutEdgeBased(from, to, PrepareEncoder.getScFwdDir(), weight, skipped1, skipped2, firstOrigEdge, lastOrigEdge);
     }
 
     private void setLevelEqualToNodeIdForAllNodes() {
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
index 0475eed71a..1030499b37 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.routing.ch.NodeBasedNodeContractorTest;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
@@ -36,7 +35,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static com.graphhopper.routing.ch.NodeBasedNodeContractorTest.SC_ACCESS;
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -48,7 +46,7 @@
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester {
     @Override
     protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(CHGraph.class, weighting);
+        return ghStorage.getCHGraph(CHProfile.nodeBased(weighting));
     }
 
     @Override
@@ -62,7 +60,7 @@ protected GraphHopperStorage createGHStorage(EncodingManager em,
     public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         ghStorage.freeze();
         PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
-                ghStorage, opts.getWeighting(), TraversalMode.NODE_BASED);
+                ghStorage, CHProfile.nodeBased(opts.getWeighting()));
         ch.doWork();
         return ch;
     }
@@ -74,7 +72,7 @@ public void testPathRecursiveUnpacking() {
         EncodingManager em = EncodingManager.create(encoder);
         ShortestWeighting weighting = new ShortestWeighting(encoder);
         GraphHopperStorage ghStorage = createGHStorage(em, Arrays.asList(weighting), false);
-        CHGraphImpl g2 = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
+        CHGraph g2 = ghStorage.getCHGraph();
         g2.edge(0, 1, 1, true);
         EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, false);
         EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, false);
@@ -92,14 +90,8 @@ public void testPathRecursiveUnpacking() {
 
         ghStorage.freeze();
         // simulate preparation
-        CHEdgeIteratorState iter2_1 = g2.shortcut(0, 5);
-        iter2_1.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 1);
-        iter2_1.setDistance(2.8);
-        iter2_1.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
-        CHEdgeIteratorState tmp = g2.shortcut(0, 7);
-        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 1);
-        tmp.setDistance(4.2);
-        tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
+        int sc2_1 = g2.shortcut(0, 5, PrepareEncoder.getScFwdDir(), 1, iter1_1.getEdge(), iter1_2.getEdge());
+        g2.shortcut(0, 7, PrepareEncoder.getScFwdDir(), 1, sc2_1, iter2_2.getEdge());
         g2.setLevel(1, 0);
         g2.setLevel(3, 1);
         g2.setLevel(4, 2);
@@ -110,9 +102,7 @@ public void testPathRecursiveUnpacking() {
         g2.setLevel(0, 7);
 
         AlgorithmOptions opts = new AlgorithmOptions(Parameters.Algorithms.DIJKSTRA_BI, weighting);
-        Path p = new PrepareContractionHierarchies(
-                g2, weighting, TraversalMode.NODE_BASED).
-                createAlgo(g2, opts).calcPath(0, 7);
+        Path p = new PrepareContractionHierarchies(g2).createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(IntArrayList.from(0, 2, 5, 7), p.calcNodes());
         assertEquals(1064, p.getTime());
@@ -196,7 +186,7 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
         }
         graph.edge(9, 0, 1, false);
         graph.edge(3, 9, 200, false);
-        CHGraph chGraph = graph.getGraph(CHGraph.class);
+        CHGraph chGraph = graph.getCHGraph();
 
         // explicitly set the node levels equal to the node ids
         // the graph contraction with this ordering yields no shortcuts
@@ -204,7 +194,7 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
             chGraph.setLevel(i, i);
         }
         graph.freeze();
-        RoutingAlgorithm algo = createCHAlgo(graph, chGraph, true, defaultOpts);
+        RoutingAlgorithm algo = createCHAlgo(chGraph, true, defaultOpts);
         Path p = algo.calcPath(1, 0);
         // node 3 will be stalled and nodes 4-7 won't be explored --> we visit 7 nodes
         // note that node 9 will be visited by both forward and backward searches
@@ -213,7 +203,7 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
         assertEquals(p.toString(), IntArrayList.from(1, 8, 9, 0), p.calcNodes());
 
         // without stalling we visit 11 nodes
-        RoutingAlgorithm algoNoSod = createCHAlgo(graph, chGraph, false, defaultOpts);
+        RoutingAlgorithm algoNoSod = createCHAlgo(chGraph, false, defaultOpts);
         Path pNoSod = algoNoSod.calcPath(1, 0);
         assertEquals(11, algoNoSod.getVisitedNodes());
         assertEquals(102, pNoSod.getDistance(), 1.e-3);
@@ -251,21 +241,20 @@ private void runTestWithDirectionDependentEdgeSpeed(double speed, double revSpee
 
         graph.edge(1, 2, 1, true);
 
-        CHGraph chGraph = graph.getGraph(CHGraph.class);
+        CHGraph chGraph = graph.getCHGraph();
         for (int i = 0; i < 3; ++i) {
             chGraph.setLevel(i, i);
         }
         graph.freeze();
 
-        RoutingAlgorithm algo = createCHAlgo(graph, chGraph, true, algoOpts);
+        RoutingAlgorithm algo = createCHAlgo(chGraph, true, algoOpts);
         Path p = algo.calcPath(from, to);
         assertEquals(3, p.getDistance(), 1.e-3);
         assertEquals(p.toString(), expectedPath, p.calcNodes());
     }
 
-    private RoutingAlgorithm createCHAlgo(GraphHopperStorage graph, CHGraph chGraph, boolean withSOD, AlgorithmOptions algorithmOptions) {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(
-                chGraph, algorithmOptions.getWeighting(), TraversalMode.NODE_BASED);
+    private RoutingAlgorithm createCHAlgo(CHGraph chGraph, boolean withSOD, AlgorithmOptions algorithmOptions) {
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(chGraph);
         if (!withSOD) {
             algorithmOptions.getHints().put("stall_on_demand", false);
         }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java
index ed84bb20f7..2e4adba9a2 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java
@@ -19,31 +19,35 @@
 
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 
-import java.util.Collections;
+import java.util.ArrayList;
 import java.util.List;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+
 public class DijkstraBidirectionEdgeCHTest extends AbstractRoutingAlgorithmTester {
     @Override
     protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(CHGraph.class, weighting);
+        return ghStorage.getCHGraph(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS));
     }
 
     @Override
     protected GraphHopperStorage createGHStorage(
             EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
-        return new GraphHopperStorage(Collections.<Weighting>emptyList(), weightings, new RAMDirectory(),
-                em, is3D, new TurnCostExtension()).create(1000);
+        List<CHProfile> chProfiles = new ArrayList<>(weightings.size());
+        for (Weighting w : weightings) {
+            chProfiles.add(CHProfile.edgeBased(w, INFINITE_U_TURN_COSTS));
+        }
+        return new GraphHopperStorage(chProfiles, new RAMDirectory(), em, is3D, new TurnCostExtension()).create(1000);
     }
 
     @Override
     public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
         ghStorage.freeze();
         PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
-                ghStorage, opts.getWeighting(), TraversalMode.EDGE_BASED);
+                ghStorage, CHProfile.edgeBased(opts.getWeighting(), INFINITE_U_TURN_COSTS));
         ch.doWork();
         return ch;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 158867463a..01545fe467 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.storage.CHProfile;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -172,7 +173,7 @@ public void testUseCache() {
 
     @Test
     public void testDifferentEdgeFilter() {
-        GraphHopperStorage g = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
+        GraphHopperStorage g = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(new FastestWeighting(carEncoder))).create();
         g.edge(4, 3, 10, true);
         g.edge(3, 6, 10, true);
 
diff --git a/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java
new file mode 100644
index 0000000000..0a8e28613c
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/DirectedBidirectionalDijkstraTest.java
@@ -0,0 +1,564 @@
+package com.graphhopper.routing;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.Repeat;
+import com.graphhopper.RepeatRule;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.*;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Random;
+
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * This test makes sure that {@link DijkstraBidirectionRef#calcPath(int from, int to, int fromOutEdge, int toInEdge)}, i.e.
+ * calculating a path with restricted/enforced first/last edges works as expected.
+ * <p>
+ * For other bidirectional algorithms we simply compare with {@link DijkstraBidirectionRef} in {@link DirectedRoutingTest}
+ */
+public class DirectedBidirectionalDijkstraTest {
+    private Directory dir;
+    private TurnCostExtension turnCostExtension;
+    private int maxTurnCosts;
+    private GraphHopperStorage graph;
+    private FlagEncoder encoder;
+    private EncodingManager encodingManager;
+    private Weighting weighting;
+    private LocationIndex locationIndex;
+    private QueryGraph queryGraph;
+
+    @Rule
+    public RepeatRule repeatRule = new RepeatRule();
+
+    @Before
+    public void setup() {
+        dir = new RAMDirectory();
+        maxTurnCosts = 10;
+        encoder = new CarFlagEncoder(5, 5, maxTurnCosts);
+        encodingManager = EncodingManager.create(encoder);
+        turnCostExtension = new TurnCostExtension();
+        graph = new GraphHopperStorage(dir, encodingManager, false, turnCostExtension).create(1000);
+        weighting = createWeighting(Double.POSITIVE_INFINITY);
+    }
+
+    private Weighting createWeighting(double defaultUTurnCosts) {
+        return new TurnWeighting(new FastestWeighting(encoder), turnCostExtension, defaultUTurnCosts);
+    }
+
+    @Test
+    public void connectionNotFound() {
+        // nodes 0 and 2 are not connected
+        // 0 -> 1     2 -> 3
+        graph.edge(0, 1, 1, false);
+        graph.edge(2, 3, 1, false);
+
+        Path path = calcPath(0, 3, 0, 1);
+        assertNotFound(path);
+    }
+
+    @Test
+    public void singleEdge() {
+        graph.edge(0, 1, 1, true);
+
+        // source edge does not exist -> no path
+        assertNotFound(calcPath(0, 1, 5, 0));
+        // target edge does not exist -> no path
+        assertNotFound(calcPath(0, 1, 0, 5));
+        // using NO_EDGE -> no path
+        assertNotFound(calcPath(0, 1, NO_EDGE, 0));
+        assertNotFound(calcPath(0, 1, 0, NO_EDGE));
+        // using ANY_EDGE -> no restriction
+        assertPath(calcPath(0, 1, ANY_EDGE, 0), 0.06, 1, 60, nodes(0, 1));
+        assertPath(calcPath(0, 1, 0, ANY_EDGE), 0.06, 1, 60, nodes(0, 1));
+        // edges exist -> they are used as restrictions
+        assertPath(calcPath(0, 1, 0, 0), 0.06, 1, 60, nodes(0, 1));
+    }
+
+    @Test
+    public void simpleGraph() {
+        // 0 -> 1 -> 2
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+
+        // source edge does not exist -> no path
+        assertNotFound(calcPath(0, 2, 5, 0));
+        // target edge does not exist -> no path
+        assertNotFound(calcPath(0, 2, 0, 5));
+        // using NO_EDGE -> no  path
+        assertNotFound(calcPath(0, 2, NO_EDGE, 0));
+        assertNotFound(calcPath(0, 2, 0, NO_EDGE));
+        // using ANY_EDGE -> no restriction
+        assertPath(calcPath(0, 2, ANY_EDGE, 1), 0.12, 2, 120, nodes(0, 1, 2));
+        assertPath(calcPath(0, 2, 0, ANY_EDGE), 0.12, 2, 120, nodes(0, 1, 2));
+        // edges exist -> they are used as restrictions
+        assertPath(calcPath(0, 2, 0, 1), 0.12, 2, 120, nodes(0, 1, 2));
+    }
+
+    @Test
+    public void sourceEqualsTarget() {
+        // Since we are enforcing source/target edges, starting and arriving at the same node normally does not yield
+        // zero weight. Either the weight is finite (using a real path back to the source node) or the
+        // weight is infinite (when no such path exists). The exception of course would involve zero weight edges.
+        // 0 - 1
+        //  \  |
+        //   - 2
+        graph.edge(0, 1, 1, true);
+        graph.edge(0, 2, 1, true);
+        graph.edge(1, 2, 1, true);
+        assertPath(calcPath(0, 0, 0, 1), 0.18, 3, 180, nodes(0, 1, 2, 0));
+        assertPath(calcPath(0, 0, 1, 0), 0.18, 3, 180, nodes(0, 2, 1, 0));
+        // without restrictions the weight should be zero
+        assertPath(calcPath(0, 0, ANY_EDGE, ANY_EDGE), 0, 0, 0, nodes(0));
+        // in some cases no path is possible
+        assertNotFound(calcPath(0, 0, 1, 1));
+        assertNotFound(calcPath(0, 0, 5, 1));
+    }
+
+    @Test
+    public void restrictedEdges() {
+        // =: costly edge
+        // 0 = 1 - 2 - 3 = 4
+        //  \      |      /
+        //   - 5 - 6 - 7 -
+        int costlySource = graph.edge(0, 1, 5, true).getEdge();
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        int costlyTarget = graph.edge(3, 4, 5, true).getEdge();
+        int cheapSource = graph.edge(0, 5, 1, true).getEdge();
+        graph.edge(5, 6, 1, true);
+        graph.edge(6, 7, 1, true);
+        int cheapTarget = graph.edge(7, 4, 1, true).getEdge();
+        graph.edge(2, 6, 1, true);
+
+        assertPath(calcPath(0, 4, cheapSource, cheapTarget), 0.24, 4, 240, nodes(0, 5, 6, 7, 4));
+        assertPath(calcPath(0, 4, cheapSource, costlyTarget), 0.54, 9, 540, nodes(0, 5, 6, 2, 3, 4));
+        assertPath(calcPath(0, 4, costlySource, cheapTarget), 0.54, 9, 540, nodes(0, 1, 2, 6, 7, 4));
+        assertPath(calcPath(0, 4, costlySource, costlyTarget), 0.72, 12, 720, nodes(0, 1, 2, 3, 4));
+    }
+
+    @Test
+    public void notConnectedDueToRestrictions() {
+        //   - 1 -
+        //  /     \
+        // 0       2
+        //  \     /
+        //   - 3 -
+        // we cannot go from 0 to 2 if we enforce north-south or south-north
+        int sourceNorth = graph.edge(0, 1, 1, true).getEdge();
+        int sourceSouth = graph.edge(0, 3, 2, true).getEdge();
+        int targetNorth = graph.edge(1, 2, 3, true).getEdge();
+        int targetSouth = graph.edge(3, 2, 4, true).getEdge();
+
+        assertPath(calcPath(0, 2, sourceNorth, targetNorth), 0.24, 4, 240, nodes(0, 1, 2));
+        assertNotFound(calcPath(0, 2, sourceNorth, targetSouth));
+        assertNotFound(calcPath(0, 2, sourceSouth, targetNorth));
+        assertPath(calcPath(0, 2, sourceSouth, targetSouth), 0.36, 6, 360, nodes(0, 3, 2));
+    }
+
+    @Test
+    public void restrictions_one_ways() {
+        // 0 <- 1 <- 2
+        //  \   |   /
+        //   >--3-->
+        graph.edge(0, 3, 1, false);
+        graph.edge(1, 0, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 1, 1, false);
+        graph.edge(1, 3, 1, true);
+
+        assertPath(calcPath(0, 2, 0, 2), 0.12, 2, 120, nodes(0, 3, 2));
+        assertNotFound(calcPath(0, 2, 1, 2));
+        assertNotFound(calcPath(0, 2, 0, 3));
+        assertNotFound(calcPath(0, 2, 1, 3));
+    }
+
+    @Test
+    public void forcingDirectionDoesNotMeanWeCannotUseEdgeAtAll() {
+        // 0 - 6 - 7
+        // |
+        // 1
+        // |
+        // 2 - 3
+        // |   |
+        // 5 - 4
+        int north = graph.edge(1, 0, 1, true).getEdge();
+        int south = graph.edge(1, 2, 1, true).getEdge();
+        graph.edge(2, 5, 1, false);
+        graph.edge(5, 4, 1, false);
+        graph.edge(4, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(1, 0, 1, false);
+        graph.edge(0, 6, 1, false);
+        int targetEdge = graph.edge(6, 7, 1, false).getEdge();
+        assertPath(calcPath(1, 7, north, targetEdge), 0.18, 3, 180, nodes(1, 0, 6, 7));
+        assertPath(calcPath(1, 7, south, targetEdge), 0.54, 9, 540, nodes(1, 2, 5, 4, 3, 2, 1, 0, 6, 7));
+    }
+
+    @Test
+    public void directedCircle() {
+        // 0---6--1 -> 2
+        // |          /
+        // 5 <- 4 <- 3
+        graph.edge(0, 6, 1, true);
+        graph.edge(6, 1, 1, true);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 0, 1, false);
+        assertPath(calcPath(6, 0, 1, 6), 0.36, 6, 360, nodes(6, 1, 2, 3, 4, 5, 0));
+    }
+
+    @Test
+    public void directedRouting() {
+        // =: costly edge
+        //   0 - 1   3 = 4
+        //   |    \ /    |
+        //   9     2     10
+        //   |    / \    |
+        //   8 = 7   6 = 5
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(3, 4, 3, true);
+        int rightNorth = graph.edge(4, 10, 1, true).getEdge();
+        int rightSouth = graph.edge(10, 5, 1, true).getEdge();
+        graph.edge(5, 6, 2, true);
+        graph.edge(6, 2, 1, true);
+        graph.edge(2, 7, 1, true);
+        graph.edge(7, 8, 9, true);
+        int leftSouth = graph.edge(8, 9, 1, true).getEdge();
+        int leftNorth = graph.edge(9, 0, 1, true).getEdge();
+
+        // make paths fully deterministic by applying some turn costs at junction node 2
+        addTurnCost(7, 2, 3, 1);
+        addTurnCost(7, 2, 6, 3);
+        addTurnCost(1, 2, 3, 5);
+        addTurnCost(1, 2, 6, 7);
+        addTurnCost(1, 2, 7, 9);
+
+        final double unitEdgeWeight = 0.06;
+        assertPath(calcPath(9, 9, leftNorth, leftSouth),
+                23 * unitEdgeWeight + 5, 23, (long) ((23 * unitEdgeWeight + 5) * 1000),
+                nodes(9, 0, 1, 2, 3, 4, 10, 5, 6, 2, 7, 8, 9));
+        assertPath(calcPath(9, 9, leftSouth, leftNorth),
+                14 * unitEdgeWeight, 14, (long) ((14 * unitEdgeWeight) * 1000),
+                nodes(9, 8, 7, 2, 1, 0, 9));
+        assertPath(calcPath(9, 10, leftSouth, rightSouth),
+                15 * unitEdgeWeight + 3, 15, (long) ((15 * unitEdgeWeight + 3) * 1000),
+                nodes(9, 8, 7, 2, 6, 5, 10));
+        assertPath(calcPath(9, 10, leftSouth, rightNorth),
+                16 * unitEdgeWeight + 1, 16, (long) ((16 * unitEdgeWeight + 1) * 1000),
+                nodes(9, 8, 7, 2, 3, 4, 10));
+    }
+
+    @Test
+    public void enforceLoopEdge() {
+        //  o       o
+        //  0 - 1 - 2
+        graph.edge(0, 0, 1, true);
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 2, 1, true);
+
+        assertPath(calcPath(0, 2, ANY_EDGE, ANY_EDGE), 0.12, 2, 120, nodes(0, 1, 2));
+        assertPath(calcPath(0, 2, 1, 2), 0.12, 2, 120, nodes(0, 1, 2));
+        // we can enforce taking the loop at start/target
+        assertPath(calcPath(0, 2, 0, 2), 0.18, 3, 180, nodes(0, 0, 1, 2));
+        assertPath(calcPath(0, 2, 1, 3), 0.18, 3, 180, nodes(0, 1, 2, 2));
+        assertPath(calcPath(0, 2, 0, 3), 0.24, 4, 240, nodes(0, 0, 1, 2, 2));
+    }
+
+    @Test
+    public void sourceAndTargetAreNeighbors() {
+        // 0-1-2-3
+        graph.edge(0, 1, 100, true);
+        graph.edge(1, 2, 100, true);
+        graph.edge(2, 3, 100, true);
+        assertPath(calcPath(1, 2, ANY_EDGE, ANY_EDGE), 6, 100, 6000, nodes(1, 2));
+        assertPath(calcPath(1, 2, 1, ANY_EDGE), 6, 100, 6000, nodes(1, 2));
+        assertPath(calcPath(1, 2, ANY_EDGE, 1), 6, 100, 6000, nodes(1, 2));
+        assertPath(calcPath(1, 2, 1, 1), 6, 100, 6000, nodes(1, 2));
+        // this case is a bit sketchy: we may not find a valid path just because the from/to
+        // node initialization hits the target/source node, but we have to also consider the
+        // edge restriction at the source/target nodes
+        assertNotFound(calcPath(1, 2, 1, 2));
+        assertNotFound(calcPath(1, 2, 0, 1));
+        assertNotFound(calcPath(1, 2, 0, 2));
+
+        // if we allow u-turns it is of course different again
+        assertPath(calcPath(1, 2, 1, 2, createWeighting(100)), 118, 300, 118000, nodes(1, 2, 3, 2));
+        assertPath(calcPath(1, 2, 0, 1, createWeighting(100)), 118, 300, 118000, nodes(1, 0, 1, 2));
+        assertPath(calcPath(1, 2, 0, 2, createWeighting(100)), 230, 500, 230000, nodes(1, 0, 1, 2, 3, 2));
+    }
+
+    @Test
+    public void worksWithTurnCosts() {
+        // 0 - 1 - 2
+        // |   |   |
+        // 3 - 4 - 5
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(1, 4, 1, true);
+        graph.edge(0, 3, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(4, 5, 1, true);
+        graph.edge(5, 2, 1, true);
+
+        addRestriction(0, 3, 4);
+        addTurnCost(4, 5, 2, 6);
+
+        // due to the restrictions we have to take the expensive path with turn costs
+        assertPath(calcPath(0, 2, 0, 6), 6.24, 4, 6240, nodes(0, 1, 4, 5, 2));
+        // enforcing going south from node 0 yields no path, because of the restricted turn 0->3->4
+        assertNotFound(calcPath(0, 2, 3, ANY_EDGE));
+        // without the restriction its possible
+        assertPath(calcPath(0, 2, ANY_EDGE, ANY_EDGE), 0.12, 2, 120, nodes(0, 1, 2));
+    }
+
+    @Test
+    public void finiteUTurnCosts() {
+        // = expensive edge
+        //      3 - 4
+        //      |   |
+        //      2 = 5
+        //      |
+        // 0 -- 1 -- 6
+        // |         |
+        // 7 -- 8 -- 9
+        int right0 = graph.edge(0, 1, 10, true).getEdge();
+        graph.edge(1, 2, 10, true);
+        graph.edge(2, 3, 10, true);
+        graph.edge(3, 4, 10, true);
+        graph.edge(4, 5, 10, true);
+        graph.edge(5, 2, 1000, true);
+        int left6 = graph.edge(1, 6, 10, true).getEdge();
+        int left0 = graph.edge(0, 7, 10, true).getEdge();
+        graph.edge(7, 8, 10, true);
+        graph.edge(8, 9, 10, true);
+        int right6 = graph.edge(9, 6, 10, true).getEdge();
+
+        // enforce p-turn (using the loop in clockwise direction)
+        addRestriction(0, 1, 6);
+        addRestriction(5, 4, 3);
+
+        assertPath(calcPath(0, 6, right0, left6), 64.2, 1070, 64200, nodes(0, 1, 2, 3, 4, 5, 2, 1, 6));
+        // if the u-turn cost is finite it depends on its value if we rather do the p-turn or do an immediate u-turn at node 2
+        assertPath(calcPath(0, 6, right0, left6, createWeighting(65)), 64.2, 1070, 64200, nodes(0, 1, 2, 3, 4, 5, 2, 1, 6));
+        assertPath(calcPath(0, 6, right0, left6, createWeighting(40)), 42.4, 40, 42400, nodes(0, 1, 2, 1, 6));
+
+        assertPath(calcPath(0, 6, left0, right6), 2.4, 40, 2400, nodes(0, 7, 8, 9, 6));
+        assertPath(calcPath(0, 6, left0, left6), 66.6, 1110, 66600, nodes(0, 7, 8, 9, 6, 1, 2, 3, 4, 5, 2, 1, 6));
+        // if the u-turn cost is finite we do a u-turn at node 1 (not at node 7 at the beginning!)
+        assertPath(calcPath(0, 6, left0, left6, createWeighting(40)), 43.6, 60, 43600, nodes(0, 7, 8, 9, 6, 1, 6));
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void compare_standard_dijkstra() {
+        compare_with_dijkstra(weighting);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void compare_standard_dijkstra_finite_uturn_costs() {
+        compare_with_dijkstra(createWeighting(40));
+    }
+
+    private void compare_with_dijkstra(Weighting w) {
+        // if we do not use start/target edge restrictions we should get the same result as with Dijkstra.
+        // basically this test should cover all kinds of interesting cases except the ones where we restrict the
+        // start/target edges.
+        final long seed = System.nanoTime();
+        final int numQueries = 1000;
+        System.out.println("compare_standard_dijkstra seed: " + seed);
+
+        Random rnd = new Random(seed);
+        int numNodes = 100;
+        GHUtility.buildRandomGraph(graph, rnd, numNodes, 2.2, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.8, 0.8);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, turnCostExtension);
+
+        long numStrictViolations = 0;
+        for (int i = 0; i < numQueries; i++) {
+            int source = rnd.nextInt(numNodes);
+            int target = rnd.nextInt(numNodes);
+            Path dijkstraPath = new Dijkstra(graph, w, TraversalMode.EDGE_BASED).calcPath(source, target);
+            Path path = calcPath(source, target, ANY_EDGE, ANY_EDGE, w);
+            assertEquals("dijkstra found/did not find a path, from: " + source + ", to: " + target, dijkstraPath.isFound(), path.isFound());
+            assertEquals("weight does not match dijkstra, from: " + source + ", to: " + target, dijkstraPath.getWeight(), path.getWeight(), 1.e-6);
+            // we do not do a strict check because there can be ambiguity, for example when there are zero weight loops.
+            // however, when there are too many deviations we fail
+            if (
+                    Math.abs(dijkstraPath.getDistance() - path.getDistance()) > 1.e-6
+                            || Math.abs(dijkstraPath.getTime() - path.getTime()) > 10
+                            || !dijkstraPath.calcNodes().equals(path.calcNodes())) {
+                numStrictViolations++;
+            }
+        }
+        if (numStrictViolations > Math.max(1, 0.05 * numQueries)) {
+            fail("Too many strict violations: " + numStrictViolations + " / " + numQueries);
+        }
+    }
+
+    @Test
+    public void blockArea() {
+        // 0 - 1 - 2 - 3
+        // |           |
+        // 4 --- 5 --- 6
+        EdgeIteratorState edge1 = graph.edge(0, 1, 10, true);
+        graph.edge(1, 2, 10, true);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 10, true);
+        graph.edge(0, 4, 100, true);
+        graph.edge(4, 5, 100, true);
+        graph.edge(5, 6, 100, true);
+        graph.edge(6, 3, 100, true);
+
+        // usually we would take the direct route
+        assertPath(calcPath(0, 3, ANY_EDGE, ANY_EDGE), 1.8, 30, 1800, nodes(0, 1, 2, 3));
+
+        // with forced edges we might have to go around
+        assertPath(calcPath(0, 3, 3, ANY_EDGE), 24, 400, 24000, nodes(0, 4, 5, 6, 3));
+        assertPath(calcPath(0, 3, ANY_EDGE, 6), 24, 400, 24000, nodes(0, 4, 5, 6, 3));
+
+        // with avoided edges we also have to take a longer route
+        assertPath(calcPath(0, 3, ANY_EDGE, ANY_EDGE, createAvoidEdgeWeighting(edge1)), 24, 400, 24000, nodes(0, 4, 5, 6, 3));
+        assertPath(calcPath(0, 3, ANY_EDGE, ANY_EDGE, createAvoidEdgeWeighting(edge2)), 24, 400, 24000, nodes(0, 4, 5, 6, 3));
+
+        // enforcing forbidden start/target edges still does not allow using them
+        assertNotFound(calcPath(0, 3, edge1.getEdge(), edge2.getEdge(), createAvoidEdgeWeighting(edge1)));
+        assertNotFound(calcPath(0, 3, edge1.getEdge(), edge2.getEdge(), createAvoidEdgeWeighting(edge2)));
+
+        // .. even when the nodes are just next to each other
+        assertNotFound(calcPath(0, 1, edge1.getEdge(), ANY_EDGE, createAvoidEdgeWeighting(edge1)));
+        assertNotFound(calcPath(0, 1, ANY_EDGE, edge2.getEdge(), createAvoidEdgeWeighting(edge2)));
+    }
+
+    private AvoidEdgesWeighting createAvoidEdgeWeighting(EdgeIteratorState edgeOut) {
+        AvoidEdgesWeighting avoidEdgesWeighting = new AvoidEdgesWeighting(weighting);
+        avoidEdgesWeighting.setEdgePenaltyFactor(Double.POSITIVE_INFINITY);
+        avoidEdgesWeighting.addEdges(Collections.singletonList(edgeOut));
+        return avoidEdgesWeighting;
+    }
+
+    @Test
+    public void directedRouting_noUTurnAtVirtualEdge() {
+        // what happens if we force to leave the snapped (virtual) node in eastern direction, even though we would
+        // like to go to node 0 just west from us ? we have to make sure there is no u-turn at node 1 (from the
+        // virtual edge onto edge 1-0). the query graph does this for us!
+
+        //    x
+        // 0 -- 1 -> 2
+        // |         |
+        // 5 <- 4 <- 3
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 0, 1, false);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 1, 0);
+        na.setNode(1, 1, 1);
+        na.setNode(2, 1, 2);
+        na.setNode(3, 0, 2);
+        na.setNode(4, 0, 1);
+        na.setNode(5, 0, 0);
+        initQueryGraph();
+
+        QueryResult qr = findClosest();
+        assertEquals("wanted to get EDGE", QueryResult.Position.EDGE, qr.getSnappedPosition());
+        assertEquals(6, qr.getClosestNode());
+
+        // check what edges there are on the query graph directly, there should not be a direct connection from 1 to 0
+        // anymore, but only the virtual edge from 1 to 6 (this is how the u-turn is prevented).
+        assertEquals(new HashSet<>(Arrays.asList(0, 2)), GHUtility.getNeighbors(graph.createEdgeExplorer().setBaseNode(1)));
+        assertEquals(new HashSet<>(Arrays.asList(6, 2)), GHUtility.getNeighbors(queryGraph.createEdgeExplorer().setBaseNode(1)));
+
+        EdgeIteratorState virtualEdge = GHUtility.getEdge(queryGraph, 6, 1);
+        int outEdge = virtualEdge.getEdge();
+        AbstractBidirAlgo algo = createAlgo(queryGraph, weighting);
+        Path path = algo.calcPath(6, 0, outEdge, ANY_EDGE);
+        assertEquals(nodes(6, 1, 2, 3, 4, 5, 0), path.calcNodes());
+        assertEquals(5 + virtualEdge.getDistance(), path.getDistance(), 1.e-3);
+    }
+
+    private void initQueryGraph() {
+        queryGraph = new QueryGraph(graph);
+        locationIndex = new LocationIndexTree(graph, dir);
+        locationIndex.prepareIndex();
+    }
+
+    private QueryResult findClosest() {
+        QueryResult qr = locationIndex.findClosest(1.1, 0.5, EdgeFilter.ALL_EDGES);
+        queryGraph.lookup(Collections.singletonList(qr));
+        return qr;
+    }
+
+    private Path calcPath(int source, int target, int sourceOutEdge, int targetInEdge) {
+        return calcPath(source, target, sourceOutEdge, targetInEdge, weighting);
+    }
+
+    private Path calcPath(int source, int target, int sourceOutEdge, int targetInEdge, Weighting w) {
+        AbstractBidirAlgo algo = createAlgo(graph, w);
+        return algo.calcPath(source, target, sourceOutEdge, targetInEdge);
+    }
+
+    private AbstractBidirAlgo createAlgo(Graph graph, Weighting weighting) {
+        return new DijkstraBidirectionRef(graph, weighting, TraversalMode.EDGE_BASED);
+    }
+
+    private void addRestriction(int fromNode, int node, int toNode) {
+        turnCostExtension.addTurnInfo(
+                GHUtility.getEdge(graph, fromNode, node).getEdge(),
+                node,
+                GHUtility.getEdge(graph, node, toNode).getEdge(),
+                encoder.getTurnFlags(true, 0)
+        );
+    }
+
+    private void addTurnCost(int fromNode, int node, int toNode, double turnCost) {
+        turnCostExtension.addTurnInfo(
+                GHUtility.getEdge(graph, fromNode, node).getEdge(),
+                node,
+                GHUtility.getEdge(graph, node, toNode).getEdge(),
+                encoder.getTurnFlags(false, turnCost)
+        );
+    }
+
+    private IntArrayList nodes(int... nodes) {
+        return IntArrayList.from(nodes);
+    }
+
+    private void assertPath(Path path, double weight, double distance, long time, IntArrayList nodes) {
+        assertTrue("expected a path, but no path was found", path.isFound());
+        assertEquals("unexpected weight", weight, path.getWeight(), 1.e-6);
+        assertEquals("unexpected distance", distance, path.getDistance(), 1.e-6);
+        assertEquals("unexpected time", time, path.getTime());
+        assertEquals("unexpected nodes", nodes, path.calcNodes());
+    }
+
+    private void assertNotFound(Path path) {
+        assertFalse("expected no path, but a path was found", path.isFound());
+        assertEquals(Double.MAX_VALUE, path.getWeight(), 1.e-6);
+        // if no path is found dist&time are zero, see core #1566
+        assertEquals(0, path.getDistance(), 1.e-6);
+        assertEquals(0, path.getTime());
+        assertEquals(nodes(), path.calcNodes());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index f816aa4ded..baf8ae858a 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -25,6 +25,7 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.GenericWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.details.PathDetail;
@@ -79,12 +80,10 @@ public void testWayList() {
         EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge2.setWayGeometry(Helper.createPointList(11, 1, 10, 1));
 
-        Path path = new Path(g, new FastestWeighting(encoder));
         SPTEntry e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setSPTEntry(e1);
-        path.extract();
+        Path path = extractPath(g, new FastestWeighting(encoder), e1);
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
         InstructionList instr = path.calcInstructions(carManagerRoundabout, tr);
@@ -116,12 +115,10 @@ public void testWayList() {
         na.setNode(3, 1.0, 1.0);
         g.edge(1, 3).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 10.0);
 
-        path = new Path(g, new FastestWeighting(encoder));
         e1 = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setSPTEntry(e1);
-        path.extract();
+        path = extractPath(g, new FastestWeighting(encoder), e1);
         instr = path.calcInstructions(carManagerRoundabout, tr);
 
         tmp = instr.get(0);
@@ -142,12 +139,10 @@ public void testWayList() {
         assertEquals(path.calcPoints().size() - 1, acc);
 
         // now reverse order
-        path = new Path(g, new FastestWeighting(encoder));
         e1 = new SPTEntry(edge1.getEdge(), 0, 1);
         e1.parent = new SPTEntry(edge2.getEdge(), 1, 1);
         e1.parent.parent = new SPTEntry(-1, 2, 1);
-        path.setSPTEntry(e1);
-        path.extract();
+        path = extractPath(g, new FastestWeighting(encoder), e1);
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
 
@@ -199,14 +194,12 @@ public void testFindInstruction() {
         g.edge(2, 5).setDistance(10000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         g.edge(3, 5).setDistance(100000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
 
-        Path path = new Path(g, new FastestWeighting(encoder));
         SPTEntry e1 = new SPTEntry(edge4.getEdge(), 4, 1);
         e1.parent = new SPTEntry(edge3.getEdge(), 3, 1);
         e1.parent.parent = new SPTEntry(edge2.getEdge(), 2, 1);
         e1.parent.parent.parent = new SPTEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent.parent.parent = new SPTEntry(-1, 0, 1);
-        path.setSPTEntry(e1);
-        path.extract();
+        Path path = extractPath(g, new FastestWeighting(encoder), e1);
 
         InstructionList il = path.calcInstructions(carManagerRoundabout, tr);
         Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
@@ -1026,4 +1019,8 @@ private double getAngle(int n1, int n2, int n3, int n4) {
         }
     }
 
+    private static Path extractPath(Graph graph, Weighting weighting, SPTEntry sptEntry) {
+        return PathExtractor.extractPath(graph, weighting, sptEntry);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index fda2a48546..fe65613253 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -36,6 +36,7 @@
 import java.util.*;
 
 import static com.graphhopper.storage.index.QueryResult.Position.*;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.*;
 
 /**
@@ -296,10 +297,10 @@ public void testLoopStreet_Issue151() {
         g.edge(1, 3, 10, true);
         g.edge(3, 4, 10, true);
         EdgeIteratorState edge = g.edge(1, 3, 20, true).setWayGeometry(Helper.createPointList(-0.001, 0.001, -0.001, 0.002));
-        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 0, 0, 0);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 1, 0, 0.001);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 3, 0, 0.002);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 4, 0, 0.003);
+        updateDistancesFor(g, 0, 0, 0);
+        updateDistancesFor(g, 1, 0, 0.001);
+        updateDistancesFor(g, 3, 0, 0.002);
+        updateDistancesFor(g, 4, 0, 0.003);
 
         QueryResult qr = new QueryResult(-0.0005, 0.001);
         qr.setClosestEdge(edge);
diff --git a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
index c8e7e5f609..ef0ac373be 100644
--- a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
@@ -23,10 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
+import java.util.*;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
@@ -34,24 +33,26 @@
 public class RandomCHRoutingTest {
     private final TraversalMode traversalMode;
     private final int maxTurnCosts;
+    private final int uTurnCosts;
     private Directory dir;
     private CarFlagEncoder encoder;
     private Weighting weighting;
     private GraphHopperStorage graph;
     private LocationIndexTree locationIndex;
-    private CHGraph chGraph;
 
-    @Parameterized.Parameters(name = "{0}")
-    public static Object[] params() {
-        return new Object[]{
-                TraversalMode.NODE_BASED,
-                TraversalMode.EDGE_BASED
-        };
+    @Parameterized.Parameters(name = "{0}, u-turn-costs={1}")
+    public static Collection<Object[]> params() {
+        return Arrays.asList(new Object[][]{
+                {TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS},
+                {TraversalMode.EDGE_BASED, 40},
+                {TraversalMode.EDGE_BASED, INFINITE_U_TURN_COSTS}
+        });
     }
 
-    public RandomCHRoutingTest(TraversalMode traversalMode) {
+    public RandomCHRoutingTest(TraversalMode traversalMode, int uTurnCosts) {
         this.traversalMode = traversalMode;
         this.maxTurnCosts = 10;
+        this.uTurnCosts = uTurnCosts;
     }
 
     @Before
@@ -60,10 +61,9 @@ public void init() {
         encoder = new CarFlagEncoder(5, 5, maxTurnCosts);
         EncodingManager em = EncodingManager.create(encoder);
         weighting = new FastestWeighting(encoder);
-        GraphBuilder graphBuilder = new GraphBuilder(em);
-        graphBuilder.setEdgeBasedCH(traversalMode.isEdgeBased());
-        graph = graphBuilder.setCHGraph(weighting).create();
-        chGraph = graph.getGraph(CHGraph.class);
+        graph = new GraphBuilder(em)
+                .setCHProfiles(new CHProfile(weighting, traversalMode.isEdgeBased(), uTurnCosts))
+                .create();
     }
 
     /**
@@ -135,7 +135,9 @@ private void runRandomTest(Random rnd, int numVirtualNodes) {
         locationIndex.prepareIndex();
 
         graph.freeze();
-        PrepareContractionHierarchies pch = new PrepareContractionHierarchies(chGraph, weighting, traversalMode);
+        CHProfile chProfile = new CHProfile(weighting, traversalMode, uTurnCosts);
+        CHGraph chGraph = graph.getCHGraph(chProfile);
+        PrepareContractionHierarchies pch = new PrepareContractionHierarchies(chGraph);
         pch.doWork();
 
         int numQueryGraph = 25;
@@ -154,7 +156,7 @@ private void runRandomTest(Random rnd, int numVirtualNodes) {
                 int from = rnd.nextInt(queryGraph.getNodes());
                 int to = rnd.nextInt(queryGraph.getNodes());
                 Weighting w = traversalMode.isEdgeBased()
-                        ? new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension())
+                        ? new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension(), uTurnCosts == INFINITE_U_TURN_COSTS ? Double.POSITIVE_INFINITY : uTurnCosts)
                         : weighting;
                 // using plain dijkstra instead of bidirectional, because of #1592
                 RoutingAlgorithm refAlgo = new Dijkstra(queryGraph, w, traversalMode);
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 55a96877b1..24dce0d943 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -25,10 +25,7 @@
 import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.util.Parameters;
@@ -92,25 +89,17 @@ public RoutingAlgorithmFactory createRoutingFactory() {
             final HintsMap chHints = new HintsMap(defaultHints);
             chHints.put(Parameters.CH.DISABLE, false);
             chHints.put(Parameters.Routing.EDGE_BASED, tMode.isEdgeBased());
-            Weighting pickedWeighting = null;
-            for (Weighting tmpWeighting : hopper.getCHFactoryDecorator().getNodeBasedWeightings()) {
-                if (tmpWeighting.equals(weighting)) {
-                    pickedWeighting = tmpWeighting;
+            CHProfile pickedProfile = null;
+            for (CHProfile chProfile : hopper.getCHFactoryDecorator().getCHProfiles()) {
+                if (chProfile.getWeighting().equals(weighting) && tMode.isEdgeBased() == chProfile.getTraversalMode().isEdgeBased()) {
+                    pickedProfile = chProfile;
                     break;
                 }
             }
-            // todo: not so sure about this, can the edge based weighting entry overwrite the picked weighting found
-            // in the node based weightings ?
-            for (Weighting tmpWeighting : hopper.getCHFactoryDecorator().getEdgeBasedWeightings()) {
-                if (tmpWeighting.equals(weighting)) {
-                    pickedWeighting = tmpWeighting;
-                    break;
-                }
-            }
-            if (pickedWeighting == null)
-                throw new IllegalStateException("Didn't find weighting " + hints.getWeighting() + " in " + hopper.getCHFactoryDecorator().getNodeBasedWeightings());
+            if (pickedProfile == null)
+                throw new IllegalStateException("Didn't find weighting " + hints.getWeighting() + " in " + hopper.getCHFactoryDecorator().getCHProfiles());
 
-            prepare.add(new AlgoHelperEntry(ghStorage.getGraph(CHGraph.class, pickedWeighting),
+            prepare.add(new AlgoHelperEntry(ghStorage.getCHGraph(pickedProfile),
                     AlgorithmOptions.start(dijkstrabiOpts).hints(chHints).build(), idx, "dijkstrabi|ch|prepare|" + hints.getWeighting()) {
                 @Override
                 public RoutingAlgorithmFactory createRoutingFactory() {
@@ -118,7 +107,7 @@ public RoutingAlgorithmFactory createRoutingFactory() {
                 }
             });
 
-            prepare.add(new AlgoHelperEntry(ghStorage.getGraph(CHGraph.class, pickedWeighting),
+            prepare.add(new AlgoHelperEntry(ghStorage.getCHGraph(pickedProfile),
                     AlgorithmOptions.start(astarbiOpts).hints(chHints).build(), idx, "astarbi|ch|prepare|" + hints.getWeighting()) {
                 @Override
                 public RoutingAlgorithmFactory createRoutingFactory() {
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
index b3915467b0..5d7a6977c2 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
@@ -20,23 +20,17 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortFastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Arrays;
 import java.util.List;
 
-import static com.graphhopper.routing.util.TraversalMode.EDGE_BASED;
-import static com.graphhopper.routing.util.TraversalMode.NODE_BASED;
 import static org.junit.Assert.*;
 
 /**
@@ -44,9 +38,12 @@
  */
 public class CHAlgoFactoryDecoratorTest {
     private CHAlgoFactoryDecorator instance;
-    private Weighting weighting1;
-    private Weighting weighting2;
-    private Weighting weighting3;
+    private CHProfile profileNode1;
+    private CHProfile profileNode2;
+    private CHProfile profileNode3;
+    private CHProfile profileEdge1;
+    private CHProfile profileEdge2;
+    private CHProfile profileEdge3;
     private GraphHopperStorage ghStorage;
 
     @Before
@@ -55,87 +52,77 @@ public void setup() {
         Directory dir = new RAMDirectory();
         FlagEncoder encoder = new CarFlagEncoder();
         EncodingManager encodingManager = EncodingManager.create(encoder);
-        weighting1 = new FastestWeighting(encoder);
-        weighting2 = new ShortestWeighting(encoder);
-        weighting3 = new ShortFastestWeighting(encoder, 0.1);
+        profileNode1 = CHProfile.nodeBased(new FastestWeighting(encoder));
+        profileNode2 = CHProfile.nodeBased(new ShortestWeighting(encoder));
+        profileNode3 = CHProfile.nodeBased(new ShortFastestWeighting(encoder, 0.1));
+        profileEdge1 = CHProfile.edgeBased(new FastestWeighting(encoder), 30);
+        profileEdge2 = CHProfile.edgeBased(new ShortestWeighting(encoder), 30);
+        profileEdge3 = CHProfile.edgeBased(new ShortFastestWeighting(encoder, 0.1), 30);
         ghStorage = new GraphHopperStorage(
-                Arrays.asList(weighting1, weighting2, weighting3),
-                Arrays.asList(weighting1, weighting2, weighting3),
+                Arrays.asList(profileNode1, profileNode2, profileNode3, profileEdge1, profileEdge2, profileEdge3),
                 dir, encodingManager, false, new GraphExtension.NoOpExtension());
     }
 
     @Test
-    public void testCreatePreparations() {
+    public void testDisablingAllowed() {
         assertFalse(instance.isDisablingAllowed());
         instance.setEnabled(false);
         assertTrue(instance.isDisablingAllowed());
     }
 
     @Test(expected = IllegalStateException.class)
-    public void testAddingPreparationBeforeWeighting_throws() {
-        PrepareContractionHierarchies preparation = createNodeBasedPreparation(weighting1);
+    public void testAddingPreparationBeforeProfile_throws() {
+        PrepareContractionHierarchies preparation = createPreparation(profileNode1);
         instance.addPreparation(preparation);
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testAddingPreparationWithWrongWeighting_throws() {
-        instance.addNodeBasedWeighting(weighting1);
-        PrepareContractionHierarchies preparation = createNodeBasedPreparation(weighting2);
+    public void testAddingPreparationWithWrongProfile_throws() {
+        instance.addCHProfile(profileNode1);
+        PrepareContractionHierarchies preparation = createPreparation(profileNode2);
         instance.addPreparation(preparation);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testAddingPreparationsInWrongOrder_throws() {
-        instance.addNodeBasedWeighting(weighting1);
-        instance.addNodeBasedWeighting(weighting2);
-        instance.addPreparation(createNodeBasedPreparation(weighting2));
-        instance.addPreparation(createNodeBasedPreparation(weighting1));
+        instance.addCHProfile(profileNode1);
+        instance.addCHProfile(profileNode2);
+        instance.addPreparation(createPreparation(profileNode2));
+        instance.addPreparation(createPreparation(profileNode1));
     }
 
     @Test
     public void testAddingPreparationsWithEdgeAndNodeBasedIntermixed_works() {
-        instance.addNodeBasedWeighting(weighting1);
-        instance.addEdgeBasedWeighting(weighting1);
-        instance.addPreparation(createEdgeBasedPreparation(weighting1));
-        instance.addPreparation(createNodeBasedPreparation(weighting1));
+        instance.addCHProfile(profileNode1);
+        instance.addCHProfile(profileEdge1);
+        instance.addCHProfile(profileNode2);
+        instance.addPreparation(createPreparation(profileNode1));
+        instance.addPreparation(createPreparation(profileEdge1));
+        instance.addPreparation(createPreparation(profileNode2));
     }
 
     @Test
     public void testAddingEdgeAndNodeBased_works() {
-        instance.addEdgeBasedWeighting(weighting1);
-        instance.addNodeBasedWeighting(weighting2);
-        instance.addNodeBasedWeighting(weighting1);
-        instance.addEdgeBasedWeighting(weighting2);
-        instance.addEdgeBasedWeighting(weighting3);
-        // we can change the order between edge and node based as long as within each group the weightings have the
-        // right order
-        instance.addPreparation(createEdgeBasedPreparation(weighting1));
-        instance.addPreparation(createNodeBasedPreparation(weighting2));
-        instance.addPreparation(createEdgeBasedPreparation(weighting2));
-        instance.addPreparation(createEdgeBasedPreparation(weighting3));
-        instance.addPreparation(createNodeBasedPreparation(weighting1));
-
-        Weighting[] expectedWeightings = new Weighting[]{weighting1, weighting2, weighting2, weighting3, weighting1};
-        boolean[] expectedEdgedBaseds = new boolean[]{true, false, true, true, false};
-
+        instance.addCHProfile(profileNode1);
+        instance.addCHProfile(profileNode2);
+        instance.addCHProfile(profileEdge1);
+        instance.addCHProfile(profileEdge2);
+        instance.addCHProfile(profileNode3);
+        instance.addPreparation(createPreparation(profileNode1));
+        instance.addPreparation(createPreparation(profileNode2));
+        instance.addPreparation(createPreparation(profileEdge1));
+        instance.addPreparation(createPreparation(profileEdge2));
+        instance.addPreparation(createPreparation(profileNode3));
+
+        CHProfile[] expectedProfiles = new CHProfile[]{profileNode1, profileNode2, profileEdge1, profileEdge2, profileNode3};
         List<PrepareContractionHierarchies> preparations = instance.getPreparations();
         for (int i = 0; i < preparations.size(); ++i) {
-            assertSame(expectedWeightings[i], preparations.get(i).getWeighting());
-            assertSame(expectedEdgedBaseds[i], preparations.get(i).isEdgeBased());
+            assertSame(expectedProfiles[i], preparations.get(i).getCHProfile());
         }
     }
 
-    private PrepareContractionHierarchies createNodeBasedPreparation(Weighting weighting) {
-        return createPreparation(weighting, false);
-    }
-
-    private PrepareContractionHierarchies createEdgeBasedPreparation(Weighting weighting) {
-        return createPreparation(weighting, true);
-    }
-
-    private PrepareContractionHierarchies createPreparation(Weighting weighting, boolean edgedBased) {
-        TraversalMode traversalMode = edgedBased ? EDGE_BASED : NODE_BASED;
-        return PrepareContractionHierarchies.fromGraphHopperStorage(ghStorage, weighting, traversalMode);
+    private PrepareContractionHierarchies createPreparation(CHProfile chProfile) {
+        return PrepareContractionHierarchies.fromGraphHopperStorage(ghStorage, chProfile);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHProfileSelectorTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHProfileSelectorTest.java
new file mode 100644
index 0000000000..74d01342b7
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHProfileSelectorTest.java
@@ -0,0 +1,134 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHProfile;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+import static org.junit.Assert.*;
+
+public class CHProfileSelectorTest {
+
+    private Weighting fastestWeighting;
+
+    @Before
+    public void setup() {
+        EncodingManager em = EncodingManager.create("car");
+        FlagEncoder carEncoder = em.fetchEdgeEncoders().iterator().next();
+        fastestWeighting = new FastestWeighting(carEncoder);
+    }
+
+    @Test
+    public void onlyNodeBasedPresent() {
+        List<CHProfile> chProfiles = Collections.singletonList(
+                CHProfile.nodeBased(fastestWeighting)
+        );
+        assertCHProfileSelectionError("Found a node-based CH profile for weighting map {weighting=fastest, vehicle=car}, but requested edge-based CH", chProfiles, true, null);
+        assertCHProfileSelectionError("Found a node-based CH profile for weighting map {weighting=fastest, vehicle=car}, but requested edge-based CH", chProfiles, true, 20);
+        assertProfileFound(chProfiles.get(0), chProfiles, false, null);
+        assertProfileFound(chProfiles.get(0), chProfiles, false, 20);
+        assertProfileFound(chProfiles.get(0), chProfiles, null, null);
+        assertProfileFound(chProfiles.get(0), chProfiles, null, 30);
+        assertCHProfileSelectionError("Cannot find CH profile for weighting map", chProfiles, "foot", "fastest", false, null);
+    }
+
+    @Test
+    public void onlyEdgeBasedPresent() {
+        List<CHProfile> chProfiles = Collections.singletonList(
+                CHProfile.edgeBased(fastestWeighting, INFINITE_U_TURN_COSTS)
+        );
+        assertCHProfileSelectionError("Found 1 edge-based CH profile(s) for weighting map {weighting=fastest, vehicle=car}, but requested node-based CH", chProfiles, false, null);
+        assertCHProfileSelectionError("Found 1 edge-based CH profile(s) for weighting map {weighting=fastest, vehicle=car}, but requested node-based CH", chProfiles, false, 20);
+        assertProfileFound(chProfiles.get(0), chProfiles, true, null);
+        assertProfileFound(chProfiles.get(0), chProfiles, null, null);
+    }
+
+    @Test
+    public void edgeAndNodePresent() {
+        List<CHProfile> chProfiles = Arrays.asList(
+                CHProfile.nodeBased(fastestWeighting),
+                CHProfile.edgeBased(fastestWeighting, INFINITE_U_TURN_COSTS)
+        );
+        // in case edge-based is not specified we prefer the edge-based profile over the node-based one
+        assertProfileFound(chProfiles.get(1), chProfiles, null, null);
+        assertProfileFound(chProfiles.get(0), chProfiles, false, null);
+        assertProfileFound(chProfiles.get(1), chProfiles, true, null);
+    }
+
+    @Test
+    public void multipleEdgeBased() {
+        List<CHProfile> chProfiles = Arrays.asList(
+                CHProfile.nodeBased(fastestWeighting),
+                CHProfile.edgeBased(fastestWeighting, 30),
+                CHProfile.edgeBased(fastestWeighting, 50)
+        );
+        // when no u-turns are specified we throw
+        assertCHProfileSelectionError("Found matching edge-based CH profiles for multiple values of u-turn costs: [30, 50].",
+                chProfiles, true, null);
+        // when we request one that does not exist we throw
+        assertCHProfileSelectionError("but none for requested u-turn costs: 40, available: [30, 50]", chProfiles, true, 40);
+        // when we request one that exists it works
+        assertProfileFound(chProfiles.get(1), chProfiles, true, 30);
+
+        // without specifying edge-based
+        assertProfileFound(chProfiles.get(1), chProfiles, null, 30);
+        assertCHProfileSelectionError("but none for requested u-turn costs: 40, available: [30, 50", chProfiles, null, 40);
+        assertCHProfileSelectionError("Found matching edge-based CH profiles for multiple values of u-turn costs: [30, 50].", chProfiles, null, null);
+    }
+
+    private void assertProfileFound(CHProfile expectedProfile, List<CHProfile> profiles, Boolean edgeBased, Integer uTurnCosts) {
+        assertProfileFound(expectedProfile, profiles, "car", "fastest", edgeBased, uTurnCosts);
+    }
+
+    private void assertProfileFound(CHProfile expectedProfile, List<CHProfile> profiles, String vehicle, String weighting, Boolean edgeBased, Integer uTurnCosts) {
+        HintsMap weightingMap = new HintsMap().setWeighting(weighting).setVehicle(vehicle);
+        try {
+            CHProfile selectedProfile = CHProfileSelector.select(profiles, weightingMap, edgeBased, uTurnCosts);
+            assertEquals(expectedProfile, selectedProfile);
+        } catch (CHProfileSelectionException e) {
+            fail("no profile found, but expected: " + expectedProfile + ", error: " + e.getMessage());
+        }
+    }
+
+    private void assertCHProfileSelectionError(String expectedError, List<CHProfile> profiles, Boolean edgeBased, Integer uTurnCosts) {
+        assertCHProfileSelectionError(expectedError, profiles, "car", "fastest", edgeBased, uTurnCosts);
+    }
+
+    private void assertCHProfileSelectionError(String expectedError, List<CHProfile> profiles, String vehicle, String weighting, Boolean edgeBased, Integer uTurnCosts) {
+        HintsMap weightingMap = new HintsMap().setWeighting(weighting).setVehicle(vehicle);
+        try {
+            CHProfileSelector.select(profiles, weightingMap, edgeBased, uTurnCosts);
+            fail("There should have been an error");
+        } catch (CHProfileSelectionException e) {
+            assertTrue("There should have been an error message containing '" + expectedError + "', but was: '" + e.getMessage() + "'",
+                    e.getMessage().contains(expectedError));
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
index 2a255c20e4..92b3df91e0 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -38,8 +38,9 @@
 
 import java.util.*;
 
-import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.*;
 
 /**
@@ -59,7 +60,7 @@
     private Weighting weighting;
     private GraphHopperStorage graph;
     private TurnCostExtension turnCostExtension;
-    private TurnWeighting turnWeighting;
+    private List<CHProfile> chProfiles;
     private CHGraph chGraph;
     private boolean checkStrict;
 
@@ -73,13 +74,34 @@ public void init() {
         encoder = new CarFlagEncoder(5, 5, maxCost);
         EncodingManager encodingManager = EncodingManager.create(encoder);
         weighting = new ShortestWeighting(encoder);
-        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        chProfiles = createCHProfiles();
+        graph = new GraphBuilder(encodingManager).setCHProfiles(chProfiles).create();
+        // the default CH graph with infinite u-turn costs, can be reset in tests that should run with finite u-turn
+        // costs
+        chGraph = graph.getCHGraph(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS));
         turnCostExtension = (TurnCostExtension) graph.getExtension();
-        turnWeighting = new TurnWeighting(weighting, turnCostExtension);
-        chGraph = graph.getGraph(CHGraph.class);
         checkStrict = true;
     }
 
+    /**
+     * Creates a list of distinct CHProfiles with different u-turn costs that can be used by the tests.
+     * There is always a profile with infinite u-turn costs and one with u-turn-costs = 50.
+     */
+    private List<CHProfile> createCHProfiles() {
+        Set<CHProfile> profileSet = new HashSet<>(25);
+        // the first one is always the one with infinite u-turn costs
+        profileSet.add(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS));
+        // this one we also always add
+        profileSet.add(CHProfile.edgeBased(weighting, 50));
+        // add more (distinct) profiles
+        long seed = System.nanoTime();
+        Random rnd = new Random(seed);
+        while (profileSet.size() < 5) {
+            profileSet.add(CHProfile.edgeBased(weighting, 10 + rnd.nextInt(90)));
+        }
+        return new ArrayList<>(profileSet);
+    }
+
     @Test
     @Repeat(times = 10)
     public void testFindPath_randomContractionOrder_linear() {
@@ -623,6 +645,29 @@ public void testFindPath_loop() {
         compareCHQueryWithDijkstra(factory, 0, 5);
     }
 
+    @Test
+    public void testFindPath_finiteUTurnCost() {
+        // turning to 1 at node 3 when coming from 0 is forbidden, but taking the full loop 3-4-2-3 is very
+        // expensive, so the best solution is to go straight to 4 and take a u-turn there
+        //   1
+        //   |
+        // 0-3-4
+        //   |/
+        //   2
+        graph.edge(0, 3, 100, false);
+        graph.edge(3, 4, 100, true);
+        graph.edge(4, 2, 500, false);
+        graph.edge(2, 3, 200, false);
+        graph.edge(3, 1, 100, false);
+        addRestriction(0, 3, 1);
+        graph.freeze();
+        chGraph = graph.getCHGraph(CHProfile.edgeBased(weighting, 50));
+        RoutingAlgorithmFactory pch = prepareCH(Arrays.asList(4, 0, 2, 3, 1));
+        Path path = pch.createAlgo(chGraph, AlgorithmOptions.start().build()).calcPath(0, 1);
+        assertEquals(IntArrayList.from(0, 3, 4, 3, 1), path.calcNodes());
+        compareCHQueryWithDijkstra(pch, 0, 1);
+    }
+
     @Test
     public void testFindPath_calcTurnCostTime() {
         // here there will be a shortcut from 1 to 4 and when the path is unpacked it is important that
@@ -941,6 +986,57 @@ public void testRouteViaVirtualNode_withAlternative() {
         assertEquals(IntArrayList.from(1, 3, 0), path.calcNodes());
     }
 
+    @Test
+    public void testFiniteUTurnCost_virtualViaNode() {
+        // if there is an extra virtual node it can be possible to do a u-turn that otherwise would not be possible
+        // and so there can be a difference between CH and non-CH... therefore u-turns at virtual nodes are forbidden
+        // 4->3->2->1-x-0
+        //          |
+        //          5->6
+        graph.edge(4, 3, 0, false);
+        graph.edge(3, 2, 0, false);
+        graph.edge(2, 1, 0, false);
+        graph.edge(1, 0, 0, true);
+        graph.edge(1, 5, 0, false);
+        graph.edge(5, 6, 0, false);
+        updateDistancesFor(graph, 4, 0.1, 0.0);
+        updateDistancesFor(graph, 3, 0.1, 0.1);
+        updateDistancesFor(graph, 2, 0.1, 0.2);
+        updateDistancesFor(graph, 1, 0.1, 0.3);
+        updateDistancesFor(graph, 0, 0.1, 0.4);
+        updateDistancesFor(graph, 5, 0.0, 0.3);
+        updateDistancesFor(graph, 6, 0.0, 0.4);
+        // not allowed to turn right at node 1 -> we have to take a u-turn at node 0 (or at the virtual node...)
+        addRestriction(2, 1, 5);
+        graph.freeze();
+        chGraph = graph.getCHGraph(CHProfile.edgeBased(weighting, 50));
+        RoutingAlgorithmFactory pch = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5, 6));
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        GHPoint virtualPoint = new GHPoint(0.1, 0.35);
+        QueryResult qr = index.findClosest(virtualPoint.lat, virtualPoint.lon, EdgeFilter.ALL_EDGES);
+        QueryGraph chQueryGraph = new QueryGraph(chGraph);
+        chQueryGraph.lookup(Collections.singletonList(qr));
+        assertEquals(3, qr.getClosestEdge().getEdge());
+        RoutingAlgorithm chAlgo = pch.createAlgo(chQueryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(4, 6);
+        assertTrue(path.isFound());
+        assertEquals(IntArrayList.from(4, 3, 2, 1, 0, 1, 5, 6), path.calcNodes());
+
+        QueryResult qr2 = index.findClosest(virtualPoint.lat, virtualPoint.lon, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.singletonList(qr2));
+        assertEquals(3, qr2.getClosestEdge().getEdge());
+        Dijkstra dijkstra = new Dijkstra(queryGraph, new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension(), chGraph.getCHProfile().getUTurnCosts()), TraversalMode.EDGE_BASED);
+        Path dijkstraPath = dijkstra.calcPath(4, 6);
+        assertEquals(IntArrayList.from(4, 3, 2, 1, 7, 0, 7, 1, 5, 6), dijkstraPath.calcNodes());
+        assertEquals(dijkstraPath.getWeight(), path.getWeight(), 1.e-3);
+        assertEquals(dijkstraPath.getDistance(), path.getDistance(), 1.e-3);
+        assertEquals(dijkstraPath.getTime(), path.getTime(), 1.e-3);
+    }
+
     /**
      * This test runs on a random graph with random turn costs and a predefined (but random) contraction order.
      * It often produces exotic conditions that are hard to anticipate beforehand.
@@ -950,7 +1046,21 @@ public void testRouteViaVirtualNode_withAlternative() {
     @Test
     public void testFindPath_random_compareWithDijkstra() {
         long seed = System.nanoTime();
-        LOGGER.info("Seed used to generate graph: {}", seed);
+        LOGGER.info("Seed for testFindPath_random_compareWithDijkstra: {}", seed);
+        compareWithDijkstraOnRandomGraph(seed);
+    }
+
+    @Repeat(times = 10)
+    @Test
+    public void testFindPath_random_compareWithDijkstra_finiteUTurnCost() {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed for testFindPath_random_compareWithDijkstra_finiteUTurnCost: {}", seed);
+        chGraph = graph.getCHGraph(chProfiles.get(1 + new Random(seed).nextInt(chProfiles.size() - 1)));
+        LOGGER.info("U-turn-costs: " + chGraph.getCHProfile().getUTurnCostsInt());
+        compareWithDijkstraOnRandomGraph(seed);
+    }
+
+    private void compareWithDijkstraOnRandomGraph(long seed) {
         final Random rnd = new Random(seed);
         // for larger graphs preparation takes much longer the higher the degree is!
         GHUtility.buildRandomGraph(graph, rnd, 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
@@ -968,7 +1078,21 @@ public void testFindPath_random_compareWithDijkstra() {
     @Test
     public void testFindPath_heuristic_compareWithDijkstra() {
         long seed = System.nanoTime();
-        LOGGER.info("Seed used to generate graph: {}", seed);
+        LOGGER.info("Seed for testFindPath_heuristic_compareWithDijkstra: {}", seed);
+        compareWithDijkstraOnRandomGraph_heuristic(seed);
+    }
+
+    @Repeat(times = 10)
+    @Test
+    public void testFindPath_heuristic_compareWithDijkstra_finiteUTurnCost() {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed for testFindPath_heuristic_compareWithDijkstra_finiteUTurnCost: {}", seed);
+        chGraph = graph.getCHGraph(chProfiles.get(1 + new Random(seed).nextInt(chProfiles.size() - 1)));
+        LOGGER.info("U-turn-costs: " + chGraph.getCHProfile().getUTurnCostsInt());
+        compareWithDijkstraOnRandomGraph_heuristic(seed);
+    }
+
+    private void compareWithDijkstraOnRandomGraph_heuristic(long seed) {
         GHUtility.buildRandomGraph(graph, new Random(seed), 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
         GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
         graph.freeze();
@@ -1018,7 +1142,7 @@ private void checkPathUsingCH(IntArrayList expectedPath, int expectedEdgeWeight,
     }
 
     private Path findPathUsingDijkstra(int from, int to) {
-        Dijkstra dijkstra = new Dijkstra(graph, turnWeighting, TraversalMode.EDGE_BASED);
+        Dijkstra dijkstra = new Dijkstra(graph, new TurnWeighting(weighting, turnCostExtension, chGraph.getCHProfile().getUTurnCosts()), TraversalMode.EDGE_BASED);
         return dijkstra.calcPath(from, to);
     }
 
@@ -1042,7 +1166,7 @@ public int getNumNodes() {
                 return contractionOrder.size();
             }
         };
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(chGraph, weighting, TraversalMode.EDGE_BASED)
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(chGraph)
                 .useFixedNodeOrdering(nodeOrderingProvider);
         ch.doWork();
         return ch;
@@ -1054,8 +1178,7 @@ private RoutingAlgorithmFactory automaticPrepareCH() {
         pMap.put(LAST_LAZY_NODES_UPDATES, 100);
         pMap.put(NEIGHBOR_UPDATES, 4);
         pMap.put(LOG_MESSAGES, 10);
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(
-                chGraph, weighting, TraversalMode.EDGE_BASED);
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(chGraph);
         ch.setParams(pMap);
         ch.doWork();
         return ch;
@@ -1139,7 +1262,7 @@ private void addRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge,
         turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(true, 0));
     }
 
-    private void addTurnCost(int from, int via, int to, int cost) {
+    private void addTurnCost(int from, int via, int to, double cost) {
         addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java
index 111ec5473e..21deb208a5 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java
@@ -27,16 +27,11 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostExtension;
-import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.PMap;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -45,6 +40,7 @@
 import java.util.Objects;
 import java.util.Set;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.*;
 
 /**
@@ -59,8 +55,8 @@
     private CarFlagEncoder encoder;
     private GraphHopperStorage graph;
     private TurnCostExtension turnCostExtension;
-    private TurnWeighting turnWeighting;
-    private TurnWeighting chTurnWeighting;
+    private int uTurnCosts;
+    private Weighting weighting;
 
     @Rule
     public RepeatRule repeatRule = new RepeatRule();
@@ -74,13 +70,11 @@ public void setup() {
     private void initialize() {
         encoder = new CarFlagEncoder(5, 5, maxCost);
         EncodingManager encodingManager = EncodingManager.create(encoder);
-        Weighting weighting = new ShortestWeighting(encoder);
-        PreparationWeighting preparationWeighting = new PreparationWeighting(weighting);
-        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        weighting = new ShortestWeighting(encoder);
+        uTurnCosts = INFINITE_U_TURN_COSTS;
+        graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.edgeBased(weighting, uTurnCosts)).create();
         turnCostExtension = (TurnCostExtension) graph.getExtension();
-        turnWeighting = new TurnWeighting(weighting, turnCostExtension);
-        chTurnWeighting = new TurnWeighting(preparationWeighting, turnCostExtension);
-        chGraph = graph.getGraph(CHGraph.class);
+        chGraph = graph.getCHGraph();
     }
 
     @Test
@@ -390,8 +384,7 @@ public void testContractNode_twoNormalEdges_withTurnCost() {
         graph.freeze();
         setMaxLevelOnAllNodes();
         contractNodes(2);
-        double weight = calcWeight(e3to2, e2to4);
-        checkShortcuts(createShortcut(3, 4, e3to2, e2to4, weight));
+        checkShortcuts(createShortcut(3, 4, e3to2, e2to4, 12));
     }
 
     @Test
@@ -1125,6 +1118,31 @@ public void testNodeContraction_node_in_loop() {
         );
     }
 
+    @Test
+    public void testFindPath_finiteUTurnCost() {
+        // turning to 1 at node 3 when coming from 0 is forbidden, but taking the full loop 3-4-2-3 is very
+        // expensive, so the best solution is to go straight to 4 and take a u-turn there
+        //   1
+        //   |
+        // 0-3-4
+        //   |/
+        //   2
+        graph.edge(0, 3, 100, false);
+        graph.edge(3, 4, 100, true);
+        graph.edge(4, 2, 500, false);
+        graph.edge(2, 3, 200, false);
+        graph.edge(3, 1, 100, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        addRestriction(0, 3, 1);
+        uTurnCosts = 60;
+        contractNodes(4);
+        checkShortcuts(
+                createShortcut(3, 2, 1, 2, 1, 2, 600),
+                createShortcut(3, 3, 1, 1, 1, 1, 260)
+        );
+    }
+
     @Test
     public void testNodeContraction_turnRestrictionAndLoop() {
         //  /\    /<-3
@@ -1364,16 +1382,13 @@ private void contractNodes(int... nodes) {
     }
 
     private EdgeBasedNodeContractor createNodeContractor() {
-        EdgeBasedNodeContractor nodeContractor = new EdgeBasedNodeContractor(chGraph, chTurnWeighting, new PMap());
+        PreparationWeighting preparationWeighting = new PreparationWeighting(weighting);
+        TurnWeighting turnWeighting = new TurnWeighting(preparationWeighting, turnCostExtension, uTurnCosts);
+        EdgeBasedNodeContractor nodeContractor = new EdgeBasedNodeContractor(chGraph, turnWeighting, new PMap());
         nodeContractor.initFromGraph();
         return nodeContractor;
     }
 
-    private double calcWeight(EdgeIteratorState edge1, EdgeIteratorState edge2) {
-        return turnWeighting.calcWeight(edge1, false, EdgeIterator.NO_EDGE) +
-                turnWeighting.calcWeight(edge2, false, edge1.getEdge());
-    }
-
     private void addRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode) {
         turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(true, 0));
     }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index bf4e8cdaee..784ba8c75b 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -26,12 +26,8 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -40,7 +36,7 @@
 
 import java.util.*;
 
-import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Routing.HEADING_PENALTY;
 import static org.junit.Assert.*;
 
@@ -55,8 +51,8 @@
     private final CarFlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = EncodingManager.create(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
-    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-    private final CHGraph lg = graph.getGraph(CHGraph.class);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(weighting)).create();
+    private final CHGraph lg = graph.getCHGraph();
     private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
 
     private NodeContractor createNodeContractor() {
@@ -184,20 +180,9 @@ public void testFindShortcuts_Roundabout() {
         graph.edge(6, 7, 1, true);
         graph.freeze();
 
-        CHEdgeIteratorState sc1to4 = lg.shortcut(1, 4);
-        sc1to4.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 2);
-        sc1to4.setDistance(2);
-        sc1to4.setSkippedEdges(iter1to3.getEdge(), iter3to4.getEdge());
-
-        CHEdgeIteratorState sc4to6 = lg.shortcut(4, 6);
-        sc4to6.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 2);
-        sc4to6.setDistance(2);
-        sc4to6.setSkippedEdges(iter4to5.getEdge(), iter5to6.getEdge());
-
-        CHEdgeIteratorState sc6to4 = lg.shortcut(6, 4);
-        sc6to4.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 3);
-        sc6to4.setDistance(3);
-        sc6to4.setSkippedEdges(iter6to8.getEdge(), iter8to4.getEdge());
+        int sc1to4 = lg.shortcut(1, 4, PrepareEncoder.getScDirMask(), 2, iter1to3.getEdge(), iter3to4.getEdge());
+        int sc4to6 = lg.shortcut(4, 6, PrepareEncoder.getScFwdDir(), 2, iter4to5.getEdge(), iter5to6.getEdge());
+        int sc6to4 = lg.shortcut(6, 4, PrepareEncoder.getScFwdDir(), 3, iter6to8.getEdge(), iter8to4.getEdge());
 
         setMaxLevelOnAllNodes();
 
@@ -221,8 +206,8 @@ public void testFindShortcuts_Roundabout() {
         nodeContractor.contractNode(4);
         checkShortcuts(manualSc1, manualSc2, manualSc3,
                 // there should be two different shortcuts for both directions!
-                expectedShortcut(1, 6, sc1to4, sc4to6, true, false),
-                expectedShortcut(6, 1, sc6to4, sc1to4, true, false)
+                expectedShortcut(1, 6, lg.getEdgeIteratorState(sc1to4, 4), lg.getEdgeIteratorState(sc4to6, 6), true, false),
+                expectedShortcut(6, 1, lg.getEdgeIteratorState(sc6to4, 4), lg.getEdgeIteratorState(sc1to4, 1), true, false)
         );
     }
 
@@ -352,8 +337,8 @@ public void testNodeContraction_shortcutWeightRounding() {
         CarFlagEncoder encoder = new CarFlagEncoder();
         EncodingManager encodingManager = EncodingManager.create(encoder);
         Weighting weighting = new FastestWeighting(encoder);
-        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-        CHGraph lg = graph.getGraph(CHGraph.class);
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(weighting)).create();
+        CHGraph lg = graph.getCHGraph();
         // 0 ------------> 4
         //  \             /
         //   1 --> 2 --> 3
@@ -390,8 +375,8 @@ public void testNodeContraction_preventUnnecessaryShortcutWithLoop() {
         CarFlagEncoder encoder = new CarFlagEncoder();
         EncodingManager encodingManager = EncodingManager.create(encoder);
         Weighting weighting = new FastestWeighting(encoder);
-        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-        CHGraph lg = graph.getGraph(CHGraph.class);
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(weighting)).create();
+        CHGraph lg = graph.getCHGraph();
         // 0 - 1 - 2 - 3
         // o           o
         graph.edge(0, 1, 1, true);
@@ -499,7 +484,7 @@ private void checkShortcuts(CHGraph chGraph, Shortcut... expectedShortcuts) {
         while (iter.next()) {
             if (iter.isShortcut()) {
                 given.add(new Shortcut(
-                        iter.getBaseNode(), iter.getAdjNode(), iter.getWeight(), iter.getDistance(),
+                        iter.getBaseNode(), iter.getAdjNode(), iter.getWeight(),
                         iter.get(SC_ACCESS), iter.getReverse(SC_ACCESS),
                         iter.getSkippedEdge1(), iter.getSkippedEdge2()));
             }
@@ -518,10 +503,17 @@ private void checkNoShortcuts(CHGraph chGraph) {
     private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState edge1, EdgeIteratorState edge2,
                                       boolean fwd, boolean bwd) {
         //todo: weight calculation might have to be adjusted for different encoders/weightings/reverse speed
-        double weight = weighting.calcWeight(edge1, false, EdgeIterator.NO_EDGE) +
-                weighting.calcWeight(edge2, false, EdgeIterator.NO_EDGE);
-        double distance = edge1.getDistance() + edge2.getDistance();
-        return new Shortcut(baseNode, adjNode, weight, distance, fwd, bwd, edge1.getEdge(), edge2.getEdge());
+        double weight1 = getWeight(edge1);
+        double weight2 = getWeight(edge2);
+        return new Shortcut(baseNode, adjNode, weight1 + weight2, fwd, bwd, edge1.getEdge(), edge2.getEdge());
+    }
+
+    private double getWeight(EdgeIteratorState edge) {
+        if (edge instanceof CHEdgeIteratorState) {
+            return ((CHEdgeIteratorState) edge).getWeight();
+        } else {
+            return weighting.calcWeight(edge, false, EdgeIterator.NO_EDGE);
+        }
     }
 
     private Set<Shortcut> setOf(Shortcut... shortcuts) {
@@ -547,17 +539,15 @@ private IgnoreNodeFilter createIgnoreNodeFilter(int node) {
         int baseNode;
         int adjNode;
         double weight;
-        double distance;
         boolean fwd;
         boolean bwd;
         int skipEdge1;
         int skipEdge2;
 
-        Shortcut(int baseNode, int adjNode, double weight, double distance, boolean fwd, boolean bwd, int skipEdge1, int skipEdge2) {
+        Shortcut(int baseNode, int adjNode, double weight, boolean fwd, boolean bwd, int skipEdge1, int skipEdge2) {
             this.baseNode = baseNode;
             this.adjNode = adjNode;
             this.weight = weight;
-            this.distance = distance;
             this.fwd = fwd;
             this.bwd = bwd;
             this.skipEdge1 = skipEdge1;
@@ -572,7 +562,6 @@ public boolean equals(Object obj) {
             return baseNode == shortcut.baseNode &&
                     adjNode == shortcut.adjNode &&
                     Double.compare(shortcut.weight, weight) == 0 &&
-                    Double.compare(shortcut.distance, distance) == 0 &&
                     fwd == shortcut.fwd &&
                     bwd == shortcut.bwd &&
                     skipEdge1 == shortcut.skipEdge1 &&
@@ -581,7 +570,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hash(baseNode, adjNode, weight, distance, fwd, bwd, skipEdge1, skipEdge2);
+            return Objects.hash(baseNode, adjNode, weight, fwd, bwd, skipEdge1, skipEdge2);
         }
 
         @Override
@@ -590,7 +579,6 @@ public String toString() {
                     "baseNode=" + baseNode +
                     ", adjNode=" + adjNode +
                     ", weight=" + weight +
-                    ", distance=" + distance +
                     ", fwd=" + fwd +
                     ", bwd=" + bwd +
                     ", skipEdge1=" + skipEdge1 +
diff --git a/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
index 68b1927fe8..3482316b12 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
@@ -11,15 +11,13 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 
 public class Path4CHTest {
@@ -35,8 +33,8 @@ public void init() {
         encoder = new MotorcycleFlagEncoder(5, 5, maxTurnCosts);
         EncodingManager em = EncodingManager.create(encoder);
         weighting = new FastestWeighting(encoder);
-        graph = new GraphBuilder(em).setEdgeBasedCH(true).setCHGraph(weighting).create();
-        chGraph = graph.getGraph(CHGraph.class);
+        graph = new GraphBuilder(em).setCHProfiles(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS)).create();
+        chGraph = graph.getCHGraph();
         turnCostExtension = (TurnCostExtension) graph.getExtension();
     }
 
@@ -60,10 +58,10 @@ public void shortcut_chain() {
         // we 'contract' the graph such that only a few shortcuts are created and that the fwd/bwd searches for the
         // 0-8 query meet at node 4 (make sure we include all three cases where turn cost times might come to play:
         // fwd/bwd search and meeting point)
-        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 0);
-        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 0);
-        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 0);
-        addShortcut(6, 8, 6, 7, 6, 7, 0.12, 2, 0);
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 0);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 0);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 0);
+        addShortcut(6, 8, 6, 7, 6, 7, 0.12, 0);
         setCHOrder(1, 3, 5, 7, 0, 8, 2, 6, 4);
 
         // going from 0 to 8 will create shortest path tree entries that follow the shortcuts.
@@ -107,18 +105,18 @@ public void paths_different_fwd_bwd_speeds() {
         addTurnCost(edge1, edge0, 1, 0);
 
         // shortcuts ->
-        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 5);
-        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 2);
-        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 4);
-        addShortcut(2, 6, 2, 5, 7, 8, 0.24, 4, 7);
-        addShortcut(0, 6, 0, 5, 6, 9, 0.36, 6, 12);
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 5);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 4);
+        addShortcut(2, 6, 2, 5, 7, 8, 0.24, 7);
+        addShortcut(0, 6, 0, 5, 6, 9, 0.36, 12);
 
         // shortcuts <-
-        addShortcut(6, 4, 5, 4, 5, 4, 0.24, 2, 3);
-        addShortcut(4, 2, 3, 2, 3, 2, 0.24, 2, 4);
-        addShortcut(2, 0, 1, 0, 1, 0, 0.24, 2, 0);
-        addShortcut(6, 2, 5, 2, 11, 12, 0.48, 4, 9);
-        addShortcut(6, 0, 5, 0, 14, 13, 0.60, 6, 10);
+        addShortcut(6, 4, 5, 4, 5, 4, 0.24, 3);
+        addShortcut(4, 2, 3, 2, 3, 2, 0.24, 4);
+        addShortcut(2, 0, 1, 0, 1, 0, 0.24, 0);
+        addShortcut(6, 2, 5, 2, 11, 12, 0.48, 9);
+        addShortcut(6, 0, 5, 0, 14, 13, 0.60, 10);
 
         // strictly it would be cleaner to manually build the SPT and extract the path, but for convenience we
         // use the routing algo to build it
@@ -142,9 +140,9 @@ private EdgeIteratorState getEdge(int from, int to) {
         return GHUtility.getEdge(graph, from, to);
     }
 
-    private void addShortcut(int from, int to, int origFirst, int origLast, int skip1, int skip2, double edgeWeight, double distance, int turnCost) {
+    private void addShortcut(int from, int to, int origFirst, int origLast, int skip1, int skip2, double edgeWeight, int turnCost) {
         double weight = edgeWeight + turnCost * 1000;
-        chGraph.shortcutEdgeBased(from, to, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+        chGraph.shortcutEdgeBased(from, to, PrepareEncoder.getScFwdDir(), weight, skip1, skip2, origFirst, origLast);
     }
 
     private void checkPath(int from, int to, double edgeWeight, int distance, int turnCostTime) {
@@ -157,7 +155,7 @@ private void checkPath(int from, int to, double edgeWeight, int distance, int tu
 
     private AbstractBidirectionEdgeCHNoSOD createAlgo() {
         TurnWeighting chTurnWeighting = new TurnWeighting(new PreparationWeighting(weighting), turnCostExtension);
-        CHGraph lg = graph.getGraph(CHGraph.class, weighting);
+        CHGraph lg = graph.getCHGraph();
         AbstractBidirectionEdgeCHNoSOD algo = new DijkstraBidirectionEdgeCHNoSOD(lg, chTurnWeighting);
         algo.setEdgeFilter(new LevelEdgeFilter(lg));
         return algo;
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 3e79f7c574..7f12a151ee 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -32,7 +32,7 @@
 
 import java.util.*;
 
-import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
@@ -125,7 +125,7 @@ GraphHopperStorage createGHStorage() {
     }
 
     GraphHopperStorage createGHStorage(Weighting w) {
-        return new GraphBuilder(encodingManager).setCHGraph(w).create();
+        return new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(w)).create();
     }
 
     GraphHopperStorage createExampleGraph() {
@@ -155,7 +155,7 @@ public void setUp() {
     @Test
     public void testReturnsCorrectWeighting() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
         assertSame(weighting, prepare.getWeighting());
@@ -164,7 +164,7 @@ public void testReturnsCorrectWeighting() {
     @Test
     public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         int old = lg.getEdges();
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
@@ -174,7 +174,7 @@ public void testAddShortcuts() {
     @Test
     public void testMoreComplexGraph() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initShortcutsGraph(lg);
         int oldCount = g.getAllEdges().length();
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
@@ -186,7 +186,7 @@ public void testMoreComplexGraph() {
     @Test
     public void testDirectedGraph() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.edge(5, 4, 3, false);
         g.edge(4, 5, 10, false);
         g.edge(2, 4, 1, false);
@@ -209,7 +209,7 @@ public void testDirectedGraph() {
     @Test
     public void testDirectedGraph2() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initDirected2(g);
         int oldCount = GHUtility.count(g.getAllEdges());
         assertEquals(19, oldCount);
@@ -283,7 +283,7 @@ void initRoundaboutGraph(Graph g) {
     @Test
     public void testRoundaboutUnpacking() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initRoundaboutGraph(g);
         int oldCount = g.getAllEdges().length();
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
@@ -309,34 +309,30 @@ void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
         EdgeIteratorState edgeState34 = g.edge(3, 4).setDistance(dist).setFlags(edgeFlags);
         EdgeIteratorState edgeState45 = g.edge(4, 5).setDistance(dist).setFlags(edgeFlags);
         EdgeIteratorState edgeState56 = g.edge(5, 6).setDistance(dist).setFlags(edgeFlags);
+        int oneDirFlags = PrepareEncoder.getScFwdDir();
 
         int tmpEdgeId = edgeState01.getEdge();
         ghStorage.freeze();
-        CHEdgeIteratorState sc0_2 = g.shortcut(0, 2);
         int x = EdgeIterator.NO_EDGE;
-        sc0_2.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x));
-        sc0_2.setDistance(2 * dist);
-        sc0_2.setSkippedEdges(tmpEdgeId, edgeState12.getEdge());
-        tmpEdgeId = sc0_2.getEdge();
-        CHEdgeIteratorState sc0_3 = g.shortcut(0, 3);
-        sc0_3.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_2.getWeight() + w.calcWeight(edgeState23, false, x));
-        sc0_3.setDistance(3 * dist);
-        sc0_3.setSkippedEdges(tmpEdgeId, edgeState23.getEdge());
-        tmpEdgeId = sc0_3.getEdge();
-        CHEdgeIteratorState sc0_4 = g.shortcut(0, 4);
-        sc0_4.setDistance(4);
-        sc0_4.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_3.getWeight() + w.calcWeight(edgeState34, false, x));
-        sc0_4.setSkippedEdges(tmpEdgeId, edgeState34.getEdge());
-        tmpEdgeId = sc0_4.getEdge();
-        CHEdgeIteratorState sc0_5 = g.shortcut(0, 5);
-        sc0_5.setDistance(5);
-        sc0_5.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_4.getWeight() + w.calcWeight(edgeState45, false, x));
-        sc0_5.setSkippedEdges(tmpEdgeId, edgeState45.getEdge());
-        tmpEdgeId = sc0_5.getEdge();
-        CHEdgeIteratorState sc0_6 = g.shortcut(0, 6);
-        sc0_6.setDistance(6);
-        sc0_6.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_5.getWeight() + w.calcWeight(edgeState56, false, x));
-        sc0_6.setSkippedEdges(tmpEdgeId, edgeState56.getEdge());
+        double weight = w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x);
+        int sc0_2 = g.shortcut(0, 2, oneDirFlags, w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x), tmpEdgeId, edgeState12.getEdge());
+
+        tmpEdgeId = sc0_2;
+        weight += w.calcWeight(edgeState23, false, x);
+        int sc0_3 = g.shortcut(0, 3, oneDirFlags, weight, tmpEdgeId, edgeState23.getEdge());
+
+        tmpEdgeId = sc0_3;
+        weight += w.calcWeight(edgeState34, false, x);
+        int sc0_4 = g.shortcut(0, 4, oneDirFlags, weight, tmpEdgeId, edgeState34.getEdge());
+
+        tmpEdgeId = sc0_4;
+        weight += w.calcWeight(edgeState45, false, x);
+        int sc0_5 = g.shortcut(0, 5, oneDirFlags, weight, tmpEdgeId, edgeState45.getEdge());
+
+        tmpEdgeId = sc0_5;
+        weight += w.calcWeight(edgeState56, false, x);
+        int sc0_6 = g.shortcut(0, 6, oneDirFlags, weight, tmpEdgeId, edgeState56.getEdge());
+
         g.setLevel(0, 10);
         g.setLevel(6, 9);
         g.setLevel(5, 8);
@@ -350,7 +346,7 @@ void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
     @Test
     public void testUnpackingOrder() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initUnpackingGraph(g, lg, weighting);
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
@@ -363,7 +359,7 @@ public void testUnpackingOrder() {
     @Test
     public void testUnpackingOrder_Fastest() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, lg, w);
 
@@ -378,7 +374,7 @@ public void testUnpackingOrder_Fastest() {
     @Test
     public void testDisconnects() {
         final GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         //            4
         //            v
         //            0
@@ -440,7 +436,7 @@ public void testStallOnDemandViaVirtuaNode_issue1574() {
         // use fastest weighting in this test to be able to fine-tune some weights via the speed (see below)
         Weighting fastestWeighting = new FastestWeighting(carEncoder);
         final GraphHopperStorage g = createGHStorage(fastestWeighting);
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         // the following graph reproduces the issue. note that we will use the node ids as ch levels, so there will
         // be a shortcut 3->2 visible at node 2 and another one 3->4 visible at node 3.
         // we will fine-tune the edge-speeds such that without the fix node 4 will be stalled and node 5 will not get
@@ -539,7 +535,7 @@ private EdgeIteratorState getEdge(Graph graph, int from, int to, boolean incomin
     @Test
     public void testCircleBug() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         //  /--1
         // -0--/
         //  |
@@ -560,7 +556,7 @@ public void testBug178() {
         //   \-<-/
         //
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.edge(1, 2, 1, false);
         g.edge(2, 1, 1, false);
 
@@ -623,17 +619,17 @@ public void testMultiplePreparationsIdenticalView() {
         EncodingManager tmpEncodingManager = EncodingManager.create(tmpCarEncoder, tmpBikeEncoder);
 
         // FastestWeighting would lead to different shortcuts due to different default speeds for bike and car
-        Weighting carWeighting = new ShortestWeighting(tmpCarEncoder);
-        Weighting bikeWeighting = new ShortestWeighting(tmpBikeEncoder);
+        CHProfile carProfile = CHProfile.nodeBased(new ShortestWeighting(tmpCarEncoder));
+        CHProfile bikeProfile = CHProfile.nodeBased(new ShortestWeighting(tmpBikeEncoder));
 
-        List<Weighting> chWeightings = Arrays.asList(carWeighting, bikeWeighting);
-        GraphHopperStorage ghStorage = new GraphHopperStorage(chWeightings, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
+        List<CHProfile> profiles = Arrays.asList(carProfile, bikeProfile);
+        GraphHopperStorage ghStorage = new GraphHopperStorage(profiles, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
         initShortcutsGraph(ghStorage);
 
         ghStorage.freeze();
 
-        for (Weighting w : chWeightings) {
-            checkPath(ghStorage, w, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
+        for (CHProfile p : profiles) {
+            checkPath(ghStorage, p, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         }
     }
 
@@ -643,20 +639,20 @@ public void testMultiplePreparationsDifferentView() {
         BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
         EncodingManager tmpEncodingManager = EncodingManager.create(tmpCarEncoder, tmpBikeEncoder);
 
-        Weighting carWeighting = new FastestWeighting(tmpCarEncoder);
-        Weighting bikeWeighting = new FastestWeighting(tmpBikeEncoder);
+        CHProfile carProfile = CHProfile.nodeBased(new FastestWeighting(tmpCarEncoder));
+        CHProfile bikeProfile = CHProfile.nodeBased(new FastestWeighting(tmpBikeEncoder));
 
-        List<Weighting> chWeightings = Arrays.asList(carWeighting, bikeWeighting);
-        GraphHopperStorage ghStorage = new GraphHopperStorage(chWeightings, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
+        List<CHProfile> profiles = Arrays.asList(carProfile, bikeProfile);
+        GraphHopperStorage ghStorage = new GraphHopperStorage(profiles, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
         initShortcutsGraph(ghStorage);
         EdgeIteratorState edge = GHUtility.getEdge(ghStorage, 9, 14).
                 set(tmpBikeEncoder.getAccessEnc(), false).setReverse(tmpBikeEncoder.getAccessEnc(), false);
 
         ghStorage.freeze();
 
-        checkPath(ghStorage, carWeighting, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
+        checkPath(ghStorage, carProfile, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         // detour around blocked 9,14
-        checkPath(ghStorage, bikeWeighting, 9, 5, IntArrayList.from(3, 10, 14, 16, 13, 12));
+        checkPath(ghStorage, bikeProfile, 9, 5, IntArrayList.from(3, 10, 14, 16, 13, 12));
     }
 
     @Test
@@ -664,10 +660,10 @@ public void testReusingNodeOrdering() {
         CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         MotorcycleFlagEncoder motorCycleEncoder = new MotorcycleFlagEncoder();
         EncodingManager em = EncodingManager.create(carFlagEncoder, motorCycleEncoder);
-        Weighting carWeighting = new FastestWeighting(carFlagEncoder);
-        Weighting motorCycleWeighting = new FastestWeighting(motorCycleEncoder);
+        CHProfile carProfile = CHProfile.nodeBased(new FastestWeighting(carFlagEncoder));
+        CHProfile motorCycleProfile = CHProfile.nodeBased(new FastestWeighting(motorCycleEncoder));
         Directory dir = new RAMDirectory();
-        GraphHopperStorage ghStorage = new GraphHopperStorage(Arrays.asList(carWeighting, motorCycleWeighting), dir, em, false, new GraphExtension.NoOpExtension());
+        GraphHopperStorage ghStorage = new GraphHopperStorage(Arrays.asList(carProfile, motorCycleProfile), dir, em, false, new GraphExtension.NoOpExtension());
         ghStorage.create(1000);
 
         int numNodes = 5_000;
@@ -679,25 +675,24 @@ public void testReusingNodeOrdering() {
 
         // create CH for cars
         StopWatch sw = new StopWatch().start();
-        CHGraph carCH = ghStorage.getGraph(CHGraphImpl.class, carWeighting);
-        TraversalMode traversalMode = TraversalMode.NODE_BASED;
-        PrepareContractionHierarchies carPch = new PrepareContractionHierarchies(carCH, carWeighting, traversalMode);
+        CHGraph carCH = ghStorage.getCHGraph(carProfile);
+        PrepareContractionHierarchies carPch = new PrepareContractionHierarchies(carCH);
         carPch.doWork();
         long timeCar = sw.stop().getMillis();
 
         // create CH for motorcycles, re-use car contraction order
         // this speeds up contraction significantly, but can lead to slower queries
         sw = new StopWatch().start();
-        CHGraph motorCycleCH = ghStorage.getGraph(CHGraphImpl.class, motorCycleWeighting);
+        CHGraph motorCycleCH = ghStorage.getCHGraph(motorCycleProfile);
         NodeOrderingProvider nodeOrderingProvider = carCH.getNodeOrderingProvider();
-        PrepareContractionHierarchies motorCyclePch = new PrepareContractionHierarchies(motorCycleCH, motorCycleWeighting, traversalMode)
+        PrepareContractionHierarchies motorCyclePch = new PrepareContractionHierarchies(motorCycleCH)
                 .useFixedNodeOrdering(nodeOrderingProvider);
         motorCyclePch.doWork();
 
         // run a few sample queries to check correctness
         for (int i = 0; i < numQueries; ++i) {
-            Dijkstra dijkstra = new Dijkstra(ghStorage, motorCycleWeighting, traversalMode);
-            RoutingAlgorithm chAlgo = motorCyclePch.createAlgo(motorCycleCH, AlgorithmOptions.start().weighting(motorCycleWeighting).build());
+            Dijkstra dijkstra = new Dijkstra(ghStorage, motorCycleProfile.getWeighting(), TraversalMode.NODE_BASED);
+            RoutingAlgorithm chAlgo = motorCyclePch.createAlgo(motorCycleCH, AlgorithmOptions.start().weighting(motorCycleProfile.getWeighting()).build());
 
             int from = rnd.nextInt(numNodes);
             int to = rnd.nextInt(numNodes);
@@ -710,15 +705,15 @@ public void testReusingNodeOrdering() {
         assertTrue("reusing node ordering should speed up ch contraction", timeMotorCycle < 0.5 * timeCar);
     }
 
-    void checkPath(GraphHopperStorage g, Weighting w, int expShortcuts, double expDistance, IntIndexedContainer expNodes) {
-        CHGraph lg = g.getGraph(CHGraph.class, w);
-        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg, w);
+    void checkPath(GraphHopperStorage g, CHProfile p, int expShortcuts, double expDistance, IntIndexedContainer expNodes) {
+        CHGraph lg = g.getCHGraph(p);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg, p);
         prepare.doWork();
-        assertEquals(w.toString(), expShortcuts, prepare.getShortcuts());
-        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, w, tMode));
-        Path p = algo.calcPath(3, 12);
-        assertEquals(w.toString(), expDistance, p.getDistance(), 1e-5);
-        assertEquals(w.toString(), expNodes, p.calcNodes());
+        assertEquals(p.toString(), expShortcuts, prepare.getShortcuts());
+        RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, p.getWeighting(), tMode));
+        Path path = algo.calcPath(3, 12);
+        assertEquals(path.toString(), expDistance, path.getDistance(), 1e-5);
+        assertEquals(path.toString(), expNodes, path.calcNodes());
     }
 
     private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphHopperStorage g, CHGraph lg) {
@@ -726,8 +721,12 @@ private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphH
     }
 
     private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphHopperStorage g, CHGraph lg, Weighting w) {
+        return createPrepareContractionHierarchies(g, lg, CHProfile.nodeBased(w));
+    }
+
+    private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphHopperStorage g, CHGraph lg, CHProfile p) {
         g.freeze();
-        return new PrepareContractionHierarchies(lg, w, tMode);
+        return new PrepareContractionHierarchies(lg);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java b/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java
index 245c17cc1a..9c315cf52d 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java
@@ -23,15 +23,13 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.PMap;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -47,10 +45,10 @@ public void setup() {
         EncodingManager encodingManager = EncodingManager.create(encoder);
         Weighting weighting = new ShortestWeighting(encoder);
         PreparationWeighting preparationWeighting = new PreparationWeighting(weighting);
-        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS)).create();
         TurnCostExtension turnCostExtension = (TurnCostExtension) graph.getExtension();
         chTurnWeighting = new TurnWeighting(preparationWeighting, turnCostExtension);
-        chGraph = graph.getGraph(CHGraph.class);
+        chGraph = graph.getCHGraph();
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java b/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
index 35116bc627..a238715a83 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
@@ -3,7 +3,6 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.GraphExtension;
@@ -15,9 +14,7 @@
 
 import java.util.Arrays;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 
 public class LMAlgoFactoryDecoratorTest {
@@ -55,5 +52,10 @@ public void testPrepareWeightingNo() {
         dec = new LMAlgoFactoryDecorator();
         dec.init(args);
         assertFalse(dec.isEnabled());
+
+        args.put(Parameters.Landmark.PREPARE + "weightings", "false");
+        dec = new LMAlgoFactoryDecorator();
+        dec.init(args);
+        assertFalse(dec.isEnabled());
     }
 }
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
index 41d97b5e61..4a9fa9c3e3 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
@@ -87,7 +87,7 @@ public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevO
     public void testSetGetWeight() {
         ghStorage.edge(0, 1, 40, true);
         Directory dir = new RAMDirectory();
-        DataAccess da = dir.find("landmarks_fastest_car_node");
+        DataAccess da = dir.find("landmarks_fastest_car");
         da.create(2000);
 
         LandmarkStorage lms = new LandmarkStorage(ghStorage, dir, new FastestWeighting(encoder), 4).
diff --git a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
index def9c2eea1..33c6ee0e3c 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
@@ -40,6 +40,7 @@
 import java.util.List;
 import java.util.Random;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -87,7 +88,7 @@ public void testLandmarkStorageAndRouting() {
                 if (hIndex + 1 < height)
                     graph.edge(node, node + width).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, speed);
 
-                AbstractRoutingAlgorithmTester.updateDistancesFor(graph, node, -hIndex / 50.0, wIndex / 50.0);
+                updateDistancesFor(graph, node, -hIndex / 50.0, wIndex / 50.0);
             }
         }
         Directory dir = new RAMDirectory();
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 57d62929d4..9b26da4bd2 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -39,7 +39,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.assertEquals;
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 377ac98d56..04adb88b84 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.*;
@@ -651,4 +652,34 @@ public void testIssue_1256() {
         assertEquals(2.5, encoder.getFerrySpeed(way), .1);
         assertEquals(.5, lowFactorCar.getFerrySpeed(way), .1);
     }
+
+    @Test
+    public void testAcceptsTurnRelation() {
+        List<String> vehicleTypesExcept = new ArrayList<>();
+        OSMTurnRelation osmTurnRelation = new OSMTurnRelation(1, 1, 1, OSMTurnRelation.Type.NOT);
+        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
+
+        vehicleTypesExcept.add("bus");
+        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
+
+        vehicleTypesExcept.clear();
+        vehicleTypesExcept.add("vehicle");
+        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
+
+        vehicleTypesExcept.clear();
+        vehicleTypesExcept.add("motor_vehicle");
+        vehicleTypesExcept.add("vehicle");
+        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
+
+        vehicleTypesExcept.clear();
+        osmTurnRelation.setVehicleTypeRestricted("bus");
+        osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+        assertFalse(encoder.acceptsTurnRelation(osmTurnRelation));
+
+        osmTurnRelation.setVehicleTypeRestricted("vehicle");
+        assertTrue(encoder.acceptsTurnRelation(osmTurnRelation));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index 7b80efa42d..e0b17c6fb7 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -1,9 +1,33 @@
 package com.graphhopper.routing.util;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+import org.junit.Test;
+
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.profiles.*;
-import com.graphhopper.routing.util.parsers.*;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.Country;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
+import com.graphhopper.routing.profiles.MaxSpeed;
+import com.graphhopper.routing.profiles.RoadAccess;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.routing.profiles.Surface;
+import com.graphhopper.routing.util.parsers.OSMMaxSpeedParser;
+import com.graphhopper.routing.util.parsers.OSMRoadAccessParser;
+import com.graphhopper.routing.util.parsers.OSMRoadClassParser;
+import com.graphhopper.routing.util.parsers.OSMRoadEnvironmentParser;
+import com.graphhopper.routing.util.parsers.OSMSurfaceParser;
+import com.graphhopper.routing.util.parsers.SpatialRuleParser;
 import com.graphhopper.routing.util.spatialrules.SpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
 import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
@@ -17,12 +41,6 @@
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.Collections;
-
-import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
@@ -39,8 +57,6 @@
     private final DecimalEncodedValue carMaxSpeedEnc;
     private final EncodingManager encodingManager;
 
-    private final double DELTA = 0.1;
-
     public DataFlagEncoderTest() {
         properties = new PMap();
         encoder = new DataFlagEncoder(properties);
@@ -301,59 +317,6 @@ public void acceptWay() {
         assertTrue(encoder.getAccess(osmWay).canSkip());
     }
 
-    @Test
-    public void stringToMeter() {
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5m"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5 m"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5   m"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5 meter"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("4 ft 11 in"), DELTA);
-        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("4'11''"), DELTA);
-
-
-        assertEquals(3, OSMMaxWidthParser.stringToMeter("3 m."), DELTA);
-        assertEquals(3, OSMMaxWidthParser.stringToMeter("3meters"), DELTA);
-        assertEquals(0.8 * 3, OSMMaxWidthParser.stringToMeter("~3"), DELTA);
-        assertEquals(3 * 0.8, OSMMaxWidthParser.stringToMeter("3 m approx"), DELTA);
-
-        // 2.743 + 0.178
-        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9 ft 7in"), DELTA);
-        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9'7\""), DELTA);
-        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9'7''"), DELTA);
-        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9' 7\""), DELTA);
-
-        assertEquals(2.743, OSMMaxWidthParser.stringToMeter("9'"), DELTA);
-        assertEquals(2.743, OSMMaxWidthParser.stringToMeter("9 feet"), DELTA);
-    }
-
-    @Test(expected = NumberFormatException.class)
-    public void stringToMeterException() {
-        // Unexpected values
-        OSMMaxWidthParser.stringToMeter("height limit 1.5m");
-    }
-
-    @Test
-    public void stringToTons() {
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5"), DELTA);
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 t"), DELTA);
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5   t"), DELTA);
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 tons"), DELTA);
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 ton"), DELTA);
-        assertEquals(1.5, OSMMaxWeightParser.stringToTons("3306.9 lbs"), DELTA);
-        assertEquals(3, OSMMaxWeightParser.stringToTons("3 T"), DELTA);
-        assertEquals(3, OSMMaxWeightParser.stringToTons("3ton"), DELTA);
-
-        // maximum gross weight
-        assertEquals(6, OSMMaxWeightParser.stringToTons("6t mgw"), DELTA);
-    }
-
-    @Test(expected = NumberFormatException.class)
-    public void stringToTonsException() {
-        // Unexpected values
-        OSMMaxWeightParser.stringToTons("weight limit 1.5t");
-    }
-
     @Test
     public void testSpatialId() {
         final GermanySpatialRule germany = new GermanySpatialRule();
@@ -411,11 +374,11 @@ public BBox getBounds() {
         EdgeIteratorState e2 = graph.edge(0, 2, 1, true);
         EdgeIteratorState e3 = graph.edge(0, 3, 1, true);
         EdgeIteratorState e4 = graph.edge(0, 4, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, -0.01, -0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, -0.01, -0.01);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 2, -0.01, -0.01);
+        updateDistancesFor(graph, 3, 0.01, 0.01);
+        updateDistancesFor(graph, 4, -0.01, -0.01);
 
         ReaderWay way = new ReaderWay(27l);
         way.setTag("highway", "track");
diff --git a/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java
index cec30e2f2d..2e891baa02 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java
@@ -23,21 +23,22 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.CHProfile;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.CHEdgeExplorer;
 import com.graphhopper.util.CHEdgeIterator;
-import com.graphhopper.util.CHEdgeIteratorState;
 import org.junit.Test;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 
 public class DefaultEdgeFilterTest {
     private final CarFlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = EncodingManager.create(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
-    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
-    private final CHGraph chGraph = graph.getGraph(CHGraph.class);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.edgeBased(weighting, INFINITE_U_TURN_COSTS)).create();
+    private final CHGraph chGraph = graph.getCHGraph();
 
     @Test
     public void testAccept_fwdLoopShortcut_acceptedByInExplorer() {
@@ -68,10 +69,9 @@ public void testAccept_fwdLoopShortcut_acceptedByInExplorer() {
         assertEquals("Wrong incoming edges", IntHashSet.from(2, 3), inEdges);
     }
 
-    private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int firstOrigEdge, int lastOrigEdge) {
-        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
-        shortcut.setFlagsAndWeight(fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir(), 0);
-        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge);
+    private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int skip1, int skip2) {
+        int accessFlags = fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir();
+        chGraph.shortcut(from, to, accessFlags, 5, skip1, skip2);
     }
 
 }
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index cfdd50df7e..f7281ab182 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -17,15 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.profiles.Roundabout;
 import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.BitUtil;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 
 import static org.junit.Assert.*;
 
@@ -33,8 +32,6 @@
  * @author Peter Karich
  */
 public class EncodingManagerTest {
-    @Rule
-    public ExpectedException thrown = ExpectedException.none();
 
     @Test
     public void testCompatibility() {
@@ -48,19 +45,20 @@ public void testCompatibility() {
         assertNotEquals(car.hashCode(), foot.hashCode());
 
         FootFlagEncoder foot2 = new FootFlagEncoder();
-        EncodingManager manager2 = EncodingManager.create(foot2);
+        EncodingManager.create(foot2);
         assertNotEquals(foot, foot2);
         assertNotEquals(foot.hashCode(), foot2.hashCode());
 
         FootFlagEncoder foot3 = new FootFlagEncoder();
-        EncodingManager manager3 = EncodingManager.create(foot3);
+        EncodingManager.create(foot3);
         assertEquals(foot3, foot2);
         assertEquals(foot3.hashCode(), foot2.hashCode());
 
         try {
             EncodingManager.create("car,car");
-            assertTrue("do not allow duplicate flag encoders", false);
+            fail("there should have been an exception, do not allow duplicate flag encoders");
         } catch (Exception ex) {
+            // ok
         }
     }
 
@@ -71,25 +69,19 @@ public void testEncoderAcceptNoException() {
         assertFalse(manager.hasEncoder("foot"));
     }
 
-    @Test
-    public void testEncoderWithWrongVersionIsRejected() {
-        thrown.expect(IllegalArgumentException.class);
-        EncodingManager manager = EncodingManager.create("car|version=0");
-    }
-
     @Test
     public void testWrongEncoders() {
         try {
             FootFlagEncoder foot = new FootFlagEncoder();
             EncodingManager.create(foot, foot);
-            assertTrue(false);
+            fail("There should have been an exception");
         } catch (Exception ex) {
             assertEquals("You must not register a FlagEncoder (foot) twice!", ex.getMessage());
         }
 
         try {
             EncodingManager.create(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
-            assertTrue(false);
+            fail("There should have been an exception");
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting 36 bits, more than 32 bits of edge flags"));
         }
@@ -113,6 +105,14 @@ protected String getPropertiesString() {
                 return "my_properties";
             }
 
+            @Override
+            public boolean acceptsTurnRelation(OSMTurnRelation relation) {
+                if (relation.isVehicleTypeConcernedByTurnRestriction(restrictions)) {
+                    return true;
+                }
+                return false;
+            }
+
             @Override
             public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
                 return 0;
diff --git a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
index 81dfa60b0f..4171b36e12 100644
--- a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
@@ -19,10 +19,10 @@
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -56,7 +56,7 @@ public void testAccept() {
         edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertTrue(edgeFilter.accept(edge));
 
-        edgeFilter = createNameSimilarityEdgeFilter("Johannesstrae, 99636, Rastenberg, Deutschland");
+        edgeFilter = createNameSimilarityEdgeFilter("Johannesstrae, Rastenberg, Deutschland");
         edge = createTestEdgeIterator("Laufamholzstrae, ST1333");
         assertFalse(edgeFilter.accept(edge));
 
@@ -104,6 +104,7 @@ public void testAcceptFromGoogleMapsGeocoding() {
 
         assertTrue(createNameSimilarityEdgeFilter("Main Rd").accept(createTestEdgeIterator("Main Road")));
         assertTrue(createNameSimilarityEdgeFilter("Main Road").accept(createTestEdgeIterator("Main Rd")));
+        assertTrue(createNameSimilarityEdgeFilter("Main Rd").accept(createTestEdgeIterator("Main Road, New York")));
 
         assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point")));
         assertTrue(createNameSimilarityEdgeFilter("Cape Point Rd").accept(createTestEdgeIterator("Cape Point Road")));
@@ -131,13 +132,30 @@ public void testWithDash() {
         assertFalse(createNameSimilarityEdgeFilter("Potsdamer Str.").accept(edge));
     }
 
-    @Ignore
-    public void testThatShouldSucceed() {
-        // Google Maps vs OSM @ 32.121435,-110.857969
-        assertTrue(createNameSimilarityEdgeFilter("S Wilmot Rd").accept(createTestEdgeIterator("South Wilmot Road")));
+    @Test
+    public void normalization() {
+        assertEquals("northderby", createNameSimilarityEdgeFilter("North Derby Lane").getNormalizedPointHint());
+
+        // do not remove the number as it is a significant part of the name, especially in the US
+        assertEquals("28north", createNameSimilarityEdgeFilter("I-28 N").getNormalizedPointHint());
+        assertEquals("28north", createNameSimilarityEdgeFilter(" I-28    N  ").getNormalizedPointHint());
+        assertEquals("south23rd", createNameSimilarityEdgeFilter("S 23rd St").getNormalizedPointHint());
+        assertEquals("66", createNameSimilarityEdgeFilter("Route 66").getNormalizedPointHint());
+        assertEquals("fayettecounty1", createNameSimilarityEdgeFilter("Fayette County Rd 1").getNormalizedPointHint());
+
+        // too short, except when numbers
+        assertEquals("112", createNameSimilarityEdgeFilter("A B C 1 12").getNormalizedPointHint());
+    }
+
+    @Test
+    public void testServiceMix() {
+        assertTrue(createNameSimilarityEdgeFilter("North Derby Lane").accept(createTestEdgeIterator("N Derby Ln")));
+        assertTrue(createNameSimilarityEdgeFilter("N Derby Ln").accept(createTestEdgeIterator("North Derby Lane")));
+
+        assertFalse(createNameSimilarityEdgeFilter("North Derby Lane").accept(createTestEdgeIterator("I-29 N")));
+        assertFalse(createNameSimilarityEdgeFilter("I-29 N").accept(createTestEdgeIterator("North Derby Lane")));
 
-        // @ 37.307774,13.581259
-        assertTrue(createNameSimilarityEdgeFilter("Via Manzoni").accept(createTestEdgeIterator("Via Alessandro Manzoni")));
+        assertTrue(createNameSimilarityEdgeFilter("George Street").accept(createTestEdgeIterator("George St")));
     }
 
     /**
@@ -174,13 +192,13 @@ public void testAcceptWithTypos() {
 //        assertTrue(edgeFilter.accept(edge));
     }
 
-    private NameSimilarityEdgeFilter createNameSimilarityEdgeFilter(String s) {
+    private NameSimilarityEdgeFilter createNameSimilarityEdgeFilter(String pointHint) {
         return new NameSimilarityEdgeFilter(new EdgeFilter() {
             @Override
             public boolean accept(EdgeIteratorState edgeState) {
                 return true;
             }
-        }, s);
+        }, pointHint);
     }
 
     private EdgeIteratorState createTestEdgeIterator(final String name) {
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java
new file mode 100644
index 0000000000..d5b76a70d9
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxAxleLoadParserTest.java
@@ -0,0 +1,69 @@
+package com.graphhopper.routing.util.parsers;
+
+import static com.graphhopper.routing.util.EncodingManager.Access.WAY;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.MaxAxleLoad;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMMaxAxleLoadParserTest {
+
+    private EncodingManager em;
+    private DecimalEncodedValue malEnc;
+    private OSMMaxAxleLoadParser parser;
+
+    @Before
+    public void setUp() {
+        parser = new OSMMaxAxleLoadParser();
+        em = new EncodingManager.Builder(4).add(parser).build();
+        malEnc = em.getDecimalEncodedValue(MaxAxleLoad.KEY);
+    }
+
+    @Test
+    public void testSimpleTags() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxaxleload", "11.5");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(11.5, malEnc.getDecimal(false, intsRef), .01);
+
+        // if value is beyond the maximum then do not use infinity instead fallback to more restrictive maximum
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxaxleload", "80");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(malEnc.getMaxDecimal(), malEnc.getDecimal(false, intsRef), .01);
+    }
+
+    @Test
+    public void testRounding() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxaxleload", "4.8");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(5.0, malEnc.getDecimal(false, intsRef), .01);
+        
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxaxleload", "3.6");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(3.5, malEnc.getDecimal(false, intsRef), .01);
+        
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxaxleload", "2.4");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(2.5, malEnc.getDecimal(false, intsRef), .01);
+    }
+    
+    @Test
+    public void testNoLimit() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Double.POSITIVE_INFINITY, malEnc.getDecimal(false, intsRef), .01);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
index f6cc675a55..94249da5ec 100644
--- a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
@@ -36,6 +36,18 @@ public void testSimpleTags() {
         readerWay.setTag("toll:hgv", "yes");
         parser.handleWayTags(intsRef, readerWay, WAY, 0);
         assertEquals(Toll.HGV, tollEnc.getEnum(false, intsRef));
+        
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("toll:N2", "yes");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.HGV, tollEnc.getEnum(false, intsRef));
+        
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("toll:N3", "yes");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.HGV, tollEnc.getEnum(false, intsRef));
 
         intsRef = em.createEdgeFlags();
         readerWay.setTag("highway", "primary");
@@ -47,6 +59,8 @@ public void testSimpleTags() {
         readerWay.setTag("highway", "primary");
         readerWay.setTag("toll", "yes");
         readerWay.setTag("toll:hgv", "yes");
+        readerWay.setTag("toll:N2", "yes");
+        readerWay.setTag("toll:N3", "yes");
         parser.handleWayTags(intsRef, readerWay, WAY, 0);
         assertEquals(Toll.ALL, tollEnc.getEnum(false, intsRef));
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java
new file mode 100644
index 0000000000..eefc29332d
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTrackTypeParserTest.java
@@ -0,0 +1,73 @@
+package com.graphhopper.routing.util.parsers;
+
+import static com.graphhopper.routing.util.EncodingManager.Access.WAY;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.TrackType;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+public class OSMTrackTypeParserTest {
+
+    private EncodingManager em;
+    private EnumEncodedValue<TrackType> ttEnc;
+    private OSMTrackTypeParser parser;
+
+    @Before
+    public void setUp() {
+        parser = new OSMTrackTypeParser();
+        em = new EncodingManager.Builder(4).add(parser).build();
+        ttEnc = em.getEnumEncodedValue(TrackType.KEY, TrackType.class);
+    }
+
+    @Test
+    public void testSimpleTags() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "grade1");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.GRADE1, ttEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "grade2");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.GRADE2, ttEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "grade3");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.GRADE3, ttEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "grade4");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.GRADE4, ttEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "grade5");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.GRADE5, ttEnc.getEnum(false, intsRef));
+    }
+
+    @Test
+    public void testUnkownValue() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("tracktype", "unknownstuff");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.OTHER, ttEnc.getEnum(false, intsRef));
+    }
+
+    @Test
+    public void testNoNPE() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(TrackType.OTHER, ttEnc.getEnum(false, intsRef));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java
new file mode 100644
index 0000000000..916249b18f
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMValueExtractorTest.java
@@ -0,0 +1,65 @@
+package com.graphhopper.routing.util.parsers;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import com.graphhopper.routing.util.parsers.helpers.OSMValueExtractor;
+
+public class OSMValueExtractorTest {
+    
+    private final double DELTA = 0.1;
+
+    @Test
+    public void stringToTons() {
+        assertEquals(1.5, OSMValueExtractor.stringToTons("1.5"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToTons("1.5 t"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToTons("1.5   t"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToTons("1.5 tons"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToTons("1.5 ton"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToTons("3306.9 lbs"), DELTA);
+        assertEquals(3, OSMValueExtractor.stringToTons("3 T"), DELTA);
+        assertEquals(3, OSMValueExtractor.stringToTons("3ton"), DELTA);
+
+        // maximum gross weight
+        assertEquals(6, OSMValueExtractor.stringToTons("6t mgw"), DELTA);
+    }
+
+    @Test(expected = NumberFormatException.class)
+    public void stringToTonsException() {
+        // Unexpected values
+        OSMValueExtractor.stringToTons("weight limit 1.5t");
+    }
+
+    @Test
+    public void stringToMeter() {
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5m"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5 m"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5   m"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("1.5 meter"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("4 ft 11 in"), DELTA);
+        assertEquals(1.5, OSMValueExtractor.stringToMeter("4'11''"), DELTA);
+
+
+        assertEquals(3, OSMValueExtractor.stringToMeter("3 m."), DELTA);
+        assertEquals(3, OSMValueExtractor.stringToMeter("3meters"), DELTA);
+        assertEquals(0.8 * 3, OSMValueExtractor.stringToMeter("~3"), DELTA);
+        assertEquals(3 * 0.8, OSMValueExtractor.stringToMeter("3 m approx"), DELTA);
+
+        // 2.743 + 0.178
+        assertEquals(2.921, OSMValueExtractor.stringToMeter("9 ft 7in"), DELTA);
+        assertEquals(2.921, OSMValueExtractor.stringToMeter("9'7\""), DELTA);
+        assertEquals(2.921, OSMValueExtractor.stringToMeter("9'7''"), DELTA);
+        assertEquals(2.921, OSMValueExtractor.stringToMeter("9' 7\""), DELTA);
+
+        assertEquals(2.743, OSMValueExtractor.stringToMeter("9'"), DELTA);
+        assertEquals(2.743, OSMValueExtractor.stringToMeter("9 feet"), DELTA);
+    }
+
+    @Test(expected = NumberFormatException.class)
+    public void stringToMeterException() {
+        // Unexpected values
+        OSMValueExtractor.stringToMeter("height limit 1.5m");
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
index d9f9cafefa..2a28ef42f3 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
@@ -1,6 +1,5 @@
 package com.graphhopper.routing.weighting;
 
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -15,6 +14,7 @@
 
 import java.util.Arrays;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 
 public class BlockAreaWeightingTest {
@@ -30,8 +30,8 @@ public void setUp() {
         graph = new GraphBuilder(em).create();
         // 0-1
         graph.edge(0, 1, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java
new file mode 100644
index 0000000000..35fb14f139
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/weighting/DirectedRoutingTest.java
@@ -0,0 +1,329 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.Repeat;
+import com.graphhopper.RepeatRule;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.lm.PrepareLandmarks;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.*;
+
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * This test makes sure the different bidirectional routing algorithms correctly implement restrictions of the source/
+ * target edges, by comparing with {@link DijkstraBidirectionRef}
+ *
+ * @author easbar
+ * @see DirectedBidirectionalDijkstraTest
+ */
+@RunWith(Parameterized.class)
+public class DirectedRoutingTest {
+    private final Algo algo;
+    private final int uTurnCosts;
+    private final boolean prepareCH;
+    private final boolean prepareLM;
+    private Directory dir;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private CarFlagEncoder encoder;
+    private TurnCostExtension turnCostExtension;
+    private int maxTurnCosts;
+    private Weighting weighting;
+    private EncodingManager encodingManager;
+    private PrepareContractionHierarchies pch;
+    private PrepareLandmarks lm;
+
+    @Rule
+    public RepeatRule repeatRule = new RepeatRule();
+
+    @Parameterized.Parameters(name = "{0}, u-turn-costs: {1}")
+    public static Collection<Object[]> params() {
+        return Arrays.asList(new Object[][]{
+                {Algo.ASTAR, INFINITE_U_TURN_COSTS, false, false},
+                {Algo.CH_ASTAR, INFINITE_U_TURN_COSTS, true, false},
+                {Algo.CH_DIJKSTRA, INFINITE_U_TURN_COSTS, true, false},
+                // todo: yields warnings and fails, see #1665, #1687
+//                {Algo.LM, INFINITE_UTURN_COSTS, false, true}
+                {Algo.ASTAR, 40, false, false},
+                {Algo.CH_ASTAR, 40, true, false},
+                {Algo.CH_DIJKSTRA, 40, true, false},
+                // todo: yields warnings and fails, see #1665, 1687
+//                {Algo.LM, 40, false, true}
+                // todo: add AlternativeRoute ?
+        });
+    }
+
+    private enum Algo {
+        ASTAR,
+        CH_ASTAR,
+        CH_DIJKSTRA,
+        LM
+    }
+
+    public DirectedRoutingTest(Algo algo, int uTurnCosts, boolean prepareCH, boolean prepareLM) {
+        this.algo = algo;
+        this.uTurnCosts = uTurnCosts;
+        this.prepareCH = prepareCH;
+        this.prepareLM = prepareLM;
+    }
+
+    @Before
+    public void init() {
+        dir = new RAMDirectory();
+        maxTurnCosts = 10;
+        // todonow: make this work with speed_both_directions=true!
+        encoder = new CarFlagEncoder(5, 5, maxTurnCosts);
+        encodingManager = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        turnCostExtension = new TurnCostExtension();
+        graph = createGraph();
+        chGraph = graph.getCHGraph();
+    }
+
+    private void preProcessGraph() {
+        graph.freeze();
+        if (!prepareCH && !prepareLM) {
+            return;
+        }
+        if (prepareCH) {
+            pch = new PrepareContractionHierarchies(chGraph);
+            pch.doWork();
+        }
+        if (prepareLM) {
+            lm = new PrepareLandmarks(dir, graph, weighting, 16, 8);
+            lm.setMaximumWeight(1000);
+            lm.doWork();
+        }
+    }
+
+    private AbstractBidirAlgo createAlgo() {
+        return createAlgo(prepareCH ? chGraph : graph);
+    }
+
+    private AbstractBidirAlgo createAlgo(Graph graph) {
+        switch (algo) {
+            case ASTAR:
+                return new AStarBidirection(graph, createTurnWeighting(graph), TraversalMode.EDGE_BASED);
+            case CH_DIJKSTRA:
+                return (AbstractBidirAlgo) pch.createAlgo(graph, AlgorithmOptions.start().weighting(weighting).algorithm(DIJKSTRA_BI).build());
+            case CH_ASTAR:
+                return (AbstractBidirAlgo) pch.createAlgo(graph, AlgorithmOptions.start().weighting(weighting).algorithm(ASTAR_BI).build());
+            case LM:
+                AStarBidirection astarbi = new AStarBidirection(graph, createTurnWeighting(graph), TraversalMode.EDGE_BASED);
+                return (AbstractBidirAlgo) lm.getDecoratedAlgorithm(graph, astarbi, AlgorithmOptions.start().build());
+            default:
+                throw new IllegalArgumentException("unknown algo " + algo);
+        }
+    }
+
+    private TurnWeighting createTurnWeighting(Graph g) {
+        return new TurnWeighting(weighting, (TurnCostExtension) g.getExtension(), uTurnCosts);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void randomGraph() {
+        final long seed = System.nanoTime();
+        System.out.println("random Graph seed: " + seed);
+        final int numQueries = 50;
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(graph, rnd, 100, 2.2, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.8, 0.8);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, turnCostExtension);
+//        GHUtility.printGraphForUnitTest(graph, encoder);
+        preProcessGraph();
+        List<String> strictViolations = new ArrayList<>();
+        for (int i = 0; i < numQueries; i++) {
+            int source = getRandom(rnd);
+            int target = getRandom(rnd);
+            int sourceOutEdge = getSourceOutEdge(rnd, source, graph);
+            int targetInEdge = getTargetInEdge(rnd, target, graph);
+//            System.out.println("source: " + source + ", target: " + target + ", sourceOutEdge: " + sourceOutEdge + ", targetInEdge: " + targetInEdge);
+            Path refPath = new DijkstraBidirectionRef(graph, createTurnWeighting(graph), TraversalMode.EDGE_BASED)
+                    .calcPath(source, target, sourceOutEdge, targetInEdge);
+            Path path = createAlgo()
+                    .calcPath(source, target, sourceOutEdge, targetInEdge);
+            // do not check nodes, because there can be ambiguity when there are zero weight loops
+            strictViolations.addAll(comparePaths(refPath, path, source, target, false));
+        }
+        // sometimes there are multiple best paths with different distance/time, if this happens too often something
+        // is wrong and we fail
+        if (strictViolations.size() > Math.max(1, 0.05 * numQueries)) {
+            for (String strictViolation : strictViolations) {
+                System.out.println("strict violation: " + strictViolation);
+            }
+            fail("Too many strict violations: " + strictViolations.size() + " / " + numQueries);
+        }
+    }
+
+    /**
+     * Similar to {@link #randomGraph()}, but using the {@link QueryGraph} as it is done in real usage.
+     */
+    @Test
+    @Repeat(times = 10)
+    public void randomGraph_withQueryGraph() {
+        final long seed = System.nanoTime();
+        System.out.println("randomGraph_withQueryGraph seed: " + seed);
+        final int numQueries = 50;
+
+        // we may not use an offset when query graph is involved, otherwise traveling via virtual edges will not be
+        // the same as taking the direct edge!
+        double pOffset = 0;
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(graph, rnd, 50, 2.2, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.8, pOffset);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, turnCostExtension);
+//        GHUtility.printGraphForUnitTest(graph, encoder);
+        preProcessGraph();
+        LocationIndexTree index = new LocationIndexTree(graph, dir);
+        index.prepareIndex();
+        List<String> strictViolations = new ArrayList<>();
+        for (int i = 0; i < numQueries; i++) {
+            List<GHPoint> points = getRandomPoints(2, index, rnd);
+
+            List<QueryResult> chQueryResults = findQueryResults(index, points);
+            List<QueryResult> queryResults = findQueryResults(index, points);
+
+            QueryGraph chQueryGraph = new QueryGraph(prepareCH ? chGraph : graph);
+            QueryGraph queryGraph = new QueryGraph(graph);
+
+            chQueryGraph.lookup(chQueryResults);
+            queryGraph.lookup(queryResults);
+
+            int source = queryResults.get(0).getClosestNode();
+            int target = queryResults.get(1).getClosestNode();
+            Random tmpRnd1 = new Random(seed);
+            int sourceOutEdge = getSourceOutEdge(tmpRnd1, source, queryGraph);
+            int targetInEdge = getTargetInEdge(tmpRnd1, target, queryGraph);
+            Random tmpRnd2 = new Random(seed);
+            int chSourceOutEdge = getSourceOutEdge(tmpRnd2, source, chQueryGraph);
+            int chTargetInEdge = getTargetInEdge(tmpRnd2, target, chQueryGraph);
+
+            Path refPath = new DijkstraBidirectionRef(queryGraph, createTurnWeighting(queryGraph), TraversalMode.EDGE_BASED)
+                    .calcPath(source, target, sourceOutEdge, targetInEdge);
+            Path path = createAlgo(chQueryGraph)
+                    .calcPath(source, target, chSourceOutEdge, chTargetInEdge);
+            // do not check nodes, because there can be ambiguity when there are zero weight loops
+            strictViolations.addAll(comparePaths(refPath, path, source, target, false));
+        }
+        // sometimes there are multiple best paths with different distance/time, if this happens too often something
+        // is wrong and we fail
+        if (strictViolations.size() > Math.max(1, 0.05 * numQueries)) {
+            fail("Too many strict violations: " + strictViolations.size() + " / " + numQueries);
+        }
+    }
+
+    private List<GHPoint> getRandomPoints(int numPoints, LocationIndex index, Random rnd) {
+        List<GHPoint> points = new ArrayList<>(numPoints);
+        BBox bounds = graph.getBounds();
+        final int maxAttempts = 100 * numPoints;
+        int attempts = 0;
+        while (attempts < maxAttempts && points.size() < numPoints) {
+            double lat = rnd.nextDouble() * (bounds.maxLat - bounds.minLat) + bounds.minLat;
+            double lon = rnd.nextDouble() * (bounds.maxLon - bounds.minLon) + bounds.minLon;
+            QueryResult queryResult = index.findClosest(lat, lon, EdgeFilter.ALL_EDGES);
+            if (queryResult.isValid()) {
+                points.add(new GHPoint(lat, lon));
+            }
+            attempts++;
+        }
+        assertEquals("could not find valid random points after " + attempts + " attempts", numPoints, points.size());
+        return points;
+    }
+
+    private List<QueryResult> findQueryResults(LocationIndexTree index, List<GHPoint> ghPoints) {
+        List<QueryResult> result = new ArrayList<>(ghPoints.size());
+        for (GHPoint ghPoint : ghPoints) {
+            result.add(index.findClosest(ghPoint.getLat(), ghPoint.getLon(), DefaultEdgeFilter.ALL_EDGES));
+        }
+        return result;
+    }
+
+    private List<String> comparePaths(Path refPath, Path path, int source, int target, boolean checkNodes) {
+        List<String> strictViolations = new ArrayList<>();
+        double refWeight = refPath.getWeight();
+        double weight = path.getWeight();
+        if (Math.abs(refWeight - weight) > 1.e-2) {
+            System.out.println("expected: " + refPath.calcNodes());
+            System.out.println("given:    " + path.calcNodes());
+            fail("wrong weight: " + source + "->" + target + ", expected: " + refWeight + ", given: " + weight);
+        }
+        if (Math.abs(path.getDistance() - refPath.getDistance()) > 1.e-1) {
+            strictViolations.add("wrong distance " + source + "->" + target + ", expected: " + refPath.getDistance() + ", given: " + path.getDistance());
+        }
+        if (Math.abs(path.getTime() - refPath.getTime()) > 50) {
+            strictViolations.add("wrong time " + source + "->" + target + ", expected: " + refPath.getTime() + ", given: " + path.getTime());
+        }
+        if (checkNodes && !refPath.calcNodes().equals(path.calcNodes())) {
+            strictViolations.add("wrong nodes " + source + "->" + target + "\nexpected: " + refPath.calcNodes() + "\ngiven:    " + path.calcNodes());
+        }
+        return strictViolations;
+    }
+
+    private GraphHopperStorage createGraph() {
+        GraphHopperStorage gh = new GraphHopperStorage(Collections.singletonList(CHProfile.edgeBased(weighting, uTurnCosts)), dir, encodingManager,
+                false, turnCostExtension);
+        gh.create(1000);
+        return gh;
+    }
+
+    private int getTargetInEdge(Random rnd, int node, Graph graph) {
+        return getAdjEdge(rnd, node, graph);
+    }
+
+    private int getSourceOutEdge(Random rnd, int node, Graph graph) {
+        return getAdjEdge(rnd, node, graph);
+    }
+
+    private int getAdjEdge(Random rnd, int node, Graph graph) {
+        // sometimes do not restrict anything
+        if (rnd.nextDouble() < 0.05) {
+            return ANY_EDGE;
+        }
+        // sometimes use NO_EDGE
+        if (rnd.nextDouble() < 0.05) {
+            return NO_EDGE;
+        }
+        // use all edge explorer, sometimes we will find an edge we can restrict sometimes we do not
+        EdgeExplorer explorer = graph.createEdgeExplorer();
+        EdgeIterator iter = explorer.setBaseNode(node);
+        List<Integer> edgeIds = new ArrayList<>();
+        while (iter.next()) {
+            if (iter instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) iter).isShortcut()) {
+                // skip shortcuts here so we get the same restricted edges for a normal query graph and a
+                // query graph that wraps a CH graph (provided that the rnd number generator is in the same
+                // state)!
+                continue;
+            }
+            edgeIds.add(iter.getOrigEdgeFirst());
+            edgeIds.add(iter.getOrigEdgeLast());
+        }
+        return edgeIds.isEmpty() ? ANY_EDGE : edgeIds.get(rnd.nextInt(edgeIds.size()));
+    }
+
+    private int getRandom(Random rnd) {
+        return rnd.nextInt(graph.getNodes());
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
index 2a7404ae8a..2ae8440fbf 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
@@ -18,21 +18,19 @@
 package com.graphhopper.routing.weighting;
 
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.util.parsers.OSMMaxHeightParser;
-import com.graphhopper.routing.util.parsers.OSMMaxWeightParser;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.PMap;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -61,8 +59,8 @@ public void setUp() {
         graph = new GraphBuilder(em).create();
         // 0-1
         graph.edge(0, 1, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
         EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), EncodingManager.Access.WAY);
         graph.getEdgeIteratorState(0, 1).setFlags(em.handleWayTags(way, map, 0));
     }
@@ -97,8 +95,8 @@ public void testDisabledRoadAttributes() {
 
         // 0-1
         simpleGraph.edge(0, 1, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(simpleGraph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(simpleGraph, 1, 0.01, 0.01);
+        updateDistancesFor(simpleGraph, 0, 0.00, 0.00);
+        updateDistancesFor(simpleGraph, 1, 0.01, 0.01);
         EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), EncodingManager.Access.WAY);
         simpleGraph.getEdgeIteratorState(0, 1).setFlags(simpleEncodingManager.handleWayTags(way, map, 0));
 
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
index 99163de6e4..0f4072f463 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
@@ -42,8 +42,7 @@ public void calcWeightAndTime_withTurnCosts() {
     }
 
     @Test
-    public void calcWeightAndTime_defaultUTurn() {
-        // for u-turns default costs get applied
+    public void calcWeightAndTime_uTurnCosts() {
         EdgeIteratorState edge = graph.edge(0, 1, 100, true);
         TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExt, 40);
         assertEquals(6 + 40, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index fff721bd3d..247700dac9 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -119,7 +119,7 @@ public void tearDown() {
     public void testSetTooBigDistance_435() {
         graph = createGHStorage();
 
-        double maxDist = EdgeAccess.MAX_DIST;
+        double maxDist = BaseGraph.MAX_DIST;
         EdgeIteratorState edge1 = graph.edge(0, 1, maxDist, true);
         assertEquals(maxDist, edge1.getDistance(), 1);
 
diff --git a/core/src/test/java/com/graphhopper/storage/CHProfileTest.java b/core/src/test/java/com/graphhopper/storage/CHProfileTest.java
new file mode 100644
index 0000000000..ab9d29da03
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/CHProfileTest.java
@@ -0,0 +1,21 @@
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class CHProfileTest {
+
+    @Test
+    public void filename() {
+        CarFlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager.create(encoder);
+        assertEquals("fastest_car_edge_utc30", CHProfile.edgeBased(new FastestWeighting(encoder), 30).toFileName());
+        assertEquals("shortest_car_node", CHProfile.nodeBased(new ShortestWeighting(encoder)).toFileName());
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
index 55982a04ea..fe38b067bb 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.coll.GHIntHashSet;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -32,6 +31,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -52,11 +52,11 @@ public void testParseStringHints() {
         graph.edge(3, 4, 1, true);
         graph.edge(0, 3, 1, true);
         graph.edge(1, 4, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        updateDistancesFor(graph, 0, 0.01, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 2, 0.01, 0.02);
+        updateDistancesFor(graph, 3, 0.00, 0.00);
+        updateDistancesFor(graph, 4, 0.00, 0.01);
 
         LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory())
                 .prepareIndex();
@@ -104,18 +104,18 @@ public void testBlockAreasWithPolygon() {
         graph.edge(9, 10, 1, true); // 11
         graph.edge(10, 11, 1, true); // 12
 
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 2, 0);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 2, 1);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 2, 2);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 2, 3);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 1, 0);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 5, 1, 1);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 6, 1, 2);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 7, 1, 3);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 8, 0, 0);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 9, 0, 1);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 10, 0, 2);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 11, 0, 3);
+        updateDistancesFor(graph, 0, 2, 0);
+        updateDistancesFor(graph, 1, 2, 1);
+        updateDistancesFor(graph, 2, 2, 2);
+        updateDistancesFor(graph, 3, 2, 3);
+        updateDistancesFor(graph, 4, 1, 0);
+        updateDistancesFor(graph, 5, 1, 1);
+        updateDistancesFor(graph, 6, 1, 2);
+        updateDistancesFor(graph, 7, 1, 3);
+        updateDistancesFor(graph, 8, 0, 0);
+        updateDistancesFor(graph, 9, 0, 1);
+        updateDistancesFor(graph, 10, 0, 2);
+        updateDistancesFor(graph, 11, 0, 3);
 
         LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory())
                 .prepareIndex();
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 27ce4c79fc..de6faa0e6a 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -36,6 +36,8 @@
 import java.util.List;
 
 import static com.graphhopper.routing.ch.NodeBasedNodeContractorTest.SC_ACCESS;
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 import static org.junit.Assert.*;
 
 /**
@@ -43,7 +45,7 @@
  */
 public class GraphHopperStorageCHTest extends GraphHopperStorageTest {
     protected CHGraph getGraph(GraphHopperStorage ghStorage) {
-        return ghStorage.getGraph(CHGraph.class);
+        return ghStorage.getCHGraph();
     }
 
     @Override
@@ -56,11 +58,8 @@ private GraphHopperStorage newGHStorage(boolean is3D, boolean forEdgeBasedTraver
     }
 
     private GraphHopperStorage newGHStorage(Directory dir, boolean is3D, boolean forEdgeBasedTraversal) {
-        if (forEdgeBasedTraversal) {
-            return new GraphHopperStorage(Collections.<Weighting>emptyList(), Arrays.asList(new FastestWeighting(carEncoder)), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
-        } else {
-            return new GraphHopperStorage(Arrays.asList(new FastestWeighting(carEncoder)), Collections.<Weighting>emptyList(), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
-        }
+        CHProfile chProfile = new CHProfile(new FastestWeighting(carEncoder), forEdgeBasedTraversal, INFINITE_U_TURN_COSTS);
+        return new GraphHopperStorage(Collections.singletonList(chProfile), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
     }
 
     @Test
@@ -108,15 +107,8 @@ public void testEdgeFilter() {
         g.edge(10, 11, 1, true);
 
         graph.freeze();
-        CHEdgeIteratorState tmpIter = g.shortcut(3, 4);
-        tmpIter.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
-        tmpIter.setDistance(40);
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
-        assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
-
-        tmpIter = g.shortcut(0, 4);
-        tmpIter.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
-        tmpIter.setDistance(40);
+        g.shortcut(3, 4, PrepareEncoder.getScDirMask(), 0, NO_EDGE, NO_EDGE);
+        g.shortcut(0, 4, PrepareEncoder.getScDirMask(), 0, NO_EDGE, NO_EDGE);
         g.setLevel(0, 1);
         g.setLevel(4, 1);
 
@@ -125,8 +117,8 @@ public void testEdgeFilter() {
         iter = g.createEdgeExplorer().setBaseNode(2);
         assertEquals(2, GHUtility.count(iter));
 
-        tmpIter = g.shortcut(5, 6);
-        tmpIter.setSkippedEdges(1, 2);
+        int sc = g.shortcut(5, 6, PrepareEncoder.getScDirMask(), 0, 1, 2);
+        CHEdgeIteratorState tmpIter = g.getEdgeIteratorState(sc, 6);
         assertEquals(1, tmpIter.getSkippedEdge1());
         assertEquals(2, tmpIter.getSkippedEdge2());
     }
@@ -134,7 +126,7 @@ public void testEdgeFilter() {
     @Test
     public void testDisconnectEdge() {
         graph = createGHStorage();
-        CHGraphImpl lg = (CHGraphImpl) getGraph(graph);
+        CHGraph lg = getGraph(graph);
 
         EdgeExplorer chCarOutExplorer = lg.createEdgeExplorer(carOutFilter);
         EdgeExplorer tmpCarInExplorer = lg.createEdgeExplorer(carInFilter);
@@ -144,18 +136,9 @@ public void testDisconnectEdge() {
         // only remove edges
         lg.edge(4, 1, 30, true);
         graph.freeze();
-        CHEdgeIteratorState tmp = lg.shortcut(1, 2);
-        tmp.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
-        tmp.setDistance(10);
-        tmp.setSkippedEdges(10, 11);
-        tmp = lg.shortcut(1, 0);
-        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 0);
-        tmp.setDistance(20);
-        tmp.setSkippedEdges(12, 13);
-        tmp = lg.shortcut(3, 1);
-        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 0);
-        tmp.setDistance(30);
-        tmp.setSkippedEdges(14, 15);
+        lg.shortcut(1, 2, PrepareEncoder.getScDirMask(), 0, 10, 11);
+        lg.shortcut(1, 0, PrepareEncoder.getScFwdDir(), 0, 12, 13);
+        lg.shortcut(3, 1, PrepareEncoder.getScFwdDir(), 0, 14, 15);
         // create everytime a new independent iterator for disconnect method
         EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(1);
         iter.next();
@@ -186,15 +169,16 @@ public void testDisconnectEdge() {
     @Test
     public void testGetWeight() {
         graph = createGHStorage();
-        CHGraphImpl g = (CHGraphImpl) getGraph(graph);
-        assertFalse(g.edge(0, 1).isShortcut());
-        assertFalse(g.edge(1, 2).isShortcut());
+        CHGraph g = getGraph(graph);
+        assertFalse(((CHEdgeIteratorState) g.edge(0, 1)).isShortcut());
+        assertFalse(((CHEdgeIteratorState) g.edge(1, 2)).isShortcut());
 
         graph.freeze();
 
         // only remove edges
         int flags = PrepareEncoder.getScDirMask();
-        CHEdgeIteratorState sc1 = g.shortcut(0, 1);
+        int sc = g.shortcut(0, 1, flags, 5, NO_EDGE, NO_EDGE);
+        CHEdgeIteratorState sc1 = g.getEdgeIteratorState(sc, 1);
         assertTrue(sc1.isShortcut());
         sc1.setWeight(2.001);
         assertEquals(2.001, sc1.getWeight(), 1e-3);
@@ -224,40 +208,37 @@ public void testGetWeightIfAdvancedEncoder() {
         FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
         EncodingManager em = EncodingManager.create(customEncoder);
         FastestWeighting weighting = new FastestWeighting(customEncoder);
-        GraphHopperStorage ghStorage = new GraphBuilder(em).setCHGraph(weighting).create();
+        GraphHopperStorage ghStorage = new GraphBuilder(em).setCHProfiles(CHProfile.nodeBased(weighting)).create();
         ghStorage.edge(0, 2);
         ghStorage.freeze();
 
-        CHGraphImpl lg = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
-        CHEdgeIteratorState sc1 = lg.shortcut(0, 1);
-        sc1.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 100.123);
+        CHGraph lg = ghStorage.getCHGraph();
+        int sc1 = lg.shortcut(0, 1, PrepareEncoder.getScFwdDir(), 100.123, NO_EDGE, NO_EDGE);
 
-        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
-        assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
-        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
-        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1, 1).getWeight(), 1e-3);
+        assertEquals(100.123, lg.getEdgeIteratorState(sc1, 0).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, 0, 1)).getWeight(), 1e-3);
+        assertEquals(100.123, ((CHEdgeIteratorState) GHUtility.getEdge(lg, 1, 0)).getWeight(), 1e-3);
 
-        sc1 = lg.shortcut(1, 0);
-        assertTrue(sc1.isShortcut());
-        sc1.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 1.011011);
-        assertEquals(1.011011, sc1.getWeight(), 1e-3);
+        int sc2 = lg.shortcut(1, 0, PrepareEncoder.getScDirMask(), 1.011011, NO_EDGE, NO_EDGE);
+        assertEquals(1.011011, lg.getEdgeIteratorState(sc2, 0).getWeight(), 1e-3);
+        assertEquals(1.011011, lg.getEdgeIteratorState(sc2, 1).getWeight(), 1e-3);
     }
 
     @Test
-    public void weightAndDistanceExact() {
+    public void weightExact() {
         graph = createGHStorage();
         CHGraph chGraph = getGraph(graph);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
         graph.freeze();
 
-        // we just make up some weights and distances, they do not really have to be related to our previous edges.
+        // we just make up some weights, they do not really have to be related to our previous edges.
         // 1.004+1.006 = 2.09999999999. we make sure this does not become 2.09 instead of 2.10 (due to truncation)
         double x1 = 1.004;
         double x2 = 1.006;
-        chGraph.shortcut(0, 2, PrepareEncoder.getScFwdDir(), x1 + x2, x1 + x2, 0, 1);
+        chGraph.shortcut(0, 2, PrepareEncoder.getScFwdDir(), x1 + x2, 0, 1);
         CHEdgeIteratorState sc = chGraph.getEdgeIteratorState(2, 2);
-        assertEquals(2.01, sc.getDistance(), 1.e-6);
         assertEquals(2.01, sc.getWeight(), 1.e-6);
     }
 
@@ -273,7 +254,7 @@ public void testQueryGraph() {
         EdgeIteratorState edge1 = chGraph.edge(0, 1);
         chGraph.edge(1, 2);
         graph.freeze();
-        chGraph.shortcut(0, 1);
+        chGraph.shortcut(0, 1, PrepareEncoder.getScDirMask(), 10, NO_EDGE, NO_EDGE);
 
         QueryGraph qGraph = new QueryGraph(chGraph);
         QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
@@ -321,7 +302,7 @@ public void testSave_and_Freeze() throws IOException {
         assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
         assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(1)));
 
-        chGraph.shortcut(2, 3);
+        chGraph.shortcut(2, 3, PrepareEncoder.getScDirMask(), 10, NO_EDGE, NO_EDGE);
 
         // should be identical to access without shortcut
         assertEquals(1, GHUtility.count(graph.createEdgeExplorer().setBaseNode(1)));
@@ -366,8 +347,8 @@ public void testSimpleShortcutCreationAndTraversal() {
         graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        lg.shortcut(1, 4).setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 3);
+        CHGraph lg = graph.getCHGraph();
+        lg.shortcut(1, 4, PrepareEncoder.getScFwdDir(), 3, NO_EDGE, NO_EDGE);
 
         EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
         // iteration should result in same nodes even if reusing the iterator
@@ -382,8 +363,8 @@ public void testAddShortcutSkippedEdgesWriteRead() {
         final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        lg.shortcut(1, 4);
+        CHGraph lg = graph.getCHGraph();
+        lg.shortcut(1, 4, PrepareEncoder.getScDirMask(), 10, NO_EDGE, NO_EDGE);
 
         AllCHEdgesIterator iter = lg.getAllEdges();
         iter.next();
@@ -402,9 +383,8 @@ public void testAddShortcutSkippedEdgesWriteRead_writeWithCHEdgeIterator() {
         final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        CHEdgeIteratorState shortcut = lg.shortcut(1, 4);
-        shortcut.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
+        CHGraph lg = graph.getCHGraph();
+        lg.shortcut(1, 4, PrepareEncoder.getScDirMask(), 10, edge1.getEdge(), edge2.getEdge());
 
         AllCHEdgesIterator iter = lg.getAllEdges();
         iter.next();
@@ -475,9 +455,7 @@ public void testGetEdgeIterator() {
 
     private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int firstOrigEdge, int lastOrigEdge,
                              int skipEdge1, int skipEdge2, int distance) {
-        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
-        shortcut.setFlagsAndWeight(fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir(), 0);
-        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge).setSkippedEdges(skipEdge1, skipEdge2).setDistance(distance);
+        chGraph.shortcutEdgeBased(from, to, fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir(), 0, skipEdge1, skipEdge2, firstOrigEdge, lastOrigEdge);
     }
 
     @Test
@@ -485,50 +463,46 @@ public void testShortcutCreationAndAccessForManyVehicles() {
         FlagEncoder tmpCar = new CarFlagEncoder();
         FlagEncoder tmpBike = new Bike2WeightFlagEncoder();
         EncodingManager em = EncodingManager.create(tmpCar, tmpBike);
-        List<Weighting> chWeightings = new ArrayList<>();
-        chWeightings.add(new FastestWeighting(tmpCar));
-        chWeightings.add(new FastestWeighting(tmpBike));
+        List<CHProfile> chProfiles = Arrays.asList(
+                CHProfile.nodeBased(new FastestWeighting(tmpCar)),
+                CHProfile.nodeBased(new FastestWeighting(tmpBike)));
         BooleanEncodedValue tmpCarAccessEnc = tmpCar.getAccessEnc();
 
-        graph = new GraphHopperStorage(chWeightings, new RAMDirectory(), em, false, new GraphExtension.NoOpExtension()).create(1000);
+        graph = new GraphHopperStorage(chProfiles, new RAMDirectory(), em, false, new GraphExtension.NoOpExtension()).create(1000);
         IntsRef edgeFlags = GHUtility.setProperties(em.createEdgeFlags(), tmpCar, 100, true, false);
         graph.edge(0, 1).setDistance(10).setFlags(GHUtility.setProperties(edgeFlags, tmpBike, 10, true, true));
         graph.edge(1, 2).setDistance(10).setFlags(edgeFlags);
 
         graph.freeze();
 
-        CHGraph carCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(0));
+        CHGraph carCHGraph = graph.getCHGraph(chProfiles.get(0));
         // enable forward directions for car
-        CHEdgeIteratorState carSC02 = carCHGraph.shortcut(0, 2);
-        carSC02.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 10);
-        carSC02.setDistance(20);
+        int carSC02 = carCHGraph.shortcut(0, 2, PrepareEncoder.getScFwdDir(), 10, NO_EDGE, NO_EDGE);
 
-        CHGraph bikeCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(1));
-        CHEdgeIteratorState bikeSC02 = bikeCHGraph.shortcut(0, 2);
+        CHGraph bikeCHGraph = graph.getCHGraph(chProfiles.get(1));
         // enable both directions for bike
-        bikeSC02.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 10);
-        bikeSC02.setDistance(20);
+        int bikeSC02 = bikeCHGraph.shortcut(0, 2, PrepareEncoder.getScDirMask(), 10, NO_EDGE, NO_EDGE);
 
         // assert car CH graph
-        assertTrue(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).get(tmpCarAccessEnc));
-        assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).getReverse(tmpCarAccessEnc));
+        assertTrue(carCHGraph.getEdgeIteratorState(carSC02, 2).get(tmpCarAccessEnc));
+        assertFalse(carCHGraph.getEdgeIteratorState(carSC02, 2).getReverse(tmpCarAccessEnc));
 
         BooleanEncodedValue tmpBikeAccessEnc = tmpBike.getAccessEnc();
 
         // throw exception for wrong encoder
         try {
-            assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).get(tmpBikeAccessEnc));
+            assertFalse(carCHGraph.getEdgeIteratorState(carSC02, 2).get(tmpBikeAccessEnc));
             fail();
         } catch (AssertionError ex) {
         }
 
         // assert bike CH graph
-        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).get(tmpBikeAccessEnc));
-        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).getReverse(tmpBikeAccessEnc));
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02, 2).get(tmpBikeAccessEnc));
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02, 2).getReverse(tmpBikeAccessEnc));
 
         // throw exception for wrong encoder
         try {
-            assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).getReverse(tmpCarAccessEnc));
+            assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02, 2).getReverse(tmpCarAccessEnc));
             fail();
         } catch (AssertionError ex) {
         }
@@ -589,15 +563,15 @@ private void testLoadingWithLessWeightings_works(boolean edgeBased) {
         // now we create a new storage but only use one of the weightings, which should be ok
         GraphHopperStorage smallStorage = createStorageWithWeightings(edgeBased, weighting1);
         smallStorage.loadExisting();
-        assertEquals(edgeBased ? 0 : 1, smallStorage.getNodeBasedCHWeightings().size());
-        assertEquals(edgeBased ? 1 : 0, smallStorage.getEdgeBasedCHWeightings().size());
+        assertEquals(edgeBased ? 0 : 1, smallStorage.getCHProfiles(false).size());
+        assertEquals(edgeBased ? 1 : 0, smallStorage.getCHProfiles(true).size());
         smallStorage.flush();
 
         // now we create yet another storage that uses both weightings again, which still works
         GraphHopperStorage fullStorage = createStorageWithWeightings(edgeBased, weighting1, weighting2);
         fullStorage.loadExisting();
-        assertEquals(edgeBased ? 0 : 2, fullStorage.getNodeBasedCHWeightings().size());
-        assertEquals(edgeBased ? 2 : 0, fullStorage.getEdgeBasedCHWeightings().size());
+        assertEquals(edgeBased ? 0 : 2, fullStorage.getCHProfiles(false).size());
+        assertEquals(edgeBased ? 2 : 0, fullStorage.getCHProfiles(true).size());
         fullStorage.flush();
     }
 
@@ -615,17 +589,17 @@ public void testLoadingWithLessWeightings_nodeAndEdge_works() {
         // now we create a new storage but only use the edge weighting, which should be ok
         GraphHopperStorage edgeStorage = createStorageWithWeightings(true, weighting2);
         edgeStorage.loadExisting();
-        assertEquals(0, edgeStorage.getNodeBasedCHWeightings().size());
-        assertEquals(1, edgeStorage.getEdgeBasedCHWeightings().size());
+        assertEquals(0, edgeStorage.getCHProfiles(false).size());
+        assertEquals(1, edgeStorage.getCHProfiles(true).size());
         edgeStorage.flush();
 
         // now we create yet another storage that uses one of the node and the edge weighting, which still works
         GraphHopperStorage mixedStorage = createStorageWithWeightings(
-                Arrays.<Weighting>asList(weighting1),
-                Arrays.<Weighting>asList(weighting2));
+                Collections.<Weighting>singletonList(weighting1),
+                Collections.<Weighting>singletonList(weighting2));
         mixedStorage.loadExisting();
-        assertEquals(1, mixedStorage.getNodeBasedCHWeightings().size());
-        assertEquals(1, mixedStorage.getNodeBasedCHWeightings().size());
+        assertEquals(1, mixedStorage.getCHProfiles(false).size());
+        assertEquals(1, mixedStorage.getCHProfiles(true).size());
         mixedStorage.flush();
     }
 
@@ -636,7 +610,14 @@ private GraphHopperStorage createStorageWithWeightings(boolean edgeBased, Weight
     }
 
     private GraphHopperStorage createStorageWithWeightings(List<Weighting> nodeBasedCHWeightings, List<Weighting> edgeBasedCHWeightings) {
-        return new GraphHopperStorage(nodeBasedCHWeightings, edgeBasedCHWeightings,
+        List<CHProfile> profiles = new ArrayList<>(nodeBasedCHWeightings.size() + edgeBasedCHWeightings.size());
+        for (Weighting nodeBasedCHWeighting : nodeBasedCHWeightings) {
+            profiles.add(CHProfile.nodeBased(nodeBasedCHWeighting));
+        }
+        for (Weighting edgeBasedCHWeighting : edgeBasedCHWeightings) {
+            profiles.add(CHProfile.edgeBased(edgeBasedCHWeighting, INFINITE_U_TURN_COSTS));
+        }
+        return new GraphHopperStorage(profiles,
                 new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), encodingManager, false, new GraphExtension.NoOpExtension());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
index 901d2fcaf2..7aacb8315d 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
@@ -2,7 +2,6 @@
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.EncodingManager.Access;
@@ -19,6 +18,7 @@
 
 import java.io.File;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.*;
 
 /**
@@ -61,8 +61,8 @@ public void testStorageProperties() {
         way_0_1.setTag("maxheight", "4.4");
 
         graph.edge(0, 1, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
         EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), Access.WAY);
         graph.getEdgeIteratorState(0, 1).setFlags(encodingManager.handleWayTags(way_0_1, map, 0));
 
@@ -72,7 +72,7 @@ public void testStorageProperties() {
         way_1_2.setTag("maxweight", "45");
 
         graph.edge(1, 2, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.02, 0.02);
+        updateDistancesFor(graph, 2, 0.02, 0.02);
         graph.getEdgeIteratorState(1, 2).setFlags(encodingManager.handleWayTags(way_1_2, map, 0));
 
         // 2-0
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
index e7fdb3c551..09030265be 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
@@ -2,7 +2,6 @@
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.EncodingManager.Access;
@@ -12,6 +11,7 @@
 import java.io.File;
 import java.util.Arrays;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
@@ -31,8 +31,8 @@ public void testLoad() {
         way_0_1.setTag("maxheight", "4.4");
 
         graph.edge(0, 1, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
         graph.getEdgeIteratorState(0, 1).setFlags(carFlagEncoder.handleWayTags(encodingManager.createEdgeFlags(), way_0_1, Access.WAY, 0));
 
         // 1-2
@@ -41,7 +41,7 @@ public void testLoad() {
         way_1_2.setTag("maxweight", "45");
 
         graph.edge(1, 2, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.02, 0.02);
+        updateDistancesFor(graph, 2, 0.02, 0.02);
         graph.getEdgeIteratorState(1, 2).setFlags(carFlagEncoder.handleWayTags(encodingManager.createEdgeFlags(), way_1_2, Access.WAY, 0));
 
         graph.flush();
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index fc652925db..7dc9ce4898 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -44,9 +44,9 @@ protected GraphHopperStorage newGHStorage(Directory dir, boolean enabled3D) {
     }
 
     @Test
-    public void testNoCreateCalled() throws IOException {
+    public void testNoCreateCalled() {
         try (GraphHopperStorage gs = new GraphBuilder(encodingManager).build()) {
-            ((BaseGraph) gs.getGraph(Graph.class)).ensureNodeIndex(123);
+            ((BaseGraph) gs.getBaseGraph()).ensureNodeIndex(123);
             fail("AssertionError should be raised");
         } catch (AssertionError err) {
             // ok
@@ -148,7 +148,7 @@ protected void checkGraph(Graph g) {
     @Test
     public void internalDisconnect() {
         GraphHopperStorage storage = createGHStorage();
-        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
+        BaseGraph graph = (BaseGraph) storage.getBaseGraph();
         EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(1, 2, 10, true);
         EdgeIteratorState iter3 = graph.edge(0, 3, 10, true);
@@ -191,7 +191,7 @@ public void testBigDataEdge() {
         Directory dir = new RAMDirectory();
         GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(defaultSize);
-        ((BaseGraph) graph.getGraph(Graph.class)).setEdgeCount(Integer.MAX_VALUE / 2);
+        ((BaseGraph) graph.getBaseGraph()).setEdgeCount(Integer.MAX_VALUE / 2);
         assertTrue(graph.getAllEdges().next());
         graph.close();
     }
@@ -214,16 +214,15 @@ public void testDoThrowExceptionIfDimDoesNotMatch() {
     @Test
     public void testIdentical() {
         GraphHopperStorage store = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension());
-        assertEquals(store.getNodes(), store.getGraph(Graph.class).getNodes());
-        assertEquals(store.getAllEdges().length(), store.getGraph(Graph.class).getAllEdges().length());
+        assertEquals(store.getNodes(), store.getBaseGraph().getNodes());
+        assertEquals(store.getAllEdges().length(), store.getBaseGraph().getAllEdges().length());
     }
 
     @Test
     public void testMultipleDecoupledEdges() {
         // a typical usage where we create independent EdgeIteratorState's BUT due to the IntsRef reference they are no more independent
         GraphHopperStorage storage = createGHStorage();
-        IntsRef intsRef = encodingManager.createEdgeFlags();
-        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
+        Graph graph = storage.getBaseGraph();
         graph.edge(0, 1, 10, true);
         graph.edge(1, 2, 10, true);
 
@@ -259,7 +258,7 @@ public void testInternalReverse() {
     @Test
     public void testDecoupledEdgeIteratorStates() {
         GraphHopperStorage storage = createGHStorage();
-        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
+        Graph graph = storage.getBaseGraph();
         IntsRef ref = encodingManager.createEdgeFlags();
         ref.ints[0] = 12;
         graph.edge(1, 2, 10, true).setFlags(ref);
diff --git a/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
index 11c888d1be..83e8ffc56e 100644
--- a/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
+++ b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
@@ -18,6 +18,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static org.junit.Assert.assertEquals;
 
 @RunWith(Parameterized.class)
@@ -49,8 +50,8 @@ public void init() {
         encoder = new MotorcycleFlagEncoder(5, 5, 10);
         EncodingManager encodingManager = EncodingManager.create(encoder);
         weighting = new FastestWeighting(encoder);
-        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(edgeBased).create();
-        chGraph = graph.getGraph(CHGraph.class, weighting);
+        graph = new GraphBuilder(encodingManager).setCHProfiles(new CHProfile(weighting, edgeBased, INFINITE_U_TURN_COSTS)).create();
+        chGraph = graph.getCHGraph();
         if (edgeBased) {
             turnCostExtension = (TurnCostExtension) graph.getExtension();
         }
@@ -295,11 +296,10 @@ private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, in
     private void shortcut(int baseNode, int adjNode, int skip1, int skip2, int origFirst, int origLast) {
         // shortcut weight/distance is not important for us here
         double weight = 1;
-        double distance = 1;
         if (edgeBased) {
-            chGraph.shortcutEdgeBased(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+            chGraph.shortcutEdgeBased(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, skip1, skip2, origFirst, origLast);
         } else {
-            chGraph.shortcut(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2);
+            chGraph.shortcut(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, skip1, skip2);
         }
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index 3feea2b09b..837d4d896e 100644
--- a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -2,7 +2,6 @@
 
 import com.graphhopper.jackson.Jackson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
@@ -26,6 +25,7 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 
+import static com.graphhopper.util.GHUtility.updateDistancesFor;
 import static org.junit.Assert.*;
 
 /**
@@ -51,11 +51,11 @@ public void testApplyChanges() throws IOException {
         graph.edge(3, 4, 1, true);
         graph.edge(0, 3, 1, true);
         graph.edge(1, 4, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        updateDistancesFor(graph, 0, 0.01, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 2, 0.01, 0.02);
+        updateDistancesFor(graph, 3, 0.00, 0.00);
+        updateDistancesFor(graph, 4, 0.00, 0.01);
         LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
 
         FlagEncoder encoder = encodingManager.getEncoder("car");
@@ -91,11 +91,11 @@ public void testRevertChanges() throws IOException {
         graph.edge(3, 4, 1, true);
         graph.edge(0, 3, 1, true);
         graph.edge(1, 4, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        updateDistancesFor(graph, 0, 0.01, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.01);
+        updateDistancesFor(graph, 2, 0.01, 0.02);
+        updateDistancesFor(graph, 3, 0.00, 0.00);
+        updateDistancesFor(graph, 4, 0.00, 0.01);
         LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
 
         FlagEncoder encoder = encodingManager.getEncoder("car");
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
index 2e1e37349a..36b8407974 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
@@ -62,7 +62,7 @@ GraphHopperStorage createGHStorage(Directory dir, EncodingManager encodingManage
     @Test
     public void testCHGraph() {
         GraphHopperStorage ghStorage = createGHStorage(new RAMDirectory(), encodingManager, false);
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        CHGraph lg = ghStorage.getCHGraph();
         // 0
         // 1
         // 2
@@ -83,27 +83,22 @@ public void testCHGraph() {
         // create shortcuts
         ghStorage.freeze();
         int flags = PrepareEncoder.getScDirMask();
-        CHEdgeIteratorState iter5 = lg.shortcut(0, 2);
-        iter5.setFlagsAndWeight(flags, 0);
-        iter5.setDistance(20);
-        iter5.setSkippedEdges(iter1.getEdge(), iter2.getEdge());
-        CHEdgeIteratorState iter6 = lg.shortcut(2, 4);
-        iter6.setFlagsAndWeight(flags, 0);
-        iter6.setDistance(28);
-        iter6.setSkippedEdges(iter3.getEdge(), iter4.getEdge());
-        CHEdgeIteratorState tmp = lg.shortcut(0, 4);
-        tmp.setFlagsAndWeight(flags, 0);
-        tmp.setDistance(40);
-        tmp.setSkippedEdges(iter5.getEdge(), iter6.getEdge());
+        int sc1 = addShortcut(lg, 0, 2, 0, iter1.getEdge(), iter2.getEdge(), flags);
+        int sc2 = addShortcut(lg, 2, 4, 0, iter3.getEdge(), iter4.getEdge(), flags);
+        addShortcut(lg, 0, 4, 0, sc1, sc2, flags);
 
         LocationIndex index = createIndex(ghStorage, -1);
         assertEquals(2, findID(index, 0, 0.5));
     }
 
+    private int addShortcut(CHGraph lg, int from, int to, double weight, int skip1, int skip2, int direction) {
+        return lg.shortcut(from, to, direction, weight, skip1, skip2);
+    }
+
     @Test
     public void testSortHighLevelFirst() {
         GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
-        final CHGraph lg = g.getGraph(CHGraph.class);
+        final CHGraph lg = g.getCHGraph();
         lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
@@ -137,7 +132,7 @@ public void testCHGraphBug() {
         EdgeIteratorState iter1 = g.edge(1, 0, 100, true);
         g.edge(2, 3, 100, true);
 
-        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.freeze();
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
diff --git a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index 676cf8caed..5e3d881814 100644
--- a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -25,6 +25,7 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.CHProfile;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import org.junit.Test;
@@ -43,8 +44,8 @@ public void testUpdateFlags() {
         EncodingManager encodingManager = EncodingManager.create(carFlagEncoder);
         FastestWeighting weighting = new FastestWeighting(carFlagEncoder);
         EdgeFilter carOutFilter = DefaultEdgeFilter.outEdges(carFlagEncoder);
-        GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-        CHGraph g = ghStorage.getGraph(CHGraph.class, weighting);
+        GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(weighting)).create();
+        CHGraph g = ghStorage.getCHGraph();
         BooleanEncodedValue accessEnc = carFlagEncoder.getAccessEnc();
         DecimalEncodedValue avSpeedEnc = carFlagEncoder.getAverageSpeedEnc();
         g.edge(0, 1).setDistance(12).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, 10.0);
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 33fb599fc0..5578818678 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -111,7 +111,7 @@ public void testCopyWithSelfRef() {
         Graph g = initUnsorted(createGraph());
         g.edge(0, 0, 11, true);
 
-        CHGraph lg = new GraphBuilder(encodingManager).chGraphCreate(new FastestWeighting(carEncoder));
+        CHGraph lg = new GraphBuilder(encodingManager).chGraphCreate(CHProfile.nodeBased(new FastestWeighting(carEncoder)));
         GHUtility.copyTo(g, lg);
 
         assertEquals(g.getAllEdges().length(), lg.getEdges());
@@ -123,8 +123,8 @@ public void testCopy() {
         EdgeIteratorState edgeState = g.edge(6, 5, 11, true);
         edgeState.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
 
-        GraphHopperStorage newStore = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
-        CHGraph lg = newStore.getGraph(CHGraph.class);
+        GraphHopperStorage newStore = new GraphBuilder(encodingManager).setCHProfiles(CHProfile.nodeBased(new FastestWeighting(carEncoder))).create();
+        CHGraph lg = newStore.getCHGraph();
         GHUtility.copyTo(g, lg);
         newStore.freeze();
 
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index b2d38c0711..215f782545 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -59,7 +59,13 @@ public void testToString() {
         trMap = SINGLETON.get("iw");
         assertEquals("", trMap.tr("web.FOOT"));
 
-        // indonesia assertEquals("in", new Locale("id").getLanguage());
+        // Indonesian
+        assertEquals("in", SINGLETON.get("in").getLanguage());
+        assertEquals("in", SINGLETON.get("in_ID").getLanguage());
+
+        // Vietnamese
+        assertEquals("vi", SINGLETON.get("vi").getLanguage());
+        assertEquals("vi", SINGLETON.get("vi_VN").getLanguage());
     }
 
     @Test
diff --git a/docs/ISSUE_TEMPLATE/bug_report.md b/docs/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 0000000000..86228683ae
--- /dev/null
+++ b/docs/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,38 @@
+---
+name: Bug report
+about: Create a report to help us improve
+title: ''
+labels: ''
+assignees: ''
+
+---
+
+**Describe the bug**
+A clear and concise description of what the bug is. If you are unsure if this is really a bug, please create a new topic in [our forum](https://discuss.graphhopper.com/c/graphhopper).
+
+If you have an Android application that uses GraphHopper, please always post to the [forum](https://discuss.graphhopper.com/c/graphhopper/graphhopper-ios-and-android) before and include logs and the version of
+your Android system.
+
+**To Reproduce**
+
+Steps to reproduce the behavior. For examples:
+
+1. checkout recent and stable version of GraphHopper
+2. download a certain.pbf
+3. run e.g. graphhopper.sh script like: `./graphhopper.sh web certain.pbf`
+4. See error
+
+Instead of a manual reproduction it would be even better to have a unit or integration test reproducing the issue.
+
+**Expected behavior**
+A clear and concise description of what you expected to happen.
+
+**System Information**
+
+Provide version of Operating system, JVM and GraphHopper
+
+**Screenshots & Logs**
+
+If applicable, add screenshots and log output.
+
+In case of a routing problem include a link to [GraphHopper Maps](https://graphhopper.com/maps/). Also tell us your expected routing result via additional markers and screenshots.
\ No newline at end of file
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
index cfea45828b..3193d39b69 100644
--- a/docs/core/create-new-flagencoder.md
+++ b/docs/core/create-new-flagencoder.md
@@ -15,17 +15,16 @@ Use it e.g. just via `graphHopper.setEncodingManager(new EncodingManager(myEncod
 
 ## Different forward and backward weights?
 
-If you need to support two different speed values for one street (one edge) you need to create
-a separate EncodedDoubleValue instance (reverseSpeedEncoder) managing the reverse speed, 
-see Bike2WeightFlagEncoder for an example. You'll have to overwrite the following methods:
-
- * setReverseSpeed, getReverseSpeed to use the reverseSpeedEncoder
- * handleSpeed, to handle oneway tags correctly
- * flagsDefault 
- * setProperties
- * reverseFlags
- * setLowSpeed
- * always set reverse speed explicitely, see #665
+With 0.12 this is now simple. Specify speedTwoDirections = true in the constructor and overwrite handleSpeed:
+
+```java
+protected void handleSpeed(IntsRef edgeFlags, ReaderWay way, double speed) {
+        speedEncoder.setDecimal(true, edgeFlags, speed);
+        super.handleSpeed(edgeFlags, way, speed);
+}
+```
+
+See Bike2WeightFlagEncoder for an example that uses different weights: slower speeds uphill than downhill.
 
 ## Elevation
 
@@ -34,6 +33,5 @@ and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
 
 ## Add to the core
 
-If you want to include your FlagEncoder in GraphHopper you have to add the creation in
-EncodingManager.parseEncoderString to let the EncodingManager pick the correct class when faced
-with the string. The convention is that encoder.toString is identical to the string.
+If you want to include your FlagEncoder in GraphHopper and e.g. still want to use the config.yml
+you can use a subclass of DefaultFlagEncoderFactory and use the configuration object to change different properties.
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 6105a36830..2e1ff69096 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -63,7 +63,7 @@ Program arguments: server config.yml
 
 ### Contribute
 
-See this [guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md) on how to contribute.
+See this [guide](../../CONTRIBUTING.md) on how to contribute.
 
 ### Java, Embedded Usage
 
diff --git a/docs/core/translations.md b/docs/core/translations.md
index a9b0735e40..fe0c250225 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -35,8 +35,8 @@ want to try your changes or want to speed up the integration you can do the foll
  * Now you can see your changes via `git diff`. Make sure that is the only one with `git status`
  * Now execute `mvn clean test` to see if you did not miss arguments in your translation (see point 2 in the questions above) and start
  the [GraphHopper service](./quickstart-from-source.md) and go to localhost:8989 append e.g. &locale=de if your translation does not show up automatically
- * Read the [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) to submit your changes
+ * Read the [contributing guide](../../CONTRIBUTING.md) to submit your changes
 
 ## License Agreement
 
-Please sign the <a href="https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md">GraphHopper License Agreement</a>.
+Please sign the [GraphHopper License Agreement](../../CONTRIBUTING.md).
diff --git a/docs/core/turn-restrictions.md b/docs/core/turn-restrictions.md
index 68a03613aa..94b1eccf17 100644
--- a/docs/core/turn-restrictions.md
+++ b/docs/core/turn-restrictions.md
@@ -18,9 +18,27 @@ for some vehicles like `foot`.
 To enable turn restrictions when using the 'speed mode' additional graph preparation is required, because turn restrictions
 require edge-based (vs. node-based) traversal of the graph. First you have to set the weightings for which the graph 
 preparation should be run using e.g. `prepare.ch.weightings=fastest`, just like when you use the 'speed mode' without 
-turn restrictions. Additionally you need to set `prepare.ch.turn_costs` to `edge_or_node` or `edge_and_node`
-(see `config-example.yml` for further details). At request time you need to add `edge_based=true` as URL parameter to 
-enable turn restricted routing and to disable the 'speed mode' per request you can add `ch.disable=true`.
+turn restrictions. Additionally you need to set `prepare.ch.turn_costs` to `edge_or_node` or `edge_and_node`. You can
+also specify a time penalty for taking u-turns (turning from one road back to the same road at a junction). Note that 
+this time-penalty only works reasonably when your weighting is time-based (like "fastest"). See 
+`config-example.yml` for further details regarding these configurations. If you prepare multiple 'speed mode' profiles you have to specify which
+one to use at request time: Use the `edge_based=true/false` parameter to enforce edge-based or node-based routing and 
+the `u_turn_costs` parameter to specify the u-turn costs (only needed if there are multiple edge-based 'speed mode'
+profiles with different u-turn costs). To disable the 'speed mode' per request you can add `ch.disable=true` and choose
+the value of `u_turn_costs` freely.
 
 While OSM data only contains turn *restrictions*, the GraphHopper routing engine can also deal with turn *costs*, i.e.
-you can specify custom turn costs for each turn at each junction.
\ No newline at end of file
+you can specify custom turn costs for each turn at each junction.
+
+Conditional turn restriction are supported. For example, the following no left turn restriction concerns only bus :
+
+> type=restriction  
+> restriction:bus=no_left_turn
+
+Another example, using the *except* tag, means only *bicycle* are allowed to turn left:
+
+> type=restriction  
+> restriction=no_left_turn  
+> except=bicycle
+
+You can overwrite `FlagEncoder#acceptsTurnRelation` to change the default handling of turn restrictions in your customized vehicle profile.
\ No newline at end of file
diff --git a/docs/index.md b/docs/index.md
index e27b0efb19..3a319139b5 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -45,7 +45,7 @@ Find all changes in previous and current versions in the [changelogs](../core/fi
 
 #### Contribute
 
-Read [here](../.github/CONTRIBUTING.md) on how to contribute as a developer and translator.
+Read [here](../CONTRIBUTING.md) on how to contribute as a developer and translator.
 
 #### Technical
 
diff --git a/isochrone/pom.xml b/isochrone/pom.xml
index 60a772c4ff..7ea0f85c40 100644
--- a/isochrone/pom.xml
+++ b/isochrone/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-isochrone</artifactId>
     <packaging>jar</packaging>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper Isochrone</name>
     <description>Isochrone calculation with GraphHopper</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
index cd0da7f7a9..83dbc732f8 100644
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
@@ -22,6 +22,7 @@
 import com.graphhopper.coll.GHIntObjectHashMap;
 import com.graphhopper.routing.AbstractRoutingAlgorithm;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.PathExtractor;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
@@ -107,7 +108,7 @@ public void setDistanceLimit(double limit) {
     public static class IsoLabelWithCoordinates {
         public final int nodeId;
         public int edgeId, prevEdgeId, prevNodeId;
-        public int timeInSec, prevTimeInSec;
+        public int timeMillis, prevTimeMillis;
         public int distance, prevDistance;
         public GHPoint coordinate, prevCoordinate;
 
@@ -132,7 +133,7 @@ public void apply(int nodeId, IsoLabel label) {
                 double lon = na.getLongitude(nodeId);
                 IsoLabelWithCoordinates isoLabelWC = new IsoLabelWithCoordinates(nodeId);
                 isoLabelWC.coordinate = new GHPoint(lat, lon);
-                isoLabelWC.timeInSec = Math.round(label.time);
+                isoLabelWC.timeMillis = Math.round(label.time);
                 isoLabelWC.distance = (int) Math.round(label.distance);
                 isoLabelWC.edgeId = label.edge;
                 if (label.parent != null) {
@@ -144,7 +145,7 @@ public void apply(int nodeId, IsoLabel label) {
                     isoLabelWC.prevEdgeId = prevLabel.edge;
                     isoLabelWC.prevCoordinate = new GHPoint(prevLat, prevLon);
                     isoLabelWC.prevDistance = (int) Math.round(prevLabel.distance);
-                    isoLabelWC.prevTimeInSec = Math.round(prevLabel.time);
+                    isoLabelWC.prevTimeMillis = Math.round(prevLabel.time);
                 }
                 callback.add(isoLabelWC);
             }
@@ -291,7 +292,7 @@ protected Path extractPath() {
         if (currEdge == null || !finished()) {
             return createEmptyPath();
         }
-        return new Path(graph, weighting).setSPTEntry(currEdge).extract();
+        return PathExtractor.extractPath(graph, weighting, currEdge);
     }
 
     @Override
diff --git a/pom.xml b/pom.xml
index 2294e7be2a..2b7bc81b41 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>pom</packaging>
     <url>https://www.graphhopper.com</url>
     <inceptionYear>2012</inceptionYear>
@@ -157,6 +157,7 @@
                 </configuration>
             </plugin>
 
+	    <!--
             <plugin>
                 <groupId>com.github.spotbugs</groupId>
                 <artifactId>spotbugs-maven-plugin</artifactId>
@@ -170,13 +171,9 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-pmd-plugin</artifactId>
-                <version>3.12</version>
-                <!-- e.g. under core/target/site/pmd.html
-                <configuration>
-                    <format>html</format>
-                </configuration>
-                -->
+                <version>3.12.0</version>
             </plugin>
+            -->
             <plugin>
                 <groupId>de.thetaphi</groupId>
                 <artifactId>forbiddenapis</artifactId>
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index bc34354627..8b6a14d111 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-gtfs</artifactId>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for Gtfs Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.13-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index 56200346d9..12b8b52be2 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -18,6 +18,7 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.EncodedValue;
@@ -57,6 +58,11 @@ public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         return oldRelationFlags;
     }
 
+    @Override
+    public boolean acceptsTurnRelation(OSMTurnRelation relation) {
+        return false;
+    }
+
     @Override
     public EncodingManager.Access getAccess(ReaderWay way) {
         return EncodingManager.Access.CAN_SKIP;
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index 03d0a48b3e..265be53944 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for OpenStreetMap Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.13-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index e865a2a0d6..fee1d8ddb6 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -23,11 +23,11 @@
 import com.graphhopper.reader.*;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.GraphElevationSmoothing;
-import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
@@ -181,8 +181,9 @@ void preProcess(File osmFile) {
                     if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
                         prepareWaysWithRelationInfo(relation);
 
-                    if (relation.hasTag("type", "restriction"))
+                    if (relation.hasTag("type", "restriction")) {
                         prepareRestrictionRelation(relation);
+                    }
 
                     if (++tmpRelationCounter % 100_000 == 0) {
                         LOGGER.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
@@ -429,13 +430,15 @@ public void processRelation(ReaderRelation relation) {
         Map<Long, TurnCostTableEntry> entries = new LinkedHashMap<>();
 
         for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
-            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation)) {
-                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
-                if (oldEntry != null) {
-                    // merging different encoders
-                    oldEntry.flags |= entry.flags;
-                } else {
-                    entries.put(entry.getItemId(), entry);
+            if (encoder.acceptsTurnRelation(turnRelation)) {
+                for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation)) {
+                    TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+                    if (oldEntry != null) {
+                        // merging different encoders
+                        oldEntry.flags |= entry.flags;
+                    } else {
+                        entries.put(entry.getItemId(), entry);
+                    }
                 }
             }
         }
@@ -457,7 +460,7 @@ public void processRelation(ReaderRelation relation) {
             edgeInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
             inExplorerMap.put(encoder, edgeInExplorer);
         }
-        return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
+        return getRestrictionAsEntries(turnRelation, encoder, edgeOutExplorer, edgeInExplorer, this);
     }
 
     /**
@@ -859,7 +862,25 @@ private long createNewNodeId() {
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation(ReaderRelation relation) {
-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
+        String tagRestriction = "";
+        String vehicleTypeRestricted = "";
+        List<String> vehicleTypesExcept = new ArrayList<>();
+        if (relation.hasTag("restriction")) {
+            tagRestriction = relation.getTag("restriction");
+        } else if (relation.hasTagStartsWith("restriction:")) {
+            vehicleTypeRestricted = relation.getKeyStartsWith("restriction:");
+            tagRestriction = relation.getTag(vehicleTypeRestricted);
+            vehicleTypeRestricted = vehicleTypeRestricted.replace("restriction:", "").trim();
+        }
+        if (relation.hasTag("except")) {
+            String tagExcept = relation.getTag("except");
+            if (!Helper.isEmpty(tagExcept)) {
+                List<String> vehicleTypes = new ArrayList<>(Arrays.asList(tagExcept.split(";")));
+                for (String vehicleType : vehicleTypes)
+                    vehicleTypesExcept.add(vehicleType.trim());
+            }
+        }
+        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(tagRestriction);
         if (type != OSMTurnRelation.Type.UNSUPPORTED) {
             long fromWayID = -1;
             long viaNodeID = -1;
@@ -877,12 +898,97 @@ OSMTurnRelation createTurnRelation(ReaderRelation relation) {
                 }
             }
             if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0) {
-                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+                OSMTurnRelation osmTurnRelation = new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+                osmTurnRelation.setVehicleTypeRestricted(vehicleTypeRestricted);
+                osmTurnRelation.addVehicleTypesExcept(vehicleTypesExcept);
+                return osmTurnRelation;
             }
         }
         return null;
     }
 
+    /**
+     * Transforms this relation into a collection of turn cost entries
+     * <p>
+     *
+     * @param edgeOutExplorer an edge filter which only allows outgoing edges
+     * @param edgeInExplorer  an edge filter which only allows incoming edges
+     * @return a collection of node cost entries which can be added to the graph later
+     */
+    public static Collection<TurnCostTableEntry> getRestrictionAsEntries(OSMTurnRelation osmTurnRelation, TurnCostEncoder encoder,
+                                                                  EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader) {
+        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(osmTurnRelation.getViaOsmNodeId());
+
+        try {
+            // street with restriction was not included (access or tag limits etc)
+            if (nodeVia == OSMReader.EMPTY_NODE)
+                return Collections.emptyList();
+
+            int edgeIdFrom = EdgeIterator.NO_EDGE;
+
+            // get all incoming edges and receive the edge which is defined by fromOsm
+            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
+
+            while (iter.next()) {
+                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == osmTurnRelation.getOsmIdFrom()) {
+                    edgeIdFrom = iter.getEdge();
+                    break;
+                }
+            }
+
+            if (!EdgeIterator.Edge.isValid(edgeIdFrom))
+                return Collections.emptyList();
+
+            final Collection<TurnCostTableEntry> entries = new ArrayList<>();
+            // get all outgoing edges of the via node
+            iter = edgeOutExplorer.setBaseNode(nodeVia);
+            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
+            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
+            while (iter.next()) {
+                int edgeId = iter.getEdge();
+                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+                if (edgeId != edgeIdFrom && osmTurnRelation.getRestriction() == OSMTurnRelation.Type.ONLY && wayId != osmTurnRelation.getOsmIdTo()
+                        || osmTurnRelation.getRestriction() == OSMTurnRelation.Type.NOT && wayId == osmTurnRelation.getOsmIdTo() && wayId >= 0) {
+                    final TurnCostTableEntry entry = new TurnCostTableEntry();
+                    entry.nodeVia = nodeVia;
+                    entry.edgeFrom = edgeIdFrom;
+                    entry.edgeTo = iter.getEdge();
+                    entry.flags = encoder.getTurnFlags(true, 0);
+                    entries.add(entry);
+
+                    if (osmTurnRelation.getRestriction() == OSMTurnRelation.Type.NOT)
+                        break;
+                }
+            }
+            return entries;
+        } catch (Exception e) {
+            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + osmTurnRelation.getViaOsmNodeId(), e);
+        }
+    }
+
+    /**
+     * Helper class to processing purposes only
+     */
+    public static class TurnCostTableEntry {
+        public int edgeFrom;
+        public int nodeVia;
+        public int edgeTo;
+        public long flags;
+
+        /**
+         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+         * are involved.
+         */
+        public long getItemId() {
+            return ((long) edgeFrom) << 32 | ((long) edgeTo);
+        }
+
+        @Override
+        public String toString() {
+            return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
+        }
+    }
+
     /**
      * Filter method, override in subclass
      */
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
deleted file mode 100644
index 8319df53d4..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.osm;
-
-import com.graphhopper.routing.util.TurnCostEncoder;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-
-import java.util.*;
-
-/**
- * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
- * <p>
- *
- * @author Karl Hbner
- */
-public class OSMTurnRelation {
-    private final long fromOsmWayId;
-    private final long viaOsmNodeId;
-    private final long toOsmWayId;
-    private final Type restriction;
-
-    OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
-        this.fromOsmWayId = fromWayID;
-        this.viaOsmNodeId = viaNodeID;
-        this.toOsmWayId = toWayID;
-        this.restriction = restrictionType;
-    }
-
-    long getOsmIdFrom() {
-        return fromOsmWayId;
-    }
-
-    long getOsmIdTo() {
-        return toOsmWayId;
-    }
-
-    /**
-     * Transforms this relation into a collection of turn cost entries
-     * <p>
-     *
-     * @param edgeOutExplorer an edge filter which only allows outgoing edges
-     * @param edgeInExplorer  an edge filter which only allows incoming edges
-     * @return a collection of node cost entries which can be added to the graph later
-     */
-    public Collection<TurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
-                                                                  EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader) {
-        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
-
-        try {
-            // street with restriction was not included (access or tag limits etc)
-            if (nodeVia == OSMReader.EMPTY_NODE)
-                return Collections.emptyList();
-
-            int edgeIdFrom = EdgeIterator.NO_EDGE;
-
-            // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
-
-            while (iter.next()) {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId) {
-                    edgeIdFrom = iter.getEdge();
-                    break;
-                }
-            }
-
-            if (edgeIdFrom == EdgeIterator.NO_EDGE)
-                return Collections.emptyList();
-
-            final Collection<TurnCostTableEntry> entries = new ArrayList<>();
-            // get all outgoing edges of the via node
-            iter = edgeOutExplorer.setBaseNode(nodeVia);
-            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
-            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
-            while (iter.next()) {
-                int edgeId = iter.getEdge();
-                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
-                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {
-                    final TurnCostTableEntry entry = new TurnCostTableEntry();
-                    entry.nodeVia = nodeVia;
-                    entry.edgeFrom = edgeIdFrom;
-                    entry.edgeTo = iter.getEdge();
-                    entry.flags = encoder.getTurnFlags(true, 0);
-                    entries.add(entry);
-
-                    if (this.restriction == Type.NOT)
-                        break;
-                }
-            }
-            return entries;
-        } catch (Exception e) {
-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
-    }
-
-    enum Type {
-        UNSUPPORTED, NOT, ONLY;
-
-        private static final Map<String, Type> tags = new HashMap<>();
-
-        static {
-            tags.put("no_left_turn", NOT);
-            tags.put("no_right_turn", NOT);
-            tags.put("no_straight_on", NOT);
-            tags.put("no_u_turn", NOT);
-            tags.put("only_right_turn", ONLY);
-            tags.put("only_left_turn", ONLY);
-            tags.put("only_straight_on", ONLY);
-        }
-
-        public static Type getRestrictionType(String tag) {
-            Type result = null;
-            if (tag != null) {
-                result = tags.get(tag);
-            }
-            return (result != null) ? result : UNSUPPORTED;
-        }
-    }
-
-    /**
-     * Helper class to processing purposes only
-     */
-    public static class TurnCostTableEntry {
-        public int edgeFrom;
-        public int nodeVia;
-        public int edgeTo;
-        public long flags;
-
-        /**
-         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
-         * are involved.
-         */
-        public long getItemId() {
-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
-        }
-
-        @Override
-        public String toString() {
-            return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
-        }
-    }
-
-}
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 336dea3e5f..6f99e72414 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -101,7 +101,7 @@ public void testMonacoWithInstructions() {
         InstructionList il = arsp.getInstructions();
         assertEquals(21, il.size());
 
-        // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
+        // TODO roundabout fine tuning -> enter + leave roundabout (+ two roundabouts -> is it necessary if we do not leave the street?)
         Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
         assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
         assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
@@ -439,13 +439,13 @@ public void testMonacoPathDetails() {
         request.addPoint(new GHPoint(43.74958, 7.436566));
         request.addPoint(new GHPoint(43.727687, 7.418737));
         request.setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr);
-        request.setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
+        request.setPathDetails(Collections.singletonList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = hopper.route(request);
 
         PathWrapper arsp = rsp.getBest();
         Map<String, List<PathDetail>> details = arsp.getPathDetails();
-        assertTrue(details.size() == 1);
+        assertEquals(1, details.size());
         List<PathDetail> detailList = details.get(Parameters.Details.AVERAGE_SPEED);
         assertEquals(1, detailList.size());
         assertEquals(5.0, detailList.get(0).getValue());
@@ -565,7 +565,7 @@ public void testMonacoStraightVia() {
     }
 
     @Test
-    public void testSRTMWithInstructions() throws Exception {
+    public void testSRTMWithInstructions() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(osmFile).
                 setStoreOnFlush(true).
@@ -608,7 +608,7 @@ public void testSRTMWithInstructions() throws Exception {
 
         assertEquals(54, arsp.getPoints().size());
         assertEquals(new GHPoint3D(43.73068455771767, 7.421283689825812, 62.0), arsp.getPoints().get(0));
-        assertEquals(new GHPoint3D(43.727680946587874, 7.4191987684222065, 11.0), arsp.getPoints().get(arsp.getPoints().size()-1));
+        assertEquals(new GHPoint3D(43.727680946587874, 7.4191987684222065, 11.0), arsp.getPoints().get(arsp.getPoints().size() - 1));
 
         assertEquals(62, arsp.getPoints().get(0).getElevation(), 1e-2);
         assertEquals(66, arsp.getPoints().get(1).getElevation(), 1e-2);
@@ -836,7 +836,7 @@ private void checkMultiVehiclesWithCH(GraphHopper tmpHopper) {
     }
 
     @Test
-    public void testIfCHIsUsed() throws Exception {
+    public void testIfCHIsUsed() {
         // route directly after import
         executeCHFootRoute();
 
@@ -853,7 +853,7 @@ private void executeCHFootRoute() {
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(EncodingManager.create(tmpImportVehicles));
-        tmpHopper.getCHFactoryDecorator().setWeightingsAsStrings(weightCalcStr);
+        tmpHopper.getCHFactoryDecorator().setCHProfileStrings(weightCalcStr);
         tmpHopper.importOrLoad();
 
         // same query as in testMonacoWithInstructions
@@ -904,7 +904,7 @@ public void testPathDetails1216() {
                         addPoint(new GHPoint(49.984565, 11.499188)).
                         addPoint(new GHPoint(49.9847, 11.499612)).
                         setVehicle("car").setWeighting("fastest").
-                        setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
+                        setPathDetails(Collections.singletonList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = tmpHopper.route(req);
 
@@ -924,7 +924,7 @@ public void testPathDetailsSamePoint() {
                 addPoint(new GHPoint(49.984352, 11.498802)).
                 addPoint(new GHPoint(49.984352, 11.498802)).
                 setVehicle("car").setWeighting("fastest").
-                setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
+                setPathDetails(Collections.singletonList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = tmpHopper.route(req);
 
@@ -942,11 +942,11 @@ public void testFlexMode_631() {
                 setEncodingManager(EncodingManager.create("car"));
 
         tmpHopper.getCHFactoryDecorator().setEnabled(true).
-                setWeightingsAsStrings(Arrays.asList("fastest")).
+                setCHProfilesAsStrings(Collections.singletonList("fastest")).
                 setDisablingAllowed(true);
 
         tmpHopper.getLMFactoryDecorator().setEnabled(true).
-                setWeightingsAsStrings(Arrays.asList("fastest|maximum=2000")).
+                setWeightingsAsStrings(Collections.singletonList("fastest|maximum=2000")).
                 setDisablingAllowed(true);
 
         tmpHopper.importOrLoad();
@@ -1002,20 +1002,12 @@ public void testTurnCostsOnOff() {
                 setEncodingManager(EncodingManager.create("car|turn_costs=true"));
         tmpHopper.importOrLoad();
 
-        // with turn costs (default if non-CH and turn cost enabled)
-        GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
-        GHResponse rsp = tmpHopper.route(req);
-        assertEquals(1044, rsp.getBest().getDistance(), 1);
-
-        // without turn costs
-        req.getHints().put(Routing.EDGE_BASED, "false");
-        rsp = tmpHopper.route(req);
-        assertEquals(400, rsp.getBest().getDistance(), 1);
-
-        // with turn costs
-        req.getHints().put(Routing.EDGE_BASED, "true");
-        rsp = tmpHopper.route(req);
-        assertEquals(1044, rsp.getBest().getDistance(), 1);
+        // no edge_based parameter -> use edge-based (since encoder supports it and no CH)
+        assertMoscowEdgeBased(tmpHopper, "none", false);
+        // edge_based=false -> use node-based
+        assertMoscowNodeBased(tmpHopper, "false", false);
+        // edge_based=true -> use edge-based
+        assertMoscowEdgeBased(tmpHopper, "true", false);
     }
 
     @Test
@@ -1030,18 +1022,12 @@ public void testTurnCostsOnOffCH() {
         tmpHopper.getCHFactoryDecorator().setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_AND_NODE);
         tmpHopper.importOrLoad();
 
-        // without turn costs
-        GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
-        req.getHints().put(Routing.EDGE_BASED, "false");
-        GHResponse rsp = tmpHopper.route(req);
-        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        assertEquals(400, rsp.getBest().getDistance(), 1);
-
-        // with turn costs                
-        req.getHints().put(Routing.EDGE_BASED, "true");
-        rsp = tmpHopper.route(req);
-        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        assertEquals(1044, rsp.getBest().getDistance(), 1);
+        // no edge_based parameter -> use edge-based (because its there)
+        assertMoscowEdgeBased(tmpHopper, "none", true);
+        // edge_based=false -> use node-based
+        assertMoscowNodeBased(tmpHopper, "false", true);
+        // edge_based=true -> use edge-based
+        assertMoscowEdgeBased(tmpHopper, "true", true);
     }
 
     @Test
@@ -1057,22 +1043,115 @@ public void testCHOnOffWithTurnCosts() {
                 .setDisablingAllowed(true);
         tmpHopper.importOrLoad();
 
-        // with CH
-        GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
-        req.getHints().put(Routing.EDGE_BASED, "true");
-        req.getHints().put(CH.DISABLE, "false");
-        GHResponse rsp1 = tmpHopper.route(req);
-        assertFalse(rsp1.getErrors().toString(), rsp1.hasErrors());
-        assertEquals(1044, rsp1.getBest().getDistance(), 1);
-
-        // without CH      
-        req.getHints().put(Routing.EDGE_BASED, "true");
-        req.getHints().put(CH.DISABLE, "true");
-        GHResponse rsp2 = tmpHopper.route(req);
-        assertFalse(rsp2.getErrors().toString(), rsp2.hasErrors());
-        assertEquals(1044, rsp2.getBest().getDistance(), 1);
+        // with CH -> edge-based
+        GHResponse rsp1 = assertMoscowEdgeBased(tmpHopper, "true", false);
+        // without CH -> also edge-based
+        GHResponse rsp2 = assertMoscowEdgeBased(tmpHopper, "true", true);
         // just a quick check that we did not run the same algorithm twice
         assertNotEquals(rsp1.getHints().get("visited_nodes.sum", "_"), rsp2.getHints().get("visited_nodes.sum", "_"));
     }
 
+    @Test
+    public void testNodeBasedCHOnlyButTurnCostForNonCH() {
+        // before edge-based CH was added a common case was to use edge-based without CH and CH for node-based
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/moscow.osm.gz").
+                setStoreOnFlush(true).
+                setCHEnabled(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
+        tmpHopper.getCHFactoryDecorator()
+                .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.OFF)
+                .setDisablingAllowed(true);
+        tmpHopper.importOrLoad();
+
+        // without CH -> use edge-based unless disabled explicitly
+        assertMoscowEdgeBased(tmpHopper, "none", false);
+        assertMoscowEdgeBased(tmpHopper, "true", false);
+        assertMoscowNodeBased(tmpHopper, "false", false);
+
+        // with CH -> use node-based unless edge_based is enabled explicitly (which should give an error)
+        assertMoscowNodeBased(tmpHopper, "none", true);
+        assertMoscowNodeBased(tmpHopper, "false", true);
+        GHResponse rsp = runMoscow(tmpHopper, "true", true);
+        assertEquals(1, rsp.getErrors().size());
+        assertTrue(rsp.getErrors().toString().contains("Found a node-based CH profile"));
+        assertTrue(rsp.getErrors().toString().contains("but requested edge-based CH"));
+    }
+
+    @Test
+    public void testEdgeBasedByDefaultIfOnlyEdgeBased() {
+        // when there is only one edge-based CH profile, there is no need to specify edge_based=true explicitly,
+        // see #1637
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/moscow.osm.gz").
+                setStoreOnFlush(true).
+                setCHEnabled(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
+        tmpHopper.getCHFactoryDecorator().setDisablingAllowed(true);
+        tmpHopper.getCHFactoryDecorator().setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE);
+        tmpHopper.importOrLoad();
+
+        // even when we omit the edge_based parameter we get edge-based CH, unless we disable it explicitly
+        assertMoscowEdgeBased(tmpHopper, "none", true);
+        assertMoscowEdgeBased(tmpHopper, "true", true);
+        GHResponse rsp = runMoscow(tmpHopper, "false", true);
+        assertTrue(rsp.hasErrors());
+        assertTrue(rsp.getErrors().toString().contains("Found 1 edge-based CH profile"));
+        assertTrue(rsp.getErrors().toString().contains("but requested node-based CH"));
+    }
+
+    private GHResponse assertMoscowNodeBased(GraphHopper tmpHopper, String edgeBasedParam, boolean ch) {
+        GHResponse rsp = runMoscow(tmpHopper, edgeBasedParam, ch);
+        assertEquals(400, rsp.getBest().getDistance(), 1);
+        return rsp;
+    }
+
+    private GHResponse assertMoscowEdgeBased(GraphHopper tmpHopper, String edgeBasedParam, boolean ch) {
+        GHResponse rsp = runMoscow(tmpHopper, edgeBasedParam, ch);
+        assertEquals(1044, rsp.getBest().getDistance(), 1);
+        return rsp;
+    }
+
+    private GHResponse runMoscow(GraphHopper tmpHopper, String edgeBasedParam, boolean ch) {
+        GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
+        if (edgeBasedParam.equals("true") || edgeBasedParam.equals("false")) {
+            req.getHints().put(Routing.EDGE_BASED, edgeBasedParam);
+        } else {
+            req.getHints().remove(Routing.EDGE_BASED);
+        }
+        req.getHints().put(CH.DISABLE, !ch);
+        return tmpHopper.route(req);
+    }
+
+    @Test
+    public void testEdgeBasedRequiresTurnCostSupport() {
+        GHPoint p = new GHPoint(43.727687, 7.418737);
+        GHPoint q = new GHPoint(43.74958, 7.436566);
+        GHRequest req = new GHRequest(p, q);
+        req.getHints().put(Routing.EDGE_BASED, true);
+        req.setVehicle("foot");
+        GHResponse rsp = hopper.route(req);
+        assertTrue("using edge-based for encoder without turncost support should be an error, but got:\n" + rsp.getErrors(),
+                rsp.getErrors().toString().contains("You need a turn cost extension to make use of edge_based=true, e.g. use car|turn_costs=true"));
+    }
+
+    @Test
+    public void testEncoderWithTurnCostSupport_stillAllows_nodeBasedRouting() {
+        // see #1698
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/moscow.osm.gz").
+                setGraphHopperLocation(tmpGraphFile).
+                setCHEnabled(false).
+                setEncodingManager(EncodingManager.create("foot,car|turn_costs=true"));
+        tmpHopper.importOrLoad();
+        GHPoint p = new GHPoint(55.813357, 37.5958585);
+        GHPoint q = new GHPoint(55.811042, 37.594689);
+        GHRequest req = new GHRequest(p, q);
+        req.setVehicle("foot");
+        GHResponse rsp = tmpHopper.route(req);
+        assertEquals("there should not be an error, but was: " + rsp.getErrors(), 0, rsp.getErrors().size());
+    }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index e03131f3d8..087b20de8c 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -152,7 +152,7 @@ public void testQueryLocationIndexWithBBox() {
         final GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
                 setEncodingManager(EncodingManager.create("car")).
                 setCHEnabled(false).
-                setGraphHopperLocation("./target/monacotmp-gh").
+                setGraphHopperLocation(ghLoc).
                 setDataReaderFile("../core/files/monaco.osm.gz");
         gh.importOrLoad();
 
@@ -225,7 +225,7 @@ public void testLoadingWithDifferentCHConfig_issue471() {
             gh.load(ghLoc);
             fail();
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("You loaded a CH graph, but you did not specify graph.ch.weightings"));
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("You loaded a CH graph, but you did not specify any CH weightings in prepare.ch.weightings"));
         }
 
         Helper.removeDir(new File(ghLoc));
@@ -337,7 +337,7 @@ public void testPrepare() {
                 setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
-        instance.getCHFactoryDecorator().setWeightingsAsStrings("shortest");
+        instance.getCHFactoryDecorator().setCHProfileStrings("shortest");
         instance.importOrLoad();
         GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
                 setAlgorithm(DIJKSTRA_BI));
@@ -419,7 +419,7 @@ public void testFootAndCar() {
     }
 
     @Test
-    public void testFailsForWrongConfig() throws IOException {
+    public void testFailsForWrongConfig() {
         instance = new GraphHopperOSM().init(
                 new CmdArgs().
                         put("datareader.file", testOsm3).
@@ -475,6 +475,74 @@ public void testFailsForWrongConfig() throws IOException {
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
+
+        // different encoded values should fail to load
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.encoded_values", "road_class").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoded values do not match"));
+        }
+
+        // different version for car should fail
+        instance = new GraphHopperOSM().setEncodingManager(EncodingManager.create(new FootFlagEncoder(), new CarFlagEncoder() {
+            @Override
+            public int getVersion() {
+                return 0;
+            }
+        })).init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
+        }
+    }
+
+    @Test
+    public void testFailsForWrongEVConfig() {
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setGraphHopperLocation(ghLoc);
+        instance.importOrLoad();
+        // older versions <= 0.12 did not store this property, ensure that we fail to load it
+        instance.getGraphHopperStorage().getProperties().remove("graph.encoded_values");
+        instance.getGraphHopperStorage().flush();
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
+        instance.close();
+
+        // different encoded values should fail to load
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.encoded_values", "road_environment,road_class").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoded values do not match"));
+        }
     }
 
     @Test
@@ -779,7 +847,7 @@ private GraphHopper createSquareGraphInstance(boolean withCH) {
         GraphHopper tmp = new GraphHopperOSM().
                 setCHEnabled(withCH).
                 setEncodingManager(encodingManager);
-        tmp.getCHFactoryDecorator().setWeightingsAsStrings("fastest");
+        tmp.getCHFactoryDecorator().setCHProfileStrings("fastest");
         tmp.setGraphHopperStorage(g);
         tmp.postProcessing();
 
@@ -866,7 +934,7 @@ public void testMultipleCHPreparationsInParallel() {
                 PrepareContractionHierarchies pch = (PrepareContractionHierarchies) raf;
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
-                String name = AbstractWeighting.weightingToFileName(pch.getWeighting(), pch.isEdgeBased());
+                String name = pch.getCHProfile().toFileName();
                 Long singleThreadShortcutCount = shortcutCountMap.get(name);
                 if (singleThreadShortcutCount == null)
                     shortcutCountMap.put(name, pch.getShortcuts());
@@ -879,7 +947,7 @@ public void testMultipleCHPreparationsInParallel() {
 
                 String key = Parameters.CH.PREPARE + "date." + name;
                 String value = tmpGH.getGraphHopperStorage().getProperties().get(key);
-                assertTrue("Properties for " + name + " did NOT contain finish date [" + threadCount + "]", !value.isEmpty());
+                assertFalse("Properties for " + name + " did NOT contain finish date [" + threadCount + "]", value.isEmpty());
             }
             tmpGH.close();
         }
@@ -910,7 +978,7 @@ public void testMultipleLMPreparationsInParallel() {
             for (PrepareLandmarks prepLM : tmpGH.getLMFactoryDecorator().getPreparations()) {
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", prepLM.isPrepared());
 
-                String name = AbstractWeighting.weightingToFileName(prepLM.getWeighting(), false);
+                String name = AbstractWeighting.weightingToFileName(prepLM.getWeighting());
                 Integer singleThreadShortcutCount = landmarkCount.get(name);
                 if (singleThreadShortcutCount == null)
                     landmarkCount.put(name, prepLM.getSubnetworksWithLandmarks());
@@ -923,7 +991,7 @@ public void testMultipleLMPreparationsInParallel() {
 
                 String key = Parameters.Landmark.PREPARE + "date." + name;
                 String value = tmpGH.getGraphHopperStorage().getProperties().get(key);
-                assertTrue("Properties for " + name + " did NOT contain finish date [" + threadCount + "]", !value.isEmpty());
+                assertFalse("Properties for " + name + " did NOT contain finish date [" + threadCount + "]", value.isEmpty());
             }
             tmpGH.close();
         }
@@ -941,10 +1009,10 @@ public void testGetWeightingForCH() {
         Weighting fwTruck = new FastestWeighting(truck);
         RAMDirectory ramDir = new RAMDirectory();
         GraphHopperStorage storage = new GraphHopperStorage(Arrays.asList(fwSimpleTruck, fwTruck), ramDir, em, false, new GraphExtension.NoOpExtension());
-        decorator.addNodeBasedWeighting(fwSimpleTruck);
-        decorator.addNodeBasedWeighting(fwTruck);
-        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwSimpleTruck, TraversalMode.NODE_BASED));
-        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwTruck, TraversalMode.NODE_BASED));
+        decorator.addCHProfile(CHProfile.nodeBased(fwSimpleTruck));
+        decorator.addCHProfile(CHProfile.nodeBased(fwTruck));
+        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, CHProfile.nodeBased(fwSimpleTruck)));
+        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, CHProfile.nodeBased(fwTruck)));
 
         HintsMap wMap = new HintsMap("fastest");
         wMap.put("vehicle", "truck");
@@ -953,10 +1021,10 @@ public void testGetWeightingForCH() {
         assertEquals("fastest|simple_truck", ((PrepareContractionHierarchies) decorator.getDecoratedAlgorithmFactory(null, wMap)).getWeighting().toString());
 
         // make sure weighting cannot be mixed
-        decorator.addNodeBasedWeighting(fwTruck);
-        decorator.addNodeBasedWeighting(fwSimpleTruck);
+        decorator.addCHProfile(CHProfile.nodeBased(fwTruck));
+        decorator.addCHProfile(CHProfile.nodeBased(fwSimpleTruck));
         try {
-            decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwSimpleTruck, TraversalMode.NODE_BASED));
+            decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, CHProfile.nodeBased(fwSimpleTruck)));
             fail();
         } catch (Exception ex) {
         }
@@ -964,17 +1032,17 @@ public void testGetWeightingForCH() {
 
     @Test
     public void testGetMultipleWeightingsForCH() {
-        EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder()), 8);
+        EncodingManager em = EncodingManager.create(Collections.singletonList(new CarFlagEncoder()), 8);
 
         GraphHopper tmpGH = new GraphHopperOSM().
                 setStoreOnFlush(false).
                 setEncodingManager(em);
-        tmpGH.getCHFactoryDecorator().setWeightingsAsStrings("fastest", "shortest");
+        tmpGH.getCHFactoryDecorator().setCHProfileStrings("fastest", "shortest");
 
-        assertEquals(2, tmpGH.getCHFactoryDecorator().getWeightingsAsStrings().size());
+        assertEquals(2, tmpGH.getCHFactoryDecorator().getCHProfileStrings().size());
     }
 
-    class TestEncoder extends CarFlagEncoder {
+    private static class TestEncoder extends CarFlagEncoder {
         private final String name;
 
         public TestEncoder(String name) {
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 1a25f0f1c3..9fdcd38584 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -22,10 +22,7 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperIT;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderRelation;
-import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.reader.*;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.profiles.*;
@@ -69,6 +66,7 @@
     private final String fileBarriers = "test-barriers.xml";
     private final String fileTurnRestrictions = "test-restrictions.xml";
     private final String fileRoadAttributes = "test-road-attributes.xml";
+    private final String fileConditionalTurnRestrictions = "test-conditional-turn-restrictions.xml";
     private final String dir = "./target/tmp/test-db";
     private CarFlagEncoder carEncoder;
     private BooleanEncodedValue carAccessEnc;
@@ -725,9 +723,11 @@ public void testReadEleFromDataProvider() {
      */
     @Test
     public void testTurnFlagCombination() {
-        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
-        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
-        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMReader.TurnCostTableEntry turnCostEntry_car = new OSMReader.TurnCostTableEntry();
+        final OSMReader.TurnCostTableEntry turnCostEntry_foot = new OSMReader.TurnCostTableEntry();
+        final OSMReader.TurnCostTableEntry turnCostEntry_bike = new OSMReader.TurnCostTableEntry();
+
+        final OSMTurnRelation osmTurnRelation = new OSMTurnRelation(1, 1,1, OSMTurnRelation.Type.NOT);
 
         CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
         FootFlagEncoder foot = new FootFlagEncoder();
@@ -737,7 +737,7 @@ public void testTurnFlagCombination() {
         GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
         OSMReader reader = new OSMReader(ghStorage) {
             @Override
-            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation(FlagEncoder encoder,
+            public Collection<OSMReader.TurnCostTableEntry> analyzeTurnRelation(FlagEncoder encoder,
                                                                                       OSMTurnRelation turnRelation) {
                 // simulate by returning one turn cost entry directly
                 if (encoder.toString().equalsIgnoreCase("car")) {
@@ -770,12 +770,12 @@ public void testTurnFlagCombination() {
         long assertFlag2 = turnCostEntry_bike.flags;
 
         // combine flags of all encoders
-        Collection<OSMTurnRelation.TurnCostTableEntry> entries = reader.analyzeTurnRelation(null);
+        Collection<OSMReader.TurnCostTableEntry> entries = reader.analyzeTurnRelation(osmTurnRelation);
 
         // we expect two different turnCost entries
         assertEquals(2, entries.size());
 
-        for (OSMTurnRelation.TurnCostTableEntry entry : entries) {
+        for (OSMReader.TurnCostTableEntry entry : entries) {
             if (entry.edgeFrom == 1) {
                 // the first entry provides turn flags for car and foot only
                 assertEquals(assertFlag1, entry.flags);
@@ -800,6 +800,70 @@ public void testTurnFlagCombination() {
         }
     }
 
+    @Test
+    public void testConditionalTurnRestriction() {
+        GraphHopper hopper = new GraphHopperFacade(fileConditionalTurnRestrictions, true, "").
+                importOrLoad();
+
+        Graph graph = hopper.getGraphHopperStorage();
+        assertEquals(8, graph.getNodes());
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
+
+        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
+        int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
+        int n3 = AbstractGraphStorageTester.getIdOf(graph, 52, 11);
+        int n4 = AbstractGraphStorageTester.getIdOf(graph, 52, 12);
+        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
+        int n6 = AbstractGraphStorageTester.getIdOf(graph, 51, 11);
+        int n8 = AbstractGraphStorageTester.getIdOf(graph, 54, 11);
+
+        int edge1_6 = GHUtility.getEdge(graph, n1, n6).getEdge();
+        int edge2_3 = GHUtility.getEdge(graph, n2, n3).getEdge();
+        int edge3_4 = GHUtility.getEdge(graph, n3, n4).getEdge();
+        int edge3_8 = GHUtility.getEdge(graph, n3, n8).getEdge();
+
+        int edge3_2 = GHUtility.getEdge(graph, n3, n2).getEdge();
+        int edge4_3 = GHUtility.getEdge(graph, n4, n3).getEdge();
+        int edge8_3 = GHUtility.getEdge(graph, n8, n3).getEdge();
+
+        int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
+        int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
+        int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
+
+        // (2-3)->(3-4) only_straight_on except bicycle = (2-3)->(3-8) restricted for car
+        // (4-3)->(3-8) no_right_turn dedicated to motorcar = (4-3)->(3-8) restricted for car
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
+
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
+
+        // u-turn except bus;bicycle restriction for (6-1)->(1-6) but not for (1-6)->(6-1)
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
+
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
+
+        // (4-5)->(5-6) right_turn_only dedicated to motorcar = (4-5)->(5-1) restricted
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6)));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
+
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6)));
+        assertFalse(bikeEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)));
+    }
+
     @Test
     public void testPreferredLanguage() {
         GraphHopper hopper = new GraphHopperFacade(file1, false, "de").importOrLoad();
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
index 9faf348c72..65fcb06154 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
@@ -17,7 +17,8 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.osm.OSMTurnRelation.Type;
+import com.graphhopper.reader.OSMTurnRelation;
+import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -70,12 +71,12 @@ public long getOsmIdOfInternalEdge(int edgeId) {
 
         // TYPE == ONLY
         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
-        Collection<OSMTurnRelation.TurnCostTableEntry> result
-                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        Collection<OSMReader.TurnCostTableEntry> result
+                = OSMReader.getRestrictionAsEntries(instance, encoder, edgeExplorer, edgeExplorer, osmReader);
 
         assertEquals(2, result.size());
-        Iterator<OSMTurnRelation.TurnCostTableEntry> iter = result.iterator();
-        OSMTurnRelation.TurnCostTableEntry entry = iter.next();
+        Iterator<OSMReader.TurnCostTableEntry> iter = result.iterator();
+        OSMReader.TurnCostTableEntry entry = iter.next();
         assertEquals(4, entry.edgeFrom);
         assertEquals(6, entry.edgeTo);
         assertEquals(3, entry.nodeVia);
@@ -87,7 +88,7 @@ public long getOsmIdOfInternalEdge(int edgeId) {
 
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
-        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        result = OSMReader.getRestrictionAsEntries(instance, encoder, edgeExplorer, edgeExplorer, osmReader);
 
         assertEquals(1, result.size());
         iter = result.iterator();
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 1ea121c3d8..f3ef03f868 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -569,7 +569,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
 
             if (withCH)
                 hopper.getCHFactoryDecorator().
-                        addWeighting(weightStr).
+                        addCHProfileAsString(weightStr).
                         setEnabled(true).
                         setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE).
                         setDisablingAllowed(true);
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java b/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java
index ae100f56be..8021cac9aa 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java
@@ -41,11 +41,9 @@
     // make sure to increase xmx/xms for the JVM created by the surefire plugin in parent pom.xml
     private static final String OSM_FILE = "../local/maps/berlin-latest.osm.pbf";
 
-    private final Weighting baseWeighting;
-    private final Weighting trafficWeighting;
     private final GraphHopperStorage ghStorage;
-    private final CHGraphImpl baseCHGraph;
-    private final CHGraphImpl trafficCHGraph;
+    private final CHGraph baseCHGraph;
+    private final CHGraph trafficCHGraph;
     private int maxDeviationPercentage;
 
     @Parameters(name = "maxDeviationPercentage = {0}")
@@ -57,12 +55,12 @@ public TrafficChangeWithNodeOrderingReusingTest(int maxDeviationPercentage) {
         this.maxDeviationPercentage = maxDeviationPercentage;
         FlagEncoder encoder = new CarFlagEncoder();
         EncodingManager em = EncodingManager.create(encoder);
-        baseWeighting = new FastestWeighting(encoder);
-        trafficWeighting = new RandomDeviationWeighting(baseWeighting, maxDeviationPercentage);
+        CHProfile baseProfile = CHProfile.nodeBased(new FastestWeighting(encoder));
+        CHProfile trafficProfile = CHProfile.nodeBased(new RandomDeviationWeighting(baseProfile.getWeighting(), maxDeviationPercentage));
         Directory dir = new RAMDirectory("traffic-change-test");
-        ghStorage = new GraphHopperStorage(Arrays.asList(baseWeighting, trafficWeighting), dir, em, false, new GraphExtension.NoOpExtension());
-        baseCHGraph = ghStorage.getGraph(CHGraphImpl.class, baseWeighting);
-        trafficCHGraph = ghStorage.getGraph(CHGraphImpl.class, trafficWeighting);
+        ghStorage = new GraphHopperStorage(Arrays.asList(baseProfile, trafficProfile), dir, em, false, new GraphExtension.NoOpExtension());
+        baseCHGraph = ghStorage.getCHGraph(baseProfile);
+        trafficCHGraph = ghStorage.getCHGraph(trafficProfile);
     }
 
     @Test
@@ -79,7 +77,7 @@ public void testPerformanceForRandomTrafficChange() throws IOException {
         ghStorage.freeze();
 
         // create CH
-        PrepareContractionHierarchies basePch = new PrepareContractionHierarchies(baseCHGraph, baseWeighting, TraversalMode.NODE_BASED);
+        PrepareContractionHierarchies basePch = new PrepareContractionHierarchies(baseCHGraph);
         basePch.doWork();
 
         // check correctness & performance
@@ -87,7 +85,7 @@ public void testPerformanceForRandomTrafficChange() throws IOException {
         runPerformanceTest(ghStorage, baseCHGraph, basePch, seed, numQueries);
 
         // now we re-use the contraction order from the previous contraction and re-run it with the traffic weighting
-        PrepareContractionHierarchies trafficPch = new PrepareContractionHierarchies(trafficCHGraph, trafficWeighting, TraversalMode.NODE_BASED)
+        PrepareContractionHierarchies trafficPch = new PrepareContractionHierarchies(trafficCHGraph)
                 .useFixedNodeOrdering(baseCHGraph.getNodeOrderingProvider());
         trafficPch.doWork();
 
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-conditional-turn-restrictions.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-conditional-turn-restrictions.xml
new file mode 100644
index 0000000000..36e7397117
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-conditional-turn-restrictions.xml
@@ -0,0 +1,129 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+    <!-- 
+       1~~~2
+       |\  |
+       | 6 3~~8
+       |/  |
+       5~~~4~~7
+       
+       
+      (2,3)->(3,4): straight_only
+      (4,3)->(3,8): no_right_turn
+      (4,5)->(5,6): right_turn_only
+      (6,1)->(1,6): no_u_turn
+    -->
+
+    <node id="1" lat="50" lon="10"> </node>
+    <node id="2" lat="52" lon="10"> </node>
+    <node id="3" lat="52" lon="11"> </node>
+    <node id="4" lat="52" lon="12"> </node>
+    <node id="5" lat="50" lon="12"> </node>
+    <node id="6" lat="51" lon="11"> </node>
+    <node id="7" lat="54" lon="12"> </node>
+    <node id="8" lat="54" lon="11"> </node>
+                      
+    <!-- 1-2 -->
+    <way id="12">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <tag k="highway" v="motorway" />
+    </way>    
+    
+    <!-- 2-3 -->
+    <way id="23">
+        <nd ref="2"/>        
+        <nd ref="3"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 3-4 -->
+    <way id="34">
+        <nd ref="3"/>     
+        <nd ref="4"/>
+        <tag k="highway" v="motorway" />
+    </way>     
+    
+    <!-- 4-5 -->
+    <way id="45">
+        <nd ref="5"/>     
+        <nd ref="4"/>
+        <tag k="highway" v="motorway" />
+    </way>  
+    
+    <!-- 5-1 -->
+    <way id="51">
+        <nd ref="1"/>     
+        <nd ref="5"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 5-6 -->
+    <way id="56">
+        <nd ref="6"/>     
+        <nd ref="5"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 6-1 -->
+    <way id="61">
+        <nd ref="1"/>     
+        <nd ref="6"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 3-8 -->
+    <way id="38">
+        <nd ref="3"/>     
+        <nd ref="8"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <!-- 4-7 -->
+    <way id="47">
+        <nd ref="4"/>     
+        <nd ref="7"/>
+        <tag k="highway" v="motorway" />
+    </way>
+    
+    <way id="510">
+        <nd ref="5"/>     
+        <nd ref="10"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+        
+    <relation id="1001">
+        <member type="way" ref="23" role="from"/>
+        <member type="way" ref="34" role="to"/>
+        <member type="node" ref="3" role="via"/>
+        <tag k="restriction" v="only_straight_on"/>
+        <tag k="type" v="restriction"/>
+		<tag k="except" v="bicycle"/>
+    </relation>
+        
+    <relation id="1002">
+        <member type="way" ref="34" role="from"/>
+        <member type="way" ref="38" role="to"/>
+        <member type="node" ref="3" role="via"/>
+        <tag k="restriction:motorcar" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+    
+    <relation id="1003">
+        <member type="way" ref="45" role="from"/>
+        <member type="way" ref="56" role="to"/>
+        <member type="node" ref="5" role="via"/>
+        <tag k="restriction:motorcar" v="only_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+    
+    <relation id="1004">
+        <member type="way" ref="61" role="from"/>
+        <member type="way" ref="61" role="to"/>
+        <member type="node" ref="1" role="via"/>
+        <tag k="restriction" v="no_u_turn"/>
+        <tag k="type" v="restriction"/>
+		<tag k="except" v="bus;bicycle"/>
+    </relation>
+    
+</osm>
diff --git a/tools/pom.xml b/tools/pom.xml
index bc70bbb8bb..f9fab3027f 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,17 +5,22 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.13-SNAPSHOT</version>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
diff --git a/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java b/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java
index 266337c9dc..4b76f895b8 100644
--- a/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java
@@ -35,6 +35,7 @@
 import java.util.*;
 
 import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.routing.weighting.TurnWeighting.INFINITE_U_TURN_COSTS;
 import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static java.lang.System.nanoTime;
@@ -75,6 +76,7 @@ private static void testPerformanceAutomaticNodeOrdering(String[] args) {
         final int landmarks = cmdArgs.getInt("landmarks", 0);
         final boolean cleanup = cmdArgs.getBool("cleanup", true);
         final boolean withTurnCosts = cmdArgs.getBool("turncosts", true);
+        final int uTurnCosts = cmdArgs.getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);
         final double errorThreshold = cmdArgs.getDouble("threshold", 0.1);
         final long seed = cmdArgs.getLong("seed", 456);
         final int compIterations = cmdArgs.getInt("comp_iterations", 100);
@@ -129,8 +131,8 @@ private static void testPerformanceAutomaticNodeOrdering(String[] args) {
         LOGGER.info("Import and preparation took {}s", sw.getMillis() / 1000);
 
         if (!quick) {
-            runCompareTest(DIJKSTRA_BI, graphHopper, withTurnCosts, seed, compIterations, errorThreshold, results);
-            runCompareTest(ASTAR_BI, graphHopper, withTurnCosts, seed, compIterations, errorThreshold, results);
+            runCompareTest(DIJKSTRA_BI, graphHopper, withTurnCosts, uTurnCosts, seed, compIterations, errorThreshold, results);
+            runCompareTest(ASTAR_BI, graphHopper, withTurnCosts, uTurnCosts, seed, compIterations, errorThreshold, results);
         }
 
         if (!quick) {
@@ -193,7 +195,7 @@ private static String getStatLine(TreeSet<String> keys, Map<String, String> resu
         return sb.toString();
     }
 
-    private static void runCompareTest(final String algo, final GraphHopper graphHopper, final boolean withTurnCosts,
+    private static void runCompareTest(final String algo, final GraphHopper graphHopper, final boolean withTurnCosts, final int uTurnCosts,
                                        long seed, final int iterations, final double threshold, final PMap results) {
         LOGGER.info("Running compare test for {}, using seed {}", algo, seed);
         Graph g = graphHopper.getGraphHopperStorage();
@@ -229,6 +231,7 @@ public int doCalc(boolean warmup, int run) {
                 req.getHints().put(Parameters.Routing.EDGE_BASED, withTurnCosts);
                 req.getHints().put(Parameters.CH.DISABLE, false);
                 req.getHints().put(Parameters.Landmark.DISABLE, true);
+                req.getHints().put(Parameters.Routing.U_TURN_COSTS, uTurnCosts);
                 req.setAlgorithm(algo);
                 long start = nanoTime();
                 GHResponse chRoute = graphHopper.route(req);
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 9fb0af5d87..e7b3316070 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -26,11 +26,7 @@
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.osm.GraphHopperOSM;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Algorithms;
@@ -93,14 +89,14 @@ protected void prepareCH() {
                 // note that we measure the total time of all (possibly edge&node) CH preparations
                 put(Parameters.CH.PREPARE + "time", sw.stop().getMillis());
                 int edges = getGraphHopperStorage().getEdges();
-                if (!getCHFactoryDecorator().getNodeBasedWeightings().isEmpty()) {
-                    Weighting weighting = getCHFactoryDecorator().getNodeBasedWeightings().get(0);
-                    int edgesAndShortcuts = getGraphHopperStorage().getGraph(CHGraph.class, weighting).getEdges();
+                if (!getCHFactoryDecorator().getNodeBasedCHProfiles().isEmpty()) {
+                    CHProfile chProfile = getCHFactoryDecorator().getNodeBasedCHProfiles().get(0);
+                    int edgesAndShortcuts = getGraphHopperStorage().getCHGraph(chProfile).getEdges();
                     put(Parameters.CH.PREPARE + "node.shortcuts", edgesAndShortcuts - edges);
                 }
-                if (!getCHFactoryDecorator().getEdgeBasedWeightings().isEmpty()) {
-                    Weighting weighting = getCHFactoryDecorator().getEdgeBasedWeightings().get(0);
-                    int edgesAndShortcuts = getGraphHopperStorage().getGraph(CHGraph.class, weighting).getEdges();
+                if (!getCHFactoryDecorator().getEdgeBasedCHProfiles().isEmpty()) {
+                    CHProfile chProfile = getCHFactoryDecorator().getEdgeBasedCHProfiles().get(0);
+                    int edgesAndShortcuts = getGraphHopperStorage().getCHGraph(chProfile).getEdges();
                     put(Parameters.CH.PREPARE + "edge.shortcuts", edgesAndShortcuts - edges);
                 }
             }
@@ -147,14 +143,16 @@ protected DataReader importData() throws IOException {
             GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
             printMiscUnitPerfTests(g, isCH, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
-            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr, true, -1, true, false);
+            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr,
+                    true, false, -1, true, false);
 
             if (hopper.getLMFactoryDecorator().isEnabled()) {
                 System.gc();
                 isLM = true;
                 int activeLMCount = 12;
                 for (; activeLMCount > 3; activeLMCount -= 4) {
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr, true, activeLMCount, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr,
+                            true, false, activeLMCount, true, false);
                 }
 
                 // compareRouting(hopper, vehicleStr, count / 5);
@@ -168,23 +166,31 @@ protected DataReader importData() throws IOException {
                     System.gc();
                     // try just one constellation, often ~4-6 is best
                     int lmCount = 5;
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr, true, lmCount, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr,
+                            true, false, lmCount, true, false);
                 }
 
                 isLM = false;
                 System.gc();
-                if (!hopper.getCHFactoryDecorator().getNodeBasedWeightings().isEmpty()) {
-                    Weighting weighting = hopper.getCHFactoryDecorator().getNodeBasedWeightings().get(0);
-                    CHGraph lg = g.getGraph(CHGraph.class, weighting);
+                if (!hopper.getCHFactoryDecorator().getNodeBasedCHProfiles().isEmpty()) {
+                    CHProfile chProfile = hopper.getCHFactoryDecorator().getNodeBasedCHProfiles().get(0);
+                    CHGraph lg = g.getCHGraph(chProfile);
                     fillAllowedEdges(lg.getAllEdges(), allowedEdges);
                     printMiscUnitPerfTests(lg, isCH, encoder, count * 100, allowedEdges);
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr, true, -1, true, false);
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_sod", vehicleStr, true, -1, false, false);
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr, false, -1, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr,
+                            true, false, -1, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_with_hints", vehicleStr,
+                            true, true, -1, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_sod", vehicleStr,
+                            true, false, -1, false, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr,
+                            false, false, -1, true, false);
                 }
-                if (!hopper.getCHFactoryDecorator().getEdgeBasedWeightings().isEmpty()) {
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge", vehicleStr, true, -1, false, true);
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge_no_instr", vehicleStr, false, -1, false, true);
+                if (!hopper.getCHFactoryDecorator().getEdgeBasedCHProfiles().isEmpty()) {
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge", vehicleStr,
+                            true, false, -1, false, true);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge_no_instr", vehicleStr,
+                            false, false, -1, false, true);
                 }
             }
         } catch (Exception ex) {
@@ -411,7 +417,8 @@ private void compareCHWithAndWithoutSOD(final GraphHopper hopper, String vehicle
 
     private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, final boolean lm,
                                        int count, String prefix, final String vehicle,
-                                       final boolean withInstructions, final int activeLandmarks, final boolean sod, final boolean edgeBased) {
+                                       final boolean withInstructions, final boolean withPointHints,
+                                       final int activeLandmarks, final boolean sod, final boolean edgeBased) {
         final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
@@ -420,6 +427,7 @@ private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, f
         final AtomicInteger failedCount = new AtomicInteger(0);
         final DistanceCalc distCalc = new DistanceCalcEarth();
 
+        final EdgeExplorer edgeExplorer = g.createEdgeExplorer(DefaultEdgeFilter.allEdges(hopper.getEncodingManager().getEncoder(vehicle)));
         final AtomicLong visitedNodesSum = new AtomicLong(0);
 //        final AtomicLong extractTimeSum = new AtomicLong(0);
 //        final AtomicLong calcPointsTimeSum = new AtomicLong(0);
@@ -451,6 +459,17 @@ public int doCalc(boolean warmup, int run) {
                 if (withInstructions)
                     req.setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
 
+
+                if (withPointHints) {
+                    EdgeIterator iter = edgeExplorer.setBaseNode(from);
+                    if (!iter.next())
+                        throw new IllegalArgumentException("wrong 'from' when adding point hint");
+                    EdgeIterator iter2 = edgeExplorer.setBaseNode(to);
+                    if (!iter2.next())
+                        throw new IllegalArgumentException("wrong 'to' when adding point hint");
+                    req.setPointHints(Arrays.asList(iter.getName(), iter2.getName()));
+                }
+
                 // put(algo + ".approximation", "BeelineSimplification").
                 // put(algo + ".epsilon", 2);
 
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index bb7d3f0d91..53876812bb 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -29,10 +29,7 @@
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
@@ -97,8 +94,9 @@ public MiniGraphUI(GraphHopper hopper, boolean debug) {
         boolean ch = true;
         if (ch) {
             map.put(Parameters.Landmark.DISABLE, true);
-            weighting = hopper.getCHFactoryDecorator().getNodeBasedWeightings().get(0);
-            routingGraph = hopper.getGraphHopperStorage().getGraph(CHGraph.class, weighting);
+            CHProfile chProfile = hopper.getCHFactoryDecorator().getNodeBasedCHProfiles().get(0);
+            weighting = chProfile.getWeighting();
+            routingGraph = hopper.getGraphHopperStorage().getCHGraph(chProfile);
 
             final RoutingAlgorithmFactory tmpFactory = hopper.getAlgorithmFactory(map);
             algoFactory = new RoutingAlgorithmFactory() {
diff --git a/web-api/pom.xml b/web-api/pom.xml
index 4e251a56c4..6a220b10a4 100644
--- a/web-api/pom.xml
+++ b/web-api/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web-api</artifactId>
     <packaging>jar</packaging>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper Web API</name>
     <description>JSON Representation of the API classes</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/web-api/src/main/java/com/graphhopper/http/WebHelper.java b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
index b32a4d1b86..1b691ea50f 100644
--- a/web-api/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
@@ -28,6 +28,8 @@
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.text.NumberFormat;
+import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -141,13 +143,16 @@ private static void encodeNumber(StringBuilder sb, int num) {
         sb.append((char) (num));
     }
 
+    /**
+     * This includes the required attribution for OpenStreetMap.
+     * Do not hesitate to you mention us and link us in your about page
+     * https://support.graphhopper.com/support/search/solutions?term=attribution
+     */
+    public static final List<String> COPYRIGHTS = Arrays.asList("GraphHopper", "OpenStreetMap contributors");
+
     public static ObjectNode jsonResponsePutInfo(ObjectNode json, float took) {
-        // Do not hesitate to you mention us and link us in your about page too!
-        // https://support.graphhopper.com/support/search/solutions?term=attribution
         final ObjectNode info = json.putObject("info");
-        info.putArray("copyrights")
-                .add("GraphHopper")
-                .add("OpenStreetMap contributors");
+        info.putPOJO("copyrights", COPYRIGHTS);
         info.put("took", Math.round(took * 1000));
         return json;
     }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
index 15f8532eb5..117ec00c83 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
@@ -19,11 +19,15 @@
 
 import com.bedatadriven.jackson.datatype.jts.JtsModule;
 import com.fasterxml.jackson.annotation.JsonInclude;
-import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.ObjectMapper;
 
 public class Jackson {
+
     public static ObjectMapper newObjectMapper() {
-        ObjectMapper objectMapper = new ObjectMapper();
+        return initObjectMapper(new ObjectMapper());
+    }
+
+    public static ObjectMapper initObjectMapper(ObjectMapper objectMapper) {
         objectMapper.registerModule(new GraphHopperModule());
         objectMapper.registerModule(new JtsModule());
         objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
index 6f782bff26..dd3a8775ff 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
@@ -168,6 +168,16 @@ public static PathWrapper createPathWrapper(ObjectMapper objectMapper, JsonNode
             }
         }
 
+        if (path.has("points_order")) {
+            pathWrapper.setPointsOrder((List<Integer>) objectMapper.convertValue(path.get("points_order"), List.class));
+        } else {
+            List<Integer> list = new ArrayList<>(pathWrapper.getWaypoints().size());
+            for (int i = 0; i < pathWrapper.getWaypoints().size(); i++) {
+                list.add(i);
+            }
+            pathWrapper.setPointsOrder(list);
+        }
+
         double distance = path.get("distance").asDouble();
         long time = path.get("time").asLong();
         pathWrapper.setDistance(distance).setTime(time);
diff --git a/web-bundle/pom.xml b/web-bundle/pom.xml
index 44c2fed1b7..337d43d3ad 100644
--- a/web-bundle/pom.xml
+++ b/web-bundle/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web-bundle</artifactId>
     <packaging>jar</packaging>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper Dropwizard Bundle</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
 
     <dependencies>
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index 1d0a0b8d9d..e18907c63e 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -18,8 +18,6 @@
 
 package com.graphhopper.http;
 
-import com.bedatadriven.jackson.datatype.jts.JtsModule;
-import com.fasterxml.jackson.annotation.JsonInclude;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.databind.BeanDescription;
 import com.fasterxml.jackson.databind.SerializationConfig;
@@ -28,12 +26,13 @@
 import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
 import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
 import com.fasterxml.jackson.databind.util.StdDateFormat;
+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.http.health.GraphHopperHealthCheck;
 import com.graphhopper.http.health.GraphHopperStorageHealthCheck;
 import com.graphhopper.isochrone.algorithm.DelaunayTriangulationIsolineBuilder;
-import com.graphhopper.jackson.GraphHopperModule;
+import com.graphhopper.jackson.Jackson;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
@@ -158,10 +157,13 @@ public void dispose(DelaunayTriangulationIsolineBuilder delaunayTriangulationIso
 
     @Override
     public void initialize(Bootstrap<?> bootstrap) {
+        // See #1440: avoids warning regarding com.fasterxml.jackson.module.afterburner.util.MyClassLoader
+        bootstrap.setObjectMapper(io.dropwizard.jackson.Jackson.newMinimalObjectMapper());
+        // avoids warning regarding com.fasterxml.jackson.databind.util.ClassUtil
+        bootstrap.getObjectMapper().registerModule(new Jdk8Module());
+
+        Jackson.initObjectMapper(bootstrap.getObjectMapper());
         bootstrap.getObjectMapper().setDateFormat(new StdDateFormat());
-        bootstrap.getObjectMapper().registerModule(new JtsModule());
-        bootstrap.getObjectMapper().registerModule(new GraphHopperModule());
-        bootstrap.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
         // Because VirtualEdgeIteratorState has getters which throw Exceptions.
         // http://stackoverflow.com/questions/35359430/how-to-make-jackson-ignore-properties-if-the-getters-throw-exceptions
         bootstrap.getObjectMapper().registerModule(new SimpleModule().setSerializerModifier(new BeanSerializerModifier() {
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
index 7d7ea28a2a..267b9d3052 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
@@ -18,6 +18,7 @@
 
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.json.geo.JsonFeatureCollection;
@@ -44,10 +45,12 @@
     private final GraphHopper graphHopper;
 
     public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
+        ObjectMapper localObjectMapper = objectMapper.copy();
+        localObjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
         String splitAreaLocation = configuration.get(Parameters.Landmark.PREPARE + "split_area_location", "");
         JsonFeatureCollection landmarkSplittingFeatureCollection;
         try (Reader reader = splitAreaLocation.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(splitAreaLocation), UTF_CS)) {
-            landmarkSplittingFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+            landmarkSplittingFeatureCollection = localObjectMapper.readValue(reader, JsonFeatureCollection.class);
         } catch (IOException e1) {
             logger.error("Problem while reading border map GeoJSON. Skipping this.", e1);
             landmarkSplittingFeatureCollection = null;
@@ -57,7 +60,7 @@ public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
         if (!spatialRuleLocation.isEmpty()) {
             final BBox maxBounds = BBox.parseBBoxString(configuration.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
             try (final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS)) {
-                JsonFeatureCollection jsonFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+                JsonFeatureCollection jsonFeatureCollection = localObjectMapper.readValue(reader, JsonFeatureCollection.class);
                 SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, maxBounds, jsonFeatureCollection);
             } catch (IOException e) {
                 throw new RuntimeException(e);
diff --git a/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
index f548ffc1ff..afbce4a2d5 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
@@ -1,14 +1,21 @@
 package com.graphhopper.http;
 
 import com.graphhopper.MultiException;
+import com.graphhopper.util.Helper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.ws.rs.core.Response;
 import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
 
+@Provider
 public class IllegalArgumentExceptionMapper implements ExceptionMapper<IllegalArgumentException> {
+    private static final Logger logger = LoggerFactory.getLogger(IllegalArgumentExceptionMapper.class);
 
     @Override
     public Response toResponse(IllegalArgumentException e) {
+        logger.info("bad request: " + (Helper.isEmpty(e.getMessage()) ? "unknown reason" : e.getMessage()));
         return Response.status(Response.Status.BAD_REQUEST)
                 .entity(new MultiException(e))
                 .build();
diff --git a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
index 03c87e3819..123e903e29 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
@@ -19,6 +19,9 @@
 package com.graphhopper.http;
 
 import com.graphhopper.MultiException;
+import com.graphhopper.util.Helper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.ws.rs.core.Response;
 import javax.ws.rs.ext.ExceptionMapper;
@@ -26,8 +29,13 @@
 
 @Provider
 public class MultiExceptionMapper implements ExceptionMapper<MultiException> {
+    private static final Logger logger = LoggerFactory.getLogger(MultiExceptionMapper.class);
+
     @Override
-    public Response toResponse(MultiException exception) {
-        return Response.status(Response.Status.BAD_REQUEST).entity(exception).build();
+    public Response toResponse(MultiException e) {
+        logger.info("bad request: " + (Helper.isEmpty(e.getMessage()) ? "unknown reason" : e.getErrors()));
+        return Response.status(Response.Status.BAD_REQUEST)
+                .entity(e)
+                .build();
     }
 }
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index 920034f07e..f0aeb8f984 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -60,7 +60,8 @@ public Response doGet(
             @QueryParam("point") GHPoint point,
             @QueryParam("result") @DefaultValue("polygon") String resultStr,
             @QueryParam("time_limit") @DefaultValue("600") long timeLimitInSeconds,
-            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
+            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter,
+            @QueryParam("type") @DefaultValue("json") String respType) {
 
         if (nBuckets > 20 || nBuckets < 1)
             throw new IllegalArgumentException("Number of buckets has to be in the range [1, 20]");
@@ -72,6 +73,10 @@ public Response doGet(
 
         if (!encodingManager.hasEncoder(vehicle))
             throw new IllegalArgumentException("vehicle not supported:" + vehicle);
+        
+        if (respType != null && !respType.equalsIgnoreCase("json") && !respType.equalsIgnoreCase("geojson")) {
+            throw new IllegalArgumentException("Format not supported:" + respType);
+        }
 
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
@@ -117,15 +122,28 @@ public Response doGet(
                 JsonFeature feature = new JsonFeature();
                 HashMap<String, Object> properties = new HashMap<>();
                 properties.put("bucket", features.size());
+                if (respType.equalsIgnoreCase("geojson")) {
+                    properties.put("copyrights", WebHelper.COPYRIGHTS);
+                }
                 feature.setProperties(properties);
                 feature.setGeometry(geometryFactory.createPolygon(polygonShell));
                 features.add(feature);
             }
             ObjectNode json = JsonNodeFactory.instance.objectNode();
-            json.putPOJO("polygons", features);
+            
+            ObjectNode finalJson = null;
+            if (respType.equalsIgnoreCase("geojson")) {
+            	json.put("type", "FeatureCollection");
+                json.putPOJO("features", features);
+                finalJson = json;
+            } else {
+            	json.putPOJO("polygons", features);
+            	finalJson = WebHelper.jsonResponsePutInfo(json, sw.getSeconds());
+            }
+            
             sw.stop();
             logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
-            return Response.ok(WebHelper.jsonResponsePutInfo(json, sw.getSeconds())).header("X-GH-Took", "" + sw.getSeconds() * 1000).
+            return Response.ok(finalJson).header("X-GH-Took", "" + sw.getSeconds() * 1000).
                     build();
 
         } else {
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
index 876199520d..48f6ef20c4 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -18,6 +18,7 @@
 
 package com.graphhopper.resources;
 
+import com.graphhopper.http.WebHelper;
 import com.graphhopper.isochrone.algorithm.ContourBuilder;
 import com.graphhopper.json.geo.JsonFeature;
 import com.graphhopper.reader.gtfs.*;
@@ -70,6 +71,7 @@ public PtIsochroneResource(GtfsStorage gtfsStorage, EncodingManager encodingMana
         public static class Info {
             public List<String> copyrights = new ArrayList<>();
         }
+
         public List<JsonFeature> polygons = new ArrayList<>();
         public Info info = new Info();
     }
@@ -185,8 +187,7 @@ public void onNode(int nodeId) {
                 properties.put("z", targetZ);
                 feature.setProperties(properties);
                 response.polygons.add(feature);
-                response.info.copyrights.add("GraphHopper");
-                response.info.copyrights.add("OpenStreetMap contributors");
+                response.info.copyrights.addAll(WebHelper.COPYRIGHTS);
                 return response;
             } else {
                 return wrap(isoline);
@@ -204,8 +205,7 @@ private Response wrap(Geometry isoline) {
 
         Response response = new Response();
         response.polygons.add(feature);
-        response.info.copyrights.add("GraphHopper");
-        response.info.copyrights.add("OpenStreetMap contributors");
+        response.info.copyrights.addAll(WebHelper.COPYRIGHTS);
         return response;
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 9ae528bac2..55e4eeed1e 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -122,6 +122,7 @@ public Response doGet(
         }
 
         initHints(request.getHints(), uriInfo.getQueryParameters());
+        translateTurnCostsParamToEdgeBased(request, uriInfo.getQueryParameters());
         request.setVehicle(vehicleStr).
                 setWeighting(weighting).
                 setAlgorithm(algoStr).
@@ -163,6 +164,16 @@ public Response doGet(
         }
     }
 
+    private void translateTurnCostsParamToEdgeBased(GHRequest request, MultivaluedMap<String, String> queryParams) {
+        if (queryParams.containsKey(TURN_COSTS)) {
+            List<String> turnCosts = queryParams.get(TURN_COSTS);
+            if (turnCosts.size() != 1) {
+                throw new IllegalArgumentException("You may only specify the turn_costs parameter once");
+            }
+            request.getHints().put(EDGE_BASED, turnCosts.get(0));
+        }
+    }
+
     private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String
             trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
         if (ghRsp.getAll().size() > 1) {
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
index 507d8da0fe..47238430f1 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
@@ -140,10 +140,10 @@ public Response doGet(
                                 sb.append(label.prevCoordinate == null ? 0 : label.prevDistance);
                                 continue;
                             case "time":
-                                sb.append(label.timeInSec);
+                                sb.append(label.timeMillis);
                                 continue;
                             case "prev_time":
-                                sb.append(label.prevCoordinate == null ? 0 : label.prevTimeInSec);
+                                sb.append(label.prevCoordinate == null ? 0 : label.prevTimeMillis);
                                 continue;
                             case "longitude":
                                 sb.append(label.coordinate.lon);
diff --git a/web/package.json b/web/package.json
index ac843db171..7e75b27a82 100644
--- a/web/package.json
+++ b/web/package.json
@@ -27,15 +27,15 @@
     "leaflet.vectorgrid": "1.3.0",
     "browserify": "16.2.0",
     "browserify-swap": "0.2.2",
-    "d3": "5.9.7",
+    "d3": "5.11.0",
     "jquery": "3.4.1",
-    "leaflet": "1.3.1",
+    "leaflet": "1.5.1",
     "leaflet-contextmenu": "1.4.0",
     "leaflet-loading": "0.1.24",
     "moment": "2.22.1",
-    "uglifyify": "5.0.0",
+    "uglifyify": "5.0.2",
     "flatpickr": "4.4.6",
-    "leaflet.heightgraph": "0.1.0"
+    "leaflet.heightgraph": "0.2.0"
   },
   "devDependencies": {
     "jasmine": "3.1.0",
diff --git a/web/pom.xml b/web/pom.xml
index a0eccbb2a5..2d97b534ca 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.13-SNAPSHOT</version>
+    <version>0.14-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.13-SNAPSHOT</version>
+        <version>0.14-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>9.4.2.v20170220</jetty.version>
diff --git a/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
index 3cfa30059d..c3d5f3a70e 100644
--- a/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
+++ b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
@@ -19,17 +19,25 @@
 package com.graphhopper.http;
 
 import com.graphhopper.http.api.JsonErrorEntity;
+import com.graphhopper.util.Helper;
 import io.dropwizard.jersey.validation.ConstraintMessage;
 import io.dropwizard.jersey.validation.JerseyViolationException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
 import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
 import java.util.stream.Collectors;
 
+@Provider
 public class GHJerseyViolationExceptionMapper implements ExceptionMapper<JerseyViolationException> {
+    private static final Logger logger = LoggerFactory.getLogger(GHJerseyViolationExceptionMapper.class);
+
     @Override
     public Response toResponse(final JerseyViolationException e) {
+        logger.info("jersey violation exception: " + (Helper.isEmpty(e.getMessage()) ? "unknown reason" : e.getMessage()));
         return Response
                 .status(ConstraintMessage.determineStatus(e.getConstraintViolations(), e.getInvocable()))
                 .type(MediaType.APPLICATION_JSON)
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index b98b46a7a1..29db6d5e1f 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -22,10 +22,8 @@
 import com.graphhopper.http.resources.RootResource;
 import io.dropwizard.Application;
 import io.dropwizard.bundles.assets.ConfiguredAssetsBundle;
-import io.dropwizard.client.HttpClientBuilder;
 import io.dropwizard.setup.Bootstrap;
 import io.dropwizard.setup.Environment;
-import org.apache.http.client.HttpClient;
 
 import javax.servlet.DispatcherType;
 import java.util.EnumSet;
diff --git a/web/src/main/resources/assets/css/L.Control.Heightgraph.css b/web/src/main/resources/assets/css/L.Control.Heightgraph.css
index 0221dfb7e3..3267718ec9 100755
--- a/web/src/main/resources/assets/css/L.Control.Heightgraph.css
+++ b/web/src/main/resources/assets/css/L.Control.Heightgraph.css
@@ -1,5 +1,5 @@
 .heightgraph-container {
-    background-color: #FFF;
+    background-color: rgba(250,250,250,.8);
     border-radius: 10px;
     display: none;
     cursor: default;
@@ -32,11 +32,10 @@
     position: absolute;
     right: 0;
     display: none;
+    cursor: pointer;
 }
 
 .border-top {
-    stroke-width: 1;
-    stroke: #999;
     fill: none;
 }
 
@@ -51,7 +50,7 @@
 }
 
 .tick, .tick text {
-    fill: #999;
+    fill: #000;
     pointer-events: none;
 }
 
@@ -65,25 +64,24 @@
     fill: none;
     stroke-width: 2px;
     shape-rendering: crispEdges;
-    stroke: lightgrey;
     pointer-events: none;
 }
 
-.focus {
+.focusbox {
     display: none;
     font-size: 10px;
     fill: #000;
     pointer-events: none;
 }
 
-.focus rect {
+.focusbox rect {
     fill: rgba(255, 255, 255, 0.8);
     stroke-width: 1px;
     stroke: #888;
     pointer-events: none;
 }
 
-.focus text {
+.focusbox text {
     font-size: 12px;
 }
 
@@ -114,6 +112,10 @@
     stroke-width: 1px;
 }
 
+.mouse-height-box-text{
+    font-size: 12px;
+}
+
 .grid .tick {
     pointer-events: none;
 }
diff --git a/web/src/main/resources/assets/css/images/marker-icon-2x.png b/web/src/main/resources/assets/css/images/marker-icon-2x.png
index e4abba3b51..88f9e50188 100644
Binary files a/web/src/main/resources/assets/css/images/marker-icon-2x.png and b/web/src/main/resources/assets/css/images/marker-icon-2x.png differ
diff --git a/web/src/main/resources/assets/css/leaflet.css b/web/src/main/resources/assets/css/leaflet.css
index d1b47a1251..609a662453 100644
--- a/web/src/main/resources/assets/css/leaflet.css
+++ b/web/src/main/resources/assets/css/leaflet.css
@@ -25,6 +25,10 @@
 	        user-select: none;
 	  -webkit-user-drag: none;
 	}
+/* Prevents IE11 from highlighting tiles in blue */
+.leaflet-tile::selection {
+	background: transparent;
+}
 /* Safari renders non-retina tile on retina better with this, but Chrome is worse */
 .leaflet-safari .leaflet-tile {
 	image-rendering: -webkit-optimize-contrast;
@@ -45,7 +49,8 @@
 .leaflet-container .leaflet-marker-pane img,
 .leaflet-container .leaflet-shadow-pane img,
 .leaflet-container .leaflet-tile-pane img,
-.leaflet-container img.leaflet-image-layer {
+.leaflet-container img.leaflet-image-layer,
+.leaflet-container .leaflet-tile {
 	max-width: none !important;
 	max-height: none !important;
 	}
@@ -168,7 +173,6 @@
 	opacity: 0;
 	-webkit-transition: opacity 0.2s linear;
 	   -moz-transition: opacity 0.2s linear;
-	     -o-transition: opacity 0.2s linear;
 	        transition: opacity 0.2s linear;
 	}
 .leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
@@ -185,14 +189,12 @@
 .leaflet-zoom-anim .leaflet-zoom-animated {
 	-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
 	   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
-	     -o-transition:      -o-transform 0.25s cubic-bezier(0,0,0.25,1);
 	        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);
 	}
 .leaflet-zoom-anim .leaflet-tile,
 .leaflet-pan-anim .leaflet-tile {
 	-webkit-transition: none;
 	   -moz-transition: none;
-	     -o-transition: none;
 	        transition: none;
 	}
 
@@ -209,6 +211,7 @@
 .leaflet-grab {
 	cursor: -webkit-grab;
 	cursor:    -moz-grab;
+	cursor:         grab;
 	}
 .leaflet-crosshair,
 .leaflet-crosshair .leaflet-interactive {
@@ -224,6 +227,7 @@
 	cursor: move;
 	cursor: -webkit-grabbing;
 	cursor:    -moz-grabbing;
+	cursor:         grabbing;
 	}
 
 /* marker & overlays interactivity */
@@ -237,7 +241,8 @@
 
 .leaflet-marker-icon.leaflet-interactive,
 .leaflet-image-layer.leaflet-interactive,
-.leaflet-pane > svg path.leaflet-interactive {
+.leaflet-pane > svg path.leaflet-interactive,
+svg.leaflet-image-layer.leaflet-interactive path {
 	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
 	pointer-events: auto;
 	}
@@ -494,7 +499,6 @@
 	-webkit-transform: rotate(45deg);
 	   -moz-transform: rotate(45deg);
 	    -ms-transform: rotate(45deg);
-	     -o-transform: rotate(45deg);
 	        transform: rotate(45deg);
 	}
 .leaflet-popup-content-wrapper,
diff --git a/web/src/main/resources/assets/index.html b/web/src/main/resources/assets/index.html
index 1e388fd05d..5899385819 100644
--- a/web/src/main/resources/assets/index.html
+++ b/web/src/main/resources/assets/index.html
@@ -26,12 +26,12 @@
         <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
         <title>Driving Directions - GraphHopper Maps</title>
         <meta name="description" content="A fast route planner for biking, hiking and more! Based on OpenStreetMap including elevation data. Try out for free!"/>
-        <link rel="stylesheet" href="css/leaflet.css?v=1.3.1" />
+        <link rel="stylesheet" href="css/leaflet.css?v=1.5.1" />
         <link rel="stylesheet" href="css/leaflet_numbered_markers.css" />
         <link rel="stylesheet" href="css/leaflet.contextmenu.css?v=1.4.0" />
         <link rel="stylesheet" href="css/leaflet.loading.css?v=0.1.24" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui.min.css" />
-        <link rel="stylesheet" href="css/L.Control.Heightgraph.css?v=0.0.1" />
+        <link rel="stylesheet" href="css/L.Control.Heightgraph.css?v=0.2.0" />
         <link rel="stylesheet" href="css/flatpickr.min.css?v=4.4.6">
         <script type="text/javascript" src="js/main.js?v=0.11.2"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
diff --git a/web/src/main/resources/assets/js/config/options.js b/web/src/main/resources/assets/js/config/options.js
index 97b4c687fd..7855eb6bfa 100644
--- a/web/src/main/resources/assets/js/config/options.js
+++ b/web/src/main/resources/assets/js/config/options.js
@@ -13,5 +13,6 @@ exports.options = {
     routing: {host: '', api_key: ''},
     geocoding: {host: '', api_key: ''},
     thunderforest: {api_key: ''},
-    omniscale: {api_key: ''}
+    omniscale: {api_key: ''},
+    mapilion: {api_key: ''}
 };
\ No newline at end of file
diff --git a/web/src/main/resources/assets/js/config/tileLayers.js b/web/src/main/resources/assets/js/config/tileLayers.js
index a5691983c4..4559271ffd 100644
--- a/web/src/main/resources/assets/js/config/tileLayers.js
+++ b/web/src/main/resources/assets/js/config/tileLayers.js
@@ -3,6 +3,10 @@ var tfAddition = '';
 if (ghenv.thunderforest.api_key)
     tfAddition = '?apikey=' + ghenv.thunderforest.api_key;
 
+var mapilionAddition = '';
+if (ghenv.mapilion.api_key)
+    mapilionAddition = '?key=' + ghenv.mapilion.api_key;
+
 var osAPIKey = 'mapsgraph-bf48cc0b';
 if (ghenv.omniscale.api_key)
     osAPIKey = ghenv.omniscale.api_key;
@@ -21,10 +25,6 @@ var omniscale = L.tileLayer('https://maps.omniscale.net/v2/' +osAPIKey + '/style
     attribution: osmAttr + ', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'
 });
 
-var openMapSurfer = L.tileLayer('http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}', {
-    attribution: osmAttr + ', <a href="http://korona.geog.uni-heidelberg.de/contact.html">GIScience Heidelberg</a>'
-});
-
 // Not an option as too fast over limit.
 // var mapbox= L.tileLayer('https://{s}.tiles.mapbox.com/v4/peterk.map-vkt0kusv/{z}/{x}/{y}' + (retinaTiles ? '@2x' : '') + '.png?access_token=pk.eyJ1IjoicGV0ZXJrIiwiYSI6IkdFc2FJd2MifQ.YUd7dS_gOpT3xrQnB8_K-w', {
 //     attribution: osmAttr + ', <a href="https://www.mapbox.com/about/maps/">&copy; MapBox</a>'
@@ -50,6 +50,11 @@ var thunderNeighbourhood = L.tileLayer('https://{s}.tile.thunderforest.com/neigh
     attribution: osmAttr + ', <a href="https://thunderforest.com/maps/neighbourhood/" target="_blank">Thunderforest Neighbourhood</a>'
 });
 
+var kurvigerLiberty = L.tileLayer('https://{s}-tiles.mapilion.com/raster/styles/kurviger-liberty/{z}/{x}/{y}{r}.png'+mapilionAddition, {
+    subdomains: ['a', 'b', 'c', 'd', 'e'],
+    attribution: osmAttr + ',&copy; <a href="https://kurviger.de/" target="_blank">Kurviger</a> &copy; <a href="https://mapilion.com/attribution" target="_blank">Mapilion</a> <a href="http://www.openmaptiles.org/" target="_blank">&copy; OpenMapTiles</a>'
+});
+
 var wrk = L.tileLayer('http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png', {
     attribution: osmAttr + ', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',
     subdomains: ['topo4', 'topo', 'topo2', 'topo3']
@@ -78,9 +83,9 @@ var availableTileLayers = {
     "TF Cycle": thunderCycle,
     "TF Outdoors": thunderOutdoors,
     "TF Neighbourhood": thunderNeighbourhood,
+    "Kurviger Liberty": kurvigerLiberty,
     "Lyrk": lyrk,
     "WanderReitKarte": wrk,
-    "OpenMapSurfer": openMapSurfer,
     "Sorbian Language": sorbianLang,
     "OpenStreetMap.de": osmde
 };
diff --git a/web/src/main/resources/assets/js/main-template.js b/web/src/main/resources/assets/js/main-template.js
index 47891ead8a..5fad37df81 100644
--- a/web/src/main/resources/assets/js/main-template.js
+++ b/web/src/main/resources/assets/js/main-template.js
@@ -549,7 +549,7 @@ function routeLatLng(request, doQuery) {
             return;
         }
 
-        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation, useMiles, details) {
+        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation, details) {
             return function () {
 
                 var currentGeoJson = geoJsons[currentLayerIndex];
@@ -568,7 +568,7 @@ function routeLatLng(request, doQuery) {
 
                 if (hasElevation) {
                     mapLayer.clearElevation();
-                    mapLayer.addElevation(currentGeoJson, useMiles, details);
+                    mapLayer.addElevation(currentGeoJson, details);
                 }
 
                 headerTabs.find("li").removeClass("current");
@@ -633,7 +633,7 @@ function routeLatLng(request, doQuery) {
             mapLayer.addDataToRoutingLayer(geojsonFeature);
             var oneTab = $("<div class='route_result_tab'>");
             routeResultsDiv.append(oneTab);
-            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation(), request.useMiles, path.details));
+            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation(), path.details));
 
             var routeInfo = $("<div class='route_description'>");
             if (path.description && path.description.length > 0) {
diff --git a/web/src/main/resources/assets/js/map.js b/web/src/main/resources/assets/js/map.js
index 04d2ec9346..22826fc897 100644
--- a/web/src/main/resources/assets/js/map.js
+++ b/web/src/main/resources/assets/js/map.js
@@ -13,6 +13,8 @@ var fullscreenControl = null;
 // Items added in every contextmenu.
 var defaultContextmenuItems;
 
+var expandElevationDiagram = true;
+
 // called if window changes or before map is created
 function adjustMapSize() {
     var mapDiv = $("#map");
@@ -208,6 +210,11 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
         contextmenuInheritItems: false
     };
 
+    // Don't show the elevation graph on small displays
+    if(window.innerWidth < 900 || window.innerHeight < 400){
+        expandElevationDiagram = false;
+    }
+
 }
 
 function focus(coord, zoom, index) {
@@ -266,25 +273,26 @@ module.exports.focus = focus;
 module.exports.initMap = initMap;
 module.exports.adjustMapSize = adjustMapSize;
 
-module.exports.addElevation = function (geoJsonFeature, useMiles, details) {
-
-    // Don't show the elevation graph on small displays
-    if(window.innerWidth < 900 || window.innerHeight < 400){
-        return;
-    }
+module.exports.addElevation = function (geoJsonFeature, details) {
 
     // TODO no option to switch to miles yet
     var options = {
-       width: 600,
-       height: 280,
-       margins: {
-           top: 10,
-           right: 30,
-           bottom: 55,
-           left: 50
-       },
-       position: "bottomright"
-    }
+        width: 600,
+        height: 280,
+        margins: {
+            top: 10,
+            right: 30,
+            bottom: 55,
+            left: 50
+        },
+        xTicks: 6,
+        yTicks: 6,
+        position: "bottomright",
+        expand: expandElevationDiagram,
+        expandCallback: function (expand) {
+            expandElevationDiagram = expand;
+        }
+    };
 
     var GHFeatureCollection = [];
 
@@ -336,9 +344,15 @@ function sliceFeatureCollection(detail, detailKey, geoJsonFeature){
         // It's important to +1
         // Array.slice is exclusive the to element and the feature needs to include the to coordinate
         var to = detailObj[1] + 1;
-        var value = detailObj[2] || "Undefined";
+        var value;
+        try {
+            value = detailObj[2].toString()
+        } catch (error) {
+            console.error(error);
+            value = "Undefined";
+        }
 
-        var tmpPoints = points.slice(from,to)
+        var tmpPoints = points.slice(from,to);
 
         feature.features.push({
           "type": "Feature",
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
index f49c2b25f0..119c8dc0d1 100644
--- a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
@@ -9,12 +9,15 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Polygon;
 import io.dropwizard.testing.junit.DropwizardAppRule;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.JsonNode;
 import org.junit.AfterClass;
 import org.junit.ClassRule;
 import org.junit.Test;
 
 import javax.ws.rs.core.Response;
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 
@@ -117,7 +120,86 @@ public void requestWithShortest() throws Exception {
         polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         assertTrue(polygon0.size() >= 190);
     }
+    
+    @Test
+    public void requestJsonBadType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=xml");
+
+        JsonNode json = parseRequestResponse(response);
+        String message = json.path("message").asText();
 
+        assertEquals(message, "Format not supported:xml");
+    }
+    
+    
+    @Test
+    public void requestJsonWithType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=json");
+        JsonNode json = parseRequestResponse(response);
+        assertTrue(json.has("polygons"));
+        assertTrue(json.has("info"));
+    }
+    
+    @Test
+    public void requestJsonNoType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130");
+        JsonNode json = parseRequestResponse(response);
+        assertTrue(json.has("polygons"));
+        assertTrue(json.has("info"));
+    }
+    
+    @Test
+    public void requestGeoJsonPolygons() throws IOException {        
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=geojson");
+        JsonNode json = parseRequestResponse(response);
+        
+        assertFalse(json.has("polygons"));
+        assertFalse(json.has("info"));
+        
+        assertTrue(json.has("type"));
+        assertEquals(json.path("type").asText(), "FeatureCollection");
+        
+        assertTrue(json.has("features"));
+        
+        JsonNode firstFeature = json.path("features").path(0);
+        assertTrue(firstFeature.isObject());
+        
+        assertTrue(firstFeature.path("properties").has("bucket"));
+        assertTrue(firstFeature.path("properties").has("copyrights"));
+        
+        assertEquals(firstFeature.path("type").asText(), "Feature");
+        assertEquals(firstFeature.path("geometry").path("type").asText(), "Polygon");
+    }
+    
+    @Test
+    public void requestGeoJsonPolygonsBuckets() throws IOException {        
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=geojson&buckets=3");
+        JsonNode json = parseRequestResponse(response);
+        
+        JsonNode features = json.path("features");
+        int length = features.size();
+        JsonNode firstFeature = features.path(0);
+        JsonNode lastFeature = features.path(length - 1);
+        
+        assertEquals(firstFeature.path("properties").path("bucket").asInt(), 0);
+        assertEquals(firstFeature.path("geometry").path("type").asText(), "Polygon");
+        
+        assertEquals(lastFeature.path("properties").path("bucket").asInt(), 2);
+        assertEquals(lastFeature.path("geometry").path("type").asText(), "Polygon");
+    }    
+    
+    private Response requestIsochrone(String path) {
+    	String url = "http://localhost:8080" + path;
+        return app.client().target(url).request().buildGet().invoke();
+    }
+    
+    private JsonNode parseRequestResponse (Response response) throws IOException {
+        String body = response.readEntity(String.class);
+        
+        ObjectMapper objectMapper = new ObjectMapper();
+        return objectMapper.readTree(body);
+    }
+    
     private boolean contains(List polygon, double lat, double lon) {
         int index = 0;
         double lats[] = new double[polygon.size()];
