diff --git a/example/pom.xml b/example/pom.xml
deleted file mode 100644
index b7b27820c..000000000
--- a/example/pom.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-project</artifactId>
-        <version>2.1.0-SNAPSHOT-ABB</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-example</artifactId>
-    <name>Asynchronous Http Client Example</name>
-    <packaging>jar</packaging>
-    <description>
-        The Async Http Client example.
-    </description>
-    <dependencies>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-    </dependencies>
-</project>
diff --git a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
deleted file mode 100644
index 172876113..000000000
--- a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.example.completable;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-
-import java.io.IOException;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-
-public class CompletableFutures {
-    public static void main(String[] args) throws IOException {
-        try(AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
-            asyncHttpClient
-                    .prepareGet("http://www.example.com/")
-                    .execute()
-                    .toCompletableFuture()
-                    .thenApply(Response::getResponseBody)
-                    .thenAccept(System.out::println)
-                    .join();
-        }
-    }
-}
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 76c56ec76..8b04e62e5 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.1.0-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT-ABB</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 1734d2b3d..d4f37427e 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.1.0-SNAPSHOT</version>
+    <version>2.1.0-SNAPSHOT-ABB</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
deleted file mode 100644
index f684b7666..000000000
--- a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright 2013 Ray Tsang
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.asynchttpclient.extra;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.extras.jdeferred.AsyncHttpDeferredObject;
-import org.asynchttpclient.extras.jdeferred.HttpProgress;
-import org.jdeferred.DoneCallback;
-import org.jdeferred.ProgressCallback;
-import org.jdeferred.Promise;
-import org.jdeferred.impl.DefaultDeferredManager;
-import org.jdeferred.multiple.MultipleResults;
-
-public class AsyncHttpTest {
-    protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
-
-    public void testPromiseAdapter() throws IOException {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicInteger successCount = new AtomicInteger();
-        final AtomicInteger progressCount = new AtomicInteger();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-            p1.done(new DoneCallback<Response>() {
-                @Override
-                public void onDone(Response response) {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        successCount.incrementAndGet();
-                    } finally {
-                        latch.countDown();
-                    }
-                }
-            }).progress(new ProgressCallback<HttpProgress>() {
-
-                @Override
-                public void onProgress(HttpProgress progress) {
-                    progressCount.incrementAndGet();
-                }
-            });
-
-            latch.await();
-            assertTrue(progressCount.get() > 0);
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    public void testMultiplePromiseAdapter() throws IOException {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicInteger successCount = new AtomicInteger();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-            Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
-            AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
-
-            deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
-                @Override
-                public void onDone(MultipleResults result) {
-                    try {
-                        assertEquals(result.size(), 3);
-                        assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
-                        assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
-                        assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
-                        successCount.incrementAndGet();
-                    } finally {
-                        latch.countDown();
-                    }
-                }
-            });
-            latch.await();
-
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-}
diff --git a/extras/pom.xml b/extras/pom.xml
index e34bdf6ad..f601a24a0 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -28,12 +28,5 @@
             <artifactId>async-http-client</artifactId>
             <version>${project.version}</version>
         </dependency>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-            <classifier>tests</classifier>
-        </dependency>
     </dependencies>
 </project>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 49d0318db..856a58b6e 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.1.0-SNAPSHOT</version>
+		<version>2.1.0-SNAPSHOT-ABB</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
deleted file mode 100644
index bf2b166d0..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-
-import junit.extensions.PA;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
-import org.asynchttpclient.test.EchoHandler;
-import static org.asynchttpclient.test.TestUtils.*;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-public abstract class AbstractAsyncHttpClientFactoryTest {
-
-    public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
-    public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
-    public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
-
-    private Server server;
-    private int port;
-
-    @BeforeMethod
-    public void setUp() {
-        PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
-        PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-        AsyncHttpClientConfigHelper.reloadProperties();
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpBeforeTest() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new EchoHandler());
-        server.start();
-        port = connector.getLocalPort();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDown() throws Exception {
-        setUp();
-        if (server != null)
-            server.stop();
-    }
-
-    /**
-     * If the property is not found via the system property or properties file the default instance of AsyncHttpClient should be returned.
-     */
-    // ================================================================================================================
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClient() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfig() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProvider() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    // ==================================================================================================================================
-
-    /**
-     * If the class is specified via a system property then that class should be returned
-     */
-    // ===================================================================================================================================
-    @Test(groups = "standalone")
-    public void testFactoryWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfigWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProviderWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    // ===================================================================================================================================
-
-    /**
-     * If any of the constructors of the class fail then a AsyncHttpClientException is thrown.
-     */
-    // ===================================================================================================================================
-    @Test(groups = "standalone", expectedExceptions = BadAsyncHttpClientException.class)
-    public void testFactoryWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            assertException(e);
-        }
-        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            assertException(e);
-        }
-        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
-
-    // ===================================================================================================================================
-
-    /*
-     * If the system property exists instantiate the class else if the class is not found throw an AsyncHttpClientException.
-     */
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testFactoryWithNonExistentAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        }
-        Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
-
-    /**
-     * If property is specified but the class canâ€™t be created or found for any reason subsequent calls should throw an AsyncClientException.
-     */
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testRepeatedCallsToBadAsyncHttpClient() throws IOException {
-        boolean exceptionCaught = false;
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            exceptionCaught = true;
-        }
-        Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
-        exceptionCaught = false;
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            exceptionCaught = true;
-        }
-        Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
-    }
-
-    private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
-        Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-    }
-
-    private void assertException(AsyncHttpClientImplException e) {
-        InvocationTargetException t = (InvocationTargetException) e.getCause();
-        Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
-    }
-
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
deleted file mode 100644
index e546c6899..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import java.io.IOException;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
-import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
-import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-import org.asynchttpclient.extras.registry.AsyncImplHelper;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-import junit.extensions.PA;
-
-public class AsyncHttpClientRegistryTest {
-
-    private static final String TEST_AHC = "testAhc";
-
-    @BeforeMethod
-    public void setUp() {
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-        PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
-    }
-
-    @BeforeClass
-    public void setUpBeforeTest() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
-    }
-
-    @AfterClass
-    public void tearDown() {
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAndRegister() throws IOException {
-        try(AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-            Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testDeRegister() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-            Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testRegisterIfNew() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-                Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
-                Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testClearAllInstances() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                try (AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
-                    Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-                    AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-                    Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
-                }
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testCustomAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
-        AsyncHttpClientConfigHelper.reloadProperties();
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testNonExistentAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance();
-        Assert.fail("Should never have reached here");
-    }
-
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testBadAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance();
-        Assert.fail("Should never have reached here");
-    }
-
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
deleted file mode 100644
index 713887c98..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import java.util.function.Predicate;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.ClientStats;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SignatureCalculator;
-
-public class BadAsyncHttpClient implements AsyncHttpClient {
-
-    public BadAsyncHttpClient() {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    public BadAsyncHttpClient(AsyncHttpClientConfig config) {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    @Override
-    public void close() {
-
-    }
-
-    @Override
-    public boolean isClosed() {
-        return false;
-    }
-
-    @Override
-    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareGet(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareConnect(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareOptions(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareHead(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePost(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePut(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareDelete(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePatch(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareTrace(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public ClientStats getClientStats() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public AsyncHttpClientConfig getConfig() {
-        return null;
-    }
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
deleted file mode 100644
index 1aca098e8..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
-
-@SuppressWarnings("serial")
-public class BadAsyncHttpClientException extends AsyncHttpClientImplException {
-
-    public BadAsyncHttpClientException(String msg) {
-        super(msg);
-    }
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
deleted file mode 100644
index b3d853de3..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-
-public class BadAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
-
-    private BadAsyncHttpClientRegistry() {
-        throw new RuntimeException("I am bad");
-    }
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
deleted file mode 100644
index 0e61c109f..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import java.util.function.Predicate;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.ClientStats;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SignatureCalculator;
-
-public class TestAsyncHttpClient implements AsyncHttpClient {
-
-    public TestAsyncHttpClient() {
-    }
-
-    public TestAsyncHttpClient(AsyncHttpClientConfig config) {
-    }
-
-    public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-    }
-
-    @Override
-    public void close() {
-    }
-
-    @Override
-    public boolean isClosed() {
-        return false;
-    }
-
-    @Override
-    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareGet(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareConnect(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareOptions(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareHead(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePost(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePut(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareDelete(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePatch(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareTrace(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public ClientStats getClientStats() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public AsyncHttpClientConfig getConfig() {
-        return null;
-    }
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
deleted file mode 100644
index b9410737d..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-
-public class TestAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
-
-}
diff --git a/extras/registry/src/test/resources/300k.png b/extras/registry/src/test/resources/300k.png
deleted file mode 100644
index bff4a8598..000000000
Binary files a/extras/registry/src/test/resources/300k.png and /dev/null differ
diff --git a/extras/registry/src/test/resources/SimpleTextFile.txt b/extras/registry/src/test/resources/SimpleTextFile.txt
deleted file mode 100644
index 088788f82..000000000
--- a/extras/registry/src/test/resources/SimpleTextFile.txt
+++ /dev/null
@@ -1 +0,0 @@
-This is a simple test file
\ No newline at end of file
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index edba32b80..5798650ea 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT-ABB</version>
     </parent>
 
     <artifactId>async-http-client-extras-retrofit2</artifactId>
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
deleted file mode 100644
index 58eef1c91..000000000
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.retrofit;
-
-import lombok.extern.slf4j.Slf4j;
-import lombok.val;
-import okhttp3.Request;
-import okhttp3.Response;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.RequestBuilder;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
-
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCallTest.REQUEST;
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCallTest.createConsumer;
-import static org.mockito.Mockito.mock;
-import static org.testng.Assert.*;
-
-@Slf4j
-public class AsyncHttpClientCallFactoryTest {
-    @Test
-    void newCallShouldProduceExpectedResult() {
-        // given
-        val request = new Request.Builder().url("http://www.google.com/").build();
-        val httpClient = mock(AsyncHttpClient.class);
-
-        Consumer<Request> onRequestStart = createConsumer(new AtomicInteger());
-        Consumer<Throwable> onRequestFailure = createConsumer(new AtomicInteger());
-        Consumer<Response> onRequestSuccess = createConsumer(new AtomicInteger());
-        Consumer<RequestBuilder> requestCustomizer = createConsumer(new AtomicInteger());
-
-        // first call customizer
-        val customizer1Called = new AtomicInteger();
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer1 = builder -> {
-            builder.onRequestStart(onRequestStart)
-                    .onRequestFailure(onRequestFailure)
-                    .onRequestSuccess(onRequestSuccess);
-            customizer1Called.incrementAndGet();
-        };
-
-        // first call customizer
-        val customizer2Called = new AtomicInteger();
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer2 = builder -> {
-            builder.requestCustomizer(requestCustomizer);
-            customizer2Called.incrementAndGet();
-        };
-
-        // when: create call factory
-        val factory = AsyncHttpClientCallFactory.builder()
-                .httpClient(httpClient)
-                .callCustomizer(callBuilderConsumer1)
-                .callCustomizer(callBuilderConsumer2)
-                .build();
-
-        // then
-        assertTrue(factory.getHttpClient() == httpClient);
-        assertTrue(factory.getCallCustomizers().size() == 2);
-        assertTrue(customizer1Called.get() == 0);
-        assertTrue(customizer2Called.get() == 0);
-
-        // when
-        val call = (AsyncHttpClientCall) factory.newCall(request);
-
-        // then
-        assertNotNull(call);
-        assertTrue(customizer1Called.get() == 1);
-        assertTrue(customizer2Called.get() == 1);
-
-        assertTrue(call.request() == request);
-        assertTrue(call.getHttpClient() == httpClient);
-
-        assertEquals(call.getOnRequestStart().get(0), onRequestStart);
-        assertEquals(call.getOnRequestFailure().get(0), onRequestFailure);
-        assertEquals(call.getOnRequestSuccess().get(0), onRequestSuccess);
-        assertEquals(call.getRequestCustomizers().get(0), requestCustomizer);
-    }
-
-    @Test
-    void shouldApplyAllConsumersToCallBeingConstructed() throws IOException {
-        // given
-        val httpClient = mock(AsyncHttpClient.class);
-
-        val rewriteUrl = "http://foo.bar.com/";
-        val headerName = "X-Header";
-        val headerValue = UUID.randomUUID().toString();
-
-        val numCustomized = new AtomicInteger();
-        val numRequestStart = new AtomicInteger();
-        val numRequestSuccess = new AtomicInteger();
-        val numRequestFailure = new AtomicInteger();
-
-        Consumer<RequestBuilder> requestCustomizer = requestBuilder -> {
-            requestBuilder.setUrl(rewriteUrl)
-                    .setHeader(headerName, headerValue);
-            numCustomized.incrementAndGet();
-        };
-
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callCustomizer = callBuilder -> {
-            callBuilder
-                    .requestCustomizer(requestCustomizer)
-                    .requestCustomizer(rb -> log.warn("I'm customizing: {}", rb))
-                    .onRequestSuccess(createConsumer(numRequestSuccess))
-                    .onRequestFailure(createConsumer(numRequestFailure))
-                    .onRequestStart(createConsumer(numRequestStart));
-        };
-
-        // create factory
-        val factory = AsyncHttpClientCallFactory.builder()
-                .callCustomizer(callCustomizer)
-                .httpClient(httpClient)
-                .build();
-
-        // when
-        val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
-        val callRequest = call.createRequest(call.request());
-
-        // then
-        assertTrue(numCustomized.get() == 1);
-        assertTrue(numRequestStart.get() == 0);
-        assertTrue(numRequestSuccess.get() == 0);
-        assertTrue(numRequestFailure.get() == 0);
-
-        // let's see whether request customizers did their job
-        // final async-http-client request should have modified URL and one
-        // additional header value.
-        assertEquals(callRequest.getUrl(), rewriteUrl);
-        assertEquals(callRequest.getHeaders().get(headerName), headerValue);
-
-        // final call should have additional consumers set
-        assertNotNull(call.getOnRequestStart());
-        assertTrue(call.getOnRequestStart().size() == 1);
-
-        assertNotNull(call.getOnRequestSuccess());
-        assertTrue(call.getOnRequestSuccess().size() == 1);
-
-        assertNotNull(call.getOnRequestFailure());
-        assertTrue(call.getOnRequestFailure().size() == 1);
-
-        assertNotNull(call.getRequestCustomizers());
-        assertTrue(call.getRequestCustomizers().size() == 2);
-    }
-}
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
deleted file mode 100644
index 1bfd81151..000000000
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.retrofit;
-
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.*;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.*;
-import static org.testng.Assert.assertTrue;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
-
-import lombok.val;
-import okhttp3.Request;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
-import org.testng.Assert;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-public class AsyncHttpClientCallTest {
-    static final Request REQUEST = new Request.Builder().url("http://www.google.com/").build();
-
-    @Test(expectedExceptions = NullPointerException.class, dataProvider = "first")
-    void builderShouldThrowInCaseOfMissingProperties(AsyncHttpClientCall.AsyncHttpClientCallBuilder builder) {
-        builder.build();
-    }
-
-    @DataProvider(name = "first")
-    Object[][] dataProviderFirst() {
-        val httpClient = mock(AsyncHttpClient.class);
-
-        return new Object[][]{
-                {AsyncHttpClientCall.builder()},
-                {AsyncHttpClientCall.builder().request(REQUEST)},
-                {AsyncHttpClientCall.builder().httpClient(httpClient)}
-        };
-    }
-
-    @Test(dataProvider = "second")
-    void shouldInvokeConsumersOnEachExecution(Consumer<AsyncCompletionHandler<?>> handlerConsumer,
-                                              int expectedStarted,
-                                              int expectedOk,
-                                              int expectedFailed) {
-        // given
-
-        // counters
-        val numStarted = new AtomicInteger();
-        val numOk = new AtomicInteger();
-        val numFailed = new AtomicInteger();
-        val numRequestCustomizer = new AtomicInteger();
-
-        // prepare http client mock
-        val httpClient = mock(AsyncHttpClient.class);
-
-        val mockRequest = mock(org.asynchttpclient.Request.class);
-        when(mockRequest.getHeaders()).thenReturn(EmptyHttpHeaders.INSTANCE);
-
-        val brb = new BoundRequestBuilder(httpClient, mockRequest);
-        when(httpClient.prepareRequest((org.asynchttpclient.RequestBuilder) any())).thenReturn(brb);
-
-        when(httpClient.executeRequest((org.asynchttpclient.Request) any(), any())).then(invocationOnMock -> {
-            @SuppressWarnings("rawtypes")
-            val handler = invocationOnMock.getArgumentAt(1, AsyncCompletionHandler.class);
-            handlerConsumer.accept(handler);
-            return null;
-        });
-
-        // create call instance
-        val call = AsyncHttpClientCall.builder()
-                .httpClient(httpClient)
-                .request(REQUEST)
-                .onRequestStart(e -> numStarted.incrementAndGet())
-                .onRequestFailure(t -> numFailed.incrementAndGet())
-                .onRequestSuccess(r -> numOk.incrementAndGet())
-                .requestCustomizer(rb -> numRequestCustomizer.incrementAndGet())
-                .executeTimeoutMillis(1000)
-                .build();
-
-        // when
-        Assert.assertFalse(call.isExecuted());
-        Assert.assertFalse(call.isCanceled());
-        try {
-            call.execute();
-        } catch (Exception e) {
-        }
-
-        // then
-        assertTrue(call.isExecuted());
-        Assert.assertFalse(call.isCanceled());
-        assertTrue(numRequestCustomizer.get() == 1); // request customizer must be always invoked.
-        assertTrue(numStarted.get() == expectedStarted);
-        assertTrue(numOk.get() == expectedOk);
-        assertTrue(numFailed.get() == expectedFailed);
-
-        // try with non-blocking call
-        numStarted.set(0);
-        numOk.set(0);
-        numFailed.set(0);
-        val clonedCall = call.clone();
-
-        // when
-        clonedCall.enqueue(null);
-
-        // then
-        assertTrue(clonedCall.isExecuted());
-        Assert.assertFalse(clonedCall.isCanceled());
-        assertTrue(numRequestCustomizer.get() == 2); // request customizer must be always invoked.
-        assertTrue(numStarted.get() == expectedStarted);
-        assertTrue(numOk.get() == expectedOk);
-        assertTrue(numFailed.get() == expectedFailed);
-    }
-
-    @DataProvider(name = "second")
-    Object[][] dataProviderSecond() {
-        // mock response
-        val response = mock(Response.class);
-        when(response.getStatusCode()).thenReturn(200);
-        when(response.getStatusText()).thenReturn("OK");
-        when(response.getHeaders()).thenReturn(EmptyHttpHeaders.INSTANCE);
-
-        Consumer<AsyncCompletionHandler<?>> okConsumer = handler -> {
-            try {
-                handler.onCompleted(response);
-            } catch (Exception e) {
-            }
-        };
-        Consumer<AsyncCompletionHandler<?>> failedConsumer = handler -> handler.onThrowable(new TimeoutException("foo"));
-
-        return new Object[][]{
-                {okConsumer, 1, 1, 0},
-                {failedConsumer, 1, 0, 1}
-        };
-    }
-
-    @Test(dataProvider = "third")
-    void toIOExceptionShouldProduceExpectedResult(Throwable exception) {
-        // given
-        val call = AsyncHttpClientCall.builder()
-                .httpClient(mock(AsyncHttpClient.class))
-                .request(REQUEST)
-                .build();
-
-        // when
-        val result = call.toIOException(exception);
-
-        // then
-        Assert.assertNotNull(result);
-        assertTrue(result instanceof IOException);
-
-        if (exception.getMessage() == null) {
-            assertTrue(result.getMessage() == exception.toString());
-        } else {
-            assertTrue(result.getMessage() == exception.getMessage());
-        }
-    }
-
-    @DataProvider(name = "third")
-    Object[][] dataProviderThird() {
-        return new Object[][]{
-                {new IOException("foo")},
-                {new RuntimeException("foo")},
-                {new IllegalArgumentException("foo")},
-                {new ExecutionException(new RuntimeException("foo"))},
-        };
-    }
-
-    @Test(dataProvider = "4th")
-    <T> void runConsumerShouldTolerateBadConsumers(Consumer<T> consumer, T argument) {
-        // when
-        runConsumer(consumer, argument);
-
-        // then
-        assertTrue(true);
-    }
-
-    @DataProvider(name = "4th")
-    Object[][] dataProvider4th() {
-        return new Object[][]{
-                {null, null},
-                {(Consumer<String>) s -> s.trim(), null},
-                {null, "foobar"},
-                {(Consumer<String>) s -> doThrow("trololo"), null},
-                {(Consumer<String>) s -> doThrow("trololo"), "foo"},
-        };
-    }
-
-    @Test(dataProvider = "5th")
-    <T> void runConsumersShouldTolerateBadConsumers(Collection<Consumer<T>> consumers, T argument) {
-        // when
-        runConsumers(consumers, argument);
-
-        // then
-        assertTrue(true);
-    }
-
-    @DataProvider(name = "5th")
-    Object[][] dataProvider5th() {
-        return new Object[][]{
-                {null, null},
-                {Arrays.asList((Consumer<String>) s -> s.trim()), null},
-                {Arrays.asList(s -> s.trim(), null, (Consumer<String>) s -> s.isEmpty()), null},
-                {null, "foobar"},
-                {Arrays.asList((Consumer<String>) s -> doThrow("trololo")), null},
-                {Arrays.asList((Consumer<String>) s -> doThrow("trololo")), "foo"},
-        };
-    }
-
-    private void doThrow(String message) {
-        throw new RuntimeException(message);
-    }
-
-    /**
-     * Creates consumer that increments counter when it's called.
-     *
-     * @param counter counter that is going to be called
-     * @param <T>     consumer type
-     * @return consumer.
-     */
-    protected static <T> Consumer<T> createConsumer(AtomicInteger counter) {
-        return e -> counter.incrementAndGet();
-    }
-}
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
deleted file mode 100644
index d370e38c9..000000000
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.retrofit;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-import lombok.extern.slf4j.Slf4j;
-import lombok.val;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClientConfig;
-import org.asynchttpclient.testserver.HttpServer;
-import org.asynchttpclient.testserver.HttpTest;
-import org.testng.annotations.AfterSuite;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.BeforeTest;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-import retrofit2.HttpException;
-import retrofit2.Retrofit;
-import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
-import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;
-import retrofit2.converter.jackson.JacksonConverterFactory;
-import retrofit2.converter.scalars.ScalarsConverterFactory;
-import rx.schedulers.Schedulers;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.stream.IntStream;
-
-import static org.asynchttpclient.extras.retrofit.TestServices.Contributor;
-import static org.testng.Assert.*;
-import static org.testng.AssertJUnit.assertEquals;
-
-/**
- * All tests in this test suite are disabled, because they call functionality of github service that is
- * rate-limited.
- */
-@Slf4j
-public class AsyncHttpRetrofitIntegrationTest extends HttpTest {
-    private static final ObjectMapper objectMapper = new ObjectMapper();
-    private static final String OWNER = "AsyncHttpClient";
-    private static final String REPO = "async-http-client";
-
-    private static final AsyncHttpClient httpClient = createHttpClient();
-    private static HttpServer server;
-
-    private List<Contributor> expectedContributors;
-
-    private static AsyncHttpClient createHttpClient() {
-        val config = new DefaultAsyncHttpClientConfig.Builder()
-                .setCompressionEnforced(true)
-                .setTcpNoDelay(true)
-                .setKeepAlive(true)
-                .setPooledConnectionIdleTimeout(120_000)
-                .setFollowRedirect(true)
-                .setMaxRedirects(5)
-                .build();
-
-        return new DefaultAsyncHttpClient(config);
-    }
-
-    @BeforeClass
-    public static void start() throws Throwable {
-        server = new HttpServer();
-        server.start();
-    }
-
-    @BeforeTest
-    void before() {
-        this.expectedContributors = generateContributors();
-    }
-
-    @AfterSuite
-    void cleanup() throws IOException {
-        httpClient.close();
-    }
-
-    // begin: synchronous execution
-    @Test
-    public void testSynchronousService_OK() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_OK_WithBadEncoding() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_FAIL() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then:
-        assertNull(resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_NOT_FOUND() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            log.info("contributors: {}", contributors);
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then:
-        assertNull(resultRef.get());
-    }
-
-    private TestServices.GithubSync synchronousSetup() {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .callFactory(callFactory)
-                .build();
-        val service = retrofit.create(TestServices.GithubSync.class);
-        return service;
-    }
-    // end: synchronous execution
-
-    // begin: rxjava 1.x
-    @Test(dataProvider = "testRxJava1Service")
-    public void testRxJava1Service_OK(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava1Service")
-    public void testRxJava1Service_OK_WithBadEncoding(RxJavaCallAdapterFactory rxJavaCallAdapterFactory)
-            throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava1Service", expectedExceptions = HttpException.class,
-            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-    public void testRxJava1Service_HTTP_500(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    @Test(dataProvider = "testRxJava1Service",
-            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-    public void testRxJava1Service_NOT_FOUND(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    private TestServices.GithubRxJava1 rxjava1Setup(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .addCallAdapterFactory(rxJavaCallAdapterFactory)
-                .callFactory(callFactory)
-                .build();
-        return retrofit.create(TestServices.GithubRxJava1.class);
-    }
-
-    @DataProvider(name = "testRxJava1Service")
-    Object[][] testRxJava1Service_DataProvider() {
-        return new Object[][]{
-                {RxJavaCallAdapterFactory.create()},
-                {RxJavaCallAdapterFactory.createAsync()},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io())},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.computation())},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.trampoline())},
-        };
-    }
-    // end: rxjava 1.x
-
-    // begin: rxjava 2.x
-    @Test(dataProvider = "testRxJava2Service")
-    public void testRxJava2Service_OK(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava2Service")
-    public void testRxJava2Service_OK_WithBadEncoding(RxJava2CallAdapterFactory rxJavaCallAdapterFactory)
-            throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava2Service", expectedExceptions = HttpException.class,
-            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-    public void testRxJava2Service_HTTP_500(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    @Test(dataProvider = "testRxJava2Service",
-            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-    public void testRxJava2Service_NOT_FOUND(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    private TestServices.GithubRxJava2 rxjava2Setup(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .addCallAdapterFactory(rxJavaCallAdapterFactory)
-                .callFactory(callFactory)
-                .build();
-        return retrofit.create(TestServices.GithubRxJava2.class);
-    }
-
-    @DataProvider(name = "testRxJava2Service")
-    Object[][] testRxJava2Service_DataProvider() {
-        return new Object[][]{
-                {RxJava2CallAdapterFactory.create()},
-                {RxJava2CallAdapterFactory.createAsync()},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.io())},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.computation())},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.trampoline())},
-        };
-    }
-    // end: rxjava 2.x
-
-    private Retrofit.Builder createRetrofitBuilder() {
-        return new Retrofit.Builder()
-                .addConverterFactory(ScalarsConverterFactory.create())
-                .addConverterFactory(JacksonConverterFactory.create(objectMapper))
-                .validateEagerly(true)
-                .baseUrl(server.getHttpUrl());
-    }
-
-    /**
-     * Asserts contributors.
-     *
-     * @param expected expected list of contributors
-     * @param actual   actual retrieved list of contributors.
-     */
-    private void assertContributors(Collection<Contributor> expected, Collection<Contributor> actual) {
-        assertNotNull(actual, "Retrieved contributors should not be null.");
-        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-        assertTrue(expected.size() == actual.size());
-        assertEquals(expected, actual);
-    }
-
-    private void assertContributorsWithWrongCharset(List<Contributor> expected, List<Contributor> actual) {
-        assertNotNull(actual, "Retrieved contributors should not be null.");
-        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-        assertTrue(expected.size() == actual.size());
-
-        // first and second element should have different logins due to problems with decoding utf8 to us-ascii
-        assertNotEquals(expected.get(0).getLogin(), actual.get(0).getLogin());
-        assertEquals(expected.get(0).getContributions(), actual.get(0).getContributions());
-
-        assertNotEquals(expected.get(1).getLogin(), actual.get(1).getLogin());
-        assertEquals(expected.get(1).getContributions(), actual.get(1).getContributions());
-
-        // other elements should be equal
-        for (int i = 2; i < expected.size(); i++) {
-            assertEquals(expected.get(i), actual.get(i));
-        }
-    }
-
-    private List<Contributor> generateContributors() {
-        val list = new ArrayList<Contributor>();
-
-        list.add(new Contributor(UUID.randomUUID() + ": ÄÄ‡Å¾Å¡Ä‘", 100));
-        list.add(new Contributor(UUID.randomUUID() + ": ÄŒÄ†Å½Å Ä", 200));
-
-        IntStream.range(0, (int) (Math.random() * 100)).forEach(i -> {
-            list.add(new Contributor(UUID.randomUUID().toString(), (int) (Math.random() * 500)));
-        });
-
-        return list;
-    }
-
-    private HttpServer configureTestServer(HttpServer server, int status,
-                                           Collection<Contributor> contributors,
-                                           String charset) {
-        server.enqueueResponse(response -> {
-            response.setStatus(status);
-            if (status == 200) {
-                response.setHeader("Content-Type", "application/json; charset=" + charset);
-                response.getOutputStream().write(objectMapper.writeValueAsBytes(contributors));
-            } else {
-                response.setHeader("Content-Type", "text/plain");
-                val errorMsg = "This is an " + status + " error";
-                response.getOutputStream().write(errorMsg.getBytes());
-            }
-        });
-
-        return server;
-    }
-}
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
deleted file mode 100644
index 6e0939dba..000000000
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.retrofit;
-
-import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
-import lombok.NonNull;
-import lombok.Value;
-import retrofit2.Call;
-import retrofit2.http.GET;
-import retrofit2.http.Path;
-import rx.Observable;
-
-import java.io.Serializable;
-import java.util.List;
-
-/**
- * Github DTOs and services.
- */
-public class TestServices {
-    @Value
-    @JsonIgnoreProperties(ignoreUnknown = true)
-    public static class Contributor implements Serializable {
-        private static final long serialVersionUID = 1;
-
-        @NonNull
-        String login;
-
-        int contributions;
-    }
-
-    /**
-     * Synchronous interface
-     */
-    public interface GithubSync {
-        @GET("/repos/{owner}/{repo}/contributors")
-        Call<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
-
-    /**
-     * RxJava 1.x reactive interface
-     */
-    public interface GithubRxJava1 {
-        @GET("/repos/{owner}/{repo}/contributors")
-        Observable<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
-
-    /**
-     * RxJava 2.x reactive interface
-     */
-    public interface GithubRxJava2 {
-        @GET("/repos/{owner}/{repo}/contributors")
-        io.reactivex.Single<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
-}
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 7c77178cc..67d3b432e 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT-ABB</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
deleted file mode 100644
index 9497d0f81..000000000
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.rxjava;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.util.List;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.testng.annotations.Test;
-
-import rx.Observable;
-import rx.observers.TestSubscriber;
-
-public class AsyncHttpObservableTest {
-
-    @Test(groups = "standalone")
-    public void testToObservableNoError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 200);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testToObservableError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io/ttfn"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 404);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testObserveNoError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 200);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testObserveError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io/ttfn"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 404);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testObserveMultiple() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
-            Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
-            Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
-            Observable<Response> all = Observable.merge(o1, o2, o3);
-            all.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 3);
-            for (Response response : responses) {
-                assertEquals(response.getStatusCode(), 200);
-            }
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
-    }
-}
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
deleted file mode 100644
index f7f5f9b62..000000000
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.rxjava.single;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static org.testng.Assert.assertEquals;
-
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.extras.rxjava.UnsubscribedException;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.InOrder;
-import org.testng.annotations.Test;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicReference;
-
-import rx.Single;
-import rx.exceptions.CompositeException;
-import rx.observers.TestSubscriber;
-
-public class AsyncHttpSingleTest {
-
-    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
-    public void testFailsOnNullRequest() {
-        AsyncHttpSingle.create((BoundRequestBuilder) null);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
-    public void testFailsOnNullHandlerSupplier() {
-        AsyncHttpSingle.create(mock(BoundRequestBuilder.class), null);
-    }
-
-    @Test(groups = "standalone")
-    public void testSuccessfulCompletion() throws Exception {
-
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
-
-                bridge.onStatusReceived(null);
-                verify(handler).onStatusReceived(null);
-
-                bridge.onHeadersReceived(null);
-                verify(handler).onHeadersReceived(null);
-
-                bridge.onBodyPartReceived(null);
-                verify(handler).onBodyPartReceived(null);
-
-                bridge.onTrailingHeadersReceived(null);
-                verify(handler).onTrailingHeadersReceived(null);
-
-                bridge.onCompleted();
-                verify(handler).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
-
-            return mock(Future.class);
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        verifyNoMoreInteractions(handler);
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(handler);
-    }
-
-    @Test(groups = "standalone")
-    public void testSuccessfulCompletionWithProgress() throws Exception {
-
-        @SuppressWarnings("unchecked")
-        final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
-        final InOrder inOrder = inOrder(handler);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
-
-                final ProgressAsyncHandler<?> progressBridge = (ProgressAsyncHandler<?>) bridge;
-
-                progressBridge.onHeadersWritten();
-                inOrder.verify(handler).onHeadersWritten();
-
-                progressBridge.onContentWriteProgress(60, 40, 100);
-                inOrder.verify(handler).onContentWriteProgress(60, 40, 100);
-
-                progressBridge.onContentWritten();
-                inOrder.verify(handler).onContentWritten();
-
-                progressBridge.onStatusReceived(null);
-                inOrder.verify(handler).onStatusReceived(null);
-
-                progressBridge.onHeadersReceived(null);
-                inOrder.verify(handler).onHeadersReceived(null);
-
-                progressBridge.onBodyPartReceived(null);
-                inOrder.verify(handler).onBodyPartReceived(null);
-
-                bridge.onTrailingHeadersReceived(null);
-                verify(handler).onTrailingHeadersReceived(null);
-
-                progressBridge.onCompleted();
-                inOrder.verify(handler).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
-
-            return mock(Future.class);
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        inOrder.verifyNoMoreInteractions();
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(handler);
-    }
-
-    @Test(groups = "standalone")
-    public void testNewRequestForEachSubscription() throws Exception {
-        final BoundRequestBuilder builder = mock(BoundRequestBuilder.class);
-
-        final Single<?> underTest = AsyncHttpSingle.create(builder);
-        underTest.subscribe(new TestSubscriber<>());
-        underTest.subscribe(new TestSubscriber<>());
-
-        verify(builder, times(2)).execute(any());
-        verifyNoMoreInteractions(builder);
-    }
-
-    @Test(groups = "standalone")
-    public void testErrorPropagation() throws Exception {
-
-        final RuntimeException expectedException = new RuntimeException("expected");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
-        final InOrder inOrder = inOrder(handler);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onStatusReceived(null);
-                inOrder.verify(handler).onStatusReceived(null);
-
-                bridge.onHeadersReceived(null);
-                inOrder.verify(handler).onHeadersReceived(null);
-
-                bridge.onBodyPartReceived(null);
-                inOrder.verify(handler).onBodyPartReceived(null);
-
-                bridge.onThrowable(expectedException);
-                inOrder.verify(handler).onThrowable(expectedException);
-
-                // test that no further events are invoked after terminal events
-                bridge.onCompleted();
-                inOrder.verify(handler, never()).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
-
-            return mock(Future.class);
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        inOrder.verifyNoMoreInteractions();
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-        subscriber.assertError(expectedException);
-    }
-
-    @Test(groups = "standalone")
-    public void testErrorInOnCompletedPropagation() throws Exception {
-
-        final RuntimeException expectedException = new RuntimeException("expected");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenThrow(expectedException);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onCompleted();
-                return mock(Future.class);
-            } catch (final Throwable t) {
-                throw new AssertionError(t);
-            }
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        verify(handler).onCompleted();
-        verifyNoMoreInteractions(handler);
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-        subscriber.assertError(expectedException);
-    }
-
-    @Test(groups = "standalone")
-    public void testErrorInOnThrowablePropagation() throws Exception {
-
-        final RuntimeException processingException = new RuntimeException("processing");
-        final RuntimeException thrownException = new RuntimeException("thrown");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        doThrow(thrownException).when(handler).onThrowable(processingException);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onThrowable(processingException);
-                return mock(Future.class);
-            } catch (final Throwable t) {
-                throw new AssertionError(t);
-            }
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        verify(handler).onThrowable(processingException);
-        verifyNoMoreInteractions(handler);
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-
-        final List<Throwable> errorEvents = subscriber.getOnErrorEvents();
-        assertEquals(errorEvents.size(), 1);
-        assertThat(errorEvents.get(0), is(instanceOf(CompositeException.class)));
-        final CompositeException error = (CompositeException) errorEvents.get(0);
-        assertEquals(error.getExceptions(), Arrays.asList(processingException, thrownException));
-    }
-
-    @Test(groups = "standalone")
-    public void testAbort() throws Exception {
-        final TestSubscriber<Response> subscriber = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final Single<Response> underTest = AsyncHttpSingle.create(client.prepareGet("http://gatling.io"),
-                    () -> new AsyncCompletionHandlerBase() {
-                        @Override
-                        public State onStatusReceived(HttpResponseStatus status) {
-                            return State.ABORT;
-                        }
-                    });
-
-            underTest.subscribe(subscriber);
-            subscriber.awaitTerminalEvent();
-        }
-
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(null);
-    }
-
-    @Test(groups = "standalone")
-    public void testUnsubscribe() throws Exception {
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        final Future<?> future = mock(Future.class);
-        final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            bridgeRef.set(bridge);
-            return future;
-        } , () -> handler);
-
-        underTest.subscribe().unsubscribe();
-        verify(future).cancel(true);
-        verifyZeroInteractions(handler);
-
-        assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
-        verify(handler).onThrowable(isA(UnsubscribedException.class));
-        verifyNoMoreInteractions(handler);
-    }
-}
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 434e67a95..a51c6aca8 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT-ABB</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava2</artifactId>
     <name>Asynchronous Http Client RxJava2 Extras</name>
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
deleted file mode 100644
index 77f055373..000000000
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.rxjava2;
-
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import java.util.function.Supplier;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.InjectMocks;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-import io.reactivex.Maybe;
-import io.reactivex.observers.TestObserver;
-
-public class DefaultRxHttpClientTest {
-
-    @Mock
-    private AsyncHttpClient asyncHttpClient;
-
-    @Mock
-    private Request request;
-
-    @Mock
-    private Supplier<AsyncHandler<Object>> handlerSupplier;
-
-    @Mock
-    private AsyncHandler<Object> handler;
-
-    @Mock
-    private ProgressAsyncHandler<Object> progressHandler;
-
-    @Captor
-    private ArgumentCaptor<AsyncHandler<Object>> handlerCaptor;
-
-    @Mock
-    private ListenableFuture<Object> resposeFuture;
-
-    @InjectMocks
-    private DefaultRxHttpClient underTest;
-
-    @BeforeMethod(groups = "standalone")
-    public void initializeTest() {
-        underTest = null; // we want a fresh instance for each test
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullClient() {
-        new DefaultRxHttpClient(null);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullRequest() {
-        underTest.prepare(null, handlerSupplier);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullHandlerSupplier() {
-        underTest.prepare(request, null);
-    }
-
-    @Test(groups = "standalone")
-    public void emitsNullPointerExceptionWhenNullHandlerIsSupplied() {
-        // given
-        given(handlerSupplier.get()).willReturn(null);
-        final TestObserver<Object> subscriber = new TestObserver<>();
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe(subscriber);
-
-        // then
-        subscriber.assertTerminated();
-        subscriber.assertNoValues();
-        subscriber.assertError(NullPointerException.class);
-        then(handlerSupplier).should().get();
-        verifyNoMoreInteractions(handlerSupplier);
-    }
-
-    @Test(groups = "standalone")
-    public void usesVanillaAsyncHandler() throws Exception {
-        // given
-        given(handlerSupplier.get()).willReturn(handler);
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
-    }
-
-    @Test(groups = "standalone")
-    public void usesProgressAsyncHandler() throws Exception {
-        given(handlerSupplier.get()).willReturn(progressHandler);
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
-    }
-
-    @Test(groups = "standalone")
-    public void callsSupplierForEachSubscription() throws Exception {
-        // given
-        given(handlerSupplier.get()).willReturn(handler);
-        final Maybe<Object> prepared = underTest.prepare(request, handlerSupplier);
-
-        // when
-        prepared.subscribe();
-        prepared.subscribe();
-
-        // then
-        then(handlerSupplier).should(times(2)).get();
-    }
-
-    @Test(groups = "standalone")
-    public void cancelsResponseFutureOnDispose() throws Exception {
-        given(handlerSupplier.get()).willReturn(handler);
-        given(asyncHttpClient.executeRequest(eq(request), any())).willReturn(resposeFuture);
-
-        /* when */ underTest.prepare(request, handlerSupplier).subscribe().dispose();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        then(resposeFuture).should().cancel(true);
-        verifyZeroInteractions(handler);
-        assertThat(bridge.onStatusReceived(null), is(AsyncHandler.State.ABORT));
-        verify(handler).onThrowable(isA(DisposedException.class));
-        verifyNoMoreInteractions(handler);
-    }
-}
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
deleted file mode 100644
index 5c67bc1ce..000000000
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.rxjava2.maybe;
-
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.sameInstance;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.reactivex.MaybeEmitter;
-import io.reactivex.exceptions.CompositeException;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Callable;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.State;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.extras.rxjava2.DisposedException;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-public class AbstractMaybeAsyncHandlerBridgeTest {
-
-    @Mock
-    MaybeEmitter<Object> emitter;
-
-    @Mock
-    AsyncHandler<Object> delegate;
-
-    @Mock
-    private HttpResponseStatus status;
-
-    @Mock
-    private HttpHeaders headers;
-
-    @Mock
-    private HttpResponseBodyPart bodyPart;
-
-    @Captor
-    private ArgumentCaptor<Throwable> throwable;
-
-    private AbstractMaybeAsyncHandlerBridge<Object> underTest;
-
-    @BeforeMethod
-    public void initializeTest() {
-        MockitoAnnotations.initMocks(this);
-        underTest = new UnderTest();
-    }
-
-    @Test
-    public void forwardsEvents() throws Exception {
-        given(delegate.onCompleted()).willReturn(this);
-
-        /* when */ underTest.onStatusReceived(status);
-        then(delegate).should().onStatusReceived(status);
-
-        /* when */ underTest.onHeadersReceived(headers);
-        then(delegate).should().onHeadersReceived(headers);
-
-        /* when */ underTest.onBodyPartReceived(bodyPart);
-        /* when */ underTest.onBodyPartReceived(bodyPart);
-        then(delegate).should(times(2)).onBodyPartReceived(bodyPart);
-
-        /* when */ underTest.onTrailingHeadersReceived(headers);
-        then(delegate).should().onTrailingHeadersReceived(headers);
-
-        /* when */ underTest.onCompleted();
-        then(delegate).should().onCompleted();
-        then(emitter).should().onSuccess(this);
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
-
-    @Test
-    public void wontCallOnCompleteTwice() throws Exception {
-        InOrder inOrder = Mockito.inOrder(emitter);
-
-        /* when */ underTest.onCompleted();
-        /* then */ inOrder.verify(emitter).onComplete();
-
-        /* when */ underTest.onCompleted();
-        /* then */ inOrder.verify(emitter, never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnErrorTwice() throws Exception {
-        InOrder inOrder = Mockito.inOrder(emitter);
-
-        /* when */ underTest.onThrowable(null);
-        /* then */ inOrder.verify(emitter).onError(null);
-
-        /* when */ underTest.onThrowable(new RuntimeException("unwanted"));
-        /* then */ inOrder.verify(emitter, never()).onError(any());
-    }
-
-    @Test
-    public void wontCallOnErrorAfterOnComplete() throws Exception {
-        /* when */ underTest.onCompleted();
-        then(emitter).should().onComplete();
-
-        /* when */ underTest.onThrowable(null);
-        then(emitter).should(never()).onError(any());
-    }
-
-    @Test
-    public void wontCallOnCompleteAfterOnError() throws Exception {
-        /* when */ underTest.onThrowable(null);
-        then(emitter).should().onError(null);
-
-        /* when */ underTest.onCompleted();
-        then(emitter).should(never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnCompleteAfterDisposal() throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-        /* when */ underTest.onCompleted();
-        /* then */ verify(emitter, never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnErrorAfterDisposal() throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-        /* when */ underTest.onThrowable(new RuntimeException("ignored"));
-        /* then */ verify(emitter, never()).onError(any());
-    }
-
-    @Test
-    public void handlesExceptionsWhileCompleting() throws Exception {
-        /* given */ final Throwable x = new RuntimeException("mocked error in delegate onCompleted()");
-        given(delegate.onCompleted()).willThrow(x);
-        /* when */ underTest.onCompleted();
-        then(emitter).should().onError(x);
-    }
-
-    @Test
-    public void handlesExceptionsWhileFailing() throws Exception {
-        // given
-        final Throwable initial = new RuntimeException("mocked error for onThrowable()");
-        final Throwable followup = new RuntimeException("mocked error in delegate onThrowable()");
-        willThrow(followup).given(delegate).onThrowable(initial);
-
-        /* when */ underTest.onThrowable(initial);
-
-        // then
-        then(emitter).should().onError(throwable.capture());
-        final Throwable thrown = throwable.getValue();
-        assertThat(thrown, is(instanceOf(CompositeException.class)));
-        assertThat(((CompositeException) thrown).getExceptions(), is(Arrays.asList(initial, followup)));
-    }
-
-    @Test
-    public void cachesDisposedException() throws Exception {
-        // when
-        new UnderTest().disposed();
-        new UnderTest().disposed();
-
-        // then
-        then(delegate).should(times(2)).onThrowable(throwable.capture());
-        final List<Throwable> errors = throwable.getAllValues();
-        final Throwable firstError = errors.get(0), secondError = errors.get(1);
-        assertThat(secondError, is(sameInstance(firstError)));
-        final StackTraceElement[] stackTrace = firstError.getStackTrace();
-        assertThat(stackTrace.length, is(1));
-        assertThat(stackTrace[0].getClassName(), is(AbstractMaybeAsyncHandlerBridge.class.getName()));
-        assertThat(stackTrace[0].getMethodName(), is("disposed"));
-    }
-
-    @DataProvider
-    public Object[][] httpEvents() {
-        return new Object[][] { //
-                { named("onStatusReceived", () -> underTest.onStatusReceived(status)) }, //
-                { named("onHeadersReceived", () -> underTest.onHeadersReceived(headers)) }, //
-                { named("onBodyPartReceived", () -> underTest.onBodyPartReceived(bodyPart)) }, //
-                { named("onTrailingHeadersReceived", () -> underTest.onTrailingHeadersReceived(headers)) }, //
-        };
-    }
-
-    @Test(dataProvider = "httpEvents")
-    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-
-        /* when */ final AsyncHandler.State firstState = httpEvent.call();
-        /* then */ assertThat(firstState, is(State.ABORT));
-        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
-
-        /* when */ final AsyncHandler.State secondState = httpEvent.call();
-        /* then */ assertThat(secondState, is(State.ABORT));
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
-
-    private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
-        UnderTest() {
-            super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
-        }
-
-        @Override
-        protected AsyncHandler<? extends Object> delegate() {
-            return delegate;
-        }
-    }
-
-    private static <T> Callable<T> named(String name, Callable<T> callable) {
-        return new Callable<T>() {
-            @Override
-            public String toString() {
-                return name;
-            }
-
-            @Override
-            public T call() throws Exception {
-                return callable.call();
-            }
-        };
-    }
-}
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
deleted file mode 100644
index 5f33906e5..000000000
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.rxjava2.maybe;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-import java.util.concurrent.Callable;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.State;
-import org.asynchttpclient.extras.rxjava2.DisposedException;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-import io.reactivex.MaybeEmitter;
-
-public class AbstractMaybeProgressAsyncHandlerBridgeTest {
-
-    @Mock
-    MaybeEmitter<Object> emitter;
-
-    @Mock
-    ProgressAsyncHandler<? extends Object> delegate;
-
-    private AbstractMaybeProgressAsyncHandlerBridge<Object> underTest;
-
-    @BeforeMethod
-    public void initializeTest() {
-        MockitoAnnotations.initMocks(this);
-        underTest = new UnderTest();
-    }
-
-    @Test
-    public void forwardsEvents() throws Exception {
-        /* when */ underTest.onHeadersWritten();
-        then(delegate).should().onHeadersWritten();
-
-        /* when */ underTest.onContentWriteProgress(40, 60, 100);
-        then(delegate).should().onContentWriteProgress(40, 60, 100);
-
-        /* when */ underTest.onContentWritten();
-        then(delegate).should().onContentWritten();
-    }
-
-    @DataProvider
-    public Object[][] httpEvents() {
-        return new Object[][] { //
-                { named("onHeadersWritten", () -> underTest.onHeadersWritten()) }, //
-                { named("onContentWriteProgress", () -> underTest.onContentWriteProgress(40, 60, 100)) }, //
-                { named("onContentWritten", () -> underTest.onContentWritten()) }, //
-        };
-    }
-
-    @Test(dataProvider = "httpEvents")
-    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-
-        /* when */ final AsyncHandler.State firstState = httpEvent.call();
-        /* then */ assertThat(firstState, is(State.ABORT));
-        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
-
-        /* when */ final AsyncHandler.State secondState = httpEvent.call();
-        /* then */ assertThat(secondState, is(State.ABORT));
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
-
-    private final class UnderTest extends AbstractMaybeProgressAsyncHandlerBridge<Object> {
-        UnderTest() {
-            super(AbstractMaybeProgressAsyncHandlerBridgeTest.this.emitter);
-        }
-
-        @Override
-        protected ProgressAsyncHandler<? extends Object> delegate() {
-            return delegate;
-        }
-
-    }
-
-    private static <T> Callable<T> named(String name, Callable<T> callable) {
-        return new Callable<T>() {
-            @Override
-            public String toString() {
-                return name;
-            }
-
-            @Override
-            public T call() throws Exception {
-                return callable.call();
-            }
-        };
-    }
-}
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 5d4306d00..c1e280eb8 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT-ABB</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
deleted file mode 100644
index 80cd0e97c..000000000
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package org.asynchttpclient.extras.simple;
-
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.test.EchoHandler;
-import org.eclipse.jetty.proxy.ConnectHandler;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class HttpsProxyTest extends AbstractBasicTest {
-
-    private Server server2;
-
-    public AbstractHandler configureHandler() throws Exception {
-        return new ConnectHandler();
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        server.setHandler(configureHandler());
-        server.start();
-        port1 = connector1.getLocalPort();
-
-        server2 = new Server();
-        ServerConnector connector2 = addHttpsConnector(server2);
-        server2.setHandler(new EchoHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
-
-        logger.info("Local HTTP server started successfully");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-        server2.stop();
-    }
-
-    @Test(groups = "online")
-    public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setProxyHost("localhost")//
-                .setProxyPort(port1)//
-                .setFollowRedirect(true)//
-                .setUrl(getTargetUrl2())//
-                .setAcceptAnyCertificate(true)//
-                .setHeader("Content-Type", "text/html")//
-                .build()) {
-            Response r = client.get().get();
-
-            assertEquals(r.getStatusCode(), 200);
-        }
-    }
-}
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
deleted file mode 100644
index f2ca7f76c..000000000
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.simple;
-
-import static org.testng.Assert.*;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.concurrent.Future;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.extras.simple.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-/**
- * @author Benjamin Hanzelmann
- * 
- */
-public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
-    
-    @Test(groups = "standalone")
-    public void testAccumulateErrorBody() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl() + "/nonexistent")//
-                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-
-            System.out.println("waiting for response");
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 404);
-            assertEquals(o.toString(), "");
-            assertTrue(response.getResponseBody().startsWith("<html>"));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testOmitErrorBody() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl() + "/nonexistent")//
-                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-
-            System.out.println("waiting for response");
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 404);
-            assertEquals(o.toString(), "");
-            assertEquals(response.getResponseBody(), "");
-        }
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
-
-            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-                response.sendError(404);
-                baseRequest.setHandled(true);
-            }
-        };
-    }
-
-}
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
deleted file mode 100644
index b02b8c2f1..000000000
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.simple;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.*;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.request.body.generator.FileBodyGenerator;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.multipart.ByteArrayPart;
-import org.asynchttpclient.uri.Uri;
-import org.testng.annotations.Test;
-
-public class SimpleAsyncHttpClientTest extends AbstractBasicTest {
-
-    private final static String MY_MESSAGE = "my message";
-
-    @Test(groups = "standalone")
-    public void inputStreamBodyConsumerTest() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
-
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBody(), MY_MESSAGE);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void stringBuilderBodyConsumerTest() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            StringBuilder s = new StringBuilder();
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
-
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(s.toString(), MY_MESSAGE);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100).setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        }
-    }
-
-    /**
-     * See https://issues.sonatype.org/browse/AHC-5
-     */
-    @Test(groups = "standalone", enabled = true)
-    public void testPutZeroBytesFileTest() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 1000)//
-                .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")//
-                .setHeader("Content-Type", "text/plain").build()) {
-            File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
-            tmpfile.deleteOnExit();
-
-            Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
-
-            System.out.println("waiting for response");
-            Response response = future.get();
-
-            tmpfile.delete();
-
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testDerive() throws Exception {
-        try(SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-            try(SimpleAsyncHttpClient derived = client.derive().build()) {
-                assertNotSame(derived, client);
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testDeriveOverrideURL() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-
-            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
-
-            try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
-                Future<Response> future = derived.post(generator, consumer);
-
-                Response response = future.get();
-                assertEquals(response.getStatusCode(), 200);
-                assertEquals(o.toString(), MY_MESSAGE);
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testSimpleTransferListener() throws Exception {
-
-        final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
-
-        SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
-
-            public void onStatus(Uri uri, int statusCode, String statusText) {
-                try {
-                    assertEquals(statusCode, 200);
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onHeaders(Uri uri, HttpHeaders headers) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    assertNotNull(headers);
-                    assertTrue(!headers.isEmpty());
-                    assertEquals(headers.get("X-Custom"), "custom");
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onCompleted(Uri uri, int statusCode, String statusText) {
-                try {
-                    assertEquals(statusCode, 200);
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onBytesSent(Uri uri, long amount, long current, long total) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    // FIXME Netty bug, see
-                    // https://github.com/netty/netty/issues/1855
-                    // assertEquals(total, MY_MESSAGE.getBytes().length);
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onBytesReceived(Uri uri, long amount, long current, long total) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    assertEquals(total, -1);
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-        };
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl())//
-                .setHeader("Custom", "custom")//
-                .setListener(listener).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-
-            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
-
-            Future<Response> future = client.post(generator, consumer);
-
-            Response response = future.get();
-
-            if (!errors.isEmpty()) {
-                for (Error e : errors) {
-                    e.printStackTrace();
-                }
-                throw errors.get(0);
-            }
-
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testNullUrl() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-            assertTrue(true);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testCloseDerivedValidMaster() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-            try (SimpleAsyncHttpClient derived = client.derive().build()) {
-                derived.get().get();
-            }
-
-            Response response = client.get().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
-    @Test(groups = "standalone", expectedExceptions = IllegalStateException.class)
-    public void testCloseMasterInvalidDerived() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-        try (SimpleAsyncHttpClient derived = client.derive().build()) {
-            client.close();
-            
-            try {
-                derived.get().get();
-                fail("Expected closed AHC");
-            } catch (ExecutionException e) {
-                throw e.getCause();
-            }
-        }
-
-    }
-
-    @Test(groups = "standalone")
-    public void testMultiPartPut() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
-
-            String body = response.getResponseBody();
-            String contentType = response.getHeader("X-Content-Type");
-
-            assertTrue(contentType.contains("multipart/form-data"));
-
-            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-
-            assertTrue(body.startsWith("--" + boundary));
-            assertTrue(body.trim().endsWith("--" + boundary + "--"));
-            assertTrue(body.contains("Content-Disposition:"));
-            assertTrue(body.contains("Content-Type: application/test"));
-            assertTrue(body.contains("name=\"baPart"));
-            assertTrue(body.contains("filename=\"fileName"));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testMultiPartPost() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
-
-            String body = response.getResponseBody();
-            String contentType = response.getHeader("X-Content-Type");
-
-            assertTrue(contentType.contains("multipart/form-data"));
-
-            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-
-            assertTrue(body.startsWith("--" + boundary));
-            assertTrue(body.trim().endsWith("--" + boundary + "--"));
-            assertTrue(body.contains("Content-Disposition:"));
-            assertTrue(body.contains("Content-Type: application/test"));
-            assertTrue(body.contains("name=\"baPart"));
-            assertTrue(body.contains("filename=\"fileName"));
-        }
-    }
-}
diff --git a/pom.xml b/pom.xml
index 7e0e342c2..451caee1f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -211,7 +211,6 @@
 		<module>netty-utils</module>
 		<module>client</module>
 		<module>extras</module>
-		<module>example</module>
 	</modules>
 	<dependencyManagement>
 		<dependencies>
diff --git a/test.txt b/test.txt
deleted file mode 100644
index 9daeafb98..000000000
--- a/test.txt
+++ /dev/null
@@ -1 +0,0 @@
-test
