diff --git a/README.md b/README.md
index 047711c22..f19c6e017 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ Async Http Client library purpose is to allow Java applications to easily execut
 <dependency>
   <groupId>com.ning</groupId>
   <artifactId>async-http-client</artifactId>
-  <version>1.7.16</version>
+  <version>1.8.13</version>
 </dependency>
 ```
 
@@ -18,7 +18,7 @@ You can also download the artifact
 
 [Maven Search](http://search.maven.org)
 
-Then in your code you can simply do ([Javadoc](http://sonatype.github.com/async-http-client/apidocs/index.html))
+Then in your code you can simply do [Javadoc](http://asynchttpclient.github.io/async-http-client/apidocs/reference/packages.html)
 
 ```java
 import com.ning.http.client.*;
@@ -133,7 +133,9 @@ Future<String> f = c.prepareGet("http://www.ning.com/").execute(new AsyncHandler
 String bodyResponse = f.get();
 ```
 
-Finally, you can also configure the AsyncHttpClient via it's AsyncHttpClientConfig object:
+## Configuration
+
+Finally, you can also configure the AsyncHttpClient via its AsyncHttpClientConfig object:
 
 ```java
 AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder()
@@ -141,6 +143,8 @@ AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder()
 AsyncHttpClient c = new AsyncHttpClient(cf);
 ```
 
+## WebSocket
+
 Async Http Client also support WebSocket by simply doing:
 
 ```java
@@ -154,7 +158,7 @@ WebSocket websocket = c.prepareGet(getTargetUrl())
 
           @Override
           public void onOpen(WebSocket websocket) {
-              websocket.sendTextMessage("...").sendBinaryMessage("...");
+              websocket.sendTextMessage("...").sendMessage("...");
           }
 
           @Override
@@ -175,6 +179,8 @@ AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
 AsyncHttpClient client = new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
 ```
 
+## User Group
+
 Keep up to date on the library development by joining the Asynchronous HTTP Client discussion group
 
 [Google Group](http://groups.google.com/group/asynchttpclient)
@@ -182,3 +188,20 @@ Keep up to date on the library development by joining the Asynchronous HTTP Clie
 or follow us on [Twitter](http://twitter.com/jfarcand)
 
 [![githalytics.com alpha](https://cruel-carlota.pagodabox.com/6433679063b2351599c6ca44a08246a2 "githalytics.com")](http://githalytics.com/AsyncHttpClient/async-http-client)
+
+## Contributing
+
+Of course, Pull Requests are welcome.
+
+Here a the few rules we'd like you to respect if you do so:
+
+* Only edit the code related to the suggested change, so DON'T automatically format the classes you've edited.
+* Respect the formatting rules:
+  * Ident with 4 spaces
+  * Use a 140 chars line max length
+  * Don't use * imports
+  * Stick to the org, com, javax, java imports order
+* Your PR can contain multiple commits when submitting, but once it's been reviewed, we'll ask you to squash them into a single one
+* Regarding licensing:
+  * You must be the original author of the code you suggest.
+  * If not, you have to prove that the original code was published under Apache License 2 and properly mention original copyrights.
diff --git a/api/pom.xml b/api/pom.xml
index 78a6cba8d..0f5b2bdff 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -31,10 +31,15 @@
     </build>
 
     <dependencies>
+        <dependency>
+            <groupId>com.typesafe</groupId>
+            <artifactId>config</artifactId>
+            <version>1.2.1</version>
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.5</version>
+            <version>1.7.6</version>
         </dependency>
     </dependencies>
 
diff --git a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index b8e8d7088..b27a99dfb 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -105,7 +105,7 @@ public STATE onContentWriteCompleted() {
     /**
      * Invoked when the I/O operation associated with the {@link Request} body as been progressed.
      *
-     * @param amount  The amount of bytes to transfer.
+     * @param amount  The amount of bytes to transfer
      * @param current The amount of bytes transferred
      * @param total   The total number of bytes transferred
      * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
diff --git a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index c98ee9450..cd5f0a608 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -36,7 +36,7 @@ public Response onCompleted(Response response) throws Exception {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void onThrowable(Throwable t) {
         log.debug(t.getMessage(), t);
     }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHandler.java b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
index 3e6631a7a..843868e3f 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -70,6 +70,7 @@
 
     /**
      * Invoked as soon as some response body part are received. Could be invoked many times.
+     * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
      *
      * @param bodyPart response's body part.
      * @return a {@link STATE} telling to CONTINUE or ABORT the current processing.
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java b/api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java
new file mode 100644
index 000000000..1d81570b0
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+/**
+ * This interface hosts new low level callback methods on {@link AsyncHandler}.
+ * For now, those methods are in a dedicated interface in order not to break the existing API,
+ * but could be merged into one of the existing ones in AHC 2.
+ * 
+ * More additional hooks might come, such as:
+ * <ul>
+ *   <li>onConnectionClosed()</li>
+ *   <li>onBytesSent(long numberOfBytes)</li>
+ *   <li>onBytesReceived(long numberOfBytes)</li>
+ * </ul>
+ */
+public interface AsyncHandlerExtensions {
+
+    /**
+     * Notify the callback when trying to open a new connection.
+     */
+    void onOpenConnection();
+
+    /**
+     * Notify the callback when a new connection was successfully opened.
+     */
+    void onConnectionOpen();
+
+    /**
+     * Notify the callback when trying to fetch a connection from the pool.
+     */
+    void onPoolConnection();
+
+    /**
+     * Notify the callback when a new connection was successfully fetched from the pool.
+     */
+    void onConnectionPooled();
+
+    /**
+     * Notify the callback when a request is being written on the wire.
+     * If the original request causes multiple requests to be sent, for example, because of authorization or retry,
+     * it will be notified multiple times.
+     */
+    void onSendRequest();
+
+    /**
+     * Notify the callback every time a request is being retried.
+     */
+    void onRetry();
+}
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index 0966f12ba..45136c297 100755
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -16,21 +16,9 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.Request.EntityWriter;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.RequestFilter;
-import org.asynchttpclient.resumable.ResumableAsyncHandler;
 import java.io.Closeable;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
-import java.io.InputStream;
-import java.util.Collection;
-import java.util.Map;
 import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * This class support asynchronous and synchronous HTTP request.
@@ -138,317 +126,43 @@
  * An instance of this class will cache every HTTP 1.1 connections and close them when the {@link AsyncHttpClientConfig#getIdleConnectionTimeoutInMs()}
  * expires. This object can hold many persistent connections to different host.
  */
-public class AsyncHttpClient implements Closeable {
-
-    /**
-     * Providers that will be searched for, on the classpath, in order when no
-     * provider is explicitly specified by the developer.
-     */
-    private static final String[] DEFAULT_PROVIDERS = {
-        "org.asynchttpclient.providers.netty.NettyAsyncHttpProvider",
-        "org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider",
-        "org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider"
-    };
-
-    private final AsyncHttpProvider httpProvider;
-    private final AsyncHttpClientConfig config;
-    private final static Logger logger = LoggerFactory.getLogger(AsyncHttpClient.class);
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-
-    /**
-     * Default signature calculator to use for all requests constructed by this client instance.
-     *
-     * @since 1.1
-     */
-    protected SignatureCalculator signatureCalculator;
-
-    /**
-     * Create a new HTTP Asynchronous Client using the default {@link AsyncHttpClientConfig} configuration. The
-     * default {@link AsyncHttpProvider} that will be used will be based on the classpath configuration.
-     *
-     * The default providers will be searched for in this order:
-     * <ul>
-     *     <li>netty</li>
-     *     <li>grizzly</li>
-     *     <li>JDK</li>
-     * </ul>
-     *
-     * If none of those providers are found, then the runtime will default to
-     * the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider}.
-     */
-    public AsyncHttpClient() {
-        this(new AsyncHttpClientConfig.Builder().build());
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using an implementation of {@link AsyncHttpProvider} and
-     * the default {@link AsyncHttpClientConfig} configuration.
-     *
-     * @param provider a {@link AsyncHttpProvider}
-     */
-    public AsyncHttpClient(AsyncHttpProvider provider) {
-        this(provider, new AsyncHttpClientConfig.Builder().build());
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using the specified {@link AsyncHttpClientConfig} configuration.
-     * This configuration will be passed to the default {@link AsyncHttpProvider} that will be selected based on
-     * the classpath configuration.
-     *
-     * The default providers will be searched for in this order:
-     * <ul>
-     *     <li>netty</li>
-     *     <li>grizzly</li>
-     *     <li>JDK</li>
-     * </ul>
-     *
-     * If none of those providers are found, then the runtime will default to
-     * the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider}.
-     *
-     * @param config a {@link AsyncHttpClientConfig}
-     */
-    public AsyncHttpClient(AsyncHttpClientConfig config) {
-        this(loadDefaultProvider(DEFAULT_PROVIDERS, config), config);
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using a {@link AsyncHttpClientConfig} configuration and
-     * and a {@link AsyncHttpProvider}.
-     *
-     * @param config       a {@link AsyncHttpClientConfig}
-     * @param httpProvider a {@link AsyncHttpProvider}
-     */
-    public AsyncHttpClient(AsyncHttpProvider httpProvider, AsyncHttpClientConfig config) {
-        this.config = config;
-        this.httpProvider = httpProvider;
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using a {@link AsyncHttpClientConfig} configuration and
-     * and a AsyncHttpProvider class' name.
-     *
-     * @param config        a {@link AsyncHttpClientConfig}
-     * @param providerClass a {@link AsyncHttpProvider}
-     */
-    public AsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-        this.config = new AsyncHttpClientConfig.Builder().build();
-        this.httpProvider = loadProvider(providerClass, config);
-    }
-
-    public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
-        /**
-         * Calculator used for calculating request signature for the request being
-         * built, if any.
-         */
-        protected SignatureCalculator signatureCalculator;
-
-        /**
-         * URL used as the base, not including possibly query parameters. Needed for
-         * signature calculation
-         */
-        protected String baseURL;
-
-        private BoundRequestBuilder(String reqType, boolean useRawUrl) {
-            super(BoundRequestBuilder.class, reqType, useRawUrl);
-        }
-
-        private BoundRequestBuilder(Request prototype) {
-            super(BoundRequestBuilder.class, prototype);
-        }
-
-        public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) throws IOException {
-            return AsyncHttpClient.this.executeRequest(build(), handler);
-        }
-
-        public ListenableFuture<Response> execute() throws IOException {
-            return AsyncHttpClient.this.executeRequest(build(), new AsyncCompletionHandlerBase());
-        }
-
-        // Note: For now we keep the delegates in place even though they are not needed
-        //       since otherwise Clojure (and maybe other languages) won't be able to
-        //       access these methods - see Clojure tickets 126 and 259
-
-        @Override
-        public BoundRequestBuilder addBodyPart(Part part) throws IllegalArgumentException {
-            return super.addBodyPart(part);
-        }
-
-        @Override
-        public BoundRequestBuilder addCookie(Cookie cookie) {
-            return super.addCookie(cookie);
-        }
-
-        @Override
-        public BoundRequestBuilder addHeader(String name, String value) {
-            return super.addHeader(name, value);
-        }
-
-        @Override
-        public BoundRequestBuilder addParameter(String key, String value) throws IllegalArgumentException {
-            return super.addParameter(key, value);
-        }
-
-        @Override
-        public BoundRequestBuilder addQueryParameter(String name, String value) {
-            return super.addQueryParameter(name, value);
-        }
-
-        @Override
-        public Request build() {
-            /* Let's first calculate and inject signature, before finalizing actual build
-             * (order does not matter with current implementation but may in future)
-             */
-            if (signatureCalculator != null) {
-                String url = baseURL;
-                // Should not include query parameters, ensure:
-                int i = url.indexOf('?');
-                if (i >= 0) {
-                    url = url.substring(0, i);
-                }
-                signatureCalculator.calculateAndAddSignature(url, request, this);
-            }
-            return super.build();
-        }
-
-        @Override
-        public BoundRequestBuilder setBody(byte[] data) throws IllegalArgumentException {
-            return super.setBody(data);
-        }
-
-        @Override
-        public BoundRequestBuilder setBody(Request.EntityWriter dataWriter, long length) throws IllegalArgumentException {
-            return super.setBody(dataWriter, length);
-        }
-
-        @Override
-        public BoundRequestBuilder setBody(Request.EntityWriter dataWriter) {
-            return super.setBody(dataWriter);
-        }
-
-        @Override
-        public BoundRequestBuilder setBody(InputStream stream) throws IllegalArgumentException {
-            return super.setBody(stream);
-        }
-
-        @Override
-        public BoundRequestBuilder setBody(String data) throws IllegalArgumentException {
-            return super.setBody(data);
-        }
-
-        @Override
-        public BoundRequestBuilder setHeader(String name, String value) {
-            return super.setHeader(name, value);
-        }
-
-        @Override
-        public BoundRequestBuilder setHeaders(FluentCaseInsensitiveStringsMap headers) {
-            return super.setHeaders(headers);
-        }
-
-        @Override
-        public BoundRequestBuilder setHeaders(Map<String, Collection<String>> headers) {
-            return super.setHeaders(headers);
-        }
-
-        @Override
-        public BoundRequestBuilder setParameters(Map<String, Collection<String>> parameters) throws IllegalArgumentException {
-            return super.setParameters(parameters);
-        }
-
-        @Override
-        public BoundRequestBuilder setParameters(FluentStringsMap parameters) throws IllegalArgumentException {
-            return super.setParameters(parameters);
-        }
-
-        @Override
-        public BoundRequestBuilder setUrl(String url) {
-            baseURL = url;
-            return super.setUrl(url);
-        }
-
-        @Override
-        public BoundRequestBuilder setVirtualHost(String virtualHost) {
-            return super.setVirtualHost(virtualHost);
-        }
-
-        public BoundRequestBuilder setSignatureCalculator(SignatureCalculator signatureCalculator) {
-            this.signatureCalculator = signatureCalculator;
-            return this;
-        }
-    }
-
+public interface AsyncHttpClient extends Closeable {
 
     /**
      * Return the asynchronous {@link AsyncHttpProvider}
      *
      * @return an {@link AsyncHttpProvider}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public AsyncHttpProvider getProvider() {
-        return httpProvider;
-    }
+    AsyncHttpProvider getProvider();
 
     /**
      * Close the underlying connections.
      */
-    public void close() {
-        httpProvider.close();
-        isClosed.set(true);
-    }
+    void close();
 
     /**
      * Asynchronous close the {@link AsyncHttpProvider} by spawning a thread and avoid blocking.
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public void closeAsynchronously() {
-        config.applicationThreadPool.submit(new Runnable() {
-
-            public void run() {
-                httpProvider.close();
-                isClosed.set(true);
-            }
-        });
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            if (!isClosed.get()) {
-                logger.debug("AsyncHttpClient.close() hasn't been invoked, which may produce file descriptor leaks");
-            }
-        } finally {
-            super.finalize();
-        }
-    }
+    void closeAsynchronously();
 
     /**
      * Return true if closed
      *
      * @return true if closed
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public boolean isClosed() {
-        return isClosed.get();
-    }
+    boolean isClosed();
 
     /**
      * Return the {@link AsyncHttpClientConfig}
      *
      * @return {@link AsyncHttpClientConfig}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public AsyncHttpClientConfig getConfig() {
-        return config;
-    }
+    AsyncHttpClientConfig getConfig();
 
     /**
      * Set default signature calculator to use for requests build by this client instance
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        this.signatureCalculator = signatureCalculator;
-        return this;
-    }
+    AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator);
 
     /**
      * Prepare an HTTP client GET request.
@@ -456,9 +170,7 @@ public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalcu
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    public BoundRequestBuilder prepareGet(String url) {
-        return requestBuilder("GET", url);
-    }
+    BoundRequestBuilder prepareGet(String url);
 
     /**
      * Prepare an HTTP client CONNECT request.
@@ -466,10 +178,7 @@ public BoundRequestBuilder prepareGet(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public BoundRequestBuilder prepareConnect(String url) {
-        return requestBuilder("CONNECT", url);
-    }
+    BoundRequestBuilder prepareConnect(String url);
 
     /**
      * Prepare an HTTP client OPTIONS request.
@@ -477,9 +186,7 @@ public BoundRequestBuilder prepareConnect(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    public BoundRequestBuilder prepareOptions(String url) {
-        return requestBuilder("OPTIONS", url);
-    }
+    BoundRequestBuilder prepareOptions(String url);
 
     /**
      * Prepare an HTTP client HEAD request.
@@ -487,9 +194,7 @@ public BoundRequestBuilder prepareOptions(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    public BoundRequestBuilder prepareHead(String url) {
-        return requestBuilder("HEAD", url);
-    }
+    BoundRequestBuilder prepareHead(String url);
 
     /**
      * Prepare an HTTP client POST request.
@@ -497,9 +202,7 @@ public BoundRequestBuilder prepareHead(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    public BoundRequestBuilder preparePost(String url) {
-        return requestBuilder("POST", url);
-    }
+    BoundRequestBuilder preparePost(String url);
 
     /**
      * Prepare an HTTP client PUT request.
@@ -507,9 +210,7 @@ public BoundRequestBuilder preparePost(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    public BoundRequestBuilder preparePut(String url) {
-        return requestBuilder("PUT", url);
-    }
+    BoundRequestBuilder preparePut(String url);
 
     /**
      * Prepare an HTTP client DELETE request.
@@ -517,10 +218,7 @@ public BoundRequestBuilder preparePut(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public BoundRequestBuilder prepareDelete(String url) {
-        return requestBuilder("DELETE", url);
-    }
+    BoundRequestBuilder prepareDelete(String url);
 
     /**
      * Prepare an HTTP client PATCH request.
@@ -528,10 +226,7 @@ public BoundRequestBuilder prepareDelete(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public BoundRequestBuilder preparePatch(String url) {
-        return requestBuilder("PATCH", url);
-    }
+    BoundRequestBuilder preparePatch(String url);
 
     /**
      * Prepare an HTTP client TRACE request.
@@ -539,10 +234,7 @@ public BoundRequestBuilder preparePatch(String url) {
      * @param url A well formed URL.
      * @return {@link RequestBuilder}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public BoundRequestBuilder prepareTrace(String url) {
-        return requestBuilder("TRACE", url);
-    }
+    BoundRequestBuilder prepareTrace(String url);
 
     /**
      * Construct a {@link RequestBuilder} using a {@link Request}
@@ -550,10 +242,7 @@ public BoundRequestBuilder prepareTrace(String url) {
      * @param request a {@link Request}
      * @return {@link RequestBuilder}
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return requestBuilder(request);
-    }
+    BoundRequestBuilder prepareRequest(Request request);
 
     /**
      * Execute an HTTP request.
@@ -564,13 +253,7 @@ public BoundRequestBuilder prepareRequest(Request request) {
      * @return a {@link Future} of type T
      * @throws IOException
      */
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
-
-        FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
-        fc = preProcessRequest(fc);
-
-        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
-    }
+    <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException;
 
     /**
      * Execute an HTTP request.
@@ -579,86 +262,5 @@ public BoundRequestBuilder prepareRequest(Request request) {
      * @return a {@link Future} of type Response
      * @throws IOException
      */
-    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
-        FilterContext<Response> fc = new FilterContext.FilterContextBuilder<Response>().asyncHandler(new AsyncCompletionHandlerBase()).request(request).build();
-        fc = preProcessRequest(fc);
-        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
-    }
-
-    /**
-     * Configure and execute the associated {@link RequestFilter}. This class may decorate the {@link Request} and {@link AsyncHandler}
-     *
-     * @param fc {@link FilterContext}
-     * @return {@link FilterContext}
-     */
-    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws IOException {
-        for (RequestFilter asyncFilter : config.getRequestFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            } catch (FilterException e) {
-                IOException ex = new IOException();
-                ex.initCause(e);
-                throw ex;
-            }
-        }
-
-        Request request = fc.getRequest();
-        if (ResumableAsyncHandler.class.isAssignableFrom(fc.getAsyncHandler().getClass())) {
-            request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
-        }
-
-        if (request.getRangeOffset() != 0) {
-            RequestBuilder builder = new RequestBuilder(request);
-            builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
-            request = builder.build();
-        }
-        fc = new FilterContext.FilterContextBuilder<T>(fc).request(request).build();
-        return fc;
-    }
-
-    @SuppressWarnings("unchecked")
-    private static AsyncHttpProvider loadProvider(final String className,
-                                                  final AsyncHttpClientConfig config) {
-        try {
-            Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>) Thread.currentThread()
-                    .getContextClassLoader().loadClass(className);
-            return providerClass.getDeclaredConstructor(
-                    new Class[]{AsyncHttpClientConfig.class}).newInstance(config);
-        } catch (Throwable t) {
-
-            // Let's try with another classloader
-            try {
-                Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>)
-                        AsyncHttpClient.class.getClassLoader().loadClass(className);
-                return providerClass.getDeclaredConstructor(
-                        new Class[]{AsyncHttpClientConfig.class}).newInstance(config);
-            } catch (Throwable ignored) {
-            }
-        }
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    private static AsyncHttpProvider loadDefaultProvider(String[] providerClassNames,
-                                                               AsyncHttpClientConfig config) {
-        AsyncHttpProvider provider;
-        for (final String className : providerClassNames) {
-            provider = loadProvider(className, config);
-            if (provider != null) {
-                return provider;
-            }
-        }
-        throw new IllegalStateException("No providers found on the classpath");
-    }
-
-    protected BoundRequestBuilder requestBuilder(String reqType, String url) {
-        return new BoundRequestBuilder(reqType, config.isUseRawUrl()).setUrl(url).setSignatureCalculator(signatureCalculator);
-    }
-
-    protected BoundRequestBuilder requestBuilder(Request prototype) {
-        return new BoundRequestBuilder(prototype).setSignatureCalculator(signatureCalculator);
-    }
+    ListenableFuture<Response> executeRequest(Request request) throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 8e6cfa2d4..12dcda85e 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -15,43 +15,32 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.RequestFilter;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.util.AllowAllHostnameVerifier;
-import org.asynchttpclient.util.ProxyUtils;
+import static org.asynchttpclient.AsyncHttpClientConfigDefaults.*;
 
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.GeneralSecurityException;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+
+import org.asynchttpclient.date.TimeConverter;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.util.DefaultHostnameVerifier;
+import org.asynchttpclient.util.ProxyUtils;
 
 /**
  * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this
  * object default behavior by doing:
  * <p/>
  * -Dorg.asynchttpclient.AsyncHttpClientConfig.nameOfTheProperty
- * ex:
- * <p/>
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxTotalConnections
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxTotalConnections
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxConnectionsPerHost
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultConnectionTimeoutInMS
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultIdleConnectionInPoolTimeoutInMS
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultRequestTimeoutInMS
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultRedirectsEnabled
- * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxRedirects
  */
 public class AsyncHttpClientConfig {
 
@@ -78,138 +67,123 @@
         AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
     }
 
-    protected int maxTotalConnections;
-    protected int maxConnectionPerHost;
-    protected int connectionTimeOutInMs;
-    protected int webSocketIdleTimeoutInMs;
-    protected int idleConnectionInPoolTimeoutInMs;
-    protected int idleConnectionTimeoutInMs;
-    protected int requestTimeoutInMs;
-    protected boolean redirectEnabled;
-    protected int maxDefaultRedirects;
-    protected boolean compressionEnabled;
+    protected int connectionTimeout;
+
+    protected int maxConnections;
+    protected int maxConnectionsPerHost;
+
+    protected int requestTimeout;
+    protected int readTimeout;
+    protected int webSocketTimeout;
+
+    protected boolean allowPoolingConnections;
+    protected boolean allowPoolingSslConnections;
+    protected int pooledConnectionIdleTimeout;
+    protected int connectionTTL;
+
+    protected SSLContext sslContext;
+    protected HostnameVerifier hostnameVerifier;
+    protected boolean acceptAnyCertificate;
+
+    protected boolean followRedirect;
+    protected int maxRedirects;
+    protected boolean removeQueryParamOnRedirect;
+    protected boolean strict302Handling;
+
+    protected ProxyServerSelector proxyServerSelector;
+    protected boolean useRelativeURIsWithConnectProxies;
+
+    protected boolean compressionEnforced;
     protected String userAgent;
-    protected boolean allowPoolingConnection;
-    protected ScheduledExecutorService reaper;
     protected ExecutorService applicationThreadPool;
-    protected ProxyServer proxyServer;
-    protected SSLContext sslContext;
-    protected SSLEngineFactory sslEngineFactory;
-    protected AsyncHttpProviderConfig<?, ?> providerConfig;
-    protected ConnectionsPool<?, ?> connectionsPool;
     protected Realm realm;
     protected List<RequestFilter> requestFilters;
     protected List<ResponseFilter> responseFilters;
     protected List<IOExceptionFilter> ioExceptionFilters;
-    protected int requestCompressionLevel;
     protected int maxRequestRetry;
-    protected boolean allowSslConnectionPool;
-    protected boolean useRawUrl;
-    protected boolean removeQueryParamOnRedirect;
-    protected HostnameVerifier hostnameVerifier;
+    protected boolean disableUrlEncodingForBoundRequests;
     protected int ioThreadMultiplier;
-    protected boolean strict302Handling;
-    protected int maxConnectionLifeTimeInMs;
-    protected boolean useRelativeURIsWithSSLProxies;
+    protected TimeConverter timeConverter;
+    protected AsyncHttpProviderConfig<?, ?> providerConfig;
+    
+    // AHC 2 specific
     protected boolean spdyEnabled;
     protected int spdyInitialWindowSize;
     protected int spdyMaxConcurrentStreams;
-    protected boolean rfc6265CookieEncoding;
-    protected boolean asyncConnectMode;
 
     protected AsyncHttpClientConfig() {
     }
 
-    private AsyncHttpClientConfig(int maxTotalConnections,
-                                  int maxConnectionPerHost,
-                                  int connectionTimeOutInMs,
-                                  int webSocketTimeoutInMs,
-                                  int idleConnectionInPoolTimeoutInMs,
-                                  int idleConnectionTimeoutInMs,
-                                  int requestTimeoutInMs,
-                                  int connectionMaxLifeTimeInMs,
-                                  boolean redirectEnabled,
-                                  int maxDefaultRedirects,
-                                  boolean compressionEnabled,
-                                  String userAgent,
-                                  boolean keepAlive,
-                                  ScheduledExecutorService reaper,
-                                  ExecutorService applicationThreadPool,
-                                  ProxyServer proxyServer,
-                                  SSLContext sslContext,
-                                  SSLEngineFactory sslEngineFactory,
-                                  AsyncHttpProviderConfig<?, ?> providerConfig,
-                                  ConnectionsPool<?, ?> connectionsPool, Realm realm,
-                                  List<RequestFilter> requestFilters,
-                                  List<ResponseFilter> responseFilters,
-                                  List<IOExceptionFilter> ioExceptionFilters,
-                                  int requestCompressionLevel,
-                                  int maxRequestRetry,
-                                  boolean allowSslConnectionCaching,
-                                  boolean useRawUrl,
-                                  boolean removeQueryParamOnRedirect,
-                                  HostnameVerifier hostnameVerifier,
-                                  int ioThreadMultiplier,
-                                  boolean strict302Handling,
-                                  boolean useRelativeURIsWithSSLProxies,
-                                  boolean spdyEnabled,
-                                  int spdyInitialWindowSize,
-                                  int spdyMaxConcurrentStreams,
-                                  boolean rfc6265CookieEncoding,
-                                  boolean asyncConnectMode) {
-
-        this.maxTotalConnections = maxTotalConnections;
-        this.maxConnectionPerHost = maxConnectionPerHost;
-        this.connectionTimeOutInMs = connectionTimeOutInMs;
-        this.webSocketIdleTimeoutInMs = webSocketTimeoutInMs;
-        this.idleConnectionInPoolTimeoutInMs = idleConnectionInPoolTimeoutInMs;
-        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
-        this.requestTimeoutInMs = requestTimeoutInMs;
-        this.maxConnectionLifeTimeInMs = connectionMaxLifeTimeInMs;
-        this.redirectEnabled = redirectEnabled;
-        this.maxDefaultRedirects = maxDefaultRedirects;
-        this.compressionEnabled = compressionEnabled;
-        this.userAgent = userAgent;
-        this.allowPoolingConnection = keepAlive;
+    private AsyncHttpClientConfig(int connectionTimeout,//
+            int maxConnections,//
+            int maxConnectionsPerHost,//
+            int requestTimeout,//
+            int readTimeout,//
+            int webSocketTimeout,//
+            boolean allowPoolingConnection,//
+            boolean allowSslConnectionPool,//
+            int idleConnectionInPoolTimeout,//
+            int maxConnectionLifeTime,//
+            SSLContext sslContext, //
+            HostnameVerifier hostnameVerifier,//
+            boolean acceptAnyCertificate, //
+            boolean followRedirect, //
+            int maxRedirects, //
+            boolean removeQueryParamOnRedirect,//
+            boolean strict302Handling, //
+            ExecutorService applicationThreadPool,//
+            ProxyServerSelector proxyServerSelector, //
+            boolean useRelativeURIsWithConnectProxies, //
+            boolean compressionEnforced, //
+            String userAgent,//
+            Realm realm,//
+            List<RequestFilter> requestFilters,//
+            List<ResponseFilter> responseFilters,//
+            List<IOExceptionFilter> ioExceptionFilters,//
+            int maxRequestRetry, //
+            boolean disableUrlEncodingForBoundRequests, //
+            int ioThreadMultiplier, //
+            TimeConverter timeConverter,//
+            AsyncHttpProviderConfig<?, ?> providerConfig,//
+            boolean spdyEnabled, //
+            int spdyInitialWindowSize, //
+            int spdyMaxConcurrentStreams) {
+
+        this.connectionTimeout = connectionTimeout;
+        this.maxConnections = maxConnections;
+        this.maxConnectionsPerHost = maxConnectionsPerHost;
+        this.requestTimeout = requestTimeout;
+        this.readTimeout = readTimeout;
+        this.webSocketTimeout = webSocketTimeout;
+        this.allowPoolingConnections = allowPoolingConnection;
+        this.allowPoolingSslConnections = allowSslConnectionPool;
+        this.pooledConnectionIdleTimeout = idleConnectionInPoolTimeout;
+        this.connectionTTL = maxConnectionLifeTime;
         this.sslContext = sslContext;
-        this.sslEngineFactory = sslEngineFactory;
-        this.providerConfig = providerConfig;
-        this.connectionsPool = connectionsPool;
+        this.hostnameVerifier = hostnameVerifier;
+        this.acceptAnyCertificate = acceptAnyCertificate;
+        this.followRedirect = followRedirect;
+        this.maxRedirects = maxRedirects;
+        this.removeQueryParamOnRedirect = removeQueryParamOnRedirect;
+        this.strict302Handling = strict302Handling;
+        this.proxyServerSelector = proxyServerSelector;
+        this.useRelativeURIsWithConnectProxies = useRelativeURIsWithConnectProxies;
+        this.compressionEnforced = compressionEnforced;
+        this.userAgent = userAgent;
+        this.applicationThreadPool = applicationThreadPool == null ? Executors.newCachedThreadPool() : applicationThreadPool;
         this.realm = realm;
         this.requestFilters = requestFilters;
         this.responseFilters = responseFilters;
         this.ioExceptionFilters = ioExceptionFilters;
-        this.requestCompressionLevel = requestCompressionLevel;
         this.maxRequestRetry = maxRequestRetry;
-        this.reaper = reaper;
-        this.allowSslConnectionPool = allowSslConnectionCaching;
-        this.removeQueryParamOnRedirect = removeQueryParamOnRedirect;
-        this.hostnameVerifier = hostnameVerifier;
+        this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
         this.ioThreadMultiplier = ioThreadMultiplier;
-        this.strict302Handling = strict302Handling;
-        this.useRelativeURIsWithSSLProxies = useRelativeURIsWithSSLProxies;
-
-        if (applicationThreadPool == null) {
-            this.applicationThreadPool = Executors.newCachedThreadPool();
-        } else {
-            this.applicationThreadPool = applicationThreadPool;
-        }
-        this.proxyServer = proxyServer;
-        this.useRawUrl = useRawUrl;
+        this.timeConverter = timeConverter;
+        this.providerConfig = providerConfig;
         this.spdyEnabled = spdyEnabled;
         this.spdyInitialWindowSize = spdyInitialWindowSize;
         this.spdyMaxConcurrentStreams = spdyMaxConcurrentStreams;
-        this.rfc6265CookieEncoding = rfc6265CookieEncoding;
-        this.asyncConnectMode = asyncConnectMode;
-    }
-
-    /**
-     * A {@link ScheduledExecutorService} used to expire idle connections.
-     *
-     * @return {@link ScheduledExecutorService}
-     */
-    public ScheduledExecutorService reaper() {
-        return reaper;
+        
     }
 
     /**
@@ -217,8 +191,8 @@ public ScheduledExecutorService reaper() {
      *
      * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
      */
-    public int getMaxTotalConnections() {
-        return maxTotalConnections;
+    public int getMaxConnections() {
+        return maxConnections;
     }
 
     /**
@@ -226,8 +200,8 @@ public int getMaxTotalConnections() {
      *
      * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
      */
-    public int getMaxConnectionPerHost() {
-        return maxConnectionPerHost;
+    public int getMaxConnectionsPerHost() {
+        return maxConnectionsPerHost;
     }
 
     /**
@@ -235,16 +209,16 @@ public int getMaxConnectionPerHost() {
      *
      * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      */
-    public int getConnectionTimeoutInMs() {
-        return connectionTimeOutInMs;
+    public int getConnectionTimeout() {
+        return connectionTimeout;
     }
 
     /**
      * Return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
      * @return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
      */
-    public int getWebSocketIdleTimeoutInMs() {
-        return webSocketIdleTimeoutInMs;
+    public int getWebSocketTimeout() {
+        return webSocketTimeout;
     }
 
     /**
@@ -252,8 +226,8 @@ public int getWebSocketIdleTimeoutInMs() {
      *
      * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      */
-    public int getIdleConnectionTimeoutInMs() {
-        return idleConnectionTimeoutInMs;
+    public int getReadTimeout() {
+        return readTimeout;
     }
 
     /**
@@ -263,8 +237,8 @@ public int getIdleConnectionTimeoutInMs() {
      * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
      *         in pool.
      */
-    public int getIdleConnectionInPoolTimeoutInMs() {
-        return idleConnectionInPoolTimeoutInMs;
+    public int getPooledConnectionIdleTimeout() {
+        return pooledConnectionIdleTimeout;
     }
 
     /**
@@ -272,8 +246,8 @@ public int getIdleConnectionInPoolTimeoutInMs() {
      *
      * @return the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
      */
-    public int getRequestTimeoutInMs() {
-        return requestTimeoutInMs;
+    public int getRequestTimeout() {
+        return requestTimeout;
     }
 
     /**
@@ -281,8 +255,8 @@ public int getRequestTimeoutInMs() {
      *
      * @return true if enabled.
      */
-    public boolean isRedirectEnabled() {
-        return redirectEnabled;
+    public boolean isFollowRedirect() {
+        return followRedirect;
     }
 
     /**
@@ -291,7 +265,7 @@ public boolean isRedirectEnabled() {
      * @return the maximum number of HTTP redirect
      */
     public int getMaxRedirects() {
-        return maxDefaultRedirects;
+        return maxRedirects;
     }
 
     /**
@@ -299,18 +273,8 @@ public int getMaxRedirects() {
      *
      * @return true if keep-alive is enabled
      */
-    public boolean getAllowPoolingConnection() {
-        return allowPoolingConnection;
-    }
-
-    /**
-     * Is the {@link ConnectionsPool} support enabled.
-     *
-     * @return true if keep-alive is enabled
-     * @deprecated - Use {@link AsyncHttpClientConfig#getAllowPoolingConnection()}
-     */
-    public boolean getKeepAlive() {
-        return allowPoolingConnection;
+    public boolean isAllowPoolingConnections() {
+        return allowPoolingConnections;
     }
 
     /**
@@ -323,12 +287,12 @@ public String getUserAgent() {
     }
 
     /**
-     * Is HTTP compression enabled.
+     * Is HTTP compression enforced.
      *
-     * @return true if compression is enabled
+     * @return true if compression is enforced
      */
-    public boolean isCompressionEnabled() {
-        return compressionEnabled;
+    public boolean isCompressionEnforced() {
+        return compressionEnforced;
     }
 
     /**
@@ -336,7 +300,8 @@ public boolean isCompressionEnabled() {
      * asynchronous response.
      *
      * @return the {@link java.util.concurrent.ExecutorService} an {@link AsyncHttpClient} use for handling
-     *         asynchronous response.
+     *         asynchronous response.  If no {@link ExecutorService} has been explicitly provided,
+     *         this method will return <code>null</code>
      */
     public ExecutorService executorService() {
         return applicationThreadPool;
@@ -347,8 +312,8 @@ public ExecutorService executorService() {
      *
      * @return instance of {@link ProxyServer}
      */
-    public ProxyServer getProxyServer() {
-        return proxyServer;
+    public ProxyServerSelector getProxyServerSelector() {
+        return proxyServerSelector;
     }
 
     /**
@@ -360,37 +325,6 @@ public SSLContext getSSLContext() {
         return sslContext;
     }
 
-    /**
-     * Return an instance of {@link ConnectionsPool}
-     *
-     * @return an instance of {@link ConnectionsPool}
-     */
-    public ConnectionsPool<?, ?> getConnectionsPool() {
-        return connectionsPool;
-    }
-
-    /**
-     * Return an instance of {@link SSLEngineFactory} used for SSL connection.
-     *
-     * @return an instance of {@link SSLEngineFactory} used for SSL connection.
-     */
-    public SSLEngineFactory getSSLEngineFactory() {
-        if (sslEngineFactory == null) {
-            return new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() {
-                    if (sslContext != null) {
-                        SSLEngine sslEngine = sslContext.createSSLEngine();
-                        sslEngine.setUseClientMode(true);
-                        return sslEngine;
-                    } else {
-                        return null;
-                    }
-                }
-            };
-        }
-        return sslEngineFactory;
-    }
-
     /**
      * Return the {@link AsyncHttpProviderConfig}
      *
@@ -409,6 +343,15 @@ public Realm getRealm() {
         return realm;
     }
 
+    /**
+     * @return <code>true</code> if {@link RequestFilter}s have been defined.
+     *
+     * @since 2.0.0
+     */
+    public boolean hasRequestFilters() {
+        return !requestFilters.isEmpty();
+    }
+
     /**
      * Return the list of {@link RequestFilter}
      *
@@ -418,6 +361,14 @@ public Realm getRealm() {
         return Collections.unmodifiableList(requestFilters);
     }
 
+    /**
+     * @return <code>true</code> if {@link ResponseFilter}s have been defined.
+     * @since 2.0.0
+     */
+    public boolean hasResponseFilters() {
+        return !responseFilters.isEmpty();
+    }
+
     /**
      * Return the list of {@link ResponseFilter}
      *
@@ -436,15 +387,6 @@ public Realm getRealm() {
         return Collections.unmodifiableList(ioExceptionFilters);
     }
 
-    /**
-     * Return the compression level, or -1 if no compression is used.
-     *
-     * @return the compression level, or -1 if no compression is use
-     */
-    public int getRequestCompressionLevel() {
-        return requestCompressionLevel;
-    }
-
     /**
      * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
      *
@@ -459,16 +401,15 @@ public int getMaxRequestRetry() {
      *
      * @return true is enabled.
      */
-    public boolean isSslConnectionPoolEnabled() {
-        return allowSslConnectionPool;
+    public boolean isAllowPoolingSslConnections() {
+        return allowPoolingSslConnections;
     }
 
-
     /**
-     * @return the useRawUrl
+     * @return the disableUrlEncodingForBoundRequests
      */
-    public boolean isUseRawUrl() {
-        return useRawUrl;
+    public boolean isDisableUrlEncodingForBoundRequests() {
+        return disableUrlEncodingForBoundRequests;
     }
 
     /**
@@ -502,12 +443,20 @@ public boolean isRemoveQueryParamOnRedirect() {
     }
 
     /**
-     * Return true if one of the {@link java.util.concurrent.ExecutorService} has been shutdown.
-     *
-     * @return true if one of the {@link java.util.concurrent.ExecutorService} has been shutdown.
+     * @return <code>true</code> if both the application and reaper thread pools
+     * haven't yet been shutdown.
+     * @since 1.7.21
      */
-    public boolean isClosed() {
-        return applicationThreadPool.isShutdown() || reaper.isShutdown();
+    public boolean isValid() {
+        boolean atpRunning = true;
+        try {
+            atpRunning = applicationThreadPool.isShutdown();
+        } catch (Exception ignore) {
+            // isShutdown() will thrown an exception in an EE7 environment
+            // when using a ManagedExecutorService.
+            // When this is the case, we assume it's running.
+        }
+        return atpRunning;
     }
 
     /**
@@ -544,13 +493,13 @@ public boolean isStrict302Handling() {
     }
 
     /**
-     * @return<code>true</code> if AHC should use relative URIs instead of absolute ones when talking with a SSL proxy,
-     *  otherwise <code>false</code>.
+     * @return<code>true</code> if AHC should use relative URIs instead of absolute ones when talking with a SSL proxy
+     * or WebSocket proxy, otherwise <code>false</code>.
      *  
-     *  @since 1.7.12
+     *  @since 1.8.13
      */
-    public boolean isUseRelativeURIsWithSSLProxies() {
-        return useRelativeURIsWithSSLProxies;
+    public boolean isUseRelativeURIsWithConnectProxies() {
+        return useRelativeURIsWithConnectProxies;
     }
 
     /**
@@ -558,130 +507,123 @@ public boolean isUseRelativeURIsWithSSLProxies() {
      *
      * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      */
-    public int getMaxConnectionLifeTimeInMs() {
-        return maxConnectionLifeTimeInMs;
+    public int getConnectionTTL() {
+        return connectionTTL;
     }
 
     /**
-     * @return<code>true</code> if AHC should use rfc6265 for encoding client side cookies, otherwise <code>false</code>.
-     * 
-     * @since 1.7.18
-     */
-    public boolean isRfc6265CookieEncoding() {
-        return rfc6265CookieEncoding;
-    }
-
-    /**
-     * @return <code>true</code> if the underlying provider should make new connections asynchronously or not.  By default
-     *  new connections are made synchronously.
+     * @return the TimeConverter used for converting RFC2616Dates into time
      *
      * @since 2.0.0
      */
-    public boolean isAsyncConnectMode() {
-        return asyncConnectMode;
+    public TimeConverter getTimeConverter() {
+        return timeConverter;
+    }
+
+    public boolean isAcceptAnyCertificate() {
+        return acceptAnyCertificate;
     }
 
     /**
      * Builder for an {@link AsyncHttpClient}
      */
     public static class Builder {
-        private int defaultMaxTotalConnections = Integer.getInteger(ASYNC_CLIENT + "defaultMaxTotalConnections", -1);
-        private int defaultMaxConnectionPerHost = Integer.getInteger(ASYNC_CLIENT + "defaultMaxConnectionsPerHost", -1);
-        private int defaultConnectionTimeOutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultConnectionTimeoutInMS", 60 * 1000);
-        private int defaultWebsocketIdleTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultWebsocketTimoutInMS", 15 * 60 * 1000);
-        private int defaultIdleConnectionInPoolTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionInPoolTimeoutInMS", 60 * 1000);
-        private int defaultIdleConnectionTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionTimeoutInMS", 60 * 1000);
-        private int defaultRequestTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultRequestTimeoutInMS", 60 * 1000);
-        private int defaultMaxConnectionLifeTimeInMs = Integer.getInteger(ASYNC_CLIENT + "defaultMaxConnectionLifeTimeInMs", -1);
-        private boolean redirectEnabled = Boolean.getBoolean(ASYNC_CLIENT + "defaultRedirectsEnabled");
-        private int maxDefaultRedirects = Integer.getInteger(ASYNC_CLIENT + "defaultMaxRedirects", 5);
-        private boolean compressionEnabled = Boolean.getBoolean(ASYNC_CLIENT + "compressionEnabled");
-        private String userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "AsyncHttpClient/" + AHC_VERSION);
-        private boolean useProxyProperties = Boolean.getBoolean(ASYNC_CLIENT + "useProxyProperties");
-        private boolean allowPoolingConnection = true;
-        private boolean useRelativeURIsWithSSLProxies = Boolean.getBoolean(ASYNC_CLIENT + "useRelativeURIsWithSSLProxies");
-        private ScheduledExecutorService reaper;
-        private ExecutorService applicationThreadPool;
-        private ProxyServer proxyServer = null;
+        private int connectionTimeout = defaultConnectionTimeout();
+        private int maxConnections = defaultMaxConnections();
+        private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
+        private int requestTimeout = defaultRequestTimeout();
+        private int readTimeout = defaultReadTimeout();
+        private int webSocketTimeout = defaultWebSocketTimeout();
+        private boolean allowPoolingConnections = defaultAllowPoolingConnections();
+        private boolean allowPoolingSslConnections = defaultAllowPoolingSslConnections();
+        private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+        private int connectionTTL = defaultConnectionTTL();
         private SSLContext sslContext;
-        private SSLEngineFactory sslEngineFactory;
-        private AsyncHttpProviderConfig<?, ?> providerConfig;
-        private ConnectionsPool<?, ?> connectionsPool;
+        private HostnameVerifier hostnameVerifier;
+        private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
+        private boolean followRedirect = defaultFollowRedirect();
+        private int maxRedirects = defaultMaxRedirects();
+        private boolean removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
+        private boolean strict302Handling = defaultStrict302Handling();
+        private ProxyServerSelector proxyServerSelector = null;
+        private boolean useProxySelector = defaultUseProxySelector();
+        private boolean useProxyProperties = defaultUseProxyProperties();
+        private boolean useRelativeURIsWithConnectProxies = defaultUseRelativeURIsWithConnectProxies();
+        private boolean compressionEnforced = defaultCompressionEnforced();
+        private String userAgent = defaultUserAgent();
+        private ExecutorService applicationThreadPool;
         private Realm realm;
-        private int requestCompressionLevel = -1;
-        private int maxRequestRetry = 5;
         private final List<RequestFilter> requestFilters = new LinkedList<RequestFilter>();
         private final List<ResponseFilter> responseFilters = new LinkedList<ResponseFilter>();
         private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<IOExceptionFilter>();
-        private boolean allowSslConnectionPool = true;
-        private boolean useRawUrl = false;
-        private boolean removeQueryParamOnRedirect = true;
-        private HostnameVerifier hostnameVerifier = new AllowAllHostnameVerifier();
-        private int ioThreadMultiplier = 2;
-        private boolean strict302Handling;
-        private boolean spdyEnabled;
-        private int spdyInitialWindowSize = 10 * 1024 * 1024;
-        private int spdyMaxConcurrentStreams = 100;
-        private boolean rfc6265CookieEncoding;
-        private boolean asyncConnectMode;
-
+        private int maxRequestRetry = defaultMaxRequestRetry();
+        private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
+        private int ioThreadMultiplier = defaultIoThreadMultiplier();
+        private TimeConverter timeConverter;
+        private AsyncHttpProviderConfig<?, ?> providerConfig;
+        
+        // AHC 2
+        private boolean spdyEnabled = defaultSpdyEnabled();
+        private int spdyInitialWindowSize = defaultSpdyInitialWindowSize();
+        private int spdyMaxConcurrentStreams = defaultSpdyMaxConcurrentStreams();
+        
         public Builder() {
         }
 
         /**
          * Set the maximum number of connections an {@link AsyncHttpClient} can handle.
          *
-         * @param defaultMaxTotalConnections the maximum number of connections an {@link AsyncHttpClient} can handle.
+         * @param maxConnections the maximum number of connections an {@link AsyncHttpClient} can handle.
          * @return a {@link Builder}
          */
-        public Builder setMaximumConnectionsTotal(int defaultMaxTotalConnections) {
-            this.defaultMaxTotalConnections = defaultMaxTotalConnections;
+        public Builder setMaxConnections(int maxConnections) {
+            this.maxConnections = maxConnections;
             return this;
         }
 
         /**
          * Set the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
          *
-         * @param defaultMaxConnectionPerHost the maximum number of connections per host an {@link AsyncHttpClient} can handle.
+         * @param maxConnectionsPerHost the maximum number of connections per host an {@link AsyncHttpClient} can handle.
          * @return a {@link Builder}
          */
-        public Builder setMaximumConnectionsPerHost(int defaultMaxConnectionPerHost) {
-            this.defaultMaxConnectionPerHost = defaultMaxConnectionPerHost;
+        public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
+            this.maxConnectionsPerHost = maxConnectionsPerHost;
             return this;
         }
 
         /**
          * Set the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
          *
-         * @param defaultConnectionTimeOutInMs the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+         * @param connectionTimeout the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
          * @return a {@link Builder}
          */
-        public Builder setConnectionTimeoutInMs(int defaultConnectionTimeOutInMs) {
-            this.defaultConnectionTimeOutInMs = defaultConnectionTimeOutInMs;
+        public Builder setConnectionTimeout(int connectionTimeout) {
+            this.connectionTimeout = connectionTimeout;
             return this;
         }
 
         /**
          * Set the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
          *
-         * @param defaultWebSocketIdleTimeoutInMs
+         * @param webSocketTimeout
          *         the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
          * @return a {@link Builder}
          */
-        public Builder setWebSocketIdleTimeoutInMs(int defaultWebSocketIdleTimeoutInMs) {
-            this.defaultWebsocketIdleTimeoutInMs = defaultWebSocketIdleTimeoutInMs;
+        public Builder setWebSocketTimeout(int webSocketTimeout) {
+            this.webSocketTimeout = webSocketTimeout;
             return this;
         }
 
         /**
          * Set the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
          *
-         * @param defaultIdleConnectionTimeoutInMs
+         * @param readTimeout
          *         the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
          * @return a {@link Builder}
          */
-        public Builder setIdleConnectionTimeoutInMs(int defaultIdleConnectionTimeoutInMs) {
-            this.defaultIdleConnectionTimeoutInMs = defaultIdleConnectionTimeoutInMs;
+        public Builder setReadTimeout(int readTimeout) {
+            this.readTimeout = readTimeout;
             return this;
         }
 
@@ -689,24 +631,24 @@ public Builder setIdleConnectionTimeoutInMs(int defaultIdleConnectionTimeoutInMs
          * Set the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
          * idle in pool.
          *
-         * @param defaultIdleConnectionInPoolTimeoutInMs
+         * @param pooledConnectionIdleTimeout
          *         the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
          *         idle in pool.
          * @return a {@link Builder}
          */
-        public Builder setIdleConnectionInPoolTimeoutInMs(int defaultIdleConnectionInPoolTimeoutInMs) {
-            this.defaultIdleConnectionInPoolTimeoutInMs = defaultIdleConnectionInPoolTimeoutInMs;
+        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+            this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
             return this;
         }
 
         /**
          * Set the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
          *
-         * @param defaultRequestTimeoutInMs the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
+         * @param requestTimeout the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
          * @return a {@link Builder}
          */
-        public Builder setRequestTimeoutInMs(int defaultRequestTimeoutInMs) {
-            this.defaultRequestTimeoutInMs = defaultRequestTimeoutInMs;
+        public Builder setRequestTimeout(int requestTimeout) {
+            this.requestTimeout = requestTimeout;
             return this;
         }
 
@@ -716,30 +658,30 @@ public Builder setRequestTimeoutInMs(int defaultRequestTimeoutInMs) {
          * @param redirectEnabled true if enabled.
          * @return a {@link Builder}
          */
-        public Builder setFollowRedirects(boolean redirectEnabled) {
-            this.redirectEnabled = redirectEnabled;
+        public Builder setFollowRedirect(boolean followRedirect) {
+            this.followRedirect = followRedirect;
             return this;
         }
 
         /**
          * Set the maximum number of HTTP redirect
          *
-         * @param maxDefaultRedirects the maximum number of HTTP redirect
+         * @param maxRedirects the maximum number of HTTP redirect
          * @return a {@link Builder}
          */
-        public Builder setMaximumNumberOfRedirects(int maxDefaultRedirects) {
-            this.maxDefaultRedirects = maxDefaultRedirects;
+        public Builder setMaxRedirects(int maxRedirects) {
+            this.maxRedirects = maxRedirects;
             return this;
         }
 
         /**
-         * Enable HTTP compression.
+         * Enforce HTTP compression.
          *
-         * @param compressionEnabled true if compression is enabled
+         * @param compressionEnabled true if compression is enforced
          * @return a {@link Builder}
          */
-        public Builder setCompressionEnabled(boolean compressionEnabled) {
-            this.compressionEnabled = compressionEnabled;
+        public Builder setCompressionEnforced(boolean compressionEnforced) {
+            this.compressionEnforced = compressionEnforced;
             return this;
         }
 
@@ -757,34 +699,11 @@ public Builder setUserAgent(String userAgent) {
         /**
          * Set true if connection can be pooled by a {@link ConnectionsPool}. Default is true.
          *
-         * @param allowPoolingConnection true if connection can be pooled by a {@link ConnectionsPool}
+         * @param allowPoolingConnections true if connection can be pooled by a {@link ConnectionsPool}
          * @return a {@link Builder}
          */
-        public Builder setAllowPoolingConnection(boolean allowPoolingConnection) {
-            this.allowPoolingConnection = allowPoolingConnection;
-            return this;
-        }
-
-        /**
-         * Set true if connection can be pooled by a {@link ConnectionsPool}. Default is true.
-         *
-         * @param allowPoolingConnection true if connection can be pooled by a {@link ConnectionsPool}
-         * @return a {@link Builder}
-         * @deprecated - Use {@link AsyncHttpClientConfig.Builder#setAllowPoolingConnection(boolean)}
-         */
-        public Builder setKeepAlive(boolean allowPoolingConnection) {
-            this.allowPoolingConnection = allowPoolingConnection;
-            return this;
-        }
-
-        /**
-         * Set the{@link ScheduledExecutorService} used to expire idle connections.
-         *
-         * @param reaper the{@link ScheduledExecutorService} used to expire idle connections.
-         * @return a {@link Builder}
-         */
-        public Builder setScheduledExecutorService(ScheduledExecutorService reaper) {
-            this.reaper = reaper;
+        public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
+            this.allowPoolingConnections = allowPoolingConnections;
             return this;
         }
 
@@ -802,24 +721,24 @@ public Builder setExecutorService(ExecutorService applicationThreadPool) {
         }
 
         /**
-         * Set an instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
+         * Set an instance of {@link ProxyServerSelector} used by an {@link AsyncHttpClient}
          *
-         * @param proxyServer instance of {@link ProxyServer}
+         * @param proxyServerSelector instance of {@link ProxyServerSelector}
          * @return a {@link Builder}
          */
-        public Builder setProxyServer(ProxyServer proxyServer) {
-            this.proxyServer = proxyServer;
+        public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
+            this.proxyServerSelector = proxyServerSelector;
             return this;
         }
 
         /**
-         * Set the {@link SSLEngineFactory} for secure connection.
+         * Set an instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
          *
-         * @param sslEngineFactory the {@link SSLEngineFactory} for secure connection
+         * @param proxyServer instance of {@link ProxyServer}
          * @return a {@link Builder}
          */
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            this.sslEngineFactory = sslEngineFactory;
+        public Builder setProxyServer(ProxyServer proxyServer) {
+            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
             return this;
         }
 
@@ -830,13 +749,6 @@ public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
          * @return a {@link Builder}
          */
         public Builder setSSLContext(final SSLContext sslContext) {
-            this.sslEngineFactory = new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() throws GeneralSecurityException {
-                    SSLEngine sslEngine = sslContext.createSSLEngine();
-                    sslEngine.setUseClientMode(true);
-                    return sslEngine;
-                }
-            };
             this.sslContext = sslContext;
             return this;
         }
@@ -852,17 +764,6 @@ public Builder setAsyncHttpClientProviderConfig(AsyncHttpProviderConfig<?, ?> pr
             return this;
         }
 
-        /**
-         * Set the {@link ConnectionsPool}
-         *
-         * @param connectionsPool the {@link ConnectionsPool}
-         * @return a {@link Builder}
-         */
-        public Builder setConnectionsPool(ConnectionsPool<?, ?> connectionsPool) {
-            this.connectionsPool = connectionsPool;
-            return this;
-        }
-
         /**
          * Set the {@link Realm}  that will be used for all requests.
          *
@@ -944,26 +845,6 @@ public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
             return this;
         }
 
-        /**
-         * Return the compression level, or -1 if no compression is used.
-         *
-         * @return the compression level, or -1 if no compression is use
-         */
-        public int getRequestCompressionLevel() {
-            return requestCompressionLevel;
-        }
-
-        /**
-         * Set the compression level, or -1 if no compression is used.
-         *
-         * @param requestCompressionLevel compression level, or -1 if no compression is use
-         * @return this
-         */
-        public Builder setRequestCompressionLevel(int requestCompressionLevel) {
-            this.requestCompressionLevel = requestCompressionLevel;
-            return this;
-        }
-
         /**
          * Set the number of times a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
          *
@@ -978,11 +859,11 @@ public Builder setMaxRequestRetry(int maxRequestRetry) {
         /**
          * Return true is if connections pooling is enabled.
          *
-         * @param allowSslConnectionPool true if enabled
+         * @param pooledConnectionIdleTimeout true if enabled
          * @return this
          */
-        public Builder setAllowSslConnectionPool(boolean allowSslConnectionPool) {
-            this.allowSslConnectionPool = allowSslConnectionPool;
+        public Builder setAllowPoolingSslConnections(boolean allowPoolingSslConnections) {
+            this.allowPoolingSslConnections = allowPoolingSslConnections;
             return this;
         }
 
@@ -990,11 +871,11 @@ public Builder setAllowSslConnectionPool(boolean allowSslConnectionPool) {
          * Allows use unescaped URLs in requests
          * useful for retrieving data from broken sites
          *
-         * @param useRawUrl
+         * @param disableUrlEncodingForBoundRequests
          * @return this
          */
-        public Builder setUseRawUrl(boolean useRawUrl) {
-            this.useRawUrl = useRawUrl;
+        public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
+            this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
             return this;
         }
 
@@ -1009,12 +890,27 @@ public Builder setRemoveQueryParamsOnRedirect(boolean removeQueryParamOnRedirect
             return this;
         }
 
+        /**
+         * Sets whether AHC should use the default JDK ProxySelector to select a proxy server.
+         * <p/>
+         * If useProxySelector is set to <code>true</code> but {@link #setProxyServer(ProxyServer)}
+         * was used to explicitly set a proxy server, the latter is preferred.
+         * <p/>
+         * See http://docs.oracle.com/javase/7/docs/api/java/net/ProxySelector.html
+         */
+        public Builder setUseProxySelector(boolean useProxySelector) {
+            this.useProxySelector = useProxySelector;
+            return this;
+        }
+
         /**
          * Sets whether AHC should use the default http.proxy* system properties
-         * to obtain proxy information.
+         * to obtain proxy information.  This differs from {@link #setUseProxySelector(boolean)}
+         * in that AsyncHttpClient will use its own logic to handle the system properties,
+         * potentially supporting other protocols that the the JDK ProxySelector doesn't.
          * <p/>
-         * If useProxyProperties is set to <code>true</code> but {@link #setProxyServer(ProxyServer)} was used
-         * to explicitly set a proxy server, the latter is preferred.
+         * If useProxyProperties is set to <code>true</code> but {@link #setUseProxySelector(boolean)}
+         * was also set to true, the latter is preferred.
          * <p/>
          * See http://download.oracle.com/javase/1.4.2/docs/guide/net/properties.html
          */
@@ -1057,24 +953,24 @@ public Builder setStrict302Handling(final boolean strict302Handling) {
         /**
          * Set the maximum time in millisecond connection can be added to the pool for further reuse
          *
-         * @param maxConnectionLifeTimeInMs the maximum time in millisecond connection can be added to the pool for further reuse
+         * @param connectionTTL the maximum time in millisecond connection can be added to the pool for further reuse
          * @return a {@link Builder}
          */
-        public Builder setMaxConnectionLifeTimeInMs(int maxConnectionLifeTimeInMs) {
-           this.defaultMaxConnectionLifeTimeInMs = maxConnectionLifeTimeInMs;
-           return this;
+        public Builder setConnectionTTL(int connectionTTL) {
+            this.connectionTTL = connectionTTL;
+            return this;
         }
 
         /**
-         * Configures this AHC instance to use relative URIs instead of absolute ones when talking with a SSL proxy.
+         * Configures this AHC instance to use relative URIs instead of absolute ones when talking with a SSL or WebSocket proxy.
          *
-         * @param useRelativeURIsWithSSLProxies
+         * @param useRelativeURIsWithConnectProxies
          * @return this
          *
          * @since 1.7.2
          */
-        public Builder setUseRelativeURIsWithSSLProxies(boolean useRelativeURIsWithSSLProxies) {
-            this.useRelativeURIsWithSSLProxies = useRelativeURIsWithSSLProxies;
+        public Builder setUseRelativeURIsWithConnectProxies(boolean useRelativeURIsWithConnectProxies) {
+            this.useRelativeURIsWithConnectProxies = useRelativeURIsWithConnectProxies;
             return this;
         }
 
@@ -1123,59 +1019,38 @@ public Builder setSpdyMaxConcurrentStreams(int spdyMaxConcurrentStreams) {
             return this;
         }
 
-        /**
-         * Configures this AHC instance to use RFC 6265 cookie encoding style
-         * 
-         * @param rfc6265CookieEncoding
-         * @return this
-         * 
-         * @since 1.7.18
-         */
-        public Builder setRfc6265CookieEncoding(boolean rfc6265CookieEncoding) {
-            this.rfc6265CookieEncoding = rfc6265CookieEncoding;
+        public Builder setTimeConverter(TimeConverter timeConverter) {
+            this.timeConverter = timeConverter;
             return this;
         }
 
-        /**
-         * Configures how the underlying providers make new connections.  By default,
-         * connections will be made synchronously.
-         *
-         * @param asyncConnectMode pass <code>true</code> to enable async connect mode.
-         *
-         * @return this
-         *
-         * @since 2.0.0
-         */
-        public Builder setAsyncConnectMode(boolean asyncConnectMode) {
-            this.asyncConnectMode = asyncConnectMode;
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            this.acceptAnyCertificate = acceptAnyCertificate;
             return this;
         }
-
+        
         /**
          * Create a config builder with values taken from the given prototype configuration.
          *
          * @param prototype the configuration to use as a prototype.
          */
         public Builder(AsyncHttpClientConfig prototype) {
-            allowPoolingConnection = prototype.getAllowPoolingConnection();
+            allowPoolingConnections = prototype.isAllowPoolingConnections();
             providerConfig = prototype.getAsyncHttpProviderConfig();
-            connectionsPool = prototype.getConnectionsPool();
-            defaultConnectionTimeOutInMs = prototype.getConnectionTimeoutInMs();
-            defaultIdleConnectionInPoolTimeoutInMs = prototype.getIdleConnectionInPoolTimeoutInMs();
-            defaultIdleConnectionTimeoutInMs = prototype.getIdleConnectionTimeoutInMs();
-            defaultMaxConnectionPerHost = prototype.getMaxConnectionPerHost();
-            defaultMaxConnectionLifeTimeInMs = prototype.getMaxConnectionLifeTimeInMs();
-            maxDefaultRedirects = prototype.getMaxRedirects();
-            defaultMaxTotalConnections = prototype.getMaxTotalConnections();
-            proxyServer = prototype.getProxyServer();
+            connectionTimeout = prototype.getConnectionTimeout();
+            pooledConnectionIdleTimeout = prototype.getPooledConnectionIdleTimeout();
+            readTimeout = prototype.getReadTimeout();
+            maxConnectionsPerHost = prototype.getMaxConnectionsPerHost();
+            connectionTTL = prototype.getConnectionTTL();
+            maxRedirects = prototype.getMaxRedirects();
+            maxConnections = prototype.getMaxConnections();
+            proxyServerSelector = prototype.getProxyServerSelector();
             realm = prototype.getRealm();
-            defaultRequestTimeoutInMs = prototype.getRequestTimeoutInMs();
+            requestTimeout = prototype.getRequestTimeout();
             sslContext = prototype.getSSLContext();
-            sslEngineFactory = prototype.getSSLEngineFactory();
             userAgent = prototype.getUserAgent();
-            redirectEnabled = prototype.isRedirectEnabled();
-            compressionEnabled = prototype.isCompressionEnabled();
-            reaper = prototype.reaper();
+            followRedirect = prototype.isFollowRedirect();
+            compressionEnforced = prototype.isCompressionEnforced();
             applicationThreadPool = prototype.executorService();
 
             requestFilters.clear();
@@ -1186,17 +1061,19 @@ public Builder(AsyncHttpClientConfig prototype) {
             responseFilters.addAll(prototype.getResponseFilters());
             ioExceptionFilters.addAll(prototype.getIOExceptionFilters());
 
-            requestCompressionLevel = prototype.getRequestCompressionLevel();
-            useRawUrl = prototype.isUseRawUrl();
+            disableUrlEncodingForBoundRequests = prototype.isDisableUrlEncodingForBoundRequests();
             ioThreadMultiplier = prototype.getIoThreadMultiplier();
             maxRequestRetry = prototype.getMaxRequestRetry();
-            allowSslConnectionPool = prototype.getAllowPoolingConnection();
+            allowPoolingSslConnections = prototype.isAllowPoolingConnections();
             removeQueryParamOnRedirect = prototype.isRemoveQueryParamOnRedirect();
             hostnameVerifier = prototype.getHostnameVerifier();
             strict302Handling = prototype.isStrict302Handling();
-            useRelativeURIsWithSSLProxies = prototype.isUseRelativeURIsWithSSLProxies();
-            rfc6265CookieEncoding = prototype.isRfc6265CookieEncoding();
-            asyncConnectMode = prototype.isAsyncConnectMode();
+            timeConverter = prototype.timeConverter;
+            acceptAnyCertificate = prototype.acceptAnyCertificate;
+            
+            spdyEnabled = prototype.isSpdyEnabled();
+            spdyInitialWindowSize = prototype.getSpdyInitialWindowSize();
+            spdyMaxConcurrentStreams = prototype.getSpdyMaxConcurrentStreams();
         }
 
         /**
@@ -1205,77 +1082,55 @@ public Builder(AsyncHttpClientConfig prototype) {
          * @return an {@link AsyncHttpClientConfig}
          */
         public AsyncHttpClientConfig build() {
-            
-            if (reaper == null) {
-                reaper = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
-                    public Thread newThread(Runnable r) {
-                        Thread t = new Thread(r, "AsyncHttpClient-Reaper");
-                        t.setDaemon(true);
-                        return t;
-                    }
-                });
-            }
-
-            if (applicationThreadPool == null) {
-                applicationThreadPool =
-                        Executors.newCachedThreadPool(new ThreadFactory() {
-                            final AtomicInteger counter = new AtomicInteger();
-                            public Thread newThread(Runnable r) {
-                                Thread t = new Thread(r,
-                                                      "AsyncHttpClient-Callback-" + counter.incrementAndGet());
-                                t.setDaemon(true);
-                                return t;
-                            }
-                        });
-            }
 
-            if (applicationThreadPool.isShutdown()) {
-                throw new IllegalStateException("ExecutorServices closed");
-            }
-
-            if (proxyServer == null && useProxyProperties) {
-                proxyServer = ProxyUtils.createProxy(System.getProperties());
-            }
-
-            return new AsyncHttpClientConfig(defaultMaxTotalConnections,
-                    defaultMaxConnectionPerHost,
-                    defaultConnectionTimeOutInMs,
-                    defaultWebsocketIdleTimeoutInMs,
-                    defaultIdleConnectionInPoolTimeoutInMs,
-                    defaultIdleConnectionTimeoutInMs,
-                    defaultRequestTimeoutInMs,
-                    defaultMaxConnectionLifeTimeInMs,
-                    redirectEnabled,
-                    maxDefaultRedirects,
-                    compressionEnabled,
-                    userAgent,
-                    allowPoolingConnection,
-                    reaper,
-                    applicationThreadPool,
-                    proxyServer,
-                    sslContext,
-                    sslEngineFactory,
-                    providerConfig,
-                    connectionsPool,
-                    realm,
-                    requestFilters,
-                    responseFilters,
-                    ioExceptionFilters,
-                    requestCompressionLevel,
-                    maxRequestRetry,
-                    allowSslConnectionPool,
-                    useRawUrl,
-                    removeQueryParamOnRedirect,
-                    hostnameVerifier,
-                    ioThreadMultiplier,
-                    strict302Handling,
-                    useRelativeURIsWithSSLProxies,
-                    spdyEnabled,
-                    spdyInitialWindowSize,
-                    spdyMaxConcurrentStreams,
-                    rfc6265CookieEncoding,
-                    asyncConnectMode);
+            if (proxyServerSelector == null && useProxySelector)
+                proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
+
+            if (proxyServerSelector == null && useProxyProperties)
+                proxyServerSelector = ProxyUtils.createProxyServerSelector(System.getProperties());
+
+            if (proxyServerSelector == null)
+                proxyServerSelector = ProxyServerSelector.NO_PROXY_SELECTOR;
+
+            if (acceptAnyCertificate)
+                hostnameVerifier = null;
+            else if (hostnameVerifier == null)
+                hostnameVerifier = new DefaultHostnameVerifier();
+
+            return new AsyncHttpClientConfig(connectionTimeout,//
+                    maxConnections,//
+                    maxConnectionsPerHost,//
+                    requestTimeout,//
+                    readTimeout,//
+                    webSocketTimeout,//
+                    allowPoolingConnections,//
+                    allowPoolingSslConnections,//
+                    pooledConnectionIdleTimeout,//
+                    connectionTTL,//
+                    sslContext, //
+                    hostnameVerifier,//
+                    acceptAnyCertificate, //
+                    followRedirect, //
+                    maxRedirects, //
+                    removeQueryParamOnRedirect,//
+                    strict302Handling, //
+                    applicationThreadPool, //
+                    proxyServerSelector, //
+                    useRelativeURIsWithConnectProxies, //
+                    compressionEnforced, //
+                    userAgent,//
+                    realm,//
+                    requestFilters, //
+                    responseFilters,//
+                    ioExceptionFilters,//
+                    maxRequestRetry, //
+                    disableUrlEncodingForBoundRequests, //
+                    ioThreadMultiplier, //
+                    timeConverter,//
+                    providerConfig, //
+                    spdyEnabled, //
+                    spdyInitialWindowSize, //
+                    spdyMaxConcurrentStreams);
         }
     }
 }
-
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
index 4e48491b3..aa2a5c0d6 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.AsyncHttpClientConfigDefaults.*;
+
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
@@ -19,15 +21,14 @@
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
+
 import java.util.LinkedList;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
 
 /**
- * Simple JavaBean version of  {@link AsyncHttpClientConfig}
+ * Simple JavaBean version of {@link AsyncHttpClientConfig}
  */
 public class AsyncHttpClientConfigBean extends AsyncHttpClientConfig {
 
@@ -44,44 +45,40 @@ void configureFilters() {
     }
 
     void configureDefaults() {
-        maxTotalConnections = Integer.getInteger(ASYNC_CLIENT + "defaultMaxTotalConnections", -1);
-        maxConnectionPerHost = Integer.getInteger(ASYNC_CLIENT + "defaultMaxConnectionsPerHost", -1);
-        connectionTimeOutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultConnectionTimeoutInMS", 60 * 1000);
-        idleConnectionInPoolTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionInPoolTimeoutInMS", 60 * 1000);
-        idleConnectionTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionTimeoutInMS", 60 * 1000);
-        requestTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultRequestTimeoutInMS", 60 * 1000);
-        redirectEnabled = Boolean.getBoolean(ASYNC_CLIENT + "defaultRedirectsEnabled");
-        maxDefaultRedirects = Integer.getInteger(ASYNC_CLIENT + "defaultMaxRedirects", 5);
-        compressionEnabled = Boolean.getBoolean(ASYNC_CLIENT + "compressionEnabled");
-        userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "AsyncHttpClient/" + AHC_VERSION);
-
-        boolean useProxyProperties = Boolean.getBoolean(ASYNC_CLIENT + "useProxyProperties");
-        if (useProxyProperties) {
-            proxyServer = ProxyUtils.createProxy(System.getProperties());
+        maxConnections = defaultMaxConnections();
+        maxConnectionsPerHost = defaultMaxConnectionsPerHost();
+        connectionTimeout = defaultConnectionTimeout();
+        webSocketTimeout = defaultWebSocketTimeout();
+        pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+        readTimeout = defaultReadTimeout();
+        requestTimeout = defaultRequestTimeout();
+        connectionTTL = defaultConnectionTTL();
+        followRedirect = defaultFollowRedirect();
+        maxRedirects = defaultMaxRedirects();
+        compressionEnforced = defaultCompressionEnforced();
+        userAgent = defaultUserAgent();
+        allowPoolingConnections = defaultAllowPoolingConnections();
+        useRelativeURIsWithConnectProxies = defaultUseRelativeURIsWithConnectProxies();
+        maxRequestRetry = defaultMaxRequestRetry();
+        ioThreadMultiplier = defaultIoThreadMultiplier();
+        allowPoolingSslConnections = defaultAllowPoolingSslConnections();
+        disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
+        removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
+        strict302Handling = defaultStrict302Handling();
+        acceptAnyCertificate = defaultAcceptAnyCertificate();
+
+        if (defaultUseProxySelector()) {
+            proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
+        } else if (defaultUseProxyProperties()) {
+            proxyServerSelector = ProxyUtils.createProxyServerSelector(System.getProperties());
         }
-
-        allowPoolingConnection = true;
-        requestCompressionLevel = -1;
-        maxRequestRetry = 5;
-        allowSslConnectionPool = true;
-        useRawUrl = false;
-        removeQueryParamOnRedirect = true;
-        hostnameVerifier = new HostnameVerifier() {
-
-            public boolean verify(String s, SSLSession sslSession) {
-                return true;
-            }
-        };
+        // AHC 2
+        spdyEnabled = defaultSpdyEnabled();
+        spdyInitialWindowSize = defaultSpdyInitialWindowSize();
+        spdyMaxConcurrentStreams = defaultSpdyMaxConcurrentStreams();
     }
 
     void configureExecutors() {
-        reaper = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
-            public Thread newThread(Runnable r) {
-                Thread t = new Thread(r, "AsyncHttpClient-Reaper");
-                t.setDaemon(true);
-                return t;
-            }
-        });
         applicationThreadPool = Executors.newCachedThreadPool(new ThreadFactory() {
             public Thread newThread(Runnable r) {
                 Thread t = new Thread(r, "AsyncHttpClient-Callback");
@@ -91,66 +88,68 @@ public Thread newThread(Runnable r) {
         });
     }
 
-    public AsyncHttpClientConfigBean setMaxTotalConnections(int maxTotalConnections) {
-        this.maxTotalConnections = maxTotalConnections;
+    public AsyncHttpClientConfigBean setMaxTotalConnections(int maxConnections) {
+        this.maxConnections = maxConnections;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setMaxConnectionPerHost(int maxConnectionPerHost) {
-        this.maxConnectionPerHost = maxConnectionPerHost;
+    public AsyncHttpClientConfigBean setMaxConnectionsPerHost(int maxConnectionsPerHost) {
+        this.maxConnectionsPerHost = maxConnectionsPerHost;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setConnectionTimeOutInMs(int connectionTimeOutInMs) {
-        this.connectionTimeOutInMs = connectionTimeOutInMs;
+    public AsyncHttpClientConfigBean setConnectionTimeout(int connectionTimeout) {
+        this.connectionTimeout = connectionTimeout;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setIdleConnectionInPoolTimeoutInMs(int idleConnectionInPoolTimeoutInMs) {
-        this.idleConnectionInPoolTimeoutInMs = idleConnectionInPoolTimeoutInMs;
+    public AsyncHttpClientConfigBean setConnectionTTL(int connectionTTL) {
+        this.connectionTTL = connectionTTL;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setIdleConnectionTimeoutInMs(int idleConnectionTimeoutInMs) {
-        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
+    public AsyncHttpClientConfigBean setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+        this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setRequestTimeoutInMs(int requestTimeoutInMs) {
-        this.requestTimeoutInMs = requestTimeoutInMs;
+    public AsyncHttpClientConfigBean setReadTimeout(int readTimeout) {
+        this.readTimeout = readTimeout;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setRedirectEnabled(boolean redirectEnabled) {
-        this.redirectEnabled = redirectEnabled;
+    public AsyncHttpClientConfigBean setRequestTimeout(int requestTimeout) {
+        this.requestTimeout = requestTimeout;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setMaxDefaultRedirects(int maxDefaultRedirects) {
-        this.maxDefaultRedirects = maxDefaultRedirects;
+    public AsyncHttpClientConfigBean setFollowRedirect(boolean followRedirect) {
+        this.followRedirect = followRedirect;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setCompressionEnabled(boolean compressionEnabled) {
-        this.compressionEnabled = compressionEnabled;
+    public AsyncHttpClientConfigBean setMaxRedirects(int maxRedirects) {
+        this.maxRedirects = maxRedirects;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setUserAgent(String userAgent) {
-        this.userAgent = userAgent;
+    public AsyncHttpClientConfigBean setStrict302Handling(boolean strict302Handling) {
+        this.strict302Handling = strict302Handling;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setAllowPoolingConnection(boolean allowPoolingConnection) {
-        this.allowPoolingConnection = allowPoolingConnection;
+    public AsyncHttpClientConfigBean setCompressionEnforced(boolean compressionEnforced) {
+        this.compressionEnforced = compressionEnforced;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setReaper(ScheduledExecutorService reaper) {
-        if (this.reaper != null) {
-            this.reaper.shutdownNow();
-        }
-        this.reaper = reaper;
+    public AsyncHttpClientConfigBean setUserAgent(String userAgent) {
+        this.userAgent = userAgent;
+        return this;
+    }
+
+    public AsyncHttpClientConfigBean setAllowPoolingConnections(boolean allowPoolingConnections) {
+        this.allowPoolingConnections = allowPoolingConnections;
         return this;
     }
 
@@ -163,17 +162,17 @@ public AsyncHttpClientConfigBean setApplicationThreadPool(ExecutorService applic
     }
 
     public AsyncHttpClientConfigBean setProxyServer(ProxyServer proxyServer) {
-        this.proxyServer = proxyServer;
+        this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
         return this;
     }
 
-    public AsyncHttpClientConfigBean setSslContext(SSLContext sslContext) {
-        this.sslContext = sslContext;
+    public AsyncHttpClientConfigBean setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
+        this.proxyServerSelector = proxyServerSelector;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
-        this.sslEngineFactory = sslEngineFactory;
+    public AsyncHttpClientConfigBean setSslContext(SSLContext sslContext) {
+        this.sslContext = sslContext;
         return this;
     }
 
@@ -182,11 +181,6 @@ public AsyncHttpClientConfigBean setProviderConfig(AsyncHttpProviderConfig<?, ?>
         return this;
     }
 
-    public AsyncHttpClientConfigBean setConnectionsPool(ConnectionsPool<?, ?> connectionsPool) {
-        this.connectionsPool = connectionsPool;
-        return this;
-    }
-
     public AsyncHttpClientConfigBean setRealm(Realm realm) {
         this.realm = realm;
         return this;
@@ -207,23 +201,18 @@ public AsyncHttpClientConfigBean addIoExceptionFilters(IOExceptionFilter ioExcep
         return this;
     }
 
-    public AsyncHttpClientConfigBean setRequestCompressionLevel(int requestCompressionLevel) {
-        this.requestCompressionLevel = requestCompressionLevel;
-        return this;
-    }
-
     public AsyncHttpClientConfigBean setMaxRequestRetry(int maxRequestRetry) {
         this.maxRequestRetry = maxRequestRetry;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setAllowSslConnectionPool(boolean allowSslConnectionPool) {
-        this.allowSslConnectionPool = allowSslConnectionPool;
+    public AsyncHttpClientConfigBean setAllowPoolingSslConnections(boolean allowPoolingSslConnections) {
+        this.allowPoolingSslConnections = allowPoolingSslConnections;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setUseRawUrl(boolean useRawUrl) {
-        this.useRawUrl = useRawUrl;
+    public AsyncHttpClientConfigBean setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
+        this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
         return this;
     }
 
@@ -241,4 +230,9 @@ public AsyncHttpClientConfigBean setIoThreadMultiplier(int ioThreadMultiplier) {
         this.ioThreadMultiplier = ioThreadMultiplier;
         return this;
     }
+
+    public AsyncHttpClientConfigBean setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+        this.acceptAnyCertificate = acceptAnyCertificate;
+        return this;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java
new file mode 100644
index 000000000..17b58c6c7
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+import org.asynchttpclient.util.AsyncPropertiesHelper;
+import org.asynchttpclient.util.DefaultHostnameVerifier;
+
+import javax.net.ssl.HostnameVerifier;
+
+public final class AsyncHttpClientConfigDefaults {
+
+    private AsyncHttpClientConfigDefaults() {
+    }
+
+    public static final String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
+
+    public static int defaultMaxConnections() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxConnections");
+    }
+
+    public static int defaultMaxConnectionsPerHost() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxConnectionsPerHost");
+    }
+
+    public static int defaultConnectionTimeout() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "connectionTimeout");
+    }
+
+    public static int defaultPooledConnectionIdleTimeout() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "pooledConnectionIdleTimeout");
+    }
+
+    public static int defaultReadTimeout() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "readTimeout");
+    }
+
+    public static int defaultRequestTimeout() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "requestTimeout");
+    }
+
+    public static int defaultWebSocketTimeout() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "webSocketTimeout");
+    }
+
+    public static int defaultConnectionTTL() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "connectionTTL");
+    }
+
+    public static boolean defaultFollowRedirect() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "followRedirect");
+    }
+
+    public static int defaultMaxRedirects() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxRedirects");
+    }
+
+    public static boolean defaultCompressionEnforced() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "compressionEnforced");
+    }
+
+    public static String defaultUserAgent() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT + "userAgent");
+    }
+
+    public static int defaultIoThreadMultiplier() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "ioThreadMultiplier");
+    }
+
+    public static boolean defaultUseProxySelector() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useProxySelector");
+    }
+
+    public static boolean defaultUseProxyProperties() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useProxyProperties");
+    }
+
+    public static boolean defaultStrict302Handling() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "strict302Handling");
+    }
+
+    public static boolean defaultAllowPoolingConnections() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "allowPoolingConnections");
+    }
+
+    public static boolean defaultUseRelativeURIsWithConnectProxies() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useRelativeURIsWithConnectProxies");
+    } 
+
+    public static int defaultMaxRequestRetry() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxRequestRetry");
+    }
+
+    public static boolean defaultAllowPoolingSslConnections() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "allowPoolingSslConnections");
+    }
+
+    public static boolean defaultDisableUrlEncodingForBoundRequests() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "disableUrlEncodingForBoundRequests");
+    }
+
+    public static boolean defaultRemoveQueryParamOnRedirect() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "removeQueryParamOnRedirect");
+    }
+
+    public static boolean defaultSpdyEnabled() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "spdyEnabled");
+    }
+
+    public static int defaultSpdyInitialWindowSize() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "spdyInitialWindowSize");
+    }
+
+    public static int defaultSpdyMaxConcurrentStreams() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "spdyMaxConcurrentStreams");
+    }
+    
+    public static boolean defaultAcceptAnyCertificate() {
+        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "acceptAnyCertificate");
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
index da96a0497..848249a6d 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
@@ -17,12 +17,9 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.util.List;
 
 /**
  * Interface to be used when implementing custom asynchronous I/O HTTP client.
- * By default, the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider} is used if
- * none of the other provider modules are found on the classpath.
  */
 public interface AsyncHttpProvider extends Closeable {
 
@@ -33,22 +30,10 @@
      * @return a {@link ListenableFuture} of Type T.
      * @throws IOException
      */
-    public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException;
+    <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException;
 
     /**
      * Close the current underlying TCP/HTTP connection.
      */
-    public void close();
-
-    /**
-     * Prepare a {@link Response}
-     *
-     * @param status    {@link HttpResponseStatus}
-     * @param headers   {@link HttpResponseHeaders}
-     * @param bodyParts list of {@link HttpResponseBodyPart}
-     * @return a {@link Response}
-     */
-    public Response prepareResponse(HttpResponseStatus status,
-                                    HttpResponseHeaders headers,
-                                    List<HttpResponseBodyPart> bodyParts);
+    void close();
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java b/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
index 48b9cd565..f511580c9 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
@@ -29,7 +29,7 @@
      * @param value the value of the property
      * @return this instance of AsyncHttpProviderConfig
      */
-    public AsyncHttpProviderConfig<U,V> addProperty(U name, V value);
+    AsyncHttpProviderConfig<U, V> addProperty(U name, V value);
 
     /**
      * Return the value associated with the property's name
@@ -37,7 +37,7 @@
      * @param name
      * @return this instance of AsyncHttpProviderConfig
      */
-    public V getProperty(U name);
+    V getProperty(U name);
 
     /**
      * Remove the value associated with the property's name
@@ -45,12 +45,12 @@
      * @param name
      * @return true if removed
      */
-    public V removeProperty(U name);
+    V removeProperty(U name);
 
     /**
      * Return the curent entry set.
      *
      * @return a the curent entry set.
      */
-    public Set<Map.Entry<U, V>> propertiesSet();
+    Set<Map.Entry<U, V>> propertiesSet();
 }
diff --git a/api/src/main/java/org/asynchttpclient/Body.java b/api/src/main/java/org/asynchttpclient/Body.java
index dacf0642d..422e365e2 100644
--- a/api/src/main/java/org/asynchttpclient/Body.java
+++ b/api/src/main/java/org/asynchttpclient/Body.java
@@ -36,13 +36,6 @@
      * @return The non-negative number of bytes actually read or {@code -1} if the body has been read completely.
      * @throws IOException If the chunk could not be read.
      */
+    // FIXME introduce a visitor pattern so that Netty can pass a pooled buffer
     long read(ByteBuffer buffer) throws IOException;
-
-    /**
-     * Releases any resources associated with this body.
-     *
-     * @throws IOException
-     */
-    void close() throws IOException;
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/BodyConsumer.java b/api/src/main/java/org/asynchttpclient/BodyConsumer.java
index ccebd5e8b..190c586ae 100644
--- a/api/src/main/java/org/asynchttpclient/BodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/BodyConsumer.java
@@ -25,16 +25,8 @@
     /**
      * Consume the received bytes.
      *
-     * @param byteBuffer a {@link ByteBuffer} represntation of the response's chunk.
+     * @param byteBuffer a {@link ByteBuffer} representation of the response's chunk.
      * @throws IOException
      */
     void consume(ByteBuffer byteBuffer) throws IOException;
-
-    /**
-     * Invoked when all the response bytes has been processed.
-     *
-     * @throws IOException
-     */
-    void close() throws IOException;
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java b/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
index 1bf49bbb0..4ab5b30be 100644
--- a/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
@@ -12,8 +12,6 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.Response.ResponseBuilder;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -74,14 +72,13 @@
  * </pre>
  */
 public class BodyDeferringAsyncHandler implements AsyncHandler<Response> {
-    private final Response.ResponseBuilder
-            responseBuilder = new Response.ResponseBuilder();
+    private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
 
     private final CountDownLatch headersArrived = new CountDownLatch(1);
 
     private final OutputStream output;
 
-    private volatile boolean responseSet;
+    private boolean responseSet;
 
     private volatile Response response;
 
@@ -117,21 +114,18 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    public STATE onStatusReceived(HttpResponseStatus responseStatus)
-            throws Exception {
+    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
         responseBuilder.reset();
         responseBuilder.accumulate(responseStatus);
         return STATE.CONTINUE;
     }
 
-    public STATE onHeadersReceived(HttpResponseHeaders headers)
-            throws Exception {
+    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
         responseBuilder.accumulate(headers);
         return STATE.CONTINUE;
     }
 
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart)
-            throws Exception {
+    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
         // body arrived, flush headers
         if (!responseSet) {
             response = responseBuilder.build();
@@ -152,6 +146,12 @@ protected void closeOut() throws IOException {
     }
 
     public Response onCompleted() throws IOException {
+
+        if (!responseSet) {
+            response = responseBuilder.build();
+            responseSet = true;
+        }
+
         // Counting down to handle error cases too.
         // In "normal" cases, latch is already at 0 here
         // But in other cases, for example when because of some error
@@ -226,8 +226,7 @@ public Response getResponse() throws InterruptedException, IOException {
 
         private final BodyDeferringAsyncHandler bdah;
 
-        public BodyDeferringInputStream(final Future<Response> future,
-                                        final BodyDeferringAsyncHandler bdah, final InputStream in) {
+        public BodyDeferringInputStream(final Future<Response> future, final BodyDeferringAsyncHandler bdah, final InputStream in) {
             super(in);
             this.future = future;
             this.bdah = bdah;
@@ -259,8 +258,7 @@ public void close() throws IOException {
          * @return a {@link Response}
          * @throws InterruptedException
          */
-        public Response getAsapResponse() throws InterruptedException,
-                IOException {
+        public Response getAsapResponse() throws InterruptedException, IOException {
             return bdah.getResponse();
         }
 
@@ -272,8 +270,7 @@ public Response getAsapResponse() throws InterruptedException,
          * @throws InterruptedException
          * @throws ExecutionException
          */
-        public Response getLastResponse() throws InterruptedException,
-                ExecutionException {
+        public Response getLastResponse() throws InterruptedException, ExecutionException {
             return future.get();
         }
     }
diff --git a/api/src/main/java/org/asynchttpclient/BodyGenerator.java b/api/src/main/java/org/asynchttpclient/BodyGenerator.java
index 804d28f96..9d9261876 100644
--- a/api/src/main/java/org/asynchttpclient/BodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/BodyGenerator.java
@@ -28,7 +28,5 @@
      * @return The request body, never {@code null}.
      * @throws IOException If the body could not be created.
      */
-    Body createBody()
-            throws IOException;
-
+    Body createBody() throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
new file mode 100644
index 000000000..638450a20
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
+
+    private final AsyncHttpClient client;
+
+    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
+        super(BoundRequestBuilder.class, method, isDisableUrlEncoding);
+        this.client = client;
+    }
+
+    public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
+        super(BoundRequestBuilder.class, prototype);
+        this.client = client;
+    }
+
+    public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) throws IOException {
+        return client.executeRequest(build(), handler);
+    }
+
+    public ListenableFuture<Response> execute() throws IOException {
+        return client.executeRequest(build(), new AsyncCompletionHandlerBase());
+    }
+
+    // Note: For now we keep the delegates in place even though they are not
+    // needed
+    // since otherwise Clojure (and maybe other languages) won't be able to
+    // access these methods - see Clojure tickets 126 and 259
+
+    @Override
+    public BoundRequestBuilder addBodyPart(Part part) {
+        return super.addBodyPart(part);
+    }
+
+    @Override
+    public BoundRequestBuilder addCookie(Cookie cookie) {
+        return super.addCookie(cookie);
+    }
+
+    @Override
+    public BoundRequestBuilder addHeader(String name, String value) {
+        return super.addHeader(name, value);
+    }
+
+    @Override
+    public BoundRequestBuilder addFormParam(String key, String value) {
+        return super.addFormParam(key, value);
+    }
+
+    @Override
+    public BoundRequestBuilder addQueryParam(String name, String value) {
+        return super.addQueryParam(name, value);
+    }
+
+    @Override
+    public Request build() {
+        return super.build();
+    }
+
+    @Override
+    public BoundRequestBuilder setBody(byte[] data) {
+        return super.setBody(data);
+    }
+
+    @Override
+    public BoundRequestBuilder setBody(InputStream stream) {
+        return super.setBody(stream);
+    }
+
+    @Override
+    public BoundRequestBuilder setBody(String data) {
+        return super.setBody(data);
+    }
+
+    @Override
+    public BoundRequestBuilder setHeader(String name, String value) {
+        return super.setHeader(name, value);
+    }
+
+    @Override
+    public BoundRequestBuilder setHeaders(FluentCaseInsensitiveStringsMap headers) {
+        return super.setHeaders(headers);
+    }
+
+    @Override
+    public BoundRequestBuilder setHeaders(Map<String, Collection<String>> headers) {
+        return super.setHeaders(headers);
+    }
+
+    @Override
+    public BoundRequestBuilder setFormParams(Map<String, List<String>> params) {
+        return super.setFormParams(params);
+    }
+
+    @Override
+    public BoundRequestBuilder setFormParams(List<Param> params) {
+        return super.setFormParams(params);
+    }
+
+    @Override
+    public BoundRequestBuilder setUrl(String url) {
+        return super.setUrl(url);
+    }
+
+    @Override
+    public BoundRequestBuilder setVirtualHost(String virtualHost) {
+        return super.setVirtualHost(virtualHost);
+    }
+
+    public BoundRequestBuilder setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        return super.setSignatureCalculator(signatureCalculator);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/ByteArrayPart.java b/api/src/main/java/org/asynchttpclient/ByteArrayPart.java
deleted file mode 100644
index 87311f0f1..000000000
--- a/api/src/main/java/org/asynchttpclient/ByteArrayPart.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-public class ByteArrayPart implements Part {
-    private String name;
-    private String fileName;
-    private byte[] data;
-    private String mimeType;
-    private String charSet;
-
-    public ByteArrayPart(String name, String fileName, byte[] data, String mimeType, String charSet) {
-        this.name = name;
-        this.fileName = fileName;
-        this.data = data;
-        this.mimeType = mimeType;
-        this.charSet = charSet;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public String getName() {
-        return name;
-    }
-
-    public String getFileName() {
-        return fileName;
-    }
-
-    public byte[] getData() {
-        return data;
-    }
-
-    public String getMimeType() {
-        return mimeType;
-    }
-
-    public String getCharSet() {
-        return charSet;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java b/api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java
similarity index 82%
rename from api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java
rename to api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java
index 49603dabe..3d546e192 100644
--- a/api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java
+++ b/api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java
@@ -15,9 +15,9 @@
  */
 package org.asynchttpclient;
 
-import java.net.URI;
+import org.asynchttpclient.uri.Uri;
 
-public interface ConnectionPoolKeyStrategy {
+public interface ConnectionPoolPartitioning {
 
-	String getKey(URI uri);
+    String getPartitionId(Uri uri, ProxyServer proxy);
 }
diff --git a/api/src/main/java/org/asynchttpclient/ConnectionsPool.java b/api/src/main/java/org/asynchttpclient/ConnectionsPool.java
deleted file mode 100644
index c76c855b7..000000000
--- a/api/src/main/java/org/asynchttpclient/ConnectionsPool.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-/**
- * An interface used by an {@link AsyncHttpProvider} for caching http connections.
- */
-public interface ConnectionsPool<U, V> {
-
-    /**
-     * Add a connection tpo the pool
-     *
-     * @param uri        a uri used to retrieve the cached connection
-     * @param connection an I/O connection
-     * @return true if added.
-     */
-    public boolean offer(U uri, V connection);
-
-    /**
-     * Remove the connection associated with the uri.
-     *
-     * @param uri the uri used when invoking addConnection
-     * @return the connection associated with the uri
-     */
-    public V poll(U uri);
-
-    /**
-     * Remove all connections from the cache. A connection might have been associated with several uri.
-     *
-     * @param connection a connection
-     * @return the true if the connection has been removed
-     */
-    public boolean removeAll(V connection);
-
-    /**
-     * Return true if a connection can be cached. A implementation can decide based on some rules to allow caching
-     * Calling this method is equivalent of checking the returned value of {@link ConnectionsPool#offer(Object, Object)}
-     *
-     * @return true if a connection can be cached.
-     */
-    public boolean canCacheConnection();
-
-    /**
-     * Destroy all connections that has been cached by this instance.
-     */
-    public void destroy();
-}
diff --git a/api/src/main/java/org/asynchttpclient/Cookie.java b/api/src/main/java/org/asynchttpclient/Cookie.java
deleted file mode 100644
index 8ba53605f..000000000
--- a/api/src/main/java/org/asynchttpclient/Cookie.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-import java.util.Collections;
-import java.util.Set;
-import java.util.TreeSet;
-
-public class Cookie implements Comparable<Cookie>{
-    private final String domain;
-    private final String name;
-    private final String value;
-    private final String rawValue;
-    private final String path;
-    private final int maxAge;
-    private final boolean secure;
-    private final int version;
-    private final boolean httpOnly;
-    private final boolean discard;
-    private final String comment;
-    private final String commentUrl;
-
-    private Set<Integer> ports = Collections.emptySet();
-    private Set<Integer> unmodifiablePorts = ports;
-
-    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure) {
-        this(domain, name, value, path, maxAge, secure, 1);
-    }
-
-    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure, int version) {
-        this(domain, name, value, value, path, maxAge, secure, version, false, false, null, null, Collections.<Integer> emptySet());
-    }
-
-    public Cookie(String domain, String name, String value, String rawValue, String path, int maxAge, boolean secure, int version, boolean httpOnly, boolean discard, String comment, String commentUrl, Iterable<Integer> ports) {
-
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-        name = name.trim();
-        if (name.length() == 0) {
-            throw new IllegalArgumentException("empty name");
-        }
-
-        for (int i = 0; i < name.length(); i++) {
-            char c = name.charAt(i);
-            if (c > 127) {
-                throw new IllegalArgumentException("name contains non-ascii character: " + name);
-            }
-
-            // Check prohibited characters.
-            switch (c) {
-            case '\t':
-            case '\n':
-            case 0x0b:
-            case '\f':
-            case '\r':
-            case ' ':
-            case ',':
-            case ';':
-            case '=':
-                throw new IllegalArgumentException("name contains one of the following prohibited characters: " + "=,; \\t\\r\\n\\v\\f: " + name);
-            }
-        }
-
-        if (name.charAt(0) == '$') {
-            throw new IllegalArgumentException("name starting with '$' not allowed: " + name);
-        }
-
-        if (value == null) {
-            throw new NullPointerException("value");
-        }
-
-        this.name = name;
-        this.value = value;
-        this.rawValue = rawValue;
-        this.domain = validateValue("domain", domain);
-        this.path = validateValue("path", path);
-        this.maxAge = maxAge;
-        this.secure = secure;
-        this.version = version;
-        this.httpOnly = httpOnly;
-
-        if (version > 0) {
-            this.comment = validateValue("comment", comment);
-        } else {
-            this.comment = null;
-        }
-        if (version > 1) {
-            this.discard = discard;
-            this.commentUrl = validateValue("commentUrl", commentUrl);
-            setPorts(ports);
-        } else {
-            this.discard = false;
-            this.commentUrl = null;
-        }
-    }
-
-    public String getDomain() {
-        return domain;
-    }
-
-    public String getName() {
-        return name == null ? "" : name;
-    }
-
-    public String getValue() {
-        return value == null ? "" : value;
-    }
-    
-    public String getRawValue() {
-        return rawValue;
-    }
-
-    public String getPath() {
-        return path;
-    }
-
-    public int getMaxAge() {
-        return maxAge;
-    }
-
-    public boolean isSecure() {
-        return secure;
-    }
-
-    public int getVersion() {
-        return version;
-    }
-
-    public String getComment() {
-        return this.comment;
-    }
-
-    public String getCommentUrl() {
-        return this.commentUrl;
-    }
-
-    public boolean isHttpOnly() {
-        return httpOnly;
-    }
-
-    public boolean isDiscard() {
-        return discard;
-    }
-
-    public Set<Integer> getPorts() {
-        if (unmodifiablePorts == null) {
-            unmodifiablePorts = Collections.unmodifiableSet(ports);
-        }
-        return unmodifiablePorts;
-    }
-
-    private void setPorts(Iterable<Integer> ports) {
-        Set<Integer> newPorts = new TreeSet<Integer>();
-        for (int p : ports) {
-            if (p <= 0 || p > 65535) {
-                throw new IllegalArgumentException("port out of range: " + p);
-            }
-            newPorts.add(Integer.valueOf(p));
-        }
-        if (newPorts.isEmpty()) {
-            unmodifiablePorts = this.ports = Collections.emptySet();
-        } else {
-            this.ports = newPorts;
-            unmodifiablePorts = null;
-        }
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder buf = new StringBuilder();
-        buf.append(getName());
-        buf.append('=');
-        buf.append(getValue());
-        if (getDomain() != null) {
-            buf.append("; domain=");
-            buf.append(getDomain());
-        }
-        if (getPath() != null) {
-            buf.append("; path=");
-            buf.append(getPath());
-        }
-        if (getComment() != null) {
-            buf.append("; comment=");
-            buf.append(getComment());
-        }
-        if (getMaxAge() >= 0) {
-            buf.append("; maxAge=");
-            buf.append(getMaxAge());
-            buf.append('s');
-        }
-        if (isSecure()) {
-            buf.append("; secure");
-        }
-        if (isHttpOnly()) {
-            buf.append("; HTTPOnly");
-        }
-        return buf.toString();
-    }
-
-    private String validateValue(String name, String value) {
-        if (value == null) {
-            return null;
-        }
-        value = value.trim();
-        if (value.length() == 0) {
-            return null;
-        }
-        for (int i = 0; i < value.length(); i++) {
-            char c = value.charAt(i);
-            switch (c) {
-            case '\r':
-            case '\n':
-            case '\f':
-            case 0x0b:
-            case ';':
-                throw new IllegalArgumentException(name + " contains one of the following prohibited characters: " + ";\\r\\n\\f\\v (" + value + ')');
-            }
-        }
-        return value;
-    }
-
-    public int compareTo(Cookie c) {
-        int v;
-        v = getName().compareToIgnoreCase(c.getName());
-        if (v != 0) {
-            return v;
-        }
-
-        if (getPath() == null) {
-            if (c.getPath() != null) {
-                return -1;
-            }
-        } else if (c.getPath() == null) {
-            return 1;
-        } else {
-            v = getPath().compareTo(c.getPath());
-            if (v != 0) {
-                return v;
-            }
-        }
-
-        if (getDomain() == null) {
-            if (c.getDomain() != null) {
-                return -1;
-            }
-        } else if (c.getDomain() == null) {
-            return 1;
-        } else {
-            v = getDomain().compareToIgnoreCase(c.getDomain());
-            return v;
-        }
-
-        return 0;
-    }
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
new file mode 100644
index 000000000..63536a37c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient;
+
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.resumable.ResumableAsyncHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class DefaultAsyncHttpClient implements AsyncHttpClient {
+
+    /**
+     * Providers that will be searched for, on the classpath, in order when no
+     * provider is explicitly specified by the developer.
+     */
+    private static final String[] DEFAULT_PROVIDERS = {//
+    "org.asynchttpclient.providers.netty.NettyAsyncHttpProvider",/**/
+    "org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider"//
+    };
+
+    private final AsyncHttpProvider httpProvider;
+    private final AsyncHttpClientConfig config;
+    private final static Logger logger = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+
+    /**
+     * Default signature calculator to use for all requests constructed by this client instance.
+     *
+     * @since 1.1
+     */
+    protected SignatureCalculator signatureCalculator;
+
+    /**
+     * Create a new HTTP Asynchronous Client using the default {@link AsyncHttpClientConfig} configuration. The
+     * default {@link AsyncHttpProvider} that will be used will be based on the classpath configuration.
+     *
+     * The default providers will be searched for in this order:
+     * <ul>
+     *     <li>netty</li>
+     *     <li>grizzly</li>
+     * </ul>
+     *
+     * If none of those providers are found, then the engine will throw an IllegalStateException.
+     */
+    public DefaultAsyncHttpClient() {
+        this(new AsyncHttpClientConfig.Builder().build());
+    }
+
+    /**
+     * Create a new HTTP Asynchronous Client using an implementation of {@link AsyncHttpProvider} and
+     * the default {@link AsyncHttpClientConfig} configuration.
+     *
+     * @param provider a {@link AsyncHttpProvider}
+     */
+    public DefaultAsyncHttpClient(AsyncHttpProvider provider) {
+        this(provider, new AsyncHttpClientConfig.Builder().build());
+    }
+
+    /**
+     * Create a new HTTP Asynchronous Client using the specified {@link AsyncHttpClientConfig} configuration.
+     * This configuration will be passed to the default {@link AsyncHttpProvider} that will be selected based on
+     * the classpath configuration.
+     *
+     * The default providers will be searched for in this order:
+     * <ul>
+     *     <li>netty</li>
+     *     <li>grizzly</li>
+     * </ul>
+     *
+     * If none of those providers are found, then the engine will throw an IllegalStateException.
+     *
+     * @param config a {@link AsyncHttpClientConfig}
+     */
+    public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
+        this(loadDefaultProvider(DEFAULT_PROVIDERS, config), config);
+    }
+
+    /**
+     * Create a new HTTP Asynchronous Client using a {@link AsyncHttpClientConfig} configuration and
+     * and a AsyncHttpProvider class' name.
+     *
+     * @param config        a {@link AsyncHttpClientConfig}
+     * @param providerClass a {@link AsyncHttpProvider}
+     */
+    public DefaultAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+        this(loadProvider(providerClass, config), config);
+    }
+
+    /**
+     * Create a new HTTP Asynchronous Client using a {@link AsyncHttpClientConfig} configuration and
+     * and a {@link AsyncHttpProvider}.
+     *
+     * @param config       a {@link AsyncHttpClientConfig}
+     * @param httpProvider a {@link AsyncHttpProvider}
+     */
+    public DefaultAsyncHttpClient(AsyncHttpProvider httpProvider, AsyncHttpClientConfig config) {
+        this.config = config;
+        this.httpProvider = httpProvider;
+    }
+
+    @Override
+    public AsyncHttpProvider getProvider() {
+        return httpProvider;
+    }
+
+    @Override
+    public void close() {
+        if (isClosed.compareAndSet(false, true))
+            httpProvider.close();
+    }
+
+    @Override
+    public void closeAsynchronously() {
+        final ExecutorService e = Executors.newSingleThreadExecutor();
+        e.submit(new Runnable() {
+            public void run() {
+                try {
+                    close();
+                } catch (Throwable t) {
+                    logger.warn("", t);
+                } finally {
+                    e.shutdown();
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            if (!isClosed.get()) {
+                logger.error("AsyncHttpClient.close() hasn't been invoked, which may produce file descriptor leaks");
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    @Override
+    public boolean isClosed() {
+        return isClosed.get();
+    }
+
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return config;
+    }
+
+    @Override
+    public DefaultAsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        this.signatureCalculator = signatureCalculator;
+        return this;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return requestBuilder("GET", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return requestBuilder("CONNECT", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return requestBuilder("OPTIONS", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return requestBuilder("HEAD", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return requestBuilder("POST", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return requestBuilder("PUT", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return requestBuilder("DELETE", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return requestBuilder("PATCH", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return requestBuilder("TRACE", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return requestBuilder(request);
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+
+        FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
+        fc = preProcessRequest(fc);
+
+        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
+        FilterContext<Response> fc = new FilterContext.FilterContextBuilder<Response>().asyncHandler(new AsyncCompletionHandlerBase())
+                .request(request).build();
+        fc = preProcessRequest(fc);
+        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
+    }
+
+    /**
+     * Configure and execute the associated {@link RequestFilter}. This class may decorate the {@link Request} and {@link AsyncHandler}
+     *
+     * @param fc {@link FilterContext}
+     * @return {@link FilterContext}
+     */
+    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws IOException {
+        for (RequestFilter asyncFilter : config.getRequestFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                if (fc == null) {
+                    throw new NullPointerException("FilterContext is null");
+                }
+            } catch (FilterException e) {
+                IOException ex = new IOException();
+                ex.initCause(e);
+                throw ex;
+            }
+        }
+
+        Request request = fc.getRequest();
+        if (fc.getAsyncHandler() instanceof ResumableAsyncHandler) {
+            request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
+        }
+
+        if (request.getRangeOffset() != 0) {
+            RequestBuilder builder = new RequestBuilder(request);
+            builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
+            request = builder.build();
+        }
+        fc = new FilterContext.FilterContextBuilder<T>(fc).request(request).build();
+        return fc;
+    }
+
+    @SuppressWarnings("unchecked")
+    private static AsyncHttpProvider loadProvider(final String className, final AsyncHttpClientConfig config) {
+        try {
+            Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>) Thread.currentThread().getContextClassLoader()
+                    .loadClass(className);
+            return providerClass.getDeclaredConstructor(new Class[] { AsyncHttpClientConfig.class }).newInstance(config);
+        } catch (Throwable t) {
+            if (t instanceof InvocationTargetException) {
+                final InvocationTargetException ite = (InvocationTargetException) t;
+                if (logger.isErrorEnabled()) {
+                    logger.error("Unable to instantiate provider {}.  Trying other providers.", className);
+                    logger.error(ite.getCause().toString(), ite.getCause());
+                }
+            }
+            // Let's try with another classloader
+            try {
+                Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>) DefaultAsyncHttpClient.class.getClassLoader().loadClass(
+                        className);
+                return providerClass.getDeclaredConstructor(new Class[] { AsyncHttpClientConfig.class }).newInstance(config);
+            } catch (Throwable ignored) {
+            }
+        }
+        return null;
+    }
+
+    private static AsyncHttpProvider loadDefaultProvider(String[] providerClassNames, AsyncHttpClientConfig config) {
+        AsyncHttpProvider provider;
+        for (final String className : providerClassNames) {
+            provider = loadProvider(className, config);
+            if (provider != null) {
+                return provider;
+            }
+        }
+        throw new IllegalStateException("No providers found on the classpath");
+    }
+
+    protected BoundRequestBuilder requestBuilder(String method, String url) {
+        return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
+    }
+
+    protected BoundRequestBuilder requestBuilder(Request prototype) {
+        return new BoundRequestBuilder(this, prototype).setSignatureCalculator(signatureCalculator);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/FilePart.java b/api/src/main/java/org/asynchttpclient/FilePart.java
deleted file mode 100644
index c5cc15860..000000000
--- a/api/src/main/java/org/asynchttpclient/FilePart.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-import java.io.File;
-
-/**
- * A file multipart part.
- */
-public class FilePart implements Part {
-    private String name;
-    private File file;
-    private String mimeType;
-    private String charSet;
-
-    public FilePart(String name, File file, String mimeType, String charSet) {
-        this.name = name;
-        this.file = file;
-        this.mimeType = mimeType;
-        this.charSet = charSet;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public String getName() {
-        return name;
-    }
-
-    public File getFile() {
-        return file;
-    }
-
-    public String getMimeType() {
-        return mimeType;
-    }
-
-    public String getCharSet() {
-        return charSet;
-    }
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
index 5f8c54232..10805d580 100644
--- a/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
@@ -16,7 +16,7 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -26,6 +26,7 @@
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
@@ -59,12 +60,31 @@ public FluentCaseInsensitiveStringsMap(Map<String, Collection<String>> src) {
         }
     }
 
+    public FluentCaseInsensitiveStringsMap add(String key, String value) {
+        if (key != null) {
+            String lcKey = key.toLowerCase(Locale.ENGLISH);
+            String realKey = keyLookup.get(lcKey);
+            
+            List<String> curValues = null;
+            if (realKey == null) {
+                keyLookup.put(lcKey, key);
+                curValues = new ArrayList<String>();
+                values.put(key, curValues);
+            } else {
+                curValues = values.get(realKey);
+            }
+
+            String nonNullValue = value != null? value : "";
+            curValues.add(nonNullValue);
+        }
+        return this;
+    }
+
     /**
      * Adds the specified values and returns this object.
      *
      * @param key    The key
-     * @param values The value(s); if null then this method has no effect. Use the empty string to
-     *               generate an empty value
+     * @param values The value(s); if the array is null then this method has no effect. Individual null values are turned into empty strings
      * @return This object
      */
     public FluentCaseInsensitiveStringsMap add(String key, String... values) {
@@ -105,7 +125,7 @@ public FluentCaseInsensitiveStringsMap add(String key, Collection<String> values
             List<String> nonNullValues = fetchValues(values);
 
             if (nonNullValues != null) {
-                String lcKey = key.toLowerCase();
+                String lcKey = key.toLowerCase(Locale.ENGLISH);
                 String realKey = keyLookup.get(lcKey);
                 List<String> curValues = null;
 
@@ -163,8 +183,8 @@ public FluentCaseInsensitiveStringsMap addAll(Map<String, Collection<String>> sr
      * @param values The new values
      * @return This object
      */
-    public FluentCaseInsensitiveStringsMap replace(final String key, final String... values) {
-        return replace(key, Arrays.asList(values));
+    public FluentCaseInsensitiveStringsMap replaceWith(final String key, final String... values) {
+        return replaceWith(key, Arrays.asList(values));
     }
 
     /**
@@ -174,10 +194,10 @@ public FluentCaseInsensitiveStringsMap replace(final String key, final String...
      * @param values The new values
      * @return This object
      */
-    public FluentCaseInsensitiveStringsMap replace(final String key, final Collection<String> values) {
+    public FluentCaseInsensitiveStringsMap replaceWith(final String key, final Collection<String> values) {
         if (key != null) {
             List<String> nonNullValues = fetchValues(values);
-            String lcKkey = key.toLowerCase();
+            String lcKkey = key.toLowerCase(Locale.ENGLISH);
             String realKey = keyLookup.get(lcKkey);
 
             if (nonNullValues == null) {
@@ -206,7 +226,7 @@ public FluentCaseInsensitiveStringsMap replace(final String key, final Collectio
     public FluentCaseInsensitiveStringsMap replaceAll(FluentCaseInsensitiveStringsMap src) {
         if (src != null) {
             for (Map.Entry<String, List<String>> header : src) {
-                replace(header.getKey(), header.getValue());
+                replaceWith(header.getKey(), header.getValue());
             }
         }
         return this;
@@ -222,7 +242,7 @@ public FluentCaseInsensitiveStringsMap replaceAll(FluentCaseInsensitiveStringsMa
     public FluentCaseInsensitiveStringsMap replaceAll(Map<? extends String, ? extends Collection<String>> src) {
         if (src != null) {
             for (Map.Entry<? extends String, ? extends Collection<String>> header : src.entrySet()) {
-                replace(header.getKey(), header.getValue());
+                replaceWith(header.getKey(), header.getValue());
             }
         }
         return this;
@@ -231,7 +251,7 @@ public FluentCaseInsensitiveStringsMap replaceAll(Map<? extends String, ? extend
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public List<String> put(String key, List<String> value) {
         if (key == null) {
             throw new NullPointerException("Null keys are not allowed");
@@ -239,14 +259,14 @@ public FluentCaseInsensitiveStringsMap replaceAll(Map<? extends String, ? extend
 
         List<String> oldValue = get(key);
 
-        replace(key, value);
+        replaceWith(key, value);
         return oldValue;
     }
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void putAll(Map<? extends String, ? extends List<String>> values) {
         replaceAll(values);
     }
@@ -259,7 +279,7 @@ public void putAll(Map<? extends String, ? extends List<String>> values) {
      */
     public FluentCaseInsensitiveStringsMap delete(String key) {
         if (key != null) {
-            String lcKey = key.toLowerCase();
+            String lcKey = key.toLowerCase(Locale.ENGLISH);
             String realKey = keyLookup.remove(lcKey);
 
             if (realKey != null) {
@@ -302,7 +322,7 @@ public FluentCaseInsensitiveStringsMap deleteAll(Collection<String> keys) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public List<String> remove(Object key) {
         if (key == null) {
             return null;
@@ -317,7 +337,7 @@ public FluentCaseInsensitiveStringsMap deleteAll(Collection<String> keys) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void clear() {
         keyLookup.clear();
         values.clear();
@@ -326,7 +346,7 @@ public void clear() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Iterator<Map.Entry<String, List<String>>> iterator() {
         return Collections.unmodifiableSet(values.entrySet()).iterator();
     }
@@ -334,7 +354,7 @@ public void clear() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Set<String> keySet() {
         return new LinkedHashSet<String>(keyLookup.values());
     }
@@ -342,7 +362,7 @@ public void clear() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Set<Entry<String, List<String>>> entrySet() {
         return values.entrySet();
     }
@@ -350,7 +370,7 @@ public void clear() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public int size() {
         return values.size();
     }
@@ -358,7 +378,7 @@ public int size() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public boolean isEmpty() {
         return values.isEmpty();
     }
@@ -366,15 +386,15 @@ public boolean isEmpty() {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public boolean containsKey(Object key) {
-        return key == null ? false : keyLookup.containsKey(key.toString().toLowerCase());
+        return key == null ? false : keyLookup.containsKey(key.toString().toLowerCase(Locale.ENGLISH));
     }
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public boolean containsValue(Object value) {
         return values.containsValue(value);
     }
@@ -427,13 +447,13 @@ public String getJoinedValue(String key, String delimiter) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public List<String> get(Object key) {
         if (key == null) {
             return null;
         }
 
-        String lcKey = key.toString().toLowerCase();
+        String lcKey = key.toString().toLowerCase(Locale.ENGLISH);
         String realKey = keyLookup.get(lcKey);
 
         if (realKey == null) {
@@ -446,7 +466,7 @@ public String getJoinedValue(String key, String delimiter) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Collection<List<String>> values() {
         return values.values();
     }
diff --git a/api/src/main/java/org/asynchttpclient/FluentStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
index 2001413e1..5dd3dd200 100644
--- a/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
@@ -16,7 +16,7 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -54,12 +54,24 @@ public FluentStringsMap(Map<String, Collection<String>> src) {
         }
     }
 
+    public FluentStringsMap add(String key, String value) {
+        if (key != null) {
+            List<String> curValues = values.get(key);
+
+            if (curValues == null) {
+                curValues = new ArrayList<String>(1);
+                values.put(key, curValues);
+            }
+            curValues.add(value);
+        }
+        return this;
+    }
+
     /**
      * Adds the specified values and returns this object.
      *
      * @param key    The key
-     * @param values The value(s); if null then this method has no effect. Use the empty string to
-     *               generate an empty value
+     * @param values The value(s); if the array is null then this method has no effect
      * @return This object
      */
     public FluentStringsMap add(String key, String... values) {
@@ -73,8 +85,7 @@ public FluentStringsMap add(String key, String... values) {
      * Adds the specified values and returns this object.
      *
      * @param key    The key
-     * @param values The value(s); if null then this method has no effect. Use an empty collection
-     *               to generate an empty value
+     * @param values The value(s); if the array is null then this method has no effect
      * @return This object
      */
     public FluentStringsMap add(String key, Collection<String> values) {
@@ -127,8 +138,8 @@ public FluentStringsMap addAll(Map<String, Collection<String>> src) {
      * @param values The new values
      * @return This object
      */
-    public FluentStringsMap replace(final String key, final String... values) {
-        return replace(key, Arrays.asList(values));
+    public FluentStringsMap replaceWith(final String key, final String... values) {
+        return replaceWith(key, Arrays.asList(values));
     }
 
     /**
@@ -138,7 +149,7 @@ public FluentStringsMap replace(final String key, final String... values) {
      * @param values The new values
      * @return This object
      */
-    public FluentStringsMap replace(final String key, final Collection<String> values) {
+    public FluentStringsMap replaceWith(final String key, final Collection<String> values) {
         if (key != null) {
             if (values == null) {
                 this.values.remove(key);
@@ -159,7 +170,7 @@ public FluentStringsMap replace(final String key, final Collection<String> value
     public FluentStringsMap replaceAll(FluentStringsMap src) {
         if (src != null) {
             for (Map.Entry<String, List<String>> header : src) {
-                replace(header.getKey(), header.getValue());
+                replaceWith(header.getKey(), header.getValue());
             }
         }
         return this;
@@ -175,7 +186,7 @@ public FluentStringsMap replaceAll(FluentStringsMap src) {
     public FluentStringsMap replaceAll(Map<? extends String, ? extends Collection<String>> src) {
         if (src != null) {
             for (Map.Entry<? extends String, ? extends Collection<String>> header : src.entrySet()) {
-                replace(header.getKey(), header.getValue());
+                replaceWith(header.getKey(), header.getValue());
             }
         }
         return this;
@@ -192,7 +203,7 @@ public FluentStringsMap replaceAll(Map<? extends String, ? extends Collection<St
 
         List<String> oldValue = get(key);
 
-        replace(key, value);
+        replaceWith(key, value);
         return oldValue;
     }
 
@@ -389,6 +400,20 @@ public String getJoinedValue(String key, String delimiter) {
         return values.values();
     }
 
+    public List<Param> toParams() {
+        if (values.isEmpty())
+            return Collections.emptyList();
+        else {
+            List<Param> params = new ArrayList<Param>(values.size());
+            for (Map.Entry<String, List<String>> entry : values.entrySet()) {
+                String name = entry.getKey();
+                for (String value: entry.getValue())
+                    params.add(new Param(name, value));
+            }
+            return params;
+        }
+    }
+    
     @Override
     public boolean equals(Object obj) {
         if (this == obj) {
diff --git a/api/src/main/java/org/asynchttpclient/HttpContent.java b/api/src/main/java/org/asynchttpclient/HttpContent.java
deleted file mode 100644
index 219e2411c..000000000
--- a/api/src/main/java/org/asynchttpclient/HttpContent.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient;
-
-import java.net.URI;
-
-/**
- * Base class for callback class used by {@link AsyncHandler}
- */
-public class HttpContent {
-    protected final AsyncHttpProvider provider;
-    protected final URI uri;
-
-    protected HttpContent(URI url, AsyncHttpProvider provider) {
-        this.provider = provider;
-        this.uri = url;
-    }
-
-    /**
-     * Return the current {@link AsyncHttpProvider}
-     *
-     * @return the current {@link AsyncHttpProvider}
-     */
-    public final AsyncHttpProvider provider() {
-        return provider;
-    }
-
-    /**
-     * Return the request {@link URI}
-     *
-     * @return the request {@link URI}
-     */
-    public final URI getUrl() {
-        return uri;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 2a8655e2d..b7ab7c7e9 100644
--- a/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -18,39 +18,34 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.URI;
 import java.nio.ByteBuffer;
 
 /**
  * A callback class used when an HTTP response body is received.
  */
-public abstract class HttpResponseBodyPart extends HttpContent {
-
-    public HttpResponseBodyPart(URI uri, AsyncHttpProvider provider) {
-        super(uri, provider);
-    }
+public abstract class HttpResponseBodyPart {
 
     /**
      * Return length of this part in bytes.
      * 
-     * @since 1.8.0
+     * @since 2.0.0
      */
-    abstract public int length();
-    
+    public abstract int length();
+
     /**
      * Return the response body's part bytes received.
      *
      * @return the response body's part bytes received.
      */
-    abstract public byte[] getBodyPartBytes();
+    public abstract byte[] getBodyPartBytes();
 
     /**
      * Method for accessing contents of this part via stream.
      * 
-     * @since 1.8.0
+     * @since 2.0.0
      */
-    abstract public InputStream readBodyPartBytes();
-    
+    public abstract InputStream readBodyPartBytes();
+
     /**
      * Write the available bytes to the {@link java.io.OutputStream}
      *
@@ -58,7 +53,7 @@ public HttpResponseBodyPart(URI uri, AsyncHttpProvider provider) {
      * @return The number of bytes written
      * @throws IOException
      */
-    abstract public int writeTo(OutputStream outputStream) throws IOException;
+    public abstract int writeTo(OutputStream outputStream) throws IOException;
 
     /**
      * Return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk. The {@link ByteBuffer}
@@ -66,27 +61,27 @@ public HttpResponseBodyPart(URI uri, AsyncHttpProvider provider) {
      *
      * @return {@link ByteBuffer}
      */
-    abstract public ByteBuffer getBodyByteBuffer();
+    public abstract ByteBuffer getBodyByteBuffer();
 
     /**
      * Return true if this is the last part.
      *
      * @return true if this is the last part.
      */
-    abstract public boolean isLast();
+    public abstract boolean isLast();
 
     /**
      * Close the underlying connection once the processing has completed. Invoking that method means the
      * underlying TCP connection will be closed as soon as the processing of the response is completed. That
      * means the underlying connection will never get pooled.
      */
-    abstract public void markUnderlyingConnectionAsClosed();
+    public abstract void markUnderlyingConnectionAsToBeClosed();
 
     /**
      * Return true of the underlying connection will be closed once the response has been fully processed.
      *
      * @return true of the underlying connection will be closed once the response has been fully processed.
      */
-    abstract public boolean closeUnderlyingConnection();
+    public abstract boolean isUnderlyingConnectionToBeClosed();
 
 }
diff --git a/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
index 54c894f71..b573fd876 100644
--- a/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
@@ -15,22 +15,18 @@
  */
 package org.asynchttpclient;
 
-import java.net.URI;
-
 /**
  * A class that represent the HTTP headers.
  */
-public abstract class HttpResponseHeaders extends HttpContent {
+public abstract class HttpResponseHeaders {
 
     private final boolean traillingHeaders;
 
-    public HttpResponseHeaders(URI uri, AsyncHttpProvider provider) {
-        super(uri, provider);
+    public HttpResponseHeaders() {
         this.traillingHeaders = false;
     }
 
-    public HttpResponseHeaders(URI uri, AsyncHttpProvider provider, boolean traillingHeaders) {
-        super(uri, provider);
+    public HttpResponseHeaders(boolean traillingHeaders) {
         this.traillingHeaders = traillingHeaders;
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index 3581e4658..c8388ab63 100644
--- a/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -16,56 +16,81 @@
  */
 package org.asynchttpclient;
 
-import java.net.URI;
+import java.util.List;
+
+import org.asynchttpclient.uri.Uri;
 
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
-public abstract class HttpResponseStatus extends HttpContent {
+public abstract class HttpResponseStatus {
+
+    private final Uri uri;
+    protected final AsyncHttpClientConfig config;
 
-    public HttpResponseStatus(URI uri, AsyncHttpProvider provider) {
-        super(uri, provider);
+    public HttpResponseStatus(Uri uri, AsyncHttpClientConfig config) {
+        this.uri = uri;
+        this.config = config;
     }
 
     /**
-     * Return the response status code
+     * Return the request {@link Uri}
+     * 
+     * @return the request {@link Uri}
+     */
+    public final Uri getUri() {
+        return uri;
+    }
+
+    /**
+     * Prepare a {@link Response}
      *
+     * @param headers   {@link HttpResponseHeaders}
+     * @param bodyParts list of {@link HttpResponseBodyPart}
+     * @param config the client config
+     * @return a {@link Response}
+     */
+    public abstract Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts);
+
+    /**
+     * Return the response status code
+     * 
      * @return the response status code
      */
-    abstract public int getStatusCode();
+    public abstract int getStatusCode();
 
     /**
      * Return the response status text
-     *
+     * 
      * @return the response status text
      */
-    abstract public String getStatusText();
+    public abstract String getStatusText();
 
     /**
      * Protocol name from status line.
-     *
+     * 
      * @return Protocol name.
      */
-    abstract public String getProtocolName();
+    public abstract String getProtocolName();
 
     /**
      * Protocol major version.
-     *
+     * 
      * @return Major version.
      */
-    abstract public int getProtocolMajorVersion();
+    public abstract int getProtocolMajorVersion();
 
     /**
      * Protocol minor version.
-     *
+     * 
      * @return Minor version.
      */
-    abstract public int getProtocolMinorVersion();
+    public abstract int getProtocolMinorVersion();
 
     /**
      * Full protocol name + version
-     *
+     * 
      * @return protocol name + version
      */
-    abstract public String getProtocolText();
+    public abstract String getProtocolText();
 }
diff --git a/api/src/main/java/org/asynchttpclient/ListenableFuture.java b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
index f40012e76..8d2ca73dc 100755
--- a/api/src/main/java/org/asynchttpclient/ListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -30,7 +30,6 @@
  */
 package org.asynchttpclient;
 
-import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 
@@ -42,11 +41,11 @@
 public interface ListenableFuture<V> extends Future<V> {
 
     /**
-     * Execute a {@link Callable}  and if there is no exception, mark this Future as done and release the internal lock.
+     * Terminate and if there is no exception, mark this Future as done and release the internal lock.
      *
      * @param callable
      */
-    void done(Callable<?> callable);
+    void done();
 
     /**
      * Abort the current processing, and propagate the {@link Throwable} to the {@link AsyncHandler} or {@link Future}
@@ -55,28 +54,11 @@
      */
     void abort(Throwable t);
 
-    /**
-     * Set the content that will be returned by this instance
-     *
-     * @param v the content that will be returned by this instance
-     */
-    void content(V v);
-
     /**
      * Touch the current instance to prevent external service to times out.
      */
     void touch();
 
-    /**
-     * Write the {@link Request} headers
-     */
-    boolean getAndSetWriteHeaders(boolean writeHeader);
-
-    /**
-     * Write the {@link Request} body
-     */
-    boolean getAndSetWriteBody(boolean writeBody);
-
     /**
      * <p>Adds a listener and executor to the ListenableFuture.
      * The listener will be {@linkplain java.util.concurrent.Executor#execute(Runnable) passed
diff --git a/api/src/main/java/org/asynchttpclient/Param.java b/api/src/main/java/org/asynchttpclient/Param.java
new file mode 100644
index 000000000..788f66c42
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/Param.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+/**
+ * A pair of (name, value) String
+ * @author slandelle
+ */
+public class Param {
+
+    private final String name;
+    private final String value;
+    public Param(String name, String value) {
+        this.name = name;
+        this.value = value;
+    }
+    public String getName() {
+        return name;
+    }
+    public String getValue() {
+        return value;
+    }
+
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((name == null) ? 0 : name.hashCode());
+        result = prime * result + ((value == null) ? 0 : value.hashCode());
+        return result;
+    }
+
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (!(obj instanceof Param))
+            return false;
+        Param other = (Param) obj;
+        if (name == null) {
+            if (other.name != null)
+                return false;
+        } else if (!name.equals(other.name))
+            return false;
+        if (value == null) {
+            if (other.value != null)
+                return false;
+        } else if (!value.equals(other.value))
+            return false;
+        return true;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/Part.java b/api/src/main/java/org/asynchttpclient/Part.java
deleted file mode 100644
index 521cad838..000000000
--- a/api/src/main/java/org/asynchttpclient/Part.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-/**
- * Interface for the parts in a multipart request.
- */
-public interface Part {
-    public String getName();
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java b/api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java
similarity index 65%
rename from api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java
rename to api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java
index b312155c4..0139a99fe 100644
--- a/api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java
+++ b/api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java
@@ -15,16 +15,16 @@
  */
 package org.asynchttpclient;
 
-import java.net.URI;
-
+import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
-public enum DefaultConnectionPoolStrategy implements ConnectionPoolKeyStrategy {
+public enum PerHostConnectionPoolPartitioning implements ConnectionPoolPartitioning {
+
+    INSTANCE;
 
-	INSTANCE;
-	
-	@Override
-	public String getKey(URI uri) {
-		return AsyncHttpProviderUtils.getBaseUrl(uri);
-	}
+    @Override
+    public String getPartitionId(Uri uri, ProxyServer proxyServer) {
+        String serverPart = AsyncHttpProviderUtils.getBaseUrl(uri);
+        return proxyServer != null ? proxyServer.getUrl() + serverPart : serverPart;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java b/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
index a562addc4..bde0d5dd5 100644
--- a/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
@@ -44,5 +44,4 @@
      * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     STATE onContentWriteProgress(long amount, long current, long total);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/ProxyServer.java b/api/src/main/java/org/asynchttpclient/ProxyServer.java
index d7d841c3f..3c6a5ff42 100644
--- a/api/src/main/java/org/asynchttpclient/ProxyServer.java
+++ b/api/src/main/java/org/asynchttpclient/ProxyServer.java
@@ -16,13 +16,13 @@
  */
 package org.asynchttpclient;
 
-import java.net.URI;
+import org.asynchttpclient.util.StandardCharsets;
+
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
 /**
  * Represents a proxy server.
  */
@@ -53,29 +53,18 @@ public String toString() {
     private final String principal;
     private final String password;
     private final int port;
-    private final URI uri;
-    private String encoding = "UTF-8";
+    private final String url;
+    private String encoding = StandardCharsets.UTF_8.name();
+    private Charset charset = StandardCharsets.UTF_8;
     private String ntlmDomain = System.getProperty("http.auth.ntlm.domain", "");
 
-    private boolean isBasic = true;
-
-    @Deprecated
-    public boolean isBasic() {
-		return isBasic;
-	}
-
-    @Deprecated
-	public void setBasic(boolean isBasic) {
-		this.isBasic = isBasic;
-	}
-
-	public ProxyServer(final Protocol protocol, final String host, final int port, String principal, String password) {
+    public ProxyServer(final Protocol protocol, final String host, final int port, String principal, String password) {
         this.protocol = protocol;
         this.host = host;
         this.port = port;
         this.principal = principal;
         this.password = password;
-        this.uri = AsyncHttpProviderUtils.createUri(toString());
+        url = protocol + "://" + host + ":" + port;
     }
 
     public ProxyServer(final String host, final int port, String principal, String password) {
@@ -116,6 +105,7 @@ public String getPassword() {
 
     public ProxyServer setEncoding(String encoding) {
         this.encoding = encoding;
+        this.charset = Charset.forName(encoding);
         return this;
     }
 
@@ -123,8 +113,12 @@ public String getEncoding() {
         return encoding;
     }
 
-    public URI getURI() {
-        return uri;
+    public Charset getCharset() {
+        return charset;
+    }
+
+    public String getUrl() {
+        return url;
     }
 
     public ProxyServer addNonProxyHost(String uri) {
@@ -152,7 +146,6 @@ public String getNtlmDomain() {
 
     @Override
     public String toString() {
-        return protocol + "://" + host + ":" + port;
+        return url;
     }
 }
-
diff --git a/api/src/main/java/org/asynchttpclient/ProxyServerSelector.java b/api/src/main/java/org/asynchttpclient/ProxyServerSelector.java
new file mode 100644
index 000000000..241f8086c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/ProxyServerSelector.java
@@ -0,0 +1,27 @@
+package org.asynchttpclient;
+
+import org.asynchttpclient.uri.Uri;
+
+/**
+ * Selector for a proxy server
+ */
+public interface ProxyServerSelector {
+
+    /**
+     * Select a proxy server to use for the given URI.
+     *
+     * @param uri The URI to select a proxy server for.
+     * @return The proxy server to use, if any.  May return null.
+     */
+    ProxyServer select(Uri uri);
+
+    /**
+     * A selector that always selects no proxy.
+     */
+    static final ProxyServerSelector NO_PROXY_SELECTOR = new ProxyServerSelector() {
+        @Override
+        public ProxyServer select(Uri uri) {
+            return null;
+        }
+    };
+}
diff --git a/api/src/main/java/org/asynchttpclient/RandomAccessBody.java b/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
index 95aa0fb1a..fa74e9e68 100644
--- a/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
+++ b/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
@@ -1,15 +1,15 @@
 /*
-* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
-*
-* This program is licensed to you under the Apache License Version 2.0,
-* and you may not use this file except in compliance with the Apache License Version 2.0.
-* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the Apache License Version 2.0 is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
-*/
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 
 package org.asynchttpclient;
 
@@ -19,19 +19,18 @@
 /**
  * A request body which supports random access to its contents.
  */
-public interface RandomAccessBody
-        extends Body {
+public interface RandomAccessBody extends Body {
 
     /**
      * Transfers the specified chunk of bytes from this body to the specified channel.
-     *
-     * @param position The zero-based byte index from which to start the transfer, must not be negative.
-     * @param count    The maximum number of bytes to transfer, must not be negative.
-     * @param target   The destination channel to transfer the body chunk to, must not be {@code null}.
+     * 
+     * @param position
+     *            The zero-based byte index from which to start the transfer, must not be negative.
+     * @param target
+     *            The destination channel to transfer the body chunk to, must not be {@code null}.
      * @return The non-negative number of bytes actually transferred.
-     * @throws IOException If the body chunk could not be transferred.
+     * @throws IOException
+     *             If the body chunk could not be transferred.
      */
-    long transferTo(long position, long count, WritableByteChannel target)
-            throws IOException;
-
+    long transferTo(long position, WritableByteChannel target) throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/Realm.java b/api/src/main/java/org/asynchttpclient/Realm.java
index de213f74c..7906277b5 100644
--- a/api/src/main/java/org/asynchttpclient/Realm.java
+++ b/api/src/main/java/org/asynchttpclient/Realm.java
@@ -16,9 +16,12 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import java.io.UnsupportedEncodingException;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StandardCharsets;
+
+import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
@@ -40,39 +43,25 @@
     private final String qop;
     private final String nc;
     private final String cnonce;
-    private final String uri;
+    private final Uri uri;
     private final String methodName;
     private final boolean usePreemptiveAuth;
     private final String enc;
     private final String host;
     private final boolean messageType2Received;
-
-    private final String domain;
+    private final String ntlmDomain;
+    private final Charset charset;
+    private final boolean useAbsoluteURI;
+    private final boolean omitQuery;
+    private final boolean targetProxy;
 
     public enum AuthScheme {
-        DIGEST,
-        BASIC,
-        NTLM,
-        SPNEGO,
-        KERBEROS,
-        NONE
+        DIGEST, BASIC, NTLM, SPNEGO, KERBEROS, NONE
     }
 
-    private Realm(AuthScheme scheme,
-                  String principal,
-                  String password,
-                  String realmName,
-                  String nonce,
-                  String algorithm,
-                  String response,
-                  String qop,
-                  String nc,
-                  String cnonce,
-                  String uri,
-                  String method,
-                  boolean usePreemptiveAuth,
-                  String domain, String enc, String host, boolean messageType2Received,
-                  String opaque) {
+    private Realm(AuthScheme scheme, String principal, String password, String realmName, String nonce, String algorithm, String response,
+            String qop, String nc, String cnonce, Uri uri, String method, boolean usePreemptiveAuth, String ntlmDomain, String enc,
+            String host, boolean messageType2Received, String opaque, boolean useAbsoluteURI, boolean omitQuery, boolean targetProxy) {
 
         this.principal = principal;
         this.password = password;
@@ -88,10 +77,14 @@ private Realm(AuthScheme scheme,
         this.uri = uri;
         this.methodName = method;
         this.usePreemptiveAuth = usePreemptiveAuth;
-        this.domain = domain;
+        this.ntlmDomain = ntlmDomain;
         this.enc = enc;
         this.host = host;
         this.messageType2Received = messageType2Received;
+        this.charset = enc != null ? Charset.forName(enc) : null;
+        this.useAbsoluteURI = useAbsoluteURI;
+        this.omitQuery = omitQuery;
+        this.targetProxy = targetProxy;
     }
 
     public String getPrincipal() {
@@ -143,7 +136,7 @@ public String getCnonce() {
         return cnonce;
     }
 
-    public String getUri() {
+    public Uri getUri() {
         return uri;
     }
 
@@ -151,13 +144,17 @@ public String getEncoding() {
         return enc;
     }
 
+    public Charset getCharset() {
+        return charset;
+    }
+
     public String getMethodName() {
         return methodName;
     }
 
     /**
      * Return true is preemptive authentication is enabled
-     *
+     * 
      * @return true is preemptive authentication is enabled
      */
     public boolean getUsePreemptiveAuth() {
@@ -166,26 +163,16 @@ public boolean getUsePreemptiveAuth() {
 
     /**
      * Return the NTLM domain to use. This value should map the JDK
-     *
-     * @return the NTLM domain
-     * @deprecated - use getNtlmDomain()
-     */
-    public String getDomain() {
-        return domain;
-    }
-
-    /**
-     * Return the NTLM domain to use. This value should map the JDK
-     *
+     * 
      * @return the NTLM domain
      */
     public String getNtlmDomain() {
-        return domain;
+        return ntlmDomain;
     }
 
     /**
      * Return the NTLM host.
-     *
+     * 
      * @return the NTLM host
      */
     public String getNtlmHost() {
@@ -196,44 +183,60 @@ public boolean isNtlmMessageType2Received() {
         return messageType2Received;
     }
 
+    public boolean isUseAbsoluteURI() {
+        return useAbsoluteURI;
+    }
+
+    public boolean isOmitQuery() {
+        return omitQuery;
+    }
+
+    public boolean isTargetProxy() {
+        return targetProxy;
+    }
+
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o)
+            return true;
+        if (o == null || getClass() != o.getClass())
+            return false;
 
         Realm realm = (Realm) o;
 
-        if (algorithm != null ? !algorithm.equals(realm.algorithm) : realm.algorithm != null) return false;
-        if (cnonce != null ? !cnonce.equals(realm.cnonce) : realm.cnonce != null) return false;
-        if (nc != null ? !nc.equals(realm.nc) : realm.nc != null) return false;
-        if (nonce != null ? !nonce.equals(realm.nonce) : realm.nonce != null) return false;
-        if (password != null ? !password.equals(realm.password) : realm.password != null) return false;
-        if (principal != null ? !principal.equals(realm.principal) : realm.principal != null) return false;
-        if (qop != null ? !qop.equals(realm.qop) : realm.qop != null) return false;
-        if (realmName != null ? !realmName.equals(realm.realmName) : realm.realmName != null) return false;
-        if (response != null ? !response.equals(realm.response) : realm.response != null) return false;
-        if (scheme != realm.scheme) return false;
-        if (uri != null ? !uri.equals(realm.uri) : realm.uri != null) return false;
-
+        if (algorithm != null ? !algorithm.equals(realm.algorithm) : realm.algorithm != null)
+            return false;
+        if (cnonce != null ? !cnonce.equals(realm.cnonce) : realm.cnonce != null)
+            return false;
+        if (nc != null ? !nc.equals(realm.nc) : realm.nc != null)
+            return false;
+        if (nonce != null ? !nonce.equals(realm.nonce) : realm.nonce != null)
+            return false;
+        if (password != null ? !password.equals(realm.password) : realm.password != null)
+            return false;
+        if (principal != null ? !principal.equals(realm.principal) : realm.principal != null)
+            return false;
+        if (qop != null ? !qop.equals(realm.qop) : realm.qop != null)
+            return false;
+        if (realmName != null ? !realmName.equals(realm.realmName) : realm.realmName != null)
+            return false;
+        if (response != null ? !response.equals(realm.response) : realm.response != null)
+            return false;
+        if (scheme != realm.scheme)
+            return false;
+        if (uri != null ? !uri.equals(realm.uri) : realm.uri != null)
+            return false;
+        if (useAbsoluteURI != !realm.useAbsoluteURI) return false;
+        if (omitQuery != !realm.omitQuery) return false;
         return true;
     }
 
     @Override
     public String toString() {
-        return "Realm{" +
-                "principal='" + principal + '\'' +
-                ", password='" + password + '\'' +
-                ", scheme=" + scheme +
-                ", realmName='" + realmName + '\'' +
-                ", nonce='" + nonce + '\'' +
-                ", algorithm='" + algorithm + '\'' +
-                ", response='" + response + '\'' +
-                ", qop='" + qop + '\'' +
-                ", nc='" + nc + '\'' +
-                ", cnonce='" + cnonce + '\'' +
-                ", uri='" + uri + '\'' +
-                ", methodName='" + methodName + '\'' +
-                '}';
+        return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\'' + ", nonce='"
+                + nonce + '\'' + ", algorithm='" + algorithm + '\'' + ", response='" + response + '\'' + ", qop='" + qop + '\'' + ", nc='"
+                + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\'' + ", methodName='" + methodName + '\'' + ", useAbsoluteURI='" + useAbsoluteURI + '\''
+                + ", omitQuery='" + omitQuery + '\'' +'}';
     }
 
     @Override
@@ -257,8 +260,8 @@ public int hashCode() {
      */
     public static class RealmBuilder {
         //
-        //  Portions of code (newCnonce, newResponse) are highly inspired be Jetty 6 BasicAuthentication.java class.
-        //  This code is already Apache licenced.
+        // Portions of code (newCnonce, newResponse) are highly inspired be Jetty 6 BasicAuthentication.java class.
+        // This code is already Apache licenced.
         //
 
         private String principal = "";
@@ -272,31 +275,23 @@ public int hashCode() {
         private String qop = "auth";
         private String nc = "00000001";
         private String cnonce = "";
-        private String uri = "";
+        private Uri uri;
         private String methodName = "GET";
-        private boolean usePreemptive = false;
-        private String domain = System.getProperty("http.auth.ntlm.domain", "");
-        private String enc = "UTF-8";
+        private boolean usePreemptive;
+        private String ntlmDomain = System.getProperty("http.auth.ntlm.domain", "");
+        private String enc = StandardCharsets.UTF_8.name();
         private String host = "localhost";
-        private boolean messageType2Received = false;
-
-        @Deprecated
-        public String getDomain() {
-            return domain;
-        }
-
-        @Deprecated
-        public RealmBuilder setDomain(String domain) {
-            this.domain = domain;
-            return this;
-        }
+        private boolean messageType2Received;
+        private boolean useAbsoluteURI = true;
+        private boolean omitQuery;
+        private boolean targetProxy;
 
         public String getNtlmDomain() {
-            return domain;
+            return ntlmDomain;
         }
 
-        public RealmBuilder setNtlmDomain(String domain) {
-            this.domain = domain;
+        public RealmBuilder setNtlmDomain(String ntlmDomain) {
+            this.ntlmDomain = ntlmDomain;
             return this;
         }
 
@@ -309,7 +304,6 @@ public RealmBuilder setNtlmHost(String host) {
             return this;
         }
 
-
         public String getPrincipal() {
             return principal;
         }
@@ -400,11 +394,11 @@ public RealmBuilder setNc(String nc) {
             return this;
         }
 
-        public String getUri() {
+        public Uri getUri() {
             return uri;
         }
 
-        public RealmBuilder setUri(String uri) {
+        public RealmBuilder setUri(Uri uri) {
             this.uri = uri;
             return this;
         }
@@ -427,10 +421,45 @@ public RealmBuilder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
             return this;
         }
 
+        public RealmBuilder setNtlmMessageType2Received(boolean messageType2Received) {
+            this.messageType2Received = messageType2Received;
+            return this;
+        }
+
+        public boolean isUseAbsoluteURI() {
+            return useAbsoluteURI;
+        }
+        
+        public RealmBuilder setUseAbsoluteURI(boolean useAbsoluteURI) {
+            this.useAbsoluteURI = useAbsoluteURI;
+            return this;
+        }
+        
+        public boolean isOmitQuery() {
+            return omitQuery;
+        }
+        
+        public RealmBuilder setOmitQuery(boolean omitQuery) {
+            this.omitQuery = omitQuery;
+            return this;
+        }
+
+        public boolean isTargetProxy() {
+            return targetProxy;
+        }
+        
+        public RealmBuilder setTargetProxy(boolean targetProxy) {
+            this.targetProxy = targetProxy;
+            return this;
+        }
+
         public RealmBuilder parseWWWAuthenticateHeader(String headerLine) {
             setRealmName(match(headerLine, "realm"));
             setNonce(match(headerLine, "nonce"));
-            setAlgorithm(match(headerLine, "algorithm"));
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
             setOpaque(match(headerLine, "opaque"));
             setQop(match(headerLine, "qop"));
             if (isNonEmpty(getNonce())) {
@@ -451,11 +480,7 @@ public RealmBuilder parseProxyAuthenticateHeader(String headerLine) {
             } else {
                 setScheme(AuthScheme.BASIC);
             }
-            return this;
-        }
-        
-        public RealmBuilder setNtlmMessageType2Received(boolean messageType2Received) {
-            this.messageType2Received = messageType2Received;
+            setTargetProxy(true);
             return this;
         }
 
@@ -467,7 +492,7 @@ public RealmBuilder clone(Realm clone) {
             setNonce(clone.getNonce());
             setPassword(clone.getPassword());
             setPrincipal(clone.getPrincipal());
-            setEnconding(clone.getEncoding());
+            setEncoding(clone.getEncoding());
             setOpaque(clone.getOpaque());
             setQop(clone.getQop());
             setScheme(clone.getScheme());
@@ -476,13 +501,16 @@ public RealmBuilder clone(Realm clone) {
             setNtlmDomain(clone.getNtlmDomain());
             setNtlmHost(clone.getNtlmHost());
             setNtlmMessageType2Received(clone.isNtlmMessageType2Received());
+            setUseAbsoluteURI(clone.isUseAbsoluteURI());
+            setOmitQuery(clone.isOmitQuery());
+            setTargetProxy(clone.isTargetProxy());
             return this;
         }
 
         private void newCnonce() {
             try {
                 MessageDigest md = MessageDigest.getInstance("MD5");
-                byte[] b = md.digest(String.valueOf(System.currentTimeMillis()).getBytes("ISO-8859-1"));
+                byte[] b = md.digest(String.valueOf(System.currentTimeMillis()).getBytes(StandardCharsets.ISO_8859_1));
                 cnonce = toHexString(b);
             } catch (Exception e) {
                 throw new SecurityException(e);
@@ -498,68 +526,62 @@ private String match(String headerLine, String token) {
             }
 
             int match = headerLine.indexOf(token);
-            if (match <= 0) return "";
+            if (match <= 0)
+                return "";
 
             // = to skip
             match += token.length() + 1;
-            int traillingComa = headerLine.indexOf(",", match);
-            String value = headerLine.substring(match, traillingComa > 0 ? traillingComa : headerLine.length());
-            value = value.endsWith("\"") ? value.substring(0, value.length() - 1) : value;
-            return value.startsWith("\"") ? value.substring(1) : value;
+            int trailingComa = headerLine.indexOf(",", match);
+            String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
+            value = value.length() > 0 && value.charAt(value.length() - 1) == '"' ? value.substring(0, value.length() - 1) : value;
+            return value.charAt(0) == '"' ? value.substring(1) : value;
         }
 
         public String getEncoding() {
             return enc;
         }
 
-        public RealmBuilder setEnconding(String enc) {
+        public RealmBuilder setEncoding(String enc) {
             this.enc = enc;
             return this;
         }
 
-        private void newResponse() throws UnsupportedEncodingException {
+        private void newResponse() {
             MessageDigest md = null;
             try {
                 md = MessageDigest.getInstance("MD5");
             } catch (NoSuchAlgorithmException e) {
                 throw new SecurityException(e);
             }
-            md.update(new StringBuilder(principal)
-                    .append(":")
-                    .append(realmName)
-                    .append(":")
-                    .append(password)
-                    .toString().getBytes("ISO-8859-1"));
+            md.update(new StringBuilder(principal).append(":")//
+                    .append(realmName).append(":")//
+                    .append(password).toString()//
+                    .getBytes(StandardCharsets.ISO_8859_1));
             byte[] ha1 = md.digest();
 
             md.reset();
 
-            //HA2 if qop is auth-int is methodName:url:md5(entityBody)
-            md.update(new StringBuilder(methodName)
-                    .append(':')
-                    .append(uri).toString().getBytes("ISO-8859-1"));
+            // HA2 if qop is auth-int is methodName:url:md5(entityBody)
+            md.update(new StringBuilder(methodName).append(':')//
+                    .append(uri).toString()//
+                    .getBytes(StandardCharsets.ISO_8859_1));
             byte[] ha2 = md.digest();
 
-            if(qop==null || qop.length() == 0) {
-                 md.update(new StringBuilder(toBase16(ha1))
-                    .append(':')
-                    .append(nonce)
-                    .append(':')
-                    .append(toBase16(ha2)).toString().getBytes("ISO-8859-1"));
-
-             } else {
-                 //qop ="auth" or "auth-int"
-                 md.update(new StringBuilder(toBase16(ha1))
-                    .append(':')
-                    .append(nonce)
-                    .append(':')
-                    .append(NC)
-                    .append(':')
-                    .append(cnonce)
-                    .append(':')
-                    .append(qop)
-                    .append(':')
-                    .append(toBase16(ha2)).toString().getBytes("ISO-8859-1"));
+            if (qop == null || qop.length() == 0) {
+                md.update(new StringBuilder(toBase16(ha1)).append(':')//
+                        .append(nonce).append(':')//
+                        .append(toBase16(ha2)).toString()//
+                        .getBytes(StandardCharsets.ISO_8859_1));
+
+            } else {
+                // qop ="auth" or "auth-int"
+                md.update(new StringBuilder(toBase16(ha1)).append(':')//
+                        .append(nonce).append(':')//
+                        .append(NC).append(':')//
+                        .append(cnonce).append(':')//
+                        .append(qop).append(':')//
+                        .append(toBase16(ha2)).toString()//
+                        .getBytes(StandardCharsets.ISO_8859_1));
             }
 
             byte[] digest = md.digest();
@@ -595,7 +617,7 @@ private static String toBase16(byte[] bytes) {
 
         /**
          * Build a {@link Realm}
-         *
+         * 
          * @return a {@link Realm}
          */
         public Realm build() {
@@ -603,32 +625,11 @@ public Realm build() {
             // Avoid generating
             if (isNonEmpty(nonce)) {
                 newCnonce();
-                try {
-                    newResponse();
-                } catch (UnsupportedEncodingException e) {
-                    throw new RuntimeException(e);
-                }
+                newResponse();
             }
 
-            return new Realm(scheme,
-                    principal,
-                    password,
-                    realmName,
-                    nonce,
-                    algorithm,
-                    response,
-                    qop,
-                    nc,
-                    cnonce,
-                    uri,
-                    methodName,
-                    usePreemptive,
-                    domain,
-                    enc,
-                    host,
-                    messageType2Received,
-                    opaque);
+            return new Realm(scheme, principal, password, realmName, nonce, algorithm, response, qop, nc, cnonce, uri, methodName,
+                    usePreemptive, ntlmDomain, enc, host, messageType2Received, opaque, useAbsoluteURI, omitQuery, targetProxy);
         }
     }
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/Request.java b/api/src/main/java/org/asynchttpclient/Request.java
index 056f93ee0..d33e9d78b 100644
--- a/api/src/main/java/org/asynchttpclient/Request.java
+++ b/api/src/main/java/org/asynchttpclient/Request.java
@@ -16,12 +16,13 @@
  */
 package org.asynchttpclient;
 
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.uri.Uri;
+
 import java.io.File;
-import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.InetAddress;
-import java.net.URI;
 import java.util.Collection;
 import java.util.List;
 
@@ -33,201 +34,155 @@
  *                      .setPassword(admin)
  *                      .setRealmName("MyRealm")
  *                      .setScheme(Realm.AuthScheme.DIGEST).build());
- *   r.execute();
  * </pre></blockquote>
  */
 public interface Request {
 
-    /**
-     * An entity that can be used to manipulate the Request's body output before it get sent.
-     */
-    public static interface EntityWriter {
-        public void writeEntity(OutputStream out) throws IOException;
-    }
-
     /**
      * Return the request's method name (GET, POST, etc.)
      *
      * @return the request's method name (GET, POST, etc.)
      */
-    public String getMethod();
+    String getMethod();
 
-    /**
-     * Return the decoded url
-     *
-     * @return the decoded url
-     */
-    public String getUrl();
+    Uri getUri();
 
-    public URI getOriginalURI();
-    public URI getURI();
-    public URI getRawURI();
+    String getUrl();
 
     /**
      * Return the InetAddress to override
      *
      * @return the InetAddress
      */
-    public InetAddress getInetAddress();
+    InetAddress getInetAddress();
 
-    public InetAddress getLocalAddress();
-
-    /**
-     * Return the undecoded url
-     *
-     * @return the undecoded url
-     */
-    public String getRawUrl();
+    InetAddress getLocalAddress();
 
     /**
      * Return the current set of Headers.
      *
      * @return a {@link FluentCaseInsensitiveStringsMap} contains headers.
      */
-    public FluentCaseInsensitiveStringsMap getHeaders();
+    FluentCaseInsensitiveStringsMap getHeaders();
 
     /**
      * Return Coookie.
      *
      * @return an unmodifiable Collection of Cookies
      */
-    public Collection<Cookie> getCookies();
+    Collection<Cookie> getCookies();
 
     /**
      * Return the current request's body as a byte array
      *
      * @return a byte array of the current request's body.
      */
-    public byte[] getByteData();
+    byte[] getByteData();
 
     /**
      * Return the current request's body as a string
      *
      * @return an String representation of the current request's body.
      */
-    public String getStringData();
+    String getStringData();
 
     /**
      * Return the current request's body as an InputStream
      *
      * @return an InputStream representation of the current request's body.
      */
-    public InputStream getStreamData();
-
-    /**
-     * Return the current request's body as an EntityWriter
-     *
-     * @return an EntityWriter representation of the current request's body.
-     */
-    public EntityWriter getEntityWriter();
+    InputStream getStreamData();
 
     /**
      * Return the current request's body generator.
      *
      * @return A generator for the request body.
      */
-    public BodyGenerator getBodyGenerator();
-
-    /**
-     * Return the current size of the content-lenght header based on the body's size.
-     *
-     * @return the current size of the content-lenght header based on the body's size.
-     * @deprecated
-     */
-    public long getLength();
+    BodyGenerator getBodyGenerator();
 
     /**
      * Return the current size of the content-lenght header based on the body's size.
      *
      * @return the current size of the content-lenght header based on the body's size.
      */
-    public long getContentLength();
+    long getContentLength();
 
     /**
-     * Return the current parameters.
+     * Return the current form parameters.
      *
      * @return a {@link FluentStringsMap} of parameters.
      */
-    public FluentStringsMap getParams();
+    List<Param> getFormParams();
 
     /**
      * Return the current {@link Part}
      *
      * @return the current {@link Part}
      */
-    public List<Part> getParts();
+    List<Part> getParts();
 
     /**
      * Return the virtual host value.
      *
      * @return the virtual host value.
      */
-    public String getVirtualHost();
+    String getVirtualHost();
 
     /**
      * Return the query params.
      *
      * @return {@link FluentStringsMap} of query string
      */
-    public FluentStringsMap getQueryParams();
+    List<Param> getQueryParams();
 
     /**
      * Return the {@link ProxyServer}
      *
      * @return the {@link ProxyServer}
      */
-    public ProxyServer getProxyServer();
+    ProxyServer getProxyServer();
 
     /**
      * Return the {@link Realm}
      *
      * @return the {@link Realm}
      */
-    public Realm getRealm();
+    Realm getRealm();
 
     /**
      * Return the {@link File} to upload.
      *
      * @return the {@link File} to upload.
      */
-    public File getFile();
+    File getFile();
 
     /**
-     * Return the <tt>true></tt> to follow redirect
+     * Return follow redirect
      *
-     * @return the <tt>true></tt> to follow redirect
+     * @return the <tt>TRUE></tt> to follow redirect, FALSE, if NOT to follow, whatever the client config.
+     * Return null if not set.
      */
-    public boolean isRedirectEnabled();
+    Boolean getFollowRedirect();
 
     /**
-     *
-     * @return <tt>true></tt> if request's redirectEnabled setting
-     *          should be used in place of client's
-     */
-    public boolean isRedirectOverrideSet();
-
-    /**
-     * Return the request time out in milliseconds.
-     *
-     * @return requestTimeoutInMs.
+     * Overrides the config default value
+     * @return the request timeout
      */
-    public int getRequestTimeoutInMs();
+    int getRequestTimeoutInMs();
 
     /**
      * Return the HTTP Range header value, or
      *
      * @return the range header value, or 0 is not set.
      */
-    public long getRangeOffset();
+    long getRangeOffset();
 
     /**
      * Return the encoding value used when encoding the request's body.
      *
      * @return the encoding value used when encoding the request's body.
      */
-    public String getBodyEncoding();
-
-    public boolean isUseRawUrl();
+    String getBodyEncoding();
 
-    ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy();
+    ConnectionPoolPartitioning getConnectionPoolPartitioning();
 }
diff --git a/api/src/main/java/org/asynchttpclient/RequestBuilder.java b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
index 4702419ac..b5d2e9144 100644
--- a/api/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -15,12 +15,15 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.Request.EntityWriter;
-
 import java.io.InputStream;
 import java.util.Collection;
+import java.util.List;
 import java.util.Map;
 
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.util.QueryComputer;
+
 /**
  * Builder for a {@link Request}.
  * Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds,
@@ -40,16 +43,24 @@ public RequestBuilder(String method, boolean useRawUrl) {
         super(RequestBuilder.class, method, useRawUrl);
     }
 
+    public RequestBuilder(String method, QueryComputer queryComputer) {
+        super(RequestBuilder.class, method, queryComputer);
+    }
+
     public RequestBuilder(Request prototype) {
         super(RequestBuilder.class, prototype);
     }
 
+    public RequestBuilder(Request prototype, QueryComputer queryComputer) {
+        super(RequestBuilder.class, prototype, queryComputer);
+    }
+    
     // Note: For now we keep the delegates in place even though they are not needed
     //       since otherwise Clojure (and maybe other languages) won't be able to
     //       access these methods - see Clojure tickets 126 and 259
 
     @Override
-    public RequestBuilder addBodyPart(Part part) throws IllegalArgumentException {
+    public RequestBuilder addBodyPart(Part part) {
         return super.addBodyPart(part);
     }
 
@@ -64,58 +75,47 @@ public RequestBuilder addHeader(String name, String value) {
     }
 
     @Override
-    public RequestBuilder addParameter(String key, String value) throws IllegalArgumentException {
-        return super.addParameter(key, value);
+    public RequestBuilder addFormParam(String key, String value) {
+        return super.addFormParam(key, value);
     }
 
     @Override
-    public RequestBuilder addQueryParameter(String name, String value) {
-        return super.addQueryParameter(name, value);
+    public RequestBuilder addQueryParam(String name, String value) {
+        return super.addQueryParam(name, value);
     }
 
     @Override
-    public RequestBuilder setQueryParameters(FluentStringsMap parameters) {
-        return super.setQueryParameters(parameters);
+    public RequestBuilder addQueryParams(List<Param> queryParams) {
+        return super.addQueryParams(queryParams);
     }
 
     @Override
-    public Request build() {
-        return super.build();
+    public RequestBuilder setQueryParams(List<Param> params) {
+        return super.setQueryParams(params);
     }
 
     @Override
-    public RequestBuilder setBody(byte[] data) throws IllegalArgumentException {
-        return super.setBody(data);
+    public RequestBuilder setQueryParams(Map<String, List<String>> params) {
+        return super.setQueryParams(params);
     }
 
     @Override
-    public RequestBuilder setBody(EntityWriter dataWriter, long length) throws IllegalArgumentException {
-        return super.setBody(dataWriter, length);
+    public Request build() {
+        return super.build();
     }
 
     @Override
-    public RequestBuilder setBody(EntityWriter dataWriter) {
-        return super.setBody(dataWriter);
+    public RequestBuilder setBody(byte[] data) {
+        return super.setBody(data);
     }
 
-    /**
-     * Deprecated - Use setBody(new InputStreamBodyGenerator(inputStream)).
-     *
-     * @param stream - An {@link InputStream}
-     * @return a {@link RequestBuilder}
-     * @throws IllegalArgumentException
-     * @see #setBody(BodyGenerator) InputStreamBodyGenerator(inputStream)
-     * @see org.asynchttpclient.generators.InputStreamBodyGenerator
-     * @deprecated {@link #setBody(BodyGenerator)} setBody(new InputStreamBodyGenerator(inputStream))
-     */
     @Override
-    @Deprecated
-    public RequestBuilder setBody(InputStream stream) throws IllegalArgumentException {
+    public RequestBuilder setBody(InputStream stream) {
         return super.setBody(stream);
     }
 
     @Override
-    public RequestBuilder setBody(String data) throws IllegalArgumentException {
+    public RequestBuilder setBody(String data) {
         return super.setBody(data);
     }
 
@@ -135,13 +135,13 @@ public RequestBuilder setHeaders(Map<String, Collection<String>> headers) {
     }
 
     @Override
-    public RequestBuilder setParameters(Map<String, Collection<String>> parameters) throws IllegalArgumentException {
-        return super.setParameters(parameters);
+    public RequestBuilder setFormParams(List<Param> params) {
+        return super.setFormParams(params);
     }
 
     @Override
-    public RequestBuilder setParameters(FluentStringsMap parameters) throws IllegalArgumentException {
-        return super.setParameters(parameters);
+    public RequestBuilder setFormParams(Map<String, List<String>> params) {
+        return super.setFormParams(params);
     }
 
     @Override
@@ -165,8 +165,8 @@ public RequestBuilder setVirtualHost(String virtualHost) {
     }
 
     @Override
-    public RequestBuilder setFollowRedirects(boolean followRedirects) {
-        return super.setFollowRedirects(followRedirects);
+    public RequestBuilder setFollowRedirect(boolean followRedirect) {
+        return super.setFollowRedirect(followRedirect);
     }
 
     @Override
diff --git a/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index f22ff4491..db70efff4 100644
--- a/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -15,27 +15,24 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.Request.EntityWriter;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.UTF8UrlEncoder;
+import org.asynchttpclient.util.QueryComputer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.net.InetAddress;
-import java.net.URI;
-import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 /**
  * Builder for {@link Request}
@@ -45,45 +42,40 @@
 public abstract class RequestBuilderBase<T extends RequestBuilderBase<T>> {
     private final static Logger logger = LoggerFactory.getLogger(RequestBuilderBase.class);
 
-    private static final URI DEFAULT_REQUEST_URL = URI.create("http://localhost");
+    private static final Uri DEFAULT_REQUEST_URL = Uri.create("http://localhost");
 
     private static final class RequestImpl implements Request {
         private String method;
-        private URI originalUri;
-        private URI uri;
-        private URI rawUri;
+        private Uri uri;
         private InetAddress address;
         private InetAddress localAddress;
         private FluentCaseInsensitiveStringsMap headers = new FluentCaseInsensitiveStringsMap();
-        private Collection<Cookie> cookies = new ArrayList<Cookie>();
+        private ArrayList<Cookie> cookies;
         private byte[] byteData;
         private String stringData;
         private InputStream streamData;
-        private EntityWriter entityWriter;
         private BodyGenerator bodyGenerator;
-        private FluentStringsMap params;
+        private List<Param> formParams;
         private List<Part> parts;
         private String virtualHost;
         private long length = -1;
-        public FluentStringsMap queryParams;
         public ProxyServer proxyServer;
         private Realm realm;
         private File file;
-        private Boolean followRedirects;
+        private Boolean followRedirect;
         private int requestTimeoutInMs;
         private long rangeOffset;
         public String charset;
-        private boolean useRawUrl;
-        private ConnectionPoolKeyStrategy connectionPoolKeyStrategy = DefaultConnectionPoolStrategy.INSTANCE;
+        private ConnectionPoolPartitioning connectionPoolPartitioning = PerHostConnectionPoolPartitioning.INSTANCE;
+        private List<Param> queryParams;
 
-        public RequestImpl(boolean useRawUrl) {
-            this.useRawUrl = useRawUrl;
+        public RequestImpl() {
         }
 
         public RequestImpl(Request prototype) {
             if (prototype != null) {
                 this.method = prototype.getMethod();
-                this.originalUri = prototype.getOriginalURI();
+                this.uri = prototype.getUri();
                 this.address = prototype.getInetAddress();
                 this.localAddress = prototype.getLocalAddress();
                 this.headers = new FluentCaseInsensitiveStringsMap(prototype.getHeaders());
@@ -91,238 +83,163 @@ public RequestImpl(Request prototype) {
                 this.byteData = prototype.getByteData();
                 this.stringData = prototype.getStringData();
                 this.streamData = prototype.getStreamData();
-                this.entityWriter = prototype.getEntityWriter();
                 this.bodyGenerator = prototype.getBodyGenerator();
-                this.params = (prototype.getParams() == null ? null : new FluentStringsMap(prototype.getParams()));
-                this.queryParams = (prototype.getQueryParams() == null ? null : new FluentStringsMap(prototype.getQueryParams()));
-                this.parts = (prototype.getParts() == null ? null : new ArrayList<Part>(prototype.getParts()));
+                this.formParams = prototype.getFormParams() == null ? null : new ArrayList<Param>(prototype.getFormParams());
+                this.parts = prototype.getParts() == null ? null : new ArrayList<Part>(prototype.getParts());
                 this.virtualHost = prototype.getVirtualHost();
                 this.length = prototype.getContentLength();
                 this.proxyServer = prototype.getProxyServer();
                 this.realm = prototype.getRealm();
                 this.file = prototype.getFile();
-                this.followRedirects = prototype.isRedirectOverrideSet()? prototype.isRedirectEnabled() : null;
+                this.followRedirect = prototype.getFollowRedirect();
                 this.requestTimeoutInMs = prototype.getRequestTimeoutInMs();
                 this.rangeOffset = prototype.getRangeOffset();
                 this.charset = prototype.getBodyEncoding();
-                this.useRawUrl = prototype.isUseRawUrl();
-                this.connectionPoolKeyStrategy = prototype.getConnectionPoolKeyStrategy();
+                this.connectionPoolPartitioning = prototype.getConnectionPoolPartitioning();
             }
         }
 
-        /* @Override */
+        @Override
+        public String getUrl() {
+            return uri.toUrl();
+        }
 
+        @Override
         public String getMethod() {
             return method;
         }
 
+        @Override
         public InetAddress getInetAddress() {
             return address;
         }
 
+        @Override
         public InetAddress getLocalAddress() {
             return localAddress;
         }
 
-        private String removeTrailingSlash(URI uri) {
-            String uriString = uri.toString();
-            if (uriString.endsWith("/")) {
-                return uriString.substring(0, uriString.length() - 1);
-            } else {
-                return uriString;
-            }
-        }
-
-        /* @Override */
-        public String getUrl() {
-            return removeTrailingSlash(getURI());
-        }
-
-        /* @Override */
-        public String getRawUrl() {
-            return removeTrailingSlash(getRawURI());
-        }
-
-        public URI getOriginalURI() {
-            return originalUri;
-        }
-
-        public URI getURI() {
-            if (uri == null)
-                uri = toURI(true);
+        @Override
+        public Uri getUri() {
             return uri;
         }
 
-        public URI getRawURI() {
-            if (rawUri == null)
-                rawUri = toURI(false);
-            return rawUri;
-        }
-
-        private URI toURI(boolean encode) {
-
-            if (originalUri == null) {
-                logger.debug("setUrl hasn't been invoked. Using http://localhost");
-                originalUri = DEFAULT_REQUEST_URL;
-            }
-
-            AsyncHttpProviderUtils.validateSupportedScheme(originalUri);
-
-            StringBuilder builder = new StringBuilder();
-            builder.append(originalUri.getScheme()).append("://").append(originalUri.getAuthority());
-            if (isNonEmpty(originalUri.getRawPath())) {
-                builder.append(originalUri.getRawPath());
-            } else {
-                builder.append("/");
-            }
-
-            if (isNonEmpty(queryParams)) {
-
-                builder.append("?");
-
-                for (Iterator<Entry<String, List<String>>> i = queryParams.iterator(); i.hasNext();) {
-                    Map.Entry<String, List<String>> param = i.next();
-                    String name = param.getKey();
-                    for (Iterator<String> j = param.getValue().iterator(); j.hasNext();) {
-                        String value = j.next();
-                        if (encode) {
-                            UTF8UrlEncoder.appendEncoded(builder, name);
-                        } else {
-                            builder.append(name);
-                        }
-                        if (value != null) {
-                            builder.append('=');
-                            if (encode) {
-                                UTF8UrlEncoder.appendEncoded(builder, value);
-                            } else {
-                                builder.append(value);
-                            }
-                        }
-                        if (j.hasNext()) {
-                            builder.append('&');
-                        }
-                    }
-                    if (i.hasNext()) {
-                        builder.append('&');
-                    }
-                }
-            }
-
-            return URI.create(builder.toString());
-        }
-
-        /* @Override */
+        @Override
         public FluentCaseInsensitiveStringsMap getHeaders() {
             return headers;
         }
 
-        /* @Override */
+        @Override
         public Collection<Cookie> getCookies() {
-            return Collections.unmodifiableCollection(cookies);
+            return cookies != null ? Collections.unmodifiableCollection(cookies) : Collections.<Cookie> emptyList();
         }
 
-        /* @Override */
+        @Override
         public byte[] getByteData() {
             return byteData;
         }
 
-        /* @Override */
+        @Override
         public String getStringData() {
             return stringData;
         }
 
-        /* @Override */
+        @Override
         public InputStream getStreamData() {
             return streamData;
         }
 
-        /* @Override */
-        public EntityWriter getEntityWriter() {
-            return entityWriter;
-        }
-
-        /* @Override */
+        @Override
         public BodyGenerator getBodyGenerator() {
             return bodyGenerator;
         }
 
-        /* @Override */
-
-        /**
-         * @return
-         * @deprecated
-         */
-        public long getLength() {
-            return length;
-        }
-
+        @Override
         public long getContentLength() {
             return length;
         }
 
-        /* @Override */
-        public FluentStringsMap getParams() {
-            return params;
+        @Override
+        public List<Param> getFormParams() {
+            return formParams != null ? formParams : Collections.<Param> emptyList();
         }
 
-        /* @Override */
+        @Override
         public List<Part> getParts() {
-            return parts;
+            return parts != null ? parts : Collections.<Part> emptyList();
         }
 
-        /* @Override */
+        @Override
         public String getVirtualHost() {
             return virtualHost;
         }
 
-        public FluentStringsMap getQueryParams() {
-            return queryParams;
-        }
-
+        @Override
         public ProxyServer getProxyServer() {
             return proxyServer;
         }
 
+        @Override
         public Realm getRealm() {
             return realm;
         }
 
+        @Override
         public File getFile() {
             return file;
         }
 
-        public boolean isRedirectEnabled() {
-            return (followRedirects != null && followRedirects);
-        }
-
-        public boolean isRedirectOverrideSet(){
-            return followRedirects != null;
+        @Override
+        public Boolean getFollowRedirect() {
+            return followRedirect;
         }
 
+        @Override
         public int getRequestTimeoutInMs() {
             return requestTimeoutInMs;
         }
 
+        @Override
         public long getRangeOffset() {
             return rangeOffset;
         }
 
+        @Override
         public String getBodyEncoding() {
             return charset;
         }
 
-        public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
-            return connectionPoolKeyStrategy;
+        @Override
+        public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
+            return connectionPoolPartitioning;
+        }
+
+        @Override
+        public List<Param> getQueryParams() {
+            if (queryParams == null)
+                // lazy load
+                if (isNonEmpty(uri.getQuery())) {
+                    queryParams = new ArrayList<Param>(1);
+                    for (String queryStringParam : uri.getQuery().split("&")) {
+                        int pos = queryStringParam.indexOf('=');
+                        if (pos <= 0)
+                            queryParams.add(new Param(queryStringParam, null));
+                        else
+                            queryParams.add(new Param(queryStringParam.substring(0, pos), queryStringParam.substring(pos + 1)));
+                    }
+                } else
+                    queryParams = Collections.emptyList();
+            return queryParams;
         }
 
         @Override
         public String toString() {
-            StringBuilder sb = new StringBuilder(getURI().toString());
+            StringBuilder sb = new StringBuilder(getUrl());
 
             sb.append("\t");
             sb.append(method);
             sb.append("\theaders:");
-            if (headers != null) {
+            if (isNonEmpty(headers)) {
                 for (String name : headers.keySet()) {
                     sb.append("\t");
                     sb.append(name);
@@ -330,113 +247,73 @@ public String toString() {
                     sb.append(headers.getJoinedValue(name, ", "));
                 }
             }
-            sb.append("\tparams:");
-            if (params != null) {
-                for (String name : params.keySet()) {
+            if (isNonEmpty(formParams)) {
+                sb.append("\tformParams:");
+                for (Param param : formParams) {
                     sb.append("\t");
-                    sb.append(name);
+                    sb.append(param.getName());
                     sb.append(":");
-                    sb.append(params.getJoinedValue(name, ", "));
+                    sb.append(param.getValue());
                 }
             }
 
             return sb.toString();
         }
-
-        public boolean isUseRawUrl() {
-            return useRawUrl;
-        }
     }
 
     private final Class<T> derived;
     protected final RequestImpl request;
-    protected boolean useRawUrl = false;
+    protected QueryComputer queryComputer;
+    protected List<Param> queryParams;
+    protected SignatureCalculator signatureCalculator;
+
+    protected RequestBuilderBase(Class<T> derived, String method, boolean disableUrlEncoding) {
+        this(derived, method, QueryComputer.queryComputer(disableUrlEncoding));
+    }
 
-    protected RequestBuilderBase(Class<T> derived, String method, boolean rawUrls) {
+    protected RequestBuilderBase(Class<T> derived, String method, QueryComputer queryComputer) {
         this.derived = derived;
-        request = new RequestImpl(rawUrls);
+        request = new RequestImpl();
         request.method = method;
-        this.useRawUrl = rawUrls;
+        this.queryComputer = queryComputer;
     }
 
     protected RequestBuilderBase(Class<T> derived, Request prototype) {
+        this(derived, prototype, QueryComputer.URL_ENCODING_ENABLED_QUERY_COMPUTER);
+    }
+
+    protected RequestBuilderBase(Class<T> derived, Request prototype, QueryComputer queryComputer) {
         this.derived = derived;
         request = new RequestImpl(prototype);
-        this.useRawUrl = prototype.isUseRawUrl();
+        this.queryComputer = queryComputer;
     }
-
+    
     public T setUrl(String url) {
-        request.originalUri = buildURI(url);
-        request.uri = null;
-        request.rawUri = null;
+        return setUri(Uri.create(url));
+    }
+
+    public T setUri(Uri uri) {
+        request.uri = uri;
         return derived.cast(this);
     }
 
     public T setInetAddress(InetAddress address) {
-    	request.address = address;
-    	return derived.cast(this);
+        request.address = address;
+        return derived.cast(this);
     }
-    
+
     public T setLocalInetAddress(InetAddress address) {
         request.localAddress = address;
         return derived.cast(this);
     }
 
-    private URI buildURI(String url) {
-        URI uri = URI.create(url);
-
-        if (uri.getRawPath() == null) {
-            // AHC-96
-            // Let's try to derive it
-            StringBuilder buildedUrl = new StringBuilder();
-
-            if (uri.getScheme() != null) {
-                buildedUrl.append(uri.getScheme());
-                buildedUrl.append("://");
-            }
-
-            if (uri.getAuthority() != null) {
-                buildedUrl.append(uri.getAuthority());
-            }
-            if (url.indexOf("://") == -1) {
-                String s = buildedUrl.toString();
-                url = s + url.substring(uri.getScheme().length() + 1);
-                return buildURI(url);
-            } else {
-                throw new IllegalArgumentException("Invalid url "  + uri.toString());
-            }
-        }
-
-        if (isNonEmpty(uri.getRawQuery())) {
-            String[] queries = uri.getRawQuery().split("&");
-            int pos;
-            for (String query : queries) {
-                pos = query.indexOf('=');
-                if (pos <= 0) {
-                    addQueryParameter(query, null);
-                } else {
-                    try {
-                        if (useRawUrl) {
-                            addQueryParameter(query.substring(0, pos), query.substring(pos + 1));
-                        } else {
-                            addQueryParameter(URLDecoder.decode(query.substring(0, pos), "UTF-8"), URLDecoder.decode(query.substring(pos + 1), "UTF-8"));
-                        }
-                    } catch (UnsupportedEncodingException e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            }
-        }
-        return uri;
-    }
-
     public T setVirtualHost(String virtualHost) {
         request.virtualHost = virtualHost;
         return derived.cast(this);
     }
 
     public T setHeader(String name, String value) {
-        request.headers.replace(name, value);
+        request.headers.replaceWith(name, value);
         return derived.cast(this);
     }
 
@@ -465,133 +342,165 @@ public T setContentLength(int length) {
         return derived.cast(this);
     }
 
+    private void lazyInitCookies() {
+        if (request.cookies == null)
+            request.cookies = new ArrayList<Cookie>(3);
+    }
+
+    public T setCookies(Collection<Cookie> cookies) {
+        request.cookies = new ArrayList<Cookie>(cookies);
+        return derived.cast(this);
+    }
+
     public T addCookie(Cookie cookie) {
+        lazyInitCookies();
         request.cookies.add(cookie);
         return derived.cast(this);
     }
 
-    private void resetParameters() {
-        request.params = null;
+    public T addOrReplaceCookie(Cookie cookie) {
+        String cookieKey = cookie.getName();
+        boolean replace = false;
+        int index = 0;
+        lazyInitCookies();
+        for (Cookie c : request.cookies) {
+            if (c.getName().equals(cookieKey)) {
+                replace = true;
+                break;
+            }
+
+            index++;
+        }
+        if (replace)
+            request.cookies.set(index, cookie);
+        else
+            request.cookies.add(cookie);
+        return derived.cast(this);
+    }
+    
+    public void resetCookies() {
+        if (request.cookies != null)
+            request.cookies.clear();
+    }
+    
+    public void resetQuery() {
+        queryParams = null;
+        request.uri = request.uri.withNewQuery(null);
+    }
+    
+    public void resetFormParams() {
+        request.formParams = null;
     }
 
-    private void resetNonMultipartData() {
+    public void resetNonMultipartData() {
         request.byteData = null;
         request.stringData = null;
         request.streamData = null;
-        request.entityWriter = null;
         request.length = -1;
     }
 
-    private void resetMultipartData() {
+    public void resetMultipartData() {
         request.parts = null;
     }
 
-    private void checkIfBodyAllowed() {
-        if ("HEAD".equals(request.method)) {
-            throw new IllegalArgumentException("Can NOT set Body on HTTP Request Method HEAD.");
-        }
-    }
-
     public T setBody(File file) {
-        checkIfBodyAllowed();
         request.file = file;
         return derived.cast(this);
     }
 
-    public T setBody(byte[] data) throws IllegalArgumentException {
-        checkIfBodyAllowed();
-        resetParameters();
+    public T setBody(byte[] data) {
+        resetFormParams();
         resetNonMultipartData();
         resetMultipartData();
         request.byteData = data;
         return derived.cast(this);
     }
 
-    public T setBody(String data) throws IllegalArgumentException {
-        checkIfBodyAllowed();
-        resetParameters();
+    public T setBody(String data) {
+        resetFormParams();
         resetNonMultipartData();
         resetMultipartData();
         request.stringData = data;
         return derived.cast(this);
     }
 
-    public T setBody(InputStream stream) throws IllegalArgumentException {
-        checkIfBodyAllowed();
-        resetParameters();
+    public T setBody(InputStream stream) {
+        resetFormParams();
         resetNonMultipartData();
         resetMultipartData();
         request.streamData = stream;
         return derived.cast(this);
     }
 
-    public T setBody(EntityWriter dataWriter) {
-        return setBody(dataWriter, -1);
-    }
-
-    public T setBody(EntityWriter dataWriter, long length) throws IllegalArgumentException {
-        checkIfBodyAllowed();
-        resetParameters();
-        resetNonMultipartData();
-        resetMultipartData();
-        request.entityWriter = dataWriter;
-        request.length = length;
-        return derived.cast(this);
-    }
-
     public T setBody(BodyGenerator bodyGenerator) {
-        checkIfBodyAllowed();
         request.bodyGenerator = bodyGenerator;
         return derived.cast(this);
     }
 
-    public T addQueryParameter(String name, String value) {
-        if (request.queryParams == null) {
-            request.queryParams = new FluentStringsMap();
-        }
-        request.queryParams.add(name, value);
+    public T addQueryParam(String name, String value) {
+        if (queryParams == null)
+            queryParams = new ArrayList<Param>(1);
+        queryParams.add(new Param(name, value));
         return derived.cast(this);
     }
 
-    public T setQueryParameters(FluentStringsMap parameters) {
-        if (parameters == null) {
-            request.queryParams = null;
-        } else {
-            request.queryParams = new FluentStringsMap(parameters);
-        }
+    public T addQueryParams(List<Param> params) {
+        if (queryParams == null)
+            queryParams = params;
+        else
+            queryParams.addAll(params);
         return derived.cast(this);
     }
 
-    public T addParameter(String key, String value) throws IllegalArgumentException {
-        resetNonMultipartData();
-        resetMultipartData();
-        if (request.params == null) {
-            request.params = new FluentStringsMap();
+    private List<Param> map2ParamList(Map<String, List<String>> map) {
+        if (map == null)
+            return null;
+
+        List<Param> params = new ArrayList<Param>(map.size());
+        for (Map.Entry<String, List<String>> entries : map.entrySet()) {
+            String name = entries.getKey();
+            for (String value : entries.getValue())
+                params.add(new Param(name, value));
         }
-        request.params.add(key, value);
-        return derived.cast(this);
+        return params;
+    }
+    
+    public T setQueryParams(Map<String, List<String>> map) {
+        return setQueryParams(map2ParamList(map));
     }
 
-    public T setParameters(FluentStringsMap parameters) throws IllegalArgumentException {
+    public T setQueryParams(List<Param> params) {
+        // reset existing query
+        if (isNonEmpty(request.uri.getQuery()))
+            request.uri = request.uri.withNewQuery(null);
+        queryParams = params;
+        return derived.cast(this);
+    }
+    
+    public T addFormParam(String name, String value) {
         resetNonMultipartData();
         resetMultipartData();
-        request.params = new FluentStringsMap(parameters);
+        if (request.formParams == null)
+            request.formParams = new ArrayList<Param>(1);
+        request.formParams.add(new Param(name, value));
         return derived.cast(this);
     }
 
-    public T setParameters(Map<String, Collection<String>> parameters) throws IllegalArgumentException {
+    public T setFormParams(Map<String, List<String>> map) {
+        return setFormParams(map2ParamList(map));
+    }
+    public T setFormParams(List<Param> params) {
         resetNonMultipartData();
         resetMultipartData();
-        request.params = new FluentStringsMap(parameters);
+        request.formParams = params;
         return derived.cast(this);
     }
 
-    public T addBodyPart(Part part) throws IllegalArgumentException {
-        resetParameters();
+    public T addBodyPart(Part part) {
+        resetFormParams();
         resetNonMultipartData();
-        if (request.parts == null) {
+        if (request.parts == null)
             request.parts = new ArrayList<Part>();
-        }
         request.parts.add(part);
         return derived.cast(this);
     }
@@ -606,8 +515,8 @@ public T setRealm(Realm realm) {
         return derived.cast(this);
     }
 
-    public T setFollowRedirects(boolean followRedirects) {
-        request.followRedirects = followRedirects;
+    public T setFollowRedirect(boolean followRedirect) {
+        request.followRedirect = followRedirect;
         return derived.cast(this);
     }
 
@@ -631,15 +540,47 @@ public T setBodyEncoding(String charset) {
         return derived.cast(this);
     }
 
-    public T setConnectionPoolKeyStrategy(ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
-        request.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
+    public T setConnectionPoolPartitioning(ConnectionPoolPartitioning connectionPoolPartitioning) {
+        request.connectionPoolPartitioning = connectionPoolPartitioning;
         return derived.cast(this);
     }
 
-    public Request build() {
-        if ((request.length < 0) && (request.streamData == null) && allowBody(request.getMethod())) {
+    public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        this.signatureCalculator = signatureCalculator;
+        return derived.cast(this);
+    }
+
+    private void executeSignatureCalculator() {
+        /* Let's first calculate and inject signature, before finalizing actual build
+         * (order does not matter with current implementation but may in future)
+         */
+        if (signatureCalculator != null) {
+            signatureCalculator.calculateAndAddSignature(request, this);
+        }
+    }
+    
+    private void computeRequestCharset() {
+        if (request.charset == null) {
+            try {
+                final String contentType = request.headers.getFirstValue("Content-Type");
+                if (contentType != null) {
+                    final String charset = AsyncHttpProviderUtils.parseCharset(contentType);
+                    if (charset != null) {
+                        // ensure that if charset is provided with the Content-Type header,
+                        // we propagate that down to the charset of the Request object
+                        request.charset = charset;
+                    }
+                }
+            } catch (Throwable e) {
+                // NoOp -- we can't fix the Content-Type or charset from here
+            }
+        }
+    }
+    
+    private void computeRequestLength() {
+        if (request.length < 0 && request.streamData == null) {
             // can't concatenate content-length
-            String contentLength = request.headers.getFirstValue("Content-Length");
+            final String contentLength = request.headers.getFirstValue("Content-Length");
 
             if (contentLength != null) {
                 try {
@@ -649,30 +590,28 @@ public Request build() {
                 }
             }
         }
-        return request;
     }
 
-    private boolean allowBody(String method) {
-        return !(method.equalsIgnoreCase("GET") || method.equalsIgnoreCase("OPTIONS") || method.equalsIgnoreCase("TRACE") || method.equalsIgnoreCase("HEAD"));
-    }
+    private void computeFinalUri() {
 
-    public T addOrReplaceCookie(Cookie cookie) {
-        String cookieKey = cookie.getName();
-        boolean replace = false;
-        int index = 0;
-        for (Cookie c : request.cookies) {
-            if (c.getName().equals(cookieKey)) {
-                replace = true;
-                break;
-            }
-
-            index++;
+        if (request.uri == null) {
+            logger.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
+            request.uri = DEFAULT_REQUEST_URL;
         }
-        if (replace) {
-            ((ArrayList<Cookie>) request.cookies).set(index, cookie);
-        } else {
-            request.cookies.add(cookie);
-        }
-        return derived.cast(this);
+
+        AsyncHttpProviderUtils.validateSupportedScheme(request.uri);
+
+        String newQuery = queryComputer.computeFullQueryString(request.uri.getQuery(), queryParams);
+
+        request.uri = request.uri.withNewQuery(newQuery);
+    }
+
+    public Request build() {
+        computeFinalUri();
+        executeSignatureCalculator();
+        computeRequestCharset();
+        computeRequestLength();
+        return request;
     }
 }
+
diff --git a/api/src/main/java/org/asynchttpclient/Response.java b/api/src/main/java/org/asynchttpclient/Response.java
index 3db376606..e018fb9e0 100644
--- a/api/src/main/java/org/asynchttpclient/Response.java
+++ b/api/src/main/java/org/asynchttpclient/Response.java
@@ -16,13 +16,13 @@
  */
 package org.asynchttpclient;
 
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
+
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URI;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -31,50 +31,50 @@
 public interface Response {
     /**
      * Returns the status code for the request.
-     *
+     * 
      * @return The status code
      */
     int getStatusCode();
 
     /**
      * Returns the status text for the request.
-     *
+     * 
      * @return The status text
      */
     String getStatusText();
 
     /**
      * Return the entire response body as a byte[].
-     *
+     * 
      * @return the entire response body as a byte[].
      * @throws IOException
      */
     byte[] getResponseBodyAsBytes() throws IOException;
-    
+
     /**
      * Return the entire response body as a ByteBuffer.
-     *
+     * 
      * @return the entire response body as a ByteBuffer.
      * @throws IOException
      */
     ByteBuffer getResponseBodyAsByteBuffer() throws IOException;
 
     /**
-     * Returns an input stream for the response body. Note that you should not try to get this more than once,
-     * and that you should not close the stream.
-     *
+     * Returns an input stream for the response body. Note that you should not try to get this more than once, and that you should not close the stream.
+     * 
      * @return The input stream
      * @throws java.io.IOException
      */
     InputStream getResponseBodyAsStream() throws IOException;
 
     /**
-     * Returns the first maxLength bytes of the response body as a string. Note that this does not check
-     * whether the content type is actually a textual one, but it will use the charset if present in the content
-     * type header.
-     *
-     * @param maxLength The maximum number of bytes to read
-     * @param charset   the charset to use when decoding the stream
+     * Returns the first maxLength bytes of the response body as a string. Note that this does not check whether the content type is actually a textual one, but it will use the
+     * charset if present in the content type header.
+     * 
+     * @param maxLength
+     *            The maximum number of bytes to read
+     * @param charset
+     *            the charset to use when decoding the stream
      * @return The response body
      * @throws java.io.IOException
      */
@@ -82,19 +82,20 @@
 
     /**
      * Return the entire response body as a String.
-     *
-     * @param charset the charset to use when decoding the stream
+     * 
+     * @param charset
+     *            the charset to use when decoding the stream
      * @return the entire response body as a String.
      * @throws IOException
      */
     String getResponseBody(String charset) throws IOException;
 
     /**
-     * Returns the first maxLength bytes of the response body as a string. Note that this does not check
-     * whether the content type is actually a textual one, but it will use the charset if present in the content
-     * type header.
-     *
-     * @param maxLength The maximum number of bytes to read
+     * Returns the first maxLength bytes of the response body as a string. Note that this does not check whether the content type is actually a textual one, but it will use the
+     * charset if present in the content type header.
+     * 
+     * @param maxLength
+     *            The maximum number of bytes to read
      * @return The response body
      * @throws java.io.IOException
      */
@@ -102,38 +103,36 @@
 
     /**
      * Return the entire response body as a String.
-     *
+     * 
      * @return the entire response body as a String.
      * @throws IOException
      */
     String getResponseBody() throws IOException;
 
     /**
-     * Return the request {@link URI}. Note that if the request got redirected, the value of the {@link URI} will be
-     * the last valid redirect url.
-     *
-     * @return the request {@link URI}.
-     * @throws MalformedURLException
+     * Return the request {@link Uri}. Note that if the request got redirected, the value of the {@link Uri} will be the last valid redirect url.
+     * 
+     * @return the request {@link Uri}.
      */
-    URI getUri() throws MalformedURLException;
+    Uri getUri();
 
     /**
      * Return the content-type header value.
-     *
+     * 
      * @return the content-type header value.
      */
     String getContentType();
 
     /**
      * Return the response header
-     *
+     * 
      * @return the response header
      */
     String getHeader(String name);
 
     /**
      * Return a {@link List} of the response header value.
-     *
+     * 
      * @return the response header
      */
     List<String> getHeaders(String name);
@@ -142,14 +141,14 @@
 
     /**
      * Return true if the response redirects to another object.
-     *
+     * 
      * @return True if the response redirects to another object.
      */
     boolean isRedirected();
 
     /**
      * Subclasses SHOULD implement toString() in a way that identifies the request for logging.
-     *
+     * 
      * @return The textual representation
      */
     String toString();
@@ -161,69 +160,69 @@
 
     /**
      * Return true if the response's status has been computed by an {@link AsyncHandler}
-     *
+     * 
      * @return true if the response's status has been computed by an {@link AsyncHandler}
      */
     boolean hasResponseStatus();
 
     /**
-     * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the
-     * either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
-     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
-     *
+     * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
+     * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
+     * 
      * @return true if the response's headers has been computed by an {@link AsyncHandler}
      */
     boolean hasResponseHeaders();
 
     /**
-     * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the
-     * either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
+     * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
      * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
-     *
+     * 
      * @return true if the response's body has been computed by an {@link AsyncHandler}
      */
     boolean hasResponseBody();
 
     public static class ResponseBuilder {
-        private final List<HttpResponseBodyPart> bodies =
-                Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
+        private final List<HttpResponseBodyPart> bodyParts = new ArrayList<HttpResponseBodyPart>();
         private HttpResponseStatus status;
         private HttpResponseHeaders headers;
 
+        public ResponseBuilder accumulate(HttpResponseStatus status) {
+            this.status = status;
+            return this;
+        }
+
+        public ResponseBuilder accumulate(HttpResponseHeaders headers) {
+            this.headers = headers;
+            return this;
+        }
+
         /**
-         * Accumulate {@link HttpContent} in order to build a {@link Response}
-         *
-         * @param httpContent {@link HttpContent}
+         * @param bodyPart
+         *            a body part (possibly empty, but will be filtered out)
          * @return this
          */
-        public ResponseBuilder accumulate(HttpContent httpContent) {
-            if (httpContent instanceof HttpResponseStatus) {
-                status = (HttpResponseStatus) httpContent;
-            } else if (httpContent instanceof HttpResponseHeaders) {
-                headers = (HttpResponseHeaders) httpContent;
-            } else if (httpContent instanceof HttpResponseBodyPart) {
-                bodies.add((HttpResponseBodyPart) httpContent);
-            }
+        public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
+            if (bodyPart.length() > 0)
+                bodyParts.add(bodyPart);
             return this;
         }
 
         /**
          * Build a {@link Response} instance
-         *
+         * 
          * @return a {@link Response} instance
          */
         public Response build() {
-            return status == null ? null : status.provider().prepareResponse(status, headers, bodies);
+            return status == null ? null : status.prepareResponse(headers, bodyParts);
         }
 
         /**
          * Reset the internal state of this builder.
          */
         public void reset() {
-            bodies.clear();
+            bodyParts.clear();
             status = null;
             headers = null;
         }
     }
-
-}
\ No newline at end of file
+}
diff --git a/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
index 4fa002590..42e71536c 100644
--- a/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
@@ -33,6 +33,4 @@
      * @throws IOException
      */
     long getTransferredBytes() throws IOException;
-
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java b/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
index 394ab9bfe..a7152bbb4 100644
--- a/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
+++ b/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
@@ -1,21 +1,20 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient;
 
 import javax.net.ssl.SSLEngine;
+
 import java.security.GeneralSecurityException;
 
 /**
diff --git a/api/src/main/java/org/asynchttpclient/SignatureCalculator.java b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
index baa96ba3c..90339d8c5 100644
--- a/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
@@ -35,6 +35,6 @@
      * @param request        Request that is being built; needed to access content to
      *                       be signed
      */
-    public void calculateAndAddSignature(String url, Request request,
-                                         RequestBuilderBase<?> requestBuilder);
+    void calculateAndAddSignature(Request request,
+                                  RequestBuilderBase<?> requestBuilder);
 }
diff --git a/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
index ccbb0f2aa..dd502a9c7 100644
--- a/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
@@ -12,22 +12,25 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.resumable.ResumableAsyncHandler;
-import org.asynchttpclient.resumable.ResumableIOExceptionFilter;
-import org.asynchttpclient.simple.HeaderMap;
-import org.asynchttpclient.simple.SimpleAHCTransferListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.SSLContext;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collection;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
-import java.util.concurrent.ScheduledExecutorService;
+
+import javax.net.ssl.SSLContext;
+
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.resumable.ResumableIOExceptionFilter;
+import org.asynchttpclient.simple.HeaderMap;
+import org.asynchttpclient.simple.SimpleAHCTransferListener;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * Simple implementation of {@link AsyncHttpClient} and it's related builders ({@link AsyncHttpClientConfig},
@@ -38,9 +41,9 @@
  * {@link AsyncHandler} are required. As simple as:
  * <blockquote><pre>
  * SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
- * .setIdleConnectionInPoolTimeoutInMs(100)
+ * .setIdleConnectionInPoolTimeout(100)
  * .setMaximumConnectionsTotal(50)
- * .setRequestTimeoutInMs(5 * 60 * 1000)
+ * .setRequestTimeout(5 * 60 * 1000)
  * .setUrl(getTargetUrl())
  * .setHeader("Content-Type", "text/html").build();
  * <p/>
@@ -61,7 +64,6 @@
  */
 public class SimpleAsyncHttpClient implements Closeable {
 
-    private final static Logger logger = LoggerFactory.getLogger(SimpleAsyncHttpClient.class);
     private final AsyncHttpClientConfig config;
     private final RequestBuilder requestBuilder;
     private AsyncHttpClient asyncHttpClient;
@@ -70,8 +72,11 @@
     private final ErrorDocumentBehaviour errorDocumentBehaviour;
     private final SimpleAHCTransferListener listener;
     private final boolean derived;
+    private final String providerClass;
 
-    private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler, ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
+    private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
+            ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener,
+            String providerClass) {
         this.config = config;
         this.requestBuilder = requestBuilder;
         this.defaultThrowableHandler = defaultThrowableHandler;
@@ -79,6 +84,7 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
         this.errorDocumentBehaviour = errorDocumentBehaviour;
         this.asyncHttpClient = ahc;
         this.listener = listener;
+        this.providerClass = providerClass;
 
         this.derived = ahc != null;
     }
@@ -126,7 +132,8 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
         return execute(r, bodyConsumer, null);
     }
 
-    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+            throws IOException {
         RequestBuilder r = rebuildRequest(requestBuilder.build());
         r.setMethod("POST");
         r.setBody(bodyGenerator);
@@ -162,7 +169,8 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
         return execute(r, bodyConsumer, null);
     }
 
-    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+            throws IOException {
         RequestBuilder r = rebuildRequest(requestBuilder.build());
         r.setMethod("PUT");
         r.setBody(bodyGenerator);
@@ -273,10 +281,10 @@ private RequestBuilder rebuildRequest(Request rb) {
         }
 
         Request request = rb.build();
-        ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour, request.getUrl(), listener);
+        ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour,
+                request.getUri(), listener);
 
-        if (resumeEnabled && request.getMethod().equals("GET") &&
-                bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
+        if (resumeEnabled && request.getMethod().equals("GET") && bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
             ResumableBodyConsumer fileBodyConsumer = (ResumableBodyConsumer) bodyConsumer;
             long length = fileBodyConsumer.getTransferredBytes();
             fileBodyConsumer.resume();
@@ -289,7 +297,10 @@ private RequestBuilder rebuildRequest(Request rb) {
     private AsyncHttpClient asyncHttpClient() {
         synchronized (config) {
             if (asyncHttpClient == null) {
-                asyncHttpClient = new AsyncHttpClient(config);
+                if (providerClass == null)
+                    asyncHttpClient = new DefaultAsyncHttpClient(config);
+                else
+                    asyncHttpClient = new DefaultAsyncHttpClient(providerClass, config);
             }
         }
         return asyncHttpClient;
@@ -349,6 +360,11 @@ public DerivedBuilder derive() {
         OMIT;
     }
 
+    /**
+     * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
+     *
+     * @see SimpleAsyncHttpClient#derive()
+     */
     /**
      * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
      *
@@ -356,15 +372,15 @@ public DerivedBuilder derive() {
      */
     public interface DerivedBuilder {
 
-        DerivedBuilder setFollowRedirects(boolean followRedirects);
+        DerivedBuilder setFollowRedirect(boolean followRedirect);
 
         DerivedBuilder setVirtualHost(String virtualHost);
 
         DerivedBuilder setUrl(String url);
 
-        DerivedBuilder setParameters(FluentStringsMap parameters) throws IllegalArgumentException;
+        DerivedBuilder setFormParams(List<Param> params);
 
-        DerivedBuilder setParameters(Map<String, Collection<String>> parameters) throws IllegalArgumentException;
+        DerivedBuilder setFormParams(Map<String, List<String>> params);
 
         DerivedBuilder setHeaders(Map<String, Collection<String>> headers);
 
@@ -372,15 +388,15 @@ public DerivedBuilder derive() {
 
         DerivedBuilder setHeader(String name, String value);
 
-        DerivedBuilder addQueryParameter(String name, String value);
+        DerivedBuilder addQueryParam(String name, String value);
 
-        DerivedBuilder addParameter(String key, String value) throws IllegalArgumentException;
+        DerivedBuilder addFormParam(String key, String value);
 
         DerivedBuilder addHeader(String name, String value);
 
         DerivedBuilder addCookie(Cookie cookie);
 
-        DerivedBuilder addBodyPart(Part part) throws IllegalArgumentException;
+        DerivedBuilder addBodyPart(Part part);
 
         DerivedBuilder setResumableDownload(boolean resume);
 
@@ -402,6 +418,7 @@ public DerivedBuilder derive() {
         private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
         private AsyncHttpClient ahc = null;
         private SimpleAHCTransferListener listener = null;
+        private String providerClass = null;
 
         public Builder() {
             requestBuilder = new RequestBuilder("GET", false);
@@ -416,7 +433,7 @@ private Builder(SimpleAsyncHttpClient client) {
             this.listener = client.listener;
         }
 
-        public Builder addBodyPart(Part part) throws IllegalArgumentException {
+        public Builder addBodyPart(Part part) {
             requestBuilder.addBodyPart(part);
             return this;
         }
@@ -431,13 +448,13 @@ public Builder addHeader(String name, String value) {
             return this;
         }
 
-        public Builder addParameter(String key, String value) throws IllegalArgumentException {
-            requestBuilder.addParameter(key, value);
+        public Builder addFormParam(String key, String value) {
+            requestBuilder.addFormParam(key, value);
             return this;
         }
 
-        public Builder addQueryParameter(String name, String value) {
-            requestBuilder.addQueryParameter(name, value);
+        public Builder addQueryParam(String name, String value) {
+            requestBuilder.addQueryParam(name, value);
             return this;
         }
 
@@ -456,13 +473,13 @@ public Builder setHeaders(Map<String, Collection<String>> headers) {
             return this;
         }
 
-        public Builder setParameters(Map<String, Collection<String>> parameters) throws IllegalArgumentException {
-            requestBuilder.setParameters(parameters);
+        public Builder setFormParams(Map<String, List<String>> parameters) {
+            requestBuilder.setFormParams(parameters);
             return this;
         }
 
-        public Builder setParameters(FluentStringsMap parameters) throws IllegalArgumentException {
-            requestBuilder.setParameters(parameters);
+        public Builder setFormParams(List<Param> params) {
+            requestBuilder.setFormParams(params);
             return this;
         }
 
@@ -476,43 +493,43 @@ public Builder setVirtualHost(String virtualHost) {
             return this;
         }
 
-        public Builder setFollowRedirects(boolean followRedirects) {
-            requestBuilder.setFollowRedirects(followRedirects);
+        public Builder setFollowRedirect(boolean followRedirect) {
+            requestBuilder.setFollowRedirect(followRedirect);
             return this;
         }
 
-        public Builder setMaximumConnectionsTotal(int defaultMaxTotalConnections) {
-            configBuilder.setMaximumConnectionsTotal(defaultMaxTotalConnections);
+        public Builder setMaxConnections(int defaultMaxConnections) {
+            configBuilder.setMaxConnections(defaultMaxConnections);
             return this;
         }
 
-        public Builder setMaximumConnectionsPerHost(int defaultMaxConnectionPerHost) {
-            configBuilder.setMaximumConnectionsPerHost(defaultMaxConnectionPerHost);
+        public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
+            configBuilder.setMaxConnectionsPerHost(defaultMaxConnectionsPerHost);
             return this;
         }
 
-        public Builder setConnectionTimeoutInMs(int connectionTimeuot) {
-            configBuilder.setConnectionTimeoutInMs(connectionTimeuot);
+        public Builder setConnectionTimeout(int connectionTimeuot) {
+            configBuilder.setConnectionTimeout(connectionTimeuot);
             return this;
         }
 
-        public Builder setIdleConnectionInPoolTimeoutInMs(int defaultIdleConnectionInPoolTimeoutInMs) {
-            configBuilder.setIdleConnectionInPoolTimeoutInMs(defaultIdleConnectionInPoolTimeoutInMs);
+        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+            configBuilder.setPooledConnectionIdleTimeout(pooledConnectionIdleTimeout);
             return this;
         }
 
-        public Builder setRequestTimeoutInMs(int defaultRequestTimeoutInMs) {
-            configBuilder.setRequestTimeoutInMs(defaultRequestTimeoutInMs);
+        public Builder setRequestTimeout(int defaultRequestTimeout) {
+            configBuilder.setRequestTimeout(defaultRequestTimeout);
             return this;
         }
 
-        public Builder setMaximumNumberOfRedirects(int maxDefaultRedirects) {
-            configBuilder.setMaximumNumberOfRedirects(maxDefaultRedirects);
+        public Builder setMaxRedirects(int maxRedirects) {
+            configBuilder.setMaxRedirects(maxRedirects);
             return this;
         }
 
-        public Builder setCompressionEnabled(boolean compressionEnabled) {
-            configBuilder.setCompressionEnabled(compressionEnabled);
+        public Builder setCompressionEnforced(boolean compressionEnforced) {
+            configBuilder.setCompressionEnforced(compressionEnforced);
             return this;
         }
 
@@ -521,13 +538,8 @@ public Builder setUserAgent(String userAgent) {
             return this;
         }
 
-        public Builder setAllowPoolingConnection(boolean allowPoolingConnection) {
-            configBuilder.setAllowPoolingConnection(allowPoolingConnection);
-            return this;
-        }
-
-        public Builder setScheduledExecutorService(ScheduledExecutorService reaper) {
-            configBuilder.setScheduledExecutorService(reaper);
+        public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
+            configBuilder.setAllowPoolingConnections(allowPoolingConnections);
             return this;
         }
 
@@ -536,23 +548,13 @@ public Builder setExecutorService(ExecutorService applicationThreadPool) {
             return this;
         }
 
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            configBuilder.setSSLEngineFactory(sslEngineFactory);
-            return this;
-        }
-
         public Builder setSSLContext(final SSLContext sslContext) {
             configBuilder.setSSLContext(sslContext);
             return this;
         }
 
-        public Builder setRequestCompressionLevel(int requestCompressionLevel) {
-            configBuilder.setRequestCompressionLevel(requestCompressionLevel);
-            return this;
-        }
-
-        public Builder setRealmDomain(String domain) {
-            realm().setDomain(domain);
+        public Builder setRealmNtlmDomain(String domain) {
+            realm().setNtlmDomain(domain);
             return this;
         }
 
@@ -582,7 +584,7 @@ public Builder setRealmUsePreemptiveAuth(boolean usePreemptiveAuth) {
         }
 
         public Builder setRealmEnconding(String enc) {
-            realm().setEnconding(enc);
+            realm().setEncoding(enc);
             return this;
         }
 
@@ -661,6 +663,16 @@ public Builder setMaxRequestRetry(int maxRequestRetry) {
             return this;
         }
 
+        public Builder setProviderClass(String providerClass) {
+            this.providerClass = providerClass;
+            return this;
+        }
+
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            configBuilder.setAcceptAnyCertificate(acceptAnyCertificate);
+            return this;
+        }
+
         public SimpleAsyncHttpClient build() {
 
             if (realmBuilder != null) {
@@ -673,15 +685,14 @@ public SimpleAsyncHttpClient build() {
 
             configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
 
-            SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler, errorDocumentBehaviour, enableResumableDownload, ahc, listener);
+            SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
+                    errorDocumentBehaviour, enableResumableDownload, ahc, listener, providerClass);
 
             return sc;
         }
     }
 
-    private final static class ResumableBodyConsumerAsyncHandler
-            extends ResumableAsyncHandler
-            implements ProgressAsyncHandler<Response> {
+    private final static class ResumableBodyConsumerAsyncHandler extends ResumableAsyncHandler implements ProgressAsyncHandler<Response> {
 
         private final ProgressAsyncHandler<Response> delegate;
 
@@ -708,7 +719,7 @@ public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHand
         private final BodyConsumer bodyConsumer;
         private final ThrowableHandler exceptionHandler;
         private final ErrorDocumentBehaviour errorDocumentBehaviour;
-        private final String url;
+        private final Uri uri;
         private final SimpleAHCTransferListener listener;
 
         private boolean accumulateBody = false;
@@ -716,11 +727,12 @@ public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHand
         private int amount = 0;
         private long total = -1;
 
-        public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler, ErrorDocumentBehaviour errorDocumentBehaviour, String url, SimpleAHCTransferListener listener) {
+        public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler,
+                ErrorDocumentBehaviour errorDocumentBehaviour, Uri uri, SimpleAHCTransferListener listener) {
             this.bodyConsumer = bodyConsumer;
             this.exceptionHandler = exceptionHandler;
             this.errorDocumentBehaviour = errorDocumentBehaviour;
-            this.url = url;
+            this.uri = uri;
             this.listener = listener;
         }
 
@@ -754,7 +766,6 @@ public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
             return STATE.CONTINUE;
         }
 
-
         /**
          * {@inheritDoc}
          */
@@ -766,30 +777,24 @@ public Response onCompleted(Response response) throws Exception {
         }
 
         private void closeConsumer() {
-            try {
-                if (bodyConsumer != null) {
-                    bodyConsumer.close();
-                }
-            } catch (IOException ex) {
-                logger.warn("Unable to close a BodyConsumer {}", bodyConsumer);
-            }
+            if (bodyConsumer != null)
+                closeSilently(bodyConsumer);
         }
 
         @Override
-        public STATE onStatusReceived(HttpResponseStatus status)
-                throws Exception {
+        public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
             fireStatus(status);
 
             if (isErrorStatus(status)) {
                 switch (errorDocumentBehaviour) {
-                    case ACCUMULATE:
-                        accumulateBody = true;
-                        break;
-                    case OMIT:
-                        omitBody = true;
-                        break;
-                    default:
-                        break;
+                case ACCUMULATE:
+                    accumulateBody = true;
+                    break;
+                case OMIT:
+                    omitBody = true;
+                    break;
+                default:
+                    break;
                 }
             }
             return super.onStatusReceived(status);
@@ -800,8 +805,7 @@ private boolean isErrorStatus(HttpResponseStatus status) {
         }
 
         @Override
-        public STATE onHeadersReceived(HttpResponseHeaders headers)
-                throws Exception {
+        public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
             calculateTotal(headers);
 
             fireHeaders(headers);
@@ -821,13 +825,13 @@ private void calculateTotal(HttpResponseHeaders headers) {
 
         @Override
         public STATE onContentWriteProgress(long amount, long current, long total) {
-            fireSent(url, amount, current, total);
+            fireSent(uri, amount, current, total);
             return super.onContentWriteProgress(amount, current, total);
         }
 
         private void fireStatus(HttpResponseStatus status) {
             if (listener != null) {
-                listener.onStatus(url, status.getStatusCode(), status.getStatusText());
+                listener.onStatus(uri, status.getStatusCode(), status.getStatusText());
             }
         }
 
@@ -837,27 +841,26 @@ private void fireReceived(HttpResponseBodyPart content) {
             amount += remaining;
 
             if (listener != null) {
-                listener.onBytesReceived(url, amount, remaining, total);
+                listener.onBytesReceived(uri, amount, remaining, total);
             }
         }
 
         private void fireHeaders(HttpResponseHeaders headers) {
             if (listener != null) {
-                listener.onHeaders(url, new HeaderMap(headers.getHeaders()));
+                listener.onHeaders(uri, new HeaderMap(headers.getHeaders()));
             }
         }
 
-        private void fireSent(String url, long amount, long current, long total) {
+        private void fireSent(Uri uri, long amount, long current, long total) {
             if (listener != null) {
-                listener.onBytesSent(url, amount, current, total);
+                listener.onBytesSent(uri, amount, current, total);
             }
         }
 
         private void fireCompleted(Response response) {
             if (listener != null) {
-                listener.onCompleted(url, response.getStatusCode(), response.getStatusText());
+                listener.onCompleted(uri, response.getStatusCode(), response.getStatusText());
             }
         }
     }
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/StringPart.java b/api/src/main/java/org/asynchttpclient/StringPart.java
deleted file mode 100644
index cd0c617c5..000000000
--- a/api/src/main/java/org/asynchttpclient/StringPart.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient;
-
-/**
- * A string multipart part.
- */
-public class StringPart implements Part {
-    private final String name;
-    private final String value;
-    private final String charset;
-
-    public StringPart(String name, String value, String charset) {
-        this.name = name;
-        this.value = value;
-        this.charset = charset;
-    }
-
-    public StringPart(String name, String value) {
-        this.name = name;
-        this.value = value;
-        this.charset = "UTF-8";
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public String getName() {
-        return name;
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public String getCharset() {
-        return charset;
-    }
-
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/ThrowableHandler.java b/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
index cbafe5901..1bc28ea82 100644
--- a/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
@@ -19,5 +19,4 @@
 public interface ThrowableHandler {
 
     void onThrowable(Throwable t);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/UpgradeHandler.java b/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
index 9ed5e4a7b..e541e6745 100644
--- a/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
@@ -33,5 +33,4 @@
      * @param t a {@link Throwable}
      */
     void onFailure(Throwable t);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
index c69ac0698..6f84d57f6 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
@@ -13,6 +13,7 @@
 package org.asynchttpclient.consumers;
 
 import org.asynchttpclient.BodyConsumer;
+import org.asynchttpclient.util.StandardCharsets;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -33,26 +34,18 @@ public AppendableBodyConsumer(Appendable appendable, String encoding) {
 
     public AppendableBodyConsumer(Appendable appendable) {
         this.appendable = appendable;
-        this.encoding = "UTF-8";
+        this.encoding = StandardCharsets.UTF_8.name();
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
+    @Override
     public void consume(ByteBuffer byteBuffer) throws IOException {
-        appendable.append(new String(byteBuffer.array(),
-                                     byteBuffer.arrayOffset() + byteBuffer.position(),
-                                     byteBuffer.remaining(),
-                                     encoding));
+        appendable
+                .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), encoding));
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
+    @Override
     public void close() throws IOException {
-        if (Closeable.class.isAssignableFrom(appendable.getClass())) {
+        if (appendable instanceof Closeable) {
             Closeable.class.cast(appendable).close();
         }
     }
diff --git a/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
index 8ab464122..a8b4c748e 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
@@ -31,7 +31,7 @@ public ByteBufferBodyConsumer(ByteBuffer byteBuffer) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void consume(ByteBuffer byteBuffer) throws IOException {
         byteBuffer.put(byteBuffer);
     }
@@ -39,7 +39,7 @@ public void consume(ByteBuffer byteBuffer) throws IOException {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void close() throws IOException {
         byteBuffer.flip();
     }
diff --git a/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
index 531228bcc..5677dfdd1 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
@@ -32,18 +32,16 @@ public FileBodyConsumer(RandomAccessFile file) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void consume(ByteBuffer byteBuffer) throws IOException {
         // TODO: Channel.transferFrom may be a good idea to investigate.
-        file.write(byteBuffer.array(),
-                   byteBuffer.arrayOffset() + byteBuffer.position(),
-                   byteBuffer.remaining());
+        file.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
     }
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void close() throws IOException {
         file.close();
     }
@@ -51,7 +49,7 @@ public void close() throws IOException {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public long getTransferredBytes() throws IOException {
         return file.length();
     }
@@ -59,7 +57,7 @@ public long getTransferredBytes() throws IOException {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void resume() throws IOException {
         file.seek(getTransferredBytes());
     }
diff --git a/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
index 7ab4d1184..65f8f85cc 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
@@ -32,17 +32,15 @@ public OutputStreamBodyConsumer(OutputStream outputStream) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void consume(ByteBuffer byteBuffer) throws IOException {
-        outputStream.write(byteBuffer.array(),
-                           byteBuffer.arrayOffset() + byteBuffer.position(),
-                           byteBuffer.remaining());
+        outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
     }
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void close() throws IOException {
         outputStream.close();
     }
diff --git a/api/src/main/java/org/asynchttpclient/cookie/Cookie.java b/api/src/main/java/org/asynchttpclient/cookie/Cookie.java
new file mode 100644
index 000000000..66c366cfa
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/Cookie.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+public class Cookie {
+
+    public static Cookie newValidCookie(String name, String value, String rawValue, String domain, String path, long expires, int maxAge,
+            boolean secure, boolean httpOnly) {
+
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+        name = name.trim();
+        if (name.isEmpty()) {
+            throw new IllegalArgumentException("empty name");
+        }
+
+        for (int i = 0; i < name.length(); i++) {
+            char c = name.charAt(i);
+            if (c > 127) {
+                throw new IllegalArgumentException("name contains non-ascii character: " + name);
+            }
+
+            // Check prohibited characters.
+            switch (c) {
+            case '\t':
+            case '\n':
+            case 0x0b:
+            case '\f':
+            case '\r':
+            case ' ':
+            case ',':
+            case ';':
+            case '=':
+                throw new IllegalArgumentException("name contains one of the following prohibited characters: " + "=,; \\t\\r\\n\\v\\f: "
+                        + name);
+            }
+        }
+
+        if (name.charAt(0) == '$') {
+            throw new IllegalArgumentException("name starting with '$' not allowed: " + name);
+        }
+
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+
+        domain = validateValue("domain", domain);
+        path = validateValue("path", path);
+
+        return new Cookie(name, value, rawValue, domain, path, expires, maxAge, secure, httpOnly);
+    }
+
+    private static String validateValue(String name, String value) {
+        if (value == null) {
+            return null;
+        }
+        value = value.trim();
+        if (value.isEmpty()) {
+            return null;
+        }
+
+        for (int i = 0; i < value.length(); i++) {
+            char c = value.charAt(i);
+            switch (c) {
+            case '\r':
+            case '\n':
+            case '\f':
+            case 0x0b:
+            case ';':
+                throw new IllegalArgumentException(name + " contains one of the following prohibited characters: " + ";\\r\\n\\f\\v ("
+                        + value + ')');
+            }
+        }
+        return value;
+    }
+
+    private final String name;
+    private final String value;
+    private final String rawValue;
+    private final String domain;
+    private final String path;
+    private long expires;
+    private final int maxAge;
+    private final boolean secure;
+    private final boolean httpOnly;
+
+    public Cookie(String name, String value, String rawValue, String domain, String path, long expires, int maxAge, boolean secure,
+            boolean httpOnly) {
+        this.name = name;
+        this.value = value;
+        this.rawValue = rawValue;
+        this.domain = domain;
+        this.path = path;
+        this.expires = expires;
+        this.maxAge = maxAge;
+        this.secure = secure;
+        this.httpOnly = httpOnly;
+    }
+
+    public String getDomain() {
+        return domain;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public String getRawValue() {
+        return rawValue;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    public long getExpires() {
+        return expires;
+    }
+
+    public int getMaxAge() {
+        return maxAge;
+    }
+
+    public boolean isSecure() {
+        return secure;
+    }
+
+    public boolean isHttpOnly() {
+        return httpOnly;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder();
+        buf.append(name);
+        buf.append("=");
+        buf.append(rawValue);
+        if (domain != null) {
+            buf.append("; domain=");
+            buf.append(domain);
+        }
+        if (path != null) {
+            buf.append("; path=");
+            buf.append(path);
+        }
+        if (expires >= 0) {
+            buf.append("; expires=");
+            buf.append(expires);
+        }
+        if (maxAge >= 0) {
+            buf.append("; maxAge=");
+            buf.append(maxAge);
+            buf.append("s");
+        }
+        if (secure) {
+            buf.append("; secure");
+        }
+        if (httpOnly) {
+            buf.append("; HTTPOnly");
+        }
+        return buf.toString();
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java b/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
new file mode 100644
index 000000000..949fb069c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import org.asynchttpclient.date.CalendarTimeConverter;
+import org.asynchttpclient.date.TimeConverter;
+
+public class CookieDecoder {
+
+    public static final TimeConverter DEFAULT_TIME_CONVERTER = new CalendarTimeConverter();
+
+    public static Cookie decode(String header) {
+        return decode(header, DEFAULT_TIME_CONVERTER);
+    }
+
+    /**
+     * Decodes the specified HTTP header value into {@link Cookie}.
+     * 
+     * @return the decoded {@link Cookie}
+     */
+    public static Cookie decode(String header, TimeConverter timeConverter) {
+
+        if (timeConverter == null)
+            timeConverter = DEFAULT_TIME_CONVERTER;
+
+        if (header.isEmpty())
+            return null;
+
+        KeyValuePairsParser pairsParser = new KeyValuePairsParser(timeConverter);
+
+        final int headerLen = header.length();
+        loop: for (int i = 0;;) {
+
+            // Skip spaces and separators.
+            for (;;) {
+                if (i == headerLen) {
+                    break loop;
+                }
+                char c = header.charAt(i);
+                if (c == ',') {
+                    // Having multiple cookies in a single Set-Cookie header is
+                    // deprecated, modern browsers only parse the first one
+                    break loop;
+
+                } else if (c == '\t' || c == '\n' || c == 0x0b || c == '\f' || c == '\r' || c == ' ' || c == ';') {
+                    i++;
+                    continue;
+                }
+                break;
+            }
+
+            int newNameStart = i;
+            int newNameEnd = i;
+            String value;
+            String rawValue;
+            boolean first = true;
+
+            if (i == headerLen) {
+                value = rawValue = null;
+            } else {
+                keyValLoop: for (;;) {
+
+                    char curChar = header.charAt(i);
+                    if (curChar == ';') {
+                        // NAME; (no value till ';')
+                        newNameEnd = i;
+                        value = rawValue = null;
+                        first = false;
+                        break keyValLoop;
+                    } else if (curChar == '=') {
+                        // NAME=VALUE
+                        newNameEnd = i;
+                        i++;
+                        if (i == headerLen) {
+                            // NAME= (empty value, i.e. nothing after '=')
+                            value = rawValue = "";
+                            first = false;
+                            break keyValLoop;
+                        }
+
+                        int newValueStart = i;
+                        char c = header.charAt(i);
+                        if (c == '"' || c == '\'') {
+                            // NAME="VALUE" or NAME='VALUE'
+                            StringBuilder newValueBuf = new StringBuilder(header.length() - i);
+
+                            int rawValueStart = i;
+                            int rawValueEnd = i;
+
+                            final char q = c;
+                            boolean hadBackslash = false;
+                            i++;
+                            for (;;) {
+                                if (i == headerLen) {
+                                    value = newValueBuf.toString();
+                                    // only need to compute raw value for cookie
+                                    // value which is at most in 2nd position
+                                    rawValue = first ? header.substring(rawValueStart, rawValueEnd) : null;
+                                    first = false;
+                                    break keyValLoop;
+                                }
+                                if (hadBackslash) {
+                                    hadBackslash = false;
+                                    c = header.charAt(i++);
+                                    rawValueEnd = i;
+                                    switch (c) {
+                                    case '\\':
+                                    case '"':
+                                    case '\'':
+                                        // Escape last backslash.
+                                        newValueBuf.setCharAt(newValueBuf.length() - 1, c);
+                                        break;
+                                    default:
+                                        // Do not escape last backslash.
+                                        newValueBuf.append(c);
+                                    }
+                                } else {
+                                    c = header.charAt(i++);
+                                    rawValueEnd = i;
+                                    if (c == q) {
+                                        value = newValueBuf.toString();
+                                        // only need to compute raw value for
+                                        // cookie value which is at most in 2nd
+                                        // position
+                                        rawValue = first ? header.substring(rawValueStart, rawValueEnd) : null;
+                                        first = false;
+                                        break keyValLoop;
+                                    }
+                                    newValueBuf.append(c);
+                                    if (c == '\\') {
+                                        hadBackslash = true;
+                                    }
+                                }
+                            }
+                        } else {
+                            // NAME=VALUE;
+                            int semiPos = header.indexOf(';', i);
+                            if (semiPos > 0) {
+                                value = rawValue = header.substring(newValueStart, semiPos);
+                                i = semiPos;
+                            } else {
+                                value = rawValue = header.substring(newValueStart);
+                                i = headerLen;
+                            }
+                        }
+                        break keyValLoop;
+                    } else {
+                        i++;
+                    }
+
+                    if (i == headerLen) {
+                        // NAME (no value till the end of string)
+                        newNameEnd = headerLen;
+                        first = false;
+                        value = rawValue = null;
+                        break;
+                    }
+                }
+            }
+
+            pairsParser.parseKeyValuePair(header, newNameStart, newNameEnd, value, rawValue);
+        }
+        return pairsParser.cookie();
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
new file mode 100644
index 000000000..bf895f3a4
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import java.util.Collection;
+
+public final class CookieEncoder {
+
+    private CookieEncoder() {
+    }
+
+    public static String encode(Collection<Cookie> cookies) {
+        StringBuilder sb = new StringBuilder();
+
+        for (Cookie cookie : cookies) {
+            add(sb, cookie.getName(), cookie.getRawValue());
+        }
+
+        if (sb.length() > 0) {
+            sb.setLength(sb.length() - 2);
+        }
+        return sb.toString();
+    }
+
+    private static void add(StringBuilder sb, String name, String val) {
+
+        if (val == null) {
+            val = "";
+        }
+
+        sb.append(name);
+        sb.append('=');
+        sb.append(val);
+        sb.append(';');
+        sb.append(' ');
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java b/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java
new file mode 100644
index 000000000..795de30a5
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import org.asynchttpclient.date.RFC2616Date;
+import org.asynchttpclient.date.RFC2616DateParser;
+import org.asynchttpclient.date.TimeConverter;
+
+/**
+ * A companion for CookieDecoder that parses key-value pairs (cookie name/value
+ * and attributes).
+ * 
+ * @author slandelle
+ */
+class KeyValuePairsParser {
+
+    private final TimeConverter timeBuilder;
+    private String name;
+    private String value;
+    private String rawValue;
+    private String domain;
+    private String path;
+    private long expires = -1L;
+    private int maxAge = -1;
+    private boolean secure;
+    private boolean httpOnly;
+
+    /**
+     * @param timeBuilder used for parsing expires attribute
+     */
+    public KeyValuePairsParser(TimeConverter timeBuilder) {
+        this.timeBuilder = timeBuilder;
+    }
+
+    public Cookie cookie() {
+        return name != null ? new Cookie(name, value, rawValue, domain, path, expires, maxAge, secure, httpOnly) : null;
+    }
+
+    /**
+     * Parse and store a key-value pair. First one is considered to be the
+     * cookie name/value. Unknown attribute names are silently discarded.
+     * 
+     * @param header the HTTP header
+     * @param keyStart where the key starts in the header
+     * @param keyEnd where the key ends in the header
+     * @param value the decoded value
+     * @param rawValue the raw value (only non null for cookie value)
+     */
+    public void parseKeyValuePair(String header, int keyStart, int keyEnd, String value, String rawValue) {
+
+        if (name == null)
+            setCookieNameValue(header, keyStart, keyEnd, value, rawValue);
+        else
+            setCookieAttribute(header, keyStart, keyEnd, value);
+    }
+
+    private void setCookieNameValue(String header, int keyStart, int keyEnd, String value, String rawValue) {
+        name = header.substring(keyStart, keyEnd);
+        this.value = value;
+        this.rawValue = rawValue;
+    }
+
+    private void setCookieAttribute(String header, int keyStart, int keyEnd, String value) {
+
+        int length = keyEnd - keyStart;
+
+        if (length == 4)
+            parse4(header, keyStart, value);
+        else if (length == 6)
+            parse6(header, keyStart, value);
+        else if (length == 7)
+            parse7(header, keyStart, value);
+        else if (length == 8)
+            parse8(header, keyStart, value);
+    }
+
+    private boolean isPath(char c0, char c1, char c2, char c3) {
+        return (c0 == 'P' || c0 == 'p') && //
+                (c1 == 'a' || c1 == 'A') && //
+                (c2 == 't' || c2 == 'T') && //
+                (c3 == 'h' || c3 == 'H');
+    }
+
+    private void parse4(String header, int nameStart, String value) {
+
+        char c0 = header.charAt(nameStart);
+        char c1 = header.charAt(nameStart + 1);
+        char c2 = header.charAt(nameStart + 2);
+        char c3 = header.charAt(nameStart + 3);
+
+        if (isPath(c0, c1, c2, c3))
+            path = value;
+    }
+
+    private boolean isDomain(char c0, char c1, char c2, char c3, char c4, char c5) {
+        return (c0 == 'D' || c0 == 'd') && //
+                (c1 == 'o' || c1 == 'O') && //
+                (c2 == 'm' || c2 == 'M') && //
+                (c3 == 'a' || c3 == 'A') && //
+                (c4 == 'i' || c4 == 'I') && //
+                (c5 == 'n' || c5 == 'N');
+    }
+
+    private boolean isSecure(char c0, char c1, char c2, char c3, char c4, char c5) {
+        return (c0 == 'S' || c0 == 's') && //
+                (c1 == 'e' || c1 == 'E') && //
+                (c2 == 'c' || c2 == 'C') && //
+                (c3 == 'u' || c3 == 'U') && //
+                (c4 == 'r' || c4 == 'R') && //
+                (c5 == 'e' || c5 == 'E');
+    }
+
+    private void parse6(String header, int nameStart, String value) {
+
+        char c0 = header.charAt(nameStart);
+        char c1 = header.charAt(nameStart + 1);
+        char c2 = header.charAt(nameStart + 2);
+        char c3 = header.charAt(nameStart + 3);
+        char c4 = header.charAt(nameStart + 4);
+        char c5 = header.charAt(nameStart + 5);
+
+        if (isDomain(c0, c1, c2, c3, c4, c5))
+            domain = value;
+        else if (isSecure(c0, c1, c2, c3, c4, c5))
+            secure = true;
+    }
+
+    private boolean isExpires(char c0, char c1, char c2, char c3, char c4, char c5, char c6) {
+        return (c0 == 'E' || c0 == 'e') && //
+                (c1 == 'x' || c1 == 'X') && //
+                (c2 == 'p' || c2 == 'P') && //
+                (c3 == 'i' || c3 == 'I') && //
+                (c4 == 'r' || c4 == 'R') && //
+                (c5 == 'e' || c5 == 'E') && //
+                (c6 == 's' || c6 == 'S');
+    }
+
+    private boolean isMaxAge(char c0, char c1, char c2, char c3, char c4, char c5, char c6) {
+        return (c0 == 'M' || c0 == 'm') && //
+                (c1 == 'a' || c1 == 'A') && //
+                (c2 == 'x' || c2 == 'X') && //
+                (c3 == '-') && //
+                (c4 == 'A' || c4 == 'a') && //
+                (c5 == 'g' || c5 == 'G') && //
+                (c6 == 'e' || c6 == 'E');
+    }
+
+    private void setExpire(String value) {
+
+        RFC2616Date dateElements = new RFC2616DateParser(value).parse();
+        if (dateElements != null) {
+            try {
+                expires = timeBuilder.toTime(dateElements);
+            } catch (Exception e1) {
+                // ignore failure to parse -> treat as session cookie
+            }
+        }
+    }
+
+    private void setMaxAge(String value) {
+        try {
+            maxAge = Math.max(Integer.valueOf(value), 0);
+        } catch (NumberFormatException e1) {
+            // ignore failure to parse -> treat as session cookie
+        }
+    }
+
+    private void parse7(String header, int nameStart, String value) {
+
+        char c0 = header.charAt(nameStart);
+        char c1 = header.charAt(nameStart + 1);
+        char c2 = header.charAt(nameStart + 2);
+        char c3 = header.charAt(nameStart + 3);
+        char c4 = header.charAt(nameStart + 4);
+        char c5 = header.charAt(nameStart + 5);
+        char c6 = header.charAt(nameStart + 6);
+
+        if (isExpires(c0, c1, c2, c3, c4, c5, c6))
+            setExpire(value);
+
+        else if (isMaxAge(c0, c1, c2, c3, c4, c5, c6))
+            setMaxAge(value);
+    }
+
+    private boolean isHttpOnly(char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7) {
+        return (c0 == 'H' || c0 == 'h') && //
+                (c1 == 't' || c1 == 'T') && //
+                (c2 == 't' || c2 == 'T') && //
+                (c3 == 'p' || c3 == 'P') && //
+                (c4 == 'O' || c4 == 'o') && //
+                (c5 == 'n' || c5 == 'N') && //
+                (c6 == 'l' || c6 == 'L') && //
+                (c7 == 'y' || c7 == 'Y');
+    }
+
+    private void parse8(String header, int nameStart, String value) {
+
+        char c0 = header.charAt(nameStart);
+        char c1 = header.charAt(nameStart + 1);
+        char c2 = header.charAt(nameStart + 2);
+        char c3 = header.charAt(nameStart + 3);
+        char c4 = header.charAt(nameStart + 4);
+        char c5 = header.charAt(nameStart + 5);
+        char c6 = header.charAt(nameStart + 6);
+        char c7 = header.charAt(nameStart + 7);
+
+        if (isHttpOnly(c0, c1, c2, c3, c4, c5, c6, c7))
+            httpOnly = true;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java b/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java
new file mode 100644
index 000000000..edc3061db
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.date;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+/**
+ * Calendar based TimeConverter.
+ * Note that a Joda-Time or DateTime based implementation would be more efficient, but AHC doesn't have a dependency to JodaTime.
+ * 
+ * @author slandelle
+ */
+public class CalendarTimeConverter implements TimeConverter {
+
+    public static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
+    @Override
+    public long toTime(RFC2616Date dateElements) {
+
+        Calendar calendar = new GregorianCalendar(//
+                dateElements.year(), //
+                dateElements.month() - 1, // beware, Calendar use months from 0 to 11
+                dateElements.dayOfMonth(), //
+                dateElements.hour(), //
+                dateElements.minute(), //
+                dateElements.second());
+        calendar.setTimeZone(GMT);
+        return calendar.getTimeInMillis();
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java b/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java
new file mode 100644
index 000000000..247870bd5
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.date;
+
+/**
+ * A placeholder for RFC2616 date elements
+ * 
+ * @author slandelle
+ */
+public final class RFC2616Date {
+
+    private final int year;
+    // 1 to 12
+    private final int month;
+    private final int dayOfMonth;
+    private final int hour;
+    private final int minute;
+    private final int second;
+
+    public RFC2616Date(int year, int month, int dayOfMonth, int hour, int minute, int second) {
+        this.year = year;
+        this.month = month;
+        this.dayOfMonth = dayOfMonth;
+        this.hour = hour;
+        this.minute = minute;
+        this.second = second;
+    }
+
+    public int year() {
+        return year;
+    }
+
+    public int month() {
+        return month;
+    }
+
+    public int dayOfMonth() {
+        return dayOfMonth;
+    }
+
+    public int hour() {
+        return hour;
+    }
+
+    public int minute() {
+        return minute;
+    }
+
+    public int second() {
+        return second;
+    }
+
+    public static final class Builder {
+
+        private int dayOfMonth;
+        private int month;
+        private int year;
+        private int hour;
+        private int minute;
+        private int second;
+
+        public void setDayOfMonth(int dayOfMonth) {
+            this.dayOfMonth = dayOfMonth;
+        }
+
+        public void setJanuary() {
+            month = 1;
+        }
+
+        public void setFebruary() {
+            month = 2;
+        }
+
+        public void setMarch() {
+            month = 3;
+        }
+
+        public void setApril() {
+            month = 4;
+        }
+
+        public void setMay() {
+            month = 5;
+        }
+
+        public void setJune() {
+            month = 6;
+        }
+
+        public void setJuly() {
+            month = 7;
+        }
+
+        public void setAugust() {
+            month = 8;
+        }
+
+        public void setSeptember() {
+            month = 9;
+        }
+
+        public void setOctobre() {
+            month = 10;
+        }
+
+        public void setNovembre() {
+            month = 11;
+        }
+
+        public void setDecember() {
+            month = 12;
+        }
+
+        public void setYear(int year) {
+            this.year = year;
+        }
+
+        public void setHour(int hour) {
+            this.hour = hour;
+        }
+
+        public void setMinute(int minute) {
+            this.minute = minute;
+        }
+
+        public void setSecond(int second) {
+            this.second = second;
+        }
+
+        public RFC2616Date build() {
+            return new RFC2616Date(year, month, dayOfMonth, hour, minute, second);
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java b/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java
new file mode 100644
index 000000000..effc5168a
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.date;
+
+import org.asynchttpclient.date.RFC2616Date.Builder;
+
+/**
+ * A parser for <a href="http://tools.ietf.org/html/rfc2616#section-3.3">RFC2616
+ * Date format</a>.
+ * 
+ * @author slandelle
+ */
+public class RFC2616DateParser {
+
+    private final String string;
+    private final int offset;
+    private final int length;
+
+    /**
+     * @param string a string that will be fully parsed
+     */
+    public RFC2616DateParser(String string) {
+        this(string, 0, string.length());
+    }
+
+    /**
+     * @param string the string to be parsed
+     * @param offset the offset where to start parsing
+     * @param length the number of chars to parse
+     */
+    public RFC2616DateParser(String string, int offset, int length) {
+
+        if (string.length() + offset < length)
+            throw new IllegalArgumentException("String length doesn't match offset and length");
+
+        this.string = string;
+        this.offset = offset;
+        this.length = length;
+    }
+
+    private static class Tokens {
+        public final int[] starts;
+        public final int[] ends;
+        public final int length;
+
+        public Tokens(int[] starts, int[] ends, int length) {
+            this.starts = starts;
+            this.ends = ends;
+            this.length = length;
+        }
+    }
+
+    private Tokens tokenize() {
+
+        int[] starts = new int[8];
+        int[] ends = new int[8];
+        boolean inToken = false;
+        int tokenCount = 0;
+
+        int end = offset + length;
+        for (int i = offset; i < end; i++) {
+
+            char c = string.charAt(i);
+            if (c == ' ' || c == ',' || c == '-' || c == ':') {
+                if (inToken) {
+                    ends[tokenCount++] = i;
+                    inToken = false;
+                }
+            } else if (!inToken) {
+                starts[tokenCount] = i;
+                inToken = true;
+            }
+        }
+
+        // finish lastToken
+        if (inToken == true)
+            ends[tokenCount++] = end;
+
+        return new Tokens(starts, ends, tokenCount);
+    }
+
+    /**
+     * @param validate if validation is to be enabled of non-critical elements,
+     *            such as day of week and timezone
+     * @return null is the string is not a valid RFC2616 date
+     */
+    public RFC2616Date parse() {
+
+        Tokens tokens = tokenize();
+
+        if (tokens.length != 7 && tokens.length != 8)
+            return null;
+
+        // 1st token is ignored: ignore day of week
+        // 8th token is ignored: supposed to always be GMT
+
+        if (isDigit(string.charAt(tokens.starts[1])))
+            return buildDate(tokens);
+        else
+            return buildANSICDate(tokens);
+    }
+
+    private RFC2616Date buildDate(Tokens tokens) {
+
+        // Sun, 06 Nov 1994 08:49:37 GMT
+
+        Builder dateBuilder = new Builder();
+
+        if (isValidDayOfMonth(tokens.starts[1], tokens.ends[1], dateBuilder) && //
+                isValidMonth(tokens.starts[2], tokens.ends[2], dateBuilder) && //
+                isValidYear(tokens.starts[3], tokens.ends[3], dateBuilder) && //
+                isValidHour(tokens.starts[4], tokens.ends[4], dateBuilder) && //
+                isValidMinuteSecond(tokens.starts[5], tokens.ends[5], dateBuilder, true) && //
+                isValidMinuteSecond(tokens.starts[6], tokens.ends[6], dateBuilder, false)) {
+            return dateBuilder.build();
+        }
+
+        return null;
+    }
+
+    private RFC2616Date buildANSICDate(Tokens tokens) {
+
+        // Sun Nov 6 08:49:37 1994
+
+        Builder dateBuilder = new Builder();
+
+        if (isValidMonth(tokens.starts[1], tokens.ends[1], dateBuilder) && //
+                isValidDayOfMonth(tokens.starts[2], tokens.ends[2], dateBuilder) && //
+                isValidHour(tokens.starts[3], tokens.ends[3], dateBuilder) && //
+                isValidMinuteSecond(tokens.starts[4], tokens.ends[4], dateBuilder, true) && //
+                isValidMinuteSecond(tokens.starts[5], tokens.ends[5], dateBuilder, false) && //
+                isValidYear(tokens.starts[6], tokens.ends[6], dateBuilder)) {
+            return dateBuilder.build();
+        }
+
+        return null;
+    }
+
+    private boolean isValid1DigitDayOfMonth(char c0, Builder dateBuilder) {
+        if (isDigit(c0)) {
+            dateBuilder.setDayOfMonth(getNumericValue(c0));
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValid2DigitsDayOfMonth(char c0, char c1, Builder dateBuilder) {
+        if (isDigit(c0) && isDigit(c1)) {
+            int i0 = getNumericValue(c0);
+            int i1 = getNumericValue(c1);
+            int day = i0 * 10 + i1;
+            if (day <= 31) {
+                dateBuilder.setDayOfMonth(day);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isValidDayOfMonth(int start, int end, Builder dateBuilder) {
+
+        int tokenLength = end - start;
+
+        if (tokenLength == 1) {
+            char c0 = string.charAt(start);
+            return isValid1DigitDayOfMonth(c0, dateBuilder);
+
+        } else if (tokenLength == 2) {
+            char c0 = string.charAt(start);
+            char c1 = string.charAt(start + 1);
+            return isValid2DigitsDayOfMonth(c0, c1, dateBuilder);
+        }
+        return false;
+    }
+
+    private boolean isValidJanuaryJuneJuly(char c0, char c1, char c2, Builder dateBuilder) {
+        if (c0 == 'J' || c0 == 'j')
+            if (c1 == 'a' || c1 == 'A') {
+                if (c2 == 'n' || c2 == 'N') {
+                    dateBuilder.setJanuary();
+                    return true;
+                }
+            } else if (c1 == 'u' || c1 == 'U') {
+                if (c2 == 'n' || c2 == 'N') {
+                    dateBuilder.setJune();
+                    return true;
+                } else if (c2 == 'l' || c2 == 'L') {
+                    dateBuilder.setJuly();
+                    return true;
+                }
+            }
+        return false;
+    }
+
+    private boolean isValidFebruary(char c0, char c1, char c2, Builder dateBuilder) {
+        if ((c0 == 'F' || c0 == 'f') && (c1 == 'e' || c1 == 'E') && (c2 == 'b' || c2 == 'B')) {
+            dateBuilder.setFebruary();
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValidMarchMay(char c0, char c1, char c2, Builder dateBuilder) {
+        if ((c0 == 'M' || c0 == 'm') && (c1 == 'a' || c1 == 'A')) {
+            if (c2 == 'r' || c2 == 'R') {
+                dateBuilder.setMarch();
+                return true;
+            } else if (c2 == 'y' || c2 == 'M') {
+                dateBuilder.setMay();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isValidAprilAugust(char c0, char c1, char c2, Builder dateBuilder) {
+        if (c0 == 'A' || c0 == 'a')
+            if ((c1 == 'p' || c1 == 'P') && (c2 == 'r' || c2 == 'R')) {
+                dateBuilder.setApril();
+                return true;
+            } else if ((c1 == 'u' || c1 == 'U') && (c2 == 'g' || c2 == 'G')) {
+                dateBuilder.setAugust();
+                return true;
+            }
+        return false;
+    }
+
+    private boolean isValidSeptember(char c0, char c1, char c2, Builder dateBuilder) {
+        if ((c0 == 'S' || c0 == 's') && (c1 == 'e' || c1 == 'E') && (c2 == 'p' || c2 == 'P')) {
+            dateBuilder.setSeptember();
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValidOctober(char c0, char c1, char c2, Builder dateBuilder) {
+        if ((c0 == 'O' || c0 == 'o') && (c1 == 'c' || c1 == 'C') && (c2 == 't' || c2 == 'T')) {
+            dateBuilder.setOctobre();
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValidNovember(char c0, char c1, char c2, Builder dateBuilder) {
+        if ((c0 == 'N' || c0 == 'n') && (c1 == 'o' || c1 == 'O') && (c2 == 'v' || c2 == 'V')) {
+            dateBuilder.setNovembre();
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValidDecember(char c0, char c1, char c2, Builder dateBuilder) {
+        if (c0 == 'D' || c0 == 'd')
+            if (c1 == 'e' || c1 == 'E') {
+                if (c2 == 'c' || c2 == 'C') {
+                    dateBuilder.setDecember();
+                    return true;
+                }
+            }
+        return false;
+    }
+
+    private boolean isValidMonth(int start, int end, Builder dateBuilder) {
+
+        if (end - start != 3)
+            return false;
+
+        char c0 = string.charAt(start);
+        char c1 = string.charAt(start + 1);
+        char c2 = string.charAt(start + 2);
+
+        return isValidJanuaryJuneJuly(c0, c1, c2, dateBuilder) || //
+                isValidFebruary(c0, c1, c2, dateBuilder) || //
+                isValidMarchMay(c0, c1, c2, dateBuilder) || //
+                isValidAprilAugust(c0, c1, c2, dateBuilder) || //
+                isValidSeptember(c0, c1, c2, dateBuilder) || //
+                isValidOctober(c0, c1, c2, dateBuilder) || //
+                isValidNovember(c0, c1, c2, dateBuilder) || //
+                isValidDecember(c0, c1, c2, dateBuilder);
+    }
+
+    private boolean isValid2DigitsYear(char c0, char c1, Builder dateBuilder) {
+        if (isDigit(c0) && isDigit(c1)) {
+            int i0 = getNumericValue(c0);
+            int i1 = getNumericValue(c1);
+            int year = i0 * 10 + i1;
+            year = year < 70 ? year + 2000 : year + 1900;
+
+            return setValidYear(year, dateBuilder);
+        }
+        return false;
+    }
+
+    private boolean isValid4DigitsYear(char c0, char c1, char c2, char c3, Builder dateBuilder) {
+        if (isDigit(c0) && isDigit(c1) && isDigit(c2) && isDigit(c3)) {
+            int i0 = getNumericValue(c0);
+            int i1 = getNumericValue(c1);
+            int i2 = getNumericValue(c2);
+            int i3 = getNumericValue(c3);
+            int year = i0 * 1000 + i1 * 100 + i2 * 10 + i3;
+
+            return setValidYear(year, dateBuilder);
+        }
+        return false;
+    }
+
+    private boolean setValidYear(int year, Builder dateBuilder) {
+        if (year >= 1601) {
+            dateBuilder.setYear(year);
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValidYear(int start, int end, Builder dateBuilder) {
+
+        int length = end - start;
+
+        if (length == 2) {
+            char c0 = string.charAt(start);
+            char c1 = string.charAt(start + 1);
+            return isValid2DigitsYear(c0, c1, dateBuilder);
+
+        } else if (length == 4) {
+            char c0 = string.charAt(start);
+            char c1 = string.charAt(start + 1);
+            char c2 = string.charAt(start + 2);
+            char c3 = string.charAt(start + 3);
+            return isValid4DigitsYear(c0, c1, c2, c3, dateBuilder);
+        }
+
+        return false;
+    }
+
+    private boolean isValid1DigitHour(char c0, Builder dateBuilder) {
+        if (isDigit(c0)) {
+            int hour = getNumericValue(c0);
+            dateBuilder.setHour(hour);
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValid2DigitsHour(char c0, char c1, Builder dateBuilder) {
+        if (isDigit(c0) && isDigit(c1)) {
+            int i0 = getNumericValue(c0);
+            int i1 = getNumericValue(c1);
+            int hour = i0 * 10 + i1;
+            if (hour <= 24) {
+                dateBuilder.setHour(hour);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isValidHour(int start, int end, Builder dateBuilder) {
+
+        int length = end - start;
+
+        if (length == 1) {
+            char c0 = string.charAt(start);
+            return isValid1DigitHour(c0, dateBuilder);
+
+        } else if (length == 2) {
+            char c0 = string.charAt(start);
+            char c1 = string.charAt(start + 1);
+            return isValid2DigitsHour(c0, c1, dateBuilder);
+        }
+        return false;
+    }
+
+    private boolean isValid1DigitMinuteSecond(char c0, Builder dateBuilder, boolean minuteOrSecond) {
+        if (isDigit(c0)) {
+            int value = getNumericValue(c0);
+            if (minuteOrSecond)
+                dateBuilder.setMinute(value);
+            else
+                dateBuilder.setSecond(value);
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isValid2DigitsMinuteSecond(char c0, char c1, Builder dateBuilder, boolean minuteOrSecond) {
+        if (isDigit(c0) && isDigit(c1)) {
+            int i0 = getNumericValue(c0);
+            int i1 = getNumericValue(c1);
+            int value = i0 * 10 + i1;
+            if (value <= 60) {
+                if (minuteOrSecond)
+                    dateBuilder.setMinute(value);
+                else
+                    dateBuilder.setSecond(value);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isValidMinuteSecond(int start, int end, Builder dateBuilder, boolean minuteOrSecond) {
+
+        int length = end - start;
+
+        if (length == 1) {
+            char c0 = string.charAt(start);
+            return isValid1DigitMinuteSecond(c0, dateBuilder, minuteOrSecond);
+
+        } else if (length == 2) {
+            char c0 = string.charAt(start);
+            char c1 = string.charAt(start + 1);
+            return isValid2DigitsMinuteSecond(c0, c1, dateBuilder, minuteOrSecond);
+        }
+        return false;
+    }
+
+    private boolean isDigit(char c) {
+        return c >= '0' && c <= '9';
+    }
+
+    private int getNumericValue(char c) {
+        return (int) c - 48;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/date/TimeConverter.java b/api/src/main/java/org/asynchttpclient/date/TimeConverter.java
new file mode 100644
index 000000000..5b7cda67c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/date/TimeConverter.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.date;
+
+/**
+ * Converts a RFC2616Date to time in millis
+ * 
+ * @author slandelle
+ */
+public interface TimeConverter {
+
+    long toTime(RFC2616Date dateElements);
+}
diff --git a/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
index fcbce72bc..3ce952727 100644
--- a/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
+++ b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
@@ -1,7 +1,5 @@
 package org.asynchttpclient.extra;
 
-import java.util.concurrent.Semaphore;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
@@ -9,65 +7,73 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 public class AsyncHandlerWrapper<T> implements AsyncHandler<T> {
 
-	private final static Logger logger = LoggerFactory.getLogger(AsyncHandlerWrapper.class);
-	private final AsyncHandler<T> asyncHandler;
-	private final Semaphore available;
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHandlerWrapper.class);
+    private final AsyncHandler<T> asyncHandler;
+    private final Semaphore available;
+    private final AtomicBoolean complete = new AtomicBoolean(false);
+
+    public AsyncHandlerWrapper(AsyncHandler<T> asyncHandler, Semaphore available) {
+        this.asyncHandler = asyncHandler;
+        this.available = available;
+    }
 
-	public AsyncHandlerWrapper(AsyncHandler<T> asyncHandler, Semaphore available) {
-		this.asyncHandler = asyncHandler;
-		this.available = available;
-	}
+    private void complete() {
+        if (complete.compareAndSet(false, true))
+            available.release();
+        if (LOGGER.isDebugEnabled())
+            LOGGER.debug("Current Throttling Status after onThrowable {}", available.availablePermits());
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public void onThrowable(Throwable t) {
-		try {
-			asyncHandler.onThrowable(t);
-		} finally {
-			available.release();
-			if (logger.isDebugEnabled()) {
-				logger.debug("Current Throttling Status after onThrowable {}", available.availablePermits());
-			}
-		}
-	}
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onThrowable(Throwable t) {
+        try {
+            asyncHandler.onThrowable(t);
+        } finally {
+            complete();
+        }
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-		return asyncHandler.onBodyPartReceived(bodyPart);
-	}
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+        return asyncHandler.onBodyPartReceived(bodyPart);
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-		return asyncHandler.onStatusReceived(responseStatus);
-	}
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+        return asyncHandler.onStatusReceived(responseStatus);
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-		return asyncHandler.onHeadersReceived(headers);
-	}
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+        return asyncHandler.onHeadersReceived(headers);
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public T onCompleted() throws Exception {
-		available.release();
-		if (logger.isDebugEnabled()) {
-			logger.debug("Current Throttling Status {}", available.availablePermits());
-		}
-		return asyncHandler.onCompleted();
-	}
-}
\ No newline at end of file
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public T onCompleted() throws Exception {
+        try {
+            return asyncHandler.onCompleted();
+        } finally {
+            complete();
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
index 546b59a11..7b0dd64b9 100644
--- a/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
+++ b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
@@ -12,7 +12,8 @@
  */
 package org.asynchttpclient.extra;
 
-import org.asynchttpclient.resumable.ResumableListener;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 import org.asynchttpclient.resumable.ResumableListener;
 
 import java.io.IOException;
@@ -20,7 +21,7 @@
 import java.nio.ByteBuffer;
 
 /**
- * A {@link org.asynchttpclient.listener.TransferListener} which use a {@link RandomAccessFile} for storing the received bytes.
+ * A {@link org.asynchttpclient.resumable.ResumableListener} which use a {@link RandomAccessFile} for storing the received bytes.
  */
 public class ResumableRandomAccessFileListener implements ResumableListener {
     private final RandomAccessFile file;
@@ -53,13 +54,7 @@ public void onBytesReceived(ByteBuffer buffer) throws IOException {
      * {@inheritDoc}
      */
     public void onAllBytesReceived() {
-        if (file != null) {
-            try {
-                file.close();
-            } catch (IOException e) {
-                ;
-            }
-        }
+        closeSilently(file);
     }
 
     /**
@@ -69,9 +64,7 @@ public long length() {
         try {
             return file.length();
         } catch (IOException e) {
-            ;
+            return 0;
         }
-        return 0;
     }
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
index 2dcb6087e..7dd44d34a 100644
--- a/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
+++ b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
@@ -12,54 +12,56 @@
  */
 package org.asynchttpclient.extra;
 
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
 /**
  * A {@link org.asynchttpclient.filter.RequestFilter} throttles requests and block when the number of permits is reached, waiting for
  * the response to arrives before executing the next request.
  */
 public class ThrottleRequestFilter implements RequestFilter {
-	private final static Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
-	private final Semaphore available;
-	private final int maxWait;
+    private final static Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
+    private final Semaphore available;
+    private final int maxWait;
+
+    public ThrottleRequestFilter(int maxConnections) {
+        this(maxConnections, Integer.MAX_VALUE);
+    }
 
-	public ThrottleRequestFilter(int maxConnections) {
-		this(maxConnections, Integer.MAX_VALUE);
-	}
+    public ThrottleRequestFilter(int maxConnections, int maxWait) {
+      this(maxConnections, maxWait, false);
+    }
 
-	public ThrottleRequestFilter(int maxConnections, int maxWait) {
-		this.maxWait = maxWait;
-		available = new Semaphore(maxConnections, true);
-	}
+    public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
+      this.maxWait = maxWait;
+      available = new Semaphore(maxConnections, fair);
+    }
 
-	/**
-	 * {@inheritDoc}
-	 */
-	/* @Override */
-	public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
 
-		try {
-			if (logger.isDebugEnabled()) {
-				logger.debug("Current Throttling Status {}", available.availablePermits());
-			}
-			if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
-				throw new FilterException(String.format(
-						"No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
-						ctx.getAsyncHandler()));
-			}
-		} catch (InterruptedException e) {
-			throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(),
-					ctx.getAsyncHandler()));
-		}
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Current Throttling Status {}", available.availablePermits());
+            }
+            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
+                throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
+                        ctx.getRequest(), ctx.getAsyncHandler()));
+            }
+        } catch (InterruptedException e) {
+            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
+        }
 
-		return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(
-				new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available)).build();
-	}
+        return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+                .build();
+    }
 }
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/filter/FilterContext.java b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
index 5a5dc1400..dfc6f9de2 100644
--- a/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
+++ b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -23,7 +23,7 @@
  * A {@link FilterContext} can be used to decorate {@link Request} and {@link AsyncHandler} from a list of {@link RequestFilter}.
  * {@link RequestFilter} gets executed before the HTTP request is made to the remote server. Once the response bytes are
  * received, a {@link FilterContext} is then passed to the list of {@link ResponseFilter}. {@link ResponseFilter}
- * gets invoked before the response gets processed, e.g. before authorization, redirection and invokation of {@link AsyncHandler}
+ * gets invoked before the response gets processed, e.g. before authorization, redirection and invocation of {@link AsyncHandler}
  * gets processed.
  * <p/>
  * Invoking {@link FilterContext#getResponseStatus()} returns an instance of {@link HttpResponseStatus}
diff --git a/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java b/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
index 947314627..99b3ee2ee 100644
--- a/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
@@ -25,5 +25,5 @@
      * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
      * @throws FilterException to interrupt the filter processing.
      */
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java b/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
index 520db598c..9116ed0c1 100644
--- a/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
@@ -26,5 +26,5 @@
      * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
      * @throws FilterException to interrupt the filter processing.
      */
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java b/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
index 8c26bcca9..a49a71f94 100644
--- a/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
@@ -15,7 +15,7 @@
 /**
  * A Filter interface that gets invoked before making the processing of the response bytes. {@link ResponseFilter} are invoked
  * before the actual response's status code get processed. That means authorization, proxy authentication and redirects
- * processing hasn't occured when {@link ResponseFilter} gets invoked.
+ * processing hasn't occurred when {@link ResponseFilter} gets invoked.
  */
 public interface ResponseFilter {
 
@@ -29,5 +29,5 @@
      * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
      * @throws FilterException to interrupt the filter processing.
      */
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
index 0ff4a346e..f1e0a9775 100644
--- a/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
@@ -64,7 +64,7 @@ public void close() throws IOException {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Body createBody() throws IOException {
         return new ByteBody();
     }
diff --git a/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
index dd6e88dbf..dd97ec217 100644
--- a/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
@@ -25,63 +25,60 @@
 /**
  * Creates a request body from the contents of a file.
  */
-public class FileBodyGenerator
-        implements BodyGenerator {
+//Not used by Netty
+public class FileBodyGenerator implements BodyGenerator {
 
     private final File file;
     private final long regionSeek;
     private final long regionLength;
 
     public FileBodyGenerator(File file) {
-        if (file == null) {
-            throw new IllegalArgumentException("no file specified");
-        }
-        this.file = file;
-        this.regionLength = file.length();
-        this.regionSeek = 0;
+        this(file, 0L, file.length());
     }
 
     public FileBodyGenerator(File file, long regionSeek, long regionLength) {
         if (file == null) {
-            throw new IllegalArgumentException("no file specified");
+            throw new NullPointerException("file");
         }
         this.file = file;
         this.regionLength = regionLength;
         this.regionSeek = regionSeek;
     }
 
+    public File getFile() {
+        return file;
+    }
+
+    public long getRegionLength() {
+        return regionLength;
+    }
+
+    public long getRegionSeek() {
+        return regionSeek;
+    }
+
     /**
      * {@inheritDoc}
      */
-    /* @Override */
-    public RandomAccessBody createBody()
-            throws IOException {
+    @Override
+    public RandomAccessBody createBody() throws IOException {
         return new FileBody(file, regionSeek, regionLength);
     }
 
-    protected static class FileBody
-            implements RandomAccessBody {
+    private static class FileBody implements RandomAccessBody {
 
-        private final RandomAccessFile file;
+        private final RandomAccessFile raf;
 
         private final FileChannel channel;
 
         private final long length;
 
-        public FileBody(File file)
-                throws IOException {
-            this.file = new RandomAccessFile(file, "r");
-            channel = this.file.getChannel();
-            length = file.length();
-        }
-
-        public FileBody(File file, long regionSeek, long regionLength)
-                throws IOException {
-            this.file = new RandomAccessFile(file, "r");
-            channel = this.file.getChannel();
+        private FileBody(File file, long regionSeek, long regionLength) throws IOException {
+            raf = new RandomAccessFile(file, "r");
+            channel = raf.getChannel();
             length = regionLength;
             if (regionSeek > 0) {
-                this.file.seek(regionSeek);
+                raf.seek(regionSeek);
             }
         }
 
@@ -89,24 +86,16 @@ public long getContentLength() {
             return length;
         }
 
-        public long read(ByteBuffer buffer)
-                throws IOException {
+        public long read(ByteBuffer buffer) throws IOException {
             return channel.read(buffer);
         }
 
-        public long transferTo(long position, long count, WritableByteChannel target)
-                throws IOException {
-            if (count > length) {
-                count = length;
-            }
-            return channel.transferTo(position, count, target);
+        public long transferTo(long position, WritableByteChannel target) throws IOException {
+            return channel.transferTo(position, length, target);
         }
 
-        public void close()
-                throws IOException {
-            file.close();
+        public void close() throws IOException {
+            raf.close();
         }
-
     }
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
index 797b93af3..34be273b9 100644
--- a/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
@@ -23,45 +23,49 @@
 import java.nio.ByteBuffer;
 
 /**
- * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire
- * stream in memory.
+ * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
  * <p/>
- * NOTE: The {@link InputStream} must support the {@link InputStream#mark} and {@link java.io.InputStream#reset()} operation.
- * If not, mechanisms like authentication, redirect, or resumable download will not works.
+ * NOTE: The {@link InputStream} must support the {@link InputStream#mark} and {@link java.io.InputStream#reset()} operation. If not, mechanisms like authentication, redirect, or
+ * resumable download will not works.
  */
 public class InputStreamBodyGenerator implements BodyGenerator {
 
-    private final static byte[] END_PADDING = "\r\n".getBytes();
-    private final static byte[] ZERO = "0".getBytes();
     private final InputStream inputStream;
-    private final static Logger logger = LoggerFactory.getLogger(InputStreamBodyGenerator.class);
-    private boolean patchNettyChunkingIssue = false;
 
     public InputStreamBodyGenerator(InputStream inputStream) {
         this.inputStream = inputStream;
+    }
 
-        if (inputStream.markSupported()) {
-            inputStream.mark(0);
-        } else {
-            logger.info("inputStream.markSupported() not supported. Some features will not works");
-        }
+    public InputStream getInputStream() {
+        return inputStream;
     }
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Body createBody() throws IOException {
-        return new ISBody();
+        return new InputStreamBody(inputStream);
     }
 
-    protected class ISBody implements Body {
-        private boolean eof = false;
-        private int endDataCount = 0;
+    private static class InputStreamBody implements Body {
+
+        private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
+
+        private final InputStream inputStream;
         private byte[] chunk;
 
+        private InputStreamBody(InputStream inputStream) {
+            this.inputStream = inputStream;
+            if (inputStream.markSupported()) {
+                inputStream.mark(0);
+            } else {
+                LOGGER.info("inputStream.markSupported() not supported. Some features will not work.");
+            }
+        }
+
         public long getContentLength() {
-            return -1;
+            return -1L;
         }
 
         public long read(ByteBuffer buffer) throws IOException {
@@ -69,54 +73,18 @@ public long read(ByteBuffer buffer) throws IOException {
             // To be safe.
             chunk = new byte[buffer.remaining() - 10];
 
-
             int read = -1;
             try {
                 read = inputStream.read(chunk);
             } catch (IOException ex) {
-                logger.warn("Unable to read", ex);
+                LOGGER.warn("Unable to read", ex);
             }
 
-            if (patchNettyChunkingIssue) {
-                if (read == -1) {
-                    // Since we are chuncked, we must output extra bytes before considering the input stream closed.
-                    // chunking requires to end the chunking:
-                    // - A Terminating chunk of  "0\r\n".getBytes(),
-                    // - Then a separate packet of "\r\n".getBytes()
-                    if (!eof) {
-                        endDataCount++;
-                        if (endDataCount == 2)
-                            eof = true;
-
-                        if (endDataCount == 1)
-                            buffer.put(ZERO);
-
-                        buffer.put(END_PADDING);
-
-
-                        return buffer.position();
-                    } else {
-                        if (inputStream.markSupported()) {
-                            inputStream.reset();
-                        }
-                        eof = false;
-                    }
-                    return -1;
-                }
-
-                /**
-                 * Netty 3.2.3 doesn't support chunking encoding properly, so we chunk encoding ourself.
-                 */
-
-                buffer.put(Integer.toHexString(read).getBytes());
-                // Chunking is separated by "<bytesreads>\r\n"
-                buffer.put(END_PADDING);
+            if (read > 0) {
                 buffer.put(chunk, 0, read);
-                // Was missing the final chunk \r\n.
-                buffer.put(END_PADDING);
             } else {
-                if (read > 0) {
-                    buffer.put(chunk, 0, read);
+                if (inputStream.markSupported()) {
+                    inputStream.reset();
                 }
             }
             return read;
@@ -126,13 +94,4 @@ public void close() throws IOException {
             inputStream.close();
         }
     }
-
-    /**
-     * HACK: This is required because Netty has issues with chunking.
-     *
-     * @param patchNettyChunkingIssue
-     */
-    public void patchNettyChunkingIssue(boolean patchNettyChunkingIssue) {
-        this.patchNettyChunkingIssue = patchNettyChunkingIssue;
-    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java b/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
index 031775284..be0d81842 100644
--- a/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
@@ -61,9 +61,9 @@
     }
 
     /*
-    * Override the done method to execute the execution list.
+    * Execute the execution list.
     */
-    protected void done() {
+    protected void runListeners() {
         executionList.run();
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java b/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
index a6e3cba83..99347e792 100644
--- a/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
+++ b/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
@@ -48,8 +48,7 @@
 public final class ExecutionList implements Runnable {
 
     // Logger to log exceptions caught when running runnables.
-    private static final Logger log =
-            Logger.getLogger(ExecutionList.class.getName());
+    private static final Logger log = Logger.getLogger(ExecutionList.class.getName());
 
     // The runnable,executor pairs to execute.
     private final Queue<RunnableExecutorPair> runnables = new LinkedBlockingQueue<RunnableExecutorPair>();
@@ -130,8 +129,7 @@ void execute() {
                 // Log it and keep going, bad runnable and/or executor.  Don't
                 // punish the other runnables if we're given a bad one.  We only
                 // catch RuntimeException because we want Errors to propagate up.
-                log.log(Level.SEVERE, "RuntimeException while executing runnable "
-                        + runnable + " with executor " + executor, e);
+                log.log(Level.SEVERE, "RuntimeException while executing runnable " + runnable + " with executor " + executor, e);
             }
         }
     }
diff --git a/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java b/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
index 59703c258..b39930dff 100644
--- a/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
@@ -12,8 +12,6 @@
  */
 package org.asynchttpclient.listener;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -22,16 +20,14 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * A {@link org.asynchttpclient.AsyncHandler} that can be used to notify a set of {@link TransferListener}
  * <p/>
- * <blockquote><pre>
+ * <blockquote>
+ * 
+ * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * TransferCompletionHandler tl = new TransferCompletionHandler();
  * tl.addTransferListener(new TransferListener() {
@@ -45,7 +41,7 @@
  * public void onBytesReceived(ByteBuffer buffer) {
  * }
  * <p/>
- * public void onBytesSent(ByteBuffer buffer) {
+ * public void onBytesSent(long amount, long current, long total) {
  * }
  * <p/>
  * public void onRequestResponseCompleted() {
@@ -56,30 +52,30 @@
  * });
  * <p/>
  * Response response = httpClient.prepareGet("http://...").execute(tl).get();
- * </pre></blockquote>
+ * </pre>
+ * 
+ * </blockquote>
  */
 public class TransferCompletionHandler extends AsyncCompletionHandlerBase {
     private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
     private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<TransferListener>();
     private final boolean accumulateResponseBytes;
-    private TransferAdapter transferAdapter;
-    private AtomicLong bytesTransferred = new AtomicLong();
-    private AtomicLong totalBytesToTransfer = new AtomicLong(0);
+    private FluentCaseInsensitiveStringsMap headers;
 
     /**
      * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
-     * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} and {@link Response#getResponseBodyExcerpt(int)} will
-     * throw an IllegalStateException if called.
+     * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} and {@link Response#getResponseBodyExcerpt(int)} will throw an IllegalStateException if called.
      */
     public TransferCompletionHandler() {
         this(false);
     }
 
     /**
-     * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when
-     * {@link org.asynchttpclient.Response#getResponseBody()} get called. The default is false.
-     *
-     * @param accumulateResponseBytes true to accumulates bytes in memory.
+     * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when {@link org.asynchttpclient.Response#getResponseBody()} get called. The
+     * default is false.
+     * 
+     * @param accumulateResponseBytes
+     *            true to accumulates bytes in memory.
      */
     public TransferCompletionHandler(boolean accumulateResponseBytes) {
         this.accumulateResponseBytes = accumulateResponseBytes;
@@ -87,8 +83,9 @@ public TransferCompletionHandler(boolean accumulateResponseBytes) {
 
     /**
      * Add a {@link TransferListener}
-     *
-     * @param t a {@link TransferListener}
+     * 
+     * @param t
+     *            a {@link TransferListener}
      * @return this
      */
     public TransferCompletionHandler addTransferListener(TransferListener t) {
@@ -98,8 +95,9 @@ public TransferCompletionHandler addTransferListener(TransferListener t) {
 
     /**
      * Remove a {@link TransferListener}
-     *
-     * @param t a {@link TransferListener}
+     * 
+     * @param t
+     *            a {@link TransferListener}
      * @return this
      */
     public TransferCompletionHandler removeTransferListener(TransferListener t) {
@@ -108,18 +106,16 @@ public TransferCompletionHandler removeTransferListener(TransferListener t) {
     }
 
     /**
-     * Associate a {@link TransferCompletionHandler.TransferAdapter} with this listener.
-     *
-     * @param transferAdapter {@link TransferAdapter}
+     * Set headers to this listener.
+     * 
+     * @param headers
+     *            {@link FluentCaseInsensitiveStringsMap}
      */
-    public void transferAdapter(TransferAdapter transferAdapter) {
-        this.transferAdapter = transferAdapter;
+    public void headers(FluentCaseInsensitiveStringsMap headers) {
+        this.headers = headers;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
+    @Override
     public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
         fireOnHeaderReceived(headers.getHeaders());
         return super.onHeadersReceived(headers);
@@ -141,50 +137,20 @@ public Response onCompleted(Response response) throws Exception {
         return response;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public STATE onHeaderWriteCompleted() {
-        List<String> list = transferAdapter.getHeaders().get("Content-Length");
-        if (isNonEmpty(list) && list.get(0).length() != 0) {
-            totalBytesToTransfer.set(Long.valueOf(list.get(0)));
+        if (headers != null) {
+            fireOnHeadersSent(headers);
         }
-
-        fireOnHeadersSent(transferAdapter.getHeaders());
-        return STATE.CONTINUE;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public STATE onContentWriteCompleted() {
         return STATE.CONTINUE;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public STATE onContentWriteProgress(long amount, long current, long total) {
-        if (bytesTransferred.get() == -1) {
-            return STATE.CONTINUE;
-        }
-
-        if (totalBytesToTransfer.get() == 0) {
-            totalBytesToTransfer.set(total);
-        }
-
-        // We need to track the count because all is asynchronous and Netty may not invoke us on time.
-        bytesTransferred.addAndGet(amount);
-
-        if (transferAdapter != null) {
-            byte[] bytes = new byte[(int) (amount)];
-            transferAdapter.getBytes(bytes);
-            fireOnBytesSent(bytes);
-        }
+        fireOnBytesSent(amount, current, total);
         return STATE.CONTINUE;
     }
 
-
     @Override
     public void onThrowable(Throwable t) {
         fireOnThrowable(t);
@@ -211,32 +177,6 @@ private void fireOnHeaderReceived(FluentCaseInsensitiveStringsMap headers) {
     }
 
     private void fireOnEnd() {
-        // There is a probability that the asynchronous listener never gets called, so we fake it at the end once
-        // we are 100% sure the response has been received.
-        long count = bytesTransferred.getAndSet(-1);
-        if (count != totalBytesToTransfer.get()) {
-            if (transferAdapter != null) {
-                byte[] bytes = new byte[8192];
-                int leftBytes = (int) (totalBytesToTransfer.get() - count);
-                int length = 8192;
-                while (leftBytes > 0) {
-                    if (leftBytes > 8192) {
-                        leftBytes -= 8192;
-                    } else {
-                        length = leftBytes;
-                        leftBytes = 0;
-                    }
-
-                    if (length < 8192) {
-                        bytes = new byte[length];
-                    }
-
-                    transferAdapter.getBytes(bytes);
-                    fireOnBytesSent(bytes);
-                }
-            }
-        }
-
         for (TransferListener l : listeners) {
             try {
                 l.onRequestResponseCompleted();
@@ -249,17 +189,17 @@ private void fireOnEnd() {
     private void fireOnBytesReceived(byte[] b) {
         for (TransferListener l : listeners) {
             try {
-                l.onBytesReceived(ByteBuffer.wrap(b));
+                l.onBytesReceived(b);
             } catch (Throwable t) {
                 l.onThrowable(t);
             }
         }
     }
 
-    private void fireOnBytesSent(byte[] b) {
+    private void fireOnBytesSent(long amount, long current, long total) {
         for (TransferListener l : listeners) {
             try {
-                l.onBytesSent(ByteBuffer.wrap(b));
+                l.onBytesSent(amount, current, total);
             } catch (Throwable t) {
                 l.onThrowable(t);
             }
@@ -275,18 +215,4 @@ private void fireOnThrowable(Throwable t) {
             }
         }
     }
-
-    public abstract static class TransferAdapter {
-        private final FluentCaseInsensitiveStringsMap headers;
-
-        public TransferAdapter(FluentCaseInsensitiveStringsMap headers) throws IOException {
-            this.headers = headers;
-        }
-
-        public FluentCaseInsensitiveStringsMap getHeaders() {
-            return headers;
-        }
-
-        public abstract void getBytes(byte[] bytes);
-    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/listener/TransferListener.java b/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
index 7ae234446..1043b3c56 100644
--- a/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
@@ -15,7 +15,6 @@
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 
 import java.io.IOException;
-import java.nio.ByteBuffer;
 
 /**
  * A simple interface an application can implements in order to received byte transfer information.
@@ -25,36 +24,39 @@
     /**
      * Invoked when the request bytes are starting to get send.
      */
-    public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers);
+    void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers);
 
     /**
      * Invoked when the response bytes are starting to get received.
      */
-    public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers);
+    void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers);
 
     /**
      * Invoked every time response's chunk are received.
      *
-     * @param buffer a {@link ByteBuffer}
+     * @param bytes a {@link byte[]}
      */
-    public void onBytesReceived(ByteBuffer buffer) throws IOException;
+    void onBytesReceived(byte[] bytes) throws IOException;
 
     /**
      * Invoked every time request's chunk are sent.
      *
-     * @param buffer a {@link ByteBuffer}
+     * @param amount  The amount of bytes to transfer
+     * @param current The amount of bytes transferred
+     * @param total   The total number of bytes transferred
      */
-    public void onBytesSent(ByteBuffer buffer);
+    void onBytesSent(long amount, long current, long total);
 
     /**
      * Invoked when the response bytes are been fully received.
      */
-    public void onRequestResponseCompleted();
+    void onRequestResponseCompleted();
 
     /**
      * Invoked when there is an unexpected issue.
      *
      * @param t a {@link Throwable}
      */
-    public void onThrowable(Throwable t);
+    void onThrowable(Throwable t);
 }
+
diff --git a/api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java b/api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java
new file mode 100644
index 000000000..c3a253360
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.multipart;
+
+import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.charset.Charset;
+
+/**
+ * This class is an adaptation of the Apache HttpClient implementation
+ * 
+ * @link http://hc.apache.org/httpclient-3.x/
+ */
+public abstract class AbstractFilePart extends PartBase {
+
+    /**
+     * Default content encoding of file attachments.
+     */
+    public static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
+
+    /**
+     * Default transfer encoding of file attachments.
+     */
+    public static final String DEFAULT_TRANSFER_ENCODING = "binary";
+
+    /**
+     * Attachment's file name as a byte array
+     */
+    private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
+
+    private long stalledTime = -1L;
+
+    private String fileName;
+
+    /**
+     * FilePart Constructor.
+     * 
+     * @param name
+     *            the name for this part
+     * @param partSource
+     *            the source for this part
+     * @param contentType
+     *            the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
+     * @param charset
+     *            the charset encoding for this part
+     */
+    public AbstractFilePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
+        super(name,//
+                contentType == null ? DEFAULT_CONTENT_TYPE : contentType,//
+                charset,//
+                contentId,//
+                transfertEncoding == null ? DEFAULT_TRANSFER_ENCODING : transfertEncoding);
+    }
+
+    protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
+        super.visitDispositionHeader(visitor);
+        if (fileName != null) {
+            visitor.withBytes(FILE_NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(fileName.getBytes(US_ASCII));
+            visitor.withByte(QUOTE_BYTE);
+        }
+    }
+
+    protected byte[] generateFileStart(byte[] boundary) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
+        visitStart(visitor, boundary);
+        visitDispositionHeader(visitor);
+        visitContentTypeHeader(visitor);
+        visitTransferEncodingHeader(visitor);
+        visitContentIdHeader(visitor);
+        visitEndOfHeader(visitor);
+
+        return out.toByteArray();
+    }
+
+    protected byte[] generateFileEnd() throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
+        visitEnd(visitor);
+        return out.toByteArray();
+    }
+
+    public void setStalledTime(long ms) {
+        stalledTime = ms;
+    }
+
+    public long getStalledTime() {
+        return stalledTime;
+    }
+
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+
+    public String getFileName() {
+        return fileName;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder()//
+                .append(super.toString())//
+                .append(" filename=").append(fileName)//
+                .toString();
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java b/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java
new file mode 100644
index 000000000..f3dc0f11c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.multipart;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+
+public class ByteArrayPart extends AbstractFilePart {
+
+    private final byte[] bytes;
+
+    public ByteArrayPart(String name, byte[] bytes) {
+        this(name, bytes, null);
+    }
+
+    public ByteArrayPart(String name, byte[] bytes, String contentType) {
+        this(name, bytes, contentType, null);
+    }
+
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset) {
+        this(name, bytes, contentType, charset, null);
+    }
+
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName) {
+        this(name, bytes, contentType, charset, fileName, null);
+    }
+
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId) {
+        this(name, bytes, contentType, charset, fileName, contentId, null);
+    }
+
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+        super(name, contentType, charset, contentId, transferEncoding);
+        if (bytes == null)
+            throw new NullPointerException("bytes");
+        this.bytes = bytes;
+        setFileName(fileName);
+    }
+    
+    @Override
+    protected void sendData(OutputStream out) throws IOException {
+        out.write(bytes);
+    }
+
+    @Override
+    protected long getDataLength() {
+        return bytes.length;
+    }
+
+    public byte[] getBytes() {
+        return bytes;
+    }
+
+    @Override
+    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
+        FilePartStallHandler handler = new FilePartStallHandler(getStalledTime(), this);
+
+        try {
+            handler.start();
+
+            long length = MultipartUtils.writeBytesToChannel(target, generateFileStart(boundary));
+            length += MultipartUtils.writeBytesToChannel(target, bytes);
+            length += MultipartUtils.writeBytesToChannel(target, generateFileEnd());
+
+            return length;
+        } finally {
+            handler.completed();
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java b/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java
deleted file mode 100644
index 62b218d3d..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- *
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public class ByteArrayPartSource implements PartSource {
-
-    /**
-     * Name of the source file.
-     */
-    private final String fileName;
-
-    /**
-     * Byte array of the source file.
-     */
-    private final byte[] bytes;
-
-    /**
-     * Constructor for ByteArrayPartSource.
-     *
-     * @param fileName the name of the file these bytes represent
-     * @param bytes    the content of this part
-     */
-    public ByteArrayPartSource(String fileName, byte[] bytes) {
-        this.fileName = fileName;
-        this.bytes = bytes;
-    }
-
-    /**
-     * @see PartSource#getLength()
-     */
-    public long getLength() {
-        return bytes.length;
-    }
-
-    /**
-     * @see PartSource#getFileName()
-     */
-    public String getFileName() {
-        return fileName;
-    }
-
-    /**
-     * @see PartSource#createInputStream()
-     */
-    public InputStream createInputStream() throws IOException {
-        return new ByteArrayInputStream(bytes);
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java b/api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java
new file mode 100644
index 000000000..dc7b82216
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.multipart;
+
+import java.io.IOException;
+
+public class CounterPartVisitor implements PartVisitor {
+
+    private long count = 0L;
+
+    @Override
+    public void withBytes(byte[] bytes) throws IOException {
+        count += bytes.length;
+    }
+
+    @Override
+    public void withByte(byte b) throws IOException {
+        count++;
+    }
+
+    public long getCount() {
+        return count;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FilePart.java b/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
index 6cbab86a5..359ec21f7 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
@@ -1,171 +1,71 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.multipart;
 
 import java.io.File;
-import java.io.FileNotFoundException;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
 
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public class FilePart extends PartBase {
-
-    /**
-     * Default content encoding of file attachments.
-     */
-    public static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
-
-    /**
-     * Default charset of file attachments.
-     */
-    public static final String DEFAULT_CHARSET = "ISO-8859-1";
-
-    /**
-     * Default transfer encoding of file attachments.
-     */
-    public static final String DEFAULT_TRANSFER_ENCODING = "binary";
-
-    /**
-     * Attachment's file name
-     */
-    protected static final String FILE_NAME = "; filename=";
-
-    /**
-     * Attachment's file name as a byte array
-     */
-    private static final byte[] FILE_NAME_BYTES = MultipartEncodingUtil.getAsciiBytes(FILE_NAME);
-
-    /**
-     * Source of the file part.
-     */
-    private final PartSource source;
-
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name for this part
-     * @param partSource the source for this part
-     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
-     * @param contentId
-     */
-    public FilePart(String name, PartSource partSource, String contentType, String charset, String contentId) {
-
-        super(name, contentType == null ? DEFAULT_CONTENT_TYPE : contentType, charset == null ? "ISO-8859-1" : charset, DEFAULT_TRANSFER_ENCODING, contentId);
-
-        if (partSource == null) {
-            throw new IllegalArgumentException("Source may not be null");
-        }
-        this.source = partSource;
-    }
-    
-    public FilePart(String name, PartSource partSource, String contentType, String charset) {
-        this(name, partSource, contentType, charset, null);
-    }
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name for this part
-     * @param partSource the source for this part
-     */
-    public FilePart(String name, PartSource partSource) {
-        this(name, partSource, null, null);
-    }
+public class FilePart extends AbstractFilePart {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(FilePart.class);
+
+    private final File file;
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name of the file part
-     * @param file the file to post
-     * @throws java.io.FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
-     */
-    public FilePart(String name, File file) throws FileNotFoundException {
-        this(name, new FilePartSource(file), null, null);
+    public FilePart(String name, File file) {
+        this(name, file, null);
     }
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name of the file part
-     * @param file the file to post
-     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
-     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
-     */
-    public FilePart(String name, File file, String contentType, String charset) throws FileNotFoundException {
-        this(name, new FilePartSource(file), contentType, charset);
+    public FilePart(String name, File file, String contentType) {
+        this(name, file, contentType, null);
     }
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name of the file part
-     * @param fileName the file name
-     * @param file the file to post
-     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
-     */
-    public FilePart(String name, String fileName, File file) throws FileNotFoundException {
-        this(name, new FilePartSource(fileName, file), null, null);
+    public FilePart(String name, File file, String contentType, Charset charset) {
+        this(name, file, contentType, charset, null);
     }
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name of the file part
-     * @param fileName the file name
-     * @param file the file to post
-     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
-     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
-     */
-    public FilePart(String name, String fileName, File file, String contentType, String charset) throws FileNotFoundException {
-        this(name, new FilePartSource(fileName, file), contentType, charset);
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName) {
+        this(name, file, contentType, charset, fileName, null);
     }
 
-    /**
-     * Write the disposition header to the output stream
-     * 
-     * @param out The output stream
-     * @throws java.io.IOException If an IO problem occurs
-     */
-    protected void sendDispositionHeader(OutputStream out) throws IOException {
-        String filename = this.source.getFileName();
-        if (filename != null) {
-            super.sendDispositionHeader(out);
-            out.write(FILE_NAME_BYTES);
-            out.write(QUOTE_BYTES);
-            out.write(MultipartEncodingUtil.getAsciiBytes(filename));
-            out.write(QUOTE_BYTES);
-        }
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId) {
+        this(name, file, contentType, charset, fileName, contentId, null);
     }
 
-    /**
-     * Write the data in "source" to the specified stream.
-     * 
-     * @param out The output stream.
-     * @throws IOException if an IO problem occurs.
-     */
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+        super(name, contentType, charset, contentId, transferEncoding);
+        if (file == null)
+            throw new NullPointerException("file");
+        if (!file.isFile())
+            throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
+        if (!file.canRead())
+            throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
+        this.file = file;
+        setFileName(fileName != null ? fileName : file.getName());
+    }
+    
+    @Override
     protected void sendData(OutputStream out) throws IOException {
-        if (lengthOfData() == 0) {
+        if (getDataLength() == 0) {
 
             // this file contains no data, so there is nothing to send.
             // we don't want to create a zero length buffer as this will
@@ -174,7 +74,7 @@ protected void sendData(OutputStream out) throws IOException {
         }
 
         byte[] tmp = new byte[4096];
-        InputStream instream = source.createInputStream();
+        InputStream instream = new FileInputStream(file);
         try {
             int len;
             while ((len = instream.read(tmp)) >= 0) {
@@ -186,33 +86,78 @@ protected void sendData(OutputStream out) throws IOException {
         }
     }
 
-    public void setStalledTime(long ms) {
-        _stalledTime = ms;
+    @Override
+    protected long getDataLength() {
+        return file.length();
     }
 
-    public long getStalledTime() {
-        return _stalledTime;
+    public File getFile() {
+        return file;
     }
 
-    /**
-     * Returns the source of the file part.
-     * 
-     * @return The source.
-     */
-    protected PartSource getSource() {
-        return this.source;
-    }
+    @Override
+    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
+        FilePartStallHandler handler = new FilePartStallHandler(getStalledTime(), this);
 
-    /**
-     * Return the length of the data.
-     * 
-     * @return The length.
-     * @throws IOException if an IO problem occurs
-     */
-    protected long lengthOfData() throws IOException {
-        return source.getLength();
-    }
+        handler.start();
+
+        int length = 0;
 
-    private long _stalledTime = -1;
+        length += MultipartUtils.writeBytesToChannel(target, generateFileStart(boundary));
 
+        RandomAccessFile raf = new RandomAccessFile(file, "r");
+        FileChannel fc = raf.getChannel();
+
+        long l = file.length();
+        int fileLength = 0;
+        long nWrite = 0;
+        // FIXME why sync?
+        try {
+            synchronized (fc) {
+                while (fileLength != l) {
+                    if (handler.isFailed()) {
+                        LOGGER.debug("Stalled error");
+                        throw new FileUploadStalledException();
+                    }
+                    try {
+                        nWrite = fc.transferTo(fileLength, l, target);
+
+                        if (nWrite == 0) {
+                            LOGGER.info("Waiting for writing...");
+                            try {
+                                fc.wait(50);
+                            } catch (InterruptedException e) {
+                                LOGGER.trace(e.getMessage(), e);
+                            }
+                        } else {
+                            handler.writeHappened();
+                        }
+                    } catch (IOException ex) {
+                        String message = ex.getMessage();
+
+                        // http://bugs.sun.com/view_bug.do?bug_id=5103988
+                        if (message != null && message.equalsIgnoreCase("Resource temporarily unavailable")) {
+                            try {
+                                fc.wait(1000);
+                            } catch (InterruptedException e) {
+                                LOGGER.trace(e.getMessage(), e);
+                            }
+                            LOGGER.warn("Experiencing NIO issue http://bugs.sun.com/view_bug.do?bug_id=5103988. Retrying");
+                            continue;
+                        } else {
+                            throw ex;
+                        }
+                    }
+                    fileLength += nWrite;
+                }
+            }
+        } finally {
+            handler.completed();
+            raf.close();
+        }
+
+        length += MultipartUtils.writeBytesToChannel(target, generateFileEnd());
+
+        return length;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java b/api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java
deleted file mode 100644
index 0e9a74991..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public class FilePartSource implements PartSource {
-
-    /**
-     * File part file.
-     */
-    private File file = null;
-
-    /**
-     * File part file name.
-     */
-    private String fileName = null;
-
-    /**
-     * Constructor for FilePartSource.
-     * 
-     * @param file the FilePart source File.
-     * @throws java.io.FileNotFoundException if the file does not exist or cannot be read
-     */
-    public FilePartSource(File file) throws FileNotFoundException {
-        this.file = file;
-        if (file != null) {
-            if (!file.isFile()) {
-                final String errorMessage = String.format("File is not a normal file (%s).", file.getAbsolutePath());
-                throw new FileNotFoundException(errorMessage);
-            }
-            if (!file.canRead()) {
-                final String errorMessage = String.format("File is not readable (%s).", file.getAbsolutePath());
-                throw new FileNotFoundException(errorMessage);
-            }
-            this.fileName = file.getName();
-        }
-    }
-
-    /**
-     * Constructor for FilePartSource.
-     * 
-     * @param fileName the file name of the FilePart
-     * @param file the source File for the FilePart
-     * @throws FileNotFoundException if the file does not exist or cannot be read
-     */
-    public FilePartSource(String fileName, File file) throws FileNotFoundException {
-        this(file);
-        this.fileName = fileName;
-    }
-
-    /**
-     * Return the length of the file
-     * 
-     * @return the length of the file.
-     * @see PartSource#getLength()
-     */
-    public long getLength() {
-        if (this.file != null) {
-            return this.file.length();
-        } else {
-            return 0;
-        }
-    }
-
-    /**
-     * Return the current filename
-     * 
-     * @return the filename.
-     * @see PartSource#getFileName()
-     */
-    public String getFileName() {
-        return fileName;
-    }
-
-    /**
-     * Return a new {@link java.io.FileInputStream} for the current filename.
-     * 
-     * @return the new input stream.
-     * @throws java.io.IOException If an IO problem occurs.
-     * @see PartSource#createInputStream()
-     */
-    public InputStream createInputStream() throws IOException {
-        if (this.file != null) {
-            return new FileInputStream(this.file);
-        } else {
-            return new ByteArrayInputStream(new byte[] {});
-        }
-    }
-
-    public File getFile() {
-        return file;
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java b/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
index d52db46af..ed8972302 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
@@ -19,43 +19,43 @@
  * @author Gail Hernandez
  */
 public class FilePartStallHandler extends TimerTask {
-	public FilePartStallHandler(long waitTime, FilePart filePart) {
-		_waitTime = waitTime;
-		_failed = false;
-		_written = false;
-	}
-	
-	public void completed() {
-		if(_waitTime > 0) {
-			_timer.cancel();
-		}
-	}
-
-	public boolean isFailed() {
-		return _failed;
-	}
-
-	public void run() {
-		if(!_written) {
-			_failed = true;
-			_timer.cancel();
-		}
-		_written = false;
-	}
-
-	public void start() {
-		if(_waitTime > 0) {
-			_timer = new Timer();
-			_timer.scheduleAtFixedRate(this, _waitTime, _waitTime);
-		}
-	}
-	
-	public void writeHappened() {
-		_written = true;
-	}
-
-	private long _waitTime;
-	private Timer _timer;
-	private boolean _failed;
-	private boolean _written;
+    public FilePartStallHandler(long waitTime, AbstractFilePart filePart) {
+        _waitTime = waitTime;
+        _failed = false;
+        _written = false;
+    }
+
+    public void completed() {
+        if (_waitTime > 0) {
+            _timer.cancel();
+        }
+    }
+
+    public boolean isFailed() {
+        return _failed;
+    }
+
+    public void run() {
+        if (!_written) {
+            _failed = true;
+            _timer.cancel();
+        }
+        _written = false;
+    }
+
+    public void start() {
+        if (_waitTime > 0) {
+            _timer = new Timer();
+            _timer.scheduleAtFixedRate(this, _waitTime, _waitTime);
+        }
+    }
+
+    public void writeHappened() {
+        _written = true;
+    }
+
+    private long _waitTime;
+    private Timer _timer;
+    private boolean _failed;
+    private boolean _written;
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
index 97a998f8b..1b732b939 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
@@ -13,59 +13,49 @@
 package org.asynchttpclient.multipart;
 
 import org.asynchttpclient.RandomAccessBody;
-
-import org.asynchttpclient.ByteArrayPart;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
-import java.nio.channels.*;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 
 public class MultipartBody implements RandomAccessBody {
 
-    private byte[] boundary;
-    private long contentLength;
-    private List<org.asynchttpclient.Part> parts;
-    private List<RandomAccessFile> files;
-    private int startPart;
-    private final static Logger logger = LoggerFactory.getLogger(MultipartBody.class);
-    ByteArrayInputStream currentStream;
-    int currentStreamPosition;
-    boolean endWritten;
-    boolean doneWritingParts;
-    FileLocation fileLocation;
-    FilePart currentFilePart;
-    FileChannel currentFileChannel;
-
-    enum FileLocation {NONE, START, MIDDLE, END}
-
-    public MultipartBody(List<org.asynchttpclient.Part> parts, String contentType, String contentLength) {
-        this.boundary = MultipartEncodingUtil.getAsciiBytes(contentType.substring(contentType.indexOf("boundary=") + "boundary=".length()));
-        this.contentLength = Long.parseLong(contentLength);
-        this.parts = parts;
+    private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
+
+    private final byte[] boundary;
+    private final long contentLength;
+    private final String contentType;
+    private final List<Part> parts;
+    private final List<RandomAccessFile> pendingOpenFiles = new ArrayList<RandomAccessFile>();
 
-        files = new ArrayList<RandomAccessFile>();
+    private boolean transfertDone = false;
+
+    private int currentPart = 0;
+    private byte[] currentBytes;
+    private int currentBytesPosition = -1;
+    private boolean doneWritingParts = false;
+    private FileLocation fileLocation = FileLocation.NONE;
+    private FileChannel currentFileChannel;
+
+    enum FileLocation {
+        NONE, START, MIDDLE, END
+    }
 
-        startPart = 0;
-        currentStreamPosition = -1;
-        endWritten = false;
-        doneWritingParts = false;
-        fileLocation = FileLocation.NONE;
-        currentFilePart = null;
+    public MultipartBody(List<Part> parts, String contentType, long contentLength, byte[] boundary) {
+        this.boundary = boundary;
+        this.contentLength = contentLength;
+        this.contentType = contentType;
+        this.parts = parts;
     }
 
     public void close() throws IOException {
-        for (RandomAccessFile file : files) {
+        for (RandomAccessFile file : pendingOpenFiles) {
             file.close();
         }
     }
@@ -74,98 +64,90 @@ public long getContentLength() {
         return contentLength;
     }
 
+    public String getContentType() {
+        return contentType;
+    }
+
+    // RandomAccessBody API, suited for HTTP but not for HTTPS
+    public long transferTo(long position, WritableByteChannel target) throws IOException {
+
+        long overallLength = 0;
+
+        if (transfertDone) {
+            return contentLength;
+        }
+
+        for (Part part : parts) {
+            overallLength += part.write(target, boundary);
+        }
+
+        overallLength += MultipartUtils.writeBytesToChannel(target, MultipartUtils.getMessageEnd(boundary));
+
+        transfertDone = true;
+
+        return overallLength;
+    }
+
+    // Regular Body API
     public long read(ByteBuffer buffer) throws IOException {
         try {
             int overallLength = 0;
 
-            int maxLength = buffer.capacity();
+            int maxLength = buffer.remaining();
 
-            if (startPart == parts.size() && endWritten) {
-                return overallLength;
+            if (currentPart == parts.size() && transfertDone) {
+                return -1;
             }
 
             boolean full = false;
+
             while (!full && !doneWritingParts) {
-                org.asynchttpclient.Part part = null;
-                if (startPart < parts.size()) {
-                    part = parts.get(startPart);
+                Part part = null;
+
+                if (currentPart < parts.size()) {
+                    part = parts.get(currentPart);
                 }
                 if (currentFileChannel != null) {
-                    overallLength += currentFileChannel.read(buffer);
+                    overallLength += writeCurrentFile(buffer);
+                    full = overallLength == maxLength;
 
-                    if (currentFileChannel.position() == currentFileChannel.size()) {
-                        currentFileChannel.close();
-                        currentFileChannel = null;
-                    }
-
-                    if (overallLength == maxLength) {
-                        full = true;
-                    }
-                } else if (currentStreamPosition > -1) {
-                    overallLength += writeToBuffer(buffer, maxLength - overallLength);
+                } else if (currentBytesPosition > -1) {
+                    overallLength += writeCurrentBytes(buffer, maxLength - overallLength);
+                    full = overallLength == maxLength;
 
-                    if (overallLength == maxLength) {
-                        full = true;
-                    }
-                    if (startPart == parts.size() && currentStream.available() == 0) {
+                    if (currentPart == parts.size() && currentBytesFullyRead()) {
                         doneWritingParts = true;
                     }
+
                 } else if (part instanceof StringPart) {
-                    StringPart currentPart = (StringPart) part;
-
-                    initializeStringPart(currentPart);
-
-                    startPart++;
-                } else if (part instanceof org.asynchttpclient.StringPart) {
-                    StringPart currentPart = generateClientStringpart(part);
-
-                    initializeStringPart(currentPart);
-
-                    startPart++;
-                } else if (part instanceof FilePart) {
-                    if (fileLocation == FileLocation.NONE) {
-                        currentFilePart = (FilePart) part;
-                        initializeFilePart(currentFilePart);
-                    } else if (fileLocation == FileLocation.START) {
-                        initializeFileBody(currentFilePart);
-                    } else if (fileLocation == FileLocation.MIDDLE) {
-                        initializeFileEnd(currentFilePart);
-                    } else if (fileLocation == FileLocation.END) {
-                        startPart++;
-                        if (startPart == parts.size() && currentStream.available() == 0) {
-                            doneWritingParts = true;
-                        }
-                    }
-                } else if (part instanceof org.asynchttpclient.FilePart) {
-                    if (fileLocation == FileLocation.NONE) {
-                        currentFilePart = generateClientFilePart(part);
-                        initializeFilePart(currentFilePart);
-                    } else if (fileLocation == FileLocation.START) {
-                        initializeFileBody(currentFilePart);
-                    } else if (fileLocation == FileLocation.MIDDLE) {
-                        initializeFileEnd(currentFilePart);
-                    } else if (fileLocation == FileLocation.END) {
-                        startPart++;
-                        if (startPart == parts.size() && currentStream.available() == 0) {
-                            doneWritingParts = true;
-                        }
-                    }
-                } else if (part instanceof ByteArrayPart) {
-                    ByteArrayPart bytePart =
-                            (ByteArrayPart) part;
-
-                    if (fileLocation == FileLocation.NONE) {
-                        currentFilePart =
-                                generateClientByteArrayPart(bytePart);
-
-                        initializeFilePart(currentFilePart);
-                    } else if (fileLocation == FileLocation.START) {
-                        initializeByteArrayBody(currentFilePart);
-                    } else if (fileLocation == FileLocation.MIDDLE) {
-                        initializeFileEnd(currentFilePart);
-                    } else if (fileLocation == FileLocation.END) {
-                        startPart++;
-                        if (startPart == parts.size() && currentStream.available() == 0) {
+                    StringPart stringPart = (StringPart) part;
+                    // set new bytes, not full, so will loop to writeCurrentBytes above
+                    initializeCurrentBytes(stringPart.getBytes(boundary));
+                    currentPart++;
+
+                } else if (part instanceof AbstractFilePart) {
+
+                    AbstractFilePart filePart = (AbstractFilePart) part;
+
+                    switch (fileLocation) {
+                    case NONE:
+                        // set new bytes, not full, so will loop to writeCurrentBytes above
+                        initializeCurrentBytes(filePart.generateFileStart(boundary));
+                        fileLocation = FileLocation.START;
+                        break;
+                    case START:
+                        // set current file channel so code above executes first
+                        initializeFileBody(filePart);
+                        fileLocation = FileLocation.MIDDLE;
+                        break;
+                    case MIDDLE:
+                        initializeCurrentBytes(filePart.generateFileEnd());
+                        fileLocation = FileLocation.END;
+                        break;
+                    case END:
+                        currentPart++;
+                        fileLocation = FileLocation.NONE;
+                        if (currentPart == parts.size()) {
                             doneWritingParts = true;
                         }
                     }
@@ -173,449 +155,86 @@ public long read(ByteBuffer buffer) throws IOException {
             }
 
             if (doneWritingParts) {
-                if (currentStreamPosition == -1) {
-                    ByteArrayOutputStream endWriter = new ByteArrayOutputStream();
-
-                    Part.sendMessageEnd(endWriter, boundary);
-
-                    initializeBuffer(endWriter);
+                if (currentBytesPosition == -1) {
+                    initializeCurrentBytes(MultipartUtils.getMessageEnd(boundary));
                 }
 
-                if (currentStreamPosition > -1) {
-                    overallLength += writeToBuffer(buffer, maxLength - overallLength);
+                if (currentBytesPosition > -1) {
+                    overallLength += writeCurrentBytes(buffer, maxLength - overallLength);
 
-                    if (currentStream.available() == 0) {
-                        currentStream.close();
-                        currentStreamPosition = -1;
-                        endWritten = true;
+                    if (currentBytesFullyRead()) {
+                        currentBytes = null;
+                        currentBytesPosition = -1;
+                        transfertDone = true;
                     }
                 }
             }
             return overallLength;
 
         } catch (Exception e) {
-            logger.info("read exception", e);
+            LOGGER.error("Read exception", e);
             return 0;
         }
     }
 
-    private void initializeByteArrayBody(FilePart filePart)
-            throws IOException {
-
-        ByteArrayOutputStream output = generateByteArrayBody(filePart);
-
-        initializeBuffer(output);
-
-        fileLocation = FileLocation.MIDDLE;
+    private boolean currentBytesFullyRead() {
+        return currentBytes == null || currentBytesPosition >= currentBytes.length - 1;
     }
 
-    private void initializeFileEnd(FilePart currentPart)
-            throws IOException {
-
-        ByteArrayOutputStream output = generateFileEnd(currentPart);
-
-        initializeBuffer(output);
-
-        fileLocation = FileLocation.END;
-
-    }
-
-    private void initializeFileBody(FilePart currentPart)
-            throws IOException {
-
-        if (FilePartSource.class.isAssignableFrom(currentPart.getSource().getClass())) {
-
-            FilePartSource source = (FilePartSource) currentPart.getSource();
-
-            File file = source.getFile();
-
-            RandomAccessFile raf = new RandomAccessFile(file, "r");
-            files.add(raf);
+    private void initializeFileBody(AbstractFilePart part) throws IOException {
 
+        if (part instanceof FilePart) {
+            RandomAccessFile raf = new RandomAccessFile(FilePart.class.cast(part).getFile(), "r");
+            pendingOpenFiles.add(raf);
             currentFileChannel = raf.getChannel();
 
-        } else {
-            PartSource partSource = currentPart.getSource();
-
-            InputStream stream = partSource.createInputStream();
-
-            byte[] bytes = new byte[(int) partSource.getLength()];
-
-            stream.read(bytes);
-
-            currentStream = new ByteArrayInputStream(bytes);
-
-            currentStreamPosition = 0;
-        }
-
-        fileLocation = FileLocation.MIDDLE;
-    }
-
-    private void initializeFilePart(FilePart filePart)
-            throws IOException {
-
-        filePart.setPartBoundary(boundary);
-
-        ByteArrayOutputStream output = generateFileStart(filePart);
-
-        initializeBuffer(output);
-
-        fileLocation = FileLocation.START;
-    }
-
-    private void initializeStringPart(StringPart currentPart)
-            throws IOException {
-        currentPart.setPartBoundary(boundary);
-
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-
-        Part.sendPart(outputStream, currentPart, boundary);
-
-        initializeBuffer(outputStream);
-    }
-
-    private int writeToBuffer(ByteBuffer buffer, int length)
-            throws IOException {
+        } else if (part instanceof ByteArrayPart) {
+            initializeCurrentBytes(ByteArrayPart.class.cast(part).getBytes());
 
-        int available = currentStream.available();
-
-        int writeLength = Math.min(available, length);
-
-        byte[] bytes = new byte[writeLength];
-
-        currentStream.read(bytes);
-
-        buffer.put(bytes);
-
-        if (available <= length) {
-            currentStream.close();
-            currentStreamPosition = -1;
         } else {
-            currentStreamPosition += writeLength;
+            throw new IllegalArgumentException("Unknow AbstractFilePart type");
         }
-
-        return writeLength;
     }
 
-    private void initializeBuffer(ByteArrayOutputStream outputStream)
-            throws IOException {
-
-        currentStream = new ByteArrayInputStream(outputStream.toByteArray());
-
-        currentStreamPosition = 0;
-
+    private void initializeCurrentBytes(byte[] bytes) throws IOException {
+        currentBytes = bytes;
+        currentBytesPosition = 0;
     }
 
-    public long transferTo(long position, long count, WritableByteChannel target)
-            throws IOException {
+    private int writeCurrentFile(ByteBuffer buffer) throws IOException {
 
-        long overallLength = 0;
+        int read = currentFileChannel.read(buffer);
 
-        if (startPart == parts.size()) {
-            return contentLength;
-        }
-
-        int tempPart = startPart;
+        if (currentFileChannel.position() == currentFileChannel.size()) {
 
-        for (org.asynchttpclient.Part part : parts) {
-            if (part instanceof Part) {
-                overallLength += handleMultiPart(target, (Part) part);
-            } else {
-                overallLength += handleClientPart(target, part);
-            }
+            currentFileChannel.close();
+            currentFileChannel = null;
 
-            tempPart++;
+            int currentFile = pendingOpenFiles.size() - 1;
+            pendingOpenFiles.get(currentFile).close();
+            pendingOpenFiles.remove(currentFile);
         }
-        ByteArrayOutputStream endWriter =
-                new ByteArrayOutputStream();
-
-        Part.sendMessageEnd(endWriter, boundary);
 
-        overallLength += writeToTarget(target, endWriter);
-
-        startPart = tempPart;
-
-        return overallLength;
+        return read;
     }
 
-    private long handleClientPart(
-            WritableByteChannel target, org.asynchttpclient.Part part) throws IOException {
-
-        if (part.getClass().equals(org.asynchttpclient.StringPart.class)) {
-            StringPart currentPart = generateClientStringpart(part);
-
-            return handleStringPart(target, currentPart);
-        } else if (part.getClass().equals(org.asynchttpclient.FilePart.class)) {
-            FilePart filePart = generateClientFilePart(part);
+    private int writeCurrentBytes(ByteBuffer buffer, int length) throws IOException {
 
-            return handleFilePart(target, filePart);
-        } else if (part.getClass().equals(ByteArrayPart.class)) {
-            ByteArrayPart bytePart = (ByteArrayPart) part;
+        int available = currentBytes.length - currentBytesPosition;
 
-            FilePart filePart = generateClientByteArrayPart(bytePart);
-
-            return handleByteArrayPart(target, filePart, bytePart.getData());
-        }
-
-        return 0;
-    }
-
-    private FilePart generateClientByteArrayPart(
-            ByteArrayPart bytePart) {
-        ByteArrayPartSource source = new ByteArrayPartSource(bytePart.getFileName(), bytePart.getData());
-
-        FilePart filePart = new FilePart(bytePart.getName(), source, bytePart.getMimeType(), bytePart.getCharSet());
-        return filePart;
-    }
-
-    private FilePart generateClientFilePart(org.asynchttpclient.Part part)
-            throws FileNotFoundException {
-        org.asynchttpclient.FilePart
-                currentPart = (org.asynchttpclient.FilePart) part;
-
-        FilePart filePart = new FilePart(currentPart.getName(), currentPart.getFile(), currentPart.getMimeType(), currentPart.getCharSet());
-        return filePart;
-    }
-
-    private StringPart generateClientStringpart(org.asynchttpclient.Part part) {
-        org.asynchttpclient.StringPart
-                stringPart = (org.asynchttpclient.StringPart) part;
-
-        StringPart currentPart = new StringPart(stringPart.getName(), stringPart.getValue(), stringPart.getCharset());
-        return currentPart;
-    }
-
-    private long handleByteArrayPart(WritableByteChannel target,
-                                     FilePart filePart, byte[] data) throws IOException {
-
-        ByteArrayOutputStream output = generateByteArrayBody(filePart);
-        return writeToTarget(target, output);
-    }
-
-    private ByteArrayOutputStream generateByteArrayBody(FilePart filePart)
-            throws IOException {
-        ByteArrayOutputStream output = new ByteArrayOutputStream();
-        Part.sendPart(output, filePart, boundary);
-        return output;
-    }
-
-    private long handleFileEnd(WritableByteChannel target, FilePart filePart)
-            throws IOException {
-
-        ByteArrayOutputStream endOverhead = generateFileEnd(filePart);
-
-        return this.writeToTarget(target, endOverhead);
-    }
-
-    private ByteArrayOutputStream generateFileEnd(FilePart filePart)
-            throws IOException {
-        ByteArrayOutputStream endOverhead = new ByteArrayOutputStream();
-
-        filePart.sendEnd(endOverhead);
-        return endOverhead;
-    }
-
-    private long handleFileHeaders(WritableByteChannel target, FilePart filePart) throws IOException {
-        filePart.setPartBoundary(boundary);
-
-        ByteArrayOutputStream overhead = generateFileStart(filePart);
-
-        return writeToTarget(target, overhead);
-    }
-
-    private ByteArrayOutputStream generateFileStart(FilePart filePart)
-            throws IOException {
-        ByteArrayOutputStream overhead = new ByteArrayOutputStream();
-
-        filePart.setPartBoundary(boundary);
-
-        filePart.sendStart(overhead);
-        filePart.sendDispositionHeader(overhead);
-        filePart.sendContentTypeHeader(overhead);
-        filePart.sendTransferEncodingHeader(overhead);
-        filePart.sendContentIdHeader(overhead);
-        filePart.sendEndOfHeader(overhead);
-        return overhead;
-    }
-
-    private long handleFilePart(WritableByteChannel target, FilePart filePart) throws IOException {
-        FilePartStallHandler handler = new FilePartStallHandler(
-                filePart.getStalledTime(), filePart);
-
-        handler.start();
-
-        if (FilePartSource.class.isAssignableFrom(filePart.getSource().getClass())) {
-            int length = 0;
-
-            length += handleFileHeaders(target, filePart);
-            FilePartSource source = (FilePartSource) filePart.getSource();
-
-            File file = source.getFile();
-
-            RandomAccessFile raf = new RandomAccessFile(file, "r");
-            files.add(raf);
-
-            FileChannel fc = raf.getChannel();
-
-            long l = file.length();
-            int fileLength = 0;
-            long nWrite = 0;
-            synchronized (fc) {
-                while (fileLength != l) {
-                    if (handler.isFailed()) {
-                        logger.debug("Stalled error");
-                        throw new FileUploadStalledException();
-                    }
-                    try {
-                        nWrite = fc.transferTo(fileLength, l, target);
-
-                        if (nWrite == 0) {
-                            logger.info("Waiting for writing...");
-                            try {
-                                fc.wait(50);
-                            } catch (InterruptedException e) {
-                                logger.trace(e.getMessage(), e);
-                            }
-                        } else {
-                            handler.writeHappened();
-                        }
-                    } catch (IOException ex) {
-                        String message = ex.getMessage();
-
-                        // http://bugs.sun.com/view_bug.do?bug_id=5103988
-                        if (message != null && message.equalsIgnoreCase("Resource temporarily unavailable")) {
-                            try {
-                                fc.wait(1000);
-                            } catch (InterruptedException e) {
-                                logger.trace(e.getMessage(), e);
-                            }
-                            logger.warn("Experiencing NIO issue http://bugs.sun.com/view_bug.do?bug_id=5103988. Retrying");
-                            continue;
-                        } else {
-                            throw ex;
-                        }
-                    }
-                    fileLength += nWrite;
-                }
-            }
-            handler.completed();
-
-            fc.close();
-
-            length += handleFileEnd(target, filePart);
-
-            return length;
-        } else {
-            return handlePartSource(target, filePart);
-        }
-    }
-
-    private long handlePartSource(WritableByteChannel target, FilePart filePart) throws IOException {
-
-        int length = 0;
-
-        length += handleFileHeaders(target, filePart);
-
-        PartSource partSource = filePart.getSource();
-
-        InputStream stream = partSource.createInputStream();
-
-        try {
-            int nRead = 0;
-            while (nRead != -1) {
-                // Do not buffer the entire monster in memory.
-                byte[] bytes = new byte[8192];
-                nRead = stream.read(bytes);
-                if (nRead > 0) {
-                    ByteArrayOutputStream bos = new ByteArrayOutputStream(nRead);
-                    bos.write(bytes, 0, nRead);
-                    writeToTarget(target, bos);
-                }
-            }
-        } finally {
-            stream.close();
-        }
-        length += handleFileEnd(target, filePart);
-
-        return length;
-    }
-
-    private long handleStringPart(WritableByteChannel target, StringPart currentPart) throws IOException {
-
-        currentPart.setPartBoundary(boundary);
-
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-
-        Part.sendPart(outputStream, currentPart, boundary);
-
-        return writeToTarget(target, outputStream);
-    }
-
-    private long handleMultiPart(WritableByteChannel target, Part currentPart) throws IOException {
-
-        currentPart.setPartBoundary(boundary);
-
-        if (currentPart.getClass().equals(StringPart.class)) {
-            return handleStringPart(target, (StringPart) currentPart);
-        } else if (currentPart.getClass().equals(FilePart.class)) {
-            FilePart filePart = (FilePart) currentPart;
-
-            return handleFilePart(target, filePart);
-        }
-        return 0;
-    }
-
-    private long writeToTarget(WritableByteChannel target, ByteArrayOutputStream byteWriter)
-            throws IOException {
-
-        int written = 0;
-        int maxSpin = 0;
-        synchronized (byteWriter) {
-            ByteBuffer message = ByteBuffer.wrap(byteWriter.toByteArray());
-
-            if (target instanceof SocketChannel) {
-                final Selector selector = Selector.open();
-                try {
-                    final SocketChannel channel = (SocketChannel) target;
-                    channel.register(selector, SelectionKey.OP_WRITE);
+        int writeLength = Math.min(available, length);
 
-                    while (written < byteWriter.size() && selector.select() != 0) {
-                        final Set<SelectionKey> selectedKeys = selector.selectedKeys();
+        if (writeLength > 0) {
+            buffer.put(currentBytes, currentBytesPosition, writeLength);
 
-                        for (SelectionKey key : selectedKeys) {
-                            if (key.isWritable()) {
-                                written += target.write(message);
-                            }
-                        }
-                    }
-
-                    if (written < byteWriter.size()) {
-                        throw new IOException("Unable to write on channel " + target);
-                    }
-                } finally {
-                    selector.close();
-                }
+            if (available <= length) {
+                currentBytesPosition = -1;
+                currentBytes = null;
             } else {
-                while ((target.isOpen()) && (written < byteWriter.size())) {
-                    long nWrite = target.write(message);
-                    written += nWrite;
-                    if (nWrite == 0 && maxSpin++ < 10) {
-                        logger.info("Waiting for writing...");
-                        try {
-                            byteWriter.wait(1000);
-                        } catch (InterruptedException e) {
-                            logger.trace(e.getMessage(), e);
-                        }
-                    } else {
-                        if (maxSpin >= 10) {
-                            throw new IOException("Unable to write on channel " + target);
-                        }
-                        maxSpin = 0;
-                    }
-                }
+                currentBytesPosition += writeLength;
             }
         }
-        return written;
-    }
 
+        return writeLength;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java
deleted file mode 100644
index 4542f824e..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- *
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public class MultipartEncodingUtil {
-
-    public static byte[] getAsciiBytes(String data) {
-        try {
-            return data.getBytes("US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static String getAsciiString(final byte[] data) {
-        if (data == null) {
-            throw new IllegalArgumentException("Parameter may not be null");
-        }
-
-        try {
-            return new String(data, "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static byte[] getBytes(final String data, String charset) {
-
-        if (data == null) {
-            throw new IllegalArgumentException("data may not be null");
-        }
-
-        if (charset == null || charset.length() == 0) {
-            throw new IllegalArgumentException("charset may not be null or empty");
-        }
-
-        try {
-            return data.getBytes(charset);
-        } catch (UnsupportedEncodingException e) {
-            throw new IllegalArgumentException(String.format("Unsupported encoding: %s", charset));
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java
deleted file mode 100644
index 356bb59d0..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Random;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public class MultipartRequestEntity implements RequestEntity {
-
-    /**
-     * The Content-Type for multipart/form-data.
-     */
-    private static final String MULTIPART_FORM_CONTENT_TYPE = "multipart/form-data";
-
-    /**
-     * The pool of ASCII chars to be used for generating a multipart boundary.
-     */
-    private static byte[] MULTIPART_CHARS = MultipartEncodingUtil.getAsciiBytes("-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-    /**
-     * Generates a random multipart boundary string.
-     * 
-     * @return
-     */
-    private static byte[] generateMultipartBoundary() {
-        Random rand = new Random();
-        byte[] bytes = new byte[rand.nextInt(11) + 30]; // a random size from 30 to 40
-        for (int i = 0; i < bytes.length; i++) {
-            bytes[i] = MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)];
-        }
-        return bytes;
-    }
-
-    private final Logger log = LoggerFactory.getLogger(MultipartRequestEntity.class);
-
-    /**
-     * The MIME parts as set by the constructor
-     */
-    protected Part[] parts;
-
-    private byte[] multipartBoundary;
-
-    private final String contentType;
-
-    /**
-     * Creates a new multipart entity containing the given parts.
-     * 
-     * @param parts The parts to include.
-     * @param requestHeader
-     */
-    public MultipartRequestEntity(Part[] parts, FluentCaseInsensitiveStringsMap requestHeaders) {
-        if (parts == null) {
-            throw new IllegalArgumentException("parts cannot be null");
-        }
-        String contentTypeHeader = requestHeaders.getFirstValue("Content-Type");
-        if (isNonEmpty(contentTypeHeader))
-            this.contentType = contentTypeHeader;
-        else
-            this.contentType = MULTIPART_FORM_CONTENT_TYPE;
-        this.parts = parts;
-    }
-
-    /**
-     * Returns the MIME boundary string that is used to demarcate boundaries of this part. The first call to this method will implicitly create a new boundary string. To create a boundary string first the HttpMethodParams.MULTIPART_BOUNDARY parameter is considered. Otherwise a
-     * random one is generated.
-     * 
-     * @return The boundary string of this entity in ASCII encoding.
-     */
-    protected byte[] getMultipartBoundary() {
-        if (multipartBoundary == null) {
-            multipartBoundary = generateMultipartBoundary();
-        }
-        return multipartBoundary;
-    }
-
-    /**
-     * Returns <code>true</code> if all parts are repeatable, <code>false</code> otherwise.
-     */
-    public boolean isRepeatable() {
-        for (int i = 0; i < parts.length; i++) {
-            if (!parts[i].isRepeatable()) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.httpclient.methods.RequestEntity#writeRequest(java.io.OutputStream)
-     */
-    public void writeRequest(OutputStream out) throws IOException {
-        Part.sendParts(out, parts, getMultipartBoundary());
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.httpclient.methods.RequestEntity#getContentLength()
-     */
-    public long getContentLength() {
-        try {
-            return Part.getLengthOfParts(parts, getMultipartBoundary());
-        } catch (Exception e) {
-            log.error("An exception occurred while getting the length of the parts", e);
-            return 0;
-        }
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.httpclient.methods.RequestEntity#getContentType()
-     */
-    public String getContentType() {
-        if (contentType.contains("boundary="))
-            return contentType;
-        else {
-            StringBuilder buffer = new StringBuilder(contentType);
-            if (!contentType.endsWith(";"))
-                buffer.append(";");
-            buffer.append(" boundary=");
-            buffer.append(MultipartEncodingUtil.getAsciiString(getMultipartBoundary()));
-            return buffer.toString();
-        }
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java
new file mode 100644
index 000000000..d1f3ace5d
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.multipart;
+
+import static org.asynchttpclient.multipart.Part.CRLF_BYTES;
+import static org.asynchttpclient.multipart.Part.EXTRA_BYTES;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.util.StandardCharsets;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.nio.channels.WritableByteChannel;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+
+public class MultipartUtils {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(MultipartUtils.class);
+
+    /**
+     * The Content-Type for multipart/form-data.
+     */
+    private static final String MULTIPART_FORM_CONTENT_TYPE = "multipart/form-data";
+
+    /**
+     * The pool of ASCII chars to be used for generating a multipart boundary.
+     */
+    private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
+            .getBytes(StandardCharsets.US_ASCII);
+
+    private MultipartUtils() {
+    }
+
+    /**
+     * Creates a new multipart entity containing the given parts.
+     * 
+     * @param parts
+     *            The parts to include.
+     */
+    public static MultipartBody newMultipartBody(List<Part> parts, FluentCaseInsensitiveStringsMap requestHeaders) {
+        if (parts == null) {
+            throw new NullPointerException("parts");
+        }
+
+        byte[] multipartBoundary;
+        String contentType;
+
+        String contentTypeHeader = requestHeaders.getFirstValue("Content-Type");
+        if (isNonEmpty(contentTypeHeader)) {
+            int boundaryLocation = contentTypeHeader.indexOf("boundary=");
+            if (boundaryLocation != -1) {
+                // boundary defined in existing Content-Type
+                contentType = contentTypeHeader;
+                multipartBoundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim())
+                        .getBytes(StandardCharsets.US_ASCII);
+            } else {
+                // generate boundary and append it to existing Content-Type
+                multipartBoundary = generateMultipartBoundary();
+                contentType = computeContentType(contentTypeHeader, multipartBoundary);
+            }
+        } else {
+            multipartBoundary = generateMultipartBoundary();
+            contentType = computeContentType(MULTIPART_FORM_CONTENT_TYPE, multipartBoundary);
+        }
+
+        long contentLength = getLengthOfParts(parts, multipartBoundary);
+
+        return new MultipartBody(parts, contentType, contentLength, multipartBoundary);
+    }
+
+    private static byte[] generateMultipartBoundary() {
+        Random rand = new Random();
+        byte[] bytes = new byte[rand.nextInt(11) + 30]; // a random size from 30 to 40
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)];
+        }
+        return bytes;
+    }
+
+    private static String computeContentType(String base, byte[] multipartBoundary) {
+        StringBuilder buffer = new StringBuilder(base);
+        if (!base.endsWith(";"))
+            buffer.append(";");
+        return buffer.append(" boundary=").append(new String(multipartBoundary, StandardCharsets.US_ASCII)).toString();
+    }
+
+    public static long writeBytesToChannel(WritableByteChannel target, byte[] bytes) throws IOException {
+
+        int written = 0;
+        int maxSpin = 0;
+        ByteBuffer message = ByteBuffer.wrap(bytes);
+
+        if (target instanceof SocketChannel) {
+            final Selector selector = Selector.open();
+            try {
+                final SocketChannel channel = (SocketChannel) target;
+                channel.register(selector, SelectionKey.OP_WRITE);
+
+                while (written < bytes.length) {
+                    selector.select(1000);
+                    maxSpin++;
+                    final Set<SelectionKey> selectedKeys = selector.selectedKeys();
+
+                    for (SelectionKey key : selectedKeys) {
+                        if (key.isWritable()) {
+                            written += target.write(message);
+                            maxSpin = 0;
+                        }
+                    }
+                    if (maxSpin >= 10) {
+                        throw new IOException("Unable to write on channel " + target);
+                    }
+                }
+            } finally {
+                selector.close();
+            }
+        } else {
+            while ((target.isOpen()) && (written < bytes.length)) {
+                long nWrite = target.write(message);
+                written += nWrite;
+                if (nWrite == 0 && maxSpin++ < 10) {
+                    LOGGER.info("Waiting for writing...");
+                    try {
+                        bytes.wait(1000);
+                    } catch (InterruptedException e) {
+                        LOGGER.trace(e.getMessage(), e);
+                    }
+                } else {
+                    if (maxSpin >= 10) {
+                        throw new IOException("Unable to write on channel " + target);
+                    }
+                    maxSpin = 0;
+                }
+            }
+        }
+        return written;
+    }
+
+    public static byte[] getMessageEnd(byte[] partBoundary) throws IOException {
+
+        if (!isNonEmpty(partBoundary))
+            throw new IllegalArgumentException("partBoundary may not be empty");
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
+        visitor.withBytes(EXTRA_BYTES);
+        visitor.withBytes(partBoundary);
+        visitor.withBytes(EXTRA_BYTES);
+        visitor.withBytes(CRLF_BYTES);
+
+        return out.toByteArray();
+    }
+
+    public static long getLengthOfParts(List<Part> parts, byte[] partBoundary) {
+
+        try {
+            if (parts == null) {
+                throw new NullPointerException("parts");
+            }
+            long total = 0;
+            for (Part part : parts) {
+                long l = part.length(partBoundary);
+                if (l < 0) {
+                    return -1;
+                }
+                total += l;
+            }
+            total += EXTRA_BYTES.length;
+            total += partBoundary.length;
+            total += EXTRA_BYTES.length;
+            total += CRLF_BYTES.length;
+            return total;
+        } catch (Exception e) {
+            LOGGER.error("An exception occurred while getting the length of the parts", e);
+            return 0L;
+        }
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java b/api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java
similarity index 54%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
rename to api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java
index d00acde3c..518962f8d 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java
@@ -13,16 +13,30 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
+package org.asynchttpclient.multipart;
 
-package org.asynchttpclient.providers.netty;
+import java.io.IOException;
+import java.io.OutputStream;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RetryRequestTest;
+public class OutputStreamPartVisitor implements PartVisitor {
+
+    private final OutputStream out;
+
+    public OutputStreamPartVisitor(OutputStream out) {
+        this.out = out;
+    }
+
+    @Override
+    public void withBytes(byte[] bytes) throws IOException {
+        out.write(bytes);
+    }
 
-public class NettyRetryRequestTest extends RetryRequestTest{
     @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+    public void withByte(byte b) throws IOException {
+        out.write(b);
+    }
+
+    public OutputStream getOutputStream() {
+        return out;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/Part.java b/api/src/main/java/org/asynchttpclient/multipart/Part.java
index 3d71bf524..4a5a2d90b 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/Part.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/Part.java
@@ -1,469 +1,136 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.multipart;
 
-import java.io.ByteArrayOutputStream;
+import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
 
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public abstract class Part implements org.asynchttpclient.Part {
-
-    /**
-     * The boundary
-     */
-    protected static final String BOUNDARY = "----------------314159265358979323846";
-
-    /**
-     * The default boundary to be used if etBoundaryBytes(byte[]) has not been called.
-     */
-    private static final byte[] DEFAULT_BOUNDARY_BYTES = MultipartEncodingUtil.getAsciiBytes(BOUNDARY);
-
-    /**
-     * Carriage return/linefeed
-     */
-    protected static final String CRLF = "\r\n";
+public interface Part {
 
     /**
      * Carriage return/linefeed as a byte array
      */
-    static final byte[] CRLF_BYTES = MultipartEncodingUtil.getAsciiBytes(CRLF);
+    byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
 
     /**
-     * Content dispostion characters
+     * Content dispostion as a byte
      */
-    protected static final String QUOTE = "\"";
-
-    /**
-     * Content dispostion as a byte array
-     */
-    static final byte[] QUOTE_BYTES = MultipartEncodingUtil.getAsciiBytes(QUOTE);
-
-    /**
-     * Extra characters
-     */
-    protected static final String EXTRA = "--";
+    byte QUOTE_BYTE = '\"';
 
     /**
      * Extra characters as a byte array
      */
-    static final byte[] EXTRA_BYTES = MultipartEncodingUtil.getAsciiBytes(EXTRA);
-
-    /**
-     * Content dispostion characters
-     */
-    protected static final String CONTENT_DISPOSITION = "Content-Disposition: form-data; name=";
+    byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
 
     /**
      * Content dispostion as a byte array
      */
-    static final byte[] CONTENT_DISPOSITION_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_DISPOSITION);
+    byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
 
     /**
-     * Content type header
+     * form-data as a byte array
      */
-    protected static final String CONTENT_TYPE = "Content-Type: ";
+    byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
 
     /**
-     * Content type header as a byte array
+     * name as a byte array
      */
-    static final byte[] CONTENT_TYPE_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_TYPE);
+    byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
 
     /**
-     * Content charset
+     * Content type header as a byte array
      */
-    protected static final String CHARSET = "; charset=";
+    byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
 
     /**
      * Content charset as a byte array
      */
-    static final byte[] CHARSET_BYTES = MultipartEncodingUtil.getAsciiBytes(CHARSET);
-
-    /**
-     * Content type header
-     */
-    protected static final String CONTENT_TRANSFER_ENCODING = "Content-Transfer-Encoding: ";
+    byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
 
     /**
      * Content type header as a byte array
      */
-    static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_TRANSFER_ENCODING);
-
-    /**
-     * Content type header
-     */
-    protected static final String CONTENT_ID = "Content-ID: ";
+    byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
 
     /**
      * Content type header as a byte array
      */
-    static final byte[] CONTENT_ID_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_ID);
-
-    /**
-     * Return the boundary string.
-     * 
-     * @return the boundary string
-     * @deprecated uses a constant string. Rather use {@link #getPartBoundary}
-     */
-    public static String getBoundary() {
-        return BOUNDARY;
-    }
-
-    /**
-     * The ASCII bytes to use as the multipart boundary.
-     */
-    private byte[] boundaryBytes;
+    byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
 
     /**
      * Return the name of this part.
      * 
      * @return The name.
      */
-    public abstract String getName();
+    String getName();
 
     /**
      * Returns the content type of this part.
      * 
      * @return the content type, or <code>null</code> to exclude the content type header
      */
-    public abstract String getContentType();
+    String getContentType();
 
     /**
      * Return the character encoding of this part.
      * 
      * @return the character encoding, or <code>null</code> to exclude the character encoding header
      */
-    public abstract String getCharSet();
+    Charset getCharset();
 
     /**
      * Return the transfer encoding of this part.
      * 
      * @return the transfer encoding, or <code>null</code> to exclude the transfer encoding header
      */
-    public abstract String getTransferEncoding();
-
-    public abstract String getContentId();
-
-    /**
-     * Gets the part boundary to be used.
-     * 
-     * @return the part boundary as an array of bytes.
-     * @since 3.0
-     */
-    protected byte[] getPartBoundary() {
-        if (boundaryBytes == null) {
-            // custom boundary bytes have not been set, use the default.
-            return DEFAULT_BOUNDARY_BYTES;
-        } else {
-            return boundaryBytes;
-        }
-    }
-
-    /**
-     * Sets the part boundary. Only meant to be used by {@link Part#sendParts(java.io.OutputStream, Part[], byte[])} and {@link Part#getLengthOfParts(Part[], byte[])}
-     * 
-     * @param boundaryBytes An array of ASCII bytes.
-     * @since 3.0
-     */
-    void setPartBoundary(byte[] boundaryBytes) {
-        this.boundaryBytes = boundaryBytes;
-    }
-
-    /**
-     * Tests if this part can be sent more than once.
-     * 
-     * @return <code>true</code> if {@link #sendData(java.io.OutputStream)} can be successfully called more than once.
-     * @since 3.0
-     */
-    public boolean isRepeatable() {
-        return true;
-    }
-
-    /**
-     * Write the start to the specified output stream
-     * 
-     * @param out The output stream
-     * @throws java.io.IOException If an IO problem occurs.
-     */
-    protected void sendStart(OutputStream out) throws IOException {
-        out.write(EXTRA_BYTES);
-        out.write(getPartBoundary());
-    }
+    String getTransferEncoding();
 
     /**
-     * Write the content disposition header to the specified output stream
+     * Return the content ID of this part.
      * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
+     * @return the content ID, or <code>null</code> to exclude the content ID header
      */
-    protected void sendDispositionHeader(OutputStream out) throws IOException {
-        if (getName() != null) {
-            out.write(CRLF_BYTES);
-            out.write(CONTENT_DISPOSITION_BYTES);
-            out.write(QUOTE_BYTES);
-            out.write(MultipartEncodingUtil.getAsciiBytes(getName()));
-            out.write(QUOTE_BYTES);
-        }
-    }
+    String getContentId();
 
     /**
-     * Write the content type header to the specified output stream
+     * Gets the disposition-type to be used in Content-Disposition header
      * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
+     * @return the disposition-type
      */
-    protected void sendContentTypeHeader(OutputStream out) throws IOException {
-        String contentType = getContentType();
-        if (contentType != null) {
-            out.write(CRLF_BYTES);
-            out.write(CONTENT_TYPE_BYTES);
-            out.write(MultipartEncodingUtil.getAsciiBytes(contentType));
-            String charSet = getCharSet();
-            if (charSet != null) {
-                out.write(CHARSET_BYTES);
-                out.write(MultipartEncodingUtil.getAsciiBytes(charSet));
-            }
-        }
-    }
-
-    /**
-     * Write the content transfer encoding header to the specified output stream
-     * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
-     */
-    protected void sendTransferEncodingHeader(OutputStream out) throws IOException {
-        String transferEncoding = getTransferEncoding();
-        if (transferEncoding != null) {
-            out.write(CRLF_BYTES);
-            out.write(CONTENT_TRANSFER_ENCODING_BYTES);
-            out.write(MultipartEncodingUtil.getAsciiBytes(transferEncoding));
-        }
-    }
-
-    /**
-     * Write the content ID header to the specified output stream
-     * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
-     */
-    protected void sendContentIdHeader(OutputStream out) throws IOException {
-        String contentId = getContentId();
-        if (contentId != null) {
-            out.write(CRLF_BYTES);
-            out.write(CONTENT_ID_BYTES);
-            out.write(MultipartEncodingUtil.getAsciiBytes(contentId));
-        }
-    }
-
-    /**
-     * Write the end of the header to the output stream
-     * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
-     */
-    protected void sendEndOfHeader(OutputStream out) throws IOException {
-        out.write(CRLF_BYTES);
-        out.write(CRLF_BYTES);
-    }
-
-    /**
-     * Write the data to the specified output stream
-     * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
-     */
-    protected abstract void sendData(OutputStream out) throws IOException;
-
-    /**
-     * Return the length of the main content
-     * 
-     * @return long The length.
-     * @throws IOException If an IO problem occurs
-     */
-    protected abstract long lengthOfData() throws IOException;
-
-    /**
-     * Write the end data to the output stream.
-     * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
-     */
-    protected void sendEnd(OutputStream out) throws IOException {
-        out.write(CRLF_BYTES);
-    }
+    String getDispositionType();
 
     /**
      * Write all the data to the output stream. If you override this method make sure to override #length() as well
      * 
-     * @param out The output stream
-     * @throws IOException If an IO problem occurs.
+     * @param out
+     *            The output stream
+     * @param boundary
+     *            the boundary
+     * @throws IOException
+     *             If an IO problem occurs.
      */
-    public void send(OutputStream out) throws IOException {
-        sendStart(out);
-        sendDispositionHeader(out);
-        sendContentTypeHeader(out);
-        sendTransferEncodingHeader(out);
-        sendEndOfHeader(out);
-        sendData(out);
-        sendEnd(out);
-    }
+    void write(OutputStream out, byte[] boundary) throws IOException;
 
     /**
      * Return the full length of all the data. If you override this method make sure to override #send(OutputStream) as well
      * 
      * @return long The length.
-     * @throws IOException If an IO problem occurs
-     */
-    public long length() throws IOException {
-        if (lengthOfData() < 0) {
-            return -1;
-        }
-        ByteArrayOutputStream overhead = new ByteArrayOutputStream();
-        sendStart(overhead);
-        sendDispositionHeader(overhead);
-        sendContentTypeHeader(overhead);
-        sendTransferEncodingHeader(overhead);
-        sendContentIdHeader(overhead);
-        sendEndOfHeader(overhead);
-        sendEnd(overhead);
-        return overhead.size() + lengthOfData();
-    }
-
-    /**
-     * Return a string representation of this object.
-     * 
-     * @return A string representation of this object.
-     * @see java.lang.Object#toString()
-     */
-    public String toString() {
-        return this.getName();
-    }
-
-    /**
-     * Write all parts and the last boundary to the specified output stream.
-     * 
-     * @param out The stream to write to.
-     * @param parts The parts to write.
-     * @throws IOException If an I/O error occurs while writing the parts.
-     */
-    public static void sendParts(OutputStream out, final Part[] parts) throws IOException {
-        sendParts(out, parts, DEFAULT_BOUNDARY_BYTES);
-    }
-
-    /**
-     * Write all parts and the last boundary to the specified output stream.
-     * 
-     * @param out The stream to write to.
-     * @param parts The parts to write.
-     * @param partBoundary The ASCII bytes to use as the part boundary.
-     * @throws IOException If an I/O error occurs while writing the parts.
-     * @since 3.0
      */
-    public static void sendParts(OutputStream out, Part[] parts, byte[] partBoundary) throws IOException {
-
-        if (parts == null) {
-            throw new IllegalArgumentException("Parts may not be null");
-        }
-        if (partBoundary == null || partBoundary.length == 0) {
-            throw new IllegalArgumentException("partBoundary may not be empty");
-        }
-        for (Part part : parts) {
-            // set the part boundary before the part is sent
-            part.setPartBoundary(partBoundary);
-            part.send(out);
-        }
-        out.write(EXTRA_BYTES);
-        out.write(partBoundary);
-        out.write(EXTRA_BYTES);
-        out.write(CRLF_BYTES);
-    }
-
-    public static void sendMessageEnd(OutputStream out, byte[] partBoundary) throws IOException {
-
-        if (partBoundary == null || partBoundary.length == 0) {
-            throw new IllegalArgumentException("partBoundary may not be empty");
-        }
-
-        out.write(EXTRA_BYTES);
-        out.write(partBoundary);
-        out.write(EXTRA_BYTES);
-        out.write(CRLF_BYTES);
-    }
+    long length(byte[] boundary);
 
-    /**
-     * Write all parts and the last boundary to the specified output stream.
-     * 
-     * @param out The stream to write to.
-     * @param part The part to write.
-     * @throws IOException If an I/O error occurs while writing the parts.
-     * @since N/A
-     */
-    public static void sendPart(OutputStream out, Part part, byte[] partBoundary) throws IOException {
-
-        if (part == null) {
-            throw new IllegalArgumentException("Parts may not be null");
-        }
-
-        part.setPartBoundary(partBoundary);
-        part.send(out);
-    }
-
-    /**
-     * Return the total sum of all parts and that of the last boundary
-     * 
-     * @param parts The parts.
-     * @return The total length
-     * @throws IOException If an I/O error occurs while writing the parts.
-     */
-    public static long getLengthOfParts(Part[] parts) throws IOException {
-        return getLengthOfParts(parts, DEFAULT_BOUNDARY_BYTES);
-    }
-
-    /**
-     * Gets the length of the multipart message including the given parts.
-     * 
-     * @param parts The parts.
-     * @param partBoundary The ASCII bytes to use as the part boundary.
-     * @return The total length
-     * @throws IOException If an I/O error occurs while writing the parts.
-     * @since 3.0
-     */
-    public static long getLengthOfParts(Part[] parts, byte[] partBoundary) throws IOException {
-        if (parts == null) {
-            throw new IllegalArgumentException("Parts may not be null");
-        }
-        long total = 0;
-        for (Part part : parts) {
-            // set the part boundary before we calculate the part's length
-            part.setPartBoundary(partBoundary);
-            long l = part.length();
-            if (l < 0) {
-                return -1;
-            }
-            total += l;
-        }
-        total += EXTRA_BYTES.length;
-        total += partBoundary.length;
-        total += EXTRA_BYTES.length;
-        total += CRLF_BYTES.length;
-        return total;
-    }
+    long write(WritableByteChannel target, byte[] boundary) throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/PartBase.java b/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
index c65c00668..a241df72a 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
@@ -1,150 +1,230 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.multipart;
 
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public abstract class PartBase extends Part {
+import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+
+public abstract class PartBase implements Part {
 
     /**
-     * Name of the file part.
+     * The name of the form field, part of the Content-Disposition header
      */
-    private String name;
+    private final String name;
 
     /**
-     * Content type of the file part.
+     * The main part of the Content-Type header
      */
-    private String contentType;
+    private final String contentType;
 
     /**
-     * Content encoding of the file part.
+     * The charset (part of Content-Type header)
      */
-    private String charSet;
+    private final Charset charset;
 
     /**
-     * The transfer encoding.
+     * The Content-Transfer-Encoding header value.
      */
-    private String transferEncoding;
+    private final String transferEncoding;
 
-    private String contentId;
+    /**
+     * The Content-Id
+     */
+    private final String contentId;
+
+    /**
+     * The disposition type (part of Content-Disposition)
+     */
+    private String dispositionType;
 
     /**
      * Constructor.
      * 
-     * @param name The name of the part
+     * @param name The name of the part, or <code>null</code>
      * @param contentType The content type, or <code>null</code>
-     * @param charSet The character encoding, or <code>null</code>
-     * @param transferEncoding The transfer encoding, or <code>null</code>
+     * @param charset The character encoding, or <code>null</code>
      * @param contentId The content id, or <code>null</code>
+     * @param transferEncoding The transfer encoding, or <code>null</code>
      */
-    public PartBase(String name, String contentType, String charSet, String transferEncoding, String contentId) {
-
-        if (name == null) {
-            throw new IllegalArgumentException("Name must not be null");
-        }
+    public PartBase(String name, String contentType, Charset charset, String contentId, String transferEncoding) {
         this.name = name;
         this.contentType = contentType;
-        this.charSet = charSet;
-        this.transferEncoding = transferEncoding;
+        this.charset = charset;
         this.contentId = contentId;
+        this.transferEncoding = transferEncoding;
     }
 
-    /**
-     * Returns the name.
-     * 
-     * @return The name.
-     */
-    public String getName() {
-        return this.name;
+    protected void visitStart(PartVisitor visitor, byte[] boundary) throws IOException {
+        visitor.withBytes(EXTRA_BYTES);
+        visitor.withBytes(boundary);
     }
 
-    /**
-     * Returns the content type of this part.
-     * 
-     * @return String The name.
-     */
-    public String getContentType() {
-        return this.contentType;
+    protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CONTENT_DISPOSITION_BYTES);
+        visitor.withBytes(getDispositionType() != null ? getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
+        if (getName() != null) {
+            visitor.withBytes(NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(getName().getBytes(US_ASCII));
+            visitor.withByte(QUOTE_BYTE);
+        }
     }
 
-    /**
-     * Return the character encoding of this part.
-     * 
-     * @return String The name.
-     */
-    public String getCharSet() {
-        return this.charSet;
+    protected void visitContentTypeHeader(PartVisitor visitor) throws IOException {
+        String contentType = getContentType();
+        if (contentType != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TYPE_BYTES);
+            visitor.withBytes(contentType.getBytes(US_ASCII));
+            Charset charSet = getCharset();
+            if (charSet != null) {
+                visitor.withBytes(CHARSET_BYTES);
+                visitor.withBytes(charset.name().getBytes(US_ASCII));
+            }
+        }
     }
 
-    /**
-     * Returns the transfer encoding of this part.
-     * 
-     * @return String The name.
-     */
-    public String getTransferEncoding() {
-        return transferEncoding;
+    protected void visitTransferEncodingHeader(PartVisitor visitor) throws IOException {
+        String transferEncoding = getTransferEncoding();
+        if (transferEncoding != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
+            visitor.withBytes(transferEncoding.getBytes(US_ASCII));
+        }
     }
 
-    /**
-     * Sets the character encoding.
-     * 
-     * @param charSet the character encoding, or <code>null</code> to exclude the character encoding header
-     */
-    public void setCharSet(String charSet) {
-        this.charSet = charSet;
+    protected void visitContentIdHeader(PartVisitor visitor) throws IOException {
+        String contentId = getContentId();
+        if (contentId != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_ID_BYTES);
+            visitor.withBytes(contentId.getBytes(US_ASCII));
+        }
+    }
+
+    protected void visitEndOfHeader(PartVisitor visitor) throws IOException {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CRLF_BYTES);
+    }
+
+    protected void visitEnd(PartVisitor visitor) throws IOException {
+        visitor.withBytes(CRLF_BYTES);
     }
 
+    protected abstract long getDataLength();
+
+    protected abstract void sendData(OutputStream out) throws IOException;
+
     /**
-     * Sets the content type.
+     * Write all the data to the output stream. If you override this method make sure to override #length() as well
      * 
-     * @param contentType the content type, or <code>null</code> to exclude the content type header
+     * @param out
+     *            The output stream
+     * @param boundary
+     *            the boundary
+     * @throws IOException
+     *             If an IO problem occurs.
      */
-    public void setContentType(String contentType) {
-        this.contentType = contentType;
+    public void write(OutputStream out, byte[] boundary) throws IOException {
+
+        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
+
+        visitStart(visitor, boundary);
+        visitDispositionHeader(visitor);
+        visitContentTypeHeader(visitor);
+        visitTransferEncodingHeader(visitor);
+        visitContentIdHeader(visitor);
+        visitEndOfHeader(visitor);
+        sendData(visitor.getOutputStream());
+        visitEnd(visitor);
     }
 
     /**
-     * Sets the part name.
+     * Return the full length of all the data. If you override this method make sure to override #send(OutputStream) as well
      * 
-     * @param name
+     * @return long The length.
      */
-    public void setName(String name) {
-        if (name == null) {
-            throw new IllegalArgumentException("Name must not be null");
+    public long length(byte[] boundary) {
+
+        long dataLength = getDataLength();
+        try {
+
+            if (dataLength < 0L) {
+                return -1L;
+            } else {
+                CounterPartVisitor visitor = new CounterPartVisitor();
+                visitStart(visitor, boundary);
+                visitDispositionHeader(visitor);
+                visitContentTypeHeader(visitor);
+                visitTransferEncodingHeader(visitor);
+                visitContentIdHeader(visitor);
+                visitEndOfHeader(visitor);
+                visitEnd(visitor);
+                return dataLength + visitor.getCount();
+            }
+        } catch (IOException e) {
+            // can't happen
+            throw new RuntimeException("IOException while computing length, WTF", e);
         }
-        this.name = name;
     }
 
-    /**
-     * Sets the transfer encoding.
-     * 
-     * @param transferEncoding the transfer encoding, or <code>null</code> to exclude the transfer encoding header
-     */
-    public void setTransferEncoding(String transferEncoding) {
-        this.transferEncoding = transferEncoding;
+    public String toString() {
+        return new StringBuilder()//
+                .append(getClass().getSimpleName())//
+                .append(" name=").append(getName())//
+                .append(" contentType=").append(getContentType())//
+                .append(" charset=").append(getCharset())//
+                .append(" tranferEncoding=").append(getTransferEncoding())//
+                .append(" contentId=").append(getContentId())//
+                .append(" dispositionType=").append(getDispositionType())//
+                .toString();
     }
 
+    @Override
+    public String getName() {
+        return this.name;
+    }
+
+    @Override
+    public String getContentType() {
+        return this.contentType;
+    }
+
+    @Override
+    public Charset getCharset() {
+        return this.charset;
+    }
+
+    @Override
+    public String getTransferEncoding() {
+        return transferEncoding;
+    }
+
+    @Override
     public String getContentId() {
         return contentId;
     }
 
-    public void setContentId(String contentId) {
-        this.contentId = contentId;
+    @Override
+    public String getDispositionType() {
+        return dispositionType;
+    }
+
+    public void setDispositionType(String dispositionType) {
+        this.dispositionType = dispositionType;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/PartSource.java b/api/src/main/java/org/asynchttpclient/multipart/PartSource.java
deleted file mode 100644
index 798ae16eb..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/PartSource.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- *
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public interface PartSource {
-
-    /**
-     * Gets the number of bytes contained in this source.
-     *
-     * @return a value >= 0
-     */
-    long getLength();
-
-    /**
-     * Gets the name of the file this source represents.
-     *
-     * @return the fileName used for posting a MultiPart file part
-     */
-    String getFileName();
-
-    /**
-     * Gets a new InputStream for reading this source.  This method can be
-     * called more than once and should therefore return a new stream every
-     * time.
-     *
-     * @return a new InputStream
-     * @throws java.io.IOException if an error occurs when creating the InputStream
-     */
-    InputStream createInputStream() throws IOException;
-
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java b/api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java
similarity index 63%
rename from providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java
rename to api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java
index c83043148..a7b8b8449 100644
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,15 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty_4;
+package org.asynchttpclient.multipart;
 
-import io.netty.channel.ChannelHandlerContext;
+import java.io.IOException;
 
-public interface Protocol<T> {
+public interface PartVisitor {
 
-    void handle(ChannelHandlerContext ctx, T message) throws Exception;
-
-    void onError(ChannelHandlerContext ctx, Throwable error);
-
-    void onClose(ChannelHandlerContext ctx);
+    void withBytes(byte[] bytes) throws IOException;
+    void withByte(byte b) throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java b/api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java
deleted file mode 100644
index 99bf7bbf4..000000000
--- a/api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.multipart;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- *
- * @link http://hc.apache.org/httpclient-3.x/
- */
-public interface RequestEntity {
-
-    /**
-     * Tests if {@link #writeRequest(java.io.OutputStream)} can be called more than once.
-     *
-     * @return <tt>true</tt> if the entity can be written to {@link java.io.OutputStream} more than once,
-     *         <tt>false</tt> otherwise.
-     */
-    boolean isRepeatable();
-
-    /**
-     * Writes the request entity to the given stream.
-     *
-     * @param out
-     * @throws java.io.IOException
-     */
-    void writeRequest(OutputStream out) throws IOException;
-
-    /**
-     * Gets the request entity's length. This method should return a non-negative value if the content
-     * length is known or a negative value if it is not. In the latter case the
-     * EntityEnclosingMethod will use chunk encoding to
-     * transmit the request entity.
-     *
-     * @return a non-negative value when content length is known or a negative value when content length
-     *         is not known
-     */
-    long getContentLength();
-
-    /**
-     * Gets the entity's content type.  This content type will be used as the value for the
-     * "Content-Type" header.
-     *
-     * @return the entity's content type
-     */
-    String getContentType();
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/StringPart.java b/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
index 447d54035..eb6b90b32 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
@@ -1,28 +1,25 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.multipart;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+
+import org.asynchttpclient.util.StandardCharsets;
 
-/**
- * This class is an adaptation of the Apache HttpClient implementation
- * 
- * @link http://hc.apache.org/httpclient-3.x/
- */
 public class StringPart extends PartBase {
 
     /**
@@ -33,7 +30,7 @@
     /**
      * Default charset of string parameters
      */
-    public static final String DEFAULT_CHARSET = "US-ASCII";
+    public static final Charset DEFAULT_CHARSET = StandardCharsets.US_ASCII;
 
     /**
      * Default transfer encoding of string parameters
@@ -43,88 +40,68 @@
     /**
      * Contents of this StringPart.
      */
-    private byte[] content;
-
-    /**
-     * The String value of this part.
-     */
-    private final String value;
-
-    /**
-     * Constructor.
-     * 
-     * @param name The name of the part
-     * @param value the string to post
-     * @param charset the charset to be used to encode the string, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
-     * @param contentId the content id
-     */
-    public StringPart(String name, String value, String charset, String contentId) {
+    private final byte[] content;
 
-        super(name, DEFAULT_CONTENT_TYPE, charset == null ? DEFAULT_CHARSET : charset, DEFAULT_TRANSFER_ENCODING, contentId);
-        if (value == null) {
-            throw new IllegalArgumentException("Value may not be null");
-        }
-        if (value.indexOf(0) != -1) {
-            // See RFC 2048, 2.8. "8bit Data"
-            throw new IllegalArgumentException("NULs may not be present in string parts");
-        }
-        this.value = value;
+    private static Charset charsetOrDefault(Charset charset) {
+        return charset == null ? DEFAULT_CHARSET : charset;
     }
 
-    public StringPart(String name, String value, String charset) {
+    public StringPart(String name, String value, Charset charset) {
         this(name, value, charset, null);
     }
 
     /**
      * Constructor.
      * 
-     * @param name The name of the part
-     * @param value the string to post
+     * @param name
+     *            The name of the part
+     * @param value
+     *            the string to post
+     * @param charset
+     *            the charset to be used to encode the string, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
+     * @param contentId
+     *            the content id
      */
-    public StringPart(String name, String value) {
-        this(name, value, null, null);
-    }
+    public StringPart(String name, String value, Charset charset, String contentId) {
 
-    /**
-     * Gets the content in bytes. Bytes are lazily created to allow the charset to be changed after the part is created.
-     * 
-     * @return the content in bytes
-     */
-    private byte[] getContent() {
-        if (content == null) {
-            content = MultipartEncodingUtil.getBytes(value, getCharSet());
-        }
-        return content;
+        super(name, DEFAULT_CONTENT_TYPE, charsetOrDefault(charset), DEFAULT_TRANSFER_ENCODING, contentId);
+        if (value == null)
+            throw new NullPointerException("value");
+        if (value.indexOf(0) != -1)
+            // See RFC 2048, 2.8. "8bit Data"
+            throw new IllegalArgumentException("NULs may not be present in string parts");
+        content = value.getBytes(charsetOrDefault(charset));
     }
 
     /**
      * Writes the data to the given OutputStream.
      * 
-     * @param out the OutputStream to write to
-     * @throws java.io.IOException if there is a write error
+     * @param out
+     *            the OutputStream to write to
+     * @throws java.io.IOException
+     *             if there is a write error
      */
     protected void sendData(OutputStream out) throws IOException {
-        out.write(getContent());
+        out.write(content);
     }
 
     /**
      * Return the length of the data.
      * 
      * @return The length of the data.
-     * @throws IOException If an IO problem occurs
      */
-    protected long lengthOfData() throws IOException {
-        return getContent().length;
+    protected long getDataLength() {
+        return content.length;
     }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
-     */
-    public void setCharSet(String charSet) {
-        super.setCharSet(charSet);
-        this.content = null;
+    public byte[] getBytes(byte[] boundary) throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        write(outputStream, boundary);
+        return outputStream.toByteArray();
     }
 
+    @Override
+    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
+        return MultipartUtils.writeBytesToChannel(target, getBytes(boundary));
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
index 00da92497..687759f75 100644
--- a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
@@ -1,15 +1,3 @@
-/*
- * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
 /*
  * ====================================================================
  *
@@ -39,9 +27,11 @@
 package org.asynchttpclient.ntlm;
 
 import org.asynchttpclient.util.Base64;
+import org.asynchttpclient.util.StandardCharsets;
 
 import javax.crypto.Cipher;
 import javax.crypto.spec.SecretKeySpec;
+
 import java.io.UnsupportedEncodingException;
 import java.security.Key;
 import java.security.MessageDigest;
@@ -91,6 +81,9 @@
      */
     private String credentialCharset = DEFAULT_CHARSET;
 
+    private static final byte[] NTLMSSP_BYTES = "NTLMSSP".getBytes(StandardCharsets.US_ASCII);
+    private static final byte[] MAGIC_CONSTANT = "KGS!@#$%".getBytes(StandardCharsets.US_ASCII);
+
     /**
      * The signature string as bytes in the default encoding
      */
@@ -98,16 +91,14 @@
 
     static {
         byte[] bytesWithoutNull = new byte[0];
-        try {
-            bytesWithoutNull = "NTLMSSP".getBytes("ASCII");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-        }
+        bytesWithoutNull = NTLMSSP_BYTES;
         SIGNATURE = new byte[bytesWithoutNull.length + 1];
         System.arraycopy(bytesWithoutNull, 0, SIGNATURE, 0, bytesWithoutNull.length);
         SIGNATURE[bytesWithoutNull.length] = (byte) 0x00;
     }
 
+    public static final NTLMEngine INSTANCE = new NTLMEngine();
+
     /**
      * Returns the response for the given message.
      *
@@ -119,16 +110,15 @@
      * @return The response.
      * @throws NTLMEngineException If the messages cannot be retrieved.
      */
-    final String getResponseFor(String message, String username, String password,
-                                String host, String domain) throws NTLMEngineException {
+    final String getResponseFor(String message, String username, String password, String host, String domain) throws NTLMEngineException {
 
         final String response;
         if (message == null || message.trim().length() == 0) {
             response = getType1Message(host, domain);
         } else {
             Type2Message t2m = new Type2Message(message);
-            response = getType3Message(username, password, host, domain, t2m.getChallenge(), t2m
-                    .getFlags(), t2m.getTarget(), t2m.getTargetInfo());
+            response = getType3Message(username, password, host, domain, t2m.getChallenge(), t2m.getFlags(), t2m.getTarget(),
+                    t2m.getTargetInfo());
         }
         return response;
     }
@@ -164,12 +154,10 @@ String getType1Message(String host, String domain) throws NTLMEngineException {
      * @return The type 3 message.
      * @throws NTLMEngineException If {@encrypt(byte[],byte[])} fails.
      */
-    String getType3Message(String user, String password, String host, String domain,
-                           byte[] nonce, int type2Flags, String target, byte[] targetInformation)
-            throws NTLMEngineException {
+    String getType3Message(String user, String password, String host, String domain, byte[] nonce, int type2Flags, String target,
+            byte[] targetInformation) throws NTLMEngineException {
         try {
-            return new Type3Message(domain, host, user, password, nonce, type2Flags, target,
-                    targetInformation).getResponse();
+            return new Type3Message(domain, host, user, password, nonce, type2Flags, target, targetInformation).getResponse();
         } catch (UnsupportedEncodingException e) {
             throw new NTLMEngineException("Unsupported encoding", e);
         }
@@ -216,8 +204,7 @@ private static String convertDomain(String domain) {
     private static int readULong(byte[] src, int index) throws NTLMEngineException {
         if (src.length < index + 4)
             throw new NTLMEngineException("NTLM authentication - buffer too small for DWORD");
-        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8)
-                | ((src[index + 2] & 0xff) << 16) | ((src[index + 3] & 0xff) << 24);
+        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8) | ((src[index + 2] & 0xff) << 16) | ((src[index + 3] & 0xff) << 24);
     }
 
     private static int readUShort(byte[] src, int index) throws NTLMEngineException {
@@ -230,8 +217,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
         int length = readUShort(src, index);
         int offset = readULong(src, index + 4);
         if (src.length < offset + length)
-            throw new NTLMEngineException(
-                    "NTLM authentication - buffer too small for data item");
+            throw new NTLMEngineException("NTLM authentication - buffer too small for data item");
         byte[] buffer = new byte[length];
         System.arraycopy(src, offset, buffer, 0, length);
         return buffer;
@@ -275,8 +261,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @param challenge The Type 2 challenge from the server.
      * @return The LM Response.
      */
-    static byte[] getLMResponse(String password, byte[] challenge)
-            throws NTLMEngineException {
+    static byte[] getLMResponse(String password, byte[] challenge) throws NTLMEngineException {
         byte[] lmHash = lmHash(password);
         return lmResponse(lmHash, challenge);
     }
@@ -289,8 +274,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @param challenge The Type 2 challenge from the server.
      * @return The NTLM Response.
      */
-    static byte[] getNTLMResponse(String password, byte[] challenge)
-            throws NTLMEngineException {
+    static byte[] getNTLMResponse(String password, byte[] challenge) throws NTLMEngineException {
         byte[] ntlmHash = ntlmHash(password);
         return lmResponse(ntlmHash, challenge);
     }
@@ -308,9 +292,8 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @param clientChallenge   The random 8-byte client challenge.
      * @return The NTLMv2 Response.
      */
-    static byte[] getNTLMv2Response(String target, String user, String password,
-                                    byte[] challenge, byte[] clientChallenge, byte[] targetInformation)
-            throws NTLMEngineException {
+    static byte[] getNTLMv2Response(String target, String user, String password, byte[] challenge, byte[] clientChallenge,
+            byte[] targetInformation) throws NTLMEngineException {
         byte[] ntlmv2Hash = ntlmv2Hash(target, user, password);
         byte[] blob = createBlob(clientChallenge, targetInformation);
         return lmv2Response(ntlmv2Hash, challenge, blob);
@@ -327,8 +310,8 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @param clientChallenge The random 8-byte client challenge.
      * @return The LMv2 Response.
      */
-    static byte[] getLMv2Response(String target, String user, String password,
-                                  byte[] challenge, byte[] clientChallenge) throws NTLMEngineException {
+    static byte[] getLMv2Response(String target, String user, String password, byte[] challenge, byte[] clientChallenge)
+            throws NTLMEngineException {
         byte[] ntlmv2Hash = ntlmv2Hash(target, user, password);
         return lmv2Response(ntlmv2Hash, challenge, clientChallenge);
     }
@@ -344,8 +327,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      *         field of the Type 3 message; the LM response field contains the
      *         client challenge, null-padded to 24 bytes.
      */
-    static byte[] getNTLM2SessionResponse(String password, byte[] challenge,
-                                          byte[] clientChallenge) throws NTLMEngineException {
+    static byte[] getNTLM2SessionResponse(String password, byte[] challenge, byte[] clientChallenge) throws NTLMEngineException {
         try {
             byte[] ntlmHash = ntlmHash(password);
 
@@ -386,18 +368,17 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      */
     private static byte[] lmHash(String password) throws NTLMEngineException {
         try {
-            byte[] oemPassword = password.toUpperCase(Locale.ENGLISH).getBytes("US-ASCII");
+            byte[] oemPassword = password.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.US_ASCII);
             int length = Math.min(oemPassword.length, 14);
             byte[] keyBytes = new byte[14];
             System.arraycopy(oemPassword, 0, keyBytes, 0, length);
             Key lowKey = createDESKey(keyBytes, 0);
             Key highKey = createDESKey(keyBytes, 7);
-            byte[] magicConstant = "KGS!@#$%".getBytes("US-ASCII");
             Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
             des.init(Cipher.ENCRYPT_MODE, lowKey);
-            byte[] lowHash = des.doFinal(magicConstant);
+            byte[] lowHash = des.doFinal(MAGIC_CONSTANT);
             des.init(Cipher.ENCRYPT_MODE, highKey);
-            byte[] highHash = des.doFinal(magicConstant);
+            byte[] highHash = des.doFinal(MAGIC_CONSTANT);
             byte[] lmHash = new byte[16];
             System.arraycopy(lowHash, 0, lmHash, 0, 8);
             System.arraycopy(highHash, 0, lmHash, 8, 8);
@@ -415,14 +396,10 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      *         the NTLM Response and the NTLMv2 and LMv2 Hashes.
      */
     private static byte[] ntlmHash(String password) throws NTLMEngineException {
-        try {
-            byte[] unicodePassword = password.getBytes("UnicodeLittleUnmarked");
-            MD4 md4 = new MD4();
-            md4.update(unicodePassword);
-            return md4.getOutput();
-        } catch (java.io.UnsupportedEncodingException e) {
-            throw new NTLMEngineException("Unicode not supported: " + e.getMessage(), e);
-        }
+        byte[] unicodePassword = password.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
+        MD4 md4 = new MD4();
+        md4.update(unicodePassword);
+        return md4.getOutput();
     }
 
     /**
@@ -434,18 +411,13 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @return The NTLMv2 Hash, used in the calculation of the NTLMv2 and LMv2
      *         Responses.
      */
-    private static byte[] ntlmv2Hash(String target, String user, String password)
-            throws NTLMEngineException {
-        try {
-            byte[] ntlmHash = ntlmHash(password);
-            HMACMD5 hmacMD5 = new HMACMD5(ntlmHash);
-            // Upper case username, mixed case target!!
-            hmacMD5.update(user.toUpperCase(Locale.ENGLISH).getBytes("UnicodeLittleUnmarked"));
-            hmacMD5.update(target.getBytes("UnicodeLittleUnmarked"));
-            return hmacMD5.getOutput();
-        } catch (java.io.UnsupportedEncodingException e) {
-            throw new NTLMEngineException("Unicode not supported! " + e.getMessage(), e);
-        }
+    private static byte[] ntlmv2Hash(String target, String user, String password) throws NTLMEngineException {
+        byte[] ntlmHash = ntlmHash(password);
+        HMACMD5 hmacMD5 = new HMACMD5(ntlmHash);
+        // Upper case username, mixed case target!!
+        hmacMD5.update(user.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED));
+        hmacMD5.update(target.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED));
+        return hmacMD5.getOutput();
     }
 
     /**
@@ -489,8 +461,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @return The response (either NTLMv2 or LMv2, depending on the client
      *         data).
      */
-    private static byte[] lmv2Response(byte[] hash, byte[] challenge, byte[] clientData)
-            throws NTLMEngineException {
+    private static byte[] lmv2Response(byte[] hash, byte[] challenge, byte[] clientData) throws NTLMEngineException {
         HMACMD5 hmacMD5 = new HMACMD5(hash);
         hmacMD5.update(challenge);
         hmacMD5.update(clientData);
@@ -510,9 +481,9 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
      * @return The blob, used in the calculation of the NTLMv2 Response.
      */
     private static byte[] createBlob(byte[] clientChallenge, byte[] targetInformation) {
-        byte[] blobSignature = new byte[]{(byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00};
-        byte[] reserved = new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};
-        byte[] unknown1 = new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};
+        byte[] blobSignature = new byte[] { (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00 };
+        byte[] reserved = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
+        byte[] unknown1 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
         long time = System.currentTimeMillis();
         time += 11644473600000l; // milliseconds from January 1, 1601 -> epoch.
         time *= 10000; // tenths of a microsecond.
@@ -522,8 +493,7 @@ private static int readUShort(byte[] src, int index) throws NTLMEngineException
             timestamp[i] = (byte) time;
             time >>>= 8;
         }
-        byte[] blob = new byte[blobSignature.length + reserved.length + timestamp.length + 8
-                + unknown1.length + targetInformation.length];
+        byte[] blob = new byte[blobSignature.length + reserved.length + timestamp.length + 8 + unknown1.length + targetInformation.length];
         int offset = 0;
         System.arraycopy(blobSignature, 0, blob, offset, blobSignature.length);
         offset += blobSignature.length;
@@ -572,8 +542,7 @@ private static Key createDESKey(byte[] bytes, int offset) {
     private static void oddParity(byte[] bytes) {
         for (int i = 0; i < bytes.length; i++) {
             byte b = bytes[i];
-            boolean needsParity = (((b >>> 7) ^ (b >>> 6) ^ (b >>> 5) ^ (b >>> 4) ^ (b >>> 3)
-                    ^ (b >>> 2) ^ (b >>> 1)) & 0x01) == 0;
+            boolean needsParity = (((b >>> 7) ^ (b >>> 6) ^ (b >>> 5) ^ (b >>> 4) ^ (b >>> 3) ^ (b >>> 2) ^ (b >>> 1)) & 0x01) == 0;
             if (needsParity) {
                 bytes[i] |= (byte) 0x01;
             } else {
@@ -614,16 +583,15 @@ private static void oddParity(byte[] bytes) {
             int i = 0;
             while (i < SIGNATURE.length) {
                 if (messageContents[i] != SIGNATURE[i])
-                    throw new NTLMEngineException(
-                            "NTLM message expected - instead got unrecognized bytes");
+                    throw new NTLMEngineException("NTLM message expected - instead got unrecognized bytes");
                 i++;
             }
 
             // Check to be sure there's a type 2 message indicator next
             int type = readULong(SIGNATURE.length);
             if (type != expectedType)
-                throw new NTLMEngineException("NTLM type " + Integer.toString(expectedType)
-                        + " message expected - instead got type " + Integer.toString(type));
+                throw new NTLMEngineException("NTLM type " + Integer.toString(expectedType) + " message expected - instead got type "
+                        + Integer.toString(type));
 
             currentOutputPosition = messageContents.length;
         }
@@ -770,17 +738,13 @@ String getResponse() throws UnsupportedEncodingException {
          */
         Type1Message(String domain, String host) throws NTLMEngineException {
             super();
-            try {
-                // Strip off domain name from the host!
-                host = convertHost(host);
-                // Use only the base domain name!
-                domain = convertDomain(domain);
-
-                hostBytes = host.getBytes("UnicodeLittleUnmarked");
-                domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes("UnicodeLittleUnmarked");
-            } catch (java.io.UnsupportedEncodingException e) {
-                throw new NTLMEngineException("Unicode unsupported: " + e.getMessage(), e);
-            }
+            // Strip off domain name from the host!
+            host = convertHost(host);
+            // Use only the base domain name!
+            domain = convertDomain(domain);
+
+            hostBytes = host.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
+            domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
         }
 
         /**
@@ -798,12 +762,11 @@ String getResponse() throws UnsupportedEncodingException {
             prepareResponse(finalLength, 1);
 
             // Flags. These are the complete set of flags we support.
-            addULong(FLAG_NEGOTIATE_NTLM | FLAG_NEGOTIATE_NTLM2 | FLAG_NEGOTIATE_SIGN
-                    | FLAG_NEGOTIATE_SEAL |
-                    /*
-                     * FLAG_NEGOTIATE_ALWAYS_SIGN | FLAG_NEGOTIATE_KEY_EXCH |
-                     */
-                    FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED | FLAG_NEGOTIATE_128);
+            addULong(FLAG_NEGOTIATE_NTLM | FLAG_NEGOTIATE_NTLM2 | FLAG_NEGOTIATE_SIGN | FLAG_NEGOTIATE_SEAL |
+            /*
+             * FLAG_NEGOTIATE_ALWAYS_SIGN | FLAG_NEGOTIATE_KEY_EXCH |
+             */
+            FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED | FLAG_NEGOTIATE_128);
 
             // Domain length (two times).
             addUShort(domainBytes.length);
@@ -849,9 +812,7 @@ String getResponse() throws UnsupportedEncodingException {
 
             flags = readULong(20);
             if ((flags & FLAG_UNICODE_ENCODING) == 0)
-                throw new NTLMEngineException(
-                        "NTLM type 2 message has flags that make no sense: "
-                                + Integer.toString(flags));
+                throw new NTLMEngineException("NTLM type 2 message has flags that make no sense: " + Integer.toString(flags));
             // Do the target!
             target = null;
             // The TARGET_DESIRED flag is said to not have understood semantics
@@ -860,11 +821,7 @@ String getResponse() throws UnsupportedEncodingException {
             if (getMessageLength() >= 12 + 8) {
                 byte[] bytes = readSecurityBuffer(12);
                 if (bytes.length != 0) {
-                    try {
-                        target = new String(bytes, "UnicodeLittleUnmarked");
-                    } catch (java.io.UnsupportedEncodingException e) {
-                        throw new NTLMEngineException(e.getMessage(), e);
-                    }
+                    target = new String(bytes, StandardCharsets.UNICODE_LITTLE_UNMARKED);
                 }
             }
 
@@ -926,9 +883,8 @@ int getFlags() {
         /**
          * Constructor. Pass the arguments we will need
          */
-        Type3Message(String domain, String host, String user, String password, byte[] nonce,
-                     int type2Flags, String target, byte[] targetInformation)
-                throws NTLMEngineException {
+        Type3Message(String domain, String host, String user, String password, byte[] nonce, int type2Flags, String target,
+                byte[] targetInformation) throws NTLMEngineException {
             // Save the flags
             this.type2Flags = type2Flags;
 
@@ -942,8 +898,7 @@ int getFlags() {
             try {
                 if (targetInformation != null && target != null) {
                     byte[] clientChallenge = makeRandomChallenge();
-                    ntResp = getNTLMv2Response(target, user, password, nonce, clientChallenge,
-                            targetInformation);
+                    ntResp = getNTLMv2Response(target, user, password, nonce, clientChallenge, targetInformation);
                     lmResp = getLMv2Response(target, user, password, nonce, clientChallenge);
                 } else {
                     if ((type2Flags & FLAG_NEGOTIATE_NTLM2) != 0) {
@@ -969,13 +924,9 @@ int getFlags() {
                 lmResp = getLMResponse(password, nonce);
             }
 
-            try {
-                domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes("UnicodeLittleUnmarked");
-                hostBytes = host.getBytes("UnicodeLittleUnmarked");
-                userBytes = user.getBytes("UnicodeLittleUnmarked");
-            } catch (java.io.UnsupportedEncodingException e) {
-                throw new NTLMEngineException("Unicode not supported: " + e.getMessage(), e);
-            }
+            domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
+            hostBytes = host.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
+            userBytes = user.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
         }
 
         /**
@@ -1044,11 +995,9 @@ String getResponse() throws UnsupportedEncodingException {
 
             // Flags. Currently: NEGOTIATE_NTLM + UNICODE_ENCODING +
             // TARGET_DESIRED + NEGOTIATE_128
-            addULong(FLAG_NEGOTIATE_NTLM | FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED
-                    | FLAG_NEGOTIATE_128 | (type2Flags & FLAG_NEGOTIATE_NTLM2)
-                    | (type2Flags & FLAG_NEGOTIATE_SIGN) | (type2Flags & FLAG_NEGOTIATE_SEAL)
-                    | (type2Flags & FLAG_NEGOTIATE_KEY_EXCH)
-                    | (type2Flags & FLAG_NEGOTIATE_ALWAYS_SIGN));
+            addULong(FLAG_NEGOTIATE_NTLM | FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED | FLAG_NEGOTIATE_128
+                    | (type2Flags & FLAG_NEGOTIATE_NTLM2) | (type2Flags & FLAG_NEGOTIATE_SIGN) | (type2Flags & FLAG_NEGOTIATE_SEAL)
+                    | (type2Flags & FLAG_NEGOTIATE_KEY_EXCH) | (type2Flags & FLAG_NEGOTIATE_ALWAYS_SIGN));
 
             // Add the actual data
             addBytes(lmResp);
@@ -1160,8 +1109,7 @@ protected void processBuffer() {
             int[] d = new int[16];
 
             for (int i = 0; i < 16; i++) {
-                d[i] = (dataBuffer[i * 4] & 0xff) + ((dataBuffer[i * 4 + 1] & 0xff) << 8)
-                        + ((dataBuffer[i * 4 + 2] & 0xff) << 16)
+                d[i] = (dataBuffer[i * 4] & 0xff) + ((dataBuffer[i * 4 + 1] & 0xff) << 8) + ((dataBuffer[i * 4 + 2] & 0xff) << 16)
                         + ((dataBuffer[i * 4 + 3] & 0xff) << 24);
             }
 
@@ -1265,8 +1213,7 @@ protected void round3(int[] d) {
             } catch (Exception ex) {
                 // Umm, the algorithm doesn't exist - throw an
                 // NTLMEngineException!
-                throw new NTLMEngineException(
-                        "Error getting md5 message digest implementation: " + ex.getMessage(), ex);
+                throw new NTLMEngineException("Error getting md5 message digest implementation: " + ex.getMessage(), ex);
             }
 
             // Initialize the pad buffers with the key
@@ -1323,27 +1270,14 @@ void update(byte[] input, int offset, int length) {
 
     }
 
-    public String generateType1Msg(
-            final String domain,
-            final String workstation) throws NTLMEngineException {
+    public String generateType1Msg(final String domain, final String workstation) throws NTLMEngineException {
         return getType1Message(workstation, domain);
     }
 
-    public String generateType3Msg(
-            final String username,
-            final String password,
-            final String domain,
-            final String workstation,
+    public String generateType3Msg(final String username, final String password, final String domain, final String workstation,
             final String challenge) throws NTLMEngineException {
         Type2Message t2m = new Type2Message(challenge);
-        return getType3Message(
-                username,
-                password,
-                workstation,
-                domain,
-                t2m.getChallenge(),
-                t2m.getFlags(),
-                t2m.getTarget(),
+        return getType3Message(username, password, workstation, domain, t2m.getChallenge(), t2m.getFlags(), t2m.getTarget(),
                 t2m.getTargetInfo());
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
index 25d3f162e..a7fd1da9f 100644
--- a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
@@ -1,15 +1,3 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
 /*
  * ====================================================================
  *
diff --git a/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java b/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
index 5b270ac2d..196279833 100644
--- a/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
@@ -63,8 +63,10 @@ public int hashCode() {
 
     @Override
     public boolean equals(Object o) {
-        if (o == this) return true;
-        if (o == null || o.getClass() != getClass()) return false;
+        if (o == this)
+            return true;
+        if (o == null || o.getClass() != getClass())
+            return false;
         ConsumerKey other = (ConsumerKey) o;
         return key.equals(other.key) && secret.equals(other.secret);
     }
diff --git a/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index cd2508894..86d860141 100644
--- a/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -16,18 +16,20 @@
  */
 package org.asynchttpclient.oauth;
 
-import org.asynchttpclient.FluentStringsMap;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
+import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.UTF8Codec;
+import org.asynchttpclient.util.StandardCharsets;
 import org.asynchttpclient.util.UTF8UrlEncoder;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 
 /**
@@ -40,8 +42,7 @@
  *
  * @author tatu (tatu.saloranta@iki.fi)
  */
-public class OAuthSignatureCalculator
-        implements SignatureCalculator {
+public class OAuthSignatureCalculator implements SignatureCalculator {
     public final static String HEADER_AUTHORIZATION = "Authorization";
 
     private static final String KEY_OAUTH_CONSUMER_KEY = "oauth_consumer_key";
@@ -82,11 +83,10 @@ public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth)
 
     //@Override // silly 1.5; doesn't allow this for interfaces
 
-    public void calculateAndAddSignature(String baseURL, Request request, RequestBuilderBase<?> requestBuilder) {
-        String method = request.getMethod(); // POST etc
+    public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
         String nonce = generateNonce();
         long timestamp = System.currentTimeMillis() / 1000L;
-        String signature = calculateSignature(method, baseURL, timestamp, nonce, request.getParams(), request.getQueryParams());
+        String signature = calculateSignature(request.getMethod(), request.getUri(), timestamp, nonce, request.getFormParams(), request.getQueryParams());
         String headerValue = constructAuthHeader(signature, nonce, timestamp);
         requestBuilder.setHeader(HEADER_AUTHORIZATION, headerValue);
     }
@@ -94,8 +94,8 @@ public void calculateAndAddSignature(String baseURL, Request request, RequestBui
     /**
      * Method for calculating OAuth signature using HMAC/SHA-1 method.
      */
-    public String calculateSignature(String method, String baseURL, long oauthTimestamp, String nonce,
-                                     FluentStringsMap formParams, FluentStringsMap queryParams) {
+    public String calculateSignature(String method, Uri uri, long oauthTimestamp, String nonce,
+                                     List<Param> formParams, List<Param> queryParams) {
         StringBuilder signedText = new StringBuilder(100);
         signedText.append(method); // POST / GET etc (nothing to URL encode)
         signedText.append('&');
@@ -103,18 +103,23 @@ public String calculateSignature(String method, String baseURL, long oauthTimest
         /* 07-Oct-2010, tatu: URL may contain default port number; if so, need to extract
          *   from base URL.
          */
-        if (baseURL.startsWith("http:")) {
-            int i = baseURL.indexOf(":80/", 4);
-            if (i > 0) {
-                baseURL = baseURL.substring(0, i) + baseURL.substring(i + 3);
-            }
-        } else if (baseURL.startsWith("https:")) {
-            int i = baseURL.indexOf(":443/", 5);
-            if (i > 0) {
-                baseURL = baseURL.substring(0, i) + baseURL.substring(i + 4);
-            }
-        }
-        signedText.append(UTF8UrlEncoder.encode(baseURL));
+        String scheme = uri.getScheme();
+        int port = uri.getPort();
+        if (scheme.equals("http"))
+            if (port == 80)
+                port = -1;
+        else if (scheme.equals("https"))
+            if (port == 443)
+                port = -1;
+        
+        StringBuilder sb = new StringBuilder().append(scheme).append("://").append(uri.getHost());
+        if (port != -1)
+            sb.append(':').append(port);
+        if (isNonEmpty(uri.getPath()))
+            sb.append(uri.getPath());
+        
+        String baseURL = sb.toString();
+        UTF8UrlEncoder.appendEncoded(signedText, baseURL);
 
         /**
          * List of all query and form parameters added to this request; needed
@@ -127,23 +132,19 @@ public String calculateSignature(String method, String baseURL, long oauthTimest
         allParameters.add(KEY_OAUTH_NONCE, nonce);
         allParameters.add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD);
         allParameters.add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
-        allParameters.add(KEY_OAUTH_TOKEN, userAuth.getKey());
+        if (userAuth.getKey() != null) {
+            allParameters.add(KEY_OAUTH_TOKEN, userAuth.getKey());
+        }
         allParameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
 
         if (formParams != null) {
-            for (Map.Entry<String, List<String>> entry : formParams) {
-                String key = entry.getKey();
-                for (String value : entry.getValue()) {
-                    allParameters.add(key, value);
-                }
+            for (Param param : formParams) {
+                allParameters.add(param.getName(), param.getValue());
             }
         }
         if (queryParams != null) {
-            for (Map.Entry<String, List<String>> entry : queryParams) {
-                String key = entry.getKey();
-                for (String value : entry.getValue()) {
-                    allParameters.add(key, value);
-                }
+            for (Param param : queryParams) {
+                allParameters.add(param.getName(), param.getValue());
             }
         }
         String encodedParams = allParameters.sortAndConcat();
@@ -152,7 +153,7 @@ public String calculateSignature(String method, String baseURL, long oauthTimest
         signedText.append('&');
         UTF8UrlEncoder.appendEncoded(signedText, encodedParams);
 
-        byte[] rawBase = UTF8Codec.toUTF8(signedText.toString());
+        byte[] rawBase = signedText.toString().getBytes(StandardCharsets.UTF_8);
         byte[] rawSignature = mac.digest(rawBase);
         // and finally, base64 encoded... phew!
         return Base64.encode(rawSignature);
@@ -165,7 +166,9 @@ public String constructAuthHeader(String signature, String nonce, long oauthTime
         StringBuilder sb = new StringBuilder(200);
         sb.append("OAuth ");
         sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getKey()).append("\", ");
-        sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getKey()).append("\", ");
+        if (userAuth.getKey() != null) {
+            sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getKey()).append("\", ");
+        }
         sb.append(KEY_OAUTH_SIGNATURE_METHOD).append("=\"").append(OAUTH_SIGNATURE_METHOD).append("\", ");
 
         // careful: base64 has chars that need URL encoding:
diff --git a/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java b/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
index 78b3758b4..2fd02c424 100644
--- a/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
@@ -65,8 +65,10 @@ public int hashCode() {
 
     @Override
     public boolean equals(Object o) {
-        if (o == this) return true;
-        if (o == null || o.getClass() != getClass()) return false;
+        if (o == this)
+            return true;
+        if (o == null || o.getClass() != getClass())
+            return false;
         RequestToken other = (RequestToken) o;
         return key.equals(other.key) && secret.equals(other.secret);
     }
diff --git a/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
index 784583f1b..028020f75 100644
--- a/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
@@ -16,8 +16,8 @@
  */
 package org.asynchttpclient.oauth;
 
+import org.asynchttpclient.util.StandardCharsets;
 import org.asynchttpclient.util.UTF8UrlEncoder;
-import org.asynchttpclient.util.UTF8Codec;
 
 import javax.crypto.Mac;
 import javax.crypto.spec.SecretKeySpec;
@@ -37,7 +37,8 @@
     private final Mac mac;
 
     public ThreadSafeHMAC(ConsumerKey consumerAuth, RequestToken userAuth) {
-        byte[] keyBytes = UTF8Codec.toUTF8(UTF8UrlEncoder.encode(consumerAuth.getSecret()) + "&" + UTF8UrlEncoder.encode(userAuth.getSecret()));
+        byte[] keyBytes = (UTF8UrlEncoder.encode(consumerAuth.getSecret()) + "&" + UTF8UrlEncoder.encode(userAuth.getSecret()))
+                .getBytes(StandardCharsets.UTF_8);
         SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
 
         // Get an hmac_sha1 instance and initialize with the signing key
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java
deleted file mode 100644
index 2b33cbf97..000000000
--- a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.org.jboss.netty.handler.codec.http;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import java.util.HashSet;
-
-import org.asynchttpclient.org.jboss.netty.util.internal.StringUtil;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
-/**
- * Decodes an HTTP header value into {@link Cookie}s. This decoder can decode the HTTP cookie version 0, 1, and 2.
- * 
- * <pre>
- * {@link HttpRequest} req = ...;
- * String value = req.getHeader("Cookie");
- * Set&lt;{@link Cookie}&gt; cookies = new {@link CookieDecoder}().decode(value);
- * </pre>
- * 
- * @see CookieEncoder
- * 
- * @apiviz.stereotype utility
- * @apiviz.has org.jboss.netty.handler.codec.http.Cookie oneway - - decodes
- */
-public class CookieDecoder {
-
-    private static final char COMMA = ',';
-
-    /**
-     * Creates a new decoder.
-     */
-    private CookieDecoder() {
-    }
-
-    /**
-     * Decodes the specified HTTP header value into {@link Cookie}s.
-     * 
-     * @return the decoded {@link Cookie}s
-     */
-    public static Set<Cookie> decode(String header) {
-        List<String> names = new ArrayList<String>(8);
-        List<String> values = new ArrayList<String>(8);
-        List<String> rawValues = new ArrayList<String>(8);
-        extractKeyValuePairs(header, names, values, rawValues);
-
-        if (names.isEmpty()) {
-            return Collections.emptySet();
-        }
-
-        int i;
-        int version = 0;
-
-        // $Version is the only attribute that can appear before the actual
-        // cookie name-value pair.
-        if (names.get(0).equalsIgnoreCase(CookieHeaderNames.VERSION)) {
-            try {
-                version = Integer.parseInt(values.get(0));
-            } catch (NumberFormatException e) {
-                // Ignore.
-            }
-            i = 1;
-        } else {
-            i = 0;
-        }
-
-        if (names.size() <= i) {
-            // There's a version attribute, but nothing more.
-            return Collections.emptySet();
-        }
-
-        Set<Cookie> cookies = new HashSet<Cookie>();
-        for (; i < names.size(); i++) {
-            String name = names.get(i);
-            String value = values.get(i);
-            String rawValue = rawValues.get(i);
-            if (value == null) {
-                value = "";
-            }
-            if (rawValue == null) {
-                rawValue = "";
-            }
-
-            String cookieName = name;
-            String cookieValue = value;
-            String cookieRawValue = rawValue;
-            boolean discard = false;
-            boolean secure = false;
-            boolean httpOnly = false;
-            String comment = null;
-            String commentURL = null;
-            String domain = null;
-            String path = null;
-            int maxAge = -1;
-            List<Integer> ports = Collections.emptyList();
-
-            for (int j = i + 1; j < names.size(); j++, i++) {
-                name = names.get(j);
-                value = values.get(j);
-
-                if (CookieHeaderNames.DISCARD.equalsIgnoreCase(name)) {
-                    discard = true;
-                } else if (CookieHeaderNames.SECURE.equalsIgnoreCase(name)) {
-                    secure = true;
-                } else if (CookieHeaderNames.HTTPONLY.equalsIgnoreCase(name)) {
-                    httpOnly = true;
-                } else if (CookieHeaderNames.COMMENT.equalsIgnoreCase(name)) {
-                    comment = value;
-                } else if (CookieHeaderNames.COMMENTURL.equalsIgnoreCase(name)) {
-                    commentURL = value;
-                } else if (CookieHeaderNames.DOMAIN.equalsIgnoreCase(name)) {
-                    domain = value;
-                } else if (CookieHeaderNames.PATH.equalsIgnoreCase(name)) {
-                    path = value;
-                } else if (CookieHeaderNames.EXPIRES.equalsIgnoreCase(name)) {
-                    try {
-                        maxAge = AsyncHttpProviderUtils.convertExpireField(value);
-                    } catch (Exception e) {
-                        // original behavior, is this correct at all (expires field with max-age semantics)?
-                        try {
-                            maxAge = Math.max(Integer.valueOf(value), 0);
-                        } catch (NumberFormatException e1) {
-                            // ignore failure to parse -> treat as session cookie
-                        }
-                    }
-                } else if (CookieHeaderNames.MAX_AGE.equalsIgnoreCase(name)) {
-                    maxAge = Integer.parseInt(value);
-                } else if (CookieHeaderNames.VERSION.equalsIgnoreCase(name)) {
-                    version = Integer.parseInt(value);
-                } else if (CookieHeaderNames.PORT.equalsIgnoreCase(name)) {
-                    String[] portList = StringUtil.split(value, COMMA);
-                    ports = new ArrayList<Integer>(2);
-                    for (String s1 : portList) {
-                        try {
-                            ports.add(Integer.valueOf(s1));
-                        } catch (NumberFormatException e) {
-                            // Ignore.
-                        }
-                    }
-                } else {
-                    break;
-                }
-            }
-
-            Cookie c = new Cookie(domain, cookieName, cookieValue, cookieRawValue, path, maxAge, secure, version, httpOnly, discard, comment, commentURL, ports);
-            cookies.add(c);
-        }
-
-        return cookies;
-    }
-
-    private static void extractKeyValuePairs(final String header, final List<String> names, final List<String> values, final List<String> rawValues) {
-
-        final int headerLen = header.length();
-        loop: for (int i = 0;;) {
-
-            // Skip spaces and separators.
-            for (;;) {
-                if (i == headerLen) {
-                    break loop;
-                }
-                switch (header.charAt(i)) {
-                case '\t':
-                case '\n':
-                case 0x0b:
-                case '\f':
-                case '\r':
-                case ' ':
-                case ',':
-                case ';':
-                    i++;
-                    continue;
-                }
-                break;
-            }
-
-            // Skip '$'.
-            for (;;) {
-                if (i == headerLen) {
-                    break loop;
-                }
-                if (header.charAt(i) == '$') {
-                    i++;
-                    continue;
-                }
-                break;
-            }
-
-            String name;
-            String value;
-            String rawValue;
-
-            if (i == headerLen) {
-                name = null;
-                value = null;
-                rawValue = null;
-            } else {
-                int newNameStart = i;
-                keyValLoop: for (;;) {
-                    switch (header.charAt(i)) {
-                    case ';':
-                        // NAME; (no value till ';')
-                        name = header.substring(newNameStart, i);
-                        value = null;
-                        rawValue = null;
-                        break keyValLoop;
-                    case '=':
-                        // NAME=VALUE
-                        name = header.substring(newNameStart, i);
-                        i++;
-                        if (i == headerLen) {
-                            // NAME= (empty value, i.e. nothing after '=')
-                            value = "";
-                            rawValue = "";
-                            break keyValLoop;
-                        }
-
-                        int newValueStart = i;
-                        char c = header.charAt(i);
-                        if (c == '"' || c == '\'') {
-                            // NAME="VALUE" or NAME='VALUE'
-                            StringBuilder newValueBuf = new StringBuilder(header.length() - i);
-                            StringBuilder newRawValueBuf = new StringBuilder(header.length() - i);
-                            newRawValueBuf.append(c);
-                            final char q = c;
-                            boolean hadBackslash = false;
-                            i++;
-                            for (;;) {
-                                if (i == headerLen) {
-                                    value = newValueBuf.toString();
-                                    rawValue = newRawValueBuf.toString();
-                                    break keyValLoop;
-                                }
-                                if (hadBackslash) {
-                                    hadBackslash = false;
-                                    c = header.charAt(i++);
-                                    newRawValueBuf.append(c);
-                                    switch (c) {
-                                    case '\\':
-                                    case '"':
-                                    case '\'':
-                                        // Escape last backslash.
-                                        newValueBuf.setCharAt(newValueBuf.length() - 1, c);
-                                        break;
-                                    default:
-                                        // Do not escape last backslash.
-                                        newValueBuf.append(c);
-                                    }
-                                } else {
-                                    c = header.charAt(i++);
-                                    newRawValueBuf.append(c);
-                                    if (c == q) {
-                                        value = newValueBuf.toString();
-                                        rawValue = newRawValueBuf.toString();
-                                        break keyValLoop;
-                                    }
-                                    newValueBuf.append(c);
-                                    if (c == '\\') {
-                                        hadBackslash = true;
-                                    }
-                                }
-                            }
-                        } else {
-                            // NAME=VALUE;
-                            int semiPos = header.indexOf(';', i);
-                            if (semiPos > 0) {
-                                value = rawValue = header.substring(newValueStart, semiPos);
-                                i = semiPos;
-                            } else {
-                                value = rawValue = header.substring(newValueStart);
-                                i = headerLen;
-                            }
-                        }
-                        break keyValLoop;
-                    default:
-                        i++;
-                    }
-
-                    if (i == headerLen) {
-                        // NAME (no value till the end of string)
-                        name = header.substring(newNameStart);
-                        value = rawValue = null;
-                        break;
-                    }
-                }
-            }
-
-            names.add(name);
-            values.add(value);
-            rawValues.add(rawValue);
-        }
-    }
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java
deleted file mode 100644
index 7a8ff6768..000000000
--- a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.org.jboss.netty.handler.codec.http;
-
-import java.util.Collection;
-
-import org.asynchttpclient.Cookie;
-
-/**
- * Encodes {@link Cookie}s into an HTTP header value.  This encoder can encode
- * the HTTP cookie version 0, 1, and 2.
- * <p>
- * This encoder is stateful.  It maintains an internal data structure that
- * holds the {@link Cookie}s added by the {@link #addCookie(String, String)}
- * method.  Once {@link #encode()} is called, all added {@link Cookie}s are
- * encoded into an HTTP header value and all {@link Cookie}s in the internal
- * data structure are removed so that the encoder can start over.
- * <pre>
- * // Client-side example
- * {@link HttpRequest} req = ...;
- * {@link CookieEncoder} encoder = new {@link CookieEncoder}(false);
- * encoder.addCookie("JSESSIONID", "1234");
- * res.setHeader("Cookie", encoder.encode());
- *
- * // Server-side example
- * {@link HttpResponse} res = ...;
- * {@link CookieEncoder} encoder = new {@link CookieEncoder}(true);
- * encoder.addCookie("JSESSIONID", "1234");
- * res.setHeader("Set-Cookie", encoder.encode());
- * </pre>
- *
- * @see CookieDecoder
- *
- * @apiviz.stereotype utility
- * @apiviz.has        org.jboss.netty.handler.codec.http.Cookie oneway - - encodes
- */
-// This fork brings support for RFC6265, that's used if the Cookie has a raw value
-public final class CookieEncoder {
-
-    private CookieEncoder() {
-    }
-    
-    public static String encodeClientSide(Collection<Cookie> cookies, boolean useRFC6265Style) {
-        StringBuilder sb = new StringBuilder();
-
-        for (Cookie cookie: cookies) {
-            if (useRFC6265Style)
-                encodeRFC6265Style(sb, cookie);
-            else
-                encodeRFC2965Style(sb, cookie);
-        }
-
-        if (sb.length() > 0) {
-            sb.setLength(sb.length() - 2);
-        }
-        return sb.toString();
-    }
-    
-    private static void encodeRFC6265Style(StringBuilder sb, Cookie cookie) {
-        addUnquoted(sb, cookie.getName(), cookie.getRawValue());
-    }
-    
-    private static void encodeRFC2965Style(StringBuilder sb, Cookie cookie) {
-        if (cookie.getVersion() >= 1) {
-            add(sb, '$' + CookieHeaderNames.VERSION, 1);
-        }
-
-        add(sb, cookie.getName(), cookie.getValue());
-
-        if (cookie.getPath() != null) {
-            add(sb, '$' + CookieHeaderNames.PATH, cookie.getPath());
-        }
-
-        if (cookie.getDomain() != null) {
-            add(sb, '$' + CookieHeaderNames.DOMAIN, cookie.getDomain());
-        }
-
-        if (cookie.getVersion() >= 1) {
-            if (!cookie.getPorts().isEmpty()) {
-                sb.append('$');
-                sb.append(CookieHeaderNames.PORT);
-                sb.append((char) HttpConstants.EQUALS);
-                sb.append((char) HttpConstants.DOUBLE_QUOTE);
-                for (int port: cookie.getPorts()) {
-                    sb.append(port);
-                    sb.append((char) HttpConstants.COMMA);
-                }
-                sb.setCharAt(sb.length() - 1, (char) HttpConstants.DOUBLE_QUOTE);
-                sb.append((char) HttpConstants.SEMICOLON);
-                sb.append((char) HttpConstants.SP);
-            }
-        }
-    }
-
-    private static void add(StringBuilder sb, String name, String val) {
-        if (val == null) {
-            addQuoted(sb, name, "");
-            return;
-        }
-
-        for (int i = 0; i < val.length(); i ++) {
-            char c = val.charAt(i);
-            switch (c) {
-            case '\t': case ' ': case '"': case '(':  case ')': case ',':
-            case '/':  case ':': case ';': case '<':  case '=': case '>':
-            case '?':  case '@': case '[': case '\\': case ']':
-            case '{':  case '}':
-                addQuoted(sb, name, val);
-                return;
-            }
-        }
-
-        addUnquoted(sb, name, val);
-    }
-
-    private static void addUnquoted(StringBuilder sb, String name, String val) {
-        sb.append(name);
-        sb.append((char) HttpConstants.EQUALS);
-        sb.append(val);
-        sb.append((char) HttpConstants.SEMICOLON);
-        sb.append((char) HttpConstants.SP);
-    }
-
-    private static void addQuoted(StringBuilder sb, String name, String val) {
-        if (val == null) {
-            val = "";
-        }
-
-        sb.append(name);
-        sb.append((char) HttpConstants.EQUALS);
-        sb.append((char) HttpConstants.DOUBLE_QUOTE);
-        sb.append(val.replace("\\", "\\\\").replace("\"", "\\\""));
-        sb.append((char) HttpConstants.DOUBLE_QUOTE);
-        sb.append((char) HttpConstants.SEMICOLON);
-        sb.append((char) HttpConstants.SP);
-    }
-
-    private static void add(StringBuilder sb, String name, int val) {
-        sb.append(name);
-        sb.append((char) HttpConstants.EQUALS);
-        sb.append(val);
-        sb.append((char) HttpConstants.SEMICOLON);
-        sb.append((char) HttpConstants.SP);
-    }
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
deleted file mode 100644
index 523cb479d..000000000
--- a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.org.jboss.netty.handler.codec.http;
-
-final class CookieHeaderNames {
-    static final String PATH = "Path";
-
-    static final String EXPIRES = "Expires";
-
-    static final String MAX_AGE = "Max-Age";
-
-    static final String DOMAIN = "Domain";
-
-    static final String SECURE = "Secure";
-
-    static final String HTTPONLY = "HTTPOnly";
-
-    static final String COMMENT = "Comment";
-
-    static final String COMMENTURL = "CommentURL";
-
-    static final String DISCARD = "Discard";
-
-    static final String PORT = "Port";
-
-    static final String VERSION = "Version";
-
-    private CookieHeaderNames() {
-        // Unused.
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java
deleted file mode 100644
index c5b4212bf..000000000
--- a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.org.jboss.netty.handler.codec.http;
-
-import java.nio.charset.Charset;
-
-public final class HttpConstants {
-
-    /**
-     * Horizontal space
-     */
-    public static final byte SP = 32;
-
-    /**
-     * Horizontal tab
-     */
-    public static final byte HT = 9;
-
-    /**
-     * Carriage return
-     */
-    public static final byte CR = 13;
-
-    /**
-     * Equals '='
-     */
-    public static final byte EQUALS = 61;
-
-    /**
-     * Line feed character
-     */
-    public static final byte LF = 10;
-
-    /**
-     * Colon ':'
-     */
-    public static final byte COLON = 58;
-
-    /**
-     * Semicolon ';'
-     */
-    public static final byte SEMICOLON = 59;
-
-    /**
-     * Comma ','
-     */
-    public static final byte COMMA = 44;
-
-    /**
-     * Double quote '"'
-     */
-    public static final byte DOUBLE_QUOTE = '"';
-
-    /**
-     * Default character set (UTF-8)
-     */
-    public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
-
-    private HttpConstants() {
-        // Unused
-    }
-}
-
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java
deleted file mode 100644
index b828761d0..000000000
--- a/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.org.jboss.netty.util.internal;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * String utility class.
- */
-public final class StringUtil {
-
-    private StringUtil() {
-        // Unused.
-    }
-
-    private static final String EMPTY_STRING = "";
-
-    /**
-     * Splits the specified {@link String} with the specified delimiter.  This operation is a simplified and optimized
-     * version of {@link String#split(String)}.
-     */
-    public static String[] split(String value, char delim) {
-        final int end = value.length();
-        final List<String> res = new ArrayList<String>();
-
-        int start = 0;
-        for (int i = 0; i < end; i ++) {
-            if (value.charAt(i) == delim) {
-                if (start == i) {
-                    res.add(EMPTY_STRING);
-                } else {
-                    res.add(value.substring(start, i));
-                }
-                start = i + 1;
-            }
-        }
-
-        if (start == 0) { // If no delimiter was found in the value
-            res.add(value);
-        } else {
-            if (start != end) {
-                // Add the last element if it's not empty.
-                res.add(value.substring(start, end));
-            } else {
-                // Truncate trailing empty elements.
-                for (int i = res.size() - 1; i >= 0; i --) {
-                    if (res.get(i).length() == 0) {
-                        res.remove(i);
-                    } else {
-                        break;
-                    }
-                }
-            }
-        }
-
-        return res.toArray(new String[res.size()]);
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java b/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
index d22a511ea..52e9746b8 100644
--- a/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
+++ b/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
@@ -1,24 +1,20 @@
 package org.asynchttpclient.providers;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.util.Collections;
-import java.util.List;
-
-import org.asynchttpclient.Cookie;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
-public abstract class ResponseBase implements Response
-{
+import java.util.Collections;
+import java.util.List;
+
+public abstract class ResponseBase implements Response {
     protected final static String DEFAULT_CHARSET = "ISO-8859-1";
 
     protected final List<HttpResponseBodyPart> bodyParts;
@@ -26,80 +22,74 @@
     protected final HttpResponseStatus status;
     private List<Cookie> cookies;
 
-    protected ResponseBase(HttpResponseStatus status,
-            HttpResponseHeaders headers,
-            List<HttpResponseBodyPart> bodyParts)
-    {
+    protected ResponseBase(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
         this.bodyParts = bodyParts;
         this.headers = headers;
         this.status = status;
     }
 
-    /* @Override */
+    protected abstract List<Cookie> buildCookies();
+
+    protected String calculateCharset(String charset) {
+
+        if (charset == null) {
+            String contentType = getContentType();
+            if (contentType != null)
+                charset = AsyncHttpProviderUtils.parseCharset(contentType); // parseCharset can return null
+        }
+        return charset != null ? charset : DEFAULT_CHARSET;
+    }
+
+    @Override
     public final int getStatusCode() {
         return status.getStatusCode();
     }
 
-    /* @Override */
+    @Override
     public final String getStatusText() {
         return status.getStatusText();
     }
 
-    /* @Override */
-    public final URI getUri() /*throws MalformedURLException*/ {
-        return status.getUrl();
+    @Override
+    public final Uri getUri() {
+        return status.getUri();
     }
 
-    /* @Override */
+    @Override
     public final String getContentType() {
-        return headers != null? getHeader("Content-Type"): null;
+        return headers != null ? getHeader("Content-Type") : null;
     }
 
-    /* @Override */
+    @Override
     public final String getHeader(String name) {
-        return headers != null? getHeaders().getFirstValue(name): null;
+        return headers != null ? getHeaders().getFirstValue(name) : null;
     }
 
-    /* @Override */
+    @Override
     public final List<String> getHeaders(String name) {
-        return headers != null? getHeaders().get(name): null;
+        return headers != null ? getHeaders().get(name) : null;
     }
 
-    /* @Override */
+    @Override
     public final FluentCaseInsensitiveStringsMap getHeaders() {
-        return headers != null? headers.getHeaders(): new FluentCaseInsensitiveStringsMap();
+        return headers != null ? headers.getHeaders() : new FluentCaseInsensitiveStringsMap();
     }
 
-    /* @Override */
+    @Override
     public final boolean isRedirected() {
-        return (status.getStatusCode() >= 300) && (status.getStatusCode() <= 399);
-    }
-    
-    /* @Override */
-    public byte[] getResponseBodyAsBytes() throws IOException {
-        return AsyncHttpProviderUtils.contentToBytes(bodyParts);
-    }
-
-    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
-        return ByteBuffer.wrap(getResponseBodyAsBytes());
-    }
-
-    /* @Override */
-    public String getResponseBody() throws IOException {
-        return getResponseBody(DEFAULT_CHARSET);
-    }
-
-    public String getResponseBody(String charset) throws IOException {
-        return AsyncHttpProviderUtils.contentToString(bodyParts, calculateCharset(charset));
+        switch (status.getStatusCode()) {
+        case 301:
+        case 302:
+        case 303:
+        case 307:
+        case 308:
+            return true;
+        default:
+            return false;
+        }
     }
 
-    /* @Override */
-    public InputStream getResponseBodyAsStream() throws IOException {
-        return AsyncHttpProviderUtils.contentAsStream(bodyParts);
-    }
-    
-    protected abstract List<Cookie> buildCookies();
-    
+    @Override
     public List<Cookie> getCookies() {
 
         if (headers == null) {
@@ -113,24 +103,17 @@ public InputStream getResponseBodyAsStream() throws IOException {
 
     }
 
-    protected String calculateCharset(String charset) {
-        
-        if (charset == null) {
-        	String contentType = getContentType();
-        	if (contentType != null)
-        		charset = AsyncHttpProviderUtils.parseCharset(contentType); // parseCharset can return null
-        }
-        return charset != null? charset: DEFAULT_CHARSET;
-    }
-
+    @Override
     public boolean hasResponseStatus() {
         return status != null;
     }
 
+    @Override
     public boolean hasResponseHeaders() {
         return headers != null && isNonEmpty(headers.getHeaders());
     }
 
+    @Override
     public boolean hasResponseBody() {
         return isNonEmpty(bodyParts);
     }
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java
deleted file mode 100644
index c7a79c0dd..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java
+++ /dev/null
@@ -1,737 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.Body;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.ProgressAsyncHandler;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.multipart.MultipartRequestEntity;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.util.ProxyUtils;
-import org.asynchttpclient.util.SslUtils;
-import org.asynchttpclient.util.UTF8UrlEncoder;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.naming.AuthenticationException;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.Field;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.zip.GZIPInputStream;
-
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-
-public class JDKAsyncHttpProvider implements AsyncHttpProvider {
-    private final static Logger logger = LoggerFactory.getLogger(JDKAsyncHttpProvider.class);
-
-    private final static String NTLM_DOMAIN = "http.auth.ntlm.domain";
-
-    private final AsyncHttpClientConfig config;
-
-    private final AtomicBoolean isClose = new AtomicBoolean(false);
-
-    private final static int MAX_BUFFERED_BYTES = 8192;
-
-    private final AtomicInteger maxConnections = new AtomicInteger();
-
-    private String jdkNtlmDomain;
-
-    private Authenticator jdkAuthenticator;
-
-    private boolean bufferResponseInMemory = false;
-
-    public JDKAsyncHttpProvider(AsyncHttpClientConfig config) {
-
-        this.config = config;
-        AsyncHttpProviderConfig<?, ?> providerConfig = config.getAsyncHttpProviderConfig();
-        if (providerConfig != null && JDKAsyncHttpProviderConfig.class.isAssignableFrom(providerConfig.getClass())) {
-            configure(JDKAsyncHttpProviderConfig.class.cast(providerConfig));
-        }
-    }
-
-    private void configure(JDKAsyncHttpProviderConfig config) {
-        for (Map.Entry<String, String> e : config.propertiesSet()) {
-            System.setProperty(e.getKey(), e.getValue());
-        }
-
-        if (config.getProperty(JDKAsyncHttpProviderConfig.FORCE_RESPONSE_BUFFERING) != null) {
-            bufferResponseInMemory = true;
-        }
-    }
-
-    public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException {
-        return execute(request, handler, null);
-    }
-
-    public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler, ListenableFuture<T> future) throws IOException {
-        if (isClose.get()) {
-            throw new IOException("Closed");
-        }
-
-        if (config.getMaxTotalConnections() > -1 && (maxConnections.get() + 1) > config.getMaxTotalConnections()) {
-            throw new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
-        }
-
-        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        if (proxyServer != null || realm != null) {
-            try {
-                configureProxyAndAuth(proxyServer, realm);
-            } catch (AuthenticationException e) {
-                throw new IOException(e.getMessage());
-            }
-        }
-
-        HttpURLConnection urlConnection = createUrlConnection(request);
-
-        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
-
-        JDKDelegateFuture<T> delegate = null;
-        if (future != null) {
-            delegate = new JDKDelegateFuture<T>(handler, requestTimeout, future, urlConnection);
-        }
-
-        JDKFuture<T> f = (delegate == null) ? new JDKFuture<T>(handler, requestTimeout, urlConnection) : delegate;
-        f.touch();
-
-        f.setInnerFuture(config.executorService().submit(new AsyncHttpUrlConnection<T>(urlConnection, request, handler, f)));
-        maxConnections.incrementAndGet();
-
-        return f;
-    }
-
-    private HttpURLConnection createUrlConnection(Request request) throws IOException {
-        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        Proxy proxy = null;
-        if (proxyServer != null || realm != null) {
-            try {
-                proxy = configureProxyAndAuth(proxyServer, realm);
-            } catch (AuthenticationException e) {
-                throw new IOException(e.getMessage());
-            }
-        }
-
-        HttpURLConnection urlConnection = (HttpURLConnection)
-            request.getURI().toURL().openConnection(proxy == null ? Proxy.NO_PROXY : proxy);
-
-        if (request.getUrl().startsWith("https")) {
-            HttpsURLConnection secure = (HttpsURLConnection) urlConnection;
-            SSLContext sslContext = config.getSSLContext();
-            if (sslContext == null) {
-                try {
-                    sslContext = SslUtils.getSSLContext();
-                } catch (NoSuchAlgorithmException e) {
-                    throw new IOException(e.getMessage());
-                } catch (GeneralSecurityException e) {
-                    throw new IOException(e.getMessage());
-                }
-            }
-            secure.setSSLSocketFactory(sslContext.getSocketFactory());
-            secure.setHostnameVerifier(config.getHostnameVerifier());
-        }
-        return urlConnection;
-    }
-
-    public void close() {
-        isClose.set(true);
-    }
-
-    public Response prepareResponse(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new JDKResponse(status, headers, bodyParts);
-    }
-
-    private final class AsyncHttpUrlConnection<T> implements Callable<T> {
-
-        private HttpURLConnection urlConnection;
-        private Request request;
-        private final AsyncHandler<T> asyncHandler;
-        private final ListenableFuture<T> future;
-        private int currentRedirectCount;
-        private AtomicBoolean isAuth = new AtomicBoolean(false);
-        private byte[] cachedBytes;
-        private int cachedBytesLenght;
-        private boolean terminate = true;
-
-        public AsyncHttpUrlConnection(HttpURLConnection urlConnection, Request request, AsyncHandler<T> asyncHandler, ListenableFuture<T> future) {
-            this.urlConnection = urlConnection;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-            this.request = request;
-        }
-
-        public T call() throws Exception {
-            AsyncHandler.STATE state = AsyncHandler.STATE.ABORT;
-            try {
-                URI uri = null;
-                // Encoding with URLConnection is a bit bogus so we need to try both way before setting it
-                try {
-                    uri = AsyncHttpProviderUtils.createUri(request.getRawUrl());
-                } catch (IllegalArgumentException u) {
-                    uri = AsyncHttpProviderUtils.createUri(request.getUrl());
-                }
-
-                configure(uri, urlConnection, request);
-                urlConnection.connect();
-
-                if (TransferCompletionHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                    throw new IllegalStateException(TransferCompletionHandler.class.getName() + "not supported by this provider");
-                }
-
-                int statusCode = urlConnection.getResponseCode();
-
-                logger.debug("\n\nRequest {}\n\nResponse {}\n", request, statusCode);
-
-                ResponseStatus status = new ResponseStatus(uri, urlConnection, JDKAsyncHttpProvider.this);
-                FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(asyncHandler).request(request).responseStatus(status).build();
-                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                    fc = asyncFilter.filter(fc);
-                    if (fc == null) {
-                        throw new NullPointerException("FilterContext is null");
-                    }
-                }
-
-                // The request has changed
-                if (fc.replayRequest()) {
-                    request = fc.getRequest();
-                    urlConnection = createUrlConnection(request);
-                    terminate = false;
-                    return call();
-                }
-
-                boolean redirectEnabled = (request.isRedirectEnabled() || config.isRedirectEnabled());
-                if (redirectEnabled && (statusCode == 302 || statusCode == 301)) {
-
-                    if (currentRedirectCount++ < config.getMaxRedirects()) {
-                        String location = urlConnection.getHeaderField("Location");
-                        URI redirUri = AsyncHttpProviderUtils.getRedirectUri(uri, location);
-                        String newUrl = redirUri.toString();
-
-                        if (!newUrl.equals(uri.toString())) {
-                            RequestBuilder builder = new RequestBuilder(request);
-
-                            logger.debug("Redirecting to {}", newUrl);
-
-                            request = builder.setUrl(newUrl).build();
-                            urlConnection = createUrlConnection(request);
-                            terminate = false;
-                            return call();
-                        }
-                    } else {
-                        throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-                    }
-                }
-
-                Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-                if (statusCode == 401 && !isAuth.getAndSet(true) && realm != null) {
-                    String wwwAuth = urlConnection.getHeaderField("WWW-Authenticate");
-
-                    logger.debug("Sending authentication to {}", request.getUrl());
-
-                    Realm nr = new Realm.RealmBuilder().clone(realm)
-                            .parseWWWAuthenticateHeader(wwwAuth)
-                            .setUri(URI.create(request.getUrl()).getPath())
-                            .setMethodName(request.getMethod())
-                            .setUsePreemptiveAuth(true)
-                            .build();
-                    RequestBuilder builder = new RequestBuilder(request);
-                    request = builder.setRealm(nr).build();
-                    urlConnection = createUrlConnection(request);
-                    terminate = false;
-                    return call();
-                }
-
-                state = asyncHandler.onStatusReceived(status);
-                if (state == AsyncHandler.STATE.CONTINUE) {
-                    state = asyncHandler.onHeadersReceived(new ResponseHeaders(uri, urlConnection, JDKAsyncHttpProvider.this));
-                }
-
-                if (state == AsyncHandler.STATE.CONTINUE) {
-                    InputStream is = getInputStream(urlConnection);
-                    String contentEncoding = urlConnection.getHeaderField("Content-Encoding");
-                    boolean isGZipped = contentEncoding == null ? false : "gzip".equalsIgnoreCase(contentEncoding);
-                    if (isGZipped) {
-                        is = new GZIPInputStream(is);
-                    }
-
-                    int byteToRead = urlConnection.getContentLength();
-                    InputStream stream = is;
-                    if (bufferResponseInMemory || byteToRead <= 0) {
-                        int[] lengthWrapper = new int[1];
-                        byte[] bytes = AsyncHttpProviderUtils.readFully(is, lengthWrapper);
-                        stream = new ByteArrayInputStream(bytes, 0, lengthWrapper[0]);
-                        byteToRead = lengthWrapper[0];
-                    }
-
-                    if (byteToRead > 0) {
-                        int minBytes = Math.min(8192, byteToRead);
-                        byte[] bytes = new byte[minBytes];
-                        int leftBytes = minBytes < 8192 ? minBytes : byteToRead;
-                        int read = 0;
-                        while (leftBytes > -1) {
-
-                            read = stream.read(bytes);
-                            if (read == -1) {
-                                break;
-                            }
-
-                            future.touch();
-
-                            byte[] b = new byte[read];
-                            System.arraycopy(bytes, 0, b, 0, read);
-                            leftBytes -= read;
-                            asyncHandler.onBodyPartReceived(new ResponseBodyPart(uri, b, JDKAsyncHttpProvider.this, leftBytes > -1));
-                        }
-                    }
-
-                    if (request.getMethod().equalsIgnoreCase("HEAD")) {
-                        asyncHandler.onBodyPartReceived(new ResponseBodyPart(uri, "".getBytes(), JDKAsyncHttpProvider.this, true));
-                    }
-                }
-
-                if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
-                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
-                }
-                try {
-                    T t = asyncHandler.onCompleted();
-                    future.content(t);
-                    future.done(null);
-                    return t;
-                } catch (Throwable t) {
-                    RuntimeException ex = new RuntimeException();
-                    ex.initCause(t);
-                    throw ex;
-                }
-            } catch (Throwable t) {
-                logger.debug(t.getMessage(), t);
-
-                if (IOException.class.isAssignableFrom(t.getClass()) && !config.getIOExceptionFilters().isEmpty()) {
-                    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(asyncHandler)
-                            .request(request).ioException(IOException.class.cast(t)).build();
-
-                    try {
-                        fc = handleIoException(fc);
-                    } catch (FilterException e) {
-                        if (config.getMaxTotalConnections() != -1) {
-                            maxConnections.decrementAndGet();
-                        }
-                        future.done(null);
-                    }
-
-                    if (fc.replayRequest()) {
-                        request = fc.getRequest();
-                        urlConnection = createUrlConnection(request);
-                        return call();
-                    }
-                }
-
-                try {
-                    future.abort(filterException(t));
-                } catch (Throwable t2) {
-                    logger.error(t2.getMessage(), t2);
-                }
-            } finally {
-                if (terminate) {
-                    if (config.getMaxTotalConnections() != -1) {
-                        maxConnections.decrementAndGet();
-                    }
-                    urlConnection.disconnect();
-                    if (jdkNtlmDomain != null) {
-                        System.setProperty(NTLM_DOMAIN, jdkNtlmDomain);
-                    }
-                    Authenticator.setDefault(jdkAuthenticator);
-                }
-            }
-            return null;
-        }
-
-        private FilterContext handleIoException(FilterContext fc) throws FilterException {
-            for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            }
-            return fc;
-        }
-
-        private Throwable filterException(Throwable t) {
-            if (UnknownHostException.class.isAssignableFrom(t.getClass())) {
-                t = new ConnectException(t.getMessage());
-            }
-
-            if (SocketTimeoutException.class.isAssignableFrom(t.getClass())) {
-                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
-                t = new TimeoutException("No response received after " + requestTimeout);
-            }
-
-            if (SSLHandshakeException.class.isAssignableFrom(t.getClass())) {
-                Throwable t2 = new ConnectException();
-                t2.initCause(t);
-                t = t2;
-            }
-
-            return t;
-        }
-
-        private void configure(URI uri, HttpURLConnection urlConnection, Request request) throws IOException, AuthenticationException {
-
-            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
-
-            if (requestTimeout != 0) {
-                urlConnection.setConnectTimeout(requestTimeout);
-                urlConnection.setReadTimeout(requestTimeout);
-            }
-
-            urlConnection.setInstanceFollowRedirects(false);
-            String host = uri.getHost();
-            String method = request.getMethod();
-
-            if (request.getVirtualHost() != null) {
-                host = request.getVirtualHost();
-            }
-
-            if (uri.getPort() == -1 || request.getVirtualHost() != null) {
-                urlConnection.setRequestProperty("Host", host);
-            } else {
-                urlConnection.setRequestProperty("Host", host + ":" + uri.getPort());
-            }
-
-
-            if (config.isCompressionEnabled()) {
-                urlConnection.setRequestProperty("Accept-Encoding", "gzip");
-            }
-
-            if (!method.equalsIgnoreCase("CONNECT")) {
-                FluentCaseInsensitiveStringsMap h = request.getHeaders();
-                if (h != null) {
-                    for (String name : h.keySet()) {
-                        if (!"host".equalsIgnoreCase(name)) {
-                            for (String value : h.get(name)) {
-                                urlConnection.setRequestProperty(name, value);
-                                if (name.equalsIgnoreCase("Expect")) {
-                                    throw new IllegalStateException("Expect: 100-Continue not supported");
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            String ka = AsyncHttpProviderUtils.keepAliveHeaderValue(config);
-            urlConnection.setRequestProperty("Connection", ka);
-            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-            if (proxyServer != null) {
-                urlConnection.setRequestProperty("Proxy-Connection", ka);
-                if (proxyServer.getPrincipal() != null) {
-                    urlConnection.setRequestProperty("Proxy-Authorization", AuthenticatorUtils.computeBasicAuthentication(proxyServer));
-                }
-
-                if (proxyServer.getProtocol().equals(ProxyServer.Protocol.NTLM)) {
-                    jdkNtlmDomain = System.getProperty(NTLM_DOMAIN);
-                    System.setProperty(NTLM_DOMAIN, proxyServer.getNtlmDomain());
-                }
-            }
-
-            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-            if (realm != null && realm.getUsePreemptiveAuth()) {
-                switch (realm.getAuthScheme()) {
-                    case BASIC:
-                        urlConnection.setRequestProperty("Authorization",
-                                AuthenticatorUtils.computeBasicAuthentication(realm));
-                        break;
-                    case DIGEST:
-                        if (isNonEmpty(realm.getNonce())) {
-                            try {
-                                urlConnection.setRequestProperty("Authorization",
-                                        AuthenticatorUtils.computeDigestAuthentication(realm));
-                            } catch (NoSuchAlgorithmException e) {
-                                throw new SecurityException(e);
-                            }
-                        }
-                        break;
-                    case NTLM:
-                        jdkNtlmDomain = System.getProperty(NTLM_DOMAIN);
-                        System.setProperty(NTLM_DOMAIN, realm.getDomain());
-                        break;
-                    case NONE:
-                        break;
-                    default:
-                        throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
-                }
-
-            }
-
-            // Add default accept headers.
-            if (request.getHeaders().getFirstValue("Accept") == null) {
-                urlConnection.setRequestProperty("Accept", "*/*");
-            }
-
-            if (request.getHeaders().getFirstValue("User-Agent") != null) {
-                urlConnection.setRequestProperty("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
-            } else if (config.getUserAgent() != null) {
-                urlConnection.setRequestProperty("User-Agent", config.getUserAgent());
-            } else {
-                urlConnection.setRequestProperty("User-Agent",
-                        AsyncHttpProviderUtils.constructUserAgent(JDKAsyncHttpProvider.class,
-                                                                  config));
-            }
-
-            if (isNonEmpty(request.getCookies())) {
-                urlConnection.setRequestProperty("Cookie", AsyncHttpProviderUtils.encodeCookies(request.getCookies()));
-            }
-
-            String reqType = request.getMethod();
-            urlConnection.setRequestMethod(reqType);
-
-            if ("POST".equals(reqType) || "PUT".equals(reqType)) {
-                urlConnection.setRequestProperty("Content-Length", "0");
-                urlConnection.setDoOutput(true);
-                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
-
-                if (cachedBytes != null) {
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(cachedBytesLenght));
-                    urlConnection.setFixedLengthStreamingMode(cachedBytesLenght);
-                    urlConnection.getOutputStream().write(cachedBytes, 0, cachedBytesLenght);
-                } else if (request.getByteData() != null) {
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(request.getByteData().length));
-                    urlConnection.setFixedLengthStreamingMode(request.getByteData().length);
-
-                    urlConnection.getOutputStream().write(request.getByteData());
-                } else if (request.getStringData() != null) {
-                    if (!request.getHeaders().containsKey("Content-Type")) {
-                        urlConnection.setRequestProperty("Content-Type", "text/html;" + bodyCharset);
-                    }
-                    byte[] b = request.getStringData().getBytes(bodyCharset);
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(b.length));
-                    urlConnection.getOutputStream().write(b);
-                } else if (request.getStreamData() != null) {
-                    int[] lengthWrapper = new int[1];
-                    cachedBytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
-                    cachedBytesLenght = lengthWrapper[0];
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(cachedBytesLenght));
-                    urlConnection.setFixedLengthStreamingMode(cachedBytesLenght);
-
-                    urlConnection.getOutputStream().write(cachedBytes, 0, cachedBytesLenght);
-                } else if (request.getParams() != null) {
-                    StringBuilder sb = new StringBuilder();
-                    for (final Map.Entry<String, List<String>> paramEntry : request.getParams()) {
-                        final String key = paramEntry.getKey();
-                        for (final String value : paramEntry.getValue()) {
-                            if (sb.length() > 0) {
-                                sb.append("&");
-                            }
-                            UTF8UrlEncoder.appendEncoded(sb, key);
-                            sb.append("=");
-                            UTF8UrlEncoder.appendEncoded(sb, value);
-                        }
-                    }
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(sb.length()));
-                    urlConnection.setFixedLengthStreamingMode(sb.length());
-
-                    if (!request.getHeaders().containsKey("Content-Type")) {
-                        urlConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
-                    }
-                    urlConnection.getOutputStream().write(sb.toString().getBytes(bodyCharset));
-                } else if (request.getParts() != null) {
-                    int lenght = (int) request.getContentLength();
-                    if (lenght != -1) {
-                        urlConnection.setRequestProperty("Content-Length", String.valueOf(lenght));
-                        urlConnection.setFixedLengthStreamingMode(lenght);
-                    }
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getHeaders());
-
-                    urlConnection.setRequestProperty("Content-Type", mre.getContentType());
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(mre.getContentLength()));
-
-                    mre.writeRequest(urlConnection.getOutputStream());
-                } else if (request.getEntityWriter() != null) {
-                    int lenght = (int) request.getContentLength();
-                    if (lenght != -1) {
-                        urlConnection.setRequestProperty("Content-Length", String.valueOf(lenght));
-                        urlConnection.setFixedLengthStreamingMode(lenght);
-                    }
-                    request.getEntityWriter().writeEntity(urlConnection.getOutputStream());
-                } else if (request.getFile() != null) {
-                    File file = request.getFile();
-                    if (!file.isFile()) {
-                        throw new IOException(String.format(Thread.currentThread()
-                                + "File %s is not a file or doesn't exist", file.getAbsolutePath()));
-                    }
-                    urlConnection.setRequestProperty("Content-Length", String.valueOf(file.length()));
-                    urlConnection.setFixedLengthStreamingMode((int) file.length());
-
-                    FileInputStream fis = new FileInputStream(file);
-                    try {
-                        OutputStream os = urlConnection.getOutputStream();
-                        for (final byte[] buffer = new byte[1024 * 16]; ; ) {
-                            int read = fis.read(buffer);
-                            if (read < 0) {
-                                break;
-                            }
-                            os.write(buffer, 0, read);
-                        }
-                    } finally {
-                        fis.close();
-                    }
-                } else if (request.getBodyGenerator() != null) {
-                    Body body = request.getBodyGenerator().createBody();
-                    try {
-                        int length = (int) body.getContentLength();
-                        if (length < 0) {
-                            length = (int) request.getContentLength();
-                        }
-                        if (length >= 0) {
-                            urlConnection.setRequestProperty("Content-Length", String.valueOf(length));
-                            urlConnection.setFixedLengthStreamingMode(length);
-                        }
-                        OutputStream os = urlConnection.getOutputStream();
-                        for (ByteBuffer buffer = ByteBuffer.allocate(1024 * 8); ; ) {
-                            buffer.clear();
-                            if (body.read(buffer) < 0) {
-                                break;
-                            }
-                            os.write(buffer.array(), buffer.arrayOffset(), buffer.position());
-                        }
-                    } finally {
-                        try {
-                            body.close();
-                        } catch (IOException e) {
-                            logger.warn("Failed to close request body: {}", e.getMessage(), e);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private Proxy configureProxyAndAuth(final ProxyServer proxyServer, final Realm realm) throws AuthenticationException {
-
-        Proxy proxy = null;
-        if (proxyServer != null) {
-
-            String proxyHost = proxyServer.getHost().startsWith("http://")
-                    ? proxyServer.getHost().substring("http://".length()) : proxyServer.getHost();
-
-            SocketAddress addr = new InetSocketAddress(proxyHost, proxyServer.getPort());
-            proxy = new Proxy(Proxy.Type.HTTP, addr);
-        }
-
-        final boolean hasProxy = (proxyServer != null && proxyServer.getPrincipal() != null);
-        final boolean hasAuthentication = (realm != null && realm.getPrincipal() != null);
-        if (hasProxy || hasAuthentication) {
-
-            Field f = null;
-            try {
-                f = Authenticator.class.getDeclaredField("theAuthenticator");
-
-                f.setAccessible(true);
-                jdkAuthenticator = (Authenticator) f.get(Authenticator.class);
-            } catch (NoSuchFieldException e) {
-            } catch (IllegalAccessException e) {
-            }
-
-
-            Authenticator.setDefault(new Authenticator() {
-                protected PasswordAuthentication getPasswordAuthentication() {
-                    if (hasProxy && getRequestingHost().equals(proxyServer.getHost())
-                            && getRequestingPort() == proxyServer.getPort()) {
-                        String password = "";
-                        if (proxyServer.getPassword() != null) {
-                            password = proxyServer.getPassword();
-                        }
-                        return new PasswordAuthentication(proxyServer.getPrincipal(), password.toCharArray());
-                    }
-
-                    if (hasAuthentication) {
-                        return new PasswordAuthentication(realm.getPrincipal(), realm.getPassword().toCharArray());
-                    }
-
-                    return super.getPasswordAuthentication();
-                }
-            });
-        } else {
-            Authenticator.setDefault(null);
-        }
-        return proxy;
-    }
-
-    private InputStream getInputStream(HttpURLConnection urlConnection) throws IOException {
-        if (urlConnection.getResponseCode() < 400) {
-            return urlConnection.getInputStream();
-        } else {
-            InputStream ein = urlConnection.getErrorStream();
-            return (ein != null)
-                    ? ein : new ByteArrayInputStream(new byte[0]);
-        }
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java
deleted file mode 100644
index 8d743a21a..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import org.asynchttpclient.AsyncHttpProviderConfig;
-
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-public class JDKAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, String> {
-
-    public static final String FORCE_RESPONSE_BUFFERING = "bufferResponseInMemory";
-
-    private final ConcurrentHashMap<String, String> properties = new ConcurrentHashMap<String, String>();
-
-    @Override
-    public JDKAsyncHttpProviderConfig addProperty(String name, String value) {
-        properties.put(name, value);
-        return this;
-    }
-
-    public String getProperty(String name) {
-        return properties.get(name);
-    }
-
-    public String removeProperty(String name) {
-        return properties.remove(name);
-    }
-
-    public Set<Map.Entry<String, String>> propertiesSet() {
-        return properties.entrySet();
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java
deleted file mode 100644
index 62dede5fd..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import static org.asynchttpclient.util.DateUtil.millisTime;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.ListenableFuture;
-
-import java.net.HttpURLConnection;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-public class JDKDelegateFuture<V> extends JDKFuture<V> {
-
-    private final ListenableFuture<V> delegateFuture;
-
-    public JDKDelegateFuture(AsyncHandler<V> asyncHandler, int responseTimeoutInMs,
-            ListenableFuture<V> delegateFuture, HttpURLConnection urlConnection) {
-        super(asyncHandler, responseTimeoutInMs, urlConnection);
-        this.delegateFuture = delegateFuture;
-    }
-
-    public void done(Callable<?> callable) {
-        delegateFuture.done(callable);
-        super.done(callable);
-    }
-
-    public void abort(Throwable t) {
-        if (innerFuture != null) {
-            innerFuture.cancel(true);
-        }
-        delegateFuture.abort(t);
-    }
-
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        delegateFuture.cancel(mayInterruptIfRunning);
-        if (innerFuture != null) {
-            return innerFuture.cancel(mayInterruptIfRunning);
-        } else {
-            return false;
-        }
-    }
-
-    public boolean isCancelled() {
-        if (innerFuture != null) {
-            return innerFuture.isCancelled();
-        } else {
-            return false;
-        }
-    }
-
-    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        V content = null;
-        try {
-            if (innerFuture != null) {
-                content = innerFuture.get(timeout, unit);
-            }
-        } catch (Throwable t) {
-            if (!contentProcessed.get() && timeout != -1 && ((millisTime() - touch.get()) <= responseTimeoutInMs)) {
-                return get(timeout, unit);
-            }
-            timedOut.set(true);
-            delegateFuture.abort(t);
-        }
-
-        if (exception.get() != null) {
-            delegateFuture.abort(new ExecutionException(exception.get()));
-        }
-        delegateFuture.content(content);
-        delegateFuture.done(null);
-        return content;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java
deleted file mode 100644
index 2810a33f2..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import static org.asynchttpclient.util.DateUtil.millisTime;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.net.HttpURLConnection;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-
-public class JDKFuture<V> extends AbstractListenableFuture<V> {
-
-    private final static Logger logger = LoggerFactory.getLogger(JDKFuture.class);
-
-    protected Future<V> innerFuture;
-    protected final AsyncHandler<V> asyncHandler;
-    protected final int responseTimeoutInMs;
-    protected final AtomicBoolean cancelled = new AtomicBoolean(false);
-    protected final AtomicBoolean timedOut = new AtomicBoolean(false);
-    protected final AtomicBoolean isDone = new AtomicBoolean(false);
-    protected final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
-    protected final AtomicLong touch = new AtomicLong(millisTime());
-    protected final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    protected final HttpURLConnection urlConnection;
-    private boolean writeHeaders;
-    private boolean writeBody;
-
-    public JDKFuture(AsyncHandler<V> asyncHandler, int responseTimeoutInMs, HttpURLConnection urlConnection) {
-        this.asyncHandler = asyncHandler;
-        this.responseTimeoutInMs = responseTimeoutInMs;
-        this.urlConnection = urlConnection;
-        writeHeaders = true;
-        writeBody = true;
-    }
-
-    protected void setInnerFuture(Future<V> innerFuture) {
-        this.innerFuture = innerFuture;
-    }
-
-    public void done(Callable<?> callable) {
-        isDone.set(true);
-        super.done();
-    }
-
-    public void abort(Throwable t) {
-        exception.set(t);
-        if (innerFuture != null) {
-            innerFuture.cancel(true);
-        }
-        if (!timedOut.get() && !cancelled.get()) {
-            try {
-                asyncHandler.onThrowable(t);
-            } catch (Throwable te) {
-                logger.debug("asyncHandler.onThrowable", te);
-            }
-        }
-        super.done();
-    }
-
-    public void content(V v) {
-    }
-
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        if (!cancelled.get() && innerFuture != null) {
-            urlConnection.disconnect();
-            try {
-                asyncHandler.onThrowable(new CancellationException());
-            } catch (Throwable te) {
-                logger.debug("asyncHandler.onThrowable", te);
-            }
-            cancelled.set(true);
-            super.done();
-            return innerFuture.cancel(mayInterruptIfRunning);
-        } else {
-            super.done();
-            return false;
-        }
-    }
-
-    public boolean isCancelled() {
-        if (innerFuture != null) {
-            return innerFuture.isCancelled();
-        } else {
-            return false;
-        }
-    }
-
-    public boolean isDone() {
-        contentProcessed.set(true);
-        return innerFuture.isDone();
-    }
-
-    public V get() throws InterruptedException, ExecutionException {
-        try {
-            return get(responseTimeoutInMs, TimeUnit.MILLISECONDS);
-        } catch (TimeoutException e) {
-            throw new ExecutionException(e);
-        }
-    }
-
-    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        V content = null;
-        try {
-            if (innerFuture != null) {
-                content = innerFuture.get(timeout, unit);
-            }
-        } catch (TimeoutException t) {
-            if (!contentProcessed.get() && timeout != -1 && ((millisTime() - touch.get()) <= responseTimeoutInMs)) {
-                return get(timeout, unit);
-            }
-
-            if (exception.get() == null) {
-                timedOut.set(true);
-                throw new ExecutionException(new TimeoutException(String.format("No response received after %s", responseTimeoutInMs)));
-            }
-        } catch (CancellationException ce) {
-        }
-
-        if (exception.get() != null) {
-            throw new ExecutionException(exception.get());
-        }
-        return content;
-    }
-
-    /**
-     * Is the Future still valid
-     *
-     * @return <code>true</code> if response has expired and should be terminated.
-     */
-    public boolean hasExpired() {
-        return responseTimeoutInMs != -1 && ((millisTime() - touch.get()) > responseTimeoutInMs);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override  */
-    public void touch() {
-        touch.set(millisTime());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override  */
-    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
-        boolean b = this.writeHeaders;
-        this.writeHeaders = writeHeaders;
-        return b;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteBody(boolean writeBody) {
-        boolean b = this.writeBody;
-        this.writeBody = writeBody;
-        return b;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java
deleted file mode 100644
index 682db9fc4..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.providers.ResponseBase;
-import org.asynchttpclient.providers.ResponseBase;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-public class JDKResponse extends ResponseBase {
-
-    public JDKResponse(HttpResponseStatus status,
-                       HttpResponseHeaders headers,
-                       List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
-    }
-
-    /* @Override */
-
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, DEFAULT_CHARSET);
-    }
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        // should be fine; except that it may split multi-byte chars (last char may become '?')
-        byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
-        return new String(b, charset);
-    }
-
-    /* @Override */
-    public List<Cookie> buildCookies() {
-    	List<Cookie> cookies = new ArrayList<Cookie>();
-        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                // TODO: ask for parsed header
-                List<String> v = header.getValue();
-                for (String value : v) {
-                    cookies.addAll(CookieDecoder.decode(value));
-                }
-            }
-        }
-        return Collections.unmodifiableList(cookies);
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java
deleted file mode 100644
index d88d21168..000000000
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.jdk;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseStatus;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-
-/**
- * A class that represent the HTTP response' status line (code + text)
- */
-public class ResponseStatus extends HttpResponseStatus {
-
-    private final HttpURLConnection urlConnection;
-
-    public ResponseStatus(URI uri, HttpURLConnection urlConnection, AsyncHttpProvider provider) {
-        super(uri, provider);
-        this.urlConnection = urlConnection;
-    }
-
-    /**
-     * Return the response status code
-     *
-     * @return the response status code
-     */
-    public int getStatusCode() {
-        try {
-            return urlConnection.getResponseCode();
-        } catch (IOException e) {
-            return 500;
-        }
-    }
-
-    /**
-     * Return the response status text
-     *
-     * @return the response status text
-     */
-    public String getStatusText() {
-        try {
-            return urlConnection.getResponseMessage();
-        } catch (IOException e) {
-            return "Internal Error";
-        }
-    }
-
-    @Override
-    public String getProtocolName() {
-        return "http";
-    }
-
-    @Override
-    public int getProtocolMajorVersion() {
-        return 1;
-    }
-
-    @Override
-    public int getProtocolMinorVersion() {
-        return 1; //TODO
-    }
-
-    @Override
-    public String getProtocolText() {
-        return ""; //TODO
-    }
-
-}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java b/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
index 85ebb2bde..030a95fb7 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
@@ -12,17 +12,19 @@
  */
 package org.asynchttpclient.resumable;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
-import java.io.IOException;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
 
+import org.asynchttpclient.util.StandardCharsets;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * A {@link org.asynchttpclient.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
  * to store the download index information.
@@ -36,7 +38,7 @@
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void put(String url, long transferredBytes) {
         properties.put(url, transferredBytes);
     }
@@ -44,7 +46,7 @@ public void put(String url, long transferredBytes) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void remove(String uri) {
         if (uri != null) {
             properties.remove(uri);
@@ -54,7 +56,7 @@ public void remove(String uri) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void save(Map<String, Long> map) {
         log.debug("Saving current download state {}", properties.toString());
         FileOutputStream os = null;
@@ -74,18 +76,14 @@ public void save(Map<String, Long> map) {
             os = new FileOutputStream(f);
 
             for (Map.Entry<String, Long> e : properties.entrySet()) {
-                os.write((append(e)).getBytes("UTF-8"));
+                os.write(append(e).getBytes(StandardCharsets.UTF_8));
             }
             os.flush();
         } catch (Throwable e) {
             log.warn(e.getMessage(), e);
         } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (IOException ignored) {
-                }
-            }
+            if (os != null)
+                closeSilently(os);
         }
     }
 
@@ -96,10 +94,11 @@ private static String append(Map.Entry<String, Long> e) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Map<String, Long> load() {
+        Scanner scan = null;
         try {
-            Scanner scan = new Scanner(new File(TMP, storeName), "UTF-8");
+            scan = new Scanner(new File(TMP, storeName), StandardCharsets.UTF_8.name());
             scan.useDelimiter("[=\n]");
 
             String key;
@@ -115,6 +114,9 @@ private static String append(Map.Entry<String, Long> e) {
         } catch (Throwable ex) {
             // Survive any exceptions
             log.warn(ex.getMessage(), ex);
+        } finally {
+            if (scan != null)
+                scan.close();
         }
         return properties;
     }
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
index 3200f5486..c7fd13d75 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
@@ -33,8 +33,8 @@
 
 /**
  * An {@link AsyncHandler} which support resumable download, e.g when used with an {@link ResumableIOExceptionFilter},
- * this handler can resume the download operation at the point it was before the interruption occured. This prevent having to
- * download the entire file again. It's the responsibility of the {@link org.asynchttpclient.listener.TransferListener}
+ * this handler can resume the download operation at the point it was before the interruption occurred. This prevent having to
+ * download the entire file again. It's the responsibility of the {@link org.asynchttpclient.resumable.ResumableAsyncHandler}
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <p/>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
@@ -42,7 +42,6 @@
 public class ResumableAsyncHandler implements AsyncHandler<Response> {
     private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
     private final AtomicLong byteTransferred;
-    private Integer contentLength;
     private String url;
     private final ResumableProcessor resumableProcessor;
     private final AsyncHandler<Response> decoratedAsyncHandler;
@@ -52,10 +51,8 @@
     private final boolean accumulateBody;
     private ResumableListener resumableListener = new NULLResumableListener();
 
-    private ResumableAsyncHandler(long byteTransferred,
-                                  ResumableProcessor resumableProcessor,
-                                  AsyncHandler<Response> decoratedAsyncHandler,
-                                  boolean accumulateBody) {
+    private ResumableAsyncHandler(long byteTransferred, ResumableProcessor resumableProcessor,
+            AsyncHandler<Response> decoratedAsyncHandler, boolean accumulateBody) {
 
         this.byteTransferred = new AtomicLong(byteTransferred);
 
@@ -102,11 +99,11 @@ public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accu
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public AsyncHandler.STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
         responseBuilder.accumulate(status);
         if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
-            url = status.getUrl().toURL().toString();
+            url = status.getUri().toUrl();
         } else {
             return AsyncHandler.STATE.ABORT;
         }
@@ -121,7 +118,7 @@ public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accu
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void onThrowable(Throwable t) {
         if (decoratedAsyncHandler != null) {
             decoratedAsyncHandler.onThrowable(t);
@@ -133,7 +130,7 @@ public void onThrowable(Throwable t) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public AsyncHandler.STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
 
         if (accumulateBody) {
@@ -160,7 +157,7 @@ public void onThrowable(Throwable t) {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public Response onCompleted() throws Exception {
         resumableProcessor.remove(url);
         resumableListener.onAllBytesReceived();
@@ -175,12 +172,12 @@ public Response onCompleted() throws Exception {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public AsyncHandler.STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
         responseBuilder.accumulate(headers);
-        if (headers.getHeaders().getFirstValue("Content-Length") != null) {
-            contentLength = Integer.valueOf(headers.getHeaders().getFirstValue("Content-Length"));
-            if (contentLength == null || contentLength == -1) {
+        String contentLengthHeader = headers.getHeaders().getFirstValue("Content-Length");
+        if (contentLengthHeader != null) {
+            if (Long.parseLong(contentLengthHeader) == -1L) {
                 return AsyncHandler.STATE.ABORT;
             }
         }
@@ -200,8 +197,9 @@ public Response onCompleted() throws Exception {
      */
     public Request adjustRequestRange(Request request) {
 
-        if (resumableIndex.get(request.getUrl()) != null) {
-            byteTransferred.set(resumableIndex.get(request.getUrl()));
+        Long ri = resumableIndex.get(request.getUrl());
+        if (ri != null) {
+            byteTransferred.set(ri);
         }
 
         // The Resumbale
@@ -252,19 +250,19 @@ public void run() {
     public static interface ResumableProcessor {
 
         /**
-         * Associate a key with the number of bytes sucessfully transferred.
+         * Associate a key with the number of bytes successfully transferred.
          *
          * @param key              a key. The recommended way is to use an url.
-         * @param transferredBytes The number of bytes sucessfully transferred.
+         * @param transferredBytes The number of bytes successfully transferred.
          */
-        public void put(String key, long transferredBytes);
+        void put(String key, long transferredBytes);
 
         /**
          * Remove the key associate value.
          *
-         * @param key key from which the value will be discarted
+         * @param key key from which the value will be discarded
          */
-        public void remove(String key);
+        void remove(String key);
 
         /**
          * Save the current {@link Map} instance which contains information about the current transfer state.
@@ -272,14 +270,14 @@ public void run() {
          *
          * @param map
          */
-        public void save(Map<String, Long> map);
+        void save(Map<String, Long> map);
 
         /**
          * Load the {@link Map} in memory, contains information about the transferred bytes.
          *
          * @return {@link Map}
          */
-        public Map<String, Long> load();
+        Map<String, Long> load();
 
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
index 2b686f7ba..87868e35d 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
@@ -16,22 +16,18 @@
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.IOExceptionFilter;
 
 /**
- * Simple {@link org.asynchttpclient.filter.IOExceptionFilter} that replay the current {@link org.asynchttpclient.Request} using
- * a {@link ResumableAsyncHandler}
+ * Simple {@link org.asynchttpclient.filter.IOExceptionFilter} that replay the current {@link org.asynchttpclient.Request} using a {@link ResumableAsyncHandler}
  */
 public class ResumableIOExceptionFilter implements IOExceptionFilter {
-    public FilterContext filter(FilterContext ctx) throws FilterException {
-        if (ctx.getIOException() != null && ResumableAsyncHandler.class.isAssignableFrom(ctx.getAsyncHandler().getClass())) {
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+        if (ctx.getIOException() != null && ctx.getAsyncHandler() instanceof ResumableAsyncHandler) {
 
             Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
 
-            return new FilterContext.FilterContextBuilder(ctx).request(request).replayRequest(true).build();
+            return new FilterContext.FilterContextBuilder<T>(ctx).request(request).replayRequest(true).build();
         }
         return ctx;
     }
 }
-    
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
index 252236cba..c8af9c656 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
@@ -26,18 +26,17 @@
      * @param byteBuffer the current bytes
      * @throws IOException
      */
-    public void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
+    void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
 
     /**
      * Invoked when all the bytes has been sucessfully transferred.
      */
-    public void onAllBytesReceived();
+    void onAllBytesReceived();
 
     /**
      * Return the length of previously downloaded bytes.
      *
      * @return the length of previously downloaded bytes
      */
-    public long length();
-
-}
\ No newline at end of file
+    long length();
+}
diff --git a/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
index b8e300f02..a22d7a4e3 100644
--- a/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
@@ -14,6 +14,7 @@
  */
 
 import org.asynchttpclient.SimpleAsyncHttpClient;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * A simple transfer listener for use with the {@link SimpleAsyncHttpClient}.
@@ -29,51 +30,51 @@
     /**
      * This method is called after the connection status is received.
      *
-     * @param url        the url for the connection.
+     * @param uri        the uri
      * @param statusCode the received status code.
      * @param statusText the received status text.
      */
-    void onStatus(String url, int statusCode, String statusText);
+    void onStatus(Uri uri, int statusCode, String statusText);
 
     /**
      * This method is called after the response headers are received.
      *
-     * @param url     the url for the connection.
+     * @param uri     the uri
      * @param headers the received headers, never {@code null}.
      */
-    void onHeaders(String url, HeaderMap headers);
+    void onHeaders(Uri uri, HeaderMap headers);
 
     /**
      * This method is called when bytes of the responses body are received.
      *
-     * @param url     the url for the connection.
+     * @param uri     the uri
      * @param amount  the number of transferred bytes so far.
      * @param current the number of transferred bytes since the last call to this
      *                method.
      * @param total   the total number of bytes to be transferred. This is taken
      *                from the Content-Length-header and may be unspecified (-1).
      */
-    void onBytesReceived(String url, long amount, long current, long total);
+    void onBytesReceived(Uri uri, long amount, long current, long total);
 
     /**
      * This method is called when bytes are sent.
      *
-     * @param url     the url for the connection.
+     * @param uri     the uri
      * @param amount  the number of transferred bytes so far.
      * @param current the number of transferred bytes since the last call to this
      *                method.
      * @param total   the total number of bytes to be transferred. This is taken
      *                from the Content-Length-header and may be unspecified (-1).
      */
-    void onBytesSent(String url, long amount, long current, long total);
+    void onBytesSent(Uri uri, long amount, long current, long total);
 
     /**
      * This method is called when the request is completed.
      *
-     * @param url        the url for the connection.
+     * @param uri        the uri
      * @param statusCode the received status code.
      * @param statusText the received status text.
      */
-    void onCompleted(String url, int statusCode, String statusText);
-
+    void onCompleted(Uri uri, int statusCode, String statusText);
 }
+
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
similarity index 85%
rename from providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java
rename to api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index a712421cc..dc371e029 100644
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java
+++ b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -35,7 +35,7 @@
  * <http://www.apache.org/>.
  */
 
-package org.asynchttpclient.providers.netty_4.spnego;
+package org.asynchttpclient.spnego;
 
 import org.asynchttpclient.util.Base64;
 import org.ietf.jgss.GSSContext;
@@ -49,12 +49,12 @@
 import java.io.IOException;
 
 /**
- * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
- * scheme.
- *
+ * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme.
+ * 
  * @since 4.1
  */
 public class SpnegoEngine {
+
     private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
     private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
 
@@ -70,6 +70,14 @@ public SpnegoEngine() {
         this(null);
     }
 
+    private static SpnegoEngine instance;
+
+    public static SpnegoEngine instance() {
+        if (instance == null)
+            instance = new SpnegoEngine();
+        return instance;
+    }
+
     public String generateToken(String server) throws Throwable {
         GSSContext gssContext = null;
         byte[] token = null; // base64 decoded challenge
@@ -77,17 +85,16 @@ public String generateToken(String server) throws Throwable {
 
         try {
             log.debug("init {}", server);
-            /* Using the SPNEGO OID is the correct method.
-             * Kerberos v5 works for IIS but not JBoss. Unwrapping
-             * the initial token when using SPNEGO OID looks like what is
-             * described here...
-             *
+            /*
+             * Using the SPNEGO OID is the correct method. Kerberos v5 works for IIS but not JBoss. Unwrapping the initial token when using SPNEGO OID looks like what is described
+             * here...
+             * 
              * http://msdn.microsoft.com/en-us/library/ms995330.aspx
-             *
+             * 
              * Another helpful URL...
-             *
+             * 
              * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
-             *
+             * 
              * Unfortunately SPNEGO is JRE >=1.6.
              */
 
@@ -98,8 +105,7 @@ public String generateToken(String server) throws Throwable {
             try {
                 GSSManager manager = GSSManager.getInstance();
                 GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(
-                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
                         GSSContext.DEFAULT_LIFETIME);
                 gssContext.requestMutualAuth(true);
                 gssContext.requestCredDeleg(true);
@@ -116,13 +122,12 @@ public String generateToken(String server) throws Throwable {
 
             }
             if (tryKerberos) {
-                /* Kerberos v5 GSS-API mechanism defined in RFC 1964.*/
+                /* Kerberos v5 GSS-API mechanism defined in RFC 1964. */
                 log.debug("Using Kerberos MECH {}", KERBEROS_OID);
                 negotiationOid = new Oid(KERBEROS_OID);
                 GSSManager manager = GSSManager.getInstance();
                 GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(
-                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
                         GSSContext.DEFAULT_LIFETIME);
                 gssContext.requestMutualAuth(true);
                 gssContext.requestCredDeleg(true);
@@ -139,8 +144,7 @@ public String generateToken(String server) throws Throwable {
             }
 
             /*
-             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish?
-             * seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
+             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish? seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
              */
             if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
                 token = spnegoGenerator.generateSpnegoDERObject(token);
@@ -154,13 +158,11 @@ public String generateToken(String server) throws Throwable {
             return tokenstr;
         } catch (GSSException gsse) {
             log.error("generateToken", gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL
-                    || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
+            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
                 throw new Exception(gsse.getMessage(), gsse);
             if (gsse.getMajor() == GSSException.NO_CRED)
                 throw new Exception(gsse.getMessage(), gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN
-                    || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
+            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
                     || gsse.getMajor() == GSSException.OLD_TOKEN)
                 throw new Exception(gsse.getMessage(), gsse);
             // other error
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java b/api/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
similarity index 97%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java
rename to api/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
index 20d6dcc1a..ee0b9876c 100644
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
@@ -36,7 +36,7 @@
  *
  */
 
-package org.asynchttpclient.providers.netty.spnego;
+package org.asynchttpclient.spnego;
 
 import java.io.IOException;
 
@@ -51,5 +51,4 @@
 public interface SpnegoTokenGenerator {
 
     byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/uri/Uri.java b/api/src/main/java/org/asynchttpclient/uri/Uri.java
new file mode 100644
index 000000000..4eb455957
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.uri;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.asynchttpclient.util.MiscUtils;
+
+public class Uri {
+    
+    public static Uri create(String originalUrl) {
+        return create(null, originalUrl);
+    }
+
+    public static Uri create(Uri context, final String originalUrl) {
+        UriParser parser = new UriParser();
+        parser.parse(context, originalUrl);
+
+        return new Uri(parser.scheme,//
+                parser.userInfo,//
+                parser.host,//
+                parser.port,//
+                parser.path,//
+                parser.query);
+    }
+
+    private final String scheme;
+    private final String userInfo;
+    private final String host;
+    private final int port;
+    private final String query;
+    private final String path;
+    private String url;
+
+    public Uri(String scheme,//
+            String userInfo,//
+            String host,//
+            int port,//
+            String path,//
+            String query) {
+
+        if (scheme == null)
+            throw new NullPointerException("scheme");
+        if (host == null)
+            throw new NullPointerException("host");
+
+        this.scheme = scheme;
+        this.userInfo = userInfo;
+        this.host = host;
+        this.port = port;
+        this.path = path;
+        this.query = query;
+    }
+
+    public String getQuery() {
+        return query;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    public String getUserInfo() {
+        return userInfo;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public String getScheme() {
+        return scheme;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public URI toJavaNetURI() throws URISyntaxException {
+        return new URI(toUrl());
+    }
+
+    public String toUrl() {
+        if (url == null) {
+            StringBuilder sb = new StringBuilder();
+            sb.append(scheme).append("://");
+            if (userInfo != null)
+                sb.append(userInfo).append('@');
+            sb.append(host);
+            if (port != -1)
+                sb.append(':').append(port);
+            if (path != null)
+                sb.append(path);
+            if (query != null)
+                sb.append('?').append(query);
+
+            url = sb.toString();
+        }
+        return url;
+    }
+
+    public String toRelativeUrl() {
+        StringBuilder sb = new StringBuilder();
+        if (MiscUtils.isNonEmpty(path))
+            sb.append(path);
+        else
+            sb.append('/');
+        if (query != null)
+            sb.append('?').append(query);
+
+        return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+        // for now, but might change
+        return toUrl();
+    }
+
+    public Uri withNewScheme(String newScheme) {
+        return new Uri(newScheme,//
+                userInfo,//
+                host,//
+                port,//
+                path,//
+                query);
+    }
+
+    public Uri withNewQuery(String newQuery) {
+        return new Uri(scheme,//
+                userInfo,//
+                host,//
+                port,//
+                path,//
+                newQuery);
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((host == null) ? 0 : host.hashCode());
+        result = prime * result + ((path == null) ? 0 : path.hashCode());
+        result = prime * result + port;
+        result = prime * result + ((query == null) ? 0 : query.hashCode());
+        result = prime * result + ((scheme == null) ? 0 : scheme.hashCode());
+        result = prime * result + ((userInfo == null) ? 0 : userInfo.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Uri other = (Uri) obj;
+        if (host == null) {
+            if (other.host != null)
+                return false;
+        } else if (!host.equals(other.host))
+            return false;
+        if (path == null) {
+            if (other.path != null)
+                return false;
+        } else if (!path.equals(other.path))
+            return false;
+        if (port != other.port)
+            return false;
+        if (query == null) {
+            if (other.query != null)
+                return false;
+        } else if (!query.equals(other.query))
+            return false;
+        if (scheme == null) {
+            if (other.scheme != null)
+                return false;
+        } else if (!scheme.equals(other.scheme))
+            return false;
+        if (userInfo == null) {
+            if (other.userInfo != null)
+                return false;
+        } else if (!userInfo.equals(other.userInfo))
+            return false;
+        return true;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/uri/UriParser.java b/api/src/main/java/org/asynchttpclient/uri/UriParser.java
new file mode 100644
index 000000000..505bf78b6
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.uri;
+
+final class UriParser {
+
+    public String scheme;
+    public String host;
+    public int port = -1;
+    public String query;
+    public String authority;
+    public String path;
+    public String userInfo;
+
+    private int start, end = 0;
+    private String urlWithoutQuery;
+
+    private void trimRight(String originalUrl) {
+        end = originalUrl.length();
+        while (end > 0 && originalUrl.charAt(end - 1) <= ' ')
+            end--;
+    }
+
+    private void trimLeft(String originalUrl) {
+        while (start < end && originalUrl.charAt(start) <= ' ')
+            start++;
+
+        if (originalUrl.regionMatches(true, start, "url:", 0, 4))
+            start += 4;
+    }
+
+    private boolean isFragmentOnly(String originalUrl) {
+        return start < originalUrl.length() && originalUrl.charAt(start) == '#';
+    }
+
+    private boolean isValidProtocolChar(char c) {
+        return Character.isLetterOrDigit(c) && c != '.' && c != '+' && c != '-';
+    }
+
+    private boolean isValidProtocolChars(String protocol) {
+        for (int i = 1; i < protocol.length(); i++) {
+            if (!isValidProtocolChar(protocol.charAt(i)))
+                return false;
+        }
+        return true;
+    }
+
+    private boolean isValidProtocol(String protocol) {
+        return protocol.length() > 0 && Character.isLetter(protocol.charAt(0)) && isValidProtocolChars(protocol);
+    }
+
+    private void computeInitialScheme(String originalUrl) {
+        for (int i = start; i < end; i++) {
+            char c = originalUrl.charAt(i);
+            if (c == ':') {
+                String s = originalUrl.substring(start, i);
+                if (isValidProtocol(s)) {
+                  scheme = s.toLowerCase();
+                    start = i + 1;
+                }
+                break;
+            } else if (c == '/')
+                break;
+        }
+    }
+
+    private boolean overrideWithContext(Uri context, String originalUrl) {
+
+        boolean isRelative = false;
+
+        // only use context if the schemes match
+        if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {
+
+            // see RFC2396 5.2.3
+            String contextPath = context.getPath();
+            if (isNotEmpty(contextPath) && contextPath.charAt(0) == '/')
+              scheme = null;
+
+            if (scheme == null) {
+                scheme = context.getScheme();
+                userInfo = context.getUserInfo();
+                host = context.getHost();
+                port = context.getPort();
+                path = contextPath;
+                isRelative = true;
+            }
+        }
+        return isRelative;
+    }
+
+    private void computeFragment(String originalUrl) {
+        int charpPosition = originalUrl.indexOf('#', start);
+        if (charpPosition >= 0) {
+            end = charpPosition;
+        }
+    }
+
+    private void inheritContextQuery(Uri context, boolean isRelative) {
+        // see RFC2396 5.2.2: query and fragment inheritance
+        if (isRelative && start == end) {
+            query = context.getQuery();
+        }
+    }
+
+    private boolean splitUrlAndQuery(String originalUrl) {
+        boolean queryOnly = false;
+        urlWithoutQuery = originalUrl;
+        if (start < end) {
+            int askPosition = originalUrl.indexOf('?');
+            queryOnly = askPosition == start;
+            if (askPosition != -1 && askPosition < end) {
+                query = originalUrl.substring(askPosition + 1, end);
+                if (end > askPosition)
+                    end = askPosition;
+                urlWithoutQuery = originalUrl.substring(0, askPosition);
+            }
+        }
+
+        return queryOnly;
+    }
+
+    private boolean currentPositionStartsWith4Slashes() {
+        return urlWithoutQuery.regionMatches(start, "////", 0, 4);
+    }
+
+    private boolean currentPositionStartsWith2Slashes() {
+        return urlWithoutQuery.regionMatches(start, "//", 0, 2);
+    }
+
+    private void computeAuthority() {
+        int authorityEndPosition = urlWithoutQuery.indexOf('/', start);
+        if (authorityEndPosition < 0) {
+            authorityEndPosition = urlWithoutQuery.indexOf('?', start);
+            if (authorityEndPosition < 0)
+                authorityEndPosition = end;
+        }
+        host = authority = urlWithoutQuery.substring(start, authorityEndPosition);
+        start = authorityEndPosition;
+    }
+
+    private void computeUserInfo() {
+        int atPosition = authority.indexOf('@');
+        if (atPosition != -1) {
+            userInfo = authority.substring(0, atPosition);
+            host = authority.substring(atPosition + 1);
+        } else
+            userInfo = null;
+    }
+
+    private boolean isMaybeIPV6() {
+        // If the host is surrounded by [ and ] then its an IPv6
+        // literal address as specified in RFC2732
+        return host.length() > 0 && host.charAt(0) == '[';
+    }
+
+    private void computeIPV6() {
+        int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
+        if (positionAfterClosingSquareBrace > 1) {
+
+            port = -1;
+
+            if (host.length() > positionAfterClosingSquareBrace) {
+                if (host.charAt(positionAfterClosingSquareBrace) == ':') {
+                    // see RFC2396: port can be null
+                    int portPosition = positionAfterClosingSquareBrace + 1;
+                    if (host.length() > portPosition) {
+                        port = Integer.parseInt(host.substring(portPosition));
+                    }
+                } else
+                    throw new IllegalArgumentException("Invalid authority field: " + authority);
+            }
+
+            host = host.substring(0, positionAfterClosingSquareBrace);
+
+        } else
+            throw new IllegalArgumentException("Invalid authority field: " + authority);
+    }
+
+    private void computeRegularHostPort() {
+        int colonPosition = host.indexOf(':');
+        port = -1;
+        if (colonPosition >= 0) {
+            // see RFC2396: port can be null
+            int portPosition = colonPosition + 1;
+            if (host.length() > portPosition)
+                port = Integer.parseInt(host.substring(portPosition));
+            host = host.substring(0, colonPosition);
+        }
+    }
+
+    // /./
+    private void removeEmbeddedDot() {
+        path = path.replace("/./", "/");
+    }
+
+    // /../
+    private void removeEmbedded2Dots() {
+        int i = 0;
+        while ((i = path.indexOf("/../", i)) >= 0) {
+            if (i > 0) {
+                end = path.lastIndexOf('/', i - 1);
+                if (end >= 0 && path.indexOf("/../", end) != 0) {
+                    path = path.substring(0, end) + path.substring(i + 3);
+                    i = 0;
+                }
+            } else
+                i = i + 3;
+        }
+    }
+
+    private void removeTailing2Dots() {
+        while (path.endsWith("/..")) {
+            end = path.lastIndexOf('/', path.length() - 4);
+            if (end >= 0)
+                path = path.substring(0, end + 1);
+            else
+                break;
+        }
+    }
+
+    private void removeStartingDot() {
+        if (path.startsWith("./") && path.length() > 2)
+            path = path.substring(2);
+    }
+
+    private void removeTrailingDot() {
+        if (path.endsWith("/."))
+            path = path.substring(0, path.length() - 1);
+    }
+
+    private void initRelativePath() {
+        int lastSlashPosition = path.lastIndexOf('/');
+        String pathEnd = urlWithoutQuery.substring(start, end);
+
+        if (lastSlashPosition == -1)
+            path = authority != null ? "/" + pathEnd : pathEnd;
+        else
+            path = path.substring(0, lastSlashPosition + 1) + pathEnd;
+    }
+
+    private void handlePathDots() {
+        if (path.indexOf('.') != -1) {
+            removeEmbeddedDot();
+            removeEmbedded2Dots();
+            removeTailing2Dots();
+            removeStartingDot();
+            removeTrailingDot();
+        }
+    }
+
+    private void parseAuthority() {
+        if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
+            start += 2;
+
+            computeAuthority();
+            computeUserInfo();
+
+            if (host != null) {
+                if (isMaybeIPV6())
+                    computeIPV6();
+                else
+                    computeRegularHostPort();
+            }
+
+            if (port < -1)
+                throw new IllegalArgumentException("Invalid port number :" + port);
+
+            // see RFC2396 5.2.4: ignore context path if authority is defined
+            if (isNotEmpty(authority))
+                path = "";
+        }
+    }
+
+    private void handleRelativePath() {
+        initRelativePath();
+        handlePathDots();
+    }
+
+    private void computeRegularPath() {
+        if (urlWithoutQuery.charAt(start) == '/')
+            path = urlWithoutQuery.substring(start, end);
+
+        else if (isNotEmpty(path))
+            handleRelativePath();
+
+        else {
+            String pathEnd = urlWithoutQuery.substring(start, end);
+            path = authority != null ? "/" + pathEnd : pathEnd;
+        }
+    }
+
+    private void computeQueryOnlyPath() {
+        int lastSlashPosition = path.lastIndexOf('/');
+        path = lastSlashPosition < 0 ? "/" : path.substring(0, lastSlashPosition) + "/";
+    }
+
+    private void computePath(boolean queryOnly) {
+        // Parse the file path if any
+        if (start < end)
+            computeRegularPath();
+        else if (queryOnly && path != null)
+            computeQueryOnlyPath();
+        else if (path == null)
+            path = "";
+    }
+
+    public void parse(Uri context, final String originalUrl) {
+
+        if (originalUrl == null)
+            throw new NullPointerException("originalUrl");
+
+        boolean isRelative = false;
+
+        trimRight(originalUrl);
+        trimLeft(originalUrl);
+        if (!isFragmentOnly(originalUrl))
+            computeInitialScheme(originalUrl);
+        overrideWithContext(context, originalUrl);
+        computeFragment(originalUrl);
+        inheritContextQuery(context, isRelative);
+
+        boolean queryOnly = splitUrlAndQuery(originalUrl);
+        parseAuthority();
+        computePath(queryOnly);
+    }
+
+    private static boolean isNotEmpty(String string) {
+        return string != null && string.length() > 0;
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
index 70ab5a60a..93ed28262 100644
--- a/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
@@ -12,138 +12,34 @@
  */
 package org.asynchttpclient.util;
 
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.SequenceInputStream;
 import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
+import java.nio.charset.Charset;
 import java.util.List;
-import java.util.Locale;
-import java.util.Vector;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.ByteArrayPart;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FilePart;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.Part;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.StringPart;
-import org.asynchttpclient.multipart.ByteArrayPartSource;
-import org.asynchttpclient.multipart.MultipartRequestEntity;
-import org.asynchttpclient.multipart.PartSource;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * {@link org.asynchttpclient.AsyncHttpProvider} common utilities.
- * <p/>
- * The cookies's handling code is from the Netty framework.
  */
 public class AsyncHttpProviderUtils {
-    
-    private final static byte[] NO_BYTES = new byte[0];
-
-    public final static String DEFAULT_CHARSET = "ISO-8859-1";
-
-    private final static String BODY_NOT_COMPUTED = "Response's body hasn't been computed by your AsyncHandler.";
-
 
-    protected final static ThreadLocal<SimpleDateFormat[]> simpleDateFormat = new ThreadLocal<SimpleDateFormat[]>() {
-        protected SimpleDateFormat[] initialValue() {
+    public static final IOException REMOTELY_CLOSED_EXCEPTION = new IOException("Remotely Closed");
 
-            return new SimpleDateFormat[]
-                    {
-                            new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US), // RFC1123
-                            new SimpleDateFormat("EEEE, dd-MMM-yy HH:mm:ss zzz", Locale.US), //RFC1036
-                            new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy", Locale.US), //ASCTIME
-                            new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US),
-                            new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US),
-                            new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US),
-                            new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss Z", Locale.US)
-                    };
-        }
-    };
-
-    public final static SimpleDateFormat[] get() {
-        return simpleDateFormat.get();
+    static {
+        REMOTELY_CLOSED_EXCEPTION.setStackTrace(new StackTraceElement[] {});
     }
 
+    private final static byte[] NO_BYTES = new byte[0];
 
-    //space ' '
-    static final byte SP = 32;
-
-    //tab ' '
-    static final byte HT = 9;
-
-    /**
-     * Carriage return
-     */
-    static final byte CR = 13;
-
-    /**
-     * Equals '='
-     */
-    static final byte EQUALS = 61;
-
-    /**
-     * Line feed character
-     */
-    static final byte LF = 10;
-
-    /**
-     * carriage return line feed
-     */
-    static final byte[] CRLF = new byte[]{CR, LF};
-
-    /**
-     * Colon ':'
-     */
-    static final byte COLON = 58;
-
-    /**
-     * Semicolon ';'
-     */
-    static final byte SEMICOLON = 59;
-
-    /**
-     * comma ','
-     */
-    static final byte COMMA = 44;
-
-    static final byte DOUBLE_QUOTE = '"';
-
-    static final String PATH = "Path";
-
-    static final String EXPIRES = "Expires";
-
-    static final String MAX_AGE = "Max-Age";
-
-    static final String DOMAIN = "Domain";
-
-    static final String SECURE = "Secure";
-
-    static final String HTTPONLY = "HTTPOnly";
-
-    static final String COMMENT = "Comment";
-
-    static final String COMMENTURL = "CommentURL";
-
-    static final String DISCARD = "Discard";
-
-    static final String PORT = "Port";
-
-    static final String VERSION = "Version";
+    public final static Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;
 
-    public static final void validateSupportedScheme(URI uri) {
+    public static final void validateSupportedScheme(Uri uri) {
         final String scheme = uri.getScheme();
         if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws")
                 && !scheme.equalsIgnoreCase("wss")) {
@@ -152,76 +48,12 @@ public static final void validateSupportedScheme(URI uri) {
         }
     }
 
-    public final static URI createUri(String u) {
-        URI uri = URI.create(u);
-        validateSupportedScheme(uri);
-
-        String path = uri.getPath();
-        if (path == null) {
-            throw new IllegalArgumentException("The URI path, of the URI " + uri
-                    + ", must be non-null");
-        } else if (path.length() > 0 && path.charAt(0) != '/') {
-            throw new IllegalArgumentException("The URI path, of the URI " + uri
-                    + ". must start with a '/'");
-        } else if (path.length() == 0) {
-            return URI.create(u + "/");
-        }
-
-        return uri;
-    }
-
-    public static String getBaseUrl(String url) {
-        return getBaseUrl(createUri(url));
-    }
-
-    public final static String getBaseUrl(URI uri) {
-        String url = uri.getScheme() + "://" + uri.getAuthority();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url += ":" + port;
-        }
-        return url;
-    }
-
-    public final static String getAuthority(URI uri) {
-        String url = uri.getAuthority();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url += ":" + port;
-        }
-        return url;
-    }
-
-    public final static String contentToString(List<HttpResponseBodyPart> bodyParts, String charset) throws UnsupportedEncodingException {
-        return new String(contentToBytes(bodyParts), charset);
-    }
-
-    public final static byte[] contentToBytes(List<HttpResponseBodyPart> bodyParts) throws UnsupportedEncodingException {
-        final int partCount = bodyParts.size();
-        if (partCount == 0) {
-            return NO_BYTES;
-        }
-        if (partCount == 1) {
-            return bodyParts.get(0).getBodyPartBytes();
-        }
-        int size = 0;
-        ArrayList<byte[]> chunks = new ArrayList<byte[]>(partCount);
-        for (HttpResponseBodyPart part : bodyParts) {
-            byte[] chunk = part.getBodyPartBytes();
-            size += chunk.length;
-            chunks.add(chunk);
-        }
-        byte[] bytes = new byte[size];
-        int offset = 0;
-        for (byte[] chunk : chunks) {
-            System.arraycopy(chunk, 0, bytes, offset, chunk.length);
-            offset += chunk.length;
-        }
-        return bytes;
-    }
-
+    /**
+     * @param bodyParts NON EMPTY body part
+     * @param maxLen
+     * @return
+     * @throws UnsupportedEncodingException
+     */
     public final static byte[] contentToBytes(List<HttpResponseBodyPart> bodyParts, int maxLen) throws UnsupportedEncodingException {
         final int partCount = bodyParts.size();
         if (partCount == 0) {
@@ -240,7 +72,7 @@ public final static String contentToString(List<HttpResponseBodyPart> bodyParts,
         byte[] result = new byte[maxLen];
         for (HttpResponseBodyPart part : bodyParts) {
             byte[] chunk = part.getBodyPartBytes();
-            int amount = Math.min(maxLen-size, chunk.length);
+            int amount = Math.min(maxLen - size, chunk.length);
             System.arraycopy(chunk, 0, result, size, amount);
             size += amount;
             if (size == maxLen) {
@@ -254,78 +86,17 @@ public final static String contentToString(List<HttpResponseBodyPart> bodyParts,
         }
         return result;
     }
-    
-    public final static InputStream contentAsStream(List<HttpResponseBodyPart> bodyParts)
-    {
-        switch (bodyParts.size()) {
-        case 0:
-            return new ByteArrayInputStream(NO_BYTES);
-        case 1:
-            return bodyParts.get(0).readBodyPartBytes();
-        }
-        Vector<InputStream> streams = new Vector<InputStream>(bodyParts.size());
-        for (HttpResponseBodyPart part : bodyParts) {
-            streams.add(part.readBodyPartBytes());
-        }
-        return new SequenceInputStream(streams.elements());
-    }
-    
-    public final static String getHost(URI uri) {
-        String host = uri.getHost();
-        if (host == null) {
-            host = uri.getAuthority();
-        }
-        return host;
-    }
-
-    public final static URI getRedirectUri(URI uri, String location) {
-        if(location == null)
-            throw new IllegalArgumentException("URI " + uri + " was redirected to null location");
-        
-        URI locationURI = null;
-        try {
-            locationURI = new URI(location);
-        } catch (URISyntaxException e) {
-            // rich, we have a badly encoded location, let's try to encode the query params
-            String[] parts = location.split("\\?");
-            if (parts.length != 2) {
-                throw new IllegalArgumentException("Don't know how to turn this location into a proper URI:" + location, e);
-            } else {
-                StringBuilder properUrl = new StringBuilder(location.length()).append(parts[0]).append("?");
-                
-                String[] queryParams = parts[1].split("&");
-                for (int i = 0; i < queryParams.length; i++) {
-                    String queryParam = queryParams[i];
-                    if (i != 0)
-                        properUrl.append("&");
-                    String[] nameValue = queryParam.split("=", 2);
-                    UTF8UrlEncoder.appendEncoded(properUrl, nameValue[0]);
-                    if (nameValue.length == 2) {
-                        properUrl.append("=");
-                        UTF8UrlEncoder.appendEncoded(properUrl, nameValue[1]);
-                    }
-                }
-                
-                locationURI = URI.create(properUrl.toString());
-            }
-        }
-        
-        URI redirectUri = uri.resolve(locationURI);
 
-        String scheme = redirectUri.getScheme();
-
-        if (scheme == null || !scheme.equalsIgnoreCase("http")
-                && !scheme.equalsIgnoreCase("https")
-                && !scheme.equals("ws")
-                && !scheme.equals("wss")) {
-            throw new IllegalArgumentException("The URI scheme, of the URI " + redirectUri
-                    + ", must be equal (ignoring case) to 'ws, 'wss', 'http', or 'https'");
-        }
+    public final static String getBaseUrl(Uri uri) {
+        return uri.getScheme() + "://" + getAuthority(uri);
+    }
 
-        return redirectUri.normalize();
+    public final static String getAuthority(Uri uri) {
+        int port = uri.getPort() != -1? uri.getPort() : getDefaultPort(uri);
+        return uri.getHost() + ":" + port;
     }
 
-    public final static int getPort(URI uri) {
+    public final static int getDefaultPort(Uri uri) {
         int port = uri.getPort();
         if (port == -1)
             port = uri.getScheme().equals("http") || uri.getScheme().equals("ws") ? 80 : 443;
@@ -333,191 +104,12 @@ public final static int getPort(URI uri) {
     }
 
     /**
-     * This is quite ugly as our internal names are duplicated, but we build on top of HTTP Client implementation.
-     *
-     * @param params
-     * @param requestHeaders
-     * @return a MultipartRequestEntity.
-     * @throws java.io.FileNotFoundException
+     * Convenient for HTTP layer when targeting server root
+     * 
+     * @return the raw path or "/" if it's null
      */
-    public final static MultipartRequestEntity createMultipartRequestEntity(List<Part> params, FluentCaseInsensitiveStringsMap requestHeaders) throws FileNotFoundException {
-        org.asynchttpclient.multipart.Part[] parts = new org.asynchttpclient.multipart.Part[params.size()];
-        int i = 0;
-
-        for (Part part : params) {
-            if (part instanceof org.asynchttpclient.multipart.Part) {
-                parts[i] = (org.asynchttpclient.multipart.Part) part;
-            } else if (part instanceof StringPart) {
-                parts[i] = new org.asynchttpclient.multipart.StringPart(part.getName(),
-                        ((StringPart) part).getValue(),
-                        ((StringPart) part).getCharset());
-            } else if (part instanceof FilePart) {
-                parts[i] = new org.asynchttpclient.multipart.FilePart(part.getName(),
-                        ((FilePart) part).getFile(),
-                        ((FilePart) part).getMimeType(),
-                        ((FilePart) part).getCharSet());
-
-            } else if (part instanceof ByteArrayPart) {
-                PartSource source = new ByteArrayPartSource(((ByteArrayPart) part).getFileName(), ((ByteArrayPart) part).getData());
-                parts[i] = new org.asynchttpclient.multipart.FilePart(part.getName(),
-                        source,
-                        ((ByteArrayPart) part).getMimeType(),
-                        ((ByteArrayPart) part).getCharSet());
-
-            } else if (part == null) {
-                throw new NullPointerException("Part cannot be null");
-            } else {
-                throw new IllegalArgumentException(String.format("Unsupported part type for multipart parameter %s",
-                        part.getName()));
-            }
-            ++i;
-        }
-        return new MultipartRequestEntity(parts, requestHeaders);
-    }
-
-    public final static byte[] readFully(InputStream in, int[] lengthWrapper) throws IOException {
-        // just in case available() returns bogus (or -1), allocate non-trivial chunk
-        byte[] b = new byte[Math.max(512, in.available())];
-        int offset = 0;
-        while (true) {
-            int left = b.length - offset;
-            int count = in.read(b, offset, left);
-            if (count < 0) { // EOF
-                break;
-            }
-            offset += count;
-            if (count == left) { // full buffer, need to expand
-                b = doubleUp(b);
-            }
-        }
-        // wish Java had Tuple return type...
-        lengthWrapper[0] = offset;
-        return b;
-    }
-
-    private static byte[] doubleUp(byte[] b) {
-        int len = b.length;
-        byte[] b2 = new byte[len + len];
-        System.arraycopy(b, 0, b2, 0, len);
-        return b2;
-    }
-
-    public static String encodeCookies(Collection<Cookie> cookies) {
-        StringBuilder sb = new StringBuilder();
-
-        for (Cookie cookie : cookies) {
-            if (cookie.getVersion() >= 1) {
-                add(sb, '$' + VERSION, 1);
-            }
-
-            add(sb, cookie.getName(), cookie.getValue());
-
-            if (cookie.getPath() != null) {
-                add(sb, '$' + PATH, cookie.getPath());
-            }
-
-            if (cookie.getDomain() != null) {
-                add(sb, '$' + DOMAIN, cookie.getDomain());
-            }
-
-            if (cookie.getVersion() >= 1) {
-                if (!cookie.getPorts().isEmpty()) {
-                    sb.append('$');
-                    sb.append(PORT);
-                    sb.append((char) EQUALS);
-                    sb.append((char) DOUBLE_QUOTE);
-                    for (int port : cookie.getPorts()) {
-                        sb.append(port);
-                        sb.append((char) COMMA);
-                    }
-                    sb.setCharAt(sb.length() - 1, (char) DOUBLE_QUOTE);
-                    sb.append((char) SEMICOLON);
-                }
-            }
-        }
-
-        sb.setLength(sb.length() - 1);
-        return sb.toString();
-    }
-
-    private static void add(StringBuilder sb, String name, String val) {
-        if (val == null) {
-            addQuoted(sb, name, "");
-            return;
-        }
-
-        for (int i = 0; i < val.length(); i++) {
-            char c = val.charAt(i);
-            switch (c) {
-                case '\t':
-                case ' ':
-                case '"':
-                case '(':
-                case ')':
-                case ',':
-                case '/':
-                case ':':
-                case ';':
-                case '<':
-                case '=':
-                case '>':
-                case '?':
-                case '@':
-                case '[':
-                case '\\':
-                case ']':
-                case '{':
-                case '}':
-                    addQuoted(sb, name, val);
-                    return;
-            }
-        }
-
-        addUnquoted(sb, name, val);
-    }
-
-    private static void addUnquoted(StringBuilder sb, String name, String val) {
-        sb.append(name);
-        sb.append((char) EQUALS);
-        sb.append(val);
-        sb.append((char) SEMICOLON);
-    }
-
-    private static void addQuoted(StringBuilder sb, String name, String val) {
-        if (val == null) {
-            val = "";
-        }
-
-        sb.append(name);
-        sb.append((char) EQUALS);
-        sb.append((char) DOUBLE_QUOTE);
-        sb.append(val.replace("\\", "\\\\").replace("\"", "\\\""));
-        sb.append((char) DOUBLE_QUOTE);
-        sb.append((char) SEMICOLON);
-    }
-
-    private static void add(StringBuilder sb, String name, int val) {
-        sb.append(name);
-        sb.append((char) EQUALS);
-        sb.append(val);
-        sb.append((char) SEMICOLON);
-    }
-
-    public static String constructUserAgent(Class<? extends AsyncHttpProvider> httpProvider,
-                                            AsyncHttpClientConfig config) {
-        return new StringBuilder(config.getUserAgent())
-                .append(' ')
-                .append('(')
-                .append(httpProvider.getSimpleName())
-                .append(" - ")
-                .append(System.getProperty("os.name"))
-                .append(" - ")
-                .append(System.getProperty("os.version"))
-                .append(" - ")
-                .append(System.getProperty("java.version"))
-                .append(" - ")
-                .append(Runtime.getRuntime().availableProcessors())
-                .append(" core(s))").toString();
+    public final static String getNonEmptyPath(Uri uri) {
+        return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
     }
 
     public static String parseCharset(String contentType) {
@@ -527,10 +119,9 @@ public static String parseCharset(String contentType) {
                 if (val.length > 1) {
                     String charset = val[1].trim();
                     // Quite a lot of sites have charset="CHARSET",
-                    // e.g. charset="utf-8". Note the quotes. This is 
+                    // e.g. charset="utf-8". Note the quotes. This is
                     // not correct, but client should be able to handle
-                    // it (all browsers do, Apache HTTP Client and Grizzly 
-                    // strip it by default)
+                    // it (all browsers do, Grizzly strips it by default)
                     // This is a poor man's trim("\"").trim("'")
                     return charset.replaceAll("\"", "").replaceAll("'", "");
                 }
@@ -539,47 +130,15 @@ public static String parseCharset(String contentType) {
         return null;
     }
 
-    public static int convertExpireField(String timestring) {
-        String trimmedTimeString = removeQuote(timestring.trim());
-
-        for (SimpleDateFormat sdf : simpleDateFormat.get()) {
-            Date date = sdf.parse(trimmedTimeString, new ParsePosition(0));
-            if (date != null) {
-                long now = System.currentTimeMillis();
-                long maxAgeMillis = date.getTime() - now;
-                return (int) (maxAgeMillis / 1000) + (maxAgeMillis % 1000 != 0 ? 1 : 0);
-            }
-        }
-
-        throw new IllegalArgumentException("Not a valid expire field " + trimmedTimeString);
-    }
-
-    private final static String removeQuote(String s) {
-        if (MiscUtil.isNonEmpty(s)) {
-            if (s.charAt(0) == '"')
-                s = s.substring(1);
-
-            if (s.charAt(s.length() - 1) == '"')
-                s = s.substring(0, s.length() - 1);
-        }
-        return s;
-    }
-
-    public static void checkBodyParts(int statusCode, Collection<HttpResponseBodyPart> bodyParts) {
-        if (bodyParts == null || bodyParts.size() == 0) {
-
-            // We allow empty body on 204
-            if (statusCode == 204) return;
-
-            throw new IllegalStateException(BODY_NOT_COMPUTED);
-        }
-    }
-
     public static String keepAliveHeaderValue(AsyncHttpClientConfig config) {
-        return config.getAllowPoolingConnection() ? "keep-alive" : "close";
+        return config.isAllowPoolingConnections() ? "keep-alive" : "close";
     }
 
     public static int requestTimeout(AsyncHttpClientConfig config, Request request) {
-        return request.getRequestTimeoutInMs() != 0 ? request.getRequestTimeoutInMs() : config.getRequestTimeoutInMs();
+        return request.getRequestTimeoutInMs() != 0 ? request.getRequestTimeoutInMs() : config.getRequestTimeout();
+    }
+
+    public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
+        return request.getFollowRedirect() != null? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java b/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java
new file mode 100644
index 000000000..e46c2d113
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java
@@ -0,0 +1,25 @@
+package org.asynchttpclient.util;
+
+import com.typesafe.config.Config;
+import com.typesafe.config.ConfigFactory;
+
+public class AsyncPropertiesHelper {
+    
+    public static final String ASYNC_HTTP_CLIENT_IMPL_PROPERTIES_FILE = "ahc.properties";
+    public static final String DEFAULTAHC_PROPERTIES = "ahc-default.properties";
+    
+    public static Config getAsyncHttpClientConfig(){
+        return ConfigFactory.load(ASYNC_HTTP_CLIENT_IMPL_PROPERTIES_FILE)
+                .withFallback(ConfigFactory.load(DEFAULTAHC_PROPERTIES));
+    }
+    
+    /**
+     * This method invalidates the property caches. So if a system property has been changed and the
+     * effect of this change is to be seen then call reloadProperties() and then getAsyncHttpClientConfig() 
+     * to get the new property values.
+     */
+    public static void reloadProperties(){
+        ConfigFactory.invalidateCaches();
+    }
+
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index 27ff662c2..13074fb80 100644
--- a/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -12,62 +12,68 @@
  */
 package org.asynchttpclient.util;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Realm;
+import org.asynchttpclient.uri.Uri;
 
-import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
 
 public final class AuthenticatorUtils {
 
-    public static String computeBasicAuthentication(Realm realm) throws UnsupportedEncodingException {
+    public static String computeBasicAuthentication(Realm realm) {
         String s = realm.getPrincipal() + ":" + realm.getPassword();
-        return "Basic " + Base64.encode(s.getBytes(realm.getEncoding()));
+        return "Basic " + Base64.encode(s.getBytes(realm.getCharset()));
     }
 
-    public static String computeBasicAuthentication(ProxyServer proxyServer) throws UnsupportedEncodingException {
+    public static String computeBasicAuthentication(ProxyServer proxyServer) {
         String s = proxyServer.getPrincipal() + ":" + proxyServer.getPassword();
-        return "Basic " + Base64.encode(s.getBytes(proxyServer.getEncoding()));
+        return "Basic " + Base64.encode(s.getBytes(proxyServer.getCharset()));
     }
 
-    public static String computeDigestAuthentication(Realm realm) throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    private static String computeRealmURI(Realm realm) {
+        if (realm.isTargetProxy()) {
+            return "/";
+        } else {
+            Uri uri = realm.getUri();
+            if (realm.isUseAbsoluteURI()) {
+                return realm.isOmitQuery() && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
+            } else {
+                String path = getNonEmptyPath(uri);
+                return realm.isOmitQuery() || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
+            }
+        }
+    }
+
+    public static String computeDigestAuthentication(Realm realm) throws NoSuchAlgorithmException {
 
         StringBuilder builder = new StringBuilder().append("Digest ");
-        construct(builder, "username", realm.getPrincipal());
-        construct(builder, "realm", realm.getRealmName());
-        construct(builder, "nonce", realm.getNonce());
-        construct(builder, "uri", realm.getUri());
-        builder.append("algorithm").append('=').append(realm.getAlgorithm()).append(", ");
+        append(builder, "username", realm.getPrincipal(), true);
+        append(builder, "realm", realm.getRealmName(), true);
+        append(builder, "nonce", realm.getNonce(), true);
+        append(builder, "uri", computeRealmURI(realm), true);
+        append(builder, "algorithm", realm.getAlgorithm(), false);
 
-        construct(builder, "response", realm.getResponse());
+        append(builder, "response", realm.getResponse(), true);
         if (isNonEmpty(realm.getOpaque()))
-            construct(builder, "opaque", realm.getOpaque());
-        builder.append("qop").append('=').append(realm.getQop()).append(", ");
-        builder.append("nc").append('=').append(realm.getNc()).append(", ");
-        construct(builder, "cnonce", realm.getCnonce(), true);
+            append(builder, "opaque", realm.getOpaque(), true);
+        append(builder, "qop", realm.getQop(), false);
+        append(builder, "nc", realm.getNc(), false);
+        append(builder, "cnonce", realm.getCnonce(), true);
+        builder.setLength(builder.length() - 2); // remove tailing ", "
 
-        return new String(builder.toString().getBytes("ISO_8859_1"));
+        return new String(builder.toString().getBytes(StandardCharsets.ISO_8859_1));
     }
 
-	public static String computeDigestAuthentication(ProxyServer proxy) {
-		try{
-	        StringBuilder builder = new StringBuilder().append("Digest ");
-	        construct(builder, "username", proxy.getPrincipal(),true);
-	        return new String(builder.toString().getBytes("ISO_8859_1"));
-		}
-		catch (Exception e){
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-    private static StringBuilder construct(StringBuilder builder, String name, String value) {
-        return construct(builder, name, value, false);
-    }
+    private static StringBuilder append(StringBuilder builder, String name, String value, boolean quoted) {
+        builder.append(name).append('=');
+        if (quoted)
+            builder.append('"').append(value).append('"');
+        else
+            builder.append(value);
 
-    private static StringBuilder construct(StringBuilder builder, String name, String value, boolean tail) {
-        return builder.append(name).append('=').append('"').append(value).append(tail ? "\"" : "\", ");
+        return builder.append(", ");
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/Base64.java b/api/src/main/java/org/asynchttpclient/util/Base64.java
index c6141d065..c38ace7e3 100644
--- a/api/src/main/java/org/asynchttpclient/util/Base64.java
+++ b/api/src/main/java/org/asynchttpclient/util/Base64.java
@@ -80,10 +80,8 @@ public static String encode(byte[] bytes) {
 
         // first, handle complete chunks (fast loop)
         int i = 0;
-        for (int end = bytes.length - 2; i < end; ) {
-            int chunk = ((bytes[i++] & 0xFF) << 16)
-                    | ((bytes[i++] & 0xFF) << 8)
-                    | (bytes[i++] & 0xFF);
+        for (int end = bytes.length - 2; i < end;) {
+            int chunk = ((bytes[i++] & 0xFF) << 16) | ((bytes[i++] & 0xFF) << 8) | (bytes[i++] & 0xFF);
             buf.append(lookup[chunk >> 18]);
             buf.append(lookup[(chunk >> 12) & 0x3F]);
             buf.append(lookup[(chunk >> 6) & 0x3F]);
diff --git a/api/src/main/java/org/asynchttpclient/util/DateUtil.java b/api/src/main/java/org/asynchttpclient/util/DateUtil.java
deleted file mode 100644
index dfc0d55ef..000000000
--- a/api/src/main/java/org/asynchttpclient/util/DateUtil.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-/*
- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/java/org/apache/commons/httpclient/util/DateUtil.java,v 1.2 2004/12/24 20:36:13 olegk Exp $
- * $Revision: 480424 $
- * $Date: 2006-11-29 06:56:49 +0100 (Wed, 29 Nov 2006) $
- *
- * ====================================================================
- *
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- *
- */
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * A utility class for parsing and formatting HTTP dates as used in cookies and
- * other headers.  This class handles dates as defined by RFC 2616 section
- * 3.3.1 as well as some other common non-standard formats.
- *
- * @author Christopher Brown
- * @author Michael Becke
- */
-public class DateUtil {
-
-    /**
-     * Date format pattern used to parse HTTP date headers in RFC 1123 format.
-     */
-    public static final String PATTERN_RFC1123 = "EEE, dd MMM yyyy HH:mm:ss zzz";
-
-    /**
-     * Date format pattern used to parse HTTP date headers in RFC 1036 format.
-     */
-    public static final String PATTERN_RFC1036 = "EEEE, dd-MMM-yy HH:mm:ss zzz";
-
-    /**
-     * Date format pattern used to parse HTTP date headers in ANSI C
-     * <code>asctime()</code> format.
-     */
-    public static final String PATTERN_ASCTIME = "EEE MMM d HH:mm:ss yyyy";
-
-    private static final Collection<String> DEFAULT_PATTERNS = Arrays.asList(
-            new String[]{PATTERN_ASCTIME, PATTERN_RFC1036, PATTERN_RFC1123});
-
-    private static final Date DEFAULT_TWO_DIGIT_YEAR_START;
-
-    static {
-        Calendar calendar = Calendar.getInstance();
-        calendar.set(2000, Calendar.JANUARY, 1, 0, 0);
-        DEFAULT_TWO_DIGIT_YEAR_START = calendar.getTime();
-    }
-
-    private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
-
-    /**
-     * Parses a date value.  The formats used for parsing the date value are retrieved from
-     * the default http params.
-     *
-     * @param dateValue the date value to parse
-     * @return the parsed date
-     * @throws DateParseException if the value could not be parsed using any of the
-     *                            supported date formats
-     */
-    public static Date parseDate(String dateValue) throws DateParseException {
-        return parseDate(dateValue, null, null);
-    }
-
-    /**
-     * Parses the date value using the given date formats.
-     *
-     * @param dateValue   the date value to parse
-     * @param dateFormats the date formats to use
-     * @return the parsed date
-     * @throws DateParseException if none of the dataFormats could parse the dateValue
-     */
-    public static Date parseDate(String dateValue, Collection<String> dateFormats)
-            throws DateParseException {
-        return parseDate(dateValue, dateFormats, null);
-    }
-
-    /**
-     * Parses the date value using the given date formats.
-     *
-     * @param dateValue   the date value to parse
-     * @param dateFormats the date formats to use
-     * @param startDate   During parsing, two digit years will be placed in the range
-     *                    <code>startDate</code> to <code>startDate + 100 years</code>. This value may
-     *                    be <code>null</code>. When <code>null</code> is given as a parameter, year
-     *                    <code>2000</code> will be used.
-     * @return the parsed date
-     * @throws DateParseException if none of the dataFormats could parse the dateValue
-     */
-    public static Date parseDate(
-            String dateValue,
-            Collection<String> dateFormats,
-            Date startDate
-    ) throws DateParseException {
-
-        if (dateValue == null) {
-            throw new IllegalArgumentException("dateValue is null");
-        }
-        if (dateFormats == null) {
-            dateFormats = DEFAULT_PATTERNS;
-        }
-        if (startDate == null) {
-            startDate = DEFAULT_TWO_DIGIT_YEAR_START;
-        }
-        // trim single quotes around date if present
-        // see issue #5279
-        if (dateValue.length() > 1
-                && dateValue.startsWith("'")
-                && dateValue.endsWith("'")
-                ) {
-            dateValue = dateValue.substring(1, dateValue.length() - 1);
-        }
-
-        SimpleDateFormat dateParser = null;
-        Iterator<String> formatIter = dateFormats.iterator();
-
-        while (formatIter.hasNext()) {
-            String format = formatIter.next();
-            if (dateParser == null) {
-                dateParser = new SimpleDateFormat(format, Locale.US);
-                dateParser.setTimeZone(TimeZone.getTimeZone("GMT"));
-                dateParser.set2DigitYearStart(startDate);
-            } else {
-                dateParser.applyPattern(format);
-            }
-            try {
-                return dateParser.parse(dateValue);
-            } catch (ParseException pe) {
-                // ignore this exception, we will try the next format
-            }
-        }
-
-        // we were unable to parse the date
-        throw new DateParseException("Unable to parse the date " + dateValue);
-    }
-
-    /**
-     * Formats the given date according to the RFC 1123 pattern.
-     *
-     * @param date The date to format.
-     * @return An RFC 1123 formatted date string.
-     * @see #PATTERN_RFC1123
-     */
-    public static String formatDate(Date date) {
-        return formatDate(date, PATTERN_RFC1123);
-    }
-
-    /**
-     * Formats the given date according to the specified pattern.  The pattern
-     * must conform to that used by the {@link java.text.SimpleDateFormat simple date
-     * format} class.
-     *
-     * @param date    The date to format.
-     * @param pattern The pattern to use for formatting the date.
-     * @return A formatted date string.
-     * @throws IllegalArgumentException If the given date pattern is invalid.
-     * @see java.text.SimpleDateFormat
-     */
-    public static String formatDate(Date date, String pattern) {
-        if (date == null) throw new IllegalArgumentException("date is null");
-        if (pattern == null) throw new IllegalArgumentException("pattern is null");
-
-        SimpleDateFormat formatter = new SimpleDateFormat(pattern, Locale.US);
-        formatter.setTimeZone(GMT);
-        return formatter.format(date);
-    }
-
-    /**
-     * This class should not be instantiated.
-     */
-    private DateUtil() {
-    }
-
-    public static class DateParseException extends Exception {
-        private static final long serialVersionUID = 1L;
-
-        public DateParseException() {
-            super();
-        }
-
-        /**
-         * @param message the exception message
-         */
-        public DateParseException(String message) {
-            super(message);
-        }
-    }
-
-    public static long millisTime() {
-        return System.nanoTime() / 1000000;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java b/api/src/main/java/org/asynchttpclient/util/DateUtils.java
similarity index 76%
rename from api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java
rename to api/src/main/java/org/asynchttpclient/util/DateUtils.java
index d32424daf..c0b2d49c6 100644
--- a/api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java
+++ b/api/src/main/java/org/asynchttpclient/util/DateUtils.java
@@ -12,11 +12,12 @@
  */
 package org.asynchttpclient.util;
 
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
+public final class DateUtils {
 
-public class AllowAllHostnameVerifier implements HostnameVerifier {
-    public boolean verify(String s, SSLSession sslSession) {
-        return true;
+    private DateUtils() {
+    }
+    
+    public static long millisTime() {
+        return System.nanoTime() / 1000000;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java b/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
new file mode 100644
index 000000000..35f188ca9
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
@@ -0,0 +1,142 @@
+/*
+ * To the extent possible under law, Kevin Locke has waived all copyright and
+ * related or neighboring rights to this work.
+ * <p/>
+ * A legal description of this waiver is available in <a href="https://gist.github.com/kevinoid/3829665">LICENSE.txt</a>
+ */
+package org.asynchttpclient.util;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.kerberos.KerberosPrincipal;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Uses the internal HostnameChecker to verify the server's hostname matches with the
+ * certificate.  This is a requirement for HTTPS, but the raw SSLEngine does not have
+ * this functionality.  As such, it has to be added in manually.  For a more complete
+ * description of hostname verification and why it's important,
+ * please read
+ * <a href="http://tersesystems.com/2014/03/23/fixing-hostname-verification/">Fixing
+ * Hostname Verification</a>.
+ * <p/>
+ * This code is based on Kevin Locke's <a href="http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/">guide</a> .
+ * <p/>
+ */
+public class DefaultHostnameVerifier implements HostnameVerifier {
+
+    private HostnameChecker checker;
+
+    private HostnameVerifier extraHostnameVerifier;
+
+    // Logger to log exceptions.
+    private static final Logger log = Logger.getLogger(DefaultHostnameVerifier.class.getName());
+
+    /**
+     * A hostname verifier that uses the {{sun.security.util.HostnameChecker}} under the hood.
+     */
+    public DefaultHostnameVerifier() {
+        this.checker = new ProxyHostnameChecker();
+    }
+
+    /**
+     * A hostname verifier that takes an external hostname checker.  Useful for testing.
+     *
+     * @param checker a hostnamechecker.
+     */
+    public DefaultHostnameVerifier(HostnameChecker checker) {
+        this.checker = checker;
+    }
+
+    /**
+     * A hostname verifier that falls back to another hostname verifier if not found.
+     *
+     * @param extraHostnameVerifier another hostname verifier.
+     */
+    public DefaultHostnameVerifier(HostnameVerifier extraHostnameVerifier) {
+        this.checker = new ProxyHostnameChecker();
+        this.extraHostnameVerifier = extraHostnameVerifier;
+    }
+
+    /**
+     * A hostname verifier with a hostname checker, that falls back to another hostname verifier if not found.
+     *
+     * @param checker a custom HostnameChecker.
+     * @param extraHostnameVerifier another hostname verifier.
+     */
+    public DefaultHostnameVerifier(HostnameChecker checker, HostnameVerifier extraHostnameVerifier) {
+        this.checker = checker;
+        this.extraHostnameVerifier = extraHostnameVerifier;
+    }
+
+    /**
+     * Matches the hostname against the peer certificate in the session.
+     *
+     * @param hostname the IP address or hostname of the expected server.
+     * @param session  the SSL session containing the certificates with the ACTUAL hostname/ipaddress.
+     * @return true if the hostname matches, false otherwise.
+     */
+    private boolean hostnameMatches(String hostname, SSLSession session) {
+        log.log(Level.FINE, "hostname = {0}, session = {1}", new Object[] { hostname, Base64.encode(session.getId()) });
+
+        try {
+            final Certificate[] peerCertificates = session.getPeerCertificates();
+            if (peerCertificates.length == 0) {
+                log.log(Level.FINE, "No peer certificates");
+                return false;
+            }
+
+            if (peerCertificates[0] instanceof X509Certificate) {
+                X509Certificate peerCertificate = (X509Certificate) peerCertificates[0];
+                log.log(Level.FINE, "peerCertificate = {0}", peerCertificate);
+                try {
+                    checker.match(hostname, peerCertificate);
+                    // Certificate matches hostname if no exception is thrown.
+                    return true;
+                } catch (CertificateException ex) {
+                    log.log(Level.FINE, "Certificate does not match hostname", ex);
+                }
+            } else {
+                log.log(Level.FINE, "Peer does not have any certificates or they aren't X.509");
+            }
+            return false;
+        } catch (SSLPeerUnverifiedException ex) {
+            log.log(Level.FINE, "Not using certificates for peers, try verifying the principal");
+            try {
+                Principal peerPrincipal = session.getPeerPrincipal();
+                log.log(Level.FINE, "peerPrincipal = {0}", peerPrincipal);
+                if (peerPrincipal instanceof KerberosPrincipal) {
+                    return checker.match(hostname, (KerberosPrincipal) peerPrincipal);
+                } else {
+                    log.log(Level.FINE, "Can't verify principal, not Kerberos");
+                }
+            } catch (SSLPeerUnverifiedException ex2) {
+                // Can't verify principal, no principal
+                log.log(Level.FINE, "Can't verify principal, no principal", ex2);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Verifies the hostname against the peer certificates in a session.  Falls back to extraHostnameVerifier if
+     * there is no match.
+     *
+     * @param hostname the IP address or hostname of the expected server.
+     * @param session  the SSL session containing the certificates with the ACTUAL hostname/ipaddress.
+     * @return true if the hostname matches, false otherwise.
+     */
+    public boolean verify(String hostname, SSLSession session) {
+        if (hostnameMatches(hostname, session)) {
+            return true;
+        } else {
+            return extraHostnameVerifier != null && extraHostnameVerifier.verify(hostname, session);
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java b/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java
new file mode 100644
index 000000000..a25bb467e
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) Will Sargent. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.security.Principal;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * Hostname checker interface.
+ */
+public interface HostnameChecker {
+
+    void match(String hostname, X509Certificate peerCertificate) throws CertificateException;
+
+    boolean match(String hostname, Principal principal);
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/MiscUtil.java b/api/src/main/java/org/asynchttpclient/util/MiscUtils.java
similarity index 66%
rename from api/src/main/java/org/asynchttpclient/util/MiscUtil.java
rename to api/src/main/java/org/asynchttpclient/util/MiscUtils.java
index b65d1e4a7..55b5ba12c 100644
--- a/api/src/main/java/org/asynchttpclient/util/MiscUtil.java
+++ b/api/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -12,12 +12,14 @@
  */
 package org.asynchttpclient.util;
 
+import java.io.Closeable;
+import java.io.IOException;
 import java.util.Collection;
 import java.util.Map;
 
-public class MiscUtil {
+public class MiscUtils {
 
-    private MiscUtil() {
+    private MiscUtils() {
     }
 
     public static boolean isNonEmpty(String string) {
@@ -39,4 +41,21 @@ public static boolean isNonEmpty(Collection<?> collection) {
     public static boolean isNonEmpty(Map<?, ?> map) {
         return map != null && !map.isEmpty();
     }
+
+    public static boolean getBoolean(String systemPropName, boolean defaultValue) {
+        String systemPropValue = System.getProperty(systemPropName);
+        return systemPropValue != null ? systemPropValue.equalsIgnoreCase("true") : defaultValue;
+    }
+
+    public static <T> T withDefault(T value, T defaults) {
+        return value != null ? value : value;
+    }
+
+    public static void closeSilently(Closeable closeable) {
+        if (closeable != null)
+            try {
+                closeable.close();
+            } catch (IOException e) {
+            }
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java b/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java
new file mode 100644
index 000000000..379691129
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Will Sargent. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.Principal;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * A HostnameChecker proxy.
+ */
+public class ProxyHostnameChecker implements HostnameChecker {
+
+    public final static byte TYPE_TLS = 1;
+
+    private final Object checker = getHostnameChecker();
+
+    public ProxyHostnameChecker() {
+    }
+
+    private Object getHostnameChecker() {
+        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            @SuppressWarnings("unchecked")
+            final Class<Object> hostnameCheckerClass = (Class<Object>) classLoader.loadClass("sun.security.util.HostnameChecker");
+            final Method instanceMethod = hostnameCheckerClass.getMethod("getInstance", Byte.TYPE);
+            return instanceMethod.invoke(null, TYPE_TLS);
+        } catch (ClassNotFoundException e) {
+            throw new IllegalStateException(e);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            throw new IllegalStateException(e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public void match(String hostname, X509Certificate peerCertificate) throws CertificateException {
+        try {
+            final Class<?> hostnameCheckerClass = checker.getClass();
+            final Method checkMethod = hostnameCheckerClass.getMethod("match", String.class, X509Certificate.class);
+            checkMethod.invoke(checker, hostname, peerCertificate);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            Throwable t = e.getCause();
+            if (t instanceof CertificateException) {
+                throw (CertificateException) t;
+            } else {
+                throw new IllegalStateException(e);
+            }
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public boolean match(String hostname, Principal principal) {
+        try {
+            final Class<?> hostnameCheckerClass = checker.getClass();
+            final Method checkMethod = hostnameCheckerClass.getMethod("match", String.class, Principal.class);
+            return (Boolean) checkMethod.invoke(null, hostname, principal);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            throw new IllegalStateException(e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 6e33588f6..af66f040c 100644
--- a/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -12,22 +12,33 @@
  */
 package org.asynchttpclient.util;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
-import java.util.List;
-import java.util.Properties;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.ProxyServer.Protocol;
+import org.asynchttpclient.ProxyServerSelector;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.List;
+import java.util.Properties;
 
 /**
  * Utilities for Proxy handling.
  *
  * @author cstamas
  */
-public class ProxyUtils {
+public final class ProxyUtils {
+
+    private final static Logger log = LoggerFactory.getLogger(ProxyUtils.class);
 
     private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
 
@@ -61,6 +72,9 @@
      */
     public static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
 
+    private ProxyUtils() {
+    }
+    
     /**
      * @param config the global config
      * @param request the request
@@ -69,25 +83,34 @@
     public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
         ProxyServer proxyServer = request.getProxyServer();
         if (proxyServer == null) {
-            proxyServer = config.getProxyServer();
+            ProxyServerSelector selector = config.getProxyServerSelector();
+            if (selector != null) {
+                proxyServer = selector.select(request.getUri());
+            }
         }
         return ProxyUtils.avoidProxy(proxyServer, request) ? null : proxyServer;
     }
     
     /**
-     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to
-     * target host. If <code>null</code> proxy is passed in, this method returns true -- since there is NO proxy, we
-     * should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
-     * See http://download.oracle.com/javase/1.4.2/docs/guide/net/properties.html
-     *
-     * @param proxyServer
-     * @param request
-     * @return true if we have to avoid proxy use (obeying non-proxy hosts settings), false otherwise.
+     * @see #avoidProxy(ProxyServer, String)
      */
     public static boolean avoidProxy(final ProxyServer proxyServer, final Request request) {
-        return avoidProxy(proxyServer, AsyncHttpProviderUtils.getHost(request.getOriginalURI()));
+        return avoidProxy(proxyServer, request.getUri().getHost());
     }
 
+    private static boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
+
+        if (nonProxyHost.length() > 1) {
+            if (nonProxyHost.charAt(0) == '*')
+                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1,
+                        nonProxyHost.length() - 1);
+            else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
+                return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
+        }
+
+        return nonProxyHost.equalsIgnoreCase(targetHost);
+    }
+    
     /**
      * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to
      * target host. If <code>null</code> proxy is passed in, this method returns true -- since there is NO proxy, we
@@ -95,23 +118,20 @@ public static boolean avoidProxy(final ProxyServer proxyServer, final Request re
      * See http://download.oracle.com/javase/1.4.2/docs/guide/net/properties.html
      *
      * @param proxyServer
-     * @param target      the hostname
+     * @param hostname      the hostname
      * @return true if we have to avoid proxy use (obeying non-proxy hosts settings), false otherwise.
      */
-    public static boolean avoidProxy(final ProxyServer proxyServer, final String target) {
+    public static boolean avoidProxy(final ProxyServer proxyServer, final String hostname) {
         if (proxyServer != null) {
-            final String targetHost = target.toLowerCase();
+            if (hostname == null)
+                throw new NullPointerException("hostname");
 
             List<String> nonProxyHosts = proxyServer.getNonProxyHosts();
 
             if (isNonEmpty(nonProxyHosts)) {
                 for (String nonProxyHost : nonProxyHosts) {
-                    if (nonProxyHost.startsWith("*") && nonProxyHost.length() > 1
-                            && targetHost.endsWith(nonProxyHost.substring(1).toLowerCase())) {
+                    if (matchNonProxyHost(hostname, nonProxyHost))
                         return true;
-                    } else if (nonProxyHost.equalsIgnoreCase(targetHost)) {
-                        return true;
-                    }
                 }
             }
 
@@ -123,7 +143,6 @@ public static boolean avoidProxy(final ProxyServer proxyServer, final String tar
 
     /**
      * Creates a proxy server instance from the given properties.
-     * <p/>
      * Currently the default http.* proxy properties are supported as well as properties specific for AHC.
      *
      * @param properties the properties to evaluate. Must not be null.
@@ -134,31 +153,97 @@ public static boolean avoidProxy(final ProxyServer proxyServer, final String tar
      * @see #PROXY_PROTOCOL
      * @see #PROXY_NONPROXYHOSTS
      */
-    public static ProxyServer createProxy(Properties properties) {
-        String host = System.getProperty(PROXY_HOST);
+    public static ProxyServerSelector createProxyServerSelector(Properties properties) {
+        String host = properties.getProperty(PROXY_HOST);
 
         if (host != null) {
-            int port = Integer.valueOf(System.getProperty(PROXY_PORT, "80"));
+            int port = Integer.valueOf(properties.getProperty(PROXY_PORT, "80"));
 
             Protocol protocol;
             try {
-                protocol = Protocol.valueOf(System.getProperty(PROXY_PROTOCOL, "HTTP"));
+                protocol = Protocol.valueOf(properties.getProperty(PROXY_PROTOCOL, "HTTP"));
             } catch (IllegalArgumentException e) {
                 protocol = Protocol.HTTP;
             }
 
-            ProxyServer proxyServer = new ProxyServer(protocol, host, port, System.getProperty(PROXY_USER), System.getProperty(PROXY_PASSWORD));
+            ProxyServer proxyServer = new ProxyServer(protocol, host, port, properties.getProperty(PROXY_USER),
+                    properties.getProperty(PROXY_PASSWORD));
 
-            String nonProxyHosts = System.getProperties().getProperty(PROXY_NONPROXYHOSTS);
+            String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
             if (nonProxyHosts != null) {
                 for (String spec : nonProxyHosts.split("\\|")) {
                     proxyServer.addNonProxyHost(spec);
                 }
             }
 
-            return proxyServer;
+            return createProxyServerSelector(proxyServer);
         }
 
-        return null;
+        return ProxyServerSelector.NO_PROXY_SELECTOR;
+    }
+
+    /**
+     * Get a proxy server selector based on the JDK default proxy selector.
+     *
+     * @return The proxy server selector.
+     */
+    public static ProxyServerSelector getJdkDefaultProxyServerSelector() {
+        return createProxyServerSelector(ProxySelector.getDefault());
+    }
+
+    /**
+     * Create a proxy server selector based on the passed in JDK proxy selector.
+     *
+     * @param proxySelector The proxy selector to use.  Must not be null.
+     * @return The proxy server selector.
+     */
+    public static ProxyServerSelector createProxyServerSelector(final ProxySelector proxySelector) {
+        return new ProxyServerSelector() {
+            public ProxyServer select(Uri uri) {
+                try {
+                    URI javaUri = uri.toJavaNetURI();
+
+                    List<Proxy> proxies = proxySelector.select(javaUri);
+                    if (proxies != null) {
+                        // Loop through them until we find one that we know how to use
+                        for (Proxy proxy : proxies) {
+                            switch (proxy.type()) {
+                            case HTTP:
+                                if (!(proxy.address() instanceof InetSocketAddress)) {
+                                    log.warn("Don't know how to connect to address " + proxy.address());
+                                    return null;
+                                } else {
+                                    InetSocketAddress address = (InetSocketAddress) proxy.address();
+                                    return new ProxyServer(Protocol.HTTP, address.getHostName(), address.getPort());
+                                }
+                            case DIRECT:
+                                return null;
+                            default:
+                                log.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
+                                break;
+                            }
+                        }
+                    }
+                    return null;
+                } catch (URISyntaxException e) {
+                    log.warn(uri + " couldn't be turned into a java.net.URI", e);
+                    return null;
+                }
+            }
+        };
+    }
+
+    /**
+     * Create a proxy server selector that always selects a single proxy server.
+     *
+     * @param proxyServer The proxy server to select.
+     * @return The proxy server selector.
+     */
+    public static ProxyServerSelector createProxyServerSelector(final ProxyServer proxyServer) {
+        return new ProxyServerSelector() {
+            public ProxyServer select(Uri uri) {
+                return proxyServer;
+            }
+        };
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/QueryComputer.java b/api/src/main/java/org/asynchttpclient/util/QueryComputer.java
new file mode 100644
index 000000000..1480dd479
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/QueryComputer.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.util.List;
+
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.Param;
+
+public enum QueryComputer {
+
+    URL_ENCODING_ENABLED_QUERY_COMPUTER {
+
+        private final void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
+            UTF8UrlEncoder.appendEncoded(sb, name);
+            if (value != null) {
+                sb.append('=');
+                UTF8UrlEncoder.appendEncoded(sb, value);
+            }
+            sb.append('&');
+        }
+
+        private final void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+            for (Param param : queryParams)
+                encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
+        }
+        
+        // FIXME this could be improved: remove split
+        private final void encodeAndAppendQuery(final StringBuilder sb, final String query) {
+            int pos;
+            for (String queryParamString : query.split("&")) {
+                pos = queryParamString.indexOf('=');
+                if (pos <= 0) {
+                    CharSequence decodedName = UTF8UrlDecoder.decode(queryParamString);
+                    encodeAndAppendQueryParam(sb, decodedName, null);
+                } else {
+                    CharSequence decodedName = UTF8UrlDecoder.decode(queryParamString, 0, pos);
+                    int valueStart = pos + 1;
+                    CharSequence decodedValue = UTF8UrlDecoder.decode(queryParamString, valueStart, queryParamString.length() - valueStart);
+                    encodeAndAppendQueryParam(sb, decodedName, decodedValue);
+                }
+            }
+        }
+        
+        protected final String withQueryWithParams(final String query, final List<Param> queryParams) {
+            // concatenate encoded query + encoded query params
+            StringBuilder sb = new StringBuilder(query.length() + queryParams.size() * 16);
+            encodeAndAppendQuery(sb, query);
+            encodeAndAppendQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+
+        protected final String withQueryWithoutParams(final String query) {
+            // encode query
+            StringBuilder sb = new StringBuilder(query.length() + 6);
+            encodeAndAppendQuery(sb, query);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+
+        protected final String withoutQueryWithParams(final List<Param> queryParams) {
+            // concatenate encoded query params
+            StringBuilder sb = new StringBuilder(queryParams.size() * 16);
+            encodeAndAppendQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+    }, //
+
+    URL_ENCODING_DISABLED_QUERY_COMPUTER {
+
+        private final void appendRawQueryParam(StringBuilder sb, String name, String value) {
+            sb.append(name);
+            if (value != null)
+                sb.append('=').append(value);
+            sb.append('&');
+        }
+        
+        private final void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+            for (Param param : queryParams)
+                appendRawQueryParam(sb, param.getName(), param.getValue());
+        }
+        
+        protected final String withQueryWithParams(final String query, final List<Param> queryParams) {
+            // concatenate raw query + raw query params
+            StringBuilder sb = new StringBuilder(query.length() + queryParams.size() * 16);
+            sb.append(query);
+            appendRawQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+
+        protected final String withQueryWithoutParams(final String query) {
+            // return raw query as is
+            return query;
+        }
+
+        protected final String withoutQueryWithParams(final List<Param> queryParams) {
+            // concatenate raw queryParams
+            StringBuilder sb = new StringBuilder(queryParams.size() * 16);
+            appendRawQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+    };
+
+    public static QueryComputer queryComputer(boolean disableUrlEncoding) {
+        return disableUrlEncoding ? URL_ENCODING_DISABLED_QUERY_COMPUTER : URL_ENCODING_ENABLED_QUERY_COMPUTER;
+    }
+
+    protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
+
+    protected abstract String withQueryWithoutParams(final String query);
+
+    protected abstract String withoutQueryWithParams(final List<Param> queryParams);
+
+    private final String withQuery(final String query, final List<Param> queryParams) {
+        return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
+    }
+
+    private final String withoutQuery(final List<Param> queryParams) {
+        return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
+    }
+
+    public final String computeFullQueryString(final String query, final List<Param> queryParams) {
+        return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/SslUtils.java b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
index 2ac9769b1..becb9ed94 100644
--- a/api/src/main/java/org/asynchttpclient/util/SslUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
@@ -15,95 +15,22 @@
  */
 package org.asynchttpclient.util;
 
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
-import java.io.FileInputStream;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
-import java.security.Security;
 
 /**
  * This class is a copy of http://github.com/sonatype/wagon-ning/raw/master/src/main/java/org/apache/maven/wagon/providers/http/SslUtils.java
  */
 public class SslUtils {
-
-    public static SSLEngine getSSLEngine()
-            throws GeneralSecurityException, IOException {
-        SSLEngine engine = null;
-
-        SSLContext context = getSSLContext();
-        if (context != null) {
-            engine = context.createSSLEngine();
-            engine.setUseClientMode(true);
-        }
-
-        return engine;
-    }
-
-    public static SSLContext getSSLContext()
-            throws GeneralSecurityException, IOException {
-        SSLConfig config = new SSLConfig();
-        if (config.keyStoreLocation == null || config.trustStoreLocation == null) {
-            return getLooseSSLContext();
-        } else {
-            return getStrictSSLContext(config);
-        }
-    }
-
-    static SSLContext getStrictSSLContext(SSLConfig config)
-            throws GeneralSecurityException, IOException {
-        KeyStore keyStore = KeyStore.getInstance(config.keyStoreType);
-        InputStream keystoreInputStream = new FileInputStream(config.keyStoreLocation);
-        try {
-            keyStore.load(keystoreInputStream, (config.keyStorePassword == null) ? null
-                    : config.keyStorePassword.toCharArray());
-        } finally {
-            keystoreInputStream.close();
-        }
-
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(config.keyManagerAlgorithm);
-        keyManagerFactory.init(keyStore, (config.keyManagerPassword == null) ? null
-                : config.keyManagerPassword.toCharArray());
-        KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();
-
-        KeyStore trustStore = KeyStore.getInstance(config.trustStoreType);
-        InputStream truststoreInputStream = new FileInputStream(config.trustStoreLocation);
-        try {
-            trustStore.load(truststoreInputStream, (config.trustStorePassword == null) ? null
-                    : config.trustStorePassword.toCharArray());
-        } finally {
-            truststoreInputStream.close();
-        }
-
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(config.trustManagerAlgorithm);
-        trustManagerFactory.init(trustStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        SSLContext context = SSLContext.getInstance("TLS");
-        context.init(keyManagers, trustManagers, null);
-
-        return context;
-    }
-
-    static SSLContext getLooseSSLContext()
-            throws GeneralSecurityException {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, new TrustManager[]{LooseTrustManager.INSTANCE}, new SecureRandom());
-        return sslContext;
-    }
-
-    static class LooseTrustManager
-            implements X509TrustManager {
-
-        public static final LooseTrustManager INSTANCE = new LooseTrustManager();
+    
+    static class LooseTrustManager implements X509TrustManager {
 
         public java.security.cert.X509Certificate[] getAcceptedIssuers() {
             return new java.security.cert.X509Certificate[0];
@@ -116,53 +43,29 @@ public void checkServerTrusted(java.security.cert.X509Certificate[] certs, Strin
         }
     }
 
-    private final static class SSLConfig {
-
-        public String keyStoreLocation;
-
-        public String keyStoreType = "JKS";
-
-        public String keyStorePassword = "changeit";
-
-        public String keyManagerAlgorithm = "SunX509";
-
-        public String keyManagerPassword = "changeit";
-
-        public String trustStoreLocation;
-
-        public String trustStoreType = "JKS";
-
-        public String trustStorePassword = "changeit";
-
-        public String trustManagerAlgorithm = "SunX509";
-
-        public SSLConfig() {
-            keyStoreLocation = System.getProperty("javax.net.ssl.keyStore");
-            keyStorePassword = System.getProperty("javax.net.ssl.keyStorePassword", "changeit");
-            keyStoreType = System.getProperty("javax.net.ssl.keyStoreType", KeyStore.getDefaultType());
-            keyManagerAlgorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");
-
-            if (keyManagerAlgorithm == null) {
-                keyManagerAlgorithm = "SunX509";
-            }
-
-            keyManagerPassword = System.getProperty("javax.net.ssl.keyStorePassword", "changeit");
-
-            trustStoreLocation = System.getProperty("javax.net.ssl.trustStore");
-            if (trustStoreLocation == null) {
-                trustStoreLocation = keyStoreLocation;
-                trustStorePassword = keyStorePassword;
-                trustStoreType = keyStoreType;
-            } else {
-                trustStorePassword = System.getProperty("javax.net.ssl.trustStorePassword", "changeit");
-                trustStoreType = System.getProperty("javax.net.ssl.trustStoreType", KeyStore.getDefaultType());
-            }
-            trustManagerAlgorithm = Security.getProperty("ssl.TrustManagerFactory.algorithm");
-
-            if (trustManagerAlgorithm == null) {
-                trustManagerAlgorithm = "SunX509";
-            }
+    private SSLContext looseTrustManagerSSLContext = looseTrustManagerSSLContext(); 
+    
+    private SSLContext looseTrustManagerSSLContext() {
+        try {
+            SSLContext sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(null, new TrustManager[] { new LooseTrustManager() }, new SecureRandom());
+            return sslContext;
+        } catch (NoSuchAlgorithmException e) {
+           throw new ExceptionInInitializerError(e);
+        } catch (KeyManagementException e) {
+            throw new ExceptionInInitializerError(e);
         }
     }
+    
+    private static class SingletonHolder {
+        public static final SslUtils instance = new SslUtils();
+    }
 
+    public static SslUtils getInstance() {
+        return SingletonHolder.instance;
+    }
+
+    public SSLContext getSSLContext(boolean acceptAnyCertificate) throws GeneralSecurityException, IOException {
+        return acceptAnyCertificate? looseTrustManagerSSLContext: SSLContext.getDefault();
+    }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java b/api/src/main/java/org/asynchttpclient/util/StandardCharsets.java
similarity index 58%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
rename to api/src/main/java/org/asynchttpclient/util/StandardCharsets.java
index 94c6f0d7a..13eb64a40 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
+++ b/api/src/main/java/org/asynchttpclient/util/StandardCharsets.java
@@ -13,16 +13,17 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.util;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RemoteSiteTest;
+import java.nio.charset.Charset;
 
-public class NettyRemoteSiteTest extends RemoteSiteTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
+public final class StandardCharsets {
+
+    public static final Charset US_ASCII = Charset.forName("US-ASCII");
+    public static final Charset UTF_8 = Charset.forName("UTF-8");
+    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+    public static final Charset UNICODE_LITTLE_UNMARKED = Charset.forName("UnicodeLittleUnmarked");
 
+    private StandardCharsets() {
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/StringCharSequence.java b/api/src/main/java/org/asynchttpclient/util/StringCharSequence.java
new file mode 100644
index 000000000..a1cf2192f
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/StringCharSequence.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+/**
+ * A CharSequence String wrapper that doesn't copy the char[] (damn new String implementation!!!)
+ * 
+ * @author slandelle
+ */
+public class StringCharSequence implements CharSequence {
+
+    private final String value;
+    private final int offset;
+    public final int length;
+    
+    public StringCharSequence(String value, int offset, int length) {
+        this.value = value;
+        this.offset = offset;
+        this.length = length;
+    }
+    
+    @Override
+    public int length() {
+        return length;
+    }
+
+    @Override
+    public char charAt(int index) {
+        return value.charAt(offset + index);
+    }
+
+    @Override
+    public CharSequence subSequence(int start, int end) {
+        int offsetedEnd = offset + end;
+        if (offsetedEnd < length)
+            throw new ArrayIndexOutOfBoundsException();
+        return new StringCharSequence(value, offset + start, end - start);
+    }
+    
+    @Override
+    public String toString() {
+        return value.substring(offset, length);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/UTF8Codec.java b/api/src/main/java/org/asynchttpclient/util/UTF8Codec.java
deleted file mode 100644
index 8a18326cd..000000000
--- a/api/src/main/java/org/asynchttpclient/util/UTF8Codec.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.util;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Wrapper class for more convenient (and possibly more efficient in future)
- * UTF-8 encoding and decoding.
- */
-public class UTF8Codec {
-    private final static String ENCODING_UTF8 = "UTF-8";
-
-    // When we move to JDK 1.6+, we can do this:
-    /*
-    import java.nio.charset.Charset;
-
-    private final static Charset utf8;
-    static {
-        utf8 = Charset.forName("UTF-8");
-    }
-
-    public static byte[] toUTF8(String input) {
-        return input.getBytes(utf8);
-    }
-
-    public static String fromUTF8(byte[] input) {
-        return fromUTF8(input, 0, input.length);
-    }
-    
-    public static String fromUTF8(byte[] input, int offset, int len) {
-        return new String(input, offset, len, utf8);
-    }
-    */
-
-    // But until then (with 1.5)
-    public static byte[] toUTF8(String input) {
-        try {
-            return input.getBytes(ENCODING_UTF8);
-        } catch (UnsupportedEncodingException e) { // never happens, but since it's declared...
-            throw new IllegalStateException();
-        }
-    }
-
-    public static String fromUTF8(byte[] input) {
-        return fromUTF8(input, 0, input.length);
-    }
-
-    public static String fromUTF8(byte[] input, int offset, int len) {
-        try {
-            return new String(input, offset, len, ENCODING_UTF8);
-        } catch (UnsupportedEncodingException e) { // never happens
-            throw new IllegalStateException();
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java b/api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java
new file mode 100644
index 000000000..7184aea11
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+public final class UTF8UrlDecoder {
+
+    private UTF8UrlDecoder() {
+    }
+
+    private static StringBuilder initSb(StringBuilder sb, String s, int i, int offset, int length) {
+        if (sb != null) {
+            return sb;
+        } else {
+            int initialSbLength = length > 500 ? length / 2 : length;
+            return new StringBuilder(initialSbLength).append(s, offset, i);
+        }
+    }
+
+    private static int hexaDigit(char c) {
+        return Character.digit(c, 16);
+    }
+
+    public static CharSequence decode(String s) {
+        return decode(s, 0, s.length());
+    }
+    
+    public static CharSequence decode(final String s, final int offset, final int length) {
+
+        StringBuilder sb = null;
+        int i = offset;
+        int end = length + offset;
+
+        while (i < end) {
+            char c = s.charAt(i);
+            if (c == '+') {
+                sb = initSb(sb, s, i, offset, length);
+                sb.append(' ');
+                i++;
+
+            } else if (c == '%') {
+                if (end - i < 3) // We expect 3 chars. 0 based i vs. 1 based length!
+                    throw new IllegalArgumentException("UTF8UrlDecoder: Incomplete trailing escape (%) pattern");
+
+                int x, y;
+                if ((x = hexaDigit(s.charAt(i + 1))) == -1 || (y = hexaDigit(s.charAt(i + 2))) == -1)
+                    throw new IllegalArgumentException("UTF8UrlDecoder: Malformed");
+
+                sb = initSb(sb, s, i, offset, length);
+                sb.append((char) (x * 16 + y));
+                i += 3;
+            } else {
+                if (sb != null)
+                    sb.append(c);
+                i++;
+            }
+        }
+
+        return sb != null ? sb.toString() : new StringCharSequence(s, offset, length);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java b/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
index 80b5ca4e8..78cb74d9e 100644
--- a/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
+++ b/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
@@ -20,31 +20,31 @@
  * (as per RFC-3986, see [http://www.ietf.org/rfc/rfc3986.txt]).
  */
 public class UTF8UrlEncoder {
-    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.UTF8UrlEncoder.encodeSpaceUsingPlus") == null ? false : true;
+    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.UTF8UrlEncoder.encodeSpaceUsingPlus") != null;
 
     /**
      * Encoding table used for figuring out ascii characters that must be escaped
-     * (all non-Ascii characers need to be encoded anyway)
+     * (all non-Ascii characters need to be encoded anyway)
      */
-    private final static int[] SAFE_ASCII = new int[128];
+    private final static boolean[] SAFE_ASCII = new boolean[128];
 
     static {
         for (int i = 'a'; i <= 'z'; ++i) {
-            SAFE_ASCII[i] = 1;
+            SAFE_ASCII[i] = true;
         }
         for (int i = 'A'; i <= 'Z'; ++i) {
-            SAFE_ASCII[i] = 1;
+            SAFE_ASCII[i] = true;
         }
         for (int i = '0'; i <= '9'; ++i) {
-            SAFE_ASCII[i] = 1;
+            SAFE_ASCII[i] = true;
         }
-        SAFE_ASCII['-'] = 1;
-        SAFE_ASCII['.'] = 1;
-        SAFE_ASCII['_'] = 1;
-        SAFE_ASCII['~'] = 1;
+        SAFE_ASCII['-'] = true;
+        SAFE_ASCII['.'] = true;
+        SAFE_ASCII['_'] = true;
+        SAFE_ASCII['~'] = true;
     }
 
-    private final static char[] HEX = "0123456789ABCDEF".toCharArray();
+    private static final char[] HEX = "0123456789ABCDEF".toCharArray();
 
     private UTF8UrlEncoder() {
     }
@@ -55,20 +55,17 @@ public static String encode(String input) {
         return sb.toString();
     }
 
-    public static StringBuilder appendEncoded(StringBuilder sb, String input) {
-        final int[] safe = SAFE_ASCII;
-
-        for (int i = 0, len = input.length(); i < len; ++i) {
-            char c = input.charAt(i);
-            if (c <= 127) {
-                if (safe[c] != 0) {
-                    sb.append(c);
-                } else {
+    public static StringBuilder appendEncoded(StringBuilder sb, CharSequence input) {
+        int c;
+        for (int i = 0; i < input.length(); i+= Character.charCount(c)) {
+            c = Character.codePointAt(input, i);
+            if (c <= 127)
+                if (SAFE_ASCII[c])
+                    sb.append((char) c);
+                else
                     appendSingleByteEncoded(sb, c);
-                }
-            } else {
+            else
                 appendMultiByteEncoded(sb, c);
-            }
         }
         return sb;
     }
@@ -86,15 +83,18 @@ private final static void appendSingleByteEncoded(StringBuilder sb, int value) {
     }
 
     private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
-        // two or three bytes? (ignoring surrogate pairs for now, which would yield 4 bytes)
         if (value < 0x800) {
             appendSingleByteEncoded(sb, (0xc0 | (value >> 6)));
             appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
-        } else {
+        } else if (value < 0x10000) {
             appendSingleByteEncoded(sb, (0xe0 | (value >> 12)));
             appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)));
             appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
+        } else {
+            appendSingleByteEncoded(sb, (0xf0 | (value >> 18)));
+            appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f));
+            appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f));
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
         }
     }
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index 74ac5ab68..f28986f7c 100644
--- a/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -13,12 +13,25 @@
 
 package org.asynchttpclient.webdav;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -27,14 +40,6 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
 /**
  * Simple {@link AsyncHandler} that add support for WebDav's response manipulation.
  *
@@ -43,15 +48,14 @@
 public abstract class WebDavCompletionHandlerBase<T> implements AsyncHandler<T> {
     private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
 
-    private final List<HttpResponseBodyPart> bodies =
-            Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
+    private final List<HttpResponseBodyPart> bodies = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
     private HttpResponseStatus status;
     private HttpResponseHeaders headers;
 
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public final STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
         bodies.add(content);
         return STATE.CONTINUE;
@@ -60,7 +64,7 @@ public final STATE onBodyPartReceived(final HttpResponseBodyPart content) throws
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public final STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
         this.status = status;
         return STATE.CONTINUE;
@@ -69,7 +73,7 @@ public final STATE onStatusReceived(final HttpResponseStatus status) throws Exce
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public final STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
         this.headers = headers;
         return STATE.CONTINUE;
@@ -78,15 +82,15 @@ public final STATE onHeadersReceived(final HttpResponseHeaders headers) throws E
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public final T onCompleted() throws Exception {
         if (status != null) {
-            Response response = status.provider().prepareResponse(status, headers, bodies);
+            Response response = status.prepareResponse(headers, bodies);
             Document document = null;
             if (status.getStatusCode() == 207) {
                 document = readXMLResponse(response.getResponseBodyAsStream());
             }
-            return onCompleted(new WebDavResponse(status.provider().prepareResponse(status, headers, bodies), document));
+            return onCompleted(new WebDavResponse(status.prepareResponse(headers, bodies), document));
         } else {
             throw new IllegalStateException("Status is null");
         }
@@ -95,7 +99,7 @@ public final T onCompleted() throws Exception {
     /**
      * {@inheritDoc}
      */
-    /* @Override */
+    @Override
     public void onThrowable(Throwable t) {
         logger.debug(t.getMessage(), t);
     }
@@ -108,50 +112,152 @@ public void onThrowable(Throwable t) {
      */
     abstract public T onCompleted(WebDavResponse response) throws Exception;
 
-
     private class HttpStatusWrapper extends HttpResponseStatus {
 
-        private final HttpResponseStatus wrapper;
+        private final HttpResponseStatus wrapped;
 
         private final String statusText;
 
         private final int statusCode;
 
         public HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int statusCode) {
-            super(wrapper.getUrl(), wrapper.provider());
-            this.wrapper = wrapper;
+            super(wrapper.getUri(), null);
+            this.wrapped = wrapper;
             this.statusText = statusText;
             this.statusCode = statusCode;
         }
 
+        @Override
+        public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
+            final Response wrappedResponse = wrapped.prepareResponse(headers, bodyParts);
+
+            return new Response() {
+
+                @Override
+                public int getStatusCode() {
+                    return statusCode;
+                }
+
+                @Override
+                public String getStatusText() {
+                    return statusText;
+                }
+
+                @Override
+                public byte[] getResponseBodyAsBytes() throws IOException {
+                    return wrappedResponse.getResponseBodyAsBytes();
+                }
+
+                @Override
+                public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+                    return wrappedResponse.getResponseBodyAsByteBuffer();
+                }
+
+                @Override
+                public InputStream getResponseBodyAsStream() throws IOException {
+                    return wrappedResponse.getResponseBodyAsStream();
+                }
+
+                @Override
+                public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
+                    return wrappedResponse.getResponseBodyExcerpt(maxLength, charset);
+                }
+
+                @Override
+                public String getResponseBody(String charset) throws IOException {
+                    return wrappedResponse.getResponseBody(charset);
+                }
+
+                @Override
+                public String getResponseBodyExcerpt(int maxLength) throws IOException {
+                    return wrappedResponse.getResponseBodyExcerpt(maxLength);
+                }
+
+                @Override
+                public String getResponseBody() throws IOException {
+                    return wrappedResponse.getResponseBody();
+                }
+
+                @Override
+                public Uri getUri() {
+                    return wrappedResponse.getUri();
+                }
+
+                @Override
+                public String getContentType() {
+                    return wrappedResponse.getContentType();
+                }
+
+                @Override
+                public String getHeader(String name) {
+                    return wrappedResponse.getHeader(name);
+                }
+
+                @Override
+                public List<String> getHeaders(String name) {
+                    return wrappedResponse.getHeaders(name);
+                }
+
+                @Override
+                public FluentCaseInsensitiveStringsMap getHeaders() {
+                    return wrappedResponse.getHeaders();
+                }
+
+                @Override
+                public boolean isRedirected() {
+                    return wrappedResponse.isRedirected();
+                }
+
+                @Override
+                public List<Cookie> getCookies() {
+                    return wrappedResponse.getCookies();
+                }
+
+                @Override
+                public boolean hasResponseStatus() {
+                    return wrappedResponse.hasResponseStatus();
+                }
+
+                @Override
+                public boolean hasResponseHeaders() {
+                    return wrappedResponse.hasResponseHeaders();
+                }
+
+                @Override
+                public boolean hasResponseBody() {
+                    return wrappedResponse.hasResponseBody();
+                }
+            };
+        }
+
         @Override
         public int getStatusCode() {
-            return (statusText == null ? wrapper.getStatusCode() : statusCode);
+            return (statusText == null ? wrapped.getStatusCode() : statusCode);
         }
 
         @Override
         public String getStatusText() {
-            return (statusText == null ? wrapper.getStatusText() : statusText);
+            return (statusText == null ? wrapped.getStatusText() : statusText);
         }
 
         @Override
         public String getProtocolName() {
-            return wrapper.getProtocolName();
+            return wrapped.getProtocolName();
         }
 
         @Override
         public int getProtocolMajorVersion() {
-            return wrapper.getProtocolMajorVersion();
+            return wrapped.getProtocolMajorVersion();
         }
 
         @Override
         public int getProtocolMinorVersion() {
-            return wrapper.getProtocolMinorVersion();
+            return wrapped.getProtocolMinorVersion();
         }
 
         @Override
         public String getProtocolText() {
-            return wrapper.getStatusText();
+            return wrapped.getStatusText();
         }
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
index 340e4be2e..5f89a62cc 100644
--- a/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
@@ -12,18 +12,17 @@
  */
 package org.asynchttpclient.webdav;
 
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.Response;
-import org.w3c.dom.Document;
-
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URI;
 import java.nio.ByteBuffer;
 import java.util.List;
 
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
+import org.w3c.dom.Document;
+
 /**
  * Customized {@link Response} which add support for getting the response's body as an XML document (@link WebDavResponse#getBodyAsXML}
  */
@@ -45,7 +44,7 @@ public String getStatusText() {
         return response.getStatusText();
     }
 
-    /* @Override */
+    @Override
     public byte[] getResponseBodyAsBytes() throws IOException {
         return response.getResponseBodyAsBytes();
     }
@@ -74,7 +73,7 @@ public String getResponseBody(String charset) throws IOException {
         return response.getResponseBody(charset);
     }
 
-    public URI getUri() throws MalformedURLException {
+    public Uri getUri() {
         return response.getUri();
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java b/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
index 218d5ab32..7e465acff 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
@@ -20,10 +20,10 @@
  * 
  * @since 1.7.0
  */
-public class DefaultWebSocketListener implements  WebSocketByteListener, WebSocketTextListener, WebSocketPingListener, WebSocketPongListener {
+public class DefaultWebSocketListener implements WebSocketByteListener, WebSocketTextListener, WebSocketPingListener, WebSocketPongListener {
 
     protected WebSocket webSocket;
-    
+
     // -------------------------------------- Methods from WebSocketByteListener
 
     /**
@@ -33,16 +33,8 @@
     public void onMessage(byte[] message) {
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onFragment(byte[] fragment, boolean last) {
-    }
-
-    
     // -------------------------------------- Methods from WebSocketPingListener
-    
+
     /**
      * {@inheritDoc}
      */
@@ -50,19 +42,16 @@ public void onFragment(byte[] fragment, boolean last) {
     public void onPing(byte[] message) {
     }
 
-    
     // -------------------------------------- Methods from WebSocketPongListener
-    
+
     /**
      * {@inheritDoc}
      */
     @Override
     public void onPong(byte[] message) {
     }
-    
-    
-    // -------------------------------------- Methods from WebSocketTextListener
 
+    // -------------------------------------- Methods from WebSocketTextListener
 
     /**
      * {@inheritDoc}
@@ -71,14 +60,6 @@ public void onPong(byte[] message) {
     public void onMessage(String message) {
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onFragment(String fragment, boolean last) {
-    }
-    
-    
     // ------------------------------------------ Methods from WebSocketListener
 
     /**
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
index 9e9c981c1..321cffaf3 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
@@ -52,7 +52,7 @@
      * @param message a text message
      * @return this.
      */
-    WebSocket sendTextMessage(String message);
+    WebSocket sendMessage(String message);
 
     /**
      * Allows streaming of multiple text fragments.
@@ -61,7 +61,7 @@
      * @param last     flag indicating whether or not this is the last fragment.
      * @return this.
      */
-    WebSocket streamText(String fragment, boolean last);
+    WebSocket stream(String fragment, boolean last);
 
     /**
      * Send a <code>ping</ping> with an optional payload
@@ -108,3 +108,4 @@
      */
     void close();
 }
+
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java
new file mode 100644
index 000000000..9988115b2
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+
+/**
+ * Invoked when WebSocket binary fragments are received.
+ * 
+ * @param fragment text fragment
+ */
+public interface WebSocketByteFragmentListener extends WebSocketListener {
+
+    void onFragment(HttpResponseBodyPart fragment);
+}
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
index 86ed26180..99fb4cede 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
@@ -19,17 +19,8 @@
 
     /**
      * Invoked when bytes are available.
+     * 
      * @param message a byte array.
      */
     void onMessage(byte[] message);
-
-
-    /**
-     * Invoked when bytes of a fragmented message are available.
-     *
-     * @param fragment byte[] fragment.
-     * @param last if this fragment is the last in the series.
-     */
-    void onFragment(byte[] fragment, boolean last);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
index bf187be07..6c8b7fbc2 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
@@ -37,5 +37,4 @@
      * @param t a {@link Throwable}
      */
     void onError(Throwable t);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
index 7abc8ab4a..0567c90c2 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
@@ -22,5 +22,4 @@
      * @param message a byte array
      */
     void onPing(byte[] message);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
index f140a2208..a27e93bfd 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
@@ -22,5 +22,4 @@
      * @param message a byte array
      */
     void onPong(byte[] message);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java
new file mode 100644
index 000000000..a71f9364b
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+
+/**
+ * Invoked when WebSocket text fragments are received.
+ * 
+ * @param fragment text fragment
+ */
+public interface WebSocketTextFragmentListener extends WebSocketListener {
+
+    void onFragment(HttpResponseBodyPart fragment);
+}
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
index d52bfad0e..7f8242c74 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
@@ -22,13 +22,4 @@
      * @param message a {@link String} message
      */
     void onMessage(String message);
-
-    /**
-     * Invoked when WebSocket text fragments are received.
-     *
-     * @param fragment text fragment
-     * @param last if this fragment is the last of the series.
-     */
-    void onFragment(String fragment, boolean last);
-
 }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
index 870d74c54..b612c9b0a 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
@@ -12,36 +12,29 @@
  */
 package org.asynchttpclient.websocket;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.UpgradeHandler;
 
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 /**
  * An {@link AsyncHandler} which is able to execute WebSocket upgrade. Use the Builder for configuring WebSocket options.
  */
 public class WebSocketUpgradeHandler implements UpgradeHandler<WebSocket>, AsyncHandler<WebSocket> {
 
     private WebSocket webSocket;
-    private final ConcurrentLinkedQueue<WebSocketListener> l;
-    @SuppressWarnings("unused")
-    private final String protocol;
-    @SuppressWarnings("unused")
-    private final long maxByteSize;
-    @SuppressWarnings("unused")
-    private final long maxTextSize;
+    private final List<WebSocketListener> listeners;
     private final AtomicBoolean ok = new AtomicBoolean(false);
-    private final AtomicBoolean onSuccessCalled = new AtomicBoolean(false);
+    private boolean onSuccessCalled;
+    private int status;
 
-    private WebSocketUpgradeHandler(Builder b) {
-        l = b.l;
-        protocol = b.protocol;
-        maxByteSize = b.maxByteSize;
-        maxTextSize = b.maxTextSize;
+    public WebSocketUpgradeHandler(List<WebSocketListener> listeners) {
+        this.listeners = listeners;
     }
 
     /**
@@ -52,8 +45,10 @@ public final void onThrowable(Throwable t) {
         onFailure(t);
     }
 
-    public boolean touchSuccess(){
-        return onSuccessCalled.getAndSet(true);
+    public boolean touchSuccess() {
+        boolean prev = onSuccessCalled;
+        onSuccessCalled = true;
+        return prev;
     }
 
     /**
@@ -69,6 +64,7 @@ public final STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exce
      */
     @Override
     public final STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+        status = responseStatus.getStatusCode();
         if (responseStatus.getStatusCode() == 101) {
             return STATE.UPGRADE;
         } else {
@@ -89,6 +85,15 @@ public final STATE onHeadersReceived(HttpResponseHeaders headers) throws Excepti
      */
     @Override
     public final WebSocket onCompleted() throws Exception {
+
+        if (status != 101) {
+            IllegalStateException e = new IllegalStateException("Invalid Status Code " + status);
+            for (WebSocketListener listener : listeners) {
+                listener.onError(e);
+            }
+            return null;
+        }
+
         if (webSocket == null) {
             throw new IllegalStateException("WebSocket is null");
         }
@@ -101,9 +106,9 @@ public final WebSocket onCompleted() throws Exception {
     @Override
     public final void onSuccess(WebSocket webSocket) {
         this.webSocket = webSocket;
-        for (WebSocketListener w : l) {
-            webSocket.addWebSocketListener(w);
-            w.onOpen(webSocket);
+        for (WebSocketListener listener : listeners) {
+            webSocket.addWebSocketListener(listener);
+            listener.onOpen(webSocket);
         }
         ok.set(true);
     }
@@ -113,25 +118,26 @@ public final void onSuccess(WebSocket webSocket) {
      */
     @Override
     public final void onFailure(Throwable t) {
-        for (WebSocketListener w : l) {
+        for (WebSocketListener listener : listeners) {
             if (!ok.get() && webSocket != null) {
-                webSocket.addWebSocketListener(w);
+                webSocket.addWebSocketListener(listener);
             }
-            w.onError(t);
+            listener.onError(t);
         }
     }
 
     public final void onClose(WebSocket webSocket, int status, String reasonPhrase) {
         // Connect failure
-        if (this.webSocket == null) this.webSocket = webSocket;
+        if (this.webSocket == null)
+            this.webSocket = webSocket;
 
-        for (WebSocketListener w : l) {
+        for (WebSocketListener listener : listeners) {
             if (webSocket != null) {
-                webSocket.addWebSocketListener(w);
+                webSocket.addWebSocketListener(listener);
             }
-            w.onClose(webSocket);
-            if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(w.getClass())) {
-                WebSocketCloseCodeReasonListener.class.cast(w).onClose(webSocket, status, reasonPhrase);
+            listener.onClose(webSocket);
+            if (listener instanceof WebSocketCloseCodeReasonListener) {
+                WebSocketCloseCodeReasonListener.class.cast(listener).onClose(webSocket, status, reasonPhrase);
             }
         }
     }
@@ -140,10 +146,8 @@ public final void onClose(WebSocket webSocket, int status, String reasonPhrase)
      * Build a {@link WebSocketUpgradeHandler}
      */
     public final static class Builder {
-        private ConcurrentLinkedQueue<WebSocketListener> l = new ConcurrentLinkedQueue<WebSocketListener>();
-        private String protocol = "";
-        private long maxByteSize = 8192;
-        private long maxTextSize = 8192;
+
+        private List<WebSocketListener> listeners = new ArrayList<WebSocketListener>();
 
         /**
          * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
@@ -152,7 +156,7 @@ public final void onClose(WebSocket webSocket, int status, String reasonPhrase)
          * @return this
          */
         public Builder addWebSocketListener(WebSocketListener listener) {
-            l.add(listener);
+            listeners.add(listener);
             return this;
         }
 
@@ -163,49 +167,17 @@ public Builder addWebSocketListener(WebSocketListener listener) {
          * @return this
          */
         public Builder removeWebSocketListener(WebSocketListener listener) {
-            l.remove(listener);
-            return this;
-        }
-
-        /**
-         * Set the WebSocket protocol.
-         *
-         * @param protocol the WebSocket protocol.
-         * @return this
-         */
-        public Builder setProtocol(String protocol) {
-            this.protocol = protocol;
-            return this;
-        }
-
-        /**
-         * Set the max size of the WebSocket byte message that will be sent.
-         *
-         * @param maxByteSize max size of the WebSocket byte message
-         * @return this
-         */
-        public Builder setMaxByteSize(long maxByteSize) {
-            this.maxByteSize = maxByteSize;
-            return this;
-        }
-
-        /**
-         * Set the max size of the WebSocket text message that will be sent.
-         *
-         * @param maxTextSize max size of the WebSocket byte message
-         * @return this
-         */
-        public Builder setMaxTextSize(long maxTextSize) {
-            this.maxTextSize = maxTextSize;
+            listeners.remove(listener);
             return this;
         }
 
         /**
          * Build a {@link WebSocketUpgradeHandler}
+         *
          * @return a {@link WebSocketUpgradeHandler}
          */
         public WebSocketUpgradeHandler build() {
-            return new WebSocketUpgradeHandler(this);
+            return new WebSocketUpgradeHandler(listeners);
         }
     }
 }
diff --git a/api/src/main/resources/ahc-default.properties b/api/src/main/resources/ahc-default.properties
new file mode 100644
index 000000000..9ea9756cf
--- /dev/null
+++ b/api/src/main/resources/ahc-default.properties
@@ -0,0 +1,27 @@
+org.asynchttpclient.AsyncHttpClientConfig.maxConnections=-1
+org.asynchttpclient.AsyncHttpClientConfig.maxConnectionsPerHost=-1
+org.asynchttpclient.AsyncHttpClientConfig.connectionTimeout=60000
+org.asynchttpclient.AsyncHttpClientConfig.pooledConnectionIdleTimeout=60000
+org.asynchttpclient.AsyncHttpClientConfig.readTimeout=60000
+org.asynchttpclient.AsyncHttpClientConfig.requestTimeout=60000
+org.asynchttpclient.AsyncHttpClientConfig.webSocketTimeout=900000
+org.asynchttpclient.AsyncHttpClientConfig.connectionTTL=-1
+org.asynchttpclient.AsyncHttpClientConfig.followRedirect=false
+org.asynchttpclient.AsyncHttpClientConfig.maxRedirects=5
+org.asynchttpclient.AsyncHttpClientConfig.compressionEnforced=false
+org.asynchttpclient.AsyncHttpClientConfig.userAgent=NING/1.0
+org.asynchttpclient.AsyncHttpClientConfig.ioThreadMultiplier=2
+org.asynchttpclient.AsyncHttpClientConfig.useProxySelector=false
+org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties=false
+org.asynchttpclient.AsyncHttpClientConfig.strict302Handling=false
+org.asynchttpclient.AsyncHttpClientConfig.allowPoolingConnections=true
+org.asynchttpclient.AsyncHttpClientConfig.useRelativeURIsWithConnectProxies=true
+org.asynchttpclient.AsyncHttpClientConfig.requestCompressionLevel=-1
+org.asynchttpclient.AsyncHttpClientConfig.maxRequestRetry=5
+org.asynchttpclient.AsyncHttpClientConfig.allowPoolingSslConnections=true
+org.asynchttpclient.AsyncHttpClientConfig.disableUrlEncodingForBoundRequests=false
+org.asynchttpclient.AsyncHttpClientConfig.removeQueryParamOnRedirect=true
+org.asynchttpclient.AsyncHttpClientConfig.spdyEnabled=false
+org.asynchttpclient.AsyncHttpClientConfig.spdyInitialWindowSize=10485760
+org.asynchttpclient.AsyncHttpClientConfig.spdyMaxConcurrentStreams=100
+org.asynchttpclient.AsyncHttpClientConfig.acceptAnyCertificate=false
\ No newline at end of file
diff --git a/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
new file mode 100644
index 000000000..67034b7cb
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -0,0 +1,190 @@
+package org.asynchttpclient;
+
+import org.asynchttpclient.util.AsyncPropertiesHelper;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.lang.reflect.Method;
+
+@Test
+public class AsyncHttpClientDefaultsTest {
+    public static final String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
+    
+    public void testDefaultMaxTotalConnections() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(),-1);
+        testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
+    }
+
+    public void testDefaultMaxConnectionPerHost() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnectionsPerHost(), -1);
+        testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
+    }
+
+    public void testDefaultConnectionTimeOutInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTimeout(), 60 * 1000);
+        testIntegerSystemProperty("connectionTimeout", "defaultConnectionTimeout", "100");
+    }
+
+    public void testDefaultIdleConnectionInPoolTimeoutInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
+        testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
+    }
+
+    public void testDefaultIdleConnectionTimeoutInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
+        testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
+    }
+
+    public void testDefaultRequestTimeoutInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
+        testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
+    }
+
+    public void testDefaultWebSocketIdleTimeoutInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultWebSocketTimeout(), 15 * 60 * 1000);
+        testIntegerSystemProperty("webSocketTimeout", "defaultWebSocketTimeout", "100");
+    }
+
+    public void testDefaultMaxConnectionLifeTimeInMs() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTTL(), -1);
+        testIntegerSystemProperty("connectionTTL", "defaultConnectionTTL", "100");
+    }
+
+    public void testDefaultFollowRedirect() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultFollowRedirect());
+        testBooleanSystemProperty("followRedirect", "defaultFollowRedirect", "true");
+    }
+
+    public void testDefaultMaxRedirects() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRedirects(), 5);
+        testIntegerSystemProperty("maxRedirects", "defaultMaxRedirects", "100");
+    }
+
+    public void testDefaultCompressionEnforced() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultCompressionEnforced());
+        testBooleanSystemProperty("compressionEnforced", "defaultCompressionEnforced", "true");
+    }
+
+    public void testDefaultUserAgent() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(),"NING/1.0");
+        testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
+    }
+
+    public void testDefaultIoThreadMultiplier() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultIoThreadMultiplier(), 2);
+        testIntegerSystemProperty("ioThreadMultiplier", "defaultIoThreadMultiplier", "100");
+    }
+
+    public void testDefaultUseProxySelector() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxySelector());
+        testBooleanSystemProperty("useProxySelector", "defaultUseProxySelector", "true");
+    }
+
+    public void testDefaultUseProxyProperties() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxyProperties());
+        testBooleanSystemProperty("useProxyProperties", "defaultUseProxyProperties", "true");
+    }
+
+    public void testDefaultStrict302Handling() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultStrict302Handling());
+        testBooleanSystemProperty("strict302Handling", "defaultStrict302Handling", "true");
+    }
+
+    public void testDefaultAllowPoolingConnection() {
+       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultAllowPoolingConnections());
+       testBooleanSystemProperty("allowPoolingConnections", "defaultAllowPoolingConnections", "false");
+    }
+
+    public void testDefaultUseRelativeURIsWithConnectProxies() {
+       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultUseRelativeURIsWithConnectProxies());
+       testBooleanSystemProperty("useRelativeURIsWithConnectProxies", "defaultUseRelativeURIsWithConnectProxies", "false");
+    }
+
+    public void testDefaultMaxRequestRetry() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
+        testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
+    }
+
+    public void testDefaultAllowSslConnectionPool() {
+       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultAllowPoolingSslConnections());
+       testBooleanSystemProperty("allowPoolingSslConnections", "defaultAllowPoolingSslConnections", "false");
+    }
+
+    public void testDefaultDisableUrlEncodingForBoundRequests() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultDisableUrlEncodingForBoundRequests());
+        testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
+    }
+
+    public void testDefaultRemoveQueryParamOnRedirect() {
+       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultRemoveQueryParamOnRedirect());
+       testBooleanSystemProperty("removeQueryParamOnRedirect", "defaultRemoveQueryParamOnRedirect", "false");
+    }
+
+    public void testDefaultSpdyEnabled() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultSpdyEnabled());
+        testBooleanSystemProperty("spdyEnabled", "defaultSpdyEnabled", "true");
+    }
+
+    public void testDefaultSpdyInitialWindowSize() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultSpdyInitialWindowSize(), 10 * 1024 * 1024);
+        testIntegerSystemProperty("spdyInitialWindowSize", "defaultSpdyInitialWindowSize", "100");
+    }
+
+    public void testDefaultSpdyMaxConcurrentStreams() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultSpdyMaxConcurrentStreams(), 100);
+        testIntegerSystemProperty("spdyMaxConcurrentStreams", "defaultSpdyMaxConcurrentStreams", "100");
+    }
+    
+    public void testDefaultAcceptAnyCertificate() {
+       Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultAcceptAnyCertificate());
+       testBooleanSystemProperty("acceptAnyCertificate", "defaultAcceptAnyCertificate", "true");
+    }
+    
+    private void testIntegerSystemProperty(String propertyName,String methodName,String value){
+        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
+        System.setProperty(ASYNC_CLIENT + propertyName, value);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
+            Assert.assertEquals(method.invoke(null, new Object[]{}),Integer.parseInt(value));
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName,e);
+        } 
+        if(previous != null)
+            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT + propertyName);
+    }
+    
+    private void testBooleanSystemProperty(String propertyName,String methodName,String value){
+        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
+        System.setProperty(ASYNC_CLIENT + propertyName, value);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
+            Assert.assertEquals(method.invoke(null, new Object[]{}),Boolean.parseBoolean(value));
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName,e);
+        } 
+        if(previous != null)
+            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT + propertyName);
+    }
+    
+    private void testStringSystemProperty(String propertyName,String methodName,String value){
+        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
+        System.setProperty(ASYNC_CLIENT + propertyName, value);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
+            Assert.assertEquals(method.invoke(null, new Object[]{}),value);
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName,e);
+        } 
+        if(previous != null)
+            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT + propertyName);
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/RealmTest.java b/api/src/test/java/org/asynchttpclient/RealmTest.java
index 1cef822c2..5433765b2 100644
--- a/api/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/api/src/test/java/org/asynchttpclient/RealmTest.java
@@ -12,110 +12,114 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.Realm;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Realm.RealmBuilder;
-import org.testng.Assert;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StandardCharsets;
+import org.testng.annotations.Test;
+
 import java.math.BigInteger;
 import java.security.MessageDigest;
 
-import org.testng.annotations.Test;
-
 public class RealmTest {
     @Test(groups = "fast")
     public void testClone() {
         RealmBuilder builder = new RealmBuilder();
-        builder.setPrincipal( "user" ).setPassword( "pass" );
-        builder.setEnconding( "enc" ).setUsePreemptiveAuth( true );
-        builder.setRealmName( "realm" ).setAlgorithm( "algo" );
-        builder.setScheme( AuthScheme.BASIC );
+        builder.setPrincipal("user").setPassword("pass");
+        builder.setEncoding(StandardCharsets.UTF_8.name()).setUsePreemptiveAuth(true);
+        builder.setRealmName("realm").setAlgorithm("algo");
+        builder.setScheme(AuthScheme.BASIC);
         Realm orig = builder.build();
-        
-        Realm clone = new RealmBuilder().clone( orig ).build();
-        Assert.assertEquals( clone.getPrincipal(), orig.getPrincipal() );
-        Assert.assertEquals( clone.getPassword(), orig.getPassword() );
-        Assert.assertEquals( clone.getEncoding(), orig.getEncoding() );
-        Assert.assertEquals( clone.getUsePreemptiveAuth(), orig.getUsePreemptiveAuth() );
-        Assert.assertEquals( clone.getRealmName(), orig.getRealmName() );
-        Assert.assertEquals( clone.getAlgorithm(), orig.getAlgorithm() );
-        Assert.assertEquals( clone.getAuthScheme(), orig.getAuthScheme() );
+
+        Realm clone = new RealmBuilder().clone(orig).build();
+        assertEquals(clone.getPrincipal(), orig.getPrincipal());
+        assertEquals(clone.getPassword(), orig.getPassword());
+        assertEquals(clone.getEncoding(), orig.getEncoding());
+        assertEquals(clone.getUsePreemptiveAuth(), orig.getUsePreemptiveAuth());
+        assertEquals(clone.getRealmName(), orig.getRealmName());
+        assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
+        assertEquals(clone.getAuthScheme(), orig.getAuthScheme());
     }
+
     @Test(groups = "fast")
     public void testOldDigestEmptyString() {
-        String qop="";
+        String qop = "";
         testOldDigest(qop);
     }
+
     @Test(groups = "fast")
     public void testOldDigestNull() {
-        String qop=null;
+        String qop = null;
         testOldDigest(qop);
     }
 
-    private void testOldDigest(String qop){
-        String user="user";
-        String pass="pass";
-        String realm="realm";
-        String nonce="nonce";
-        String method="GET";
-        String uri="/foo";
+    private void testOldDigest(String qop) {
+        String user = "user";
+        String pass = "pass";
+        String realm = "realm";
+        String nonce = "nonce";
+        String method = "GET";
+        Uri uri = Uri.create("http://ahc.io/foo");
         RealmBuilder builder = new RealmBuilder();
-        builder.setPrincipal( user ).setPassword( pass );
-        builder.setNonce( nonce );
-        builder.setUri( uri );
+        builder.setPrincipal(user).setPassword(pass);
+        builder.setNonce(nonce);
+        builder.setUri(uri);
         builder.setMethodName(method);
-        builder.setRealmName( realm );
+        builder.setRealmName(realm);
         builder.setQop(qop);
-        builder.setScheme( AuthScheme.DIGEST );
+        builder.setScheme(AuthScheme.DIGEST);
         Realm orig = builder.build();
 
-        String ha1=getMd5(user +":" + realm +":"+pass);
-        String ha2=getMd5(method +":"+ uri);
-        String expectedResponse=getMd5(ha1 +":" + nonce +":"  + ha2);
+        String ha1 = getMd5(user + ":" + realm + ":" + pass);
+        String ha2 = getMd5(method + ":" + uri);
+        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
 
-        Assert.assertEquals(expectedResponse,orig.getResponse());
+        assertEquals(expectedResponse, orig.getResponse());
     }
 
     @Test(groups = "fast")
     public void testStrongDigest() {
-        String user="user";
-        String pass="pass";
-        String realm="realm";
-        String nonce="nonce";
-        String method="GET";
-        String uri="/foo";
-        String qop="auth";
+        String user = "user";
+        String pass = "pass";
+        String realm = "realm";
+        String nonce = "nonce";
+        String method = "GET";
+        Uri uri = Uri.create("http://ahc.io/foo");
+        String qop = "auth";
         RealmBuilder builder = new RealmBuilder();
-        builder.setPrincipal( user ).setPassword( pass );
-        builder.setNonce( nonce );
-        builder.setUri( uri );
+        builder.setPrincipal(user).setPassword(pass);
+        builder.setNonce(nonce);
+        builder.setUri(uri);
         builder.setMethodName(method);
-        builder.setRealmName( realm );
+        builder.setRealmName(realm);
         builder.setQop(qop);
-        builder.setScheme( AuthScheme.DIGEST );
+        builder.setScheme(AuthScheme.DIGEST);
         Realm orig = builder.build();
 
         String nc = orig.getNc();
         String cnonce = orig.getCnonce();
-        String ha1=getMd5(user +":" + realm +":"+pass);
-        String ha2=getMd5(method +":"+ uri);
-        String expectedResponse=getMd5(ha1 +":" + nonce +":" + nc + ":" + cnonce +":" + qop + ":" + ha2);
+        String ha1 = getMd5(user + ":" + realm + ":" + pass);
+        String ha2 = getMd5(method + ":" + uri);
+        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
 
-        Assert.assertEquals(expectedResponse,orig.getResponse());
+        assertEquals(expectedResponse, orig.getResponse());
     }
 
-    private String getMd5(String what){
-            try {
+    private String getMd5(String what) {
+        try {
             MessageDigest md = MessageDigest.getInstance("MD5");
-                md.update(what.getBytes("ISO-8859-1"));
-                byte[] hash  = md.digest();
-                BigInteger bi = new BigInteger(1, hash);
-                String result = bi.toString(16);
-                if (result.length() % 2 != 0) {
-                    return "0" + result;
-                }
-                return result;
-            } catch (Exception e) {
-                throw new RuntimeException(e);
+            md.update(what.getBytes("ISO-8859-1"));
+            byte[] hash = md.digest();
+            BigInteger bi = new BigInteger(1, hash);
+            String result = bi.toString(16);
+            if (result.length() % 2 != 0) {
+                return "0" + result;
             }
+            return result;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java b/api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java
similarity index 51%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java
rename to api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java
index e577d5473..e95112a70 100644
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java
+++ b/api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java
@@ -13,23 +13,21 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.netty.util;
+package org.asynchttpclient.async;
 
-import org.jboss.netty.buffer.ChannelBuffer;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
 
-public class ChannelBufferUtil {
+import org.testng.annotations.BeforeClass;
 
-    public static byte[] channelBuffer2bytes(ChannelBuffer b) {
-        int readable = b.readableBytes();
-        int readerIndex = b.readerIndex();
-        if (b.hasArray()) {
-            byte[] array = b.array();
-            if (b.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-                return array;
-            }
-        }
-        byte[] array = new byte[readable];
-        b.getBytes(readerIndex, array);
-        return array;
+public abstract class AbstractBasicHttpsTest extends AbstractBasicTest {
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        port1 = findFreePort();
+        server = newJettyHttpsServer(port1);
+        server.setHandler(configureHandler());
+        server.start();
+        logger.info("Local HTTP server started successfully");
     }
-}
\ No newline at end of file
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
index 3e6c368f7..224b24eb9 100644
--- a/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
@@ -15,6 +15,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.addHttpConnector;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
@@ -23,143 +28,42 @@
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Request;
+import org.asynchttpclient.async.util.EchoHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.testng.Assert;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.util.Enumeration;
-
 public abstract class AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
+
+    protected final static int TIMEOUT = 30;
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
     protected Server server;
     protected int port1;
     protected int port2;
 
-    public final static int TIMEOUT = 30;
-
-    public static class EchoHandler extends AbstractHandler {
-
-        /* @Override */
-        public void handle(String pathInContext,
-                           Request request,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            if (httpRequest.getHeader("X-HEAD") != null) {
-                httpResponse.setContentLength(1);
-            }
-
-            if (httpRequest.getHeader("X-ISO") != null) {
-                httpResponse.setContentType("text/html; charset=ISO-8859-1");
-            } else {
-                httpResponse.setContentType("text/html; charset=utf-8");
-            }
-
-            if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
-                httpResponse.addHeader("Allow","GET,HEAD,POST,OPTIONS,TRACE");
-            };
-
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-
-                if (param.startsWith("LockThread")) {
-                    try {
-                        Thread.sleep(40 * 1000);
-                    } catch (InterruptedException ex) {
-                    }
-                }
-
-                if (param.startsWith("X-redirect")) {
-                    httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-                    return;
-                }
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            Enumeration<?> i = httpRequest.getParameterNames();
-
-            StringBuilder requestBody = new StringBuilder();
-            while (i.hasMoreElements()) {
-                param = i.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getParameter(param));
-                requestBody.append(param);
-                requestBody.append("_");
-            }
-
-            String pathInfo = httpRequest.getPathInfo();
-            if (pathInfo != null)
-                httpResponse.addHeader("X-pathInfo", pathInfo);
-
-            String queryString = httpRequest.getQueryString();
-            if (queryString != null)
-                httpResponse.addHeader("X-queryString", queryString);
-
-            httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-            javax.servlet.http.Cookie[] cs = httpRequest.getCookies();
-            if (cs != null) {
-                for (javax.servlet.http.Cookie c : cs) {
-                    httpResponse.addCookie(c);
-                }
-            }
-
-            if (requestBody.length() > 0) {
-                httpResponse.getOutputStream().write(requestBody.toString().getBytes());
-            }
-
-            int size = 16384;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                int read = 0;
-                while (read > -1) {
-                    read = httpRequest.getInputStream().read(bytes);
-                    if (read > 0) {
-                        httpResponse.getOutputStream().write(bytes, 0, read);
-                    }
-                }
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
-    }
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-    }
+        port1 = findFreePort();
+        port2 = findFreePort();
 
-    protected int findFreePort() throws IOException {
-        ServerSocket socket = null;
+        server = newJettyHttpServer(port1);
+        server.setHandler(configureHandler());
+        addHttpConnector(server, port2);
+        server.start();
 
-        try {
-            socket = new ServerSocket(0);
+        logger.info("Local HTTP server started successfully");
+    }
 
-            return socket.getLocalPort();
-        }
-        finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        if (server != null)
+            server.stop();
     }
 
     protected String getTargetUrl() {
@@ -174,31 +78,6 @@ public AbstractHandler configureHandler() throws Exception {
         return new EchoHandler();
     }
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-
-        port1 = findFreePort();
-        port2 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-        listener = new SelectChannelConnector();
-        listener.setHost("127.0.0.1");
-        listener.setPort(port2);
-
-        server.addConnector(listener);
-
-        server.setHandler(configureHandler());
-        server.start();
-        log.info("Local HTTP server started successfully");
-    }
-
     public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
         public Runnable runnable;
 
@@ -207,45 +86,41 @@ public Response onCompleted(Response response) throws Exception {
             return response;
         }
 
-        /* @Override */
+        @Override
         public void onThrowable(Throwable t) {
             t.printStackTrace();
-            Assert.fail("Unexpected exception: " + t.getMessage(), t);
+            fail("Unexpected exception: " + t.getMessage(), t);
         }
-
     }
 
     public static class AsyncHandlerAdapter implements AsyncHandler<String> {
 
-
-        /* @Override */
+        @Override
         public void onThrowable(Throwable t) {
             t.printStackTrace();
-            Assert.fail("Unexpected exception", t);
+            fail("Unexpected exception", t);
         }
 
-        /* @Override */
+        @Override
         public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
             return STATE.CONTINUE;
         }
 
-        /* @Override */
+        @Override
         public STATE onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
             return STATE.CONTINUE;
         }
 
-        /* @Override */
+        @Override
         public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
             return STATE.CONTINUE;
         }
 
-        /* @Override */
+        @Override
         public String onCompleted() throws Exception {
             return "";
         }
-
     }
 
     public abstract AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config);
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
index e1c3c9187..e82db71a1 100755
--- a/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
@@ -15,21 +15,40 @@
  */
 package org.asynchttpclient.async;
 
-import static org.asynchttpclient.util.DateUtil.millisTime;
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.util.DateUtils.millisTime;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.AsyncHttpClientConfigBean;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.multipart.StringPart;
+import org.asynchttpclient.util.StandardCharsets;
+import org.testng.annotations.Test;
+
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.net.ConnectException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.nio.channels.UnresolvedAddressException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -43,118 +62,100 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
+public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
 
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpClientConfig.Builder;
-import org.asynchttpclient.AsyncHttpClientConfigBean;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.Part;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.StringPart;
+  protected abstract String acceptEncodingHeader();
 
-public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
-    private static final String UTF_8 = "text/html;charset=UTF-8";
+  protected abstract AsyncHttpProviderConfig<?, ?> getProviderConfig();
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncProviderEncodingTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(null);
+    public void asyncProviderEncodingTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html?q=+%20x").build();
-            String requestUrl = request.getUrl();
-            Assert.assertEquals(requestUrl, "http://foo.com/foo.html?q=%20%20x");
-            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "?q=+%20x").build();
+            assertEquals(request.getUrl(), getTargetUrl() + "?q=%20%20x");
+
+            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
                 public String onCompleted(Response response) throws Exception {
                     return response.getUri().toString();
                 }
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                    fail("Unexpected exception: " + t.getMessage(), t);
                 }
 
-            });
-            String url = responseFuture.get();
-            Assert.assertEquals(url, "http://foo.com/foo.html?q=%20%20x");
+            }).get();
+            assertEquals(url, getTargetUrl() + "?q=%20%20x");
         } finally {
-            p.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncProviderEncodingTest2() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(null);
+    public void asyncProviderEncodingTest2() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html").addQueryParameter("q", "a b").build();
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "").addQueryParam("q", "a b").build();
 
-            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
                 public String onCompleted(Response response) throws Exception {
                     return response.getUri().toString();
                 }
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                    fail("Unexpected exception: " + t.getMessage(), t);
                 }
 
-            });
-            String url = responseFuture.get();
-            Assert.assertEquals(url, "http://foo.com/foo.html?q=a%20b");
+            }).get();
+            assertEquals(url, getTargetUrl() + "?q=a%20b");
         } finally {
-            p.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void emptyRequestURI() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(null);
+    public void emptyRequestURI() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Request request = new RequestBuilder("GET").setUrl("http://foo.com").build();
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
 
-            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
                 public String onCompleted(Response response) throws Exception {
                     return response.getUri().toString();
                 }
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                    fail("Unexpected exception: " + t.getMessage(), t);
                 }
 
-            });
-            String url = responseFuture.get();
-            Assert.assertEquals(url, "http://foo.com/");
+            }).get();
+            assertEquals(url, getTargetUrl());
         } finally {
-            p.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncProviderContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(null);
+    public void asyncProviderContentLenghtGETTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        final HttpURLConnection connection = (HttpURLConnection) new URL(getTargetUrl()).openConnection();
+        connection.connect();
+        final int ct = connection.getContentLength();
+        connection.disconnect();
         try {
             final CountDownLatch l = new CountDownLatch(1);
-            URL url = new URL(getTargetUrl());
-            final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-            connection.connect();
 
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -164,7 +165,6 @@ public Response onCompleted(Response response) throws Exception {
                         if (response.getHeader("content-length") != null) {
                             contentLenght = Integer.valueOf(response.getHeader("content-length"));
                         }
-                        int ct = connection.getContentLength();
                         assertEquals(contentLenght, ct);
                     } finally {
                         l.countDown();
@@ -175,7 +175,7 @@ public Response onCompleted(Response response) throws Exception {
                 @Override
                 public void onThrowable(Throwable t) {
                     try {
-                        Assert.fail("Unexpected exception", t);
+                        fail("Unexpected exception", t);
                     } finally {
                         l.countDown();
                     }
@@ -184,26 +184,26 @@ public void onThrowable(Throwable t) {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            p.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncContentTypeGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(null);
+    public void asyncContentTypeGETTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getContentType(), UTF_8);
+                        assertEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
                     } finally {
                         l.countDown();
                     }
@@ -211,26 +211,26 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            p.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncHeaderGETTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(null);
+    public void asyncHeaderGETTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getContentType(), UTF_8);
+                        assertEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
                     } finally {
                         l.countDown();
                     }
@@ -239,16 +239,16 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncHeaderPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(null);
+    public void asyncHeaderPOSTTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
@@ -259,12 +259,11 @@ public void asyncHeaderPOSTTest() throws Throwable {
             h.add("Test5", "Test5");
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
 
-            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
-                        System.out.println(">>>>> " + response.getStatusText());
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
                             assertEquals(response.getHeader("X-Test" + i), "Test" + i);
@@ -277,37 +276,35 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncParamPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(null);
+    public void asyncParamPOSTTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
 
-            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            Map<String, List<String>> m = new HashMap<String, List<String>>();
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).build();
-            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setFormParams(m).build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
                             assertEquals(response.getHeader("X-param_" + i), "value_" + i);
                         }
-
                     } finally {
                         l.countDown();
                     }
@@ -316,20 +313,20 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncStatusHEADTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(null);
+    public void asyncStatusHEADTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
-            Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -344,31 +341,31 @@ public Response onCompleted(Response response) throws Exception {
 
             try {
                 String s = response.getResponseBody();
-                Assert.assertEquals("", s);
+                assertEquals("", s);
             } catch (IllegalStateException ex) {
                 fail();
             }
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
     // TODO: fix test
     @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
-    public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(120 * 1000).build());
+    public void asyncStatusHEADContentLenghtTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(120 * 1000).build());
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
 
-            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
-                    Assert.fail();
+                    fail();
                     return response;
                 }
 
@@ -385,34 +382,31 @@ public void onThrowable(Throwable t) {
             }).get();
 
             if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
-    public void asyncNullSchemeTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    @Test(groups = { "online", "default_provider", "async" }, expectedExceptions = { NullPointerException.class })
+    public void asyncNullSchemeTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
 
         try {
-            c.prepareGet("www.sun.com").execute();
-            Assert.fail();
-        } catch (IllegalArgumentException ex) {
-            Assert.assertTrue(true);
+            client.prepareGet("www.sun.com").execute();
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetTransferEncodingTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoGetTransferEncodingTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
 
-            c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -427,16 +421,16 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetHeadersTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoGetHeadersTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
@@ -445,7 +439,7 @@ public void asyncDoGetHeadersTest() throws Throwable {
             h.add("Test3", "Test3");
             h.add("Test4", "Test4");
             h.add("Test5", "Test5");
-            c.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
+            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -461,16 +455,16 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetCookieTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoGetCookieTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
@@ -480,8 +474,8 @@ public void asyncDoGetCookieTest() throws Throwable {
             h.add("Test4", "Test4");
             h.add("Test5", "Test5");
 
-            final Cookie coo = new Cookie("/", "foo", "value", "/", -1, false);
-            c.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
+            final Cookie coo = Cookie.newValidCookie("foo", "value", "value", "/", "/", -1L, -1, false, false);
+            client.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -489,7 +483,7 @@ public Response onCompleted(Response response) throws Exception {
                         assertEquals(response.getStatusCode(), 200);
                         List<Cookie> cookies = response.getCookies();
                         assertEquals(cookies.size(), 1);
-                        assertEquals(cookies.get(0).toString(), coo.toString());
+                        assertEquals(cookies.get(0).toString(), "foo=value");
                     } finally {
                         l.countDown();
                     }
@@ -498,19 +492,19 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostDefaultContentType() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostDefaultContentType() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
-            c.preparePost(getTargetUrl()).addParameter("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).addFormParam("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -526,42 +520,38 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostBodyIsoTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostBodyIsoTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response r = c.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
-            assertEquals(r.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
+            Response response = client.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
+            assertEquals(response.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostBytesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostBytesTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -580,32 +570,28 @@ public Response onCompleted(Response response) throws Exception {
             }).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostInputStreamTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostInputStreamTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
             ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
 
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -623,90 +609,34 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPutInputStreamTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPutInputStreamTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
             ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
 
-            c.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                        }
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
-        } finally {
-            c.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostEntityWriterTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            final CountDownLatch l = new CountDownLatch(1);
-            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-            h.add("Content-Type", "application/x-www-form-urlencoded");
-
-            final StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
-            }
-            sb.setLength(sb.length() - 1);
-            byte[] bytes = sb.toString().getBytes();
-            h.add("Content-Length", String.valueOf(bytes.length));
-
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(new Request.EntityWriter() {
-
-                /* @Override */
-                public void writeEntity(OutputStream out) throws IOException {
-                    out.write(sb.toString().getBytes("UTF-8"));
-                }
-            }).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
                             assertEquals(response.getHeader("X-param_" + i), "value_" + i);
                         }
                     } finally {
@@ -716,22 +646,22 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostMultiPartTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostMultiPartTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
 
-            Part p = new StringPart("foo", "bar");
+            Part p = new StringPart("foo", "bar", StandardCharsets.UTF_8);
 
-            c.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -748,70 +678,61 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
-
+    
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostBasicGZIPTest() throws Throwable {
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
+    public void asyncDoPostBasicGZIPTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
         try {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("X-Accept-Encoding"), "gzip");
+                        assertEquals(response.getHeader("X-Accept-Encoding"), acceptEncodingHeader());
                     } finally {
                         l.countDown();
                     }
                     return response;
                 }
             }).get();
+            
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostProxyTest() throws Throwable {
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
+    public void asyncDoPostProxyTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build());
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
-            Response response = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+            Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     return response;
@@ -823,26 +744,26 @@ public void onThrowable(Throwable t) {
             }).get();
 
             assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Proxy-Connection"), "keep-alive");
+            assertEquals(response.getHeader("X-Connection"), "keep-alive");
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncRequestVirtualServerPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(null);
+    public void asyncRequestVirtualServerPOSTTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
 
-            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            Map<String, List<String>> m = new HashMap<String, List<String>>();
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).setVirtualHost("localhost:" + port1).build();
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setFormParams(m).setVirtualHost("localhost:" + port1).build();
 
-            Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
+            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
 
             assertEquals(response.getStatusCode(), 200);
             if (response.getHeader("X-Host").startsWith("localhost")) {
@@ -851,36 +772,32 @@ public void asyncRequestVirtualServerPOSTTest() throws Throwable {
                 assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
             }
         } finally {
-            n.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPutTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPutTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
-            Response response = c.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
+            Response response = client.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
 
             assertEquals(response.getStatusCode(), 200);
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostLatchBytesTest() throws Throwable {
+    public void asyncDoPostLatchBytesTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
@@ -888,11 +805,7 @@ public void asyncDoPostLatchBytesTest() throws Throwable {
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
@@ -903,9 +816,7 @@ public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
                             assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
                         }
                         return response;
                     } finally {
@@ -915,7 +826,7 @@ public Response onCompleted(Response response) throws Exception {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
             c.close();
@@ -923,8 +834,8 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostDelayCancelTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostDelayCancelTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -932,22 +843,22 @@ public void asyncDoPostDelayCancelTest() throws Throwable {
             StringBuilder sb = new StringBuilder();
             sb.append("LockThread=true");
 
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
                 @Override
                 public void onThrowable(Throwable t) {
                 }
             });
             future.cancel(true);
             Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
-            Assert.assertNull(response);
+            assertNull(response);
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostDelayBytesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostDelayBytesTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -956,7 +867,7 @@ public void asyncDoPostDelayBytesTest() throws Throwable {
             sb.append("LockThread=true");
 
             try {
-                Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
                         t.printStackTrace();
@@ -965,65 +876,57 @@ public void onThrowable(Throwable t) {
 
                 future.get(10, TimeUnit.SECONDS);
             } catch (ExecutionException ex) {
-                if (ex.getCause() != null && TimeoutException.class.isAssignableFrom(ex.getCause().getClass())) {
-                    Assert.assertTrue(true);
+                if (ex.getCause() instanceof TimeoutException) {
+                    assertTrue(true);
                 }
             } catch (TimeoutException te) {
-                Assert.assertTrue(true);
+                assertTrue(true);
             } catch (IllegalStateException ex) {
-                Assert.assertTrue(false);
+                assertTrue(false);
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostNullBytesTest() throws Throwable {
+    public void asyncDoPostNullBytesTest() throws Exception {
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
+            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
 
             Response response = future.get();
-            Assert.assertNotNull(response);
+            assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostListenerBytesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncDoPostListenerBytesTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
             for (int i = 0; i < 5; i++) {
-                sb.append("param_");
-                sb.append(i);
-                sb.append("=value_");
-                sb.append(i);
-                sb.append("&");
+                sb.append("param_").append(i).append("=value_").append(i).append("&");
             }
             sb.setLength(sb.length() - 1);
 
             final CountDownLatch l = new CountDownLatch(1);
 
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
@@ -1036,23 +939,23 @@ public Response onCompleted(Response response) throws Exception {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Latch time out");
+                fail("Latch time out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncConnectInvalidFuture() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidFuture() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             int dummyPort = findFreePort();
             final AtomicInteger count = new AtomicInteger();
             for (int i = 0; i < 20; i++) {
                 try {
-                    Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                        /* @Override */
+                    Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                        @Override
                         public void onThrowable(Throwable t) {
                             count.incrementAndGet();
                         }
@@ -1067,18 +970,18 @@ public void onThrowable(Throwable t) {
             }
             assertEquals(count.get(), 20);
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncConnectInvalidPortFuture() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidPortFuture() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             int dummyPort = findFreePort();
             try {
-                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                    /* @Override */
+                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
                     public void onThrowable(Throwable t) {
                         t.printStackTrace();
                     }
@@ -1091,20 +994,20 @@ public void onThrowable(Throwable t) {
                 }
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncConnectInvalidPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidPort() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // pick a random unused local port
             int port = findFreePort();
 
             try {
-                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                    /* @Override */
+                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
                     public void onThrowable(Throwable t) {
                         t.printStackTrace();
                     }
@@ -1114,19 +1017,19 @@ public void onThrowable(Throwable t) {
                 assertEquals(ex.getCause().getClass(), ConnectException.class);
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncConnectInvalidHandlerPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidHandlerPort() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
             int port = findFreePort();
 
-            c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                /* @Override */
+            client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
                 public void onThrowable(Throwable t) {
                     try {
                         assertEquals(t.getClass(), ConnectException.class);
@@ -1137,21 +1040,21 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
-    public void asyncConnectInvalidHandlerHost() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidHandlerHost() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final CountDownLatch l = new CountDownLatch(1);
 
-            c.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
-                /* @Override */
+            client.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
+                @Override
                 public void onThrowable(Throwable t) {
                     if (t != null) {
                         if (t.getClass().equals(ConnectException.class)) {
@@ -1164,16 +1067,16 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncConnectInvalidFuturePort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncConnectInvalidFuturePort() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final AtomicBoolean called = new AtomicBoolean(false);
             final AtomicBoolean rightCause = new AtomicBoolean(false);
@@ -1181,7 +1084,7 @@ public void asyncConnectInvalidFuturePort() throws Throwable {
             int port = findFreePort();
 
             try {
-                Response response = c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                Response response = client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
                         called.set(true);
@@ -1197,67 +1100,67 @@ public void onThrowable(Throwable t) {
             assertTrue(called.get(), "onThrowable should get called.");
             assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncContentLenghtGETTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public void onThrowable(Throwable t) {
-                    Assert.fail("Unexpected exception", t);
+                    fail("Unexpected exception", t);
                 }
             }).get();
 
-            Assert.assertNotNull(response);
+            assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncResponseBodyTooLarge() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncResponseBodyTooLarge() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
+            Response response = client.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public void onThrowable(Throwable t) {
-                    Assert.fail("Unexpected exception", t);
+                    fail("Unexpected exception", t);
                 }
             }).get();
 
-            Assert.assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
+            assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncResponseEmptyBody() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncResponseEmptyBody() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
                 public void onThrowable(Throwable t) {
-                    Assert.fail("Unexpected exception", t);
+                    fail("Unexpected exception", t);
                 }
             }).get();
 
             assertEquals(response.getResponseBody(), "");
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "asyncAPI" })
-    public void asyncAPIContentLenghtGETTest() throws Throwable {
+    public void asyncAPIContentLenghtGETTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // Use a l in case the assert fail
@@ -1281,7 +1184,7 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1289,7 +1192,7 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "standalone", "default_provider", "asyncAPI" })
-    public void asyncAPIHandlerExceptionTest() throws Throwable {
+    public void asyncAPIHandlerExceptionTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // Use a l in case the assert fail
@@ -1314,7 +1217,7 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1322,8 +1225,8 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetDelayHandlerTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(5 * 1000).build());
+    public void asyncDoGetDelayHandlerTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(5 * 1000).build());
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("LockThread", "true");
@@ -1336,7 +1239,7 @@ public void asyncDoGetDelayHandlerTest() throws Throwable {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
-                        Assert.fail("Must not receive a response");
+                        fail("Must not receive a response");
                     } finally {
                         l.countDown();
                     }
@@ -1347,9 +1250,9 @@ public Response onCompleted(Response response) throws Exception {
                 public void onThrowable(Throwable t) {
                     try {
                         if (t instanceof TimeoutException) {
-                            Assert.assertTrue(true);
+                            assertTrue(true);
                         } else {
-                            Assert.fail("Unexpected exception", t);
+                            fail("Unexpected exception", t);
                         }
                     } finally {
                         l.countDown();
@@ -1358,7 +1261,7 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1366,7 +1269,7 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetQueryStringTest() throws Throwable {
+    public void asyncDoGetQueryStringTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // Use a l in case the assert fail
@@ -1377,8 +1280,8 @@ public void asyncDoGetQueryStringTest() throws Throwable {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
-                        Assert.assertTrue(response.getHeader("X-pathInfo") != null);
-                        Assert.assertTrue(response.getHeader("X-queryString") != null);
+                        assertTrue(response.getHeader("X-pathInfo") != null);
+                        assertTrue(response.getHeader("X-queryString") != null);
                     } finally {
                         l.countDown();
                     }
@@ -1391,7 +1294,7 @@ public Response onCompleted(Response response) throws Exception {
             client.executeRequest(req, handler).get();
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1399,7 +1302,7 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoGetKeepAliveHandlerTest() throws Throwable {
+    public void asyncDoGetKeepAliveHandlerTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // Use a l in case the assert fail
@@ -1411,15 +1314,16 @@ public void asyncDoGetKeepAliveHandlerTest() throws Throwable {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
-                    assertEquals(response.getStatusCode(), 200);
-                    if (remoteAddr == null) {
-                        remoteAddr = response.getHeader("X-KEEP-ALIVE");
-                        l.countDown();
-                    } else {
-                        assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        if (remoteAddr == null) {
+                            remoteAddr = response.getHeader("X-KEEP-ALIVE");
+                        } else {
+                            assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
+                        }
+                    } finally {
                         l.countDown();
                     }
-
                     return response;
                 }
             };
@@ -1428,7 +1332,7 @@ public Response onCompleted(Response response) throws Exception {
             client.prepareGet(getTargetUrl()).execute(handler);
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1436,8 +1340,8 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "online", "default_provider", "async" })
-    public void asyncDoGetMaxRedirectTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaximumNumberOfRedirects(0).setFollowRedirects(true).build());
+    public void asyncDoGetMaxRedirectTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaxRedirects(0).setFollowRedirect(true).build());
         try {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
@@ -1446,7 +1350,7 @@ public void asyncDoGetMaxRedirectTest() throws Throwable {
 
                 @Override
                 public Response onCompleted(Response response) throws Exception {
-                    Assert.fail("Should not be here");
+                    fail("Should not be here");
                     return response;
                 }
 
@@ -1461,10 +1365,10 @@ public void onThrowable(Throwable t) {
                 }
             };
 
-            client.prepareGet("http://google.com/").execute(handler);
+            client.prepareGet("http://google.com").execute(handler);
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1472,9 +1376,10 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "online", "default_provider", "async" })
-    public void asyncDoGetNestedTest() throws Throwable {
+    public void asyncDoGetNestedTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
+            // FIXME find a proper website that redirects the same number of times whatever the language
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(2);
 
@@ -1489,7 +1394,7 @@ public Response onCompleted(Response response) throws Exception {
                     try {
                         if (nestedCount.getAndIncrement() < MAX_NESTED) {
                             System.out.println("Executing a nested request: " + nestedCount);
-                            client.prepareGet("http://google.com/").execute(this);
+                            client.prepareGet("http://www.lemonde.fr").execute(this);
                         }
                     } finally {
                         l.countDown();
@@ -1503,10 +1408,10 @@ public void onThrowable(Throwable t) {
                 }
             };
 
-            client.prepareGet("http://www.google.com/").execute(handler);
+            client.prepareGet("http://www.lemonde.fr").execute(handler);
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             client.close();
@@ -1514,39 +1419,35 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "online", "default_provider", "async" })
-    public void asyncDoGetStreamAndBodyTest() throws Throwable {
+    public void asyncDoGetStreamAndBodyTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response r = client.prepareGet("http://www.google.com/").execute().get();
-
-            r.getResponseBody();
-            r.getResponseBodyAsStream();
+            Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
+            assertEquals(response.getStatusCode(), 200);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
-    public void asyncUrlWithoutPathTest() throws Throwable {
+    public void asyncUrlWithoutPathTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response r = client.prepareGet("http://www.google.com").execute().get();
-
-            r.getResponseBody();
-            r.getResponseBodyAsStream();
+            Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
+            assertEquals(response.getStatusCode(), 200);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "default_provider", "async" })
-    public void optionsTest() throws Throwable {
+    public void optionsTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response r = client.prepareOptions(getTargetUrl()).execute().get();
+            Response response = client.prepareOptions(getTargetUrl()).execute().get();
 
-            assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
         } finally {
             client.close();
         }
@@ -1554,38 +1455,38 @@ public void optionsTest() throws Throwable {
 
     @Test(groups = { "online", "default_provider" })
     public void testAwsS3() throws Exception {
-        final AsyncHttpClient c = getAsyncHttpClient(null);
+        final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
             if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
                 fail("No response Body");
             } else {
                 assertEquals(response.getStatusCode(), 403);
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testAsyncHttpProviderConfig() throws Exception {
 
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
         try {
-            Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
             if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
                 fail("No response Body");
             } else {
                 assertEquals(response.getStatusCode(), 403);
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void idleRequestTimeoutTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(5000).setRequestTimeoutInMs(10000).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000).build());
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -1593,30 +1494,23 @@ public void idleRequestTimeoutTest() throws Exception {
 
             long t1 = millisTime();
             try {
-                c.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-                    /* @Override */
-                    public void onThrowable(Throwable t) {
-                        // t.printStackTrace();
-                    }
-
-                }).get();
-                Assert.fail();
+                client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
+                fail();
             } catch (Throwable ex) {
                 final long elapsedTime = millisTime() - t1;
                 System.out.println("EXPIRED: " + (elapsedTime));
-                Assert.assertNotNull(ex.getCause());
-                Assert.assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
+                assertNotNull(ex.getCause());
+                assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncDoPostCancelTest() throws Throwable {
+    public void asyncDoPostCancelTest() throws Exception {
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -1627,7 +1521,7 @@ public void asyncDoPostCancelTest() throws Throwable {
             final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
             ex.set(null);
             try {
-                Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
                     @Override
                     public void onThrowable(Throwable t) {
@@ -1643,87 +1537,64 @@ public void onThrowable(Throwable t) {
             } catch (IllegalStateException ise) {
                 fail();
             }
-            Assert.assertNotNull(ex.get());
+            assertNotNull(ex.get());
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void getShouldAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
-            builder.setBody("Boo!");
-            builder.execute();
-        } finally {
-            c.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = IllegalArgumentException.class)
-    public void headShouldNotAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void getShouldAllowBody() throws IOException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareHead(getTargetUrl());
-            builder.setBody("Boo!");
-            builder.execute();
+            client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
         } finally {
-            c.close();
+            client.close();
         }
     }
 
-    protected String getBrokenTargetUrl() {
-        return String.format("http:127.0.0.1:%d/foo/test", port1);
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = { NullPointerException.class })
     public void invalidUri() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getBrokenTargetUrl());
-            Response r = c.executeRequest(builder.build()).get();
-            assertEquals(200, r.getStatusCode());
+            client.prepareGet(String.format("http:127.0.0.1:%d/foo/test", port1)).build();
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncHttpClientConfigBeanTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
         try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
-            Response r = c.executeRequest(builder.build()).get();
-            assertEquals(200, r.getStatusCode());
+            Response response = client.executeRequest(client.prepareGet(getTargetUrl()).build()).get();
+            assertEquals(200, response.getStatusCode());
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "default_provider", "async" })
-    public void bodyAsByteTest() throws Throwable {
+    public void bodyAsByteTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
-        Response r = client.prepareGet(getTargetUrl()).execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getResponseBodyAsBytes(), new byte[] {});
-
-        client.close();
+        try {
+            Response response = client.prepareGet(getTargetUrl()).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "default_provider", "async" })
-    public void mirrorByteTest() throws Throwable {
+    public void mirrorByteTest() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response r = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
-
-            assertEquals(r.getStatusCode(), 200);
-            assertEquals(new String(r.getResponseBodyAsBytes(), "UTF-8"), "MIRROR");
+            Response response = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(new String(response.getResponseBodyAsBytes(), StandardCharsets.UTF_8), "MIRROR");
         } finally {
             client.close();
         }
     }
-
-    protected abstract AsyncHttpProviderConfig getProviderConfig();
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
index a2ab86cfc..4bd4d6fe6 100644
--- a/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
@@ -15,44 +15,49 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 public abstract class AsyncStreamHandlerTest extends AbstractBasicTest {
-    private final static String RESPONSE = "param_1_";
-    private final static String UTF8 = "text/html;charset=utf-8";
+
+    private static final String RESPONSE = "param_1_";
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamGETTest() throws Throwable {
+    public void asyncStreamGETTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
         AsyncHttpClient c = getAsyncHttpClient(null);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         try {
             c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     try {
-                        FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                        Assert.assertNotNull(h);
-                        Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                        responseHeaders.set(content.getHeaders());
                         return STATE.ABORT;
                     } finally {
                         l.countDown();
@@ -62,7 +67,7 @@ public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
                 @Override
                 public void onThrowable(Throwable t) {
                     try {
-                        Assert.fail("", t);
+                        throwable.set(t);
                     } finally {
                         l.countDown();
                     }
@@ -70,31 +75,35 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(5, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
+            
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h, "No response headers");
+            assertEquals(h.getJoinedValue("content-type", ", "), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET, "Unexpected content-type");
+            assertNull(throwable.get(), "Unexpected exception");
+            
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamPOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
+    public void asyncStreamPOSTTest() throws Exception {
+
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
 
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            Future<String> f = c.preparePost(getTargetUrl())//
+                    .setHeader("Content-Type", "application/x-www-form-urlencoded")//
+                    .addFormParam("param_1", "value_1")//
+                    .execute(new AsyncHandlerAdapter() {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.CONTINUE;
                 }
 
@@ -106,84 +115,79 @@ public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
 
                 @Override
                 public String onCompleted() throws Exception {
-                    try {
-                        String r = builder.toString().trim();
-                        Assert.assertEquals(r, RESPONSE);
-                        return r;
-                    } finally {
-                        l.countDown();
-                    }
+                    return builder.toString().trim();
                 }
             });
 
-            if (!l.await(10, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
+            String responseBody = f.get(10, TimeUnit.SECONDS);
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h);
+            assertEquals(h.getJoinedValue("content-type", ", "), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            assertEquals(responseBody, RESPONSE);
+            
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamInterruptTest() throws Throwable {
+    public void asyncStreamInterruptTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
 
-        final AtomicBoolean a = new AtomicBoolean(true);
         AsyncHttpClient c = getAsyncHttpClient(null);
+        
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicBoolean bodyReceived = new AtomicBoolean(false);
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         try {
-            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            c.preparePost(getTargetUrl())//
+            .setHeader("Content-Type", "application/x-www-form-urlencoded")//
+            .addFormParam("param_1", "value_1")//
+            .execute(new AsyncHandlerAdapter() {
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.ABORT;
                 }
 
                 @Override
                 public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                    a.set(false);
-                    Assert.fail("Interrupted not working");
+                    bodyReceived.set(true);
                     return STATE.ABORT;
                 }
 
                 @Override
                 public void onThrowable(Throwable t) {
-                    try {
-                        Assert.fail("", t);
-                    } finally {
-                        l.countDown();
-                    }
+                    throwable.set(t);
+                    l.countDown();
                 }
             });
 
             l.await(5, TimeUnit.SECONDS);
-            Assert.assertTrue(a.get());
+            assertTrue(!bodyReceived.get(), "Interrupted not working");
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h, "Should receive non null headers");
+            assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+            assertNull(throwable.get(), "Should get an exception");
+            
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamFutureTest() throws Throwable {
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
+    public void asyncStreamFutureTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         try {
-            Future<String> f = c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            Future<String> f = c.preparePost(getTargetUrl()).addFormParam("param_1", "value_1").execute(new AsyncHandlerAdapter() {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.CONTINUE;
                 }
 
@@ -195,31 +199,30 @@ public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
 
                 @Override
                 public String onCompleted() throws Exception {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
+                    return builder.toString().trim();
                 }
 
                 @Override
                 public void onThrowable(Throwable t) {
-                    Assert.fail("", t);
+                    throwable.set(t);
                 }
             });
 
-            try {
-                String r = f.get(5, TimeUnit.SECONDS);
-                Assert.assertNotNull(r);
-                Assert.assertEquals(r.trim(), RESPONSE);
-            } catch (TimeoutException ex) {
-                Assert.fail();
-            }
+            String responseBody = f.get(5, TimeUnit.SECONDS);
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h, "Should receive non null headers");
+            assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+            assertNotNull(responseBody, "No response body");
+            assertEquals(responseBody.trim(), RESPONSE, "Unexpected response body");
+            assertNull(throwable.get(), "Unexpected exception");
+
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamThrowableRefusedTest() throws Throwable {
+    public void asyncStreamThrowableRefusedTest() throws Exception {
 
         final CountDownLatch l = new CountDownLatch(1);
         AsyncHttpClient c = getAsyncHttpClient(null);
@@ -235,7 +238,7 @@ public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
                 public void onThrowable(Throwable t) {
                     try {
                         if (t.getMessage() != null) {
-                            Assert.assertEquals(t.getMessage(), "FOO");
+                            assertEquals(t.getMessage(), "FOO");
                         }
                     } finally {
                         l.countDown();
@@ -244,7 +247,7 @@ public void onThrowable(Throwable t) {
             });
 
             if (!l.await(10, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
         } finally {
             c.close();
@@ -252,23 +255,21 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncStreamReusePOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+    public void asyncStreamReusePOSTTest() throws Exception {
 
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
         AsyncHttpClient c = getAsyncHttpClient(null);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
         try {
-            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            BoundRequestBuilder rb = c.preparePost(getTargetUrl())//
+                    .setHeader("Content-Type", "application/x-www-form-urlencoded")
+                    .addFormParam("param_1", "value_1");
+            
+            Future<String> f = rb.execute(new AsyncHandlerAdapter() {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.CONTINUE;
                 }
 
@@ -280,30 +281,26 @@ public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
 
                 @Override
                 public String onCompleted() throws Exception {
-                    try {
-                        String r = builder.toString().trim();
-                        Assert.assertEquals(r, RESPONSE);
-                        return r;
-                    } finally {
-                        l.countDown();
-                    }
-
+                    return builder.toString();
                 }
             });
 
-            if (!l.await(20, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
+            String r = f.get(5, TimeUnit.SECONDS);
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h, "Should receive non null headers");
+            assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+            assertNotNull(r, "No response body");
+            assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+            
+            responseHeaders.set(null);
 
             // Let do the same again
-            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            f = rb.execute(new AsyncHandlerAdapter() {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.CONTINUE;
                 }
 
@@ -315,113 +312,66 @@ public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
 
                 @Override
                 public String onCompleted() throws Exception {
-                    try {
-                        String r = builder.toString().trim();
-                        Assert.assertEquals(r, RESPONSE);
-                        return r;
-                    } finally {
-                        l.countDown();
-                    }
+                    return builder.toString();
                 }
             });
 
-            if (!l.await(20, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
+            f.get(5, TimeUnit.SECONDS);
+            h = responseHeaders.get();
+            assertNotNull(h, "Should receive non null headers");
+            assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+            assertNotNull(r, "No response body");
+            assertEquals(r.trim(), RESPONSE, "Unexpected response body");
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void asyncStream301WithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void asyncStream302RedirectWithBody() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
+        final AtomicReference<Integer> statusCode = new AtomicReference<Integer>(0);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
         try {
-            c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
-
-                @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), "text/html; charset=utf-8");
-                    return STATE.CONTINUE;
-                }
+            Future<String> f = c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
 
-                @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
+                public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
+                    statusCode.set(status.getStatusCode());
                     return STATE.CONTINUE;
                 }
 
-                @Override
-                public String onCompleted() throws Exception {
-                    String r = builder.toString();
-                    Assert.assertTrue(r.contains("301 Moved"));
-                    l.countDown();
-                    return r;
-                }
-            });
-
-            if (!l.await(20, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
-        } finally {
-            c.close();
-        }
-    }
-
-    @Test(groups = { "online", "default_provider" })
-    public void asyncStream301RedirectWithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        try {
-            c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
-
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getFirstValue("server"), "gws");
-                    // This assertion below is not an invariant, since implicitly contains locale-dependant settings
-                    // and fails when run in country having own localized Google site and it's locale relies on something
-                    // other than ISO-8859-1.
-                    // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
-                    // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
-                    // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
-                    //
-                    // Assert.assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
-                    return STATE.CONTINUE;
-                }
-
-                @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
+                    responseHeaders.set(content.getHeaders());
                     return STATE.CONTINUE;
                 }
 
                 @Override
                 public String onCompleted() throws Exception {
-                    String r = builder.toString();
-                    Assert.assertTrue(!r.contains("301 Moved"));
-                    l.countDown();
-
-                    return r;
+                    return null;
                 }
             });
 
-            if (!l.await(20, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
+            f.get(20, TimeUnit.SECONDS);
+            assertTrue(statusCode.get() != 302);
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h);
+            assertEquals(h.getFirstValue("server"), "gws");
+            // This assertion below is not an invariant, since implicitly contains locale-dependant settings
+            // and fails when run in country having own localized Google site and it's locale relies on something
+            // other than ISO-8859-1.
+            // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
+            // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
+            // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
+            //
+            // assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
-    public void asyncStreamJustStatusLine() throws Throwable {
+    public void asyncStreamJustStatusLine() throws Exception {
         final int STATUS = 0;
         final int COMPLETED = 1;
         final int OTHER = 2;
@@ -432,36 +382,35 @@ public void asyncStreamJustStatusLine() throws Throwable {
             Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
                 private int status = -1;
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     whatCalled[OTHER] = true;
                     latch.countDown();
                 }
 
-                /* @Override */
+                @Override
                 public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
                     whatCalled[OTHER] = true;
                     latch.countDown();
                     return STATE.ABORT;
                 }
 
-                /* @Override */
+                @Override
                 public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                     whatCalled[STATUS] = true;
-                    System.out.println(responseStatus);
                     status = responseStatus.getStatusCode();
                     latch.countDown();
                     return STATE.ABORT;
                 }
 
-                /* @Override */
+                @Override
                 public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
                     whatCalled[OTHER] = true;
                     latch.countDown();
                     return STATE.ABORT;
                 }
 
-                /* @Override */
+                @Override
                 public Integer onCompleted() throws Exception {
                     whatCalled[COMPLETED] = true;
                     latch.countDown();
@@ -470,20 +419,20 @@ public Integer onCompleted() throws Exception {
             });
 
             if (!latch.await(2, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout");
+                fail("Timeout");
                 return;
             }
             Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-            Assert.assertEquals((int) status, 200, "Expected status code failed.");
+            assertEquals((int) status, 200, "Expected status code failed.");
 
             if (!whatCalled[STATUS]) {
-                Assert.fail("onStatusReceived not called.");
+                fail("onStatusReceived not called.");
             }
             if (!whatCalled[COMPLETED]) {
-                Assert.fail("onCompleted not called.");
+                fail("onCompleted not called.");
             }
             if (whatCalled[OTHER]) {
-                Assert.fail("Other method of AsyncHandler got called.");
+                fail("Other method of AsyncHandler got called.");
             }
         } finally {
             client.close();
@@ -491,50 +440,42 @@ public Integer onCompleted() throws Exception {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void asyncOptionsTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
+    public void asyncOptionsTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+
         try {
             final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
-            c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+            Future<String> f = c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
                 @Override
                 public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    String[] values = h.get("Allow").get(0).split(",|, ");
-                    Assert.assertNotNull(values);
-                    Assert.assertEquals(values.length, expected.length);
-                    Arrays.sort(values);
-                    Assert.assertEquals(values, expected);
+                    responseHeaders.set(content.getHeaders());
                     return STATE.ABORT;
                 }
 
-                @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    return STATE.CONTINUE;
-                }
-
                 @Override
                 public String onCompleted() throws Exception {
-                    try {
-                        return "OK";
-                    } finally {
-                        l.countDown();
-                    }
+                    return "OK";
                 }
             });
 
-            if (!l.await(20, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
+            f.get(20, TimeUnit.SECONDS) ;
+            FluentCaseInsensitiveStringsMap h = responseHeaders.get();
+            assertNotNull(h);
+            String[] values = h.get("Allow").get(0).split(",|, ");
+            assertNotNull(values);
+            assertEquals(values.length, expected.length);
+            Arrays.sort(values);
+            assertEquals(values, expected);
+            
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void closeConnectionTest() throws Throwable {
+    public void closeConnectionTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
@@ -553,7 +494,7 @@ public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.accumulate(content);
 
                     if (content.isLast()) {
-                        content.markUnderlyingConnectionAsClosed();
+                        content.markUnderlyingConnectionAsToBeClosed();
                     }
                     return STATE.CONTINUE;
                 }
@@ -569,8 +510,8 @@ public Response onCompleted() throws Exception {
                 }
             }).get();
 
-            Assert.assertNotNull(r);
-            Assert.assertEquals(r.getStatusCode(), 200);
+            assertNotNull(r);
+            assertEquals(r.getStatusCode(), 200);
         } finally {
             c.close();
         }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
index 1c7f78c5e..8e702da2d 100644
--- a/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
@@ -15,6 +15,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -30,6 +35,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.concurrent.CountDownLatch;
@@ -40,11 +46,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
 /**
  * Tests default asynchronous life cycle.
  * 
@@ -74,9 +75,9 @@ public void run() {
                         try {
                             Thread.sleep(100);
                         } catch (InterruptedException e) {
-                            log.error("Failed to sleep for 100 ms.", e);
+                            logger.error("Failed to sleep for 100 ms.", e);
                         }
-                        log.info("Delivering part1.");
+                        logger.info("Delivering part1.");
                         writer.write("part1");
                         writer.flush();
                     }
@@ -86,9 +87,9 @@ public void run() {
                         try {
                             Thread.sleep(200);
                         } catch (InterruptedException e) {
-                            log.error("Failed to sleep for 200 ms.", e);
+                            logger.error("Failed to sleep for 200 ms.", e);
                         }
-                        log.info("Delivering part2.");
+                        logger.info("Delivering part2.");
                         writer.write("part2");
                         writer.flush();
                         continuation.complete();
@@ -117,13 +118,11 @@ public void onThrowable(Throwable t) {
                 }
 
                 public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                    String s = new String(e.getBodyPartBytes());
-                    log.info("got part: {}", s);
-                    if (s.equals("")) {
-                        // noinspection ThrowableInstanceNeverThrown
-                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    if (e.length() != 0) {
+                        String s = new String(e.getBodyPartBytes());
+                        logger.info("got part: {}", s);
+                        queue.put(s);
                     }
-                    queue.put(s);
                     return STATE.CONTINUE;
                 }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java b/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
index fb9159599..13d54d417 100644
--- a/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
@@ -12,113 +12,79 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.ADMIN;
+import static org.asynchttpclient.async.util.TestUtils.USER;
+import static org.asynchttpclient.async.util.TestUtils.addBasicAuthHandler;
+import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
-import org.apache.log4j.ConsoleAppender;
-import org.apache.log4j.Level;
-import org.apache.log4j.Logger;
-import org.apache.log4j.PatternLayout;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.BasicAuthenticator;
-import org.eclipse.jetty.server.Connector;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.util.security.Constraint;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
-
 public abstract class AuthTimeoutTest extends AbstractBasicTest {
 
-    private final static String user = "user";
-
-    private final static String admin = "admin";
-
-    protected AsyncHttpClient client;
-
-    public void setUpServer(String auth) throws Exception {
-        server = new Server();
-        Logger root = Logger.getRootLogger();
-        root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
+    private Server server2;
 
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
         port1 = findFreePort();
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-        LoginService loginService = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-        server.addBean(loginService);
-
-        Constraint constraint = new Constraint();
-        constraint.setName(auth);
-        constraint.setRoles(new String[] { user, admin });
-        constraint.setAuthenticate(true);
+        port2 = findFreePort();
 
-        ConstraintMapping mapping = new ConstraintMapping();
-        mapping.setConstraint(constraint);
-        mapping.setPathSpec("/*");
-
-        Set<String> knownRoles = new HashSet<String>();
-        knownRoles.add(user);
-        knownRoles.add(admin);
-
-        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
+        server = newJettyHttpServer(port1);
+        addBasicAuthHandler(server, false, configureHandler());
+        server.start();
 
-        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
-        cm.add(mapping);
+        server2 = newJettyHttpServer(port2);
+        addDigestAuthHandler(server2, true, configureHandler());
+        server2.start();
 
-        security.setConstraintMappings(cm, knownRoles);
-        security.setAuthenticator(new BasicAuthenticator());
-        security.setLoginService(loginService);
-        security.setStrict(false);
-        security.setHandler(configureHandler());
+        logger.info("Local HTTP server started successfully");
+    }
 
-        server.setHandler(security);
-        server.start();
-        log.info("Local HTTP server started successfully");
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        super.tearDownGlobal();
+        server2.stop();
     }
 
-    private class SimpleHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+    private class IncompleteResponseHandler extends AbstractHandler {
 
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
 
             OutputStream out = response.getOutputStream();
             if (request.getHeader("X-Content") != null) {
                 String content = request.getHeader("X-Content");
-                response.setHeader("Content-Length", String.valueOf(content.getBytes("UTF-8").length));
-                out.write(content.substring(1).getBytes("UTF-8"));
-                out.flush();
-                out.close();
-                return;
+                response.setHeader("Content-Length", String.valueOf(content.getBytes(StandardCharsets.UTF_8).length));
+                out.write(content.substring(1).getBytes(StandardCharsets.UTF_8));
+            } else {
+                response.setStatus(200);
             }
-
-            response.setStatus(200);
             out.flush();
             out.close();
         }
@@ -126,9 +92,9 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__BASIC_AUTH);
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(false);
+            Future<Response> f = execute(client, server, false);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
@@ -140,9 +106,9 @@ public void basicAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicPreemptiveAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__BASIC_AUTH);
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(true);
+            Future<Response> f = execute(client, server, true);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
@@ -154,10 +120,9 @@ public void basicPreemptiveAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__DIGEST_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(false);
+            Future<Response> f = execute(client, server2, false);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
@@ -169,10 +134,9 @@ public void digestAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestPreemptiveAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__DIGEST_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(true);
+            Future<Response> f = execute(client, server2, true);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
@@ -184,10 +148,9 @@ public void digestPreemptiveAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicFutureAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__BASIC_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(false);
+            Future<Response> f = execute(client, server, false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
@@ -199,10 +162,9 @@ public void basicFutureAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__BASIC_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(true);
+            Future<Response> f = execute(client, server, true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
@@ -214,10 +176,9 @@ public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestFutureAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__DIGEST_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(false);
+            Future<Response> f = execute(client, server2, false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
@@ -229,10 +190,9 @@ public void digestFutureAuthTimeoutTest() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
-        setUpServer(Constraint.__DIGEST_AUTH);
-
+        AsyncHttpClient client = newClient();
         try {
-            Future<Response> f = execute(true);
+            Future<Response> f = execute(client, server2, true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
@@ -245,20 +205,23 @@ public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
     protected void inspectException(Throwable t) {
         assertNotNull(t.getCause());
         assertEquals(t.getCause().getClass(), IOException.class);
-        if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
+        if (t.getCause() != AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION) {
             fail();
         }
     }
 
-    protected Future<Response> execute(boolean preemptive) throws IOException {
-        client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).setConnectionTimeoutInMs(20000).setRequestTimeoutInMs(2000).build());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content", "Test");
+    private AsyncHttpClient newClient() {
+        return getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).setConnectionTimeout(20000).setRequestTimeout(2000).build());
+    }
+
+    protected Future<Response> execute(AsyncHttpClient client, Server server, boolean preemptive) throws IOException {
+        BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content", "Test");
         Future<Response> f = r.execute();
         return f;
     }
 
     private Realm realm(boolean preemptive) {
-        return (new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(preemptive).build();
+        return (new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).setUsePreemptiveAuth(preemptive).build();
     }
 
     @Override
@@ -268,6 +231,6 @@ protected String getTargetUrl() {
 
     @Override
     public AbstractHandler configureHandler() throws Exception {
-        return new SimpleHandler();
+        return new IncompleteResponseHandler();
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java b/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
index 361e57be5..958361c6b 100644
--- a/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
@@ -15,200 +15,120 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.ADMIN;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.async.util.TestUtils.USER;
+import static org.asynchttpclient.async.util.TestUtils.addBasicAuthHandler;
+import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SimpleAsyncHttpClient;
 import org.asynchttpclient.consumers.AppendableBodyConsumer;
 import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.apache.log4j.ConsoleAppender;
-import org.apache.log4j.Level;
-import org.apache.log4j.Logger;
-import org.apache.log4j.PatternLayout;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.BasicAuthenticator;
-import org.eclipse.jetty.security.authentication.DigestAuthenticator;
-import org.eclipse.jetty.server.Connector;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.util.security.Constraint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class BasicAuthTest extends AbstractBasicTest {
 
-    protected final static String MY_MESSAGE = "my message";
-    protected final static String user = "user";
-    protected final static String admin = "admin";
+    protected static final String MY_MESSAGE = "my message";
 
     private Server server2;
+    private Server serverNoAuth;
+    private int portNoAuth;
+
+    public abstract String getProviderClass();
 
     @BeforeClass(alwaysRun = true)
     @Override
     public void setUpGlobal() throws Exception {
-        server = new Server();
-        Logger root = Logger.getRootLogger();
-        root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
-
         port1 = findFreePort();
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-        LoginService loginService = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-        server.addBean(loginService);
-
-        Constraint constraint = new Constraint();
-        constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[] { user, admin });
-        constraint.setAuthenticate(true);
-
-        ConstraintMapping mapping = new ConstraintMapping();
-        mapping.setConstraint(constraint);
-        mapping.setPathSpec("/*");
+        port2 = findFreePort();
+        portNoAuth = findFreePort();
 
-        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
-        cm.add(mapping);
+        server = newJettyHttpServer(port1);
+        addBasicAuthHandler(server, false, configureHandler());
+        server.start();
 
-        Set<String> knownRoles = new HashSet<String>();
-        knownRoles.add(user);
-        knownRoles.add(admin);
+        server2 = newJettyHttpServer(port2);
+        addDigestAuthHandler(server2, true, new RedirectHandler());
+        server2.start();
 
-        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
-        security.setConstraintMappings(cm, knownRoles);
-        security.setAuthenticator(new BasicAuthenticator());
-        security.setLoginService(loginService);
-        security.setStrict(false);
-        security.setHandler(configureHandler());
+        // need noAuth server to verify the preemptive auth mode (see basicAuthTetPreemtiveTest) 
+        serverNoAuth = newJettyHttpServer(portNoAuth);
+        serverNoAuth.setHandler(new SimpleHandler());
+        serverNoAuth.start();
 
-        server.setHandler(security);
-        server.start();
-        log.info("Local HTTP server started successfully");
+        logger.info("Local HTTP server started successfully");
     }
 
-    private String getFileContent(final File file) {
-        FileInputStream in = null;
-        try {
-            if (file.exists() && file.canRead()) {
-                final StringBuilder sb = new StringBuilder(128);
-                final byte[] b = new byte[512];
-                int read;
-                in = new FileInputStream(file);
-                while ((read = in.read(b)) != -1) {
-                    sb.append(new String(b, 0, read, "UTF-8"));
-                }
-                return sb.toString();
-            }
-            throw new IllegalArgumentException("File does not exist or cannot be read: " + file.getCanonicalPath());
-        } catch (IOException ioe) {
-            throw new IllegalStateException(ioe);
-        } finally {
-            if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException ignored) {
-                }
-            }
-        }
-
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        super.tearDownGlobal();
+        server2.stop();
+        serverNoAuth.stop();
     }
 
-    private void setUpSecondServer() throws Exception {
-        server2 = new Server();
-        port2 = findFreePort();
-
-        SelectChannelConnector connector = new SelectChannelConnector();
-        connector.setHost("127.0.0.1");
-        connector.setPort(port2);
-
-        server2.addConnector(connector);
-
-        LoginService loginService = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-        server2.addBean(loginService);
-
-        Constraint constraint = new Constraint();
-        constraint.setName(Constraint.__DIGEST_AUTH);
-        constraint.setRoles(new String[] { user, admin });
-        constraint.setAuthenticate(true);
-
-        ConstraintMapping mapping = new ConstraintMapping();
-        mapping.setConstraint(constraint);
-        mapping.setPathSpec("/*");
-
-        Set<String> knownRoles = new HashSet<String>();
-        knownRoles.add(user);
-        knownRoles.add(admin);
-
-        ConstraintSecurityHandler security = new ConstraintSecurityHandler() {
-
-            @Override
-            public void handle(String arg0, Request arg1, HttpServletRequest arg2, HttpServletResponse arg3) throws IOException, ServletException {
-                System.err.println("request in security handler");
-                System.err.println("Authorization: " + arg2.getHeader("Authorization"));
-                System.err.println("RequestUri: " + arg2.getRequestURI());
-                super.handle(arg0, arg1, arg2, arg3);
-            }
-        };
-
-        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
-        cm.add(mapping);
+    @Override
+    protected String getTargetUrl() {
+        return "http://127.0.0.1:" + port1 + "/";
+    }
 
-        security.setConstraintMappings(cm, knownRoles);
-        security.setAuthenticator(new DigestAuthenticator());
-        security.setLoginService(loginService);
-        security.setStrict(true);
-        security.setHandler(new RedirectHandler());
+    @Override
+    protected String getTargetUrl2() {
+        return "http://127.0.0.1:" + port2 + "/uff";
+    }
 
-        server2.setHandler(security);
-        server2.start();
+    protected String getTargetUrlNoAuth() {
+        return "http://127.0.0.1:" + portNoAuth + "/";
     }
 
-    private void stopSecondServer() throws Exception {
-        server2.stop();
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SimpleHandler();
     }
 
-    private class RedirectHandler extends AbstractHandler {
+    private static class RedirectHandler extends AbstractHandler {
+
+        private static final Logger LOGGER = LoggerFactory.getLogger(RedirectHandler.class);
+
         public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-            System.err.println("redirecthandler");
-            System.err.println("request: " + request.getRequestURI());
+            LOGGER.info("request: " + request.getRequestURI());
             if ("/uff".equals(request.getRequestURI())) {
 
-                System.err.println("redirect to /bla");
+                LOGGER.info("redirect to /bla");
                 response.setStatus(302);
                 response.setHeader("Location", "/bla");
                 response.getOutputStream().flush();
@@ -217,18 +137,19 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
                 return;
 
             } else {
-                System.err.println("got redirected" + request.getRequestURI());
+                LOGGER.info("got redirected" + request.getRequestURI());
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
                 response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
                 response.setStatus(200);
-                response.getOutputStream().write("content".getBytes("UTF-8"));
+                response.getOutputStream().write("content".getBytes(StandardCharsets.UTF_8));
                 response.getOutputStream().flush();
                 response.getOutputStream().close();
             }
         }
     }
 
-    private class SimpleHandler extends AbstractHandler {
+    private static class SimpleHandler extends AbstractHandler {
+
         public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             if (request.getHeader("X-401") != null) {
@@ -262,9 +183,9 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
     public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-            Future<Response> f = r.execute();
+            Future<Response> f = client.prepareGet(getTargetUrl())//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
+                    .execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
@@ -276,41 +197,28 @@ public void basicAuthTest() throws IOException, ExecutionException, TimeoutExcep
 
     @Test(groups = { "standalone", "default_provider" })
     public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setMaxRedirects(10).build());
         try {
-            setUpSecondServer();
-            client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setMaximumNumberOfRedirects(10).build());
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl2())
-            // .setHeader( "X-302", "/bla" )
-                    .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-            Future<Response> f = r.execute();
+            Future<Response> f = client.prepareGet(getTargetUrl2())//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
+                    .execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
 
         } finally {
-            if (client != null)
-                client.close();
-            stopSecondServer();
+            client.close();
         }
     }
 
-    @Override
-    protected String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/";
-    }
-
-    protected String getTargetUrl2() {
-        return "http://127.0.0.1:" + port2 + "/uff";
-    }
-
     @Test(groups = { "standalone", "default_provider" })
     public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setHeader("X-401", "401").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl())//
+                    .setHeader("X-401", "401")//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build());
 
             Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
 
@@ -353,9 +261,12 @@ public Integer onCompleted() throws Exception {
     public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(true).build());
+        	// send the request to the no-auth endpoint to be able to verify the auth header is
+        	// really sent preemptively for the initial call.
+            Future<Response> f = client.prepareGet(getTargetUrlNoAuth())//
+                    .setRealm((new Realm.RealmBuilder()).setScheme(AuthScheme.BASIC).setPrincipal(USER).setPassword(ADMIN).setUsePreemptiveAuth(true).build())//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
@@ -369,9 +280,10 @@ public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException,
     public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).build());
+            Future<Response> f = client.prepareGet(getTargetUrl())//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(ADMIN).build())//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 401);
@@ -384,10 +296,11 @@ public void basicAuthNegativeTest() throws IOException, ExecutionException, Time
     public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            ByteArrayInputStream is = new ByteArrayInputStream("test".getBytes());
-            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(is).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(new ByteArrayInputStream("test".getBytes()))//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(30, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
@@ -399,88 +312,71 @@ public void basicAuthInputStreamTest() throws IOException, ExecutionException, T
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicAuthFileTest() throws Throwable {
+    public void basicAuthFileTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-            final String fileContent = getFileContent(file);
-
-            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), fileContent);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicAuthAsyncConfigTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build()).build());
+    public void basicAuthAsyncConfigTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build()).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-            final String fileContent = getFileContent(file);
-
-            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file);
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE_STRING)//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), fileContent);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicAuthFileNoKeepAliveTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(false).build());
+    public void basicAuthFileNoKeepAliveTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(false).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-            final String fileContent = getFileContent(file);
 
-            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
+                    .execute();
 
-            Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), fileContent);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SimpleHandler();
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
-    public void StringBuilderBodyConsumerTest() throws Throwable {
+    @Test(groups = { "standalone", "default_provider" })
+    public void stringBuilderBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setRealmPrincipal(user).setRealmPassword(admin).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setRealmPrincipal(USER).setRealmPassword(ADMIN)
+                .setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
         try {
             StringBuilder s = new StringBuilder();
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
 
-            System.out.println("waiting for response");
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(s.toString(), MY_MESSAGE);
@@ -495,7 +391,7 @@ public void StringBuilderBodyConsumerTest() throws Throwable {
     public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build());
 
             Future<Response> f = r.execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
diff --git a/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java b/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
index 619f52322..9f13a7b51 100644
--- a/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
@@ -15,218 +15,53 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.async.util.TestUtils.createSSLContext;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig.Builder;
 import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.ssl.SslSocketConnector;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeClass;
+import org.testng.Assert;
 import org.testng.annotations.Test;
 
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
+import javax.net.ssl.SSLSession;
 import javax.servlet.http.HttpServletResponse;
-import java.io.File;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.ConnectException;
-import java.net.ServerSocket;
-import java.net.URL;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.Enumeration;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-
-public abstract class BasicHttpsTest extends AbstractBasicTest {
-
-    protected final Logger log = LoggerFactory.getLogger(BasicHttpsTest.class);
-
-    public static class EchoHandler extends AbstractHandler {
-
-        /* @Override */
-        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
-
-            httpResponse.setContentType("text/html; charset=utf-8");
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-
-                if (param.startsWith("LockThread")) {
-                    try {
-                        Thread.sleep(40 * 1000);
-                    } catch (InterruptedException ex) { // nothing to do here
-                    }
-                }
-
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            Enumeration<?> i = httpRequest.getParameterNames();
-
-            StringBuilder requestBody = new StringBuilder();
-            while (i.hasMoreElements()) {
-                param = i.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getParameter(param));
-                requestBody.append(param);
-                requestBody.append("_");
-            }
-
-            String pathInfo = httpRequest.getPathInfo();
-            if (pathInfo != null)
-                httpResponse.addHeader("X-pathInfo", pathInfo);
-
-            String queryString = httpRequest.getQueryString();
-            if (queryString != null)
-                httpResponse.addHeader("X-queryString", queryString);
-
-            httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-            javax.servlet.http.Cookie[] cs = httpRequest.getCookies();
-            if (cs != null) {
-                for (javax.servlet.http.Cookie c : cs) {
-                    httpResponse.addCookie(c);
-                }
-            }
-
-            if (requestBody.length() > 0) {
-                httpResponse.getOutputStream().write(requestBody.toString().getBytes());
-            }
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            int pos = 0;
-            if (bytes.length > 0) {
-                int read = 0;
-                while (read != -1) {
-                    read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
-                    pos += read;
-                }
-
-                httpResponse.getOutputStream().write(bytes);
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-
-        }
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-    }
-
-    @AfterMethod(alwaysRun = true)
-    public void tearDownProps() throws Exception {
-        System.clearProperty("javax.net.ssl.keyStore");
-        System.clearProperty("javax.net.ssl.trustStore");
-    }
+public abstract class BasicHttpsTest extends AbstractBasicHttpsTest {
 
     protected String getTargetUrl() {
         return String.format("https://127.0.0.1:%d/foo/test", port1);
     }
 
-    public AbstractHandler configureHandler() throws Exception {
-        return new EchoHandler();
-    }
-
-    protected int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            socket = new ServerSocket(0);
-
-            return socket.getLocalPort();
-        } finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        port1 = findFreePort();
-        SslSocketConnector connector = new SslSocketConnector();
-        connector.setHost("127.0.0.1");
-        connector.setPort(port1);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL cacertsUrl = cl.getResource("ssltest-cacerts.jks");
-        String trustStoreFile = new File(cacertsUrl.toURI()).getAbsolutePath();
-        connector.setTruststore(trustStoreFile);
-        connector.setTrustPassword("changeit");
-        connector.setTruststoreType("JKS");
-
-        log.info("SSL certs path: {}", trustStoreFile);
-
-        // override system properties
-        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
-        connector.setKeystore(keyStoreFile);
-        connector.setKeyPassword("changeit");
-        connector.setKeystoreType("JKS");
-
-        log.info("SSL keystore path: {}", keyStoreFile);
-
-        server.addConnector(connector);
-
-        server.setHandler(configureHandler());
-        server.start();
-        log.info("Local HTTP server started successfully");
-    }
-
     @Test(groups = { "standalone", "default_provider" })
-    public void zeroCopyPostTest() throws Throwable {
+    public void zeroCopyPostTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-            Response resp = f.get();
+            Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void multipleSSLRequestsTest() throws Throwable {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
+    public void multipleSSLRequestsTest() throws Exception {
+        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
             String body = "hello there";
 
@@ -245,8 +80,8 @@ public void multipleSSLRequestsTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void multipleSSLWithoutCacheTest() throws Throwable {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).setAllowSslConnectionPool(false).build());
+    public void multipleSSLWithoutCacheTest() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).setAllowPoolingSslConnections(false).build());
         try {
             String body = "hello there";
             c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
@@ -262,80 +97,64 @@ public void multipleSSLWithoutCacheTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void reconnectsAfterFailedCertificationPath() throws Throwable {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
+    public void reconnectsAfterFailedCertificationPath() throws Exception {
+        AtomicBoolean trusted = new AtomicBoolean(false);
+        AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(trusted)).build());
         try {
-            final String body = "hello there";
+            String body = "hello there";
 
-            TRUST_SERVER_CERT.set(false);
+            // first request fails because server certificate is rejected
+            Throwable cause = null;
             try {
-                // first request fails because server certificate is rejected
-                try {
-                    c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-                } catch (final ExecutionException e) {
-                    Throwable cause = e.getCause();
-                    if (cause instanceof ConnectException) {
-                        assertNotNull(cause.getCause());
-                        assertTrue(cause.getCause() instanceof SSLHandshakeException);
-                    } else {
-                        assertTrue(cause instanceof SSLHandshakeException);
-                    }
+                c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (final ExecutionException e) {
+                cause = e.getCause();
+                if (cause instanceof ConnectException) {
+                    //assertNotNull(cause.getCause());
+                    assertTrue(cause.getCause() instanceof SSLHandshakeException, "Expected an SSLHandshakeException, got a " + cause.getCause());
+                } else {
+                   assertTrue(cause instanceof IOException, "Expected an IOException, got a " + cause);
                 }
+            }
+            assertNotNull(cause);
 
-                TRUST_SERVER_CERT.set(true);
+            trusted.set(true);
 
-                // second request should succeed
-                final Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // second request should succeed
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-                assertEquals(response.getResponseBody(), body);
-            } finally {
-                TRUST_SERVER_CERT.set(true);
-            }
+            assertEquals(response.getResponseBody(), body);
         } finally {
             c.close();
         }
     }
 
-    private static SSLContext createSSLContext() {
-        try {
-            InputStream keyStoreStream = BasicHttpsTest.class.getResourceAsStream("ssltest-cacerts.jks");
-            char[] keyStorePassword = "changeit".toCharArray();
-            KeyStore ks = KeyStore.getInstance("JKS");
-            ks.load(keyStoreStream, keyStorePassword);
-
-            // Set up key manager factory to use our key store
-            char[] certificatePassword = "changeit".toCharArray();
-            KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
-            kmf.init(ks, certificatePassword);
-
-            // Initialize the SSLContext to work with our key managers.
-            KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
-            SecureRandom secureRandom = new SecureRandom();
+    @Test(timeOut = 5000)
+    public void failInstantlyIfHostNamesDiffer() throws Exception {
+        AsyncHttpClient client = null;
 
-            SSLContext sslContext = SSLContext.getInstance("TLS");
-            sslContext.init(keyManagers, trustManagers, secureRandom);
-
-            return sslContext;
-        } catch (Exception e) {
-            throw new Error("Failed to initialize the server-side SSLContext", e);
-        }
-    }
+        try {
+            final Builder builder = new Builder().setHostnameVerifier(new HostnameVerifier() {
 
-    private static final AtomicBoolean TRUST_SERVER_CERT = new AtomicBoolean(true);
-    private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager() {
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
+                public boolean verify(String arg0, SSLSession arg1) {
+                    return false;
+                }
+            }).setRequestTimeout(20000);
 
-        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-        }
+            client = getAsyncHttpClient(builder.build());
 
-        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            if (!TRUST_SERVER_CERT.get()) {
-                throw new CertificateException("Server certificate not trusted.");
+            try {
+            client.prepareGet("https://github.com/AsyncHttpClient/async-http-client/issues/355").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            
+            Assert.assertTrue(false, "Shouldn't be here: should get an Exception");
+            } catch (ExecutionException e) {
+                Assert.assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
+            } catch (Exception e) {
+                Assert.assertTrue(false, "Shouldn't be here: should get a ConnectException wrapping a ConnectException");
             }
+            
+        } finally {
+            client.close();
         }
-    };
-
+    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java b/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
index 449863277..727e0d67a 100644
--- a/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
@@ -15,6 +15,8 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.RequestBuilder;
@@ -25,19 +27,17 @@
 import java.io.ByteArrayInputStream;
 import java.util.concurrent.Future;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class BodyChunkTest extends AbstractBasicTest {
 
-    private final static String MY_MESSAGE = "my message";
+    private static final String MY_MESSAGE = "my message";
 
     @Test(groups = { "standalone", "default_provider" })
-    public void negativeContentTypeTest() throws Throwable {
+    public void negativeContentTypeTest() throws Exception {
 
         AsyncHttpClientConfig.Builder confbuilder = new AsyncHttpClientConfig.Builder();
-        confbuilder = confbuilder.setConnectionTimeoutInMs(100);
-        confbuilder = confbuilder.setMaximumConnectionsTotal(50);
-        confbuilder = confbuilder.setRequestTimeoutInMs(5 * 60 * 1000); // 5 minutes
+        confbuilder = confbuilder.setConnectionTimeout(100);
+        confbuilder = confbuilder.setMaxConnections(50);
+        confbuilder = confbuilder.setRequestTimeout(5 * 60 * 1000); // 5 minutes
 
         // Create client
         AsyncHttpClient client = getAsyncHttpClient(confbuilder.build());
@@ -57,5 +57,4 @@ public void negativeContentTypeTest() throws Throwable {
             client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
index e6bf47bf9..baf91d11e 100644
--- a/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
@@ -12,21 +12,29 @@
  */
 package org.asynchttpclient.async;
 
+import static org.apache.commons.io.IOUtils.copy;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.BodyDeferringAsyncHandler;
 import org.asynchttpclient.BodyDeferringAsyncHandler.BodyDeferringInputStream;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PipedInputStream;
 import java.io.PipedOutputStream;
@@ -34,9 +42,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class BodyDeferringAsyncHandlerTest extends AbstractBasicTest {
 
     // not a half gig ;) for test shorter run's sake
@@ -46,8 +51,6 @@
 
         public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-            // 512MB large download
-            // 512 * 1024 * 1024 = 536870912
             httpResponse.setStatus(200);
             httpResponse.setContentLength(HALF_GIG);
             httpResponse.setContentType("application/octet-stream");
@@ -100,32 +103,20 @@ public int getByteCount() {
         }
     }
 
-    // simple stream copy just to "consume". It closes streams.
-    public static void copy(InputStream in, OutputStream out) throws IOException {
-        byte[] buf = new byte[1024];
-        int len;
-        while ((len = in.read(buf)) > 0) {
-            out.write(buf, 0, len);
-        }
-        out.flush();
-        out.close();
-        in.close();
-    }
-
     public AbstractHandler configureHandler() throws Exception {
         return new SlowAndBigHandler();
     }
 
     public AsyncHttpClientConfig getAsyncHttpClientConfig() {
         // for this test brevity's sake, we are limiting to 1 retries
-        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).setRequestTimeoutInMs(10000).build();
+        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).setRequestTimeout(10000).build();
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
+            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
@@ -133,16 +124,16 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
             Response resp = bdah.getResponse();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            assertEquals(resp.getHeader("content-length"), String.valueOf(HALF_GIG));
             // we got headers only, it's probably not all yet here (we have BIG file
             // downloading)
-            assertEquals(true, HALF_GIG >= cos.getByteCount());
+            assertTrue(cos.getByteCount() <= HALF_GIG);
 
             // now be polite and wait for body arrival too (otherwise we would be
             // dropping the "line" on server)
             f.get();
             // it all should be here now
-            assertEquals(true, HALF_GIG == cos.getByteCount());
+            assertEquals(cos.getByteCount(), HALF_GIG);
         } finally {
             client.close();
         }
@@ -152,7 +143,8 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
     public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
+                    Boolean.TRUE.toString());
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
@@ -160,21 +152,21 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
             Response resp = bdah.getResponse();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            assertEquals(resp.getHeader("content-length"), String.valueOf(HALF_GIG));
             // we got headers only, it's probably not all yet here (we have BIG file
             // downloading)
-            assertEquals(true, HALF_GIG >= cos.getByteCount());
+            assertTrue(cos.getByteCount() <= HALF_GIG);
 
             // now be polite and wait for body arrival too (otherwise we would be
             // dropping the "line" on server)
             try {
                 f.get();
-                Assert.fail("get() should fail with IOException!");
+                fail("get() should fail with IOException!");
             } catch (Exception e) {
                 // good
             }
             // it's incomplete, there was an error
-            assertEquals(false, HALF_GIG == cos.getByteCount());
+            assertNotEquals(cos.getByteCount(), HALF_GIG);
         } finally {
             client.close();
         }
@@ -184,7 +176,7 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
     public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
+            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
 
             PipedOutputStream pos = new PipedOutputStream();
             PipedInputStream pis = new PipedInputStream(pos);
@@ -197,15 +189,20 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
             Response resp = is.getAsapResponse();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            assertEquals(resp.getHeader("content-length"), String.valueOf(HALF_GIG));
             // "consume" the body, but our code needs input stream
             CountingOutputStream cos = new CountingOutputStream();
-            copy(is, cos);
+            try {
+                copy(is, cos);
+            } finally {
+                is.close();
+                cos.close();
+            }
 
             // now we don't need to be polite, since consuming and closing
             // BodyDeferringInputStream does all.
             // it all should be here now
-            assertEquals(true, HALF_GIG == cos.getByteCount());
+            assertEquals(cos.getByteCount(), HALF_GIG);
         } finally {
             client.close();
         }
@@ -214,29 +211,38 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
     @Test(groups = { "standalone", "default_provider" })
     public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
 
-        PipedOutputStream pos = new PipedOutputStream();
-        PipedInputStream pis = new PipedInputStream(pos);
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+        try {
+            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
+                    Boolean.TRUE.toString());
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
 
-        Future<Response> f = r.execute(bdah);
+            Future<Response> f = r.execute(bdah);
 
-        BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
 
-        Response resp = is.getAsapResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
-        // "consume" the body, but our code needs input stream
-        CountingOutputStream cos = new CountingOutputStream();
-        try {
-            copy(is, cos);
-            Assert.fail("InputStream consumption should fail with IOException!");
-        } catch (IOException e) {
-            // good!
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("content-length"), String.valueOf(HALF_GIG));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            try {
+                try {
+                    copy(is, cos);
+                } finally {
+                    is.close();
+                    cos.close();
+                }
+                fail("InputStream consumption should fail with IOException!");
+            } catch (IOException e) {
+                // good!
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -244,14 +250,14 @@ public void testConnectionRefused() throws IOException, ExecutionException, Time
         int newPortWithoutAnyoneListening = findFreePort();
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
             r.execute(bdah);
             try {
                 bdah.getResponse();
-                Assert.fail("IOException should be thrown here!");
+                fail("IOException should be thrown here!");
             } catch (IOException e) {
                 // good
             }
@@ -259,5 +265,4 @@ public void testConnectionRefused() throws IOException, ExecutionException, Time
             client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java b/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
index 1a6763a43..7223357ba 100644
--- a/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
@@ -12,32 +12,34 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Enumeration;
-import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.*;
-
 public abstract class ByteBufferCapacityTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -72,17 +74,15 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicByteBufferTest() throws Throwable {
+    public void basicByteBufferTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-            File largeFile = createTempFile(bytes, (int) repeats);
+            File largeFile = createTempFile(1024 * 100 * 10);
             final AtomicInteger byteReceived = new AtomicInteger();
 
             try {
                 Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
-                    /* @Override */
+                    @Override
                     public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
                         byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
                         return super.onBodyPartReceived(content);
@@ -106,29 +106,4 @@ public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
-
-    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
-        TMP.mkdirs();
-        TMP.deleteOnExit();
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
-        write(pattern, repeat, tmpFile);
-
-        return tmpFile;
-    }
-
-    public static void write(byte[] pattern, int repeat, File file) throws IOException {
-        file.deleteOnExit();
-        file.getParentFile().mkdirs();
-        FileOutputStream out = null;
-        try {
-            out = new FileOutputStream(file);
-            for (int i = 0; i < repeat; i++) {
-                out.write(pattern);
-            }
-        } finally {
-            if (out != null) {
-                out.close();
-            }
-        }
-    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java b/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
index 9334cf38b..0566ecdba 100644
--- a/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
@@ -12,165 +12,72 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_FILE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.FileAssert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.generators.InputStreamBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
 import java.io.FileInputStream;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Random;
-
-import static org.testng.Assert.assertNotNull;
-import static org.testng.AssertJUnit.assertEquals;
-import static org.testng.AssertJUnit.assertTrue;
-import static org.testng.FileAssert.fail;
 
 /**
  * Test that the url fetcher is able to communicate via a proxy
- *
+ * 
  * @author dominict
  */
 abstract public class ChunkingTest extends AbstractBasicTest {
     // So we can just test the returned data is the image,
     // and doesn't contain the chunked delimeters.
-    public static byte[] LARGE_IMAGE_BYTES;
-
-    static {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        InputStream instream = null;
-        try {
-            ClassLoader cl = ChunkingTest.class.getClassLoader();
-            // override system properties
-            URL url = cl.getResource("300k.png");
-            File sourceFile = new File(url.toURI());
-            instream = new FileInputStream(sourceFile);
-            byte[] buf = new byte[8092];
-            int len = 0;
-            while ((len = instream.read(buf)) > 0) {
-                baos.write(buf, 0, len);
-            }
-            LARGE_IMAGE_BYTES = baos.toByteArray();
-        }
-        catch (Throwable e) {
-            LARGE_IMAGE_BYTES = new byte[265495];
-            Random x = new Random();
-            x.nextBytes(LARGE_IMAGE_BYTES);
-        }
-    }
 
     /**
-     * Tests that the custom chunked stream result in success and
-     * content returned that is unchunked
+     * Tests that the custom chunked stream result in success and content returned that is unchunked
      */
     @Test()
-    public void testCustomChunking() throws Throwable {
-        doTest(true);
-    }
+    public void testCustomChunking() throws Exception {
+        AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
 
+        bc.setAllowPoolingConnections(true);
+        bc.setMaxConnectionsPerHost(1);
+        bc.setMaxConnections(1);
+        bc.setConnectionTimeout(1000);
+        bc.setRequestTimeout(1000);
+        bc.setFollowRedirect(true);
 
-    private void doTest(boolean customChunkedInputStream) throws Exception {
-        AsyncHttpClient c = null;
+        AsyncHttpClient c = getAsyncHttpClient(bc.build());
         try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsPerHost(1);
-            bc.setMaximumConnectionsTotal(1);
-            bc.setConnectionTimeoutInMs(1000);
-            bc.setRequestTimeoutInMs(1000);
-            bc.setFollowRedirects(true);
-
-
-            c = getAsyncHttpClient(bc.build());
 
             RequestBuilder builder = new RequestBuilder("POST");
             builder.setUrl(getTargetUrl());
-            if (customChunkedInputStream) {
-                // made buff in stream big enough to mark.
-                builder.setBody(new InputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(getTestFile()), 400000)));
-            } else {
-                // made buff in stream big enough to mark.
-                builder.setBody(new InputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(getTestFile()), 400000)));
-            }
-            Request r = builder.build();
-            Response res = null;
+            // made buff in stream big enough to mark.
+            builder.setBody(new InputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE), 400000)));
 
-            try {
-                ListenableFuture<Response> response = c.executeRequest(r);
-                res = response.get();
-                assertNotNull(res.getResponseBodyAsStream());
-                if (500 == res.getStatusCode()) {
-                    System.out.println("==============");
-                    System.out.println("500 response from call");
-                    System.out.println("Headers:" + res.getHeaders());
-                    System.out.println("==============");
-                    System.out.flush();
-                    assertEquals("Should have 500 status code", 500, res.getStatusCode());
-                    assertTrue("Should have failed due to chunking", res.getHeader("X-Exception").contains("invalid.chunk.length"));
-                    fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + res.getHeader("X-Exception"));
-                } else {
-                    assertEquals(LARGE_IMAGE_BYTES, readInputStreamToBytes(res.getResponseBodyAsStream()));
-                }
-            }
-            catch (Exception e) {
-
-                fail("Exception Thrown:" + e.getMessage());
-            }
-        }
-        finally {
-            if (c != null) c.close();
-        }
-    }
-
-    private byte[] readInputStreamToBytes(InputStream stream) {
-        byte[] data = new byte[0];
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        try {
-            int nRead;
-            byte[] tmp = new byte[8192];
-
-            while ((nRead = stream.read(tmp, 0, tmp.length)) != -1) {
-                buffer.write(tmp, 0, nRead);
-            }
-            buffer.flush();
-            data = buffer.toByteArray();
-        }
-        catch (Exception e) {
+            Request r = builder.build();
 
-        }
-        finally {
-            try {
-                stream.close();
-            } catch (Exception e2) {
+            Response response = c.executeRequest(r).get();
+            if (500 == response.getStatusCode()) {
+                StringBuilder sb = new StringBuilder();
+                sb.append("==============\n");
+                sb.append("500 response from call\n");
+                sb.append("Headers:" + response.getHeaders() + "\n");
+                sb.append("==============\n");
+                logger.debug(sb.toString());
+                assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
+                assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
+                fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
+            } else {
+                assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
             }
-            return data;
-        }
-    }
-
-    private static File getTestFile() {
-        String testResource1 = "300k.png";
-
-        File testResource1File = null;
-        try {
-            ClassLoader cl = ChunkingTest.class.getClassLoader();
-            URL url = cl.getResource(testResource1);
-            testResource1File = new File(url.toURI());
-        } catch (Throwable e) {
-            // TODO Auto-generated catch block
-            fail("unable to find " + testResource1);
+        } finally {
+            c.close();
         }
-
-        return testResource1File;
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java b/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
index 8bf0bc6e6..7ecc68efb 100644
--- a/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
@@ -15,18 +15,18 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.TimeUnit;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class ComplexClientTest extends AbstractBasicTest {
 
     @Test(groups = { "standalone", "default_provider" })
-    public void multipleRequestsTest() throws Throwable {
+    public void multipleRequestsTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             String body = "hello there";
@@ -46,7 +46,7 @@ public void multipleRequestsTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void urlWithoutSlashTest() throws Throwable {
+    public void urlWithoutSlashTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             String body = "hello there";
diff --git a/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java b/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
index ccc7d3901..86ea33b6d 100644
--- a/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
@@ -15,6 +15,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
@@ -22,7 +27,6 @@
 import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
@@ -33,17 +37,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
 public abstract class ConnectionPoolTest extends AbstractBasicTest {
     protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnections() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build());
         try {
             String url = getTargetUrl();
             int i;
@@ -65,7 +64,7 @@ public void testMaxTotalConnections() {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build());
         try {
             String url = getTargetUrl();
             int i;
@@ -93,7 +92,7 @@ public void testMaxTotalConnectionsException() {
     }
 
     @Test(groups = { "standalone", "default_provider", "async" }, enabled = true, invocationCount = 10, alwaysRun = true)
-    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Throwable {
+    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             // Use a l in case the assert fail
@@ -122,7 +121,7 @@ public Response onCompleted(Response response) throws Exception {
             client.prepareGet(getTargetUrl()).execute(handler);
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timed out");
+                fail("Timed out");
             }
 
             assertEquals(remoteAddresses.size(), 2);
@@ -132,14 +131,8 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public abstract void testInvalidConnectionsPool();
-
-    @Test(groups = { "standalone", "default_provider" })
-    public abstract void testValidConnectionsPool();
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+    public void multipleMaxConnectionOpenTest() throws Exception {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000).setMaxConnections(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             String body = "hello there";
@@ -166,8 +159,8 @@ public void multipleMaxConnectionOpenTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void multipleMaxConnectionOpenTestWithQuery() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+    public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000).setMaxConnections(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             String body = "hello there";
@@ -196,11 +189,11 @@ public void multipleMaxConnectionOpenTestWithQuery() throws Throwable {
     /**
      * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
      * 
-     * @throws Throwable
+     * @throws Exception
      *             if something wrong happens.
      */
     @Test(groups = { "standalone", "default_provider" })
-    public void win7DisconnectTest() throws Throwable {
+    public void win7DisconnectTest() throws Exception {
         final AtomicInteger count = new AtomicInteger(0);
 
         AsyncHttpClient client = getAsyncHttpClient(null);
@@ -233,7 +226,7 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void asyncHandlerOnThrowableTest() throws Throwable {
+    public void asyncHandlerOnThrowableTest() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final AtomicInteger count = new AtomicInteger();
@@ -248,7 +241,7 @@ public Response onCompleted(Response response) throws Exception {
                 });
 
                 client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                    /* @Override */
+                    @Override
                     public void onThrowable(Throwable t) {
                         if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
                             count.incrementAndGet();
@@ -268,5 +261,4 @@ public Response onCompleted(Response response) throws Exception {
             client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java b/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
index dbd83a400..2753c6062 100644
--- a/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
@@ -12,96 +12,46 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.ADMIN;
+import static org.asynchttpclient.async.util.TestUtils.USER;
+import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
-import org.apache.log4j.ConsoleAppender;
-import org.apache.log4j.Level;
-import org.apache.log4j.Logger;
-import org.apache.log4j.PatternLayout;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.DigestAuthenticator;
-import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.util.security.Constraint;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class DigestAuthTest extends AbstractBasicTest {
 
-    private final static String user = "user";
-    private final static String admin = "admin";
-
     @BeforeClass(alwaysRun = true)
     @Override
     public void setUpGlobal() throws Exception {
-        server = new Server();
-        Logger root = Logger.getRootLogger();
-        root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
-
         port1 = findFreePort();
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-        LoginService loginService = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-        server.addBean(loginService);
-
-        Constraint constraint = new Constraint();
-        constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[] { user, admin });
-        constraint.setAuthenticate(true);
-
-        ConstraintMapping mapping = new ConstraintMapping();
-        mapping.setConstraint(constraint);
-        mapping.setPathSpec("/*");
-
-        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
-        cm.add(mapping);
 
-        Set<String> knownRoles = new HashSet<String>();
-        knownRoles.add(user);
-        knownRoles.add(admin);
-
-        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
-        security.setConstraintMappings(cm, knownRoles);
-        security.setAuthenticator(new DigestAuthenticator());
-        security.setLoginService(loginService);
-        security.setStrict(false);
-
-        security.setHandler(configureHandler());
-        server.setHandler(security);
+        server = newJettyHttpServer(port1);
+        addDigestAuthHandler(server, false, configureHandler());
         server.start();
-        log.info("Local HTTP server started successfully");
+        logger.info("Local HTTP server started successfully");
     }
 
-    private class SimpleHandler extends AbstractHandler {
+    private static class SimpleHandler extends AbstractHandler {
         public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             response.addHeader("X-Auth", request.getHeader("Authorization"));
@@ -111,13 +61,18 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SimpleHandler();
+    }
+
     @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").setScheme(Realm.AuthScheme.DIGEST).build());
-
-            Future<Response> f = r.execute();
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+                    .setRealm(new Realm.RealmBuilder().setPrincipal(USER).setPassword(ADMIN).setRealmName("MyRealm").setScheme(Realm.AuthScheme.DIGEST).build())//
+                    .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -131,9 +86,9 @@ public void digestAuthTest() throws IOException, ExecutionException, TimeoutExce
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").build());
-
-            Future<Response> f = r.execute();
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+                    .setRealm(new Realm.RealmBuilder().setPrincipal(USER).setPassword(ADMIN).setRealmName("MyRealm").build())//
+                    .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -147,9 +102,9 @@ public void digestAuthTestWithoutScheme() throws IOException, ExecutionException
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).setScheme(Realm.AuthScheme.DIGEST).build());
-
-            Future<Response> f = r.execute();
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+                    .setRealm(new Realm.RealmBuilder().setPrincipal("fake").setPassword(ADMIN).setScheme(Realm.AuthScheme.DIGEST).build())//
+                    .execute();
             Response resp = f.get(20, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 401);
@@ -157,9 +112,4 @@ public void digestAuthNegativeTest() throws IOException, ExecutionException, Tim
             client.close();
         }
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SimpleHandler();
-    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java b/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
index 13924201c..fc0693cba 100644
--- a/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
@@ -15,6 +15,12 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -28,6 +34,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.CountDownLatch;
@@ -36,13 +43,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.assertNotNull;
-
-import static org.testng.Assert.fail;
-
 /**
  * Tests case where response doesn't have body.
  * 
@@ -82,13 +82,14 @@ public void onThrowable(Throwable t) {
                 }
 
                 public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                    String s = new String(e.getBodyPartBytes());
-                    log.info("got part: {}", s);
-                    if (s.equals("")) {
-                        // noinspection ThrowableInstanceNeverThrown
-                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    byte[] bytes = e.getBodyPartBytes();
+
+                    if (bytes.length != 0) {
+                        String s = new String(bytes);
+                        logger.info("got part: {}", s);
+                        logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                        queue.put(s);
                     }
-                    queue.put(s);
                     return STATE.CONTINUE;
                 }
 
@@ -124,7 +125,7 @@ public Object onCompleted() throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testPutEmptyBody() throws Throwable {
+    public void testPutEmptyBody() throws Exception {
         AsyncHttpClient ahc = getAsyncHttpClient(null);
         try {
             Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
@@ -132,7 +133,7 @@ public void testPutEmptyBody() throws Throwable {
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 204);
             assertEquals(response.getResponseBody(), "");
-            assertTrue(InputStream.class.isAssignableFrom(response.getResponseBodyAsStream().getClass()));
+            assertTrue(response.getResponseBodyAsStream() instanceof InputStream);
             assertEquals(response.getResponseBodyAsStream().read(), -1);
         } finally {
             ahc.close();
diff --git a/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java b/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
index 97d038f59..4759564cf 100644
--- a/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
@@ -16,8 +16,12 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -25,14 +29,12 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Tests to reproduce issues with handling of error responses
  * 
@@ -50,7 +52,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             response.setContentType("text/plain");
             response.setStatus(400);
             OutputStream out = response.getOutputStream();
-            out.write(BAD_REQUEST_STR.getBytes("UTF-8"));
+            out.write(BAD_REQUEST_STR.getBytes(StandardCharsets.UTF_8));
             out.flush();
         }
     }
@@ -68,8 +70,7 @@ public void testQueryParameters() throws Exception {
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 400);
-            String respStr = resp.getResponseBody();
-            assertEquals(BAD_REQUEST_STR, respStr);
+            assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
         } finally {
             client.close();
         }
diff --git a/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java b/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
index d522ab05f..cb9694a81 100644
--- a/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
@@ -15,6 +15,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
@@ -24,20 +29,16 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.File;
+
 import java.io.IOException;
-import java.net.URL;
 import java.util.concurrent.Future;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Test the Expect: 100-Continue.
  */
 public abstract class Expect100ContinueTest extends AbstractBasicTest {
 
-    private class ZeroCopyHandler extends AbstractHandler {
+    private static class ZeroCopyHandler extends AbstractHandler {
         public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int size = 10 * 1024;
@@ -55,27 +56,22 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
         }
     }
 
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ZeroCopyHandler();
+    }
+
     @Test(groups = { "standalone", "default_provider" })
-    public void Expect100Continue() throws Throwable {
+    public void Expect100Continue() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(file).execute();
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ZeroCopyHandler();
-    }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java b/api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java
new file mode 100644
index 000000000..59ab42924
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.multipart.FilePart;
+import org.asynchttpclient.util.StandardCharsets;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import java.io.File;
+import java.io.IOException;
+
+public abstract class FastUnauthorizedUploadTest extends AbstractBasicTest {
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+
+            public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+
+                resp.setStatus(401);
+                resp.getOutputStream().flush();
+                resp.getOutputStream().close();
+
+                baseRequest.setHandled(true);
+            }
+        };
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testUnauthorizedWhileUploading() throws Exception {
+        File file = createTempFile(1024 * 1024);
+
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", StandardCharsets.UTF_8)).execute()
+                    .get();
+            assertEquals(response.getStatusCode(), 401);
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java b/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
index 2247181f7..b2f378f9c 100644
--- a/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
@@ -12,95 +12,34 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_FILE;
+import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.FilePart;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.multipart.FilePart;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.net.URL;
-import java.util.UUID;
-
-import static org.testng.FileAssert.fail;
 
 public abstract class FilePartLargeFileTest extends AbstractBasicTest {
 
-    private File largeFile;
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
-    public void testPutImageFile() throws Exception {
-        largeFile = getTestFile();
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100 * 6000).build();
-        AsyncHttpClient client = getAsyncHttpClient(config);
-        try {
-            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
-
-            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
-
-            Response response = rb.execute().get();
-            Assert.assertEquals(200, response.getStatusCode());
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
-    public void testPutLargeTextFile() throws Exception {
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 1024 / bytes.length) + 1;
-        largeFile = createTempFile(bytes, (int) repeats);
-
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
-
-            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
-
-            Response response = rb.execute().get();
-            Assert.assertEquals(200, response.getStatusCode());
-        } finally {
-            client.close();
-        }
-    }
-
-    private static File getTestFile() {
-        String testResource1 = "300k.png";
-
-        File testResource1File = null;
-        try {
-            ClassLoader cl = ChunkingTest.class.getClassLoader();
-            URL url = cl.getResource(testResource1);
-            testResource1File = new File(url.toURI());
-        } catch (Throwable e) {
-            // TODO Auto-generated catch block
-            fail("unable to find " + testResource1);
-        }
-
-        return testResource1File;
-    }
-
-    @AfterMethod
-    public void after() {
-        largeFile.delete();
-    }
-
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
-            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+            public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
                 ServletInputStream in = req.getInputStream();
                 byte[] b = new byte[8192];
@@ -111,45 +50,37 @@ public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServle
                     b = new byte[8192];
                     total += count;
                 }
-                System.err.println("consumed " + total + " bytes.");
-
                 resp.setStatus(200);
                 resp.addHeader("X-TRANFERED", String.valueOf(total));
                 resp.getOutputStream().flush();
                 resp.getOutputStream().close();
 
-                arg1.setHandled(true);
-
+                baseRequest.setHandled(true);
             }
         };
     }
 
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
-
-    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
-        TMP.mkdirs();
-        TMP.deleteOnExit();
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
-        tmpFile.deleteOnExit();
-        write(pattern, repeat, tmpFile);
-
-        return tmpFile;
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutImageFile() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build());
+        try {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", StandardCharsets.UTF_8)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
-    public static void write(byte[] pattern, int repeat, File file) throws IOException {
-        file.deleteOnExit();
-        file.getParentFile().mkdirs();
-        FileOutputStream out = null;
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutLargeTextFile() throws Exception {
+        File file = createTempFile(1024 * 1024);
+
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            out = new FileOutputStream(file);
-            for (int i = 0; i < repeat; i++) {
-                out.write(pattern);
-            }
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", StandardCharsets.UTF_8)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
         } finally {
-            if (out != null) {
-                out.close();
-            }
+            client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/FilterTest.java b/api/src/test/java/org/asynchttpclient/async/FilterTest.java
index 6f843e5c4..58f4c44d9 100644
--- a/api/src/test/java/org/asynchttpclient/async/FilterTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FilterTest.java
@@ -12,6 +12,10 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
@@ -27,6 +31,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Enumeration;
@@ -34,13 +39,9 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
-
 public abstract class FilterTest extends AbstractBasicTest {
 
-    private class BasicHandler extends AbstractHandler {
+    private static class BasicHandler extends AbstractHandler {
 
         public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
@@ -62,8 +63,12 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
+    public String getTargetUrl() {
+        return String.format("http://127.0.0.1:%d/foo/test", port1);
+    }
+
     @Test(groups = { "standalone", "default_provider" })
-    public void basicTest() throws Throwable {
+    public void basicTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(100));
 
@@ -78,7 +83,7 @@ public void basicTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void loadThrottleTest() throws Throwable {
+    public void loadThrottleTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(10));
 
@@ -100,7 +105,7 @@ public void loadThrottleTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void maxConnectionsText() throws Throwable {
+    public void maxConnectionsText() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(0, 1000));
         AsyncHttpClient c = getAsyncHttpClient(b.build());
@@ -116,12 +121,8 @@ public void maxConnectionsText() throws Throwable {
         }
     }
 
-    public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
-    }
-
     @Test(groups = { "standalone", "default_provider" })
-    public void basicResponseFilterTest() throws Throwable {
+    public void basicResponseFilterTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addResponseFilter(new ResponseFilter() {
 
@@ -146,7 +147,7 @@ public void basicResponseFilterTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void replayResponseFilterTest() throws Throwable {
+    public void replayResponseFilterTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
 
@@ -178,7 +179,7 @@ public void replayResponseFilterTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void replayStatusCodeResponseFilterTest() throws Throwable {
+    public void replayStatusCodeResponseFilterTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
 
@@ -210,7 +211,7 @@ public void replayStatusCodeResponseFilterTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void replayHeaderResponseFilterTest() throws Throwable {
+    public void replayHeaderResponseFilterTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
 
diff --git a/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java b/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
index d58631801..aac30159b 100644
--- a/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
@@ -15,6 +15,10 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.testng.annotations.Test;
 
@@ -25,11 +29,8 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-
 public class FluentCaseInsensitiveStringsMapTest {
+
     @Test
     public void emptyTest() {
         FluentCaseInsensitiveStringsMap map = new FluentCaseInsensitiveStringsMap();
@@ -315,7 +316,7 @@ public void deleteAllCollectionTest() {
 
         map.deleteAll(Arrays.asList("bAz", "fOO"));
 
-        assertEquals(map.keySet(), Collections.<String>emptyList());
+        assertEquals(map.keySet(), Collections.<String> emptyList());
         assertNull(map.getFirstValue("foo"));
         assertNull(map.getJoinedValue("foo", ", "));
         assertNull(map.get("foo"));
@@ -391,7 +392,7 @@ public void replaceTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("Foo", "blub", "bla");
+        map.replaceWith("Foo", "blub", "bla");
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("Foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
@@ -417,7 +418,7 @@ public void replaceUndefinedTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("bar", Arrays.asList("blub"));
+        map.replaceWith("bar", Arrays.asList("blub"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "bar");
@@ -446,7 +447,7 @@ public void replaceNullTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace(null, Arrays.asList("blub"));
+        map.replaceWith(null, Arrays.asList("blub"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
@@ -472,7 +473,7 @@ public void replaceValueWithNullTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("baZ", (Collection<String>) null);
+        map.replaceWith("baZ", (Collection<String>) null);
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
diff --git a/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java b/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
index ffbb651a7..46a436d94 100644
--- a/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
@@ -15,6 +15,10 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.FluentStringsMap;
 import org.testng.annotations.Test;
 
@@ -25,11 +29,8 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-
 public class FluentStringsMapTest {
+
     @Test
     public void emptyTest() {
         FluentStringsMap map = new FluentStringsMap();
@@ -364,7 +365,7 @@ public void deleteAllCollectionTest() {
 
         map.deleteAll(Arrays.asList("baz", "foo"));
 
-        assertEquals(map.keySet(), Collections.<String>emptyList());
+        assertEquals(map.keySet(), Collections.<String> emptyList());
         assertNull(map.getFirstValue("foo"));
         assertNull(map.getJoinedValue("foo", ", "));
         assertNull(map.get("foo"));
@@ -466,7 +467,7 @@ public void replaceArrayTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("foo", "blub", "bla");
+        map.replaceWith("foo", "blub", "bla");
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
@@ -492,7 +493,7 @@ public void replaceCollectionTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("foo", Arrays.asList("blub", "bla"));
+        map.replaceWith("foo", Arrays.asList("blub", "bla"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
@@ -518,7 +519,7 @@ public void replaceDifferentCaseTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("Foo", Arrays.asList("blub", "bla"));
+        map.replaceWith("Foo", Arrays.asList("blub", "bla"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "Foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
@@ -547,7 +548,7 @@ public void replaceUndefinedTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("bar", Arrays.asList("blub"));
+        map.replaceWith("bar", Arrays.asList("blub"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "bar");
@@ -576,7 +577,7 @@ public void replaceNullTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace(null, Arrays.asList("blub"));
+        map.replaceWith(null, Arrays.asList("blub"));
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
@@ -602,7 +603,7 @@ public void replaceValueWithNullTest() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        map.replace("baz", (Collection<String>) null);
+        map.replaceWith("baz", (Collection<String>) null);
 
         assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
diff --git a/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java b/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
index c86ad22ae..2897d772e 100644
--- a/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
@@ -35,7 +35,7 @@
  */
 public abstract class FollowingThreadTest extends AbstractBasicTest {
 
-    private final static int COUNT = 10;
+    private static final int COUNT = 10;
 
     @Test(timeOut = 30 * 1000, groups = { "online", "default_provider", "scalability" })
     public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
@@ -50,7 +50,7 @@ public void testFollowRedirect() throws IOException, ExecutionException, Timeout
 
                     public void run() {
                         final CountDownLatch l = new CountDownLatch(1);
-                        final AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+                        final AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
                         try {
                             ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
 
@@ -94,5 +94,4 @@ public Integer onCompleted() throws Exception {
             pool.shutdown();
         }
     }
-
-}
\ No newline at end of file
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/Head302Test.java b/api/src/test/java/org/asynchttpclient/async/Head302Test.java
index a01b47c91..4ef5b2e3e 100644
--- a/api/src/test/java/org/asynchttpclient/async/Head302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/Head302Test.java
@@ -15,18 +15,20 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.BrokenBarrierException;
 import java.util.concurrent.CountDownLatch;
@@ -40,10 +42,11 @@
  * @author Hubert Iwaniuk
  */
 public abstract class Head302Test extends AbstractBasicTest {
+
     /**
      * Handler that does Found (302) in response to HEAD method.
      */
-    private class Head302handler extends AbstractHandler {
+    private static class Head302handler extends AbstractHandler {
         public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("HEAD".equalsIgnoreCase(request.getMethod())) {
                 if (request.getPathInfo().endsWith("_moved")) {
@@ -52,12 +55,17 @@ public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequ
                     response.setStatus(HttpServletResponse.SC_FOUND); // 302
                     response.setHeader("Location", request.getPathInfo() + "_moved");
                 }
-            } else { // this handler is to handle HEAD reqeust
+            } else { // this handler is to handle HEAD request
                 response.setStatus(HttpServletResponse.SC_FORBIDDEN);
             }
         }
     }
 
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new Head302handler();
+    }
+
     @Test(groups = { "standalone", "default_provider" })
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClient client = getAsyncHttpClient(null);
@@ -74,15 +82,10 @@ public Response onCompleted(Response response) throws Exception {
             }).get(3, TimeUnit.SECONDS);
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
             client.close();
         }
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new Head302handler();
-    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java b/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
index 1b5238bab..083b2da0f 100644
--- a/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
@@ -12,53 +12,46 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.async.util.TestUtils.createSSLContext;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig.Builder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.ssl.SslSocketConnector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.net.ssl.*;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.File;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.ConnectException;
-import java.net.ServerSocket;
-import java.net.URL;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
 import java.util.Enumeration;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
-
-public abstract class HostnameVerifierTest extends AbstractBasicTest {
+public abstract class HostnameVerifierTest extends AbstractBasicHttpsTest {
 
     protected final Logger log = LoggerFactory.getLogger(HostnameVerifierTest.class);
 
     public static class EchoHandler extends AbstractHandler {
 
-        /* @Override */
+        @Override
         public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
 
-            httpResponse.setContentType("text/html; charset=utf-8");
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
             while (e.hasMoreElements()) {
@@ -128,17 +121,6 @@ public void handle(String pathInContext, Request r, HttpServletRequest httpReque
         }
     }
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-    }
-
-    @AfterMethod(alwaysRun = true)
-    public void tearDownProps() throws Exception {
-        System.clearProperty("javax.net.ssl.keyStore");
-        System.clearProperty("javax.net.ssl.trustStore");
-    }
-
     protected String getTargetUrl() {
         return String.format("https://127.0.0.1:%d/foo/test", port1);
     }
@@ -147,86 +129,28 @@ public AbstractHandler configureHandler() throws Exception {
         return new EchoHandler();
     }
 
-    protected int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            socket = new ServerSocket(0);
-
-            return socket.getLocalPort();
-        } finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        port1 = findFreePort();
-        SslSocketConnector connector = new SslSocketConnector();
-        connector.setHost("127.0.0.1");
-        connector.setPort(port1);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL cacertsUrl = cl.getResource("ssltest-cacerts.jks");
-        String trustStoreFile = new File(cacertsUrl.toURI()).getAbsolutePath();
-        connector.setTruststore(trustStoreFile);
-        connector.setTrustPassword("changeit");
-        connector.setTruststoreType("JKS");
-
-        log.info("SSL certs path: {}", trustStoreFile);
-
-        // override system properties
-        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
-        connector.setKeystore(keyStoreFile);
-        connector.setKeyPassword("changeit");
-        connector.setKeystoreType("JKS");
-
-        log.info("SSL keystore path: {}", keyStoreFile);
-
-        server.addConnector(connector);
-
-        server.setHandler(configureHandler());
-        server.start();
-        log.info("Local HTTP server started successfully");
-    }
-
     @Test(groups = { "standalone", "default_provider" })
-    public void positiveHostnameVerifierTest() throws Throwable {
+    public void positiveHostnameVerifierTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new PositiveHostVerifier()).setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new PositiveHostVerifier()).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            Future<Response> f = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void negativeHostnameVerifierTest() throws Throwable {
+    public void negativeHostnameVerifierTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new NegativeHostVerifier()).setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new NegativeHostVerifier()).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
             try {
-                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+                client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
                 fail("ConnectException expected");
             } catch (ExecutionException ex) {
                 assertEquals(ex.getCause().getClass(), ConnectException.class);
@@ -237,61 +161,42 @@ public void negativeHostnameVerifierTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void remoteIDHostnameVerifierTest() throws Throwable {
+    public void remoteIDHostnameVerifierTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("bouette")).setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("bouette")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            try {
-                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-                fail("ConnectException expected");
-            } catch (ExecutionException ex) {
-                assertEquals(ex.getCause().getClass(), ConnectException.class);
-            }
+            client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
+            fail("ConnectException expected");
+        } catch (ExecutionException ex) {
+            assertEquals(ex.getCause().getClass(), ConnectException.class);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void remoteNegHostnameVerifierTest() throws Throwable {
+    public void remoteNegHostnameVerifierTest() throws Exception {
         // request is made to 127.0.0.1, but cert presented for localhost - this should fail
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("localhost")).setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("localhost")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            try {
-                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-                fail("ConnectException expected");
-            } catch (ExecutionException ex) {
-                assertEquals(ex.getCause().getClass(), ConnectException.class);
-            }
+            client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
+            fail("ConnectException expected");
+        } catch (ExecutionException ex) {
+            assertEquals(ex.getCause().getClass(), ConnectException.class);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void remotePosHostnameVerifierTest() throws Throwable {
+    public void remotePosHostnameVerifierTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("127.0.0.1")).setSSLContext(createSSLContext()).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("127.0.0.1")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            Response resp = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+            Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
@@ -320,54 +225,7 @@ public CheckHost(String hostName) {
         }
 
         public boolean verify(String s, SSLSession sslSession) {
-
-            if (s != null && s.equalsIgnoreCase(hostName)) {
-                return true;
-            }
-
-            return false;
+            return s != null && s.equalsIgnoreCase(hostName);
         }
     }
-
-    private static SSLContext createSSLContext() {
-        try {
-            InputStream keyStoreStream = HostnameVerifierTest.class.getResourceAsStream("ssltest-cacerts.jks");
-            char[] keyStorePassword = "changeit".toCharArray();
-            KeyStore ks = KeyStore.getInstance("JKS");
-            ks.load(keyStoreStream, keyStorePassword);
-
-            // Set up key manager factory to use our key store
-            char[] certificatePassword = "changeit".toCharArray();
-            KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
-            kmf.init(ks, certificatePassword);
-
-            // Initialize the SSLContext to work with our key managers.
-            KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
-            SecureRandom secureRandom = new SecureRandom();
-
-            SSLContext sslContext = SSLContext.getInstance("TLS");
-            sslContext.init(keyManagers, trustManagers, secureRandom);
-
-            return sslContext;
-        } catch (Exception e) {
-            throw new Error("Failed to initialize the server-side SSLContext", e);
-        }
-    }
-
-    private static final AtomicBoolean TRUST_SERVER_CERT = new AtomicBoolean(true);
-    private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager() {
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
-
-        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-        }
-
-        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            if (!TRUST_SERVER_CERT.get()) {
-                throw new CertificateException("Server certificate not trusted.");
-            }
-        }
-    };
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java b/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
index 45fa83842..f186cbb3d 100644
--- a/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
@@ -15,45 +15,44 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.async.util.TestUtils.addHttpsConnector;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.server.ssl.SslSocketConnector;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.File;
+
 import java.io.IOException;
-import java.net.URI;
-import java.net.URL;
 import java.util.Enumeration;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class HttpToHttpsRedirectTest extends AbstractBasicTest {
-    private final AtomicBoolean isSet = new AtomicBoolean(false);
+
+    private final AtomicBoolean redirectDone = new AtomicBoolean(false);
 
     private class Relative302Handler extends AbstractHandler {
 
         public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
-            httpResponse.setContentType("text/html; charset=utf-8");
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             Enumeration<?> e = httpRequest.getHeaderNames();
             while (e.hasMoreElements()) {
                 param = e.nextElement().toString();
 
-                if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
+                if (param.startsWith("X-redirect") && !redirectDone.getAndSet(true)) {
                     httpResponse.addHeader("Location", httpRequest.getHeader(param));
                     httpResponse.setStatus(302);
                     httpResponse.getOutputStream().flush();
@@ -64,7 +63,7 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
 
             if (r.getScheme().equalsIgnoreCase("https")) {
                 httpResponse.addHeader("X-httpToHttps", "PASS");
-                isSet.getAndSet(false);
+                redirectDone.getAndSet(false);
             }
 
             httpResponse.setStatus(200);
@@ -75,69 +74,33 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
         port2 = findFreePort();
 
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-        server.addConnector(listener);
-
-        SslSocketConnector connector = new SslSocketConnector();
-        connector.setHost("127.0.0.1");
-        connector.setPort(port2);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL cacertsUrl = cl.getResource("ssltest-cacerts.jks");
-        String trustStoreFile = new File(cacertsUrl.toURI()).getAbsolutePath();
-        connector.setTruststore(trustStoreFile);
-        connector.setTrustPassword("changeit");
-        connector.setTruststoreType("JKS");
-
-        log.info("SSL certs path: {}", trustStoreFile);
-
-        // override system properties
-        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
-        connector.setKeystore(keyStoreFile);
-        connector.setKeyPassword("changeit");
-        connector.setKeystoreType("JKS");
-
-        log.info("SSL keystore path: {}", keyStoreFile);
-
-        server.addConnector(connector);
-
+        server = newJettyHttpServer(port1);
+        addHttpsConnector(server, port2);
         server.setHandler(new Relative302Handler());
         server.start();
-        log.info("Local HTTP server started successfully");
-    }
-
-    private String getBaseUrl(URI uri) {
-        String url = uri.toString();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url = url.substring(0, url.length() - 1) + ":" + port;
-        }
-        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+        logger.info("Local HTTP server started successfully");
     }
 
-    private static int getPort(URI uri) {
-        int port = uri.getPort();
-        if (port == -1)
-            port = uri.getScheme().equals("http") ? 80 : 443;
-        return port;
+    @Test(groups = { "standalone", "default_provider" })
+    // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
+    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        httpToHttpsRedirect();
+        httpToHttpsProperConfig();
+        relativeLocationUrl();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void httpToHttpsRedirect() throws Throwable {
-        isSet.getAndSet(false);
+    // @Test(groups = { "standalone", "default_provider" })
+    public void httpToHttpsRedirect() throws Exception {
+        redirectDone.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setAcceptAnyCertificate(true)//
+                .build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
@@ -149,15 +112,15 @@ public void httpToHttpsRedirect() throws Throwable {
         }
     }
 
-    public String getTargetUrl2() {
-        return String.format("https://127.0.0.1:%d/foo/test", port2);
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void httpToHttpsProperConfig() throws Throwable {
-        isSet.getAndSet(false);
+    // @Test(groups = { "standalone", "default_provider" })
+    public void httpToHttpsProperConfig() throws Exception {
+        redirectDone.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setAcceptAnyCertificate(true)//
+                .build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
@@ -175,11 +138,15 @@ public void httpToHttpsProperConfig() throws Throwable {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void relativeLocationUrl() throws Throwable {
-        isSet.getAndSet(false);
+    // @Test(groups = { "standalone", "default_provider" })
+    public void relativeLocationUrl() throws Exception {
+        redirectDone.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setAcceptAnyCertificate(true)//
+                .build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
diff --git a/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
index f42b23446..cefa7083a 100644
--- a/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
@@ -15,39 +15,33 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static org.testng.Assert.fail;
 
 public abstract class IdleStateHandlerTest extends AbstractBasicTest {
-    private final AtomicBoolean isSet = new AtomicBoolean(false);
 
     private class IdleStateHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             try {
                 Thread.sleep(20 * 1000);
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             httpResponse.setStatus(200);
@@ -58,24 +52,16 @@ public void handle(String s,
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-        server.addConnector(listener);
-
+        server = newJettyHttpServer(port1);
         server.setHandler(new IdleStateHandler());
         server.start();
-        log.info("Local HTTP server started successfully");
+        logger.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
-    public void idleStateTest() throws Throwable {
-        isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(10 * 1000).build();
+    @Test(groups = { "online", "default_provider" })
+    public void idleStateTest() throws Exception {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(10 * 1000).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
         try {
diff --git a/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java b/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
index 95d28480a..bd5b47284 100644
--- a/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
@@ -15,6 +15,9 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.Response;
@@ -25,24 +28,30 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class InputStreamTest extends AbstractBasicTest {
 
-    private class InputStreamHandler extends AbstractHandler {
+    private static class InputStreamHandler extends AbstractHandler {
         public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
-                byte[] b = new byte[3];
-                request.getInputStream().read(b, 0, 3);
+                byte[] bytes = new byte[3];
+                ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                int read = 0;
+                while (read > -1) {
+                    read = request.getInputStream().read(bytes);
+                    if (read > 0) {
+                        bos.write(bytes, 0, read);
+                    }
+                }
 
                 response.setStatus(HttpServletResponse.SC_OK);
-                response.addHeader("X-Param", new String(b));
+                response.addHeader("X-Param", new String(bos.toByteArray()));
             } else { // this handler is to handle POST request
                 response.sendError(HttpServletResponse.SC_FORBIDDEN);
             }
@@ -51,6 +60,11 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new InputStreamHandler();
+    }
+
     @Test(groups = { "standalone", "default_provider" })
     public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
@@ -80,7 +94,6 @@ public int read() throws IOException {
                     } else {
                         return -1;
                     }
-
                 }
             };
 
@@ -92,9 +105,4 @@ public int read() throws IOException {
             c.close();
         }
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new InputStreamHandler();
-    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java b/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
index 9f9f9ef5f..3109ebf96 100644
--- a/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Response;
@@ -23,12 +25,10 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class ListenableFutureTest extends AbstractBasicTest {
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testListenableFuture() throws Throwable {
+    public void testListenableFuture() throws Exception {
         final AtomicInteger statusCode = new AtomicInteger(500);
         AsyncHttpClient ahc = getAsyncHttpClient(null);
         try {
diff --git a/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java b/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
index 5ac600592..4f626fd3f 100644
--- a/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
+++ b/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
@@ -16,13 +16,16 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
@@ -30,6 +33,7 @@
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.URI;
@@ -37,10 +41,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.testng.AssertJUnit.assertTrue;
-
 abstract public class MaxConnectionsInThreads extends AbstractBasicTest {
 
+    // FIXME weird
     private static URI servletEndpointUri;
 
     @Test(groups = { "online", "default_provider" })
@@ -48,7 +51,8 @@ public void testMaxConnectionsWithinThreads() {
 
         String[] urls = new String[] { servletEndpointUri.toString(), servletEndpointUri.toString() };
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000)
+                .setAllowPoolingConnections(true).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
 
         try {
             final Boolean[] caughtError = new Boolean[] { Boolean.FALSE };
@@ -61,12 +65,9 @@ public void run() {
                             client.prepareGet(url).execute();
                         } catch (IOException e) {
                             // assert that 2nd request fails, because maxTotalConnections=1
-                            // System.out.println(i);
+                            // logger.debug(i);
                             caughtError[0] = true;
-                            System.err.println("============");
-                            e.printStackTrace();
-                            System.err.println("============");
-
+                            logger.error("Exception ", e);
                         }
                     }
                 };
@@ -78,8 +79,7 @@ public void run() {
                 try {
                     t.join();
                 } catch (InterruptedException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
+                    logger.error("Exception ", e);
                 }
             }
 
@@ -91,7 +91,7 @@ public void run() {
                 e1.printStackTrace();
             }
 
-            assertTrue("Max Connections should have been reached", caughtError[0]);
+            assertTrue(caughtError[0], "Max Connections should have been reached");
 
             boolean errorInNotThread = false;
             for (int i = 0; i < urls.length; i++) {
@@ -101,7 +101,7 @@ public void run() {
                     // client.prepareGet(url).execute();
                 } catch (IOException e) {
                     // assert that 2nd request fails, because maxTotalConnections=1
-                    // System.out.println(i);
+                    // logger.debug(i);
                     errorInNotThread = true;
                     System.err.println("============");
                     e.printStackTrace();
@@ -115,7 +115,7 @@ public void run() {
                 // TODO Auto-generated catch block
                 e1.printStackTrace();
             }
-            assertTrue("Max Connections should have been reached", errorInNotThread);
+            assertTrue(errorInNotThread, "Max Connections should have been reached");
         } finally {
             client.close();
         }
@@ -125,28 +125,18 @@ public void run() {
     @BeforeClass
     public void setUpGlobal() throws Exception {
 
-        server = new Server();
-
         port1 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
+        server = newJettyHttpServer(port1);
 
         ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-
         context.setContextPath("/");
         server.setHandler(context);
-
         context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
 
         server.start();
 
         String endpoint = "http://127.0.0.1:" + port1 + "/timeout/";
         servletEndpointUri = new URI(endpoint);
-
     }
 
     public String getTargetUrl() {
@@ -161,6 +151,7 @@ public String getTargetUrl() {
 
     @SuppressWarnings("serial")
     public static class MockTimeoutHttpServlet extends HttpServlet {
+        private static final Logger LOGGER = LoggerFactory.getLogger(MockTimeoutHttpServlet.class);
         private static final String contentType = "text/plain";
         public static long DEFAULT_TIMEOUT = 2000;
 
@@ -176,15 +167,13 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
             }
 
             try {
-                System.out.println("=======================================");
-                System.out.println("Servlet is sleeping for: " + sleepTime);
-                System.out.println("=======================================");
-                System.out.flush();
+                LOGGER.debug("=======================================");
+                LOGGER.debug("Servlet is sleeping for: " + sleepTime);
+                LOGGER.debug("=======================================");
                 Thread.sleep(sleepTime);
-                System.out.println("=======================================");
-                System.out.println("Servlet is awake for");
-                System.out.println("=======================================");
-                System.out.flush();
+                LOGGER.debug("=======================================");
+                LOGGER.debug("Servlet is awake for");
+                LOGGER.debug("=======================================");
             } catch (Exception e) {
 
             }
diff --git a/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java b/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
index 947d36c55..d12b98c61 100644
--- a/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
@@ -15,12 +15,15 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
@@ -36,7 +39,7 @@
     public void testMaxTotalConnectionsExceedingException() {
         String[] urls = new String[] { "http://google.com", "http://github.com/" };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
         try {
             boolean caughtError = false;
             for (int i = 0; i < urls.length; i++) {
@@ -44,11 +47,11 @@ public void testMaxTotalConnectionsExceedingException() {
                     client.prepareGet(urls[i]).execute();
                 } catch (IOException e) {
                     // assert that 2nd request fails, because maxTotalConnections=1
-                    Assert.assertEquals(1, i);
+                    assertEquals(i, 1);
                     caughtError = true;
                 }
             }
-            Assert.assertTrue(caughtError);
+            assertTrue(caughtError);
         } finally {
             client.close();
         }
@@ -58,13 +61,13 @@ public void testMaxTotalConnectionsExceedingException() {
     public void testMaxTotalConnections() {
         String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(2).setMaximumConnectionsPerHost(1).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(2).setMaxConnectionsPerHost(1).build());
         try {
             for (String url : urls) {
                 try {
                     client.prepareGet(url).execute();
                 } catch (IOException e) {
-                    Assert.fail("Smth wrong with connections handling!");
+                    fail("Smth wrong with connections handling!");
                 }
             }
         } finally {
@@ -79,7 +82,7 @@ public void testMaxTotalConnections() {
     public void testMaxTotalConnectionsCorrectExceptionHandling() {
         String[] urls = new String[] { "http://google.com", "http://github.com/" };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
         try {
             List<Future<Response>> futures = new ArrayList<Future<Response>>();
             boolean caughtError = false;
@@ -91,11 +94,11 @@ public void testMaxTotalConnectionsCorrectExceptionHandling() {
                     }
                 } catch (IOException e) {
                     // assert that 2nd request fails, because maxTotalConnections=1
-                    Assert.assertEquals(i, 1);
+                    assertEquals(i, 1);
                     caughtError = true;
                 }
             }
-            Assert.assertTrue(caughtError);
+            assertTrue(caughtError);
 
             // get results of executed requests
             for (Future<Response> future : futures) {
@@ -115,11 +118,11 @@ public void testMaxTotalConnectionsCorrectExceptionHandling() {
                     client.prepareGet(urls[i]).execute();
                 } catch (IOException e) {
                     // assert that 2nd request fails, because maxTotalConnections=1
-                    Assert.assertEquals(i, 1);
+                    assertEquals(i, 1);
                     caughtError = true;
                 }
             }
-            Assert.assertTrue(caughtError);
+            assertTrue(caughtError);
         } finally {
             client.close();
         }
diff --git a/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java b/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
index 2b7cc355b..ad063a978 100644
--- a/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
@@ -12,15 +12,14 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ByteArrayPart;
-import org.asynchttpclient.FilePart;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.StringPart;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.getClasspathFile;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.apache.commons.fileupload.FileItemIterator;
 import org.apache.commons.fileupload.FileItemStream;
 import org.apache.commons.fileupload.FileUploadException;
@@ -28,12 +27,20 @@
 import org.apache.commons.fileupload.util.Streams;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.multipart.ByteArrayPart;
+import org.asynchttpclient.multipart.FilePart;
+import org.asynchttpclient.multipart.StringPart;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.AfterClass;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
@@ -41,6 +48,7 @@
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
@@ -50,86 +58,36 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.Writer;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
 import java.util.zip.GZIPInputStream;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
 /**
  * @author dominict
  */
 public abstract class MultipartUploadTest extends AbstractBasicTest {
-    private String servletEndpointRedirectUrl;
-    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48, 58, 54, 6, 0, 0, 0 };
+    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48,
+            58, 54, 6, 0, 0, 0 };
 
     @BeforeClass
     public void setUp() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
 
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("localhost");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
+        server = newJettyHttpServer(port1);
 
         ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-        context.setContextPath("/");
         context.addServlet(new ServletHolder(new MockMultipartUploadServlet()), "/upload/*");
 
         server.setHandler(context);
         server.start();
-
-        servletEndpointRedirectUrl = "http://localhost" + ":" + port1;
-    }
-
-    @AfterClass
-    public void stop() {
-        try {
-
-            if (server != null) {
-                server.stop();
-            }
-
-        } catch (Exception e) {
-            System.err.print("Error stopping servlet tester");
-            e.printStackTrace();
-        }
-
-    }
-
-    private File getClasspathFile(String file) throws FileNotFoundException {
-        ClassLoader cl = null;
-        try {
-            cl = Thread.currentThread().getContextClassLoader();
-        } catch (Throwable ex) {
-        }
-        if (cl == null) {
-            cl = MultipartUploadTest.class.getClassLoader();
-        }
-        URL resourceUrl = cl.getResource(file);
-
-        try {
-            return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
-        } catch (URISyntaxException e) {
-            throw new FileNotFoundException(file);
-        }
     }
 
     /**
      * Tests that the streaming of a file works.
      */
-    @Test(enabled = true)
+    @Test
     public void testSendingSmallFilesAndByteArray() {
         String expectedContents = "filecontent: hello";
         String expectedContents2 = "gzipcontent: hello";
@@ -183,7 +141,7 @@ public void testSendingSmallFilesAndByteArray() {
         try {
             tmpFile = File.createTempFile("textbytearray", ".txt");
             os = new FileOutputStream(tmpFile);
-            IOUtils.write(expectedContents.getBytes("UTF-8"), os);
+            IOUtils.write(expectedContents.getBytes(StandardCharsets.UTF_8), os);
             tmpFileCreated = true;
 
             testFiles.add(tmpFile);
@@ -208,30 +166,30 @@ public void testSendingSmallFilesAndByteArray() {
 
         AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
 
-        bc.setFollowRedirects(true);
+        bc.setFollowRedirect(true);
 
-        AsyncHttpClient c = new AsyncHttpClient(bc.build());
+        AsyncHttpClient c = getAsyncHttpClient(bc.build());
 
         try {
 
             RequestBuilder builder = new RequestBuilder("POST");
-            builder.setUrl(servletEndpointRedirectUrl + "/upload/bob");
-            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", "UTF-8"));
+            builder.setUrl("http://localhost" + ":" + port1 + "/upload/bob");
+            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", StandardCharsets.UTF_8));
             builder.addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null));
-            builder.addBodyPart(new StringPart("Name", "Dominic"));
-            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", "UTF-8"));
+            builder.addBodyPart(new StringPart("Name", "Dominic", StandardCharsets.UTF_8));
+            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", StandardCharsets.UTF_8));
 
             builder.addBodyPart(new StringPart("Age", "3", AsyncHttpProviderUtils.DEFAULT_CHARSET));
             builder.addBodyPart(new StringPart("Height", "shrimplike", AsyncHttpProviderUtils.DEFAULT_CHARSET));
             builder.addBodyPart(new StringPart("Hair", "ridiculous", AsyncHttpProviderUtils.DEFAULT_CHARSET));
 
-            builder.addBodyPart(new ByteArrayPart("file4", "bytearray.txt", expectedContents.getBytes("UTF-8"), "text/plain", "UTF-8"));
+            builder.addBodyPart(new ByteArrayPart("file4", expectedContents.getBytes(StandardCharsets.UTF_8), "text/plain", StandardCharsets.UTF_8, "bytearray.txt"));
 
             Request r = builder.build();
 
             Response res = c.executeRequest(r).get();
 
-            assertEquals(200, res.getStatusCode());
+            assertEquals(res.getStatusCode(), 200);
 
             testSentFile(expected, testFiles, res, gzipped);
 
@@ -258,14 +216,14 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
         try {
             content = r.getResponseBody();
             assertNotNull("===>" + content);
-            System.out.println(content);
+            logger.debug(content);
         } catch (IOException e) {
             fail("Unable to obtain content");
         }
 
         String[] contentArray = content.split("\\|\\|");
         // TODO: this fail on win32
-        assertEquals(2, contentArray.length);
+        assertEquals(contentArray.length, 2);
 
         String tmpFiles = contentArray[1];
         assertNotNull(tmpFiles);
@@ -274,10 +232,9 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
 
         String[] responseFiles = tmpFiles.split(",");
         assertNotNull(responseFiles);
-        assertEquals(sourceFiles.size(), responseFiles.length);
+        assertEquals(responseFiles.length, sourceFiles.size());
 
-        System.out.println(Arrays.toString(responseFiles));
-        // assertTrue("File should exist: " + tmpFile.getAbsolutePath(),tmpFile.exists());
+        logger.debug(Arrays.toString(responseFiles));
 
         int i = 0;
         for (File sourceFile : sourceFiles) {
@@ -295,10 +252,10 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                     while ((len = instream.read(buf)) > 0) {
                         baos.write(buf, 0, len);
                     }
-                    System.out.println("================");
-                    System.out.println("Length of file: " + baos.toByteArray().length);
-                    System.out.println("Contents: " + Arrays.toString(baos.toByteArray()));
-                    System.out.println("================");
+                    logger.debug("================");
+                    logger.debug("Length of file: " + baos.toByteArray().length);
+                    logger.debug("Contents: " + Arrays.toString(baos.toByteArray()));
+                    logger.debug("================");
                     System.out.flush();
                     sourceBytes = baos.toByteArray();
                 } finally {
@@ -306,9 +263,9 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 }
 
                 tmp = new File(responseFiles[i].trim());
-                System.out.println("==============================");
-                System.out.println(tmp.getAbsolutePath());
-                System.out.println("==============================");
+                logger.debug("==============================");
+                logger.debug(tmp.getAbsolutePath());
+                logger.debug("==============================");
                 System.out.flush();
                 assertTrue(tmp.exists());
 
@@ -321,21 +278,25 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 }
                 IOUtils.closeQuietly(instream);
 
-                assertEquals(sourceBytes, baos2.toByteArray());
+                assertEquals(baos2.toByteArray(), sourceBytes);
 
                 if (!deflate.get(i)) {
 
                     String helloString = new String(baos2.toByteArray());
-                    assertEquals(expectedContents.get(i), helloString);
+                    assertEquals(helloString, expectedContents.get(i));
                 } else {
                     instream = new FileInputStream(tmp);
 
-                    GZIPInputStream deflater = new GZIPInputStream(instream);
                     ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
-                    byte[] buf3 = new byte[8092];
-                    int len3 = 0;
-                    while ((len3 = deflater.read(buf3)) > 0) {
-                        baos3.write(buf3, 0, len3);
+                    GZIPInputStream deflater = new GZIPInputStream(instream);
+                    try {
+                        byte[] buf3 = new byte[8092];
+                        int len3 = 0;
+                        while ((len3 = deflater.read(buf3)) > 0) {
+                            baos3.write(buf3, 0, len3);
+                        }
+                    } finally {
+                        deflater.close();
                     }
 
                     String helloString = new String(baos3.toByteArray());
@@ -361,9 +322,9 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
      * @author dominict
      */
     public static class MockMultipartUploadServlet extends HttpServlet {
-        /**
-         *
-         */
+
+        private static final Logger LOGGER = LoggerFactory.getLogger(MockMultipartUploadServlet.class);
+
         private static final long serialVersionUID = 1L;
         private int filesProcessed = 0;
         private int stringsProcessed = 0;
@@ -417,10 +378,10 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
                             stream = item.openStream();
 
                             if (item.isFormField()) {
-                                System.out.println("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
+                                LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
                                 incrementStringsProcessed();
                             } else {
-                                System.out.println("File field " + name + " with file name " + item.getName() + " detected.");
+                                LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
                                 // Process the input stream
                                 OutputStream os = null;
                                 try {
@@ -446,23 +407,27 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
 
                 }
                 Writer w = response.getWriter();
-                w.write(Integer.toString(getFilesProcessed()));
-                resetFilesProcessed();
-                resetStringsProcessed();
-                w.write("||");
-                w.write(files.toString());
-                w.close();
+                try {
+                    w.write(Integer.toString(getFilesProcessed()));
+                    resetFilesProcessed();
+                    resetStringsProcessed();
+                    w.write("||");
+                    w.write(files.toString());
+                } finally {
+                    // FIXME
+                    w.close();
+                }
             } else {
                 Writer w = response.getWriter();
-                w.write(Integer.toString(getFilesProcessed()));
-                resetFilesProcessed();
-                resetStringsProcessed();
-                w.write("||");
-                w.close();
+                try {
+                    w.write(Integer.toString(getFilesProcessed()));
+                    resetFilesProcessed();
+                    resetStringsProcessed();
+                    w.write("||");
+                } finally {
+                    w.close();
+                }
             }
-
         }
-
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java b/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
index 2ea4d395a..d7c1d99ac 100644
--- a/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
@@ -12,6 +12,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -19,7 +24,6 @@
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.testng.Assert;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
@@ -48,6 +52,49 @@
     private ServerSocket serverSocket;
     private Future<?> voidFuture;
 
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        port1 = findFreePort();
+
+        serverSocket = new ServerSocket(port1);
+        executorService = Executors.newFixedThreadPool(1);
+        voidFuture = executorService.submit(new Callable<Void>() {
+            public Void call() throws Exception {
+                Socket socket;
+                while ((socket = serverSocket.accept()) != null) {
+                    InputStream inputStream = socket.getInputStream();
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+                    String req = reader.readLine().split(" ")[1];
+                    int i = inputStream.available();
+                    long l = inputStream.skip(i);
+                    assertEquals(l, i);
+                    socket.shutdownInput();
+                    if (req.endsWith("MultiEnt")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n"
+                                + "Content-Length: 1\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    } else if (req.endsWith("MultiOther")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n"
+                                + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    }
+                }
+                return null;
+            }
+        });
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        voidFuture.cancel(true);
+        executorService.shutdownNow();
+        serverSocket.close();
+    }
+
     @Test(groups = { "standalone", "default_provider" })
     public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         final String[] xffHeaders = new String[] { null, null };
@@ -84,16 +131,16 @@ public Void onCompleted() throws Exception {
             }).get(3, TimeUnit.SECONDS);
 
             if (!latch.await(2, TimeUnit.SECONDS)) {
-                Assert.fail("Time out");
+                fail("Time out");
             }
-            Assert.assertNotNull(xffHeaders[0]);
-            Assert.assertNotNull(xffHeaders[1]);
+            assertNotNull(xffHeaders[0]);
+            assertNotNull(xffHeaders[1]);
             try {
-                Assert.assertEquals(xffHeaders[0], "abc");
-                Assert.assertEquals(xffHeaders[1], "def");
+                assertEquals(xffHeaders[0], "abc");
+                assertEquals(xffHeaders[1], "def");
             } catch (AssertionError ex) {
-                Assert.assertEquals(xffHeaders[1], "abc");
-                Assert.assertEquals(xffHeaders[0], "def");
+                assertEquals(xffHeaders[1], "abc");
+                assertEquals(xffHeaders[0], "def");
             }
         } finally {
             ahc.close();
@@ -139,62 +186,21 @@ public Void onCompleted() throws Exception {
             }).get(3, TimeUnit.SECONDS);
 
             if (!latch.await(2, TimeUnit.SECONDS)) {
-                Assert.fail("Time out");
+                fail("Time out");
             }
-            Assert.assertNotNull(clHeaders[0]);
-            Assert.assertNotNull(clHeaders[1]);
+            assertNotNull(clHeaders[0]);
+            assertNotNull(clHeaders[1]);
 
             // We can predict the order
             try {
-                Assert.assertEquals(clHeaders[0], "2");
-                Assert.assertEquals(clHeaders[1], "1");
+                assertEquals(clHeaders[0], "2");
+                assertEquals(clHeaders[1], "1");
             } catch (Throwable ex) {
-                Assert.assertEquals(clHeaders[0], "1");
-                Assert.assertEquals(clHeaders[1], "2");
+                assertEquals(clHeaders[0], "1");
+                assertEquals(clHeaders[1], "2");
             }
         } finally {
             ahc.close();
         }
     }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        port1 = findFreePort();
-
-        serverSocket = new ServerSocket(port1);
-        executorService = Executors.newFixedThreadPool(1);
-        voidFuture = executorService.submit(new Callable<Void>() {
-            public Void call() throws Exception {
-                Socket socket;
-                while ((socket = serverSocket.accept()) != null) {
-                    InputStream inputStream = socket.getInputStream();
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-                    String req = reader.readLine().split(" ")[1];
-                    int i = inputStream.available();
-                    long l = inputStream.skip(i);
-                    Assert.assertEquals(l, i);
-                    socket.shutdownInput();
-                    if (req.endsWith("MultiEnt")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n" + "Content-Length: 1\n" + "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    } else if (req.endsWith("MultiOther")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n" + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    }
-                }
-                return null;
-            }
-        });
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        voidFuture.cancel(true);
-        executorService.shutdownNow();
-        serverSocket.close();
-    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java b/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
index 779373891..a83cd979f 100644
--- a/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
@@ -16,16 +16,18 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+
 import java.security.GeneralSecurityException;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
@@ -34,28 +36,28 @@
     private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
 
     @Test(invocationCount = 4, groups = { "online", "default_provider" })
-    public void multipleSslRequestsWithDelayAndKeepAlive() throws Throwable {
+    public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
         final AsyncHttpClient client = create();
         try {
             final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
             final Response response1 = builder.execute().get();
-            Thread.sleep(5000);
+            Thread.sleep(4000);
             final Response response2 = builder.execute().get();
             if (response2 != null) {
                 System.out.println("Success (2nd response was not null).");
             } else {
                 System.out.println("Failed (2nd response was null).");
             }
-            Assert.assertNotNull(response1);
-            Assert.assertNotNull(response2);
+            assertNotNull(response1);
+            assertNotNull(response2);
         } finally {
             client.close();
         }
     }
 
     private AsyncHttpClient create() throws GeneralSecurityException {
-        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setFollowRedirects(true).setSSLContext(getSSLContext()).setAllowPoolingConnection(true).setConnectionTimeoutInMs(10000)
-                .setIdleConnectionInPoolTimeoutInMs(60000).setRequestTimeoutInMs(10000).setMaximumConnectionsPerHost(-1).setMaximumConnectionsTotal(-1);
+        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setSSLContext(getSSLContext()).setAllowPoolingConnections(true).setConnectionTimeout(10000)
+                .setPooledConnectionIdleTimeout(60000).setRequestTimeout(10000).setMaxConnectionsPerHost(-1).setMaxConnections(-1);
         return getAsyncHttpClient(configBuilder.build());
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java b/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
index 924a9c90f..b47b52394 100644
--- a/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
@@ -12,14 +12,17 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
@@ -27,22 +30,17 @@
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class NonAsciiContentLengthTest extends AbstractBasicTest {
 
-    public void setUpServer() throws Exception {
-        server = new Server();
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
         port1 = findFreePort();
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-        server.addConnector(listener);
+        server = newJettyHttpServer(port1);
         server.setHandler(new AbstractHandler() {
 
             public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
@@ -75,7 +73,6 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNonAsciiContentLength() throws Exception {
-        setUpServer();
         execute("test");
         execute("\u4E00"); // Unicode CJK ideograph for one
     }
@@ -83,14 +80,13 @@ public void testNonAsciiContentLength() throws Exception {
     protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding("UTF-8");
+            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding(StandardCharsets.UTF_8.name());
             Future<Response> f = r.execute();
             Response resp = f.get();
             assertEquals(resp.getStatusCode(), 200);
-            assertEquals(body, resp.getResponseBody("UTF-8"));
+            assertEquals(body, resp.getResponseBody(StandardCharsets.UTF_8.name()));
         } finally {
             client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java b/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
index 6fcf4f8c0..4b5027f9a 100644
--- a/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
@@ -15,6 +15,10 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
@@ -24,16 +28,13 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public abstract class ParamEncodingTest extends AbstractBasicTest {
 
     private class ParamEncoding extends AbstractHandler {
@@ -60,7 +61,7 @@ public void testParameters() throws IOException, ExecutionException, TimeoutExce
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addParameter("test", value).execute();
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addFormParam("test", value).execute();
             Response resp = f.get(10, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
diff --git a/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java b/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
index 6ca782abe..8b34bd40f 100644
--- a/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
@@ -15,32 +15,34 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.ConnectException;
-import java.net.URI;
 import java.util.Enumeration;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public abstract class PerRequestRelative302Test extends AbstractBasicTest {
+
     private final AtomicBoolean isSet = new AtomicBoolean(false);
 
     private class Relative302Handler extends AbstractHandler {
@@ -48,7 +50,7 @@
         public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
-            httpResponse.setContentType("text/html; charset=utf-8");
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             Enumeration<?> e = httpRequest.getHeaderNames();
             while (e.hasMoreElements()) {
                 param = e.nextElement().toString();
@@ -69,28 +71,30 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
         port2 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-        server.addConnector(listener);
+        server = newJettyHttpServer(port1);
 
         server.setHandler(new Relative302Handler());
         server.start();
-        log.info("Local HTTP server started successfully");
+        logger.info("Local HTTP server started successfully");
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void redirected302Test() throws Throwable {
+    // FIXME threadsafe
+    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        redirected302Test();
+        notRedirected302Test();
+        relativeLocationUrl();
+        redirected302InvalidTest();
+    }
+
+    // @Test(groups = { "online", "default_provider" })
+    public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -104,13 +108,13 @@ public void redirected302Test() throws Throwable {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
-    public void notRedirected302Test() throws Throwable {
+    // @Test(groups = { "online", "default_provider" })
+    public void notRedirected302Test() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
-            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
@@ -119,7 +123,7 @@ public void notRedirected302Test() throws Throwable {
         }
     }
 
-    private String getBaseUrl(URI uri) {
+    private String getBaseUrl(Uri uri) {
         String url = uri.toString();
         int port = uri.getPort();
         if (port == -1) {
@@ -129,20 +133,20 @@ private String getBaseUrl(URI uri) {
         return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
     }
 
-    private static int getPort(URI uri) {
+    private static int getPort(Uri uri) {
         int port = uri.getPort();
         if (port == -1)
             port = uri.getScheme().equals("http") ? 80 : 443;
         return port;
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void redirected302InvalidTest() throws Throwable {
+    // @Test(groups = { "standalone", "default_provider" })
+    public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
@@ -153,13 +157,13 @@ public void redirected302InvalidTest() throws Throwable {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void relativeLocationUrl() throws Throwable {
+    // @Test(groups = { "standalone", "default_provider" })
+    public void relativeLocationUrl() throws Exception {
         isSet.getAndSet(false);
 
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "/foo/test").execute().get();
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
             assertEquals(response.getUri().toString(), getTargetUrl());
diff --git a/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java b/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
index c98749bb4..9063a8f87 100644
--- a/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
@@ -15,7 +15,13 @@
  */
 package org.asynchttpclient.async;
 
-import static org.asynchttpclient.util.DateUtil.millisTime;
+import static org.asynchttpclient.util.DateUtils.millisTime;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -30,18 +36,13 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
 /**
  * Per request timeout configuration test.
  * 
@@ -69,9 +70,9 @@ public void run() {
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
                     } catch (InterruptedException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     } catch (IOException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     }
                 }
             }).start();
@@ -83,9 +84,9 @@ public void run() {
                         response.getOutputStream().flush();
                         continuation.complete();
                     } catch (InterruptedException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     } catch (IOException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     }
                 }
             }).start();
@@ -114,7 +115,7 @@ public void testRequestTimeout() throws IOException {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build());
         try {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(-1).execute();
             Response response = responseFuture.get();
@@ -131,7 +132,7 @@ public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testGlobalRequestTimeout() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build());
         try {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
@@ -152,7 +153,7 @@ public void testGlobalRequestTimeout() throws IOException {
     public void testGlobalIdleTimeout() throws IOException {
         final long times[] = new long[] { -1, -1 };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).build());
         try {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
                 @Override
@@ -178,7 +179,7 @@ public void onThrowable(Throwable t) {
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
-            log.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
+            logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
             fail("Timeouted on idle.", e);
         } finally {
             client.close();
diff --git a/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java b/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
index e741a6240..306db3efe 100644
--- a/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
@@ -13,6 +13,9 @@
 
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -23,12 +26,12 @@
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -72,7 +75,7 @@ public void postRedirectGet307Test() throws Exception {
     // --------------------------------------------------------- Private Methods
 
     private void doTestNegative(final int status, boolean strict) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -84,7 +87,7 @@ private void doTestNegative(final int status, boolean strict) throws Exception {
             }
         }).build());
         try {
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
                 @Override
@@ -92,22 +95,22 @@ public Integer onCompleted(Response response) throws Exception {
                     return response.getStatusCode();
                 }
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                    fail("Unexpected exception: " + t.getMessage(), t);
                 }
 
             });
             int statusCode = responseFuture.get();
-            Assert.assertEquals(statusCode, 200);
+            assertEquals(statusCode, 200);
         } finally {
             p.close();
         }
     }
 
     private void doTestPositive(final int status) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).addResponseFilter(new ResponseFilter() {
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).addResponseFilter(new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -119,7 +122,7 @@ private void doTestPositive(final int status) throws Exception {
             }
         }).build());
         try {
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
                 @Override
@@ -127,15 +130,15 @@ public Integer onCompleted(Response response) throws Exception {
                     return response.getStatusCode();
                 }
 
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                    fail("Unexpected exception: " + t.getMessage(), t);
                 }
 
             });
             int statusCode = responseFuture.get();
-            Assert.assertEquals(statusCode, 200);
+            assertEquals(statusCode, 200);
         } finally {
             p.close();
         }
@@ -147,7 +150,7 @@ public void onThrowable(Throwable t) {
 
         final AtomicInteger counter = new AtomicInteger();
 
-        /* @Override */
+        @Override
         public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
diff --git a/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java b/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
index 442f38908..f5bb67215 100644
--- a/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
@@ -15,6 +15,10 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseStatus;
@@ -28,16 +32,13 @@
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Tests POST request with Query String.
  * 
@@ -89,10 +90,10 @@ public void postWithNulParamQS() throws IOException, ExecutionException, Timeout
         try {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
-                /* @Override */
+                @Override
                 public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=")) {
-                        throw new IOException(status.getUrl().toURL().toString());
+                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=")) {
+                        throw new IOException(status.getUri().toUrl());
                     }
                     return super.onStatusReceived(status);
                 }
@@ -112,9 +113,9 @@ public void postWithNulParamsQS() throws IOException, ExecutionException, Timeou
         try {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
-                /* @Override */
+                @Override
                 public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
@@ -135,9 +136,9 @@ public void postWithEmptyParamsQS() throws IOException, ExecutionException, Time
         try {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
-                /* @Override */
+                @Override
                 public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
diff --git a/api/src/test/java/org/asynchttpclient/async/ProxyTest.java b/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
index 94ee870f8..3e5220d69 100644
--- a/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
@@ -15,29 +15,38 @@
  */
 package org.asynchttpclient.async;
 
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import java.io.IOException;
 import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.Arrays;
+import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
 /**
  * Proxy usage tests.
  * 
@@ -49,7 +58,8 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 response.addHeader("target", r.getUri().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
-            } else { // this handler is to handle POST request
+            } else {
+                // this handler is to handle POST request
                 response.sendError(HttpServletResponse.SC_FORBIDDEN);
             }
             r.setHandled(true);
@@ -141,12 +151,22 @@ public void testNonProxyHostIssue202() throws IOException, ExecutionException, T
     }
 
     @Test(groups = { "standalone", "default_provider" })
+    public void runSequentiallyBecauseNotThreadSafe() throws Exception {
+        testProxyProperties();
+        testIgnoreProxyPropertiesByDefault();
+        testProxyActivationProperty();
+        testWildcardNonProxyHosts();
+        testUseProxySelector();
+    }
+
+    // @Test(groups = { "standalone", "default_provider" })
     public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
         try {
             Properties props = new Properties();
             props.putAll(originalProps);
 
+            // FIXME most likely non threadsafe!
             System.setProperties(props);
 
             System.setProperty("http.proxyHost", "127.0.0.1");
@@ -179,13 +199,14 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = { "standalone", "default_provider" })
     public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
         try {
             Properties props = new Properties();
             props.putAll(originalProps);
 
+            // FIXME not threadsafe!
             System.setProperties(props);
 
             System.setProperty("http.proxyHost", "127.0.0.1");
@@ -210,13 +231,14 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = { "standalone", "default_provider" })
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
         try {
             Properties props = new Properties();
             props.putAll(originalProps);
 
+            // FIXME not threadsafe!
             System.setProperties(props);
 
             System.setProperty("http.proxyHost", "127.0.0.1");
@@ -249,4 +271,80 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
         }
     }
 
+    // @Test(groups = { "standalone", "default_provider" })
+    public void testWildcardNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        Properties originalProps = System.getProperties();
+        try {
+            Properties props = new Properties();
+            props.putAll(originalProps);
+
+            // FIXME not threadsafe!
+            System.setProperties(props);
+
+            System.setProperty("http.proxyHost", "127.0.0.1");
+            System.setProperty("http.proxyPort", String.valueOf(port1));
+            System.setProperty("http.nonProxyHosts", "127.*");
+
+            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
+            AsyncHttpClient client = getAsyncHttpClient(cfg);
+            try {
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                try {
+                    f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+            } finally {
+                client.close();
+            }
+        } finally {
+            System.setProperties(originalProps);
+        }
+    }
+
+    // @Test(groups = { "standalone", "default_provider" })
+    public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        ProxySelector originalProxySelector = ProxySelector.getDefault();
+        try {
+            ProxySelector.setDefault(new ProxySelector() {
+                public List<Proxy> select(URI uri) {
+                    if (uri.getHost().equals("127.0.0.1")) {
+                        return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", port1)));
+                    } else {
+                        return Arrays.asList(Proxy.NO_PROXY);
+                    }
+                }
+
+                public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+                }
+            });
+
+            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxySelector(true).build();
+            AsyncHttpClient client = getAsyncHttpClient(cfg);
+            try {
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                Response resp = f.get(3, TimeUnit.SECONDS);
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getHeader("target"), "/");
+
+                target = "http://localhost:1234/";
+                f = client.prepareGet(target).execute();
+                try {
+                    f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+            } finally {
+                client.close();
+            }
+        } finally {
+            // FIXME not threadsafe
+            ProxySelector.setDefault(originalProxySelector);
+        }
+    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java b/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
index 61a2bc551..203f52a26 100644
--- a/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
@@ -12,6 +12,11 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -19,81 +24,64 @@
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.eclipse.jetty.server.Connector;
+import org.asynchttpclient.async.util.EchoHandler;
+import org.eclipse.jetty.proxy.ConnectHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.handler.ProxyHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.server.ssl.SslSocketConnector;
+import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import java.io.File;
 import java.io.IOException;
-import java.net.URL;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 
-import static org.testng.Assert.assertEquals;
-
 /**
  * Proxy usage tests.
  */
-@SuppressWarnings("deprecation")
 public abstract class ProxyTunnellingTest extends AbstractBasicTest {
 
     private Server server2;
 
+    public abstract String getProviderClass();
+
     public AbstractHandler configureHandler() throws Exception {
-        ProxyHandler proxy = new ProxyHandler();
-        return proxy;
+        return new ConnectHandler();
     }
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
-        server = new Server();
-        server2 = new Server();
-
         port1 = findFreePort();
-        port2 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-        SslSocketConnector connector = new SslSocketConnector();
-        connector.setHost("127.0.0.1");
-        connector.setPort(port2);
-
-        ClassLoader cl = getClass().getClassLoader();
-        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
-        connector.setKeystore(keyStoreFile);
-        connector.setKeyPassword("changeit");
-        connector.setKeystoreType("JKS");
-
-        server2.addConnector(connector);
-
+        server = newJettyHttpServer(port1);
         server.setHandler(configureHandler());
         server.start();
 
+        port2 = findFreePort();
+
+        server2 = newJettyHttpsServer(port2);
         server2.setHandler(new EchoHandler());
         server2.start();
-        log.info("Local HTTP server started successfully");
+
+        logger.info("Local HTTP server started successfully");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        server.stop();
+        server2.stop();
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
-        AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
-        b.setFollowRedirects(true);
 
         ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", port1);
 
-        AsyncHttpClientConfig config = b.build();
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+        .setFollowRedirect(true)//
+        .setAcceptAnyCertificate(true)//
+        .build();
+
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
         try {
             RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
@@ -101,7 +89,7 @@ public void testRequestProxy() throws IOException, InterruptedException, Executi
 
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    log.debug(t.getMessage(), t);
+                    logger.debug(t.getMessage(), t);
                 }
 
                 @Override
@@ -111,7 +99,7 @@ public Response onCompleted(Response response) throws Exception {
             });
             Response r = responseFuture.get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+            assertEquals(r.getHeader("X-Connection"), "keep-alive");
         } finally {
             asyncHttpClient.close();
         }
@@ -119,21 +107,18 @@ public Response onCompleted(Response response) throws Exception {
 
     @Test(groups = { "online", "default_provider" })
     public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
-        AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
-        b.setFollowRedirects(true);
-
-        ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", port1);
-        b.setProxyServer(ps);
-
-        AsyncHttpClientConfig config = b.build();
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setFollowRedirect(true)//
+                .setProxyServer(new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", port1))//
+                .setAcceptAnyCertificate(true)//
+                .build();
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
         try {
-            RequestBuilder rb = new RequestBuilder("GET").setUrl(getTargetUrl2());
-            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
+            Future<Response> responseFuture = asyncHttpClient.executeRequest(new RequestBuilder("GET").setUrl(getTargetUrl2()).build(), new AsyncCompletionHandlerBase() {
 
                 public void onThrowable(Throwable t) {
                     t.printStackTrace();
-                    log.debug(t.getMessage(), t);
+                    logger.debug(t.getMessage(), t);
                 }
 
                 @Override
@@ -143,7 +128,7 @@ public Response onCompleted(Response response) throws Exception {
             });
             Response r = responseFuture.get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+            assertEquals(r.getHeader("X-Connection"), "keep-alive");
         } finally {
             asyncHttpClient.close();
         }
@@ -152,12 +137,21 @@ public Response onCompleted(Response response) throws Exception {
     @Test(groups = { "online", "default_provider" })
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProxyProtocol(ProxyServer.Protocol.HTTPS).setProxyHost("127.0.0.1").setProxyPort(port1).setFollowRedirects(true).setUrl(getTargetUrl2()).setHeader("Content-Type", "text/html").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setProviderClass(getProviderClass())//
+                .setProxyProtocol(ProxyServer.Protocol.HTTPS)//
+                .setProxyHost("127.0.0.1")//
+                .setProxyPort(port1)//
+                .setFollowRedirect(true)//
+                .setUrl(getTargetUrl2())//
+                .setAcceptAnyCertificate(true)//
+                .setHeader("Content-Type", "text/html")//
+                .build();
         try {
             Response r = client.get().get();
 
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+            assertEquals(r.getHeader("X-Connection"), "keep-alive");
         } finally {
             client.close();
         }
diff --git a/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java b/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
index bf7d10489..51400e304 100644
--- a/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
@@ -12,47 +12,39 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.util.UUID;
 
 /**
  * @author Benjamin Hanzelmann
  */
 public abstract class PutLargeFileTest extends AbstractBasicTest {
 
-    private File largeFile;
-
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
     public void testPutLargeFile() throws Exception {
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 1024 * 100 / bytes.length) + 1;
-        largeFile = createTempFile(bytes, (int) repeats);
-        int timeout = (int) (largeFile.length() / 1000);
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(timeout).build();
-        AsyncHttpClient client = getAsyncHttpClient(config);
-        try {
-            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-            rb.setBody(largeFile);
+        File file = createTempFile(1024 * 1024);
 
-            Response response = rb.execute().get();
-            Assert.assertEquals(200, response.getStatusCode());
+        int timeout = (int) file.length() / 1000;
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(timeout).build());
+        try {
+            Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
+            assertEquals(response.getStatusCode(), 200);
         } finally {
             client.close();
         }
@@ -60,82 +52,30 @@ public void testPutLargeFile() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testPutSmallFile() throws Exception {
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 / bytes.length) + 1;
-        // int timeout = (5000);
-        largeFile = createTempFile(bytes, (int) repeats);
+
+        File file = createTempFile(1024);
 
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
-
-            rb.setBody(largeFile);
-
-            Response response = rb.execute().get();
-            Assert.assertEquals(200, response.getStatusCode());
+            Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
+            assertEquals(response.getStatusCode(), 200);
         } finally {
             client.close();
         }
     }
 
-    @AfterMethod
-    public void after() {
-        largeFile.delete();
-    }
-
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
             public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
-                ServletInputStream in = req.getInputStream();
-                byte[] b = new byte[8092];
-
-                int count = -1;
-                int total = 0;
-                while ((count = in.read(b)) != -1) {
-                    total += count;
-                }
-
-                System.err.println("consumed " + total + " bytes.");
-
                 resp.setStatus(200);
                 resp.getOutputStream().flush();
                 resp.getOutputStream().close();
 
                 arg1.setHandled(true);
-
             }
         };
     }
-
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
-
-    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
-        TMP.mkdirs();
-        TMP.deleteOnExit();
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
-        tmpFile.deleteOnExit();
-        write(pattern, repeat, tmpFile);
-
-        return tmpFile;
-    }
-
-    public static void write(byte[] pattern, int repeat, File file) throws IOException {
-        file.deleteOnExit();
-        file.getParentFile().mkdirs();
-        FileOutputStream out = null;
-        try {
-            out = new FileOutputStream(file);
-            for (int i = 0; i < repeat; i++) {
-                out.write(pattern);
-            }
-        } finally {
-            if (out != null) {
-                out.close();
-            }
-        }
-    }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java b/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
index 2b6437a88..6bbd6c80a 100644
--- a/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
@@ -15,8 +15,13 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.slf4j.LoggerFactory;
@@ -25,6 +30,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
@@ -33,10 +39,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Testing query parameters support.
  * 
@@ -72,7 +74,7 @@ public AbstractHandler configureHandler() throws Exception {
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParameter("a", "1").addQueryParameter("b", "2").execute();
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -90,10 +92,10 @@ public void testUrlRequestParametersEncoding() throws IOException, ExecutionExce
 
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, StandardCharsets.UTF_8.name());
             LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
             Response response = client.prepareGet(requestUrl2).execute().get();
-            String s = URLDecoder.decode(response.getHeader("q"), "UTF-8");
+            String s = URLDecoder.decode(response.getHeader("q"), StandardCharsets.UTF_8.name());
             assertEquals(s, REQUEST_PARAM);
         } finally {
             client.close();
@@ -101,29 +103,15 @@ public void testUrlRequestParametersEncoding() throws IOException, ExecutionExce
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void urlWithColonTest_Netty() throws Throwable {
+    public void urlWithColonTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             String query = "test:colon:";
             Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
+            assertEquals(response.getHeader("q"), URLEncoder.encode(query, StandardCharsets.UTF_8.name()));
         } finally {
             c.close();
         }
     }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void urlWithColonTest_JDK() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            String query = "test:colon:";
-            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
-        } finally {
-            c.close();
-        }
-    }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RC10KTest.java b/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
index 9b07accd8..e3a199305 100644
--- a/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
@@ -15,17 +15,20 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
@@ -33,6 +36,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -41,9 +45,6 @@
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Reverse C10K Problem test.
  * 
@@ -62,7 +63,7 @@ public void setUpGlobal() throws Exception {
         for (int i = 0; i < SRV_COUNT; i++) {
             ports[i] = createServer();
         }
-        log.info("Local HTTP servers started successfully");
+        logger.info("Local HTTP servers started successfully");
     }
 
     @AfterClass(alwaysRun = true)
@@ -73,12 +74,8 @@ public void tearDownGlobal() throws Exception {
     }
 
     private int createServer() throws Exception {
-        Server srv = new Server();
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("127.0.0.1");
         int port = findFreePort();
-        listener.setPort(port);
-        srv.addConnector(listener);
+        Server srv = newJettyHttpServer(port);
         srv.setHandler(configureHandler());
         srv.start();
         servers.add(srv);
@@ -102,7 +99,7 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaximumConnectionsPerHost(C10K).setAllowPoolingConnection(true).build());
+        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnectionsPerHost(C10K).setAllowPoolingConnections(true).build());
         try {
             List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
             int i = 0;
@@ -129,7 +126,7 @@ public MyAsyncHandler(int i) {
         }
 
         public void onThrowable(Throwable t) {
-            log.warn("onThrowable called.", t);
+            logger.warn("onThrowable called.", t);
         }
 
         public STATE onBodyPartReceived(HttpResponseBodyPart event) throws Exception {
diff --git a/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java b/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
index ee1c0c106..26bfbfc2f 100644
--- a/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
@@ -15,19 +15,19 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
@@ -35,125 +35,71 @@
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Date;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.FileAssert.fail;
-
 /**
- * Test for multithreaded url fetcher calls that use two separate
- * sets of ssl certificates.  This then tests that the certificate
- * settings do not clash (override each other), resulting in the
- * peer not authenticated exception
- *
+ * Test for multithreaded url fetcher calls that use two separate sets of ssl certificates. This then tests that the certificate settings do not clash (override each other),
+ * resulting in the peer not authenticated exception
+ * 
  * @author dominict
  */
-public abstract class RedirectConnectionUsageTest extends AbstractBasicTest{
+public abstract class RedirectConnectionUsageTest extends AbstractBasicTest {
     private String BASE_URL;
 
     private String servletEndpointRedirectUrl;
 
     @BeforeClass
     public void setUp() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("localhost");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
+        server = newJettyHttpServer(port1);
 
         ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-
-        context.setContextPath("/");
-        server.setHandler(context);
-
         context.addServlet(new ServletHolder(new MockRedirectHttpServlet()), "/redirect/*");
         context.addServlet(new ServletHolder(new MockFullResponseHttpServlet()), "/*");
+        server.setHandler(context);
 
         server.start();
 
         BASE_URL = "http://localhost" + ":" + port1;
         servletEndpointRedirectUrl = BASE_URL + "/redirect";
-
-    }
-
-    @AfterClass
-    public void tearDown() {
-        try {
-            if (server != null) {
-                server.stop();
-            }
-
-        } catch (Exception e) {
-            System.err.print("Error stopping servlet tester");
-            e.printStackTrace();
-        }
     }
 
     /**
-     * Tests that after a redirect the final url in the response
-     * reflect the redirect
+     * Tests that after a redirect the final url in the response reflect the redirect
      */
     @Test
-    public void testGetRedirectFinalUrl() {
-
-        AsyncHttpClient c = null;
+    public void testGetRedirectFinalUrl() throws Exception {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnectionsPerHost(1)//
+                .setMaxConnections(1)//
+                .setConnectionTimeout(1000)//
+                .setRequestTimeout(1000)//
+                .setFollowRedirect(true)//
+                .build();
+
+        AsyncHttpClient c = getAsyncHttpClient(config);
         try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsPerHost(1);
-            bc.setMaximumConnectionsTotal(1);
-            bc.setConnectionTimeoutInMs(1000);
-            bc.setRequestTimeoutInMs(1000);
-            bc.setFollowRedirects(true);
-
-            c = getAsyncHttpClient(bc.build());
-
-            RequestBuilder builder = new RequestBuilder("GET");
-            builder.setUrl(servletEndpointRedirectUrl);
-
-            Request r = builder.build();
+            Request r = new RequestBuilder("GET").setUrl(servletEndpointRedirectUrl).build();
 
-            try {
-                ListenableFuture<Response> response = c.executeRequest(r);
-                Response res = null;
-                res = response.get();
-                assertNotNull(res.getResponseBody());
-                assertEquals(BASE_URL + "/overthere", BASE_URL + "/overthere", res.getUri().toString());
+            ListenableFuture<Response> response = c.executeRequest(r);
+            Response res = null;
+            res = response.get();
+            assertNotNull(res.getResponseBody());
+            assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
 
-            } catch (Exception e) {
-                System.err.print("============");
-                e.printStackTrace();
-                System.err.print("============");
-                System.err.flush();
-                fail("Should not get here, The request threw an exception");
-            }
-
-
-        }
-        finally {
-            // can hang here
-            if (c != null) c.close();
+        } finally {
+            c.close();
         }
-
-
     }
 
-    protected abstract AsyncHttpProviderConfig getProviderConfig();
-
     @SuppressWarnings("serial")
     class MockRedirectHttpServlet extends HttpServlet {
-        public void service(HttpServletRequest req, HttpServletResponse res)
-                throws ServletException, IOException {
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
             res.sendRedirect("/overthere");
         }
     }
@@ -165,9 +111,9 @@ public void service(HttpServletRequest req, HttpServletResponse res)
         private static final String xml = "<?xml version=\"1.0\"?><hello date=\"%s\"></hello>";
 
         public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-            String xmlToReturn = String.format(xml, new Object[]{new Date().toString()});
+            String xmlToReturn = String.format(xml, new Object[] { new Date().toString() });
 
-            res.setStatus(200, "Complete, XML Being Returned");
+            res.setStatus(200);
             res.addHeader("Content-Type", contentType);
             res.addHeader("X-Method", req.getMethod());
             res.addHeader("MultiValue", "1");
@@ -182,6 +128,4 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
             os.close();
         }
     }
-
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/Relative302Test.java b/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
index 9d73308e7..f36e1eb4a 100644
--- a/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
@@ -15,20 +15,13 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.URI;
@@ -36,9 +29,18 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public abstract class Relative302Test extends AbstractBasicTest {
     private final AtomicBoolean isSet = new AtomicBoolean(false);
@@ -48,7 +50,7 @@
         public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
-            httpResponse.setContentType("text/html; charset=utf-8");
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             Enumeration<?> e = httpRequest.getHeaderNames();
             while (e.hasMoreElements()) {
                 param = e.nextElement().toString();
@@ -69,26 +71,26 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
-        server = new Server();
-
         port1 = findFreePort();
         port2 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-        server.addConnector(listener);
-
+        server = newJettyHttpServer(port1);
         server.setHandler(new Relative302Handler());
         server.start();
-        log.info("Local HTTP server started successfully");
+        logger.info("Local HTTP server started successfully");
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void redirected302Test() throws Throwable {
+    public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        redirected302Test();
+        redirected302InvalidTest();
+        absolutePathRedirectTest();
+        relativePathRedirectTest();
+    }
+
+    // @Test(groups = { "online", "default_provider" })
+    public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
         try {
@@ -97,36 +99,18 @@ public void redirected302Test() throws Throwable {
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
 
-            String anyGoogleSubdomain = "http://www\\.google\\.[a-z]+(\\.[a-z]+)*:80";
             String baseUrl = getBaseUrl(response.getUri());
 
-            assertTrue(baseUrl.matches(anyGoogleSubdomain), "response does not show redirection to " + anyGoogleSubdomain);
+            assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
         } finally {
             c.close();
         }
     }
 
-    private String getBaseUrl(URI uri) {
-        String url = uri.toString();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url = url.substring(0, url.length() - 1) + ":" + port;
-        }
-        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
-    }
-
-    private static int getPort(URI uri) {
-        int port = uri.getPort();
-        if (port == -1)
-            port = uri.getScheme().equals("http") ? 80 : 443;
-        return port;
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void redirected302InvalidTest() throws Throwable {
+    // @Test(groups = { "standalone", "default_provider" })
+    public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
@@ -142,11 +126,11 @@ public void redirected302InvalidTest() throws Throwable {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void absolutePathRedirectTest() throws Throwable {
+    // @Test(groups = { "standalone", "default_provider" })
+    public void absolutePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             String redirectTarget = "/bar/test";
@@ -157,17 +141,17 @@ public void absolutePathRedirectTest() throws Throwable {
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getUri().toString(), destinationUrl);
 
-            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
         } finally {
             c.close();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void relativePathRedirectTest() throws Throwable {
+    // @Test(groups = { "standalone", "default_provider" })
+    public void relativePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             String redirectTarget = "bar/test1";
@@ -178,9 +162,26 @@ public void relativePathRedirectTest() throws Throwable {
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getUri().toString(), destinationUrl);
 
-            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
         } finally {
             c.close();
         }
     }
+
+    private String getBaseUrl(Uri uri) {
+        String url = uri.toString();
+        int port = uri.getPort();
+        if (port == -1) {
+            port = getPort(uri);
+            url = url.substring(0, url.length() - 1) + ":" + port;
+        }
+        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+    }
+
+    private static int getPort(Uri uri) {
+        int port = uri.getPort();
+        if (port == -1)
+            port = uri.getScheme().equals("http") ? 80 : 443;
+        return port;
+    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java b/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
index 8e609af81..7e8ad5f21 100644
--- a/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
@@ -17,18 +17,10 @@
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
-import static org.testng.AssertJUnit.assertTrue;
-
-import java.io.InputStream;
-import java.net.URLEncoder;
-import java.util.Collections;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import org.asynchttpclient.Cookie;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 
+import org.apache.commons.io.IOUtils;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -38,7 +30,14 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.util.StandardCharsets;
+import org.testng.annotations.Test;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Unit tests for remote site.
@@ -53,8 +52,8 @@
     public static final String REQUEST_PARAM = "github github \n" + "github";
 
     @Test(groups = { "online", "default_provider" })
-    public void testGoogleCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+    public void testGoogleCom() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
         try {
             Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
@@ -64,8 +63,8 @@ public void testGoogleCom() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void testMailGoogleCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+    public void testMailGoogleCom() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
         try {
             Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
@@ -75,9 +74,10 @@ public void testMailGoogleCom() throws Throwable {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
-    public void testMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+    @Test(groups = { "online", "default_provider" }, enabled = false)
+    // FIXME
+    public void testMicrosoftCom() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
         try {
             Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
@@ -87,18 +87,23 @@ public void testMicrosoftCom() throws Throwable {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
-    public void testWwwMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-
-        Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
+    @Test(groups = { "online", "default_provider" }, enabled = false)
+    // FIXME
+    public void testWwwMicrosoftCom() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
+        try {
+            Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = { "online", "default_provider" })
-    public void testUpdateMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+    @Test(groups = { "online", "default_provider" }, enabled = false)
+    // FIXME
+    public void testUpdateMicrosoftCom() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
         try {
             Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
@@ -109,20 +114,20 @@ public void testUpdateMicrosoftCom() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void testGoogleComWithTimeout() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+    public void testGoogleComWithTimeout() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
         try {
             Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
-            assertEquals(response.getStatusCode(), 301);
+            assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
         } finally {
             c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+    public void asyncStatusHEADContentLenghtTest() throws Exception {
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl("http://www.google.com/").build();
@@ -130,14 +135,17 @@ public void asyncStatusHEADContentLenghtTest() throws Throwable {
             p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
-                    Assert.assertEquals(response.getStatusCode(), 200);
-                    l.countDown();
-                    return response;
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        return response;
+                    } finally {
+                        l.countDown();
+                    }
                 }
             }).get();
 
             if (!l.await(5, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
             p.close();
@@ -145,8 +153,9 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
-    public void invalidStreamTest2() throws Throwable {
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).setFollowRedirects(true).setAllowPoolingConnection(false).setMaximumNumberOfRedirects(6).build();
+    public void invalidStreamTest2() throws Exception {
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).setFollowRedirect(true)
+                .setAllowPoolingConnections(false).setMaxRedirects(6).build();
 
         AsyncHttpClient c = getAsyncHttpClient(config);
         try {
@@ -164,31 +173,28 @@ public void invalidStreamTest2() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void asyncFullBodyProperlyRead() throws Throwable {
+    public void asyncFullBodyProperlyRead() throws Exception {
         final AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
 
             InputStream stream = r.getResponseBodyAsStream();
-            int available = stream.available();
-            int[] lengthWrapper = new int[1];
-            /* byte[] bytes = */AsyncHttpProviderUtils.readFully(stream, lengthWrapper);
-            int byteToRead = lengthWrapper[0];
+            int contentLength = Integer.valueOf(r.getHeader("Content-Length"));
 
-            Assert.assertEquals(available, byteToRead);
+            assertEquals(contentLength, IOUtils.toByteArray(stream).length);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void testUrlRequestParametersEncoding() throws Throwable {
+    public void testUrlRequestParametersEncoding() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
-            log.info(String.format("Executing request [%s] ...", requestUrl2));
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, StandardCharsets.UTF_8.name());
+            logger.info(String.format("Executing request [%s] ...", requestUrl2));
             Response response = client.prepareGet(requestUrl2).execute().get();
-            Assert.assertEquals(response.getStatusCode(), 301);
+            assertEquals(response.getStatusCode(), 301);
         } finally {
             client.close();
         }
@@ -197,23 +203,23 @@ public void testUrlRequestParametersEncoding() throws Throwable {
     /**
      * See https://issues.sonatype.org/browse/AHC-61
      * 
-     * @throws Throwable
+     * @throws Exception
      */
     @Test(groups = { "online", "default_provider" })
-    public void testAHC60() throws Throwable {
+    public void testAHC60() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
-            Assert.assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getStatusCode(), 200);
         } finally {
             client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void stripQueryStringTest() throws Throwable {
+    public void stripQueryStringTest() throws Exception {
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
@@ -226,9 +232,10 @@ public void stripQueryStringTest() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void stripQueryStringNegativeTest() throws Throwable {
+    public void stripQueryStringNegativeTest() throws Exception {
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setRemoveQueryParamsOnRedirect(false).setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setRemoveQueryParamsOnRedirect(false).setFollowRedirect(true)
+                .build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
@@ -241,14 +248,14 @@ public void stripQueryStringNegativeTest() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" })
-    public void evilCoookieTest() throws Throwable {
+    public void evilCoookieTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             RequestBuilder builder2 = new RequestBuilder("GET");
-            builder2.setFollowRedirects(true);
+            builder2.setFollowRedirect(true);
             builder2.setUrl("http://www.google.com/");
             builder2.addHeader("Content-Type", "text/plain");
-            builder2.addCookie(new Cookie(".google.com", "evilcookie", "evilcookie", "test", "/", 10, false, 1, false, false, null, null, Collections.<Integer> emptySet()));
+            builder2.addCookie(new Cookie("evilcookie", "test", "test", ".google.com", "/", -1L, 10, false, false));
             Request request2 = builder2.build();
             Response response = c.executeRequest(request2).get();
 
@@ -260,43 +267,43 @@ public void evilCoookieTest() throws Throwable {
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
-    public void testAHC62Com() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+    public void testAHC62Com() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
         try {
-            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js")
+                    .execute(new AsyncHandler<Response>() {
 
-                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+                        private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                }
+                        public void onThrowable(Throwable t) {
+                            t.printStackTrace();
+                        }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    System.out.println(bodyPart.getBodyPartBytes().length);
-                    builder.accumulate(bodyPart);
+                        public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                            System.out.println(bodyPart.getBodyPartBytes().length);
+                            builder.accumulate(bodyPart);
 
-                    return STATE.CONTINUE;
-                }
+                            return STATE.CONTINUE;
+                        }
 
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    builder.accumulate(responseStatus);
-                    return STATE.CONTINUE;
-                }
+                        public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                            builder.accumulate(responseStatus);
+                            return STATE.CONTINUE;
+                        }
 
-                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                    builder.accumulate(headers);
-                    return STATE.CONTINUE;
-                }
+                        public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                            builder.accumulate(headers);
+                            return STATE.CONTINUE;
+                        }
 
-                public Response onCompleted() throws Exception {
-                    return builder.build();
-                }
-            }).get(10, TimeUnit.SECONDS);
+                        public Response onCompleted() throws Exception {
+                            return builder.build();
+                        }
+                    }).get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertTrue(response.getResponseBody().length() >= 3870);
         } finally {
             c.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java b/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
index 586b74a50..073bb5b18 100644
--- a/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
@@ -15,16 +15,17 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.FluentStringsMap;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.util.List;
 import java.util.concurrent.ExecutionException;
 
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.testng.annotations.Test;
 
 public class RequestBuilderTest {
 
@@ -54,7 +55,7 @@ public void testEncodesQueryParameters() throws UnsupportedEncodingException {
         for (String value : values) {
             RequestBuilder builder = new RequestBuilder("GET").
                     setUrl("http://example.com/").
-                    addQueryParameter("name", value);
+                    addQueryParam("name", value);
 
             StringBuilder sb = new StringBuilder();
             for (int i = 0, len = value.length(); i < len; ++i) {
@@ -77,26 +78,26 @@ public void testEncodesQueryParameters() throws UnsupportedEncodingException {
     public void testChaining() throws IOException, ExecutionException, InterruptedException {
         Request request = new RequestBuilder("GET")
                 .setUrl("http://foo.com")
-                .addQueryParameter("x", "value")
+                .addQueryParam("x", "value")
                 .build();
 
         Request request2 = new RequestBuilder(request).build();
 
-        assertEquals(request2.getUrl(), request.getUrl());
+        assertEquals(request2.getUri(), request.getUri());
     }
 
     @Test(groups = {"standalone", "default_provider"})
     public void testParsesQueryParams() throws IOException, ExecutionException, InterruptedException {
         Request request = new RequestBuilder("GET")
                 .setUrl("http://foo.com/?param1=value1")
-                .addQueryParameter("param2", "value2")
+                .addQueryParam("param2", "value2")
                 .build();
 
         assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
-        FluentStringsMap params = request.getQueryParams();
+        List<Param> params = request.getQueryParams();
         assertEquals(params.size(), 2);
-        assertEquals(params.get("param1").get(0), "value1");
-        assertEquals(params.get("param2").get(0), "value2");
+        assertEquals(params.get(0), new Param("param1", "value1"));
+        assertEquals(params.get(1), new Param("param2", "value2"));
     }
 
     @Test(groups = {"standalone", "default_provider"})
@@ -105,4 +106,19 @@ public void testUserProvidedRequestMethod() {
         assertEquals(req.getMethod(), "ABC");
         assertEquals(req.getUrl(), "http://foo.com");
     }
+
+    @Test(groups = {"standalone", "default_provider"})
+    public void testPercentageEncodedUserInfo() {
+        final Request req = new RequestBuilder("GET").setUrl("http://hello:wor%20ld@foo.com").build();
+        assertEquals(req.getMethod(), "GET");
+        assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
+    }
+
+    @Test(groups = {"standalone", "default_provider"})
+    public void testContentTypeCharsetToBodyEncoding() {
+        final Request req = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=utf-8").build();
+        assertEquals(req.getBodyEncoding(), "utf-8");
+        final Request req2 = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
+        assertEquals(req2.getBodyEncoding(), "utf-8");
+    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java b/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
index d9dc0970d..8706232a2 100644
--- a/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
@@ -12,8 +12,13 @@
  */
 package org.asynchttpclient.async;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -21,11 +26,10 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.io.OutputStream;
 
-import static org.testng.Assert.*;
-
 public abstract class RetryRequestTest extends AbstractBasicTest {
     public static class SlowAndBigHandler extends AbstractHandler {
 
@@ -68,7 +72,7 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testMaxRetry() throws Throwable {
+    public void testMaxRetry() throws Exception {
         AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).build());
         try {
             ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
@@ -76,7 +80,7 @@ public void testMaxRetry() throws Throwable {
         } catch (Exception t) {
             assertNotNull(t.getCause());
             assertEquals(t.getCause().getClass(), IOException.class);
-            if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
+            if (t.getCause() != AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION) {
                 fail();
             }
         } finally {
diff --git a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
index 3baf664f2..5912a7079 100644
--- a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
@@ -12,35 +12,35 @@
  */
 package org.asynchttpclient.async;
 
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.concurrent.Future;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SimpleAsyncHttpClient;
+import org.asynchttpclient.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
+import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.asynchttpclient.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
-import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.concurrent.Future;
 
 /**
  * @author Benjamin Hanzelmann
  * 
  */
-public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
+public abstract class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
+    
+    public abstract String getProviderClass();
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testAccumulateErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build();
+    public void testAccumulateErrorBody() throws Exception {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build();
         try {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
@@ -56,8 +56,8 @@ public void testAccumulateErrorBody() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testOmitErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build();
+    public void testOmitErrorBody() throws Exception {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build();
         try {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
@@ -72,12 +72,6 @@ public void testOmitErrorBody() throws Throwable {
         }
     }
 
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        // disabled
-        return null;
-    }
-
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
diff --git a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
index a8f09a3f9..04595946f 100644
--- a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
@@ -12,42 +12,48 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.ByteArrayPart;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNotSame;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SimpleAsyncHttpClient;
 import org.asynchttpclient.consumers.AppendableBodyConsumer;
 import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
 import org.asynchttpclient.generators.FileBodyGenerator;
 import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.multipart.ByteArrayPart;
 import org.asynchttpclient.simple.HeaderMap;
 import org.asynchttpclient.simple.SimpleAHCTransferListener;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StandardCharsets;
 import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
-import java.util.concurrent.ExecutionException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.Future;
 
-import static junit.framework.Assert.assertTrue;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
-import static org.testng.AssertJUnit.assertNotNull;
-import static org.testng.AssertJUnit.assertNotSame;
-
 public abstract class SimpleAsyncHttpClientTest extends AbstractBasicTest {
 
     private final static String MY_MESSAGE = "my message";
 
+    public abstract String getProviderClass();
+
     @Test(groups = { "standalone", "default_provider" })
-    public void inpuStreamBodyConsumerTest() throws Throwable {
+    public void inpuStreamBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
+                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
         try {
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-            System.out.println("waiting for response");
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getResponseBody(), MY_MESSAGE);
@@ -57,14 +63,14 @@ public void inpuStreamBodyConsumerTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void StringBuilderBodyConsumerTest() throws Throwable {
+    public void stringBuilderBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
+                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
         try {
             StringBuilder s = new StringBuilder();
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
 
-            System.out.println("waiting for response");
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(s.toString(), MY_MESSAGE);
@@ -74,14 +80,14 @@ public void StringBuilderBodyConsumerTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
+    public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
+                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
         try {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
-            System.out.println("waiting for response");
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
@@ -91,14 +97,13 @@ public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
+    public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
         try {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
-            System.out.println("waiting for response");
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
@@ -111,8 +116,9 @@ public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
      * See https://issues.sonatype.org/browse/AHC-5
      */
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
-    public void testPutZeroBytesFileTest() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain")
+    public void testPutZeroBytesFileTest() throws Exception {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
+                .setMaxConnections(50).setRequestTimeout(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain")
                 .build();
         try {
             File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
@@ -133,7 +139,7 @@ public void testPutZeroBytesFileTest() throws Throwable {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDerive() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
         try {
             assertNotSame(derived, client);
@@ -145,7 +151,7 @@ public void testDerive() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDeriveOverrideURL() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl("http://invalid.url").build();
         ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
         InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
@@ -167,37 +173,66 @@ public void testDeriveOverrideURL() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void testSimpleTransferListener() throws Exception {
 
+        final List<Error> errors = Collections.synchronizedList(new ArrayList<Error>());
+
         SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
 
-            public void onStatus(String url, int statusCode, String statusText) {
-                assertEquals(statusCode, 200);
-                assertEquals(url, getTargetUrl());
+            public void onStatus(Uri uri, int statusCode, String statusText) {
+                try {
+                    assertEquals(statusCode, 200);
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
             }
 
-            public void onHeaders(String url, HeaderMap headers) {
-                assertEquals(url, getTargetUrl());
-                assertNotNull(headers);
-                assertTrue(!headers.isEmpty());
-                assertEquals(headers.getFirstValue("X-Custom"), "custom");
+            public void onHeaders(Uri uri, HeaderMap headers) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    assertNotNull(headers);
+                    assertTrue(!headers.isEmpty());
+                    assertEquals(headers.getFirstValue("X-Custom"), "custom");
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
             }
 
-            public void onCompleted(String url, int statusCode, String statusText) {
-                assertEquals(statusCode, 200);
-                assertEquals(url, getTargetUrl());
+            public void onCompleted(Uri uri, int statusCode, String statusText) {
+                try {
+                    assertEquals(statusCode, 200);
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
             }
 
-            public void onBytesSent(String url, long amount, long current, long total) {
-                assertEquals(url, getTargetUrl());
-                assertEquals(total, MY_MESSAGE.getBytes().length);
+            public void onBytesSent(Uri uri, long amount, long current, long total) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    // FIXME Netty bug, see https://github.com/netty/netty/issues/1855
+//                    assertEquals(total, MY_MESSAGE.getBytes().length);
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
             }
 
-            public void onBytesReceived(String url, long amount, long current, long total) {
-                assertEquals(url, getTargetUrl());
-                assertEquals(total, -1);
+            public void onBytesReceived(Uri uri, long amount, long current, long total) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    assertEquals(total, -1);
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
             }
         };
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).setHeader("Custom", "custom").setListener(listener).build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).setHeader("Custom", "custom")
+                .setListener(listener).build();
         try {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
@@ -207,6 +242,14 @@ public void onBytesReceived(String url, long amount, long current, long total) {
             Future<Response> future = client.post(generator, consumer);
 
             Response response = future.get();
+
+            if (!errors.isEmpty()) {
+                for (Error e : errors) {
+                    e.printStackTrace();
+                }
+                throw errors.get(0);
+            }
+
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
         } finally {
@@ -216,17 +259,21 @@ public void onBytesReceived(String url, long amount, long current, long total) {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNullUrl() throws Exception {
+        SimpleAsyncHttpClient client = null;
         try {
-            new SimpleAsyncHttpClient.Builder().build().derive().build();
+            client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).build();
             assertTrue(true);
         } catch (NullPointerException ex) {
             fail();
+        } finally {
+            if (client != null)
+                client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testCloseDerivedValidMaster() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
         try {
             derived.get().get();
@@ -243,7 +290,7 @@ public void testCloseDerivedValidMaster() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testCloseMasterInvalidDerived() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
 
         client.close();
@@ -251,10 +298,6 @@ public void testCloseMasterInvalidDerived() throws Exception {
         try {
             derived.get().get();
             fail("Expected closed AHC");
-        } catch (ExecutionException ee) {
-            if (!(ee.getCause() instanceof IOException)) {
-                fail("Unexpected failure: " + ee.getCause());
-            }
         } catch (IOException e) {
             // expected
         }
@@ -262,9 +305,9 @@ public void testCloseMasterInvalidDerived() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPut() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/multipart").build();
         try {
-            Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(StandardCharsets.UTF_8), "application/test", StandardCharsets.UTF_8, "fileName")).get();
 
             String body = response.getResponseBody();
             String contentType = response.getHeader("X-Content-Type");
@@ -286,9 +329,9 @@ public void testMultiPartPut() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPost() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/multipart").build();
         try {
-            Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(StandardCharsets.UTF_8), "application/test", StandardCharsets.UTF_8, "fileName")).get();
 
             String body = response.getResponseBody();
             String contentType = response.getHeader("X-Content-Type");
@@ -307,5 +350,4 @@ public void testMultiPartPost() throws Exception {
             client.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java b/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
index 48e18c1be..90ffb1993 100644
--- a/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
@@ -12,7 +12,14 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.generators.FileBodyGenerator;
@@ -24,23 +31,16 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.util.Enumeration;
-import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
 public abstract class TransferListenerTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
     private class BasicHandler extends AbstractHandler {
 
@@ -59,8 +59,13 @@ public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequ
             }
             byte[] bytes = new byte[size];
             if (bytes.length > 0) {
-                httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes);
+                int read = 0;
+                while (read != -1) {
+                    read = httpRequest.getInputStream().read(bytes);
+                    if (read > 0) {
+                        httpResponse.getOutputStream().write(bytes, 0, read);
+                    }
+                }
             }
 
             httpResponse.setStatus(200);
@@ -75,13 +80,13 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicGetTest() throws Throwable {
+    public void basicGetTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
             final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
             final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicReference<ByteBuffer> bb = new AtomicReference<ByteBuffer>();
+            final AtomicReference<byte[]> bb = new AtomicReference<byte[]>();
             final AtomicBoolean completed = new AtomicBoolean(false);
 
             TransferCompletionHandler tl = new TransferCompletionHandler();
@@ -95,11 +100,12 @@ public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
                     hRead.set(headers);
                 }
 
-                public void onBytesReceived(ByteBuffer buffer) {
-                    bb.set(buffer);
+                public void onBytesReceived(byte[] b) {
+                    if (b.length != 0)
+                        bb.set(b);
                 }
 
-                public void onBytesSent(ByteBuffer buffer) {
+                public void onBytesSent(long amount, long current, long total) {
                 }
 
                 public void onRequestResponseCompleted() {
@@ -118,7 +124,7 @@ public void onThrowable(Throwable t) {
                 assertEquals(response.getStatusCode(), 200);
                 assertNotNull(hRead.get());
                 assertNotNull(hSent.get());
-                assertNotNull(bb.get());
+                assertNull(bb.get());
                 assertNull(throwable.get());
             } catch (IOException ex) {
                 fail("Should have timed out");
@@ -129,21 +135,21 @@ public void onThrowable(Throwable t) {
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicPutTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-            final AtomicInteger bbSentLenght = new AtomicInteger(0);
+    public void basicPutFileTest() throws Exception {
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+        final AtomicLong bbSentLenght = new AtomicLong(0L);
 
-            final AtomicBoolean completed = new AtomicBoolean(false);
+        final AtomicBoolean completed = new AtomicBoolean(false);
+
+        File file = createTempFile(1024 * 100 * 10);
 
-            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-            File largeFile = createTempFile(bytes, (int) repeats);
+        int timeout = (int) (file.length() / 1000);
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(timeout).build());
 
+        try {
             TransferCompletionHandler tl = new TransferCompletionHandler();
             tl.addTransferListener(new TransferListener() {
 
@@ -155,12 +161,12 @@ public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
                     hRead.set(headers);
                 }
 
-                public void onBytesReceived(ByteBuffer buffer) {
-                    bbReceivedLenght.addAndGet(buffer.capacity());
+                public void onBytesReceived(byte[] b) {
+                    bbReceivedLenght.addAndGet(b.length);
                 }
 
-                public void onBytesSent(ByteBuffer buffer) {
-                    bbSentLenght.addAndGet(buffer.capacity());
+                public void onBytesSent(long amount, long current, long total) {
+                    bbSentLenght.addAndGet(amount);
                 }
 
                 public void onRequestResponseCompleted() {
@@ -173,37 +179,35 @@ public void onThrowable(Throwable t) {
             });
 
             try {
-                Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(tl).get();
+                Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
 
                 assertNotNull(response);
                 assertEquals(response.getStatusCode(), 200);
                 assertNotNull(hRead.get());
                 assertNotNull(hSent.get());
-                assertEquals(bbReceivedLenght.get(), largeFile.length());
-                assertEquals(bbSentLenght.get(), largeFile.length());
+                assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+                assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
             } catch (IOException ex) {
                 fail("Should have timed out");
             }
         } finally {
-            c.close();
+            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void basicPutBodyTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    public void basicPutFileBodyGeneratorTest() throws Exception {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
             final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
             final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
             final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
             final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-            final AtomicInteger bbSentLenght = new AtomicInteger(0);
+            final AtomicLong bbSentLenght = new AtomicLong(0L);
 
             final AtomicBoolean completed = new AtomicBoolean(false);
 
-            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-            File largeFile = createTempFile(bytes, (int) repeats);
+            File file = createTempFile(1024 * 100 * 10);
 
             TransferCompletionHandler tl = new TransferCompletionHandler();
             tl.addTransferListener(new TransferListener() {
@@ -216,12 +220,12 @@ public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
                     hRead.set(headers);
                 }
 
-                public void onBytesReceived(ByteBuffer buffer) {
-                    bbReceivedLenght.addAndGet(buffer.capacity());
+                public void onBytesReceived(byte[] b) {
+                    bbReceivedLenght.addAndGet(b.length);
                 }
 
-                public void onBytesSent(ByteBuffer buffer) {
-                    bbSentLenght.addAndGet(buffer.capacity());
+                public void onBytesSent(long amount, long current, long total) {
+                    bbSentLenght.addAndGet(amount);
                 }
 
                 public void onRequestResponseCompleted() {
@@ -234,48 +238,19 @@ public void onThrowable(Throwable t) {
             });
 
             try {
-                Response response = c.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(largeFile)).execute(tl).get();
+                Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
 
                 assertNotNull(response);
                 assertEquals(response.getStatusCode(), 200);
                 assertNotNull(hRead.get());
                 assertNotNull(hSent.get());
-                assertEquals(bbReceivedLenght.get(), largeFile.length());
-                assertEquals(bbSentLenght.get(), largeFile.length());
+                assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+                assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
             } catch (IOException ex) {
                 fail("Should have timed out");
             }
         } finally {
-            c.close();
-        }
-    }
-
-    public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
-    }
-
-    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
-        TMP.mkdirs();
-        TMP.deleteOnExit();
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
-        write(pattern, repeat, tmpFile);
-
-        return tmpFile;
-    }
-
-    public static void write(byte[] pattern, int repeat, File file) throws IOException {
-        file.deleteOnExit();
-        file.getParentFile().mkdirs();
-        FileOutputStream out = null;
-        try {
-            out = new FileOutputStream(file);
-            for (int i = 0; i < repeat; i++) {
-                out.write(pattern);
-            }
-        } finally {
-            if (out != null) {
-                out.close();
-            }
+            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java b/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
index fb8d5abff..7045925d5 100644
--- a/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
@@ -12,12 +12,11 @@
  */
 package org.asynchttpclient.async;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.webdav.WebDavCompletionHandlerBase;
-import org.asynchttpclient.webdav.WebDavResponse;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
 import org.apache.catalina.Context;
 import org.apache.catalina.Engine;
 import org.apache.catalina.Host;
@@ -25,6 +24,12 @@
 import org.apache.catalina.connector.Connector;
 import org.apache.catalina.startup.Embedded;
 import org.apache.coyote.http11.Http11NioProtocol;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.webdav.WebDavCompletionHandlerBase;
+import org.asynchttpclient.webdav.WebDavResponse;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeClass;
@@ -34,13 +39,9 @@
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-
 public abstract class WebDavBasicTest extends AbstractBasicTest {
 
-    public Embedded embedded;
+    protected Embedded embedded;
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
@@ -76,21 +77,25 @@ public void setUpGlobal() throws Exception {
         embedded.start();
     }
 
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws InterruptedException, Exception {
+        embedded.stop();
+    }
+
     protected String getTargetUrl() {
         return String.format("http://127.0.0.1:%s/folder1", port1);
     }
 
     @AfterMethod(alwaysRun = true)
+    // FIXME not sure that's threadsafe
     public void clean() throws InterruptedException, Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request deleteRequest = new RequestBuilder("DELETE").setUrl(getTargetUrl()).build();
-        c.executeRequest(deleteRequest).get();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws InterruptedException, Exception {
-        embedded.stop();
+        try {
+            Request deleteRequest = new RequestBuilder("DELETE").setUrl(getTargetUrl()).build();
+            c.executeRequest(deleteRequest).get();
+        } finally {
+            c.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -171,7 +176,7 @@ public void propFindCompletionHandlerWebDavTest() throws InterruptedException, I
                 /**
                  * {@inheritDoc}
                  */
-                /* @Override */
+                @Override
                 public void onThrowable(Throwable t) {
 
                     t.printStackTrace();
@@ -189,5 +194,4 @@ public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
             c.close();
         }
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java b/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
index c11a3ea5d..0ef54128f 100644
--- a/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
@@ -12,6 +12,13 @@
  */
 package org.asynchttpclient.async;
 
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
@@ -26,21 +33,16 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.URISyntaxException;
-import java.net.URL;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-
 /**
  * Zero copy test which use FileChannel.transfer under the hood . The same SSL test is also covered in {@link BasicHttpsTest}
  */
@@ -68,14 +70,10 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
     public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
             final AtomicBoolean headerSent = new AtomicBoolean(false);
             final AtomicBoolean operationCompleted = new AtomicBoolean(false);
 
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncCompletionHandler<Response>() {
+            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
 
                 public STATE onHeaderWriteCompleted() {
                     headerSent.set(true);
@@ -91,11 +89,10 @@ public STATE onContentWriteCompleted() {
                 public Response onCompleted(Response response) throws Exception {
                     return response;
                 }
-            });
-            Response resp = f.get();
+            }).get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
             assertTrue(operationCompleted.get());
             assertTrue(headerSent.get());
         } finally {
@@ -107,16 +104,11 @@ public Response onCompleted(Response response) throws Exception {
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(file).execute();
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         } finally {
             client.close();
         }
@@ -130,16 +122,11 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+        tmp.deleteOnExit();
+        final FileOutputStream stream = new FileOutputStream(tmp);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-            tmp.deleteOnExit();
-            final FileOutputStream stream = new FileOutputStream(tmp);
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                 public void onThrowable(Throwable t) {
                 }
 
@@ -159,12 +146,11 @@ public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
                 public Response onCompleted() throws Exception {
                     return null;
                 }
-            });
-            Response resp = f.get();
-            stream.close();
+            }).get();
             assertNull(resp);
-            assertEquals(file.length(), tmp.length());
+            assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
         } finally {
+            stream.close();
             client.close();
         }
     }
@@ -172,16 +158,12 @@ public Response onCompleted() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+        tmp.deleteOnExit();
+        final FileOutputStream stream = new FileOutputStream(tmp);
         try {
-            ClassLoader cl = getClass().getClassLoader();
-            // override system properties
-            URL url = cl.getResource("SimpleTextFile.txt");
-            File file = new File(url.toURI());
-
-            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-            tmp.deleteOnExit();
-            final FileOutputStream stream = new FileOutputStream(tmp);
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+
+            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                 public void onThrowable(Throwable t) {
                 }
 
@@ -206,12 +188,11 @@ public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
                 public Response onCompleted() throws Exception {
                     return null;
                 }
-            });
-            Response resp = f.get();
-            stream.close();
+            }).get();
             assertNull(resp);
-            assertEquals(file.length(), tmp.length());
+            assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
         } finally {
+            stream.close();
             client.close();
         }
     }
diff --git a/api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java b/api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java
new file mode 100644
index 000000000..00e132c84
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java
@@ -0,0 +1,103 @@
+package org.asynchttpclient.async.util;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import java.io.IOException;
+import java.util.Enumeration;
+
+public class EchoHandler extends AbstractHandler {
+
+    @Override
+    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+        if (httpRequest.getHeader("X-HEAD") != null) {
+            httpResponse.setContentLength(1);
+        }
+
+        if (httpRequest.getHeader("X-ISO") != null) {
+            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+        } else {
+            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+        }
+
+        if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+            httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+        }
+        ;
+
+        Enumeration<?> e = httpRequest.getHeaderNames();
+        String param;
+        while (e.hasMoreElements()) {
+            param = e.nextElement().toString();
+
+            if (param.startsWith("LockThread")) {
+                try {
+                    Thread.sleep(40 * 1000);
+                } catch (InterruptedException ex) {
+                }
+            }
+
+            if (param.startsWith("X-redirect")) {
+                httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+                return;
+            }
+            httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+        }
+
+        Enumeration<?> i = httpRequest.getParameterNames();
+
+        StringBuilder requestBody = new StringBuilder();
+        while (i.hasMoreElements()) {
+            param = i.nextElement().toString();
+            httpResponse.addHeader("X-" + param, httpRequest.getParameter(param));
+            requestBody.append(param);
+            requestBody.append("_");
+        }
+
+        String pathInfo = httpRequest.getPathInfo();
+        if (pathInfo != null)
+            httpResponse.addHeader("X-pathInfo", pathInfo);
+
+        String queryString = httpRequest.getQueryString();
+        if (queryString != null)
+            httpResponse.addHeader("X-queryString", queryString);
+
+        httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+
+        Cookie[] cs = httpRequest.getCookies();
+        if (cs != null) {
+            for (Cookie c : cs) {
+                httpResponse.addCookie(c);
+            }
+        }
+
+        if (requestBody.length() > 0) {
+            httpResponse.getOutputStream().write(requestBody.toString().getBytes());
+        }
+
+        int size = 16384;
+        if (httpRequest.getContentLength() > 0) {
+            size = httpRequest.getContentLength();
+        }
+        byte[] bytes = new byte[size];
+        if (bytes.length > 0) {
+            int read = 0;
+            while (read > -1) {
+                read = httpRequest.getInputStream().read(bytes);
+                if (read > 0) {
+                    httpResponse.getOutputStream().write(bytes, 0, read);
+                }
+            }
+        }
+
+        httpResponse.setStatus(200);
+        httpResponse.getOutputStream().flush();
+        httpResponse.getOutputStream().close();
+    }
+}
\ No newline at end of file
diff --git a/api/src/test/java/org/asynchttpclient/async/util/TestUtils.java b/api/src/test/java/org/asynchttpclient/async/util/TestUtils.java
new file mode 100644
index 000000000..ad87080b8
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/util/TestUtils.java
@@ -0,0 +1,283 @@
+package org.asynchttpclient.async.util;
+
+import static org.testng.Assert.assertEquals;
+
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.util.StandardCharsets;
+import org.eclipse.jetty.security.ConstraintMapping;
+import org.eclipse.jetty.security.ConstraintSecurityHandler;
+import org.eclipse.jetty.security.HashLoginService;
+import org.eclipse.jetty.security.LoginService;
+import org.eclipse.jetty.security.authentication.BasicAuthenticator;
+import org.eclipse.jetty.security.authentication.DigestAuthenticator;
+import org.eclipse.jetty.security.authentication.LoginAuthenticator;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpConfiguration;
+import org.eclipse.jetty.server.HttpConnectionFactory;
+import org.eclipse.jetty.server.SecureRequestCustomizer;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.SslConnectionFactory;
+import org.eclipse.jetty.util.security.Constraint;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+
+import javax.net.ssl.*;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.ServerSocket;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.security.*;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class TestUtils {
+
+    public static final String USER = "user";
+    public static final String ADMIN = "admin";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html; charset=UTF-8";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html; charset=ISO-8859-1";
+    private static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
+    public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
+    public static final File LARGE_IMAGE_FILE;
+    public static byte[] LARGE_IMAGE_BYTES;
+    public static final File SIMPLE_TEXT_FILE;
+    public static final String SIMPLE_TEXT_FILE_STRING;
+    private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
+
+    static {
+        try {
+            TMP_DIR.mkdirs();
+            TMP_DIR.deleteOnExit();
+            LARGE_IMAGE_FILE = new File(TestUtils.class.getClassLoader().getResource("300k.png").toURI());
+            LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
+            SIMPLE_TEXT_FILE = new File(TestUtils.class.getClassLoader().getResource("SimpleTextFile.txt").toURI());
+            SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, StandardCharsets.UTF_8);
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    public static synchronized int findFreePort() throws IOException {
+        ServerSocket socket = null;
+
+        try {
+            socket = new ServerSocket(0);
+
+            return socket.getLocalPort();
+        } finally {
+            if (socket != null)
+                socket.close();
+        }
+    }
+
+    public static File createTempFile(int approxSize) throws IOException {
+        long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
+        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+        tmpFile.deleteOnExit();
+        FileOutputStream out = null;
+        try {
+            out = new FileOutputStream(tmpFile);
+            for (int i = 0; i < repeats; i++) {
+                out.write(PATTERN_BYTES);
+            }
+
+            long expectedFileSize = PATTERN_BYTES.length * repeats;
+            assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
+
+            return tmpFile;
+        } finally {
+            if (out != null) {
+                out.close();
+            }
+        }
+    }
+
+    public static Server newJettyHttpServer(int port) {
+        Server server = new Server();
+        addHttpConnector(server, port);
+        return server;
+    }
+
+    public static void addHttpConnector(Server server, int port) {
+        ServerConnector connector = new ServerConnector(server);
+        connector.setPort(port);
+
+        server.addConnector(connector);
+    }
+
+    public static Server newJettyHttpsServer(int port) throws URISyntaxException {
+        Server server = new Server();
+        addHttpsConnector(server, port);
+        return server;
+    }
+
+    public static void addHttpsConnector(Server server, int port) throws URISyntaxException {
+        ClassLoader cl = TestUtils.class.getClassLoader();
+
+        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
+        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
+        SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
+        sslContextFactory.setKeyStorePassword("changeit");
+
+        String trustStoreFile = new File(cl.getResource("ssltest-cacerts.jks").toURI()).getAbsolutePath();
+        sslContextFactory.setTrustStorePath(trustStoreFile);
+        sslContextFactory.setTrustStorePassword("changeit");
+
+        HttpConfiguration httpsConfig = new HttpConfiguration();
+        httpsConfig.setSecureScheme("https");
+        httpsConfig.setSecurePort(port);
+        httpsConfig.addCustomizer(new SecureRequestCustomizer());
+
+        ServerConnector connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, "http/1.1"), new HttpConnectionFactory(httpsConfig));
+        connector.setPort(port);
+
+        server.addConnector(connector);
+    }
+
+    public static void addBasicAuthHandler(Server server, boolean strict, Handler handler) {
+        addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), strict, handler);
+    }
+
+    public static void addDigestAuthHandler(Server server, boolean strict, Handler handler) {
+        addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), strict, handler);
+    }
+
+    private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, boolean strict, Handler handler) {
+
+        server.addBean(LOGIN_SERVICE);
+
+        Constraint constraint = new Constraint();
+        constraint.setName(auth);
+        constraint.setRoles(new String[] { USER, ADMIN });
+        constraint.setAuthenticate(true);
+
+        ConstraintMapping mapping = new ConstraintMapping();
+        mapping.setConstraint(constraint);
+        mapping.setPathSpec("/*");
+
+        Set<String> knownRoles = new HashSet<String>();
+        knownRoles.add(USER);
+        knownRoles.add(ADMIN);
+
+        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
+        cm.add(mapping);
+
+        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
+        security.setConstraintMappings(cm, knownRoles);
+        security.setAuthenticator(authenticator);
+        security.setLoginService(LOGIN_SERVICE);
+        security.setStrict(strict);
+        security.setHandler(handler);
+        server.setHandler(security);
+    }
+
+    private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
+        InputStream keyStoreStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("ssltest-cacerts.jks");
+        char[] keyStorePassword = "changeit".toCharArray();
+        KeyStore ks = KeyStore.getInstance("JKS");
+        ks.load(keyStoreStream, keyStorePassword);
+        assert(ks.size() > 0);
+
+        // Set up key manager factory to use our key store
+        char[] certificatePassword = "changeit".toCharArray();
+        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
+        kmf.init(ks, certificatePassword);
+
+        // Initialize the SSLContext to work with our key managers.
+        return kmf.getKeyManagers();
+    }
+
+    private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
+        InputStream keyStoreStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("ssltest-keystore.jks");
+        char[] keyStorePassword = "changeit".toCharArray();
+        KeyStore ks = KeyStore.getInstance("JKS");
+        ks.load(keyStoreStream, keyStorePassword);
+        assert(ks.size() > 0);
+
+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+        tmf.init(ks);
+        return tmf.getTrustManagers();
+    }
+
+    public static SSLContext createSSLContext(AtomicBoolean trust) {
+        try {
+            KeyManager[] keyManagers = createKeyManagers();
+            TrustManager[] trustManagers = new TrustManager[] { dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0]) };
+            SecureRandom secureRandom = new SecureRandom();
+
+            SSLContext sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(keyManagers, trustManagers, secureRandom);
+
+            return sslContext;
+        } catch (Exception e) {
+            throw new Error("Failed to initialize the server-side SSLContext", e);
+        }
+    }
+
+    public static class DummyTrustManager implements X509TrustManager {
+
+        private final X509TrustManager tm;
+        private final AtomicBoolean trust;
+
+        public DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+            this.trust = trust;
+            this.tm = tm;
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            tm.checkClientTrusted(chain, authType);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            if (!trust.get()) {
+                throw new CertificateException("Server certificate not trusted.");
+            }
+            tm.checkServerTrusted(chain, authType);
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return tm.getAcceptedIssuers();
+        }
+    }
+
+    private static TrustManager dummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+        return new DummyTrustManager(trust, tm);
+
+    }
+
+    public static File getClasspathFile(String file) throws FileNotFoundException {
+        ClassLoader cl = null;
+        try {
+            cl = Thread.currentThread().getContextClassLoader();
+        } catch (Throwable ex) {
+        }
+        if (cl == null) {
+            cl = TestUtils.class.getClassLoader();
+        }
+        URL resourceUrl = cl.getResource(file);
+
+        try {
+            return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
+        } catch (URISyntaxException e) {
+            throw new FileNotFoundException(file);
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java b/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
new file mode 100644
index 000000000..f14aaf0b7
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+import org.testng.annotations.Test;
+
+public class CookieDecoderTest {
+
+    @Test(groups = "fast")
+    public void testDecodeUnquoted() {
+        Cookie cookie = CookieDecoder.decode("foo=value; domain=/; path=/");
+        assertNotNull(cookie);
+        assertEquals(cookie.getValue(), "value");
+        assertEquals(cookie.getRawValue(), "value");
+        assertEquals(cookie.getDomain(), "/");
+        assertEquals(cookie.getPath(), "/");
+    }
+
+    @Test(groups = "fast")
+    public void testDecodeQuoted() {
+        Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
+        assertNotNull(cookie);
+        assertEquals(cookie.getValue(), "VALUE1");
+        assertEquals(cookie.getRawValue(), "\"VALUE1\"");
+    }
+
+    @Test(groups = "fast")
+    public void testDecodeQuotedContainingEscapedQuote() {
+        Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\\\"\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
+        assertNotNull(cookie);
+        assertEquals(cookie.getValue(), "VALUE1\"");
+        assertEquals(cookie.getRawValue(), "\"VALUE1\\\"\"");
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java b/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java
new file mode 100644
index 000000000..ed171f692
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.date;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+import org.testng.annotations.Test;
+
+/**
+ * See http://tools.ietf.org/html/rfc2616#section-3.3
+ * 
+ * @author slandelle
+ */
+public class RFC2616DateParserTest {
+
+    @Test(groups = "fast")
+    public void testRFC822() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 06 Nov 1994 08:49:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.dayOfMonth(), 6);
+        assertEquals(date.month(), 11);
+        assertEquals(date.year(), 1994);
+        assertEquals(date.hour(), 8);
+        assertEquals(date.minute(), 49);
+        assertEquals(date.second(), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitDayOfMonth() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:49:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.dayOfMonth(), 6);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822TwoDigitsYear() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 94 08:49:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.year(), 1994);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitHour() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 8:49:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.hour(), 8);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitMinute() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:9:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.minute(), 9);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitSecond() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:49:7 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.second(), 7);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC6265() {
+        RFC2616Date date = new RFC2616DateParser("Sun, 06 Nov 1994 08:49:37").parse();
+        assertNotNull(date);
+        assertEquals(date.dayOfMonth(), 6);
+        assertEquals(date.month(), 11);
+        assertEquals(date.year(), 1994);
+        assertEquals(date.hour(), 8);
+        assertEquals(date.minute(), 49);
+        assertEquals(date.second(), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC850() {
+        RFC2616Date date = new RFC2616DateParser("Sunday, 06-Nov-94 08:49:37 GMT").parse();
+        assertNotNull(date);
+        assertEquals(date.dayOfMonth(), 6);
+        assertEquals(date.month(), 11);
+        assertEquals(date.year(), 1994);
+        assertEquals(date.hour(), 8);
+        assertEquals(date.minute(), 49);
+        assertEquals(date.second(), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testANSIC() {
+        RFC2616Date date = new RFC2616DateParser("Sun Nov  6 08:49:37 1994").parse();
+        assertNotNull(date);
+        assertEquals(date.dayOfMonth(), 6);
+        assertEquals(date.month(), 11);
+        assertEquals(date.year(), 1994);
+        assertEquals(date.hour(), 8);
+        assertEquals(date.minute(), 49);
+        assertEquals(date.second(), 37);
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java b/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
index efd53a3bf..80645ba1e 100644
--- a/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
+++ b/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
@@ -13,17 +13,15 @@
 
 package org.asynchttpclient.generators;
 
-import org.asynchttpclient.Body;
+import static org.testng.Assert.assertEquals;
 
-import org.asynchttpclient.generators.ByteArrayBodyGenerator;
+import org.asynchttpclient.Body;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Random;
 
-import static org.testng.Assert.assertEquals;
-
 /**
  * @author Bryan Davis bpd@keynetics.com
  */
@@ -74,5 +72,4 @@ public void testMultipleReads() throws IOException {
         assertEquals(reads, 4, "reads to drain generator");
         assertEquals(bytesRead, srcArraySize, "bytes read");
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java b/api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java
new file mode 100644
index 000000000..3eeb05bbe
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.multipart;
+
+import static org.asynchttpclient.util.StandardCharsets.UTF_8;
+
+import org.asynchttpclient.Body;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+public class MultipartBodyTest {
+
+    @Test(groups = "fast")
+    public void testBasics() {
+        final List<Part> parts = new ArrayList<Part>();
+
+        // add a file
+        final File testFile = getTestfile();
+        parts.add(new FilePart("filePart", testFile));
+
+        // add a byte array
+        parts.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
+
+        // add a string
+        parts.add(new StringPart("stringPart", "testString", UTF_8));
+
+        compareContentLength(parts);
+    }
+
+    private static File getTestfile() {
+        final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
+        final URL url = cl.getResource("textfile.txt");
+        Assert.assertNotNull(url);
+        File file = null;
+        try {
+            file = new File(url.toURI());
+        } catch (URISyntaxException use) {
+            Assert.fail("uri syntax error");
+        }
+        return file;
+    }
+
+    private static void compareContentLength(final List<Part> parts) {
+        Assert.assertNotNull(parts);
+        // get expected values
+        final Body multipartBody = MultipartUtils.newMultipartBody(parts, new FluentCaseInsensitiveStringsMap());
+        final long expectedContentLength = multipartBody.getContentLength();
+        try {
+            final ByteBuffer buffer = ByteBuffer.allocate(8192);
+            boolean last = false;
+            long totalBytes = 0;
+            while (!last) {
+                long readBytes = 0;
+                try {
+                    readBytes = multipartBody.read(buffer);
+                } catch (IOException ie) {
+                    Assert.fail("read failure");
+                }
+                if (readBytes > 0) {
+                    totalBytes += readBytes;
+                } else {
+                    last = true;
+                }
+                buffer.clear();
+            }
+            Assert.assertEquals(totalBytes, expectedContentLength);
+        } finally {
+            try {
+                multipartBody.close();
+            } catch (IOException ignore) {
+            }
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java b/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
index f2256fad0..b3c696dc4 100644
--- a/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
+++ b/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
@@ -15,16 +15,16 @@
  */
 package org.asynchttpclient.oauth;
 
-import org.asynchttpclient.oauth.ConsumerKey;
-import org.asynchttpclient.oauth.OAuthSignatureCalculator;
-import org.asynchttpclient.oauth.RequestToken;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.List;
 
-import org.asynchttpclient.FluentStringsMap;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
 
-public class TestSignatureCalculator
-{
+public class TestSignatureCalculator {
     private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
 
     private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
@@ -36,21 +36,20 @@
     public static final String NONCE = "kllo9940pd9333jh";
 
     final static long TIMESTAMP = 1191242096;
-    
+
     // based on the reference test case from
     // http://oauth.pbwiki.com/TestCases
-    @Test(groups="fast")
-    public void test()
-    {
+    @Test(groups = "fast")
+    public void test() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
         OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
-        FluentStringsMap queryParams = new FluentStringsMap();
-        queryParams.add("file", "vacation.jpg");
-        queryParams.add("size", "original");
+        List<Param> queryParams = new ArrayList<Param>();
+        queryParams.add(new Param("file", "vacation.jpg"));
+        queryParams.add(new Param("size", "original"));
         String url = "http://photos.example.net/photos";
-        String sig = calc.calculateSignature("GET", url, TIMESTAMP, NONCE, null, queryParams);
+        String sig = calc.calculateSignature("GET", Uri.create(url), TIMESTAMP, NONCE, null, queryParams);
 
-        Assert.assertEquals("tR3+Ty81lMeYAr/Fid0kMTYa/WM=", sig);
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java b/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
deleted file mode 100644
index 2c4e3853f..000000000
--- a/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.org.jboss.netty.handler.codec.http;
-
-import java.util.Set;
-
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.Cookie;
-
-public class CookieDecoderTest {
-    
-    @Test(groups = "fast")
-    public void testDecodeUnquoted() {
-        Set<Cookie> cookies = CookieDecoder.decode(
-                "foo=value; domain=/; path=/");
-        Assert.assertEquals(cookies.size(), 1);
-
-        Cookie first = cookies.iterator().next();
-        Assert.assertEquals(first.getValue(), "value");
-        Assert.assertEquals(first.getDomain(), "/");
-        Assert.assertEquals(first.getPath(), "/");
-    }
-
-    @Test(groups = "fast")
-    public void testDecodeQuoted() {
-        Set<Cookie> cookies = CookieDecoder.decode("ALPHA=\"VALUE1\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 13-Jan-2021 22:23:01 GMT; Secure; HttpOnly");
-        Assert.assertEquals(cookies.size(), 1);
-
-        Cookie first = cookies.iterator().next();
-        Assert.assertEquals(first.getValue(), "VALUE1");
-    }
-
-    @Test(groups = "fast")
-    public void testDecodeQuotedContainingEscapedQuote() {
-        Set<Cookie> cookies = CookieDecoder.decode("ALPHA=\"VALUE1\\\"\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 13-Jan-2021 22:23:01 GMT; Secure; HttpOnly");
-        Assert.assertEquals(cookies.size(), 1);
-
-        Cookie first = cookies.iterator().next();
-        Assert.assertEquals(first.getValue(), "VALUE1\"");
-    }
-}
\ No newline at end of file
diff --git a/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java b/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
index ab958e529..b5de1de8c 100644
--- a/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
@@ -13,13 +13,12 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import org.asynchttpclient.resumable.PropertiesBasedResumableProcessor;
+import static org.testng.Assert.assertEquals;
+
 import org.testng.annotations.Test;
 
 import java.util.Map;
 
-import static org.testng.Assert.assertEquals;
-
 /**
  * @author Benjamin Hanzelmann
  */
@@ -36,5 +35,4 @@ public void testSaveLoad() throws Exception {
         assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
         assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
     }
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
index 7feb70ce7..b8dbcbab0 100644
--- a/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
@@ -13,14 +13,13 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.resumable.ResumableAsyncHandler;
 import org.testng.annotations.Test;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-
 /**
  * @author Benjamin Hanzelmann
  */
@@ -32,13 +31,13 @@ public void testAdjustRange() {
         ResumableAsyncHandler h = new ResumableAsyncHandler(proc);
         Request request = new RequestBuilder("GET").setUrl("http://test/url").build();
         Request newRequest = h.adjustRequestRange(request);
-        assertEquals(newRequest.getUrl(), request.getUrl());
+        assertEquals(newRequest.getUri(), request.getUri());
         String rangeHeader = newRequest.getHeaders().getFirstValue("Range");
         assertNull(rangeHeader);
 
         proc.put("http://test/url", 5000);
         newRequest = h.adjustRequestRange(request);
-        assertEquals(newRequest.getUrl(), request.getUrl());
+        assertEquals(newRequest.getUri(), request.getUri());
         rangeHeader = newRequest.getHeaders().getFirstValue("Range");
         assertEquals(rangeHeader, "bytes=5000-");
     }
diff --git a/api/src/test/java/org/asynchttpclient/uri/UriTest.java b/api/src/test/java/org/asynchttpclient/uri/UriTest.java
new file mode 100644
index 000000000..c54c1f895
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.uri;
+
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertEquals;
+
+public class UriTest {
+
+    @Test
+    public void testSimpleParsing() {
+        Uri url = Uri.create("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "graph.facebook.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/750198471659552/accounts/test-users");
+        assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testRootRelativeURIWithRootContext() {
+
+        Uri context = Uri.create("https://graph.facebook.com");
+        
+        Uri url = Uri.create(context, "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+        
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "graph.facebook.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/750198471659552/accounts/test-users");
+        assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+    
+    @Test
+    public void testRootRelativeURIWithNonRootContext() {
+
+        Uri context = Uri.create("https://graph.facebook.com/foo/bar");
+        
+        Uri url = Uri.create(context, "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+        
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "graph.facebook.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/750198471659552/accounts/test-users");
+        assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+    
+    @Test
+    public void testNonRootRelativeURIWithNonRootContext() {
+
+        Uri context = Uri.create("https://graph.facebook.com/foo/bar");
+        
+        Uri url = Uri.create(context, "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+        
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "graph.facebook.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/foo/750198471659552/accounts/test-users");
+        assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+    
+    @Test
+    public void testAbsoluteURIWithContext() {
+
+        Uri context = Uri.create("https://hello.com/foo/bar");
+        
+        Uri url = Uri.create(context, "https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+        
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "graph.facebook.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/750198471659552/accounts/test-users");
+        assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+}
+
diff --git a/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java b/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java
deleted file mode 100644
index d1300614e..000000000
--- a/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.net.URI;
-
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-public class AsyncHttpProviderUtilsTest {
-
-    @Test(groups = "fast")
-    public void getRedirectUriShouldHandleProperlyEncodedLocation() {
-
-        String url = "http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505";
-        URI uri = AsyncHttpProviderUtils.getRedirectUri(
-                URI.create("http://www.ebay.de"), url);
-        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
-    }
-
-    @Test(groups = "fast")
-    public void getRedirectUriShouldHandleRawQueryParamsLocation() {
-
-        String url = "http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC Lifebook E8310 Core2Duo T8100 2 1GHz 4GB DVD RW&_itemId=150731406505";
-        URI uri = AsyncHttpProviderUtils.getRedirectUri(URI.create("http://www.ebay.de"), url);
-        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
-    }
-    
-    @Test(groups = "fast")
-    public void getRedirectUriShouldHandleRelativeLocation() {
-
-        String url = "/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC Lifebook E8310 Core2Duo T8100 2 1GHz 4GB DVD RW&_itemId=150731406505";
-        URI uri = AsyncHttpProviderUtils.getRedirectUri(URI.create("http://www.ebay.de"), url);
-        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java b/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
index 24f1823d9..fdcb8884b 100644
--- a/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
+++ b/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
@@ -12,39 +12,37 @@
  */
 package org.asynchttpclient.util;
 
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.util.ProxyUtils;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 public class ProxyUtilsTest {
     @Test(groups = "fast")
     public void testBasics() {
-        ProxyServer proxyServer;
-        Request req;
-
         // should avoid, there is no proxy (is null)
-        req = new RequestBuilder("GET").setUrl("http://somewhere.com/foo").build();
-        Assert.assertTrue(ProxyUtils.avoidProxy(null, req));
+        Request req = new RequestBuilder("GET").setUrl("http://somewhere.com/foo").build();
+        assertTrue(ProxyUtils.avoidProxy(null, req));
 
         // should avoid, it's in non-proxy hosts
         req = new RequestBuilder("GET").setUrl("http://somewhere.com/foo").build();
-        proxyServer = new ProxyServer("foo", 1234);
+        ProxyServer proxyServer = new ProxyServer("foo", 1234);
         proxyServer.addNonProxyHost("somewhere.com");
-        Assert.assertTrue(ProxyUtils.avoidProxy(proxyServer, req));
+        assertTrue(ProxyUtils.avoidProxy(proxyServer, req));
 
         // should avoid, it's in non-proxy hosts (with "*")
         req = new RequestBuilder("GET").setUrl("http://sub.somewhere.com/foo").build();
         proxyServer = new ProxyServer("foo", 1234);
         proxyServer.addNonProxyHost("*.somewhere.com");
-        Assert.assertTrue(ProxyUtils.avoidProxy(proxyServer, req));
+        assertTrue(ProxyUtils.avoidProxy(proxyServer, req));
 
         // should use it
         req = new RequestBuilder("GET").setUrl("http://sub.somewhere.com/foo").build();
         proxyServer = new ProxyServer("foo", 1234);
         proxyServer.addNonProxyHost("*.somewhere.org");
-        Assert.assertFalse(ProxyUtils.avoidProxy(proxyServer, req));
+        assertFalse(ProxyUtils.avoidProxy(proxyServer, req));
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
index 21af50869..3b1dcdfba 100644
--- a/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
+++ b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
@@ -15,17 +15,15 @@
  */
 package org.asynchttpclient.util;
 
-import org.asynchttpclient.util.UTF8UrlEncoder;
-import org.testng.Assert;
+import static org.testng.Assert.assertEquals;
+
 import org.testng.annotations.Test;
 
-public class TestUTF8UrlCodec
-{
-    @Test(groups="fast")
-    public void testBasics()
-    {
-        Assert.assertEquals(UTF8UrlEncoder.encode("foobar"), "foobar");
-        Assert.assertEquals(UTF8UrlEncoder.encode("a&b"), "a%26b");
-        Assert.assertEquals(UTF8UrlEncoder.encode("a+b"), "a%2Bb");
+public class TestUTF8UrlCodec {
+    @Test(groups = "fast")
+    public void testBasics() {
+        assertEquals(UTF8UrlEncoder.encode("foobar"), "foobar");
+        assertEquals(UTF8UrlEncoder.encode("a&b"), "a%26b");
+        assertEquals(UTF8UrlEncoder.encode("a+b"), "a%2Bb");
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
index bbff1213e..f5f944d0c 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
@@ -12,96 +12,34 @@
  */
 package org.asynchttpclient.websocket;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.handler.HandlerWrapper;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.websocket.WebSocketFactory;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.net.ServerSocket;
-
-public abstract class AbstractBasicTest extends Server {
-
-    public abstract class WebSocketHandler extends HandlerWrapper implements WebSocketFactory.Acceptor {
-        private final WebSocketFactory _webSocketFactory = new WebSocketFactory(this, 32 * 1024);
+public abstract class AbstractBasicTest extends org.asynchttpclient.async.AbstractBasicTest {
 
-        public WebSocketHandler(){
-            _webSocketFactory.setMaxIdleTime(10000);
-        }
-
-        public WebSocketFactory getWebSocketFactory() {
-            return _webSocketFactory;
-        }
-
-        /* ------------------------------------------------------------ */
-        @Override
-        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if (_webSocketFactory.acceptWebSocket(request, response) || response.isCommitted())
-                return;
-            super.handle(target, baseRequest, request, response);
-        }
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
 
-        /* ------------------------------------------------------------ */
-        public boolean checkOrigin(HttpServletRequest request, String origin) {
-            return true;
-        }
+        port1 = findFreePort();
+        server = newJettyHttpServer(port1);
+        server.setHandler(getWebSocketHandler());
 
+        server.start();
+        logger.info("Local HTTP server started successfully");
     }
 
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
-    protected int port1;
-    SelectChannelConnector _connector;
-
     @AfterClass(alwaysRun = true)
     public void tearDownGlobal() throws Exception {
-        stop();
-    }
-
-    protected int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            socket = new ServerSocket(0);
-
-            return socket.getLocalPort();
-        } finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
+        server.stop();
     }
 
     protected String getTargetUrl() {
         return String.format("ws://127.0.0.1:%d/", port1);
     }
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        port1 = findFreePort();
-        _connector = new SelectChannelConnector();
-        _connector.setPort(port1);
-
-        addConnector(_connector);
-        WebSocketHandler _wsHandler = getWebSocketHandler();
-
-        setHandler(_wsHandler);
-
-        start();
-        log.info("Local HTTP server started successfully");
-    }
-
-    public abstract WebSocketHandler getWebSocketHandler() ;
-
-    public abstract AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config);
-
+    public abstract WebSocketHandler getWebSocketHandler();
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
index f9086515c..d1078047e 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
@@ -12,69 +12,36 @@
  */
 package org.asynchttpclient.websocket;
 
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketByteListener;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class ByteMessageTest extends AbstractBasicTest {
 
-    private final class EchoByteWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnBinaryMessage {
-
-        private Connection connection;
-
-        @Override
-        public void onOpen(Connection connection) {
-            this.connection = connection;
-            connection.setMaxBinaryMessageSize(1000);
-        }
-
-        @Override
-        public void onClose(int i, String s) {
-            connection.close();
-        }
-
-        @Override
-        public void onMessage(byte[] bytes, int i, int i1) {
-            try {
-                connection.sendMessage(bytes, i, i1);
-            } catch (IOException e) {
-                try {
-                    connection.sendMessage("FAIL");
-                } catch (IOException e1) {
-                    e1.printStackTrace();
-                }
-            }
-        }
-    }
-
     @Override
     public WebSocketHandler getWebSocketHandler() {
         return new WebSocketHandler() {
             @Override
-            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
-                return new EchoByteWebSocket();
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
             }
         };
     }
 
     @Test
-    public void echoByte() throws Throwable {
+    public void echoByte() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
 
-            WebSocket
-                    websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
                 @Override
                 public void onOpen(WebSocket websocket) {
@@ -97,9 +64,6 @@ public void onMessage(byte[] message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(byte[] fragment, boolean last) {
-                }
             }).build()).get();
 
             websocket.sendMessage("ECHO".getBytes());
@@ -112,7 +76,7 @@ public void onFragment(byte[] fragment, boolean last) {
     }
 
     @Test
-    public void echoTwoMessagesTest() throws Throwable {
+    public void echoTwoMessagesTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -148,9 +112,6 @@ public void onMessage(byte[] message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(byte[] fragment, boolean last) {
-                }
             }).build()).get();
 
             websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
@@ -163,7 +124,7 @@ public void onFragment(byte[] fragment, boolean last) {
     }
 
     @Test
-    public void echoOnOpenMessagesTest() throws Throwable {
+    public void echoOnOpenMessagesTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -200,9 +161,6 @@ public void onMessage(byte[] message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(byte[] fragment, boolean last) {
-                }
             }).build()).get();
 
             latch.await();
@@ -214,46 +172,47 @@ public void onFragment(byte[] fragment, boolean last) {
 
     public void echoFragments() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
 
-        WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
-            @Override
-            public void onOpen(WebSocket websocket) {
-            }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-            @Override
-            public void onClose(WebSocket websocket) {
-                latch.countDown();
-            }
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
 
-            @Override
-            public void onError(Throwable t) {
-                t.printStackTrace();
-                latch.countDown();
-            }
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
 
-            @Override
-            public void onMessage(byte[] message) {
-                if (text.get() == null) {
-                    text.set(message);
-                } else {
-                    byte[] n = new byte[text.get().length + message.length];
-                    System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                    System.arraycopy(message, 0, n, text.get().length, message.length);
-                    text.set(n);
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
                 }
-                latch.countDown();
-            }
 
-            @Override
-            public void onFragment(byte[] fragment, boolean last) {
-            }
-        }).build()).get();
-        websocket.stream("ECHO".getBytes(), false);
-        websocket.stream("ECHO".getBytes(), true);
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO".getBytes());
+            }).build()).get();
+            websocket.stream("ECHO".getBytes(), false);
+            websocket.stream("ECHO".getBytes(), true);
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
index 271ade791..5ab3ca228 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
@@ -12,23 +12,32 @@
  */
 package org.asynchttpclient.websocket;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
-public abstract class CloseCodeReasonMessageTest extends TextMessageTest {
+public abstract class CloseCodeReasonMessageTest extends AbstractBasicTest {
 
+    @Override
+    public WebSocketHandler getWebSocketHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
+            }
+        };
+    }
+    
     @Test(timeOut = 60000)
-    public void onCloseWithCode() throws Throwable {
+    public void onCloseWithCode() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -46,7 +55,7 @@ public void onCloseWithCode() throws Throwable {
     }
 
     @Test(timeOut = 60000)
-    public void onCloseWithCodeServerClose() throws Throwable {
+    public void onCloseWithCodeServerClose() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -55,13 +64,7 @@ public void onCloseWithCodeServerClose() throws Throwable {
             c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
             latch.await();
-            final String[] parts = text.get().split(" ");
-            assertEquals(parts.length, 5);
-            assertEquals(parts[0], "1000-Idle");
-            assertEquals(parts[1], "for");
-            assertTrue(Integer.parseInt(parts[2].substring(0, parts[2].indexOf('m'))) > 10000);
-            assertEquals(parts[3], ">");
-            assertEquals(parts[4], "10000ms");
+            assertEquals(text.get(), "1001-Idle Timeout");
         } finally {
             c.close();
         }
@@ -78,12 +81,13 @@ public Listener(CountDownLatch latch, AtomicReference<String> text) {
             this.text = text;
         }
 
-        // @Override
+        @Override
         public void onOpen(WebSocket websocket) {
         }
 
-        // @Override
+        @Override
         public void onClose(WebSocket websocket) {
+            latch.countDown();
         }
 
         public void onClose(WebSocket websocket, int code, String reason) {
@@ -91,10 +95,82 @@ public void onClose(WebSocket websocket, int code, String reason) {
             latch.countDown();
         }
 
-        // @Override
+        @Override
         public void onError(Throwable t) {
             t.printStackTrace();
             latch.countDown();
         }
     }
+
+    @Test(timeOut = 60000)
+    public void wrongStatusCode() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+
+            c.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    throwable.set(t);
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertNotNull(throwable.get());
+            assertEquals(throwable.get().getClass(), IllegalStateException.class);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void wrongProtocolCode() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+
+            c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    throwable.set(t);
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertNotNull(throwable.get());
+            assertEquals(throwable.get().getClass(), IllegalStateException.class);
+        } finally {
+            c.close();
+        }
+    }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java b/api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java
new file mode 100644
index 000000000..9bc51fc79
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java
@@ -0,0 +1,55 @@
+package org.asynchttpclient.websocket;
+
+import org.eclipse.jetty.websocket.api.Session;
+import org.eclipse.jetty.websocket.api.WebSocketAdapter;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+public class EchoSocket extends WebSocketAdapter {
+
+    @Override
+    public void onWebSocketConnect(Session sess) {
+        super.onWebSocketConnect(sess);
+        sess.setIdleTimeout(10000);
+        sess.setMaximumMessageSize(1000);
+    }
+
+    @Override
+    public void onWebSocketClose(int statusCode, String reason) {
+        try {
+            getSession().close();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        super.onWebSocketClose(statusCode, reason);
+    }
+
+    @Override
+    public void onWebSocketBinary(byte[] payload, int offset, int len) {
+        if (isNotConnected()) {
+            return;
+        }
+        try {
+            getRemote().sendBytes(ByteBuffer.wrap(payload, offset, len));
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void onWebSocketText(String message) {
+        if (isNotConnected()) {
+            return;
+        }
+        try {
+            if (message.equals("CLOSE"))
+                getSession().close();
+            else
+                getRemote().sendString(message);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java b/api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java
new file mode 100644
index 000000000..3e9ce1009
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
+import static org.testng.Assert.assertEquals;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.eclipse.jetty.proxy.ConnectHandler;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Proxy usage tests.
+ */
+public abstract class ProxyTunnellingTest extends AbstractBasicTest {
+
+    private Server server2;
+
+    public void setUpServers(boolean targetHttps) throws Exception {
+        port1 = findFreePort();
+        server = newJettyHttpServer(port1);
+        server.setHandler(new ConnectHandler());
+        server.start();
+
+        port2 = findFreePort();
+
+        server2 = targetHttps ? newJettyHttpsServer(port2) : newJettyHttpServer(port2);
+        server2.setHandler(getWebSocketHandler());
+        server2.start();
+
+        logger.info("Local HTTP server started successfully");
+    }
+
+    @Override
+    public WebSocketHandler getWebSocketHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
+            }
+        };
+    }
+
+    @AfterMethod(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        server.stop();
+        server2.stop();
+    }
+
+    @Test(timeOut = 60000)
+    public void echoWSText() throws Exception {
+        runTest(false);
+    }
+
+    @Test(timeOut = 60000)
+    public void echoWSSText() throws Exception {
+        runTest(true);
+    }
+
+    private void runTest(boolean secure) throws Exception {
+
+        setUpServers(secure);
+
+        String targetUrl = String.format("%s://127.0.0.1:%d/", secure ? "wss" : "ws", port2);
+
+        // CONNECT happens over HTTP, not HTTPS
+        ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTP, "127.0.0.1", port1);
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setProxyServer(ps).setAcceptAnyCertificate(true).build();
+        AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendMessage("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHO");
+        } finally {
+            asyncHttpClient.close();
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java b/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
index dda880823..b0b825fa8 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
@@ -13,48 +13,40 @@
 
 package org.asynchttpclient.websocket;
 
+import static org.asynchttpclient.async.util.TestUtils.addHttpConnector;
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.eclipse.jetty.server.handler.HandlerList;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-
 public abstract class RedirectTest extends AbstractBasicTest {
 
-    protected int port2;
-
-    // ------------------------------------------ Methods from AbstractBasicTest
-
     @BeforeClass
     @Override
     public void setUpGlobal() throws Exception {
         port1 = findFreePort();
+        port2 = findFreePort();
 
-        _connector = new SelectChannelConnector();
-        _connector.setPort(port1);
-
-        addConnector(_connector);
+        server = newJettyHttpServer(port1);
+        addHttpConnector(server, port2);
 
-        port2 = findFreePort();
-        final SelectChannelConnector connector2 = new SelectChannelConnector();
-        connector2.setPort(port2);
-        addConnector(connector2);
-        WebSocketHandler _wsHandler = getWebSocketHandler();
         HandlerList list = new HandlerList();
         list.addHandler(new AbstractHandler() {
             @Override
@@ -64,28 +56,27 @@ public void handle(String s, Request request, HttpServletRequest httpServletRequ
                 }
             }
         });
-        list.addHandler(_wsHandler);
-        setHandler(list);
+        list.addHandler(getWebSocketHandler());
+        server.setHandler(list);
 
-        start();
-        log.info("Local HTTP server started successfully");
+        server.start();
+        logger.info("Local HTTP server started successfully");
     }
 
     @Override
     public WebSocketHandler getWebSocketHandler() {
         return new WebSocketHandler() {
             @Override
-            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
-                return new TextMessageTest.EchoTextWebSocket();
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
             }
         };
     }
 
-    // ------------------------------------------------------------ Test Methods
 
     @Test(timeOut = 60000)
     public void testRedirectToWSResource() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
         try {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<String> text = new AtomicReference<String>("");
@@ -117,8 +108,6 @@ public void onError(Throwable t) {
         }
     }
 
-    // --------------------------------------------------------- Private Methods
-
     private String getRedirectURL() {
         return String.format("ws://127.0.0.1:%d/", port2);
     }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
index c64efe4cd..d367b4d7c 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
@@ -12,71 +12,38 @@
  */
 package org.asynchttpclient.websocket;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketTextListener;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
 public abstract class TextMessageTest extends AbstractBasicTest {
 
-    public static final class EchoTextWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnTextMessage {
-
-        private Connection connection;
-
-        @Override
-        public void onOpen(Connection connection) {
-            this.connection = connection;
-            connection.setMaxTextMessageSize(1000);
-        }
-
-        @Override
-        public void onClose(int i, String s) {
-            connection.close();
-        }
-
-        @Override
-        public void onMessage(String s) {
-            try {
-                connection.sendMessage(s);
-            } catch (IOException e) {
-                try {
-                    connection.sendMessage("FAIL");
-                } catch (IOException e1) {
-                    e1.printStackTrace();
-                }
-            }
-        }
-    }
-
     @Override
     public WebSocketHandler getWebSocketHandler() {
         return new WebSocketHandler() {
             @Override
-            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
-                return new EchoTextWebSocket();
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
             }
         };
     }
 
     @Test(timeOut = 60000)
-    public void onOpen() throws Throwable {
+    public void onOpen() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<String> text = new AtomicReference<String>("");
 
-            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
                 @Override
                 public void onOpen(WebSocket websocket) {
@@ -103,7 +70,7 @@ public void onError(Throwable t) {
     }
 
     @Test(timeOut = 60000)
-    public void onEmptyListenerTest() throws Throwable {
+    public void onEmptyListenerTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             WebSocket websocket = null;
@@ -119,7 +86,7 @@ public void onEmptyListenerTest() throws Throwable {
     }
 
     @Test(timeOut = 60000)
-    public void onFailureTest() throws Throwable {
+    public void onFailureTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             Throwable t = null;
@@ -135,13 +102,13 @@ public void onFailureTest() throws Throwable {
     }
 
     @Test(timeOut = 60000)
-    public void onTimeoutCloseTest() throws Throwable {
+    public void onTimeoutCloseTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<String> text = new AtomicReference<String>("");
 
-            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
                 @Override
                 public void onOpen(WebSocket websocket) {
@@ -168,7 +135,7 @@ public void onError(Throwable t) {
     }
 
     @Test(timeOut = 60000)
-    public void onClose() throws Throwable {
+    public void onClose() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -203,7 +170,7 @@ public void onError(Throwable t) {
     }
 
     @Test(timeOut = 60000)
-    public void echoText() throws Throwable {
+    public void echoText() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -217,10 +184,6 @@ public void onMessage(String message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(String fragment, boolean last) {
-                }
-
                 @Override
                 public void onOpen(WebSocket websocket) {
                 }
@@ -237,7 +200,7 @@ public void onError(Throwable t) {
                 }
             }).build()).get();
 
-            websocket.sendTextMessage("ECHO");
+            websocket.sendMessage("ECHO");
 
             latch.await();
             assertEquals(text.get(), "ECHO");
@@ -247,7 +210,7 @@ public void onError(Throwable t) {
     }
 
     @Test(timeOut = 60000)
-    public void echoDoubleListenerText() throws Throwable {
+    public void echoDoubleListenerText() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -261,10 +224,6 @@ public void onMessage(String message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(String fragment, boolean last) {
-                }
-
                 @Override
                 public void onOpen(WebSocket websocket) {
                 }
@@ -287,10 +246,6 @@ public void onMessage(String message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(String fragment, boolean last) {
-                }
-
                 @Override
                 public void onOpen(WebSocket websocket) {
                 }
@@ -307,7 +262,7 @@ public void onError(Throwable t) {
                 }
             }).build()).get();
 
-            websocket.sendTextMessage("ECHO");
+            websocket.sendMessage("ECHO");
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO");
@@ -317,7 +272,7 @@ public void onError(Throwable t) {
     }
 
     @Test
-    public void echoTwoMessagesTest() throws Throwable {
+    public void echoTwoMessagesTest() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -331,13 +286,9 @@ public void onMessage(String message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(String fragment, boolean last) {
-                }
-
                 @Override
                 public void onOpen(WebSocket websocket) {
-                    websocket.sendTextMessage("ECHO").sendTextMessage("ECHO");
+                    websocket.sendMessage("ECHO").sendMessage("ECHO");
                 }
 
                 @Override
@@ -359,7 +310,7 @@ public void onError(Throwable t) {
         }
     }
 
-    public void echoFragments() throws Throwable {
+    public void echoFragments() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(null);
         try {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -373,10 +324,6 @@ public void onMessage(String message) {
                     latch.countDown();
                 }
 
-                @Override
-                public void onFragment(String fragment, boolean last) {
-                }
-
                 @Override
                 public void onOpen(WebSocket websocket) {
                 }
@@ -393,8 +340,8 @@ public void onError(Throwable t) {
                 }
             }).build()).get();
 
-            websocket.streamText("ECHO", false);
-            websocket.streamText("ECHO", true);
+            websocket.stream("ECHO", false);
+            websocket.stream("ECHO", true);
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO");
@@ -403,4 +350,47 @@ public void onError(Throwable t) {
         }
     }
 
+    @Test(timeOut = 60000)
+    public void echoTextAndThenClose() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch textLatch = new CountDownLatch(1);
+            final CountDownLatch closeLatch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(text.get() + message);
+                    textLatch.countDown();
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    closeLatch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    closeLatch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendMessage("ECHO");
+            textLatch.await();
+
+            websocket.sendMessage("CLOSE");
+            closeLatch.await();
+
+            assertEquals(text.get(), "ECHO");
+        } finally {
+            c.close();
+        }
+    }
 }
diff --git a/api/src/test/resources/ssltest-cacerts.jks b/api/src/test/resources/ssltest-cacerts.jks
index 9c1ffbe49..207b9646e 100644
Binary files a/api/src/test/resources/ssltest-cacerts.jks and b/api/src/test/resources/ssltest-cacerts.jks differ
diff --git a/api/src/test/resources/ssltest-keystore.jks b/api/src/test/resources/ssltest-keystore.jks
index a95b7c5f4..70267836e 100644
Binary files a/api/src/test/resources/ssltest-keystore.jks and b/api/src/test/resources/ssltest-keystore.jks differ
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java
deleted file mode 100644
index c9b875927..000000000
--- a/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package org.asynchttpclient.extra;
-
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.RequestFilter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.google.common.util.concurrent.RateLimiter;
-
-/**
- * A {@link org.asynchttpclient.filter.RequestFilter} that extends the capability of
- * {@link ThrottleRequestFilter} by allowing rate limiting per second in addition to the
- * number of concurrent connections.
- * 
- *  The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For 
- *  example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
- *  it will only spend another 500 ms waiting for the rate limiter.
- */
-public class RateLimitedThrottleRequestFilter implements RequestFilter {
-	private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
-	private final Semaphore available;
-	private final int maxWaitMs;
-	private final RateLimiter rateLimiter;
-
-	public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
-		this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
-	}
-
-	public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
-		this.maxWaitMs = maxWaitMs;
-		this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
-		available = new Semaphore(maxConnections, true);
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
-	public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-		try {
-			if (logger.isDebugEnabled()) {
-				logger.debug("Current Throttling Status {}", available.availablePermits());
-			}
-
-			long startOfWait = System.currentTimeMillis();
-			attemptConcurrencyPermitAcquistion(ctx);
-
-			attemptRateLimitedPermitAcquistion(ctx, startOfWait);
-		} catch (InterruptedException e) {
-			throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(),
-					ctx.getAsyncHandler()));
-		}
-
-		return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(
-				new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available)).build();
-	}
-
-	private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
-		long wait = getMillisRemainingInMaxWait(startOfWait);
-
-		if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
-			throw new FilterException(String.format(
-					"Wait for rate limit exceeded during processing Request %s with AsyncHandler %s", ctx.getRequest(),
-					ctx.getAsyncHandler()));
-		}
-	}
-
-	private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException,
-			FilterException {
-		if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
-			throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
-					ctx.getRequest(), ctx.getAsyncHandler()));
-		}
-	}
-
-	private long getMillisRemainingInMaxWait(long startOfWait) {
-		int MINUTE_IN_MILLIS = 60000;
-		long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
-		long nonNegativeDuration = Math.max(durationLeft, 0);
-
-		// have to reduce the duration because there is a boundary case inside the Guava
-		// rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
-		// limiter's internal calculations can exceed Long.MAX_VALUE resulting in a 
-		// negative number which causes the tryAcquire() method to fail unexpectedly
-		if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
-			return nonNegativeDuration - MINUTE_IN_MILLIS;
-		}
-
-		return nonNegativeDuration;
-	}
-}
\ No newline at end of file
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
similarity index 98%
rename from extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java
rename to extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
index 2576407a0..9c51d29b6 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
@@ -10,15 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.extra;
+package org.asynchttpclient.extras.guava;
+
+import org.asynchttpclient.ListenableFuture;
 
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import org.asynchttpclient.ListenableFuture;
-
 public final class ListenableFutureAdapter {
 
     /**
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
new file mode 100644
index 000000000..dc07928d4
--- /dev/null
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -0,0 +1,94 @@
+package org.asynchttpclient.extras.guava;
+
+import org.asynchttpclient.extra.AsyncHandlerWrapper;
+import org.asynchttpclient.extra.ThrottleRequestFilter;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.RequestFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.util.concurrent.RateLimiter;
+
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A {@link org.asynchttpclient.filter.RequestFilter} that extends the capability of
+ * {@link ThrottleRequestFilter} by allowing rate limiting per second in addition to the
+ * number of concurrent connections.
+ * 
+ *  The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For 
+ *  example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
+ *  it will only spend another 500 ms waiting for the rate limiter.
+ */
+public class RateLimitedThrottleRequestFilter implements RequestFilter {
+    private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
+    private final Semaphore available;
+    private final int maxWaitMs;
+    private final RateLimiter rateLimiter;
+
+    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
+        this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
+    }
+
+    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
+        this.maxWaitMs = maxWaitMs;
+        this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
+        available = new Semaphore(maxConnections, true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Current Throttling Status {}", available.availablePermits());
+            }
+
+            long startOfWait = System.currentTimeMillis();
+            attemptConcurrencyPermitAcquistion(ctx);
+
+            attemptRateLimitedPermitAcquistion(ctx, startOfWait);
+        } catch (InterruptedException e) {
+            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
+        }
+
+        return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+                .build();
+    }
+
+    private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
+        long wait = getMillisRemainingInMaxWait(startOfWait);
+
+        if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
+            throw new FilterException(String.format("Wait for rate limit exceeded during processing Request %s with AsyncHandler %s",
+                    ctx.getRequest(), ctx.getAsyncHandler()));
+        }
+    }
+
+    private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException, FilterException {
+        if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
+            throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
+                    ctx.getAsyncHandler()));
+        }
+    }
+
+    private long getMillisRemainingInMaxWait(long startOfWait) {
+        int MINUTE_IN_MILLIS = 60000;
+        long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
+        long nonNegativeDuration = Math.max(durationLeft, 0);
+
+        // have to reduce the duration because there is a boundary case inside the Guava
+        // rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
+        // limiter's internal calculations can exceed Long.MAX_VALUE resulting in a 
+        // negative number which causes the tryAcquire() method to fail unexpectedly
+        if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
+            return nonNegativeDuration - MINUTE_IN_MILLIS;
+        }
+
+        return nonNegativeDuration;
+    }
+}
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index c79702732..9945c60ad 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -22,11 +22,13 @@
     <relativePath>..</relativePath>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
+  <name>Async Http Client JDeferred Extras</name>
+  <description>The Async Http Client jDeffered Extras.</description>
   <dependencies>
         <dependency>
             <groupId>org.jdeferred</groupId>
             <artifactId>jdeferred-core</artifactId>
-            <version>1.0.0</version>
+            <version>1.2.0</version>
         </dependency>
     </dependencies>
 </project>
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java
deleted file mode 100644
index 570cc739d..000000000
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2013 Ray Tsang
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.asynchttpclient.extra;
-
-import java.io.IOException;
-
-import org.asynchttpclient.AsyncHandler;
-import org.jdeferred.Promise;
-import org.jdeferred.impl.DeferredObject;
-
-import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.Response;
-
-public class AsyncHttpDeferredObject extends DeferredObject<Response, Throwable, HttpProgress> {
-	public AsyncHttpDeferredObject(BoundRequestBuilder builder) throws IOException {
-		builder.execute(new AsyncCompletionHandler<Void>() {
-			@Override
-			public Void onCompleted(Response response) throws Exception {
-				AsyncHttpDeferredObject.this.resolve(response);
-				return null;
-			}
-			
-			@Override
-			public void onThrowable(Throwable t) {
-				AsyncHttpDeferredObject.this.reject(t);
-			}
-			
-			@Override
-			public AsyncHandler.STATE onContentWriteProgress(
-					long amount, long current, long total) {
-				AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
-				return super.onContentWriteProgress(amount, current, total);
-			}
-			
-			@Override
-			public AsyncHandler.STATE onBodyPartReceived(
-					HttpResponseBodyPart content) throws Exception {
-				AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
-				return super.onBodyPartReceived(content);
-			}
-		});
-	}
-	
-	public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) throws IOException {
-		return new AsyncHttpDeferredObject(builder).promise();
-	}
-}
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
new file mode 100644
index 000000000..9f50dc71c
--- /dev/null
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extras.jdeferred;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Response;
+import org.jdeferred.Promise;
+import org.jdeferred.impl.DeferredObject;
+
+import java.io.IOException;
+
+public class AsyncHttpDeferredObject extends DeferredObject<Response, Throwable, HttpProgress> {
+    public AsyncHttpDeferredObject(BoundRequestBuilder builder) throws IOException {
+        builder.execute(new AsyncCompletionHandler<Void>() {
+            @Override
+            public Void onCompleted(Response response) throws Exception {
+                AsyncHttpDeferredObject.this.resolve(response);
+                return null;
+            }
+
+            @Override
+            public void onThrowable(Throwable t) {
+                AsyncHttpDeferredObject.this.reject(t);
+            }
+
+            @Override
+            public AsyncHandler.STATE onContentWriteProgress(long amount, long current, long total) {
+                AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
+                return super.onContentWriteProgress(amount, current, total);
+            }
+
+            @Override
+            public AsyncHandler.STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
+                return super.onBodyPartReceived(content);
+            }
+        });
+    }
+
+    public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) throws IOException {
+        return new AsyncHttpDeferredObject(builder).promise();
+    }
+}
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
similarity index 50%
rename from extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java
rename to extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
index d340a89c6..b07a76d3f 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
@@ -13,35 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.asynchttpclient.extra;
+package org.asynchttpclient.extras.jdeferred;
 
 public class ContentWriteProgress implements HttpProgress {
-	private final long amount;
-	private final long current;
-	private final long total;
+    private final long amount;
+    private final long current;
+    private final long total;
 
-	public ContentWriteProgress(long amount, long current, long total) {
-		this.amount = amount;
-		this.current = current;
-		this.total = total;
-	}
+    public ContentWriteProgress(long amount, long current, long total) {
+        this.amount = amount;
+        this.current = current;
+        this.total = total;
+    }
 
-	public long getAmount() {
-		return amount;
-	}
+    public long getAmount() {
+        return amount;
+    }
 
-	public long getCurrent() {
-		return current;
-	}
+    public long getCurrent() {
+        return current;
+    }
 
-	public long getTotal() {
-		return total;
-	}
+    public long getTotal() {
+        return total;
+    }
 
-	@Override
-	public String toString() {
-		return "ContentWriteProgress [amount=" + amount + ", current="
-				+ current + ", total=" + total + "]";
-	}
-	
+    @Override
+    public String toString() {
+        return "ContentWriteProgress [amount=" + amount + ", current=" + current + ", total=" + total + "]";
+    }
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
similarity index 93%
rename from extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java
rename to extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
index 15af6debb..8ff478856 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.asynchttpclient.extra;
+package org.asynchttpclient.extras.jdeferred;
 
 public interface HttpProgress {
-
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
similarity index 65%
rename from extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java
rename to extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
index 16c84e9e1..7137c5469 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
@@ -13,23 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.asynchttpclient.extra;
+package org.asynchttpclient.extras.jdeferred;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 
 public class HttpResponseBodyPartProgress implements HttpProgress {
-	private final HttpResponseBodyPart part;
+    private final HttpResponseBodyPart part;
 
-	public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
-		this.part = part;
-	}
+    public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
+        this.part = part;
+    }
 
-	public HttpResponseBodyPart getPart() {
-		return part;
-	}
-	
-	@Override
-	public String toString() {
-		return "HttpResponseBodyPartProgress [part=" + part + "]";
-	}
+    public HttpResponseBodyPart getPart() {
+        return part;
+    }
+
+    @Override
+    public String toString() {
+        return "HttpResponseBodyPartProgress [part=" + part + "]";
+    }
 }
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
index b3c2a900b..cb5847017 100644
--- a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
+++ b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
@@ -15,108 +15,94 @@
  */
 package org.asynchttpclient.extra;
 
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
-import junit.framework.Assert;
-import junit.framework.TestCase;
-
-import org.asynchttpclient.extra.AsyncHttpDeferredObject;
-import org.asynchttpclient.extra.HttpProgress;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.extras.jdeferred.AsyncHttpDeferredObject;
+import org.asynchttpclient.extras.jdeferred.HttpProgress;
 import org.jdeferred.DoneCallback;
 import org.jdeferred.ProgressCallback;
 import org.jdeferred.Promise;
 import org.jdeferred.impl.DefaultDeferredManager;
 import org.jdeferred.multiple.MultipleResults;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-
-public class AsyncHttpTest extends TestCase {
-	protected DefaultDeferredManager deferredManager;
-
-	protected void setUp() throws Exception {
-		super.setUp();
-		deferredManager = new DefaultDeferredManager();
-	}
-
-	protected void tearDown() throws Exception {
-		super.tearDown();
-	}
-
-	public void testPromiseAdapter() throws IOException {
-		final CountDownLatch latch = new CountDownLatch(1);
-		final AtomicInteger successCount = new AtomicInteger();
-		final AtomicInteger progressCount = new AtomicInteger();
-
-		AsyncHttpClient client = new AsyncHttpClient();
-
-		Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject
-				.promise(client.prepareGet("http://www.ning.com"));
-		p1.done(new DoneCallback<Response>() {
-			@Override
-			public void onDone(Response response) {
-				try {
-					Assert.assertEquals(200, response.getStatusCode());
-					successCount.incrementAndGet();
-				} finally {
-					latch.countDown();
-				}
-			}
-		}).progress(new ProgressCallback<HttpProgress>() {
-
-			@Override
-			public void onProgress(HttpProgress progress) {
-				progressCount.incrementAndGet();
-			}
-		});
-
-		try {
-			latch.await();
-			Assert.assertTrue(progressCount.get() > 0);
-		} catch (InterruptedException e) {
-			Thread.currentThread().interrupt();
-		}
-	}
-
-	public void testMultiplePromiseAdapter() throws IOException {
-		final CountDownLatch latch = new CountDownLatch(1);
-		final AtomicInteger successCount = new AtomicInteger();
-
-		AsyncHttpClient client = new AsyncHttpClient();
-
-		Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject
-				.promise(client.prepareGet("http://www.ning.com"));
-		Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject
-				.promise(client.prepareGet("http://www.google.com"));
-		AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(
-				client.prepareGet("http://jdeferred.org"));
-
-		deferredManager.when(p1, p2, deferredRequest).then(
-				new DoneCallback<MultipleResults>() {
-					@Override
-					public void onDone(MultipleResults result) {
-						try {
-							Assert.assertEquals(3, result.size());
-							Assert.assertEquals(200, ((Response) result.get(0)
-									.getResult()).getStatusCode());
-							Assert.assertEquals(200, ((Response) result.get(1)
-									.getResult()).getStatusCode());
-							Assert.assertEquals(200, ((Response) result.get(2)
-									.getResult()).getStatusCode());
-							successCount.incrementAndGet();
-						} finally {
-							latch.countDown();
-						}
-					}
-				});
-
-		try {
-			latch.await();
-		} catch (InterruptedException e) {
-			Thread.currentThread().interrupt();
-		}
-	}
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
+public class AsyncHttpTest {
+    protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
+
+    public void testPromiseAdapter() throws IOException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicInteger successCount = new AtomicInteger();
+        final AtomicInteger progressCount = new AtomicInteger();
+
+        AsyncHttpClient client = new DefaultAsyncHttpClient();
+
+        try {
+            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.ning.com"));
+            p1.done(new DoneCallback<Response>() {
+                @Override
+                public void onDone(Response response) {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        successCount.incrementAndGet();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            }).progress(new ProgressCallback<HttpProgress>() {
+
+                @Override
+                public void onProgress(HttpProgress progress) {
+                    progressCount.incrementAndGet();
+                }
+            });
+
+            latch.await();
+            assertTrue(progressCount.get() > 0);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        } finally {
+            client.close();
+        }
+    }
+
+    public void testMultiplePromiseAdapter() throws IOException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicInteger successCount = new AtomicInteger();
+
+        AsyncHttpClient client = new DefaultAsyncHttpClient();
+
+        try {
+            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.ning.com"));
+            Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
+            AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
+
+            deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
+                @Override
+                public void onDone(MultipleResults result) {
+                    try {
+                        assertEquals(result.size(), 3);
+                        assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
+                        assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
+                        assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
+                        successCount.incrementAndGet();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            });
+            latch.await();
+
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        } finally {
+            client.close();
+        }
+    }
 }
diff --git a/extras/pom.xml b/extras/pom.xml
index 281689b29..ab0b2dc70 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -46,6 +46,7 @@
     <modules>
         <module>guava</module>
         <module>jdeferred</module>
+        <module>registry</module>
     </modules>
 
     <dependencies>
@@ -54,5 +55,12 @@
             <artifactId>async-http-client-api</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-api</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+            <classifier>tests</classifier>
+        </dependency>
     </dependencies>
 </project>
\ No newline at end of file
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
new file mode 100644
index 000000000..66119acdb
--- /dev/null
+++ b/extras/registry/pom.xml
@@ -0,0 +1,30 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <version>2.0.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-extras-registry</artifactId>
+    <name>Asynchronous Http Client Registry Extras</name>
+    <description>
+        The Async Http Client Registry Extras.
+    </description>
+
+
+    <dependencies>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-netty-provider</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-grizzly-provider</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
\ No newline at end of file
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
new file mode 100644
index 000000000..90457a924
--- /dev/null
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.lang.reflect.Constructor;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * The AsyncHttpClientFactory returns back an instance of AsyncHttpClient. The
+ * actual instance is determined by the system property
+ * 'org.async.http.client.impl'. If the system property doesn't exist then it
+ * checks for a property file 'asynchttpclient.properties' and looks for a
+ * property 'org.async.http.client.impl' in there. If it finds it then returns
+ * an instance of that class. If there is an exception while reading the
+ * properties file or system property it throws a RuntimeException
+ * AsyncHttpClientImplException. If any of the constructors of the instance
+ * throws an exception it thows a AsyncHttpClientImplException. By default if
+ * neither the system property or the property file exists then it will return
+ * the default instance of {@link DefaultAsyncHttpClient}
+ * 
+ * @author sasurendran
+ * 
+ */
+public class AsyncHttpClientFactory {
+
+    private static Class<AsyncHttpClient> asyncHttpClientImplClass = null;
+    private static volatile boolean instantiated = false;
+    public static final Logger logger = LoggerFactory.getLogger(AsyncHttpClientFactory.class);
+    private static Lock lock = new ReentrantLock();
+
+    public static AsyncHttpClient getAsyncHttpClient() {
+
+        try {
+            if (attemptInstantiation())
+                return (AsyncHttpClient) asyncHttpClientImplClass.newInstance();
+        } catch (InstantiationException e) {
+            throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
+                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+        } catch (IllegalAccessException e) {
+            throw new AsyncHttpClientImplException("Unable to find the class specified by system property : "
+                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+        }
+        return new DefaultAsyncHttpClient();
+    }
+
+    public static AsyncHttpClient getAsyncHttpClient(AsyncHttpProvider provider) {
+        if (attemptInstantiation()) {
+            try {
+                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpProvider.class);
+                return constructor.newInstance(provider);
+            } catch (Exception e) {
+                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+            }
+        }
+        return new DefaultAsyncHttpClient(provider);
+    }
+
+    public static AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        if (attemptInstantiation()) {
+            try {
+                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpClientConfig.class);
+                return constructor.newInstance(config);
+            } catch (Exception e) {
+                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+            }
+        }
+        return new DefaultAsyncHttpClient(config);
+    }
+
+    public static AsyncHttpClient getAsyncHttpClient(AsyncHttpProvider provider, AsyncHttpClientConfig config) {
+        if (attemptInstantiation()) {
+            try {
+                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpProvider.class,
+                        AsyncHttpClientConfig.class);
+                return constructor.newInstance(provider, config);
+            } catch (Exception e) {
+                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+            }
+        }
+        return new DefaultAsyncHttpClient(provider, config);
+    }
+
+    public static AsyncHttpClient getAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+        if (attemptInstantiation()) {
+            try {
+                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(String.class,
+                        AsyncHttpClientConfig.class);
+                return constructor.newInstance(providerClass, config);
+            } catch (Exception e) {
+                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+            }
+        }
+        return new DefaultAsyncHttpClient(providerClass, config);
+    }
+
+    private static boolean attemptInstantiation() {
+        if (!instantiated) {
+            lock.lock();
+            try {
+                if (!instantiated) {
+                    asyncHttpClientImplClass = AsyncImplHelper.getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+                    instantiated = true;
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
+        return asyncHttpClientImplClass != null;
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
similarity index 59%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
rename to extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
index 7c381c111..f59bf0698 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTest;
+@SuppressWarnings("serial")
+public class AsyncHttpClientImplException extends RuntimeException {
 
-public class NettyProxyTest extends ProxyTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+    public AsyncHttpClientImplException(String msg) {
+        super(msg);
     }
 
+    public AsyncHttpClientImplException(String msg, Exception e) {
+        super(msg, e);
+    }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
new file mode 100644
index 000000000..ca63009ce
--- /dev/null
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHttpClient;
+
+import java.util.Set;
+
+public interface AsyncHttpClientRegistry {
+
+    /**
+     * Returns back the AsyncHttpClient associated with this name
+     * 
+     * @param clientName
+     * @return
+     */
+    AsyncHttpClient get(String clientName);
+
+    /**
+     * Registers this instance of AsyncHttpClient with this name and returns
+     * back a null if an instance with the same name never existed but will return back the
+     * previous instance if there was another instance registered with the same
+     * name and has been replaced by this one.
+     * 
+     * @param name
+     * @param ahc
+     * @return
+     */
+    AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc);
+
+    /**
+     * Will register only if an instance with this name doesn't exist and if it
+     * does exist will not replace this instance and will return false. Use it in the 
+     * following way:
+     * <blockquote><pre>
+     *      AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();      
+     *      if(!AsyncHttpClientRegistryImpl.getInstance().registerIfNew(MyAHC,ahc)){
+     *          //An instance with this name is already registered so close ahc 
+     *          ahc.close(); 
+     *          //and do necessary cleanup
+     *      }
+     * </pre></blockquote>
+     * 
+     * @param name
+     * @param ahc
+     * @return
+     */
+
+    boolean registerIfNew(String name, AsyncHttpClient ahc);
+
+    /**
+     * Remove the instance associate with this name
+     * 
+     * @param name
+     * @return
+     */
+
+    boolean unRegister(String name);
+
+    /**
+     * Returns back all registered names
+     * 
+     * @return
+     */
+
+    Set<String> getAllRegisteredNames();
+
+    /**
+     * Removes all instances from this registry.
+     */
+
+    void clearAllInstances();
+}
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
new file mode 100644
index 000000000..0c13c2e58
--- /dev/null
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHttpClient;
+
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class AsyncHttpClientRegistryImpl implements AsyncHttpClientRegistry {
+
+    private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<String, AsyncHttpClient>();
+    private static volatile AsyncHttpClientRegistry _instance;
+    private static Lock lock = new ReentrantLock();
+
+    /**
+     * Returns a singleton instance of AsyncHttpClientRegistry
+     * @return
+     */
+    public static AsyncHttpClientRegistry getInstance() {
+        if (_instance == null) {
+            lock.lock();
+            try {
+                if (_instance == null) {
+                    Class<?> asyncHttpClientRegistryImplClass = AsyncImplHelper
+                            .getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+                    if (asyncHttpClientRegistryImplClass != null)
+                        _instance = (AsyncHttpClientRegistry) asyncHttpClientRegistryImplClass.newInstance();
+                    else
+                        _instance = new AsyncHttpClientRegistryImpl();
+                }
+            } catch (InstantiationException e) {
+                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
+            } catch (IllegalAccessException e) {
+                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
+            } finally {
+                lock.unlock();
+            }
+        }
+        return _instance;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#get(java.lang.String)
+     */
+    @Override
+    public AsyncHttpClient get(String clientName) {
+        return asyncHttpClientMap.get(clientName);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#register(java.lang.String,
+     * org.asynchttpclient.AsyncHttpClient)
+     */
+    @Override
+    public AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc) {
+        return asyncHttpClientMap.put(name, ahc);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#registerIfNew(java.lang.
+     * String, org.asynchttpclient.AsyncHttpClient)
+     */
+    @Override
+    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
+        return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#unRegister(java.lang.String)
+     */
+    @Override
+    public boolean unRegister(String name) {
+        return asyncHttpClientMap.remove(name) != null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#getAllRegisteredNames()
+     */
+    @Override
+    public Set<String> getAllRegisteredNames() {
+        return asyncHttpClientMap.keySet();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#clearAllInstances()
+     */
+    @Override
+    public void clearAllInstances() {
+        asyncHttpClientMap.clear();
+    }
+}
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
new file mode 100644
index 000000000..6d3803c64
--- /dev/null
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.util.AsyncPropertiesHelper;
+
+import com.typesafe.config.ConfigException;
+
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+
+public class AsyncImplHelper {
+
+    public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
+    public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
+    
+    /*
+     * Returns the class specified by either a system property or a properties
+     * file as the class to instantiated for the AsyncHttpClient. Returns null
+     * if property is not found and throws an AsyncHttpClientImplException if
+     * the specified class couldn't be created.
+     */
+    public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
+        try {
+            String asyncHttpClientImplClassName = AsyncPropertiesHelper.getAsyncHttpClientConfig().getString(propertyName);
+            Class<AsyncHttpClient> asyncHttpClientImplClass = AsyncImplHelper.getClass(asyncHttpClientImplClassName);
+            return asyncHttpClientImplClass;
+        }catch(ConfigException configException) {
+            return null;
+        }
+    }
+
+    private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
+        try {
+            return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<AsyncHttpClient>>() {
+                @SuppressWarnings("unchecked")
+                public Class<AsyncHttpClient> run() throws ClassNotFoundException {
+                    ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                    if (cl != null)
+                        try {
+                            return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+                        } catch (ClassNotFoundException e) {
+                            AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName
+                                    + " in thread context classpath " + "checking system class path next", e);
+                        }
+
+                    cl = ClassLoader.getSystemClassLoader();
+                    return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+                }
+            });
+        } catch (PrivilegedActionException e) {
+            throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : "
+                    + e.getMessage(), e);
+        }
+    }
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
new file mode 100644
index 000000000..b39946085
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.util.EchoHandler;
+import org.asynchttpclient.async.util.TestUtils;
+import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
+import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
+import org.asynchttpclient.extras.registry.AsyncImplHelper;
+import org.asynchttpclient.util.AsyncPropertiesHelper;
+import org.eclipse.jetty.server.Server;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import java.lang.reflect.InvocationTargetException;
+
+import junit.extensions.PA;
+
+public abstract class AbstractAsyncHttpClientFactoryTest {
+
+    public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
+    public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
+    public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
+    
+    private Server server;
+    private int port;
+
+    @BeforeMethod
+    public void setUp() {
+        PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
+        PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+        AsyncPropertiesHelper.reloadProperties();
+    }
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpBeforeTest() throws Exception {
+        port = TestUtils.findFreePort();
+        server = TestUtils.newJettyHttpServer(port);
+        server.setHandler(new EchoHandler());
+        server.start();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDown() throws Exception {
+        setUp();
+        if (server != null)
+            server.stop();
+    }
+
+    public abstract AsyncHttpProvider getAsyncHttpProvider(AsyncHttpClientConfig config);
+
+    /**
+     * If the property is not found via the system property or properties file
+     * the default instance of AsyncHttpClient should be returned.
+     */
+    // ================================================================================================================
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClient() {
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+        assertClientWorks(asyncHttpClient);
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfig() {
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+        assertClientWorks(asyncHttpClient);
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientProvider() {
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
+        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+        assertClientWorks(asyncHttpClient);
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfigAndProvider() {
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null),
+                new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+        assertClientWorks(asyncHttpClient);
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientStringConfig() {
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
+                new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+        assertClientWorks(asyncHttpClient);
+    }
+
+    // ==================================================================================================================================
+
+    /**
+     * If the class is specified via a system property then that class should be
+     * returned
+     */
+    // ===================================================================================================================================
+    @Test(groups = "fast")
+    public void testFactoryWithSystemProperty() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        Assert.assertTrue(AsyncHttpClientFactory.getAsyncHttpClient().getClass().equals(TestAsyncHttpClient.class));
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfigWithSystemProperty() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientProviderWithSystemProperty() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
+        Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfigAndProviderWithSystemProperty() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null),
+                new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientStringConfigWithSystemProperty() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
+                new AsyncHttpClientConfig.Builder().build());
+        Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
+    }
+
+    // ===================================================================================================================================
+
+    /**
+     * If any of the constructors of the class fail then a
+     * AsyncHttpClientException is thrown.
+     */
+    // ===================================================================================================================================
+    @Test(groups = "fast", expectedExceptions = BadAsyncHttpClientException.class)
+    public void testFactoryWithBadAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientConfigAndProviderWithBadAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null), new AsyncHttpClientConfig.Builder().build());
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    @Test(groups = "fast")
+    public void testGetAsyncHttpClientStringConfigWithBadAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
+                    new AsyncHttpClientConfig.Builder().build());
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    // ===================================================================================================================================
+
+    /*
+     * If the system property exists instantiate the class else if the class is
+     * not found throw an AsyncHttpClientException.
+     */
+    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testFactoryWithNonExistentAsyncHttpClient() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    /**
+     * If property is specified but the class cant be created or found for any
+     * reason subsequent calls should throw an AsyncClientException.
+     */
+    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testRepeatedCallsToBadAsyncHttpClient() {
+        boolean exceptionCaught = false;
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient();
+        } catch (AsyncHttpClientImplException e) {
+            exceptionCaught = true;
+        }
+        Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
+        exceptionCaught = false;
+        try {
+            AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        } catch (AsyncHttpClientImplException e) {
+            exceptionCaught = true;
+        }
+        Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
+        AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
+                new AsyncHttpClientConfig.Builder().build());
+
+    }
+
+    private void assertClientWorks(AsyncHttpClient asyncHttpClient) {
+        Response response;
+        try {
+            response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } catch (Exception e) {
+            Assert.fail("Failed while making call with AsyncHttpClient", e);
+        } finally {
+            asyncHttpClient.close();
+        }
+    }
+
+    private void assertException(AsyncHttpClientImplException e) {
+        InvocationTargetException t = (InvocationTargetException) e.getCause();
+        Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
+    }
+
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
new file mode 100644
index 000000000..b250a9d65
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
+import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+import org.asynchttpclient.extras.registry.AsyncImplHelper;
+import org.asynchttpclient.util.AsyncPropertiesHelper;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import junit.extensions.PA;
+
+public class AsyncHttpClientRegistryTest {
+
+    private static final String TEST_AHC = "testAhc";
+
+    @BeforeMethod
+    public void setUp() {
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+        PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
+    }
+
+    @BeforeClass
+    public void setUpBeforeTest() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
+    }
+
+    @AfterClass
+    public void tearDown() {
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+    }
+
+    @Test(groups = "fast")
+    public void testGetAndRegister() {
+        AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+        Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+    }
+
+    @Test(groups = "fast")
+    public void testDeRegister() {
+        AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unRegister(TEST_AHC));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unRegister(TEST_AHC));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+    }
+
+    @Test(groups = "fast")
+    public void testRegisterIfNew() {
+        AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
+        AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+        Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
+        Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
+    }
+
+    @Test(groups = "fast")
+    public void testClearAllInstances() {
+        AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
+        AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient();
+        AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient();
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
+        Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+        AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+        Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
+    }
+
+    @Test(groups = "fast")
+    public void testCustomAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
+        AsyncPropertiesHelper.reloadProperties();
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
+    }
+
+    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testNonExistentAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance();
+        Assert.fail("Should never have reached here");
+    }
+
+    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testBadAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
+        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance();
+        Assert.fail("Should never have reached here");
+    }
+
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
new file mode 100644
index 000000000..84343ec0d
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SignatureCalculator;
+
+import java.io.IOException;
+
+public class BadAsyncHttpClient implements AsyncHttpClient {
+
+    public BadAsyncHttpClient() {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(AsyncHttpProvider provider) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(AsyncHttpClientConfig config) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(AsyncHttpProvider httpProvider, AsyncHttpClientConfig config) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    @Override
+    public AsyncHttpProvider getProvider() {
+        return null;
+    }
+
+    @Override
+    public void close() {
+
+    }
+
+    @Override
+    public void closeAsynchronously() {
+
+    }
+
+    @Override
+    public boolean isClosed() {
+        return false;
+    }
+
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return null;
+    }
+
+    @Override
+    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
+        return null;
+    }
+
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
new file mode 100644
index 000000000..1aca098e8
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
+
+@SuppressWarnings("serial")
+public class BadAsyncHttpClientException extends AsyncHttpClientImplException {
+
+    public BadAsyncHttpClientException(String msg) {
+        super(msg);
+    }
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
new file mode 100644
index 000000000..b3d853de3
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+
+public class BadAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
+
+    private BadAsyncHttpClientRegistry() {
+        throw new RuntimeException("I am bad");
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java
similarity index 51%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
rename to extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java
index 1c1bea893..cfa9c9d4b 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,16 +10,22 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamHandlerTest;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.extras.registry.AbstractAsyncHttpClientFactoryTest;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.testng.annotations.Test;
 
-public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
+@Test
+public class GrizzlyAsyncHttpClientFactoryTest extends AbstractAsyncHttpClientFactoryTest {
 
     @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+    public AsyncHttpProvider getAsyncHttpProvider(AsyncHttpClientConfig config) {
+        if (config == null) {
+            config = new AsyncHttpClientConfig.Builder().build();
+        }
+        return new GrizzlyAsyncHttpProvider(config);
     }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
similarity index 51%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
rename to extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
index e8dacd968..a5cc1fa02 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,16 +10,22 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyChunkTest;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.extras.registry.AbstractAsyncHttpClientFactoryTest;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProvider;
+import org.testng.annotations.Test;
 
-public class NettyBodyChunkTest extends BodyChunkTest {
+@Test
+public class NettyAsyncHttpClientFactoryTest extends AbstractAsyncHttpClientFactoryTest {
 
     @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+    public AsyncHttpProvider getAsyncHttpProvider(AsyncHttpClientConfig config) {
+        if (config == null) {
+            config = new AsyncHttpClientConfig.Builder().build();
+        }
+        return new NettyAsyncHttpProvider(config);
     }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
new file mode 100644
index 000000000..9d927287f
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SignatureCalculator;
+
+import java.io.IOException;
+
+public class TestAsyncHttpClient implements AsyncHttpClient {
+
+    public TestAsyncHttpClient() {
+    }
+
+    public TestAsyncHttpClient(AsyncHttpProvider provider) {
+    }
+
+    public TestAsyncHttpClient(AsyncHttpClientConfig config) {
+    }
+
+    public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+    }
+
+    public TestAsyncHttpClient(AsyncHttpProvider httpProvider, AsyncHttpClientConfig config) {
+    }
+
+    @Override
+    public AsyncHttpProvider getProvider() {
+        return null;
+    }
+
+    @Override
+    public void close() {
+    }
+
+    @Override
+    public void closeAsynchronously() {
+    }
+
+    @Override
+    public boolean isClosed() {
+        return false;
+    }
+
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return null;
+    }
+
+    @Override
+    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
+        return null;
+    }
+
+}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
new file mode 100644
index 000000000..b9410737d
--- /dev/null
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.registry;
+
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+
+public class TestAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
+
+}
diff --git a/providers/netty-4/src/test/resources/300k.png b/extras/registry/src/test/resources/300k.png
similarity index 100%
rename from providers/netty-4/src/test/resources/300k.png
rename to extras/registry/src/test/resources/300k.png
diff --git a/providers/netty-4/src/test/resources/SimpleTextFile.txt b/extras/registry/src/test/resources/SimpleTextFile.txt
similarity index 100%
rename from providers/netty-4/src/test/resources/SimpleTextFile.txt
rename to extras/registry/src/test/resources/SimpleTextFile.txt
diff --git a/pom.xml b/pom.xml
index 5227949fc..a4e54d8de 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.sonatype.oss</groupId>
         <artifactId>oss-parent</artifactId>
@@ -215,7 +214,6 @@
                 </executions>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-resources-plugin</artifactId>
                 <version>2.4.3</version>
                 <configuration>
@@ -223,12 +221,9 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-release-plugin</artifactId>
-                <version>2.1</version>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
                 <version>2.3.1</version>
                 <executions>
@@ -240,7 +235,6 @@
                 </executions>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
                 <version>2.1.2</version>
                 <executions>
@@ -254,12 +248,10 @@
                 </executions>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-site-plugin</artifactId>
                 <version>3.0</version>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
                 <version>2.8.1</version>
                 <configuration>
@@ -281,81 +273,11 @@
                     </execution>
                 </executions>
             </plugin>
-            <!--
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-shade-plugin</artifactId>
-                <version>1.2.1</version>
-                <executions>
-                    <execution>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>shade</goal>
-                        </goals>
-                        <configuration>
-                            <shadedArtifactAttached>true</shadedArtifactAttached>
-                            <shadedClassifierName>shaded</shadedClassifierName>
-                            <artifactSet>
-                                <excludes>
-                                    <exclude>commons-codec:commons-codec</exclude>
-                                    <exclude>commons-lang:commons-lang</exclude>
-                                    <exclude>commons-logging:commons-logging</exclude>
-                                    <exclude>junit:junit</exclude>
-                                    <exclude>log4j:log4j</exclude>
-                                </excludes>
-                            </artifactSet>
-                            <transformers>
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" />
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer" />
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer" />
-                            </transformers>
-                        </configuration>
-                    </execution>
-                </executions>
-            </plugin>
-            -->
-            <!--
-            <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>clirr-maven-plugin</artifactId>
-                <version>2.3</version>
-                <configuration>
-                    <excludes>
-                        <exclude>**/NettyAsyncHttpProvider$*</exclude>
-                        <exclude>**/AsyncHandler$STATE</exclude>
-                        <exclude>**/ProxyServer$Protocol</exclude>
-                        <exclude>**/Realm$AuthScheme</exclude>
-                        <exclude>**/SimpleAsyncHttpClient$ErrorDocumentBehaviour</exclude>
-                        <exclude>**/SpnegoEngine</exclude>
-                        <exclude>**/Request</exclude>
-                        <exclude>**/Request$EntityWriter</exclude>
-                        <exclude>**/RequestBuilderBase</exclude>
-                        <exclude>**/Response</exclude>
-                        <exclude>**/Response$*</exclude>
-                        <exclude>**/FilterContext</exclude>
-                        <exclude>**/FilterContext$*</exclude>
-                        <exclude>**/NettyResponseFuture</exclude>
-                        <exclude>**/**ResponseBodyPart</exclude>
-                        <exclude>**/**WebSocket</exclude>
-                    </excludes>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>check-api-compat</id>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>check-no-fork</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            -->
         </plugins>
     </build>
     <reporting>
         <plugins>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
                 <version>2.8.1</version>
                 <configuration>
@@ -376,8 +298,10 @@
                         <version>1.0.3</version>
                     </docletArtifact>
                     <additionalparam>
-                        -hdf project.name "${project.name} ${project.version}"
-                        -d ${project.reporting.outputDirectory}/apidocs
+                        -hdf project.name "${project.name}
+                        ${project.version}"
+                        -d
+                        ${project.reporting.outputDirectory}/apidocs
                     </additionalparam>
                 </configuration>
                 <reportSets>
@@ -390,7 +314,6 @@
                 </reportSets>
             </plugin>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-report-plugin</artifactId>
                 <version>${surefire.version}</version>
             </plugin>
@@ -408,7 +331,6 @@
             <build>
                 <plugins>
                     <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
                         <executions>
                             <execution>
@@ -428,7 +350,6 @@
             <build>
                 <plugins>
                     <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-surefire-plugin</artifactId>
                         <configuration>
                             <groups>standalone</groups>
@@ -445,7 +366,6 @@
             <build>
                 <plugins>
                     <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-surefire-plugin</artifactId>
                         <configuration>
                             <groups>standalone, online</groups>
@@ -460,8 +380,7 @@
         <profile>
             <id>test-output</id>
             <properties>
-                <surefire.redirectTestOutputToFile>false
-                </surefire.redirectTestOutputToFile>
+                <surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
             </properties>
         </profile>
     </profiles>
@@ -499,92 +418,122 @@
         <dependency>
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
-            <version>1.0.13</version>
+            <version>${logback.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
-            <version>1.2.13</version>
+            <version>${log4j.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.testng</groupId>
             <artifactId>testng</artifactId>
-            <version>5.8</version>
+            <version>${testng.version}</version>
             <scope>test</scope>
-            <classifier>jdk15</classifier>
+            <exclusions>
+                <exclusion>
+                    <groupId>junit</groupId>
+                    <artifactId>junit</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>org.beanshell</groupId>
+                    <artifactId>bsh</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>org.yaml</groupId>
+                    <artifactId>snakeyaml</artifactId>
+                </exclusion>
+            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-server</artifactId>
-            <version>8.1.1.v20120215</version>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-servlet</artifactId>
-            <version>8.1.1.v20120215</version>
+            <artifactId>jetty-servlets</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-websocket</artifactId>
-            <version>8.1.1.v20120215</version>
+            <artifactId>jetty-security</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-servlets</artifactId>
-            <version>8.1.1.v20120215</version>
+            <artifactId>jetty-proxy</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-security</artifactId>
-            <version>8.1.1.v20120215</version>
+            <groupId>org.eclipse.jetty.websocket</groupId>
+            <artifactId>websocket-server</artifactId>
+            <version>${jetty.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty.websocket</groupId>
+            <artifactId>websocket-servlet</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.apache.tomcat</groupId>
             <artifactId>coyote</artifactId>
-            <version>6.0.29</version>
+            <version>${tomcat.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.apache.tomcat</groupId>
             <artifactId>catalina</artifactId>
-            <version>6.0.29</version>
+            <version>${tomcat.version}</version>
             <scope>test</scope>
             <exclusions>
                 <exclusion>
-                    <artifactId>servlet-api</artifactId>
                     <groupId>org.apache.tomcat</groupId>
+                    <artifactId>servlet-api</artifactId>
                 </exclusion>
             </exclusions>
         </dependency>
         <dependency>
             <groupId>commons-io</groupId>
             <artifactId>commons-io</artifactId>
-            <version>2.0.1</version>
+            <version>${commons-io.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>commons-fileupload</groupId>
             <artifactId>commons-fileupload</artifactId>
-            <version>1.2.2</version>
+            <version>${commons-fileupload.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+		  <groupId>com.e-movimento.tinytools</groupId>
+		  <artifactId>privilegedaccessor</artifactId>
+		  <version>${privilegedaccessor.version}</version>
+		  <scope>test</scope>
+		</dependency>
     </dependencies>
     <properties>
-        <distMgmtSnapshotsUrl>
-            http://oss.sonatype.org/content/repositories/snapshots
-        </distMgmtSnapshotsUrl>
-        <surefire.redirectTestOutputToFile>true
-        </surefire.redirectTestOutputToFile>
+        <distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
+        <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
         <source.property>1.6</source.property>
         <target.property>1.6</target.property>
-        <surefire.version>2.12</surefire.version>
+        <surefire.version>2.16</surefire.version>
+        <logback.version>1.0.13</logback.version>
+        <log4j.version>1.2.17</log4j.version>
+        <testng.version>6.8.7</testng.version>
+        <jetty.version>9.0.5.v20130815</jetty.version>
+        <tomcat.version>6.0.29</tomcat.version>
+        <commons-io.version>2.4</commons-io.version>
+        <commons-fileupload.version>1.3</commons-fileupload.version>
+        <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
     </properties>
 </project>
 
diff --git a/providers/grizzly/pom.xml b/providers/grizzly/pom.xml
index 57f9ed182..269aea00b 100644
--- a/providers/grizzly/pom.xml
+++ b/providers/grizzly/pom.xml
@@ -14,8 +14,8 @@
     </description>
 
     <properties>
-        <grizzly.version>2.3.4-SNAPSHOT</grizzly.version>
-        <grizzly.npn.version>1.0</grizzly.npn.version>
+        <grizzly.version>2.3.16</grizzly.version>
+        <grizzly.npn.version>1.1</grizzly.npn.version>
     </properties>
 
     <dependencies>
@@ -39,6 +39,12 @@
             <artifactId>grizzly-npn-api</artifactId>
             <version>${grizzly.npn.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.glassfish.grizzly</groupId>
+            <artifactId>grizzly-http-server</artifactId>
+            <version>${grizzly.version}</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 
     <repositories>
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
index 51fc80a16..161a7accd 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,10 +13,13 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.CompletionHandler;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.Grizzly;
@@ -27,42 +30,43 @@
 import org.glassfish.grizzly.impl.FutureImpl;
 import org.glassfish.grizzly.utils.Futures;
 import org.glassfish.grizzly.utils.IdleTimeoutFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.net.ssl.HostnameVerifier;
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.net.URI;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeoutException;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter;
 
 public class ConnectionManager {
 
-    private static final Attribute<Boolean> DO_NOT_CACHE =
-        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(ConnectionManager.class.getName());
+    private final static Logger LOGGER = LoggerFactory.getLogger(ConnectionManager.class);
+
+    private static final Attribute<Boolean> DO_NOT_CACHE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(ConnectionManager.class
+            .getName());
     private final ConnectionPool connectionPool;
     private final GrizzlyAsyncHttpProvider provider;
     private final boolean canDestroyPool;
-    private final Map<String,EndpointKey<SocketAddress>> endpointKeyMap = new HashMap<String,EndpointKey<SocketAddress>>();
+    private final Map<String, EndpointKey<SocketAddress>> endpointKeyMap = new HashMap<String, EndpointKey<SocketAddress>>();
     private final FilterChainBuilder secureBuilder;
     private final FilterChainBuilder nonSecureBuilder;
     private final boolean asyncConnect;
 
-
     // ------------------------------------------------------------ Constructors
 
-
-    @SuppressWarnings("unchecked")
-    ConnectionManager(final GrizzlyAsyncHttpProvider provider,
-                      final ConnectionPool connectionPool,
-                      final FilterChainBuilder secureBuilder,
-                      final FilterChainBuilder nonSecureBuilder) {
-
+    ConnectionManager(final GrizzlyAsyncHttpProvider provider,//
+            final ConnectionPool connectionPool,//
+            final FilterChainBuilder secureBuilder,//
+            final FilterChainBuilder nonSecureBuilder) {
 
         this.provider = provider;
         final AsyncHttpClientConfig config = provider.getClientConfig();
@@ -70,34 +74,39 @@
             this.connectionPool = connectionPool;
             canDestroyPool = false;
         } else {
-            this.connectionPool =
-                    new ConnectionPool(config.getMaxConnectionPerHost(),
-                                       config.getMaxTotalConnections(),
-                                       null,
-                                       config.getConnectionTimeoutInMs(),
-                                       config.getIdleConnectionInPoolTimeoutInMs(),
-                                       2000);
+            this.connectionPool = new ConnectionPool(config.getMaxConnectionsPerHost(),//
+                    config.getMaxConnections(),//
+                    null,//
+                    config.getConnectionTimeout(),//
+                    config.getPooledConnectionIdleTimeout(),//
+                    2000);
             canDestroyPool = true;
         }
         this.secureBuilder = secureBuilder;
         this.nonSecureBuilder = nonSecureBuilder;
-        asyncConnect = config.isAsyncConnectMode();
-
+        AsyncHttpProviderConfig<?, ?> providerConfig = config.getAsyncHttpProviderConfig();
+        asyncConnect = providerConfig instanceof GrizzlyAsyncHttpProviderConfig ? GrizzlyAsyncHttpProviderConfig.class.cast(providerConfig)
+                .isAsyncConnectMode() : false;
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
-    public void doTrackedConnection(final Request request,
-                                    final GrizzlyResponseFuture requestFuture,
-                                    final CompletionHandler<Connection> connectHandler)
-    throws IOException {
-        final EndpointKey<SocketAddress> key =
-                getEndPointKey(request, requestFuture.getProxyServer());
-
+    public void doTrackedConnection(final Request request,//
+            final GrizzlyResponseFuture requestFuture,//
+            CompletionHandler<Connection> completionHandler) throws IOException {
+        final EndpointKey<SocketAddress> key = getEndPointKey(request, requestFuture.getProxyServer());
+        
+        final HostnameVerifier verifier = getVerifier();
+        final Uri uri = request.getUri();
+        
+        if (Utils.isSecure(uri) && verifier != null) {
+            completionHandler =
+                    SwitchingSSLFilter.wrapWithHostnameVerifierHandler(
+                            completionHandler, verifier, uri.getHost());
+        }
+        
         if (asyncConnect) {
-            connectionPool.take(key, connectHandler);
+            connectionPool.take(key, completionHandler);
         } else {
             IOException ioe = null;
             GrizzlyFuture<Connection> future = connectionPool.take(key);
@@ -105,18 +114,18 @@ public void doTrackedConnection(final Request request,
                 // No explicit timeout when calling get() here as the Grizzly
                 // endpoint pool will time it out based on the connect timeout
                 // setting.
-                connectHandler.completed(future.get());
+                completionHandler.completed(future.get());
             } catch (CancellationException e) {
-                connectHandler.cancelled();
+                completionHandler.cancelled();
             } catch (ExecutionException ee) {
                 final Throwable cause = ee.getCause();
                 if (cause instanceof ConnectionPool.MaxCapacityException) {
                     ioe = (IOException) cause;
                 } else {
-                    connectHandler.failed(ee.getCause());
+                    completionHandler.failed(ee.getCause());
                 }
             } catch (Exception ie) {
-                connectHandler.failed(ie);
+                completionHandler.failed(ie);
             }
             if (ioe != null) {
                 throw ioe;
@@ -124,9 +133,8 @@ public void doTrackedConnection(final Request request,
         }
     }
 
-    public Connection obtainConnection(final Request request,
-                                       final GrizzlyResponseFuture requestFuture)
-    throws ExecutionException, InterruptedException, TimeoutException {
+    public Connection obtainConnection(final Request request, final GrizzlyResponseFuture requestFuture) throws ExecutionException,
+            InterruptedException, TimeoutException, IOException {
 
         final Connection c = obtainConnection0(request, requestFuture);
         markConnectionAsDoNotCache(c);
@@ -136,48 +144,39 @@ public Connection obtainConnection(final Request request,
 
     // --------------------------------------------------Package Private Methods
 
-
     static void markConnectionAsDoNotCache(final Connection c) {
         DO_NOT_CACHE.set(c, Boolean.TRUE);
     }
 
     static boolean isConnectionCacheable(final Connection c) {
-        final Boolean canCache =  DO_NOT_CACHE.get(c);
+        final Boolean canCache = DO_NOT_CACHE.get(c);
         return ((canCache != null) ? canCache : false);
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-    private EndpointKey<SocketAddress> getEndPointKey(final Request request,
-                                                      final ProxyServer proxyServer) {
-        final String stringKey = getPoolKey(request, proxyServer);
+    private HostnameVerifier getVerifier() {
+        return provider.getClientConfig().getHostnameVerifier();
+    }
+
+    private EndpointKey<SocketAddress> getEndPointKey(final Request request, final ProxyServer proxyServer) throws IOException {
+        final String stringKey = getPartitionId(request, proxyServer);
         EndpointKey<SocketAddress> key = endpointKeyMap.get(stringKey);
         if (key == null) {
             synchronized (endpointKeyMap) {
                 key = endpointKeyMap.get(stringKey);
                 if (key == null) {
-                    SocketAddress address =
-                            getRemoteAddress(request, proxyServer);
+                    SocketAddress address = getRemoteAddress(request, proxyServer);
                     InetAddress localAddress = request.getLocalAddress();
                     InetSocketAddress localSocketAddress = null;
                     if (localAddress != null) {
                         localSocketAddress = new InetSocketAddress(localAddress.getHostName(), 0);
                     }
-                    ProxyAwareConnectorHandler handler =
-                            ProxyAwareConnectorHandler
-                                    .builder(provider.clientTransport)
-                                    .setNonSecureFilterChainTemplate(nonSecureBuilder)
-                                    .setSecureFilterChainTemplate(secureBuilder)
-                                    .setAsyncHttpClientConfig(provider.getClientConfig())
-                                    .setURI(request.getURI())
-                                    .setProxyServer(proxyServer)
-                                    .build();
-                    EndpointKey<SocketAddress> localKey =
-                            new EndpointKey<SocketAddress>(stringKey,
-                                               address,
-                                               localSocketAddress,
-                                               handler);
+                    
+                    ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler.builder(provider.clientTransport)
+                            .nonSecureFilterChainTemplate(nonSecureBuilder).secureFilterChainTemplate(secureBuilder)
+                            .asyncHttpClientConfig(provider.getClientConfig()).uri(request.getUri()).proxyServer(proxyServer).build();
+                    EndpointKey<SocketAddress> localKey = new EndpointKey<SocketAddress>(stringKey, address, localSocketAddress, handler);
                     endpointKeyMap.put(stringKey, localKey);
                     key = localKey;
                 }
@@ -186,52 +185,45 @@ static boolean isConnectionCacheable(final Connection c) {
         return key;
     }
 
-    private SocketAddress getRemoteAddress(final Request request,
-                                           final ProxyServer proxyServer) {
-        final URI requestUri = request.getURI();
-        final String host = ((proxyServer != null)
-                ? proxyServer.getHost()
-                : requestUri.getHost());
-        final int port = ((proxyServer != null)
-                ? proxyServer.getPort()
-                : requestUri.getPort());
-        return new InetSocketAddress(host, getPort(request.getURI(), port));
+    private SocketAddress getRemoteAddress(final Request request, final ProxyServer proxyServer) {
+        final Uri requestUri = request.getUri();
+        final String host = ((proxyServer != null) ? proxyServer.getHost() : requestUri.getHost());
+        final int port = ((proxyServer != null) ? proxyServer.getPort() : requestUri.getPort());
+        return new InetSocketAddress(host, getPort(request.getUri(), port));
     }
 
-    private static int getPort(final URI uri, final int p) {
+    private static int getPort(final Uri uri, final int p) {
         int port = p;
         if (port == -1) {
-            final String protocol = uri.getScheme().toLowerCase();
+            final String protocol = uri.getScheme().toLowerCase(Locale.ENGLISH);
             if ("http".equals(protocol) || "ws".equals(protocol)) {
                 port = 80;
             } else if ("https".equals(protocol) || "wss".equals(protocol)) {
                 port = 443;
             } else {
-                throw new IllegalArgumentException(
-                        "Unknown protocol: " + protocol);
+                throw new IllegalArgumentException("Unknown protocol: " + protocol);
             }
         }
         return port;
     }
 
-    private Connection obtainConnection0(final Request request,
-                                         final GrizzlyResponseFuture requestFuture)
-    throws ExecutionException, InterruptedException, TimeoutException {
+    private Connection obtainConnection0(final Request request, final GrizzlyResponseFuture requestFuture) throws ExecutionException,
+            InterruptedException, TimeoutException, IOException {
 
-        final int cTimeout = provider.getClientConfig().getConnectionTimeoutInMs();
+        final int cTimeout = provider.getClientConfig().getConnectionTimeout();
         final FutureImpl<Connection> future = Futures.createSafeFuture();
         final CompletionHandler<Connection> ch = Futures.toCompletionHandler(future,
                 createConnectionCompletionHandler(request, requestFuture, null));
         final ProxyServer proxyServer = requestFuture.getProxyServer();
         final SocketAddress address = getRemoteAddress(request, proxyServer);
-        ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler
-                            .builder(provider.clientTransport)
-                            .setNonSecureFilterChainTemplate(nonSecureBuilder)
-                            .setSecureFilterChainTemplate(secureBuilder)
-                            .setAsyncHttpClientConfig(provider.getClientConfig())
-                            .setURI(request.getURI())
-                            .setProxyServer(proxyServer)
-                            .build();
+
+        ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler.builder(provider.clientTransport)
+                .nonSecureFilterChainTemplate(nonSecureBuilder)//
+                .secureFilterChainTemplate(secureBuilder)//
+                .asyncHttpClientConfig(provider.getClientConfig())//
+                .uri(request.getUri())//
+                .proxyServer(proxyServer)//
+                .build();
         if (cTimeout > 0) {
             handler.connect(address, ch);
             return future.get(cTimeout, MILLISECONDS);
@@ -242,29 +234,26 @@ private Connection obtainConnection0(final Request request,
     }
 
     boolean returnConnection(final Connection c) {
-        final boolean result = (DO_NOT_CACHE.get(c) == null
-                                   && connectionPool.release(c));
+        final boolean result = (DO_NOT_CACHE.get(c) == null && connectionPool.release(c));
         if (result) {
             if (provider.getResolver() != null) {
                 provider.getResolver().setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
             }
         }
         return result;
-
     }
 
-
     void destroy() {
-
         if (canDestroyPool) {
             connectionPool.close();
         }
-
     }
 
-    CompletionHandler<Connection> createConnectionCompletionHandler(final Request request,
-                                                                    final GrizzlyResponseFuture future,
-                                                                    final CompletionHandler<Connection> wrappedHandler) {
+    CompletionHandler<Connection> createConnectionCompletionHandler(//
+            final Request request,//
+            final GrizzlyResponseFuture future,//
+            final CompletionHandler<Connection> wrappedHandler) {
+
         return new CompletionHandler<Connection>() {
             public void cancelled() {
                 if (wrappedHandler != null) {
@@ -299,10 +288,7 @@ public void updated(Connection result) {
         };
     }
 
-    private static String getPoolKey(final Request request, ProxyServer proxyServer) {
-        final ConnectionPoolKeyStrategy keyStrategy = request.getConnectionPoolKeyStrategy();
-        URI uri = proxyServer != null ? proxyServer.getURI() : request.getURI();
-        return keyStrategy.getKey(uri);
+    private static String getPartitionId(final Request request, ProxyServer proxyServer) {
+        return request.getConnectionPoolPartitioning().getPartitionId(request.getUri(), proxyServer);
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
index dae88f302..11197930d 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
@@ -13,6 +13,10 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import org.glassfish.grizzly.CompletionHandler;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.EmptyCompletionHandler;
+import org.glassfish.grizzly.GrizzlyFuture;
 import org.glassfish.grizzly.connectionpool.EndpointKey;
 import org.glassfish.grizzly.connectionpool.MultiEndpointPool;
 import org.glassfish.grizzly.connectionpool.SingleEndpointPool;
@@ -27,31 +31,33 @@
  * @since 2.0
  * @author The Grizzly Team
  */
-public class ConnectionPool extends MultiEndpointPool<SocketAddress>{
+public class ConnectionPool extends MultiEndpointPool<SocketAddress> {
 
+    private final Object lock = new Object();
 
     // ------------------------------------------------------------ Constructors
 
-
-    public ConnectionPool(final int maxConnectionsPerEndpoint,
-                          final int maxConnectionsTotal,
-                          final DelayedExecutor delayedExecutor,
-                          final long connectTimeoutMillis,
-                          final long keepAliveTimeoutMillis,
-                          final long keepAliveCheckIntervalMillis) {
-        super(null, maxConnectionsPerEndpoint,
-              maxConnectionsTotal, delayedExecutor, connectTimeoutMillis,
-              keepAliveTimeoutMillis, keepAliveCheckIntervalMillis, -1, -1);
+    public ConnectionPool(final int maxConnectionsPerEndpoint,//
+            final int maxConnectionsTotal,//
+            final DelayedExecutor delayedExecutor,//
+            final long connectTimeoutMillis,//
+            final long keepAliveTimeoutMillis,//
+            final long keepAliveCheckIntervalMillis) {
+        super(null,//
+                maxConnectionsPerEndpoint,//
+                maxConnectionsTotal,//
+                delayedExecutor,//
+                connectTimeoutMillis,//
+                keepAliveTimeoutMillis,//
+                keepAliveCheckIntervalMillis,//
+                -1,//
+                -1);
     }
 
-
     // ------------------------------------------ Methods from MultiEndpointPool
 
-
-    protected SingleEndpointPool<SocketAddress> obtainSingleEndpointPool(
-            final EndpointKey<SocketAddress> endpointKey) throws IOException {
-        SingleEndpointPool<SocketAddress> sePool =
-                endpointToPoolMap.get(endpointKey);
+    protected SingleEndpointPool<SocketAddress> obtainSingleEndpointPool(final EndpointKey<SocketAddress> endpointKey) throws IOException {
+        SingleEndpointPool<SocketAddress> sePool = endpointToPoolMap.get(endpointKey);
         if (sePool == null) {
             synchronized (poolSync) {
                 checkNotClosed();
@@ -69,16 +75,68 @@ public ConnectionPool(final int maxConnectionsPerEndpoint,
         return sePool;
     }
 
+    @Override
+    public GrizzlyFuture<Connection> take(final EndpointKey<SocketAddress> endpointKey) {
+        synchronized (lock) {
+            final GrizzlyFuture<Connection> f = super.take(endpointKey);
+            f.addCompletionHandler(new EmptyCompletionHandler<Connection>() {
+                @Override
+                public void completed(Connection result) {
+                    if (Utils.isSpdyConnection(result)) {
+                        release(result);
+                    }
+                    super.completed(result);
+                }
+            });
+            return f;
+        }
+    }
+
+    @Override
+    public void take(final EndpointKey<SocketAddress> endpointKey, final CompletionHandler<Connection> completionHandler) {
+        synchronized (lock) {
+            if (completionHandler == null) {
+                throw new IllegalStateException("CompletionHandler argument cannot be null.");
+            }
 
-    // ---------------------------------------------------------- Nested Classes
+            super.take(endpointKey, new CompletionHandler<Connection>() {
+                @Override
+                public void cancelled() {
+                    completionHandler.cancelled();
+                }
+
+                @Override
+                public void failed(Throwable throwable) {
+                    completionHandler.failed(throwable);
+                }
 
+                @Override
+                public void completed(Connection result) {
+                    release(result);
+                    completionHandler.completed(result);
+                }
+
+                @Override
+                public void updated(Connection result) {
+                    completionHandler.updated(result);
+                }
+            });
+        }
+    }
+
+    @Override
+    public boolean release(Connection connection) {
+        synchronized (lock) {
+            return super.release(connection);
+        }
+    }
+
+    // ---------------------------------------------------------- Nested Classes
 
     public static final class MaxCapacityException extends IOException {
 
         public MaxCapacityException() {
             super("Maximum pool capacity has been reached");
         }
-
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
index 46a6830ff..7ca759938 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,103 +13,88 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import static org.asynchttpclient.AsyncHandler.STATE.ABORT;
+import static org.asynchttpclient.AsyncHandler.STATE.UPGRADE;
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
+
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.Cookie;
 import org.asynchttpclient.MaxRedirectException;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.ResponseFilter;
 import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
 import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
 import org.asynchttpclient.providers.grizzly.statushandler.AuthorizationHandler;
 import org.asynchttpclient.providers.grizzly.statushandler.ProxyAuthorizationHandler;
 import org.asynchttpclient.providers.grizzly.statushandler.RedirectHandler;
 import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
 import org.asynchttpclient.providers.grizzly.websocket.GrizzlyWebSocketAdapter;
+import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.http.HttpContent;
 import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.http.HttpRequestPacket;
 import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.Method;
 import org.glassfish.grizzly.http.ProcessingState;
 import org.glassfish.grizzly.http.Protocol;
 import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.http.util.HttpStatus;
 import org.glassfish.grizzly.utils.IdleTimeoutFilter;
-import org.glassfish.grizzly.websockets.HandshakeException;
 import org.glassfish.grizzly.websockets.SimpleWebSocket;
 import org.glassfish.grizzly.websockets.WebSocketHolder;
 
-import java.io.IOException;
-import java.net.URI;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
-
-import static org.asynchttpclient.AsyncHandler.STATE.ABORT;
-import static org.asynchttpclient.AsyncHandler.STATE.UPGRADE;
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.http.HttpRequestPacket;
 
 public final class EventHandler {
 
-    private static final Map<Integer, StatusHandler> HANDLER_MAP =
-            new HashMap<Integer, StatusHandler>();
+    private static final Map<Integer, StatusHandler> HANDLER_MAP = new HashMap<Integer, StatusHandler>();
 
     static {
-        HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(),
-                AuthorizationHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.getStatusCode(),
-                ProxyAuthorizationHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.MOVED_PERMANENTLY_301.getStatusCode(),
-                RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.FOUND_302.getStatusCode(),
-                RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.TEMPORARY_REDIRECT_307.getStatusCode(),
-                RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(), AuthorizationHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.getStatusCode(), ProxyAuthorizationHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.MOVED_PERMANENTLY_301.getStatusCode(), RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.FOUND_302.getStatusCode(), RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.SEE_OTHER_303.getStatusCode(), RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.TEMPORARY_REDIRECT_307.getStatusCode(), RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.PERMANENT_REDIRECT_308.getStatusCode(), RedirectHandler.INSTANCE);
     }
 
-
-    private final GrizzlyAsyncHttpProvider provider;
+    private final AsyncHttpClientConfig config;
     GrizzlyAsyncHttpProvider.Cleanup cleanup;
 
-
     // -------------------------------------------------------- Constructors
 
-
-    EventHandler(final GrizzlyAsyncHttpProvider provider) {
-        this.provider = provider;
+    EventHandler(final AsyncHttpClientConfig config) {
+        this.config = config;
     }
 
-
     // ----------------------------------------------------- Event Callbacks
 
-
     public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
 
-        HttpTransactionContext.get(ctx.getConnection()).abort(error);
-
+        HttpTxContext.get(ctx).abort(error);
     }
 
+    public void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
 
-    public void onHttpContentParsed(HttpContent content,
-                                    FilterChainContext ctx) {
-
-        final HttpTransactionContext context =
-                HttpTransactionContext.get(ctx.getConnection());
+        final HttpTxContext context = HttpTxContext.get(ctx);
         final AsyncHandler handler = context.getHandler();
         if (handler != null && context.getCurrentState() != ABORT) {
             try {
-                context.setCurrentState(handler.onBodyPartReceived(
-                        new GrizzlyResponseBodyPart(content,
-                                                    context.getRequest().getURI(),
-                                                    ctx.getConnection(),
-                                                    provider)));
+                context.setCurrentState(handler.onBodyPartReceived(new GrizzlyResponseBodyPart(content, ctx.getConnection())));
             } catch (Exception e) {
                 handler.onThrowable(e);
             }
@@ -119,45 +104,31 @@ public void onHttpContentParsed(HttpContent content,
 
     @SuppressWarnings("UnusedParameters")
     public void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        final HttpTxContext context = HttpTxContext.get(ctx);
         final AsyncHandler handler = context.getHandler();
-        if (handler != null) {
-            if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                ((TransferCompletionHandler) handler).onHeaderWriteCompleted();
-            }
+        if (handler instanceof TransferCompletionHandler) {
+            ((TransferCompletionHandler) handler).onHeaderWriteCompleted();
         }
     }
 
     public void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        final HttpTxContext context = HttpTxContext.get(ctx);
         final AsyncHandler handler = context.getHandler();
-        if (handler != null) {
-            if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                final int written = content.getContent().remaining();
-                final long total = context.getTotalBodyWritten().addAndGet(
-                        written);
-                ((TransferCompletionHandler) handler).onContentWriteProgress(
-                        written,
-                        total,
-                        content.getHttpHeader().getContentLength());
-            }
+        if (handler instanceof TransferCompletionHandler) {
+            final int written = content.getContent().remaining();
+            final long total = context.getTotalBodyWritten().addAndGet(written);
+            ((TransferCompletionHandler) handler).onContentWriteProgress(written, total, content.getHttpHeader().getContentLength());
         }
     }
 
-    public void onInitialLineParsed(HttpHeader httpHeader,
-                                       FilterChainContext ctx) {
+    public void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
 
         //super.onInitialLineParsed(httpHeader, ctx);
         if (httpHeader.isSkipRemainder()) {
             return;
         }
-        final Connection connection = ctx.getConnection();
-        final HttpTransactionContext context =
-                HttpTransactionContext.get(connection);
+        final HttpTxContext context = HttpTxContext.get(ctx);
         final int status = ((HttpResponsePacket) httpHeader).getStatus();
-        if (context.isEstablishingTunnel() && HttpStatus.OK_200.statusMatches(status)) {
-            return;
-        }
         if (HttpStatus.CONINTUE_100.statusMatches(status)) {
             ctx.notifyUpstream(new ContinueEvent(context));
             return;
@@ -198,21 +169,25 @@ public void onInitialLineParsed(HttpHeader httpHeader,
         }
         final GrizzlyResponseStatus responseStatus =
                 new GrizzlyResponseStatus((HttpResponsePacket) httpHeader,
-                        context.getRequest().getURI(),
-                        provider);
+                        context.getRequest().getUri(), config);
         context.setResponseStatus(responseStatus);
         if (context.getStatusHandler() != null) {
             return;
         }
-        if (context.getCurrentState() != ABORT) {
 
+        if (context.getCurrentState() != ABORT) {
             try {
                 final AsyncHandler handler = context.getHandler();
                 if (handler != null) {
                     context.setCurrentState(handler.onStatusReceived(responseStatus));
                     if (context.isWSRequest() && context.getCurrentState() == ABORT) {
                         httpHeader.setSkipRemainder(true);
-                        context.abort(new HandshakeException("Upgrade failed"));
+                        try {
+                            context.result(handler.onCompleted());
+                            context.done();
+                        } catch (Throwable e) {
+                            context.abort(e);
+                        }
                     }
                 }
             } catch (Exception e) {
@@ -223,47 +198,39 @@ public void onInitialLineParsed(HttpHeader httpHeader,
 
     }
 
+    public void onHttpHeaderError(final HttpHeader httpHeader, final FilterChainContext ctx, final Throwable t) {
 
-    public void onHttpHeaderError(final HttpHeader httpHeader,
-                                     final FilterChainContext ctx,
-                                     final Throwable t) {
+        httpHeader.setSkipRemainder(true);
+        HttpTxContext.get(ctx).abort(t);
+    }
+
+    public void onHttpContentError(final HttpHeader httpHeader, final FilterChainContext ctx, final Throwable t) {
 
-        t.printStackTrace();
         httpHeader.setSkipRemainder(true);
-        final HttpTransactionContext context =
-                HttpTransactionContext.get(ctx.getConnection());
-        context.abort(t);
+        HttpTxContext.get(ctx).abort(t);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public void onHttpHeadersParsed(HttpHeader httpHeader,
-                                       FilterChainContext ctx) {
+    @SuppressWarnings({ "unchecked" })
+    public void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
 
         //super.onHttpHeadersParsed(httpHeader, ctx);
         GrizzlyAsyncHttpProvider.LOGGER.debug("RESPONSE: {}", httpHeader);
         processKeepAlive(ctx.getConnection(), httpHeader);
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        final HttpTxContext context = HttpTxContext.get(ctx);
 
-        if (httpHeader.isSkipRemainder()
-                || (context.isEstablishingTunnel()
-                    && context.getStatusHandler() == null)) {
+        if (httpHeader.isSkipRemainder()) {
             return;
         }
 
         final AsyncHandler handler = context.getHandler();
-        final List<ResponseFilter> filters = context.getProvider()
-                .getClientConfig().getResponseFilters();
-        final GrizzlyResponseHeaders responseHeaders =
-                new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader,
-                                           context.getRequest().getURI(),
-                                           provider);
-        if (!filters.isEmpty()) {
-            FilterContext fc = new FilterContext.FilterContextBuilder()
-                    .asyncHandler(handler).request(context.getRequest())
-                    .responseHeaders(responseHeaders)
-                    .responseStatus(context.getResponseStatus()).build();
+        final GrizzlyResponseHeaders responseHeaders = new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader);
+        if (context.getProvider().getClientConfig().hasResponseFilters()) {
+            final List<ResponseFilter> filters = context.getProvider().getClientConfig().getResponseFilters();
+            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(context.getRequest())
+                    .responseHeaders(responseHeaders).responseStatus(context.getResponseStatus()).build();
             try {
-                for (final ResponseFilter f : filters) {
+                for (int i = 0, len = filters.size(); i < len; i++) {
+                    final ResponseFilter f = filters.get(i);
                     fc = f.filter(fc);
                 }
             } catch (Exception e) {
@@ -274,19 +241,12 @@ public void onHttpHeadersParsed(HttpHeader httpHeader,
                 final Request newRequest = fc.getRequest();
                 final AsyncHandler newHandler = fc.getAsyncHandler();
                 try {
-                    final ConnectionManager m =
-                            context.getProvider().getConnectionManager();
-                    final Connection c =
-                            m.obtainConnection(newRequest,
-                                               context.getFuture());
-                    final HttpTransactionContext newContext =
-                            context.copy();
+                    final ConnectionManager m = context.getProvider().getConnectionManager();
+                    final Connection c = m.obtainConnection(newRequest, context.getFuture());
+                    final HttpTxContext newContext = context.copy();
+                    newContext.setRequest(newRequest);
                     context.setFuture(null);
-                    HttpTransactionContext.set(c, newContext);
-                    context.getProvider().execute(c,
-                                                  newRequest,
-                                                  newHandler,
-                                                  context.getFuture());
+                    context.getProvider().execute(c, newRequest, newHandler, context.getFuture(), newContext);
                 } catch (Exception e) {
                     context.abort(e);
                 }
@@ -294,11 +254,7 @@ public void onHttpHeadersParsed(HttpHeader httpHeader,
             }
         }
         if (context.getStatusHandler() != null && context.getInvocationStatus() == CONTINUE) {
-            final boolean result =
-                    context.getStatusHandler().handleStatus(
-                            ((HttpResponsePacket) httpHeader),
-                            context,
-                            ctx);
+            final boolean result = context.getStatusHandler().handleStatus(((HttpResponsePacket) httpHeader), context, ctx);
             if (!result) {
                 httpHeader.setSkipRemainder(true);
                 return;
@@ -307,15 +263,13 @@ public void onHttpHeadersParsed(HttpHeader httpHeader,
         if (context.isWSRequest()) {
             try {
                 //in case of DIGEST auth protocol handler is null and just returning here is working
-                if(context.getProtocolHandler() == null)
-                {
+                if (context.getProtocolHandler() == null) {
                     return;
                     //context.protocolHandler = Version.DRAFT17.createHandler(true);
                     //context.currentState = AsyncHandler.STATE.UPGRADE;
                 }
 
-                context.getProtocolHandler().setConnection(
-                        ctx.getConnection());
+                context.getProtocolHandler().setConnection(ctx.getConnection());
 
                 final GrizzlyWebSocketAdapter webSocketAdapter = createWebSocketAdapter(context);
                 context.setWebSocket(webSocketAdapter);
@@ -323,34 +277,26 @@ public void onHttpHeadersParsed(HttpHeader httpHeader,
                 if (context.getCurrentState() == UPGRADE) {
                     httpHeader.setChunked(false);
                     ws.onConnect();
-                    WebSocketHolder.set(ctx.getConnection(),
-                                        context.getProtocolHandler(),
-                                        ws);
+                    WebSocketHolder.set(ctx.getConnection(), context.getProtocolHandler(), ws);
                     ((WebSocketUpgradeHandler) context.getHandler()).onSuccess(context.getWebSocket());
-                    final int wsTimeout = context.getProvider().getClientConfig().getWebSocketIdleTimeoutInMs();
-                    IdleTimeoutFilter.setCustomTimeout(ctx.getConnection(),
-                                                       ((wsTimeout <= 0)
-                                                               ? IdleTimeoutFilter.FOREVER
-                                                               : wsTimeout),
-                                                       TimeUnit.MILLISECONDS);
+                    final int wsTimeout = context.getProvider().getClientConfig().getWebSocketTimeout();
+                    IdleTimeoutFilter.setCustomTimeout(ctx.getConnection(), ((wsTimeout <= 0) ? IdleTimeoutFilter.FOREVER : wsTimeout),
+                            TimeUnit.MILLISECONDS);
                     context.result(handler.onCompleted());
                 } else {
                     httpHeader.setSkipRemainder(true);
-                    ((WebSocketUpgradeHandler) context.getHandler()).
-                            onClose(context.getWebSocket(),
-                                    1002,
-                                    "WebSocket protocol error: unexpected HTTP response status during handshake.");
+                    ((WebSocketUpgradeHandler) context.getHandler()).onClose(context.getWebSocket(), 1002,
+                            "WebSocket protocol error: unexpected HTTP response status during handshake.");
                     context.result(null);
                 }
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 httpHeader.setSkipRemainder(true);
                 context.abort(e);
             }
         } else {
             if (context.getCurrentState() != ABORT) {
                 try {
-                    context.setCurrentState(
-                            handler.onHeadersReceived(responseHeaders));
+                    context.setCurrentState(handler.onHeadersReceived(responseHeaders));
                 } catch (Exception e) {
                     httpHeader.setSkipRemainder(true);
                     context.abort(e);
@@ -360,10 +306,21 @@ public void onHttpHeadersParsed(HttpHeader httpHeader,
 
     }
 
-    @SuppressWarnings("unchecked")
-    public boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+    public boolean onHttpHeaderParsed(final HttpHeader httpHeader,
+            final Buffer buffer, final FilterChainContext ctx) {
+        final HttpRequestPacket request = ((HttpResponsePacket) httpHeader).getRequest();
+        if (Method.CONNECT.equals(request.getMethod())) {
+            // finish request/response processing, because Grizzly itself
+            // treats CONNECT traffic as part of request-response processing
+            // and we don't want it be treated like that
+            httpHeader.setExpectContent(false);
+        }
 
-        boolean result;
+        return false;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
 
         Utils.removeRequestInFlight(ctx.getConnection());
 
@@ -378,59 +335,31 @@ public boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx)
             return false;
         }
 
-        result = false;
-        final HttpResponsePacket response =
-                (HttpResponsePacket) httpHeader;
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
-        try {
-            if (context.isEstablishingTunnel()
-                    && HttpStatus.OK_200.statusMatches(response.getStatus())) {
-                context.setEstablishingTunnel(false);
-                final Connection c = ctx.getConnection();
-                context.tunnelEstablished(c);
-                context.getProvider().execute(c,
-                                              context.getRequest(),
-                                              context.getHandler(),
-                                              context.getFuture());
-                return result;
-            } else {
-                cleanup(ctx);
-                final AsyncHandler handler = context.getHandler();
-                if (handler != null) {
-                    try {
-                        context.result(handler.onCompleted());
-                    } catch (Exception e) {
-                        context.abort(e);
-                    }
-                } else {
-                    context.done(null);
-                }
-                return result;
+        final HttpTxContext context = HttpTxContext.get(ctx);
+        cleanup(ctx);
+        final AsyncHandler handler = context.getHandler();
+        if (handler != null) {
+            try {
+                context.result(handler.onCompleted());
+            } catch (Throwable e) {
+                context.abort(e);
             }
-        } finally {
-            recycleRequestResponsePackets(response);
+        } else {
+            context.done();
         }
-
+        return false;
     }
 
-
     // ----------------------------------------------------- Private Methods
 
-    private static void recycleRequestResponsePackets(final HttpResponsePacket response) {
-        HttpRequestPacket request = response.getRequest();
-        request.setExpectContent(false);
-        response.recycle();
-        request.recycle();
-    }
-
-    private static void processKeepAlive(final Connection c,
-                                         final HttpHeader header) {
+    @SuppressWarnings("rawtypes")
+    private static void processKeepAlive(final Connection c, final HttpHeader header) {
         final ProcessingState state = header.getProcessingState();
         final String connectionHeader = header.getHeader(Header.Connection);
         if (connectionHeader == null) {
             state.setKeepAlive(header.getProtocol() == Protocol.HTTP_1_1);
         } else {
-            if ("close".equals(connectionHeader.toLowerCase())) {
+            if ("close".equals(connectionHeader.toLowerCase(Locale.ENGLISH))) {
                 ConnectionManager.markConnectionAsDoNotCache(c);
                 state.setKeepAlive(false);
             } else {
@@ -439,46 +368,37 @@ private static void processKeepAlive(final Connection c,
         }
     }
 
-
-    private static GrizzlyWebSocketAdapter createWebSocketAdapter(final HttpTransactionContext context) {
+    @SuppressWarnings("rawtypes")
+    private static GrizzlyWebSocketAdapter createWebSocketAdapter(final HttpTxContext context) {
         SimpleWebSocket ws = new SimpleWebSocket(context.getProtocolHandler());
         AsyncHttpProviderConfig config = context.getProvider().getClientConfig().getAsyncHttpProviderConfig();
         boolean bufferFragments = true;
         if (config instanceof GrizzlyAsyncHttpProviderConfig) {
-            bufferFragments = (Boolean) ((GrizzlyAsyncHttpProviderConfig) config).getProperty(
-                    GrizzlyAsyncHttpProviderConfig.Property.BUFFER_WEBSOCKET_FRAGMENTS);
+            bufferFragments = (Boolean) ((GrizzlyAsyncHttpProviderConfig) config)
+                    .getProperty(GrizzlyAsyncHttpProviderConfig.Property.BUFFER_WEBSOCKET_FRAGMENTS);
         }
 
         return new GrizzlyWebSocketAdapter(ws, bufferFragments);
     }
 
-    private static boolean isRedirectAllowed(final HttpTransactionContext ctx) {
-        boolean allowed = ctx.getRequest().isRedirectEnabled();
-        if (ctx.getRequest().isRedirectOverrideSet()) {
-            return allowed;
-        }
-        if (!allowed) {
-            allowed = ctx.isRedirectsAllowed();
-        }
-        return allowed;
+    private static boolean isRedirectAllowed(final HttpTxContext ctx) {
+        return ctx.getRequest().getFollowRedirect() != null? ctx.getRequest().getFollowRedirect().booleanValue() : ctx.isRedirectsAllowed();
     }
 
-    private static HttpTransactionContext cleanup(final FilterChainContext ctx) {
+    @SuppressWarnings("rawtypes")
+    private static HttpTxContext cleanup(final FilterChainContext ctx) {
 
         final Connection c = ctx.getConnection();
-        final HttpTransactionContext context =
-                HttpTransactionContext.get(c);
-        HttpTransactionContext.set(c, null);
-        if (!Utils.isIgnored(ctx.getConnection())) {
-            final ConnectionManager manager =
-                    context.getProvider().getConnectionManager();
+        final HttpTxContext context = HttpTxContext.remove(ctx);
+        if (!Utils.isSpdyConnection(c) && !Utils.isIgnored(c)) {
+            final ConnectionManager manager = context.getProvider().getConnectionManager();
             //if (!manager.canReturnConnection(c)) {
             //    context.abort(
             //            new IOException("Maximum pooled connections exceeded"));
             //} else {
-                if (!manager.returnConnection(c)) {
-                    ctx.getConnection().close();
-                }
+            if (!manager.returnConnection(c)) {
+                ctx.getConnection().close();
+            }
             //}
         }
 
@@ -486,49 +406,41 @@ private static HttpTransactionContext cleanup(final FilterChainContext ctx) {
 
     }
 
-
-    private static boolean redirectCountExceeded(final HttpTransactionContext context) {
-
+    private static boolean redirectCountExceeded(final HttpTxContext context) {
         return (context.getRedirectCount().get() > context.getMaxRedirectCount());
-
     }
 
-
     public static boolean isRedirect(final int status) {
 
-        return HttpStatus.MOVED_PERMANENTLY_301.statusMatches(status)
-                || HttpStatus.FOUND_302.statusMatches(status)
-                || HttpStatus.SEE_OTHER_303.statusMatches(status)
-                || HttpStatus.TEMPORARY_REDIRECT_307.statusMatches(status);
-
+        return HttpStatus.MOVED_PERMANENTLY_301.statusMatches(status)//
+                || HttpStatus.FOUND_302.statusMatches(status)//
+                || HttpStatus.SEE_OTHER_303.statusMatches(status)//
+                || HttpStatus.TEMPORARY_REDIRECT_307.statusMatches(status)
+                || HttpStatus.PERMANENT_REDIRECT_308.statusMatches(status);
     }
 
-
     // ----------------------------------------------------- Private Methods
 
-
-    public static Request newRequest(final URI uri,
-                                      final HttpResponsePacket response,
-                                      final HttpTransactionContext ctx,
-                                      boolean asGet) {
+    public static Request newRequest(final Uri uri, final HttpResponsePacket response, final HttpTxContext ctx, boolean asGet) {
 
         final RequestBuilder builder = new RequestBuilder(ctx.getRequest());
         if (asGet) {
-            builder.setMethod("GET");
+            builder.setMethod(Method.GET.getMethodString());
         }
         builder.setUrl(uri.toString());
 
-        if (ctx.getProvider().getClientConfig().isRemoveQueryParamOnRedirect()) {
-            builder.setQueryParameters(null);
-        }
-        for (String cookieStr : response.getHeaders().values(Header.Cookie)) {
-            for (Cookie c : CookieDecoder.decode(cookieStr)) {
-                builder.addOrReplaceCookie(c);
+        if (!ctx.getProvider().getClientConfig().isRemoveQueryParamOnRedirect())
+            builder.addQueryParams(ctx.getRequest().getQueryParams());
+        
+        if (response.getHeader(Header.Cookie) != null) {
+            for (String cookieStr : response.getHeaders().values(Header.Cookie)) {
+                Cookie c = CookieDecoder.decode(cookieStr);
+                if (c != null) {
+                    builder.addOrReplaceCookie(c);
+                }
             }
         }
         return builder.build();
-
     }
 
-
 } // END AsyncHttpClientEventFilter
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
index ad4febd66..6514edb61 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,17 +12,34 @@
  */
 package org.asynchttpclient.providers.grizzly;
 
+import static java.lang.Boolean.TRUE;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.glassfish.grizzly.utils.Exceptions.makeIOException;
+
 import org.asynchttpclient.Body;
 import org.asynchttpclient.BodyGenerator;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
 import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.CompletionHandler;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.OutputSink;
+import org.glassfish.grizzly.WriteHandler;
+import org.glassfish.grizzly.WriteResult;
+import org.glassfish.grizzly.filterchain.FilterChain;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpContext;
 import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.impl.FutureImpl;
+import org.glassfish.grizzly.ssl.SSLBaseFilter;
+import org.glassfish.grizzly.ssl.SSLFilter;
+import org.glassfish.grizzly.threadpool.Threads;
+import org.glassfish.grizzly.utils.Futures;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.ExecutionException;
+
+import static org.glassfish.grizzly.ssl.SSLUtils.getSSLEngine;
 
 /**
  * {@link BodyGenerator} which may return just part of the payload at the time
@@ -33,56 +50,180 @@
  * @since 1.7.0
  */
 public class FeedableBodyGenerator implements BodyGenerator {
-    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
-    private final AtomicInteger queueSize = new AtomicInteger();
-    
+    /**
+     * There is no limit on bytes waiting to be written.  This configuration
+     * value should be used with caution as it could lead to out-of-memory
+     * conditions.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static final int UNBOUND = -1;
+
+    /**
+     * Defer to whatever the connection has been configured for max pending bytes.
+     */
+    public static final int DEFAULT = -2;
+
     private volatile HttpRequestPacket requestPacket;
     private volatile FilterChainContext context;
-    
+    private volatile HttpContent.Builder contentBuilder;
+
+    private final EmptyBody EMPTY_BODY = new EmptyBody();
+
+    private Feeder feeder;
+    private int origMaxPendingBytes;
+    private int configuredMaxPendingBytes = DEFAULT;
+    private boolean asyncTransferInitiated;
+
+    // ---------------------------------------------- Methods from BodyGenerator
+
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Body createBody() throws IOException {
-        return new EmptyBody();
+        return EMPTY_BODY;
     }
-    
+
+    // ---------------------------------------------------------- Public Methods
+
+    /**
+     * Configured the maximum number of bytes that may be pending to be written
+     * to the wire.  If not explicitly configured, the connection's current
+     * configuration will be used instead.
+     * <p/>
+     * Once all data has been fed, the connection's max pending bytes configuration
+     * will be restored to its original value.
+     *
+     * @param maxPendingBytes maximum number of bytes that may be queued to
+     *                        be written to the wire.
+     * @throws IllegalStateException    if called after {@link #initializeAsynchronousTransfer(FilterChainContext, HttpRequestPacket)}
+     *                                  has been called by the {@link GrizzlyAsyncHttpProvider}.
+     * @throws IllegalArgumentException if maxPendingBytes is less than zero and is
+     *                                  not {@link #UNBOUND} or {@link #DEFAULT}.
+     */
     @SuppressWarnings("UnusedDeclaration")
-    public void feed(final Buffer buffer, final boolean isLast)
-            throws IOException {
-        queue.offer(new BodyPart(buffer, isLast));
-        queueSize.incrementAndGet();
-        
-        if (context != null) {
-            flushQueue();            
+    public synchronized void setMaxPendingBytes(final int maxPendingBytes) {
+        if (maxPendingBytes < DEFAULT) {
+            throw new IllegalArgumentException("Invalid maxPendingBytes value: " + maxPendingBytes);
         }
+        if (asyncTransferInitiated) {
+            throw new IllegalStateException("Unable to set max pending bytes after async data transfer has been initiated.");
+        }
+        configuredMaxPendingBytes = maxPendingBytes;
     }
-    
-    public void initializeAsynchronousTransfer(final FilterChainContext context,
-            final HttpRequestPacket requestPacket) {
-        this.context = context;
-        this.requestPacket = requestPacket;
-        flushQueue();
+
+    /**
+     * Add a {@link Feeder} implementation that will be invoked when writing
+     * without blocking is possible.  This method must be set before dispatching
+     * the request this feeder is associated with.
+     *
+     * @param feeder the {@link Feeder} responsible for providing data.
+     * @throws IllegalStateException    if called after {@link #initializeAsynchronousTransfer(FilterChainContext, HttpRequestPacket)}
+     *                                  has been called by the {@link GrizzlyAsyncHttpProvider}.
+     * @throws IllegalArgumentException if <code>feeder</code> is <code>null</code>
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public synchronized void setFeeder(final Feeder feeder) {
+        if (asyncTransferInitiated) {
+            throw new IllegalStateException("Unable to set Feeder after async data transfer has been initiated.");
+        }
+        if (feeder == null) {
+            throw new IllegalArgumentException("Feeder argument cannot be null.");
+        }
+        this.feeder = feeder;
     }
 
-    @SuppressWarnings("unchecked")
-    private void flushQueue() {
-        if (queueSize.get() > 0) {
-            synchronized(this) {
-                while(queueSize.get() > 0) {
-                    final BodyPart bodyPart = queue.poll();
-                    queueSize.decrementAndGet();
-                    final HttpContent content =
-                            requestPacket.httpContentBuilder()
-                            .content(bodyPart.buffer)
-                            .last(bodyPart.isLast)
-                            .build();
-                    context.write(content, ((!requestPacket.isCommitted()) ?
-                            context.getTransportContext().getCompletionHandler() :
-                            null));
-                    
+    // ------------------------------------------------- Package Private Methods
+
+    /**
+     * Even though this method is public, it's not intended to be called by
+     * Developers directly.  Please avoid doing so.
+     */
+    public synchronized void initializeAsynchronousTransfer(final FilterChainContext context, final HttpRequestPacket requestPacket)
+            throws IOException {
+
+        if (asyncTransferInitiated) {
+            throw new IllegalStateException("Async transfer has already been initiated.");
+        }
+        if (feeder == null) {
+            throw new IllegalStateException("No feeder available to perform the transfer.");
+        }
+        assert (context != null);
+        assert (requestPacket != null);
+
+        this.requestPacket = requestPacket;
+        this.contentBuilder = HttpContent.builder(requestPacket);
+        final Connection c = context.getConnection();
+        origMaxPendingBytes = c.getMaxAsyncWriteQueueSize();
+        if (configuredMaxPendingBytes != DEFAULT) {
+            c.setMaxAsyncWriteQueueSize(configuredMaxPendingBytes);
+        }
+        this.context = context;
+        asyncTransferInitiated = true;
+        final Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    if (requestPacket.isSecure() &&
+                            (getSSLEngine(context.getConnection()) == null)) {
+                        flushOnSSLHandshakeComplete();
+                    } else {
+                        feeder.flush();
+                    }
+                } catch (IOException ioe) {
+                    throwError(ioe);
                 }
             }
+        };
+
+        // If the current thread is a selector thread, we need to execute
+        // the remainder of the task on the worker thread to prevent
+        // it from being blocked.
+        if (isServiceThread()) {
+            c.getTransport().getWorkerThreadPool().execute(r);
+        } else {
+            r.run();
         }
     }
-    
+
+    // --------------------------------------------------------- Private Methods
+
+    private boolean isServiceThread() {
+        return Threads.isService();
+    }
+
+
+    private void flushOnSSLHandshakeComplete() throws IOException {
+        final FilterChain filterChain = context.getFilterChain();
+        final int idx = filterChain.indexOfType(SSLFilter.class);
+        assert (idx != -1);
+        final SSLFilter filter = (SSLFilter) filterChain.get(idx);
+        final Connection c = context.getConnection();
+        filter.addHandshakeListener(new SSLBaseFilter.HandshakeListener() {
+            public void onStart(Connection connection) {
+            }
+
+            public void onComplete(Connection connection) {
+                if (c.equals(connection)) {
+                    filter.removeHandshakeListener(this);
+                    try {
+                        feeder.flush();
+                    } catch (IOException ioe) {
+                        throwError(ioe);
+                    }
+                }
+            }
+        });
+        filter.handshake(context.getConnection(),  null);
+    }
+
+    private void throwError(final Throwable t) {
+        HttpTxContext httpTxContext = HttpTxContext.get(context);
+        httpTxContext.abort(t);
+    }
+
+    // ----------------------------------------------------------- Inner Classes
+
     private final class EmptyBody implements Body {
 
         @Override
@@ -100,16 +241,360 @@ public void close() throws IOException {
             context.completeAndRecycle();
             context = null;
             requestPacket = null;
+            contentBuilder = null;
         }
-    }
-    
-    private final static class BodyPart {
-        private final boolean isLast;
-        private final Buffer buffer;
 
-        public BodyPart(final Buffer buffer, final boolean isLast) {
-            this.buffer = buffer;
-            this.isLast = isLast;
+    } // END EmptyBody
+
+    // ---------------------------------------------------------- Nested Classes
+
+    /**
+     * Specifies the functionality all Feeders must implement.  Typically,
+     * developers need not worry about implementing this interface directly.
+     * It should be sufficient, for most use-cases, to simply use the {@link NonBlockingFeeder}
+     * or {@link SimpleFeeder} implementations.
+     */
+    public interface Feeder {
+
+        /**
+         * This method will be invoked when it's possible to begin feeding
+         * data downstream.  Implementations of this method must use {@link #feed(Buffer, boolean)}
+         * to perform the actual write.
+         *
+         * @throws IOException if an I/O error occurs.
+         */
+        void flush() throws IOException;
+
+        /**
+         * This method will write the specified {@link Buffer} to the connection.
+         * Be aware that this method may block depending if data is being fed
+         * faster than it can write.  How much data may be queued is dictated
+         * by {@link #setMaxPendingBytes(int)}.  Once this threshold is exceeded,
+         * the method will block until the write queue length drops below the
+         * aforementioned threshold.
+         *
+         * @param buffer the {@link Buffer} to write.
+         * @param last   flag indicating if this is the last buffer to send.
+         * @throws IOException                        if an I/O error occurs.
+         * @throws java.lang.IllegalArgumentException if <code>buffer</code>
+         *                                            is <code>null</code>.
+         * @throws java.lang.IllegalStateException    if this method is invoked
+         *                                            before asynchronous transferring has been initiated.
+         * @see #setMaxPendingBytes(int)
+         */
+        @SuppressWarnings("UnusedDeclaration")
+        void feed(final Buffer buffer, final boolean last) throws IOException;
+
+    } // END Feeder
+
+    /**
+     * Base class for {@link Feeder} implementations.  This class provides
+     * an implementation for the contract defined by the {@link #feed} method.
+     */
+    public static abstract class BaseFeeder implements Feeder {
+
+        protected final FeedableBodyGenerator feedableBodyGenerator;
+
+        // -------------------------------------------------------- Constructors
+
+        protected BaseFeeder(FeedableBodyGenerator feedableBodyGenerator) {
+            this.feedableBodyGenerator = feedableBodyGenerator;
         }
-    }
+
+        // --------------------------------------------- Package Private Methods
+
+        /**
+         * {@inheritDoc}
+         */
+        @SuppressWarnings("UnusedDeclaration")
+        public final synchronized void feed(final Buffer buffer, final boolean last) throws IOException {
+            if (buffer == null) {
+                throw new NullPointerException("buffer");
+            }
+            if (!feedableBodyGenerator.asyncTransferInitiated) {
+                throw new IllegalStateException("Asynchronous transfer has not been initiated.");
+            }
+            blockUntilQueueFree(feedableBodyGenerator.context);
+            final HttpContent content = feedableBodyGenerator.contentBuilder.content(buffer).last(last).build();
+            final CompletionHandler<WriteResult> handler = ((last) ? new LastPacketCompletionHandler() : null);
+            feedableBodyGenerator.context.write(content, handler);
+        }
+
+        /**
+         * This method will block if the async write queue is currently larger
+         * than the configured maximum.  The amount of time that this method
+         * will block is dependent on the write timeout of the transport
+         * associated with the specified connection.
+         */
+        private static void blockUntilQueueFree(final FilterChainContext ctx) {
+            HttpContext httpContext = HttpContext.get(ctx);
+            final OutputSink outputSink = httpContext.getOutputSink();
+            if (!outputSink.canWrite()) {
+                final FutureImpl<Boolean> future = Futures.createSafeFuture();
+                outputSink.notifyCanWrite(new WriteHandler() {
+
+                    @Override
+                    public void onWritePossible() throws Exception {
+                        future.result(TRUE);
+                    }
+
+                    @Override
+                    public void onError(Throwable t) {
+                        future.failure(makeIOException(t));
+                    }
+                });
+
+                block(ctx, future);
+            }
+        }
+
+        private static void block(final FilterChainContext ctx, final FutureImpl<Boolean> future) {
+            try {
+                final long writeTimeout = ctx.getConnection().getTransport().getWriteTimeout(MILLISECONDS);
+                if (writeTimeout != -1) {
+                    future.get(writeTimeout, MILLISECONDS);
+                } else {
+                    future.get();
+                }
+            } catch (ExecutionException e) {
+                HttpTxContext httpTxContext = HttpTxContext.get(ctx);
+                httpTxContext.abort(e.getCause());
+            } catch (Exception e) {
+                HttpTxContext httpTxContext = HttpTxContext.get(ctx);
+                httpTxContext.abort(e);
+            }
+        }
+
+        // ------------------------------------------------------- Inner Classes
+
+        private final class LastPacketCompletionHandler implements CompletionHandler<WriteResult> {
+
+            private final CompletionHandler<WriteResult> delegate;
+            private final Connection c;
+            private final int origMaxPendingBytes;
+
+            // -------------------------------------------------------- Constructors
+
+            @SuppressWarnings("unchecked")
+            private LastPacketCompletionHandler() {
+                delegate = ((!feedableBodyGenerator.requestPacket.isCommitted()) ? feedableBodyGenerator.context.getTransportContext()
+                        .getCompletionHandler() : null);
+                c = feedableBodyGenerator.context.getConnection();
+                origMaxPendingBytes = feedableBodyGenerator.origMaxPendingBytes;
+            }
+
+            // -------------------------------------- Methods from CompletionHandler
+
+            @Override
+            public void cancelled() {
+                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
+                if (delegate != null) {
+                    delegate.cancelled();
+                }
+            }
+
+            @Override
+            public void failed(Throwable throwable) {
+                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
+                if (delegate != null) {
+                    delegate.failed(throwable);
+                }
+
+            }
+
+            @Override
+            public void completed(WriteResult result) {
+                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
+                if (delegate != null) {
+                    delegate.completed(result);
+                }
+
+            }
+
+            @Override
+            public void updated(WriteResult result) {
+                if (delegate != null) {
+                    delegate.updated(result);
+                }
+            }
+
+        } // END LastPacketCompletionHandler
+
+    } // END Feeder
+
+    /**
+     * Implementations of this class provide the framework to read data from
+     * some source and feed data to the {@link FeedableBodyGenerator}
+     * without blocking.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static abstract class NonBlockingFeeder extends BaseFeeder {
+
+        // -------------------------------------------------------- Constructors
+
+        /**
+         * Constructs the <code>NonBlockingFeeder</code> with the associated
+         * {@link FeedableBodyGenerator}.
+         */
+        public NonBlockingFeeder(final FeedableBodyGenerator feedableBodyGenerator) {
+            super(feedableBodyGenerator);
+        }
+
+        // ------------------------------------------------------ Public Methods
+
+        /**
+         * Notification that it's possible to send another block of data via
+         * {@link #feed(org.glassfish.grizzly.Buffer, boolean)}.
+         * <p/>
+         * It's important to only invoke {@link #feed(Buffer, boolean)}
+         * once per invocation of {@link #canFeed()}.
+         */
+        public abstract void canFeed() throws IOException;
+
+        /**
+         * @return <code>true</code> if all data has been fed by this feeder,
+         * otherwise returns <code>false</code>.
+         */
+        public abstract boolean isDone();
+
+        /**
+         * @return <code>true</code> if data is available to be fed, otherwise
+         * returns <code>false</code>.  When this method returns <code>false</code>,
+         * the {@link FeedableBodyGenerator} will call {@link #notifyReadyToFeed(ReadyToFeedListener)}
+         * by which this {@link NonBlockingFeeder} implementation may signal data is once
+         * again available to be fed.
+         */
+        public abstract boolean isReady();
+
+        /**
+         * Callback registration to signal the {@link FeedableBodyGenerator} that
+         * data is available once again to continue feeding.  Once this listener
+         * has been invoked, the NonBlockingFeeder implementation should no longer maintain
+         * a reference to the listener.
+         */
+        public abstract void notifyReadyToFeed(final ReadyToFeedListener listener);
+
+        // ------------------------------------------------- Methods from Feeder
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public synchronized void flush() throws IOException {
+            final HttpContext httpContext = HttpContext.get(feedableBodyGenerator.context);
+            final OutputSink outputSink = httpContext.getOutputSink();
+            if (isReady()) {
+                final boolean notReady = writeUntilFullOrDone(outputSink);
+                if (!isDone()) {
+                    if (notReady) {
+                        notifyReadyToFeed(new ReadyToFeedListenerImpl());
+                    } else {
+                        // write queue is full, leverage WriteListener to let us know
+                        // when it is safe to write again.
+                        outputSink.notifyCanWrite(new WriteHandlerImpl());
+                    }
+                }
+            } else {
+                notifyReadyToFeed(new ReadyToFeedListenerImpl());
+            }
+        }
+
+        // ----------------------------------------------------- Private Methods
+
+        private boolean writeUntilFullOrDone(final OutputSink outputSink)
+                throws IOException {
+            while (outputSink.canWrite()) {
+                if (isReady()) {
+                    canFeed();
+                } else {
+                    return true;
+                }
+            }
+            
+            return false;
+        }
+
+        // ------------------------------------------------------- Inner Classes
+
+        /**
+         * Listener to signal that data is available to be fed.
+         */
+        public interface ReadyToFeedListener {
+
+            /**
+             * Data is once again ready to be fed.
+             */
+            @SuppressWarnings("UnusedDeclaration")
+            void ready();
+
+        } // END ReadyToFeedListener
+
+        private final class WriteHandlerImpl implements WriteHandler {
+
+            private final Connection c;
+            private final FilterChainContext ctx;
+
+            // -------------------------------------------------------- Constructors
+
+            private WriteHandlerImpl() {
+                this.c = feedableBodyGenerator.context.getConnection();
+                this.ctx = feedableBodyGenerator.context;
+            }
+
+            // ------------------------------------------ Methods from WriteListener
+
+            @Override
+            public void onWritePossible() throws Exception {
+                flush();
+            }
+
+            @Override
+            public void onError(Throwable t) {
+                if (!Utils.isSpdyConnection(c)) {
+                    c.setMaxAsyncWriteQueueSize(feedableBodyGenerator.origMaxPendingBytes);
+                }
+                feedableBodyGenerator.throwError(t);
+            }
+
+        } // END WriteHandlerImpl
+
+        private final class ReadyToFeedListenerImpl implements NonBlockingFeeder.ReadyToFeedListener {
+
+            // ------------------------------------ Methods from ReadyToFeedListener
+
+            @Override
+            public void ready() {
+                try {
+                    flush();
+                } catch (IOException e) {
+                    final Connection c = feedableBodyGenerator.context.getConnection();
+                    if (!Utils.isSpdyConnection(c)) {
+                        c.setMaxAsyncWriteQueueSize(feedableBodyGenerator.origMaxPendingBytes);
+                    }
+                    feedableBodyGenerator.throwError(e);
+                }
+            }
+
+        } // END ReadToFeedListenerImpl
+
+    } // END NonBlockingFeeder
+
+    /**
+     * This simple {@link Feeder} implementation allows the implementation to
+     * feed data in whatever fashion is deemed appropriate.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public abstract static class SimpleFeeder extends BaseFeeder {
+
+        // -------------------------------------------------------- Constructors
+
+        /**
+         * Constructs the <code>SimpleFeeder</code> with the associated
+         * {@link FeedableBodyGenerator}.
+         */
+        public SimpleFeeder(FeedableBodyGenerator feedableBodyGenerator) {
+            super(feedableBodyGenerator);
+        }
+
+    } // END SimpleFeeder
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
index b334fb426..31f485055 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,30 +13,26 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.CONNECTION_POOL;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
+import static org.glassfish.grizzly.asyncqueue.AsyncQueueWriter.AUTO_SIZE;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
-import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandlerFactory;
-import org.asynchttpclient.providers.grizzly.bodyhandler.ExpectHandler;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property;
 import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientEventFilter;
 import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientFilter;
-import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientTransportFilter;
 import org.asynchttpclient.providers.grizzly.filters.AsyncSpdyClientEventFilter;
 import org.asynchttpclient.providers.grizzly.filters.ClientEncodingFilter;
 import org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
 import org.asynchttpclient.util.ProxyUtils;
 import org.asynchttpclient.util.SslUtils;
-
 import org.glassfish.grizzly.CompletionHandler;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.WriteResult;
@@ -44,12 +40,13 @@
 import org.glassfish.grizzly.filterchain.FilterChain;
 import org.glassfish.grizzly.filterchain.FilterChainBuilder;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.TransportFilter;
 import org.glassfish.grizzly.http.ContentEncoding;
 import org.glassfish.grizzly.http.GZipContentEncoding;
 import org.glassfish.grizzly.http.HttpClientFilter;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.http.Method;
+import org.glassfish.grizzly.impl.SafeFutureImpl;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransportBuilder;
 import org.glassfish.grizzly.npn.ClientSideNegotiator;
 import org.glassfish.grizzly.spdy.NextProtoNegSupport;
 import org.glassfish.grizzly.spdy.SpdyFramingFilter;
@@ -58,14 +55,9 @@
 import org.glassfish.grizzly.spdy.SpdySession;
 import org.glassfish.grizzly.ssl.SSLBaseFilter;
 import org.glassfish.grizzly.ssl.SSLConnectionContext;
-import org.glassfish.grizzly.ssl.SSLUtils;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.impl.SafeFutureImpl;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransportBuilder;
 import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
 import org.glassfish.grizzly.ssl.SSLFilter;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
+import org.glassfish.grizzly.ssl.SSLUtils;
 import org.glassfish.grizzly.strategies.WorkerThreadIOStrategy;
 import org.glassfish.grizzly.utils.DelayedExecutor;
 import org.glassfish.grizzly.utils.IdleTimeoutFilter;
@@ -75,17 +67,15 @@
 
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
-import java.io.File;
+
 import java.io.IOException;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property;
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.CONNECTION_POOL;
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
+import org.glassfish.grizzly.nio.RoundRobinConnectionDistributor;
+import org.glassfish.grizzly.spdy.SpdyVersion;
+import org.glassfish.grizzly.threadpool.ThreadPoolConfig;
 
 /**
  * A Grizzly 2.0-based implementation of {@link AsyncHttpProvider}.
@@ -99,7 +89,6 @@
     public static final Logger LOGGER = LoggerFactory.getLogger(GrizzlyAsyncHttpProvider.class);
     public final static NTLMEngine NTLM_ENGINE = new NTLMEngine();
 
-    private final BodyHandlerFactory bodyHandlerFactory;
     private final AsyncHttpClientConfig clientConfig;
 
     private ConnectionManager connectionManager;
@@ -108,10 +97,8 @@
 
     final TCPNIOTransport clientTransport;
 
-
     // ------------------------------------------------------------ Constructors
 
-
     public GrizzlyAsyncHttpProvider(final AsyncHttpClientConfig clientConfig) {
 
         this.clientConfig = clientConfig;
@@ -123,24 +110,22 @@ public GrizzlyAsyncHttpProvider(final AsyncHttpClientConfig clientConfig) {
         } catch (IOException ioe) {
             throw new RuntimeException(ioe);
         }
-        bodyHandlerFactory = new BodyHandlerFactory(this);
-
     }
 
-
     // ------------------------------------------ Methods from AsyncHttpProvider
 
-
     /**
      * {@inheritDoc}
      */
-    public <T> ListenableFuture<T> execute(final Request request,
-            final AsyncHandler<T> handler) throws IOException {
+    public <T> ListenableFuture<T> execute(final Request request, final AsyncHandler<T> handler) throws IOException {
 
+        if (clientTransport.isStopped()) {
+            throw new IOException("AsyncHttpClient has been closed.");
+        }
         final ProxyServer proxy = ProxyUtils.getProxyServer(clientConfig, request);
         final GrizzlyResponseFuture<T> future = new GrizzlyResponseFuture<T>(this, request, handler, proxy);
-        future.setDelegate(SafeFutureImpl.<T>create());
-        final CompletionHandler<Connection>  connectHandler = new CompletionHandler<Connection>() {
+        future.setDelegate(SafeFutureImpl.<T> create());
+        final CompletionHandler<Connection> connectHandler = new CompletionHandler<Connection>() {
             @Override
             public void cancelled() {
                 future.cancel(true);
@@ -155,7 +140,7 @@ public void failed(final Throwable throwable) {
             public void completed(final Connection c) {
                 try {
                     touchConnection(c, request);
-                    execute(c, request, handler, future);
+                    execute(c, request, handler, future, null);
                 } catch (Exception e) {
                     failed(e);
                 }
@@ -179,37 +164,27 @@ public void close() {
 
         try {
             connectionManager.destroy();
-            clientTransport.stop();
+            clientTransport.shutdownNow();
             final ExecutorService service = clientConfig.executorService();
+            // service may be null due to a custom configuration that
+            // leverages Grizzly's SameThreadIOStrategy.
             if (service != null) {
                 service.shutdown();
             }
             if (timeoutExecutor != null) {
                 timeoutExecutor.stop();
+                final ExecutorService threadPool = timeoutExecutor.getThreadPool();
+                if (threadPool != null) {
+                    threadPool.shutdownNow();
+                }
             }
-        } catch (IOException ignored) { }
-
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public Response prepareResponse(HttpResponseStatus status,
-                                    HttpResponseHeaders headers,
-                                    List<HttpResponseBodyPart> bodyParts) {
-
-        return new GrizzlyResponse(status,
-                                   headers,
-                                   bodyParts,
-                                   clientConfig.isRfc6265CookieEncoding());
+        } catch (IOException ignored) {
+        }
 
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
     public AsyncHttpClientConfig getClientConfig() {
         return clientConfig;
     }
@@ -222,33 +197,27 @@ public ConnectionManager getConnectionManager() {
         return resolver;
     }
 
-
     // ------------------------------------------------------- Protected Methods
 
-
-    @SuppressWarnings({"unchecked"})
-    public <T> ListenableFuture<T> execute(final Connection c,
-                                           final Request request,
-                                           final AsyncHandler<T> handler,
-                                           final GrizzlyResponseFuture<T> future) {
-            Utils.addRequestInFlight(c);
-            if (HttpTransactionContext.get(c) == null) {
-                HttpTransactionContext.create(this, future, request, handler, c);
-            }
-            c.write(request, createWriteCompletionHandler(future));
+    @SuppressWarnings({ "unchecked" })
+    public <T> ListenableFuture<T> execute(final Connection c, final Request request, final AsyncHandler<T> handler,
+            final GrizzlyResponseFuture<T> future, final HttpTxContext httpTxContext) {
+        Utils.addRequestInFlight(c);
+        final RequestInfoHolder requestInfoHolder = new RequestInfoHolder(this, request, handler, future, httpTxContext);
+        c.write(requestInfoHolder, createWriteCompletionHandler(future));
 
         return future;
     }
 
-
     void initializeTransport(final AsyncHttpClientConfig clientConfig) {
 
         final FilterChainBuilder secure = FilterChainBuilder.stateless();
-        secure.add(new AsyncHttpClientTransportFilter());
+        secure.add(new TransportFilter());
 
-        final int timeout = clientConfig.getRequestTimeoutInMs();
+        final int timeout = clientConfig.getRequestTimeout();
         if (timeout > 0) {
             int delay = 500;
+            //noinspection ConstantConditions
             if (timeout < delay) {
                 delay = timeout - 10;
                 if (delay <= 0) {
@@ -257,26 +226,23 @@ void initializeTransport(final AsyncHttpClientConfig clientConfig) {
             }
             timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
             timeoutExecutor.start();
-            final IdleTimeoutFilter.TimeoutResolver timeoutResolver =
-                    new IdleTimeoutFilter.TimeoutResolver() {
-                        @Override
-                        public long getTimeout(FilterChainContext ctx) {
-                            final HttpTransactionContext context =
-                                    HttpTransactionContext.get(ctx.getConnection());
-                            if (context != null) {
-                                if (context.isWSRequest()) {
-                                    return clientConfig.getWebSocketIdleTimeoutInMs();
-                                }
-                                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, context.getRequest());
-                                if (requestTimeout > 0) {
-                                    return requestTimeout;
-                                }
-                            }
-                            return IdleTimeoutFilter.FOREVER;
+            final IdleTimeoutFilter.TimeoutResolver timeoutResolver = new IdleTimeoutFilter.TimeoutResolver() {
+                @Override
+                public long getTimeout(FilterChainContext ctx) {
+                    final HttpTxContext context = HttpTxContext.get(ctx);
+                    if (context != null) {
+                        if (context.isWSRequest()) {
+                            return clientConfig.getWebSocketTimeout();
                         }
-                    };
-            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor,
-                    timeoutResolver,
+                        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, context.getRequest());
+                        if (requestTimeout > 0) {
+                            return requestTimeout;
+                        }
+                    }
+                    return IdleTimeoutFilter.FOREVER;
+                }
+            };
+            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor, timeoutResolver,
                     new IdleTimeoutFilter.TimeoutHandler() {
                         public void onTimeout(Connection connection) {
                             timeout(connection);
@@ -289,20 +255,16 @@ public void onTimeout(Connection connection) {
         SSLContext context = clientConfig.getSSLContext();
         if (context == null) {
             try {
-                context = SslUtils.getSSLContext();
+                context = SslUtils.getInstance().getSSLContext(clientConfig.isAcceptAnyCertificate());
             } catch (Exception e) {
                 throw new IllegalStateException(e);
             }
         }
-        final SSLEngineConfigurator configurator =
-                new SSLEngineConfigurator(context,
-                        true,
-                        false,
-                        false);
-        final SwitchingSSLFilter filter = new SwitchingSSLFilter(configurator);
-        secure.add(filter);
-        GrizzlyAsyncHttpProviderConfig providerConfig =
-                        (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
+        final SSLEngineConfigurator configurator = new SSLEngineConfigurator(context, true, false, false);
+        final SwitchingSSLFilter sslFilter = new SwitchingSSLFilter(configurator);
+        secure.add(sslFilter);
+        
+        GrizzlyAsyncHttpProviderConfig providerConfig = (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
 
         boolean npnEnabled = NextProtoNegSupport.isEnabled();
         boolean spdyEnabled = clientConfig.isSpdyEnabled();
@@ -323,13 +285,9 @@ public void onTimeout(Connection connection) {
         }
 
         final AsyncHttpClientEventFilter eventFilter;
-        final EventHandler handler = new EventHandler(this);
+        final EventHandler handler = new EventHandler(clientConfig);
         if (providerConfig != null) {
-            eventFilter =
-                    new AsyncHttpClientEventFilter(handler,
-                                                   (Integer) providerConfig
-                                                           .getProperty(
-                                                                   MAX_HTTP_PACKET_HEADER_SIZE));
+            eventFilter = new AsyncHttpClientEventFilter(handler, (Integer) providerConfig.getProperty(MAX_HTTP_PACKET_HEADER_SIZE));
         } else {
             eventFilter = new AsyncHttpClientEventFilter(handler);
         }
@@ -340,22 +298,34 @@ public void onTimeout(Connection connection) {
                 eventFilter.removeContentEncoding(encoding);
             }
         }
-        if (clientConfig.isCompressionEnabled()) {
-            eventFilter.addContentEncoding(
-                    new GZipContentEncoding(512,
-                                            512,
-                                            new ClientEncodingFilter()));
+        if (clientConfig.isCompressionEnforced()) {
+            eventFilter.addContentEncoding(new GZipContentEncoding(512, 512, new ClientEncodingFilter()));
         }
         secure.add(eventFilter);
-        final AsyncHttpClientFilter clientFilter =
-                new AsyncHttpClientFilter(this, clientConfig);
+        final AsyncHttpClientFilter clientFilter = new AsyncHttpClientFilter(this, clientConfig);
         secure.add(clientFilter);
         secure.add(new WebSocketClientFilter());
 
-
+        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(AUTO_SIZE);
+        
+        clientTransport.setNIOChannelDistributor(
+                new RoundRobinConnectionDistributor(clientTransport, false, false));
+        
+        final int kernelThreadsCount =
+                clientConfig.getIoThreadMultiplier() *
+                Runtime.getRuntime().availableProcessors();
+        
+        clientTransport.setSelectorRunnersCount(kernelThreadsCount);
+        clientTransport.setKernelThreadPoolConfig(
+                ThreadPoolConfig.defaultConfig()
+                .setCorePoolSize(kernelThreadsCount)
+                .setMaxPoolSize(kernelThreadsCount)
+                .setPoolName("grizzly-ahc-kernel")
+//                .setPoolName(Utils.discoverTestName("grizzly-ahc-kernel")) // uncomment for tests to track down the leaked threads
+        );
+        
         if (providerConfig != null) {
-            final TransportCustomizer customizer = (TransportCustomizer)
-                    providerConfig.getProperty(Property.TRANSPORT_CUSTOMIZER);
+            final TransportCustomizer customizer = (TransportCustomizer) providerConfig.getProperty(Property.TRANSPORT_CUSTOMIZER);
             if (customizer != null) {
                 customizer.customize(clientTransport, secure);
             } else {
@@ -368,17 +338,11 @@ public void onTimeout(Connection connection) {
         // FilterChain for the standard HTTP case has been configured, we now
         // copy it and modify for SPDY purposes.
         if (spdyEnabled) {
-            FilterChainBuilder spdyFilterChain =
-                    createSpdyFilterChain(secure, npnEnabled);
-            ProtocolNegotiator pn =
-                    new ProtocolNegotiator(spdyFilterChain.build());
-            NextProtoNegSupport.getInstance()
-                    .setClientSideNegotiator(clientTransport, pn);
+            FilterChainBuilder spdyFilterChain = createSpdyFilterChain(secure, npnEnabled);
+            ProtocolNegotiator pn = new ProtocolNegotiator(spdyFilterChain.build());
+            NextProtoNegSupport.getInstance().setClientSideNegotiator(clientTransport, pn);
         }
 
-        // Don't limit the number of bytes the client can have queued to write.
-        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(-1);
-
         // Install the HTTP filter chain.
         //clientTransport.setProcessor(fcb.build());
         FilterChainBuilder nonSecure = FilterChainBuilder.stateless();
@@ -391,17 +355,12 @@ public void onTimeout(Connection connection) {
         } else {
             pool = null;
         }
-        connectionManager = new ConnectionManager(this,
-                                                  pool,
-                                                  secure,
-                                                  nonSecure);
+        connectionManager = new ConnectionManager(this, pool, secure, nonSecure);
 
     }
 
-
     // ------------------------------------------------- Package Private Methods
 
-
     void touchConnection(final Connection c, final Request request) {
 
         int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, request);
@@ -413,19 +372,15 @@ void touchConnection(final Connection c, final Request request) {
 
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
-    private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb,
-                                                     final boolean npnEnabled) {
+    private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb, final boolean npnEnabled) {
 
         FilterChainBuilder spdyFcb = FilterChainBuilder.stateless();
         spdyFcb.addAll(fcb);
         int idx = spdyFcb.indexOfType(SSLFilter.class);
         Filter f = spdyFcb.get(idx);
 
-
         // Adjust the SSLFilter to support NPN
         if (npnEnabled) {
             SSLBaseFilter sslBaseFilter = (SSLBaseFilter) f;
@@ -437,10 +392,8 @@ private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb,
         idx = spdyFcb.indexOfType(HttpClientFilter.class);
         spdyFcb.set(idx, new SpdyFramingFilter());
         final SpdyMode spdyMode = ((npnEnabled) ? SpdyMode.NPN : SpdyMode.PLAIN);
-        AsyncSpdyClientEventFilter spdyFilter =
-                new AsyncSpdyClientEventFilter(new EventHandler(this),
-                                               spdyMode,
-                                               clientConfig.executorService());
+        AsyncSpdyClientEventFilter spdyFilter = new AsyncSpdyClientEventFilter(new EventHandler(clientConfig), spdyMode,
+                clientConfig.executorService());
         spdyFilter.setInitialWindowSize(clientConfig.getSpdyInitialWindowSize());
         spdyFilter.setMaxConcurrentStreams(clientConfig.getSpdyMaxConcurrentStreams());
         spdyFcb.add(idx + 1, spdyFilter);
@@ -452,16 +405,15 @@ private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb,
         return spdyFcb;
     }
 
-
-
-
     private void doDefaultTransportConfig() {
         final ExecutorService service = clientConfig.executorService();
+        clientTransport.setIOStrategy(WorkerThreadIOStrategy.getInstance());
         if (service != null) {
-            clientTransport.setIOStrategy(WorkerThreadIOStrategy.getInstance());
             clientTransport.setWorkerThreadPool(service);
         } else {
-            clientTransport.setIOStrategy(SameThreadIOStrategy.getInstance());
+            final int multiplier = clientConfig.getIoThreadMultiplier();
+            final int threadCount = multiplier * Runtime.getRuntime().availableProcessors();
+            clientTransport.getWorkerThreadPoolConfig().setCorePoolSize(threadCount).setMaxPoolSize(threadCount);
         }
     }
 
@@ -486,80 +438,38 @@ public void updated(WriteResult result) {
         };
     }
 
-
     void timeout(final Connection c) {
 
-        final HttpTransactionContext context = HttpTransactionContext.get(c);
-        if (context != null) {
-            HttpTransactionContext.set(c, null);
-            context.abort(new TimeoutException("Timeout exceeded"));
-        }
-
-    }
-
-
-    @SuppressWarnings({"unchecked"})
-    public boolean sendRequest(final FilterChainContext ctx,
-                               final Request request,
-                               final HttpRequestPacket requestPacket)
-    throws IOException {
-
-        boolean isWriteComplete = true;
-
-        if (requestHasEntityBody(request)) {
-            final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
-            BodyHandler handler = bodyHandlerFactory.getBodyHandler(request);
-            if (requestPacket.getHeaders().contains(Header.Expect)
-                    && requestPacket.getHeaders().getValue(1).equalsIgnoreCase("100-Continue")) {
-                // We have to set the content-length now as the headers will be flushed
-                // before the FileBodyHandler is invoked.  If we don't do it here, and
-                // the user didn't explicitly set the length, then the transfer-encoding
-                // will be chunked and zero-copy file transfer will not occur.
-                final File f = request.getFile();
-                if (f != null) {
-                    requestPacket.setContentLengthLong(f.length());
-                }
-                handler = new ExpectHandler(handler);
+        final String key = HttpTxContext.class.getName();
+        HttpTxContext ctx;
+        if (!Utils.isSpdyConnection(c)) {
+            ctx = (HttpTxContext) c.getAttributes().getAttribute(key);
+            if (ctx != null) {
+                c.getAttributes().removeAttribute(key);
+                ctx.abort(new TimeoutException("Timeout exceeded"));
             }
-            context.setBodyHandler(handler);
-            isWriteComplete = handler.doHandle(ctx, request, requestPacket);
         } else {
-            HttpContent content = HttpContent.builder(requestPacket).last(true).build();
-            ctx.write(content, ctx.getTransportContext().getCompletionHandler());
+            throw new IllegalStateException();
         }
-        LOGGER.debug("REQUEST: {}", requestPacket);
 
-        return isWriteComplete;
-    }
-
-
-    public static boolean requestHasEntityBody(final Request request) {
-
-        final String method = request.getMethod();
-        return (Method.POST.matchesMethod(method)
-                || Method.PUT.matchesMethod(method)
-                || Method.PATCH.matchesMethod(method)
-                || Method.DELETE.matchesMethod(method));
+        //        if (context != null) {
+        //            HttpTxContext.set(c, null);
+        //            context.abort(new TimeoutException("Timeout exceeded"));
+        //        }
 
     }
 
-
-    // ----------------------------------------------------------- Inner Classes
-
-
     // ---------------------------------------------------------- Nested Classes
 
-
     private static final class ProtocolNegotiator implements ClientSideNegotiator {
+        private static final SpdyVersion[] SUPPORTED_SPDY_VERSIONS =
+                {SpdyVersion.SPDY_3_1, SpdyVersion.SPDY_3};
 
-
-        private static final String SPDY = "spdy/3";
         private static final String HTTP = "HTTP/1.1";
 
         private final FilterChain spdyFilterChain;
         private final SpdyHandlerFilter spdyHandlerFilter;
 
-
         // -------------------------------------------------------- Constructors
 
         private ProtocolNegotiator(final FilterChain spdyFilterChain) {
@@ -568,10 +478,8 @@ private ProtocolNegotiator(final FilterChain spdyFilterChain) {
             spdyHandlerFilter = (SpdyHandlerFilter) spdyFilterChain.get(idx);
         }
 
-
         // ----------------------------------- Methods from ClientSideNegotiator
 
-
         @Override
         public boolean wantNegotiate(SSLEngine engine) {
             GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::wantNegotiate");
@@ -579,25 +487,31 @@ public boolean wantNegotiate(SSLEngine engine) {
         }
 
         @Override
-        public String selectProtocol(SSLEngine engine, LinkedHashSet<String> strings) {
-            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selectProtocol: " + strings);
+        public String selectProtocol(SSLEngine engine, LinkedHashSet<String> protocols) {
+            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selectProtocol: " + protocols);
             final Connection connection = NextProtoNegSupport.getConnection(engine);
 
-            // Give preference to SPDY/3.  If not available, check for HTTP as a
-            // fallback
-            if (strings.contains(SPDY)) {
-                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + SPDY);
-                SSLConnectionContext sslCtx =
-                                        SSLUtils.getSslConnectionContext(connection);
-                                sslCtx.setNewConnectionFilterChain(spdyFilterChain);
-                final SpdySession spdySession =
-                        new SpdySession(connection, false, spdyHandlerFilter);
-                spdySession.setLocalInitialWindowSize(spdyHandlerFilter.getInitialWindowSize());
-                spdySession.setLocalMaxConcurrentStreams(spdyHandlerFilter.getMaxConcurrentStreams());
-
-                SpdySession.bind(connection, spdySession);
-                return SPDY;
-            } else if (strings.contains(HTTP)) {
+            // Give preference to SPDY/3.1 or SPDY/3.  If not available, check for HTTP as a
+            // fallback            
+            for (SpdyVersion version : SUPPORTED_SPDY_VERSIONS) {
+                final String versionDef = version.toString();
+                if (protocols.contains(versionDef)) {
+                    GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + versionDef);
+                    SSLConnectionContext sslCtx = SSLUtils.getSslConnectionContext(connection);
+                    sslCtx.setNewConnectionFilterChain(spdyFilterChain);
+                    final SpdySession spdySession =
+                            version.newSession(connection, false, spdyHandlerFilter);
+
+                    spdySession.setLocalStreamWindowSize(spdyHandlerFilter.getInitialWindowSize());
+                    spdySession.setLocalMaxConcurrentStreams(spdyHandlerFilter.getMaxConcurrentStreams());
+                    Utils.setSpdyConnection(connection);
+                    SpdySession.bind(connection, spdySession);
+
+                    return versionDef;
+                }
+            }
+            
+            if (protocols.contains(HTTP)) {
                 GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + HTTP);
                 // Use the default HTTP FilterChain.
                 return HTTP;
@@ -617,14 +531,9 @@ public void onNoDeal(SSLEngine engine) {
         }
     }
 
-
     public static interface Cleanup {
 
         void cleanup(final FilterChainContext ctx);
 
     }
-
 }
-
-
-
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
index dd1d940e5..662eb6a5d 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
@@ -31,7 +31,7 @@
  * @author The Grizzly Team
  * @since 1.7.0
  */
-public class GrizzlyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<GrizzlyAsyncHttpProviderConfig.Property,Object> {
+public class GrizzlyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<GrizzlyAsyncHttpProviderConfig.Property, Object> {
 
     /**
      * Grizzly-specific customization properties.  Each property describes
@@ -74,34 +74,47 @@
          */
         NPN_ENABLED(Boolean.class, true),
 
-
         /**
          * Grizzly specific connection pool.
          */
         CONNECTION_POOL(ConnectionPool.class, null);
-        
-        
+
         final Object defaultValue;
         final Class<?> type;
-        
+
         private Property(final Class<?> type, final Object defaultValue) {
             this.type = type;
             this.defaultValue = defaultValue;
         }
-        
+
         private Property(final Class<?> type) {
             this(type, null);
         }
-        
+
         boolean hasDefaultValue() {
             return (defaultValue != null);
         }
-        
-        
+
     } // END PROPERTY
-    
-    private final Map<Property,Object> attributes = new HashMap<Property,Object>();
-    
+
+    private final Map<Property, Object> attributes = new HashMap<Property, Object>();
+
+    /**
+     * @return <code>true</code> if the underlying provider should make new connections asynchronously or not.  By default
+     *  new connections are made synchronously.
+     *
+     * @since 2.0.0
+     */
+    private boolean asyncConnectMode;
+
+    public boolean isAsyncConnectMode() {
+        return asyncConnectMode;
+    }
+
+    public void setAsyncConnectMode(boolean asyncConnectMode) {
+        this.asyncConnectMode = asyncConnectMode;
+    }
+
     // ------------------------------------ Methods from AsyncHttpProviderConfig
 
     /**
@@ -124,12 +137,9 @@ public AsyncHttpProviderConfig addProperty(Property name, Object value) {
             }
         } else {
             if (!name.type.isAssignableFrom(value.getClass())) {
-                throw new IllegalArgumentException(
-                        String.format(
-                                "The value of property [%s] must be of type [%s].  Type of value provided: [%s].",
-                                name.name(),
-                                name.type.getName(),
-                                value.getClass().getName()));
+                throw new IllegalArgumentException(String.format(
+                        "The value of property [%s] must be of type [%s].  Type of value provided: [%s].", name.name(),
+                        name.type.getName(), value.getClass().getName()));
             }
         }
         attributes.put(name, value);
@@ -165,8 +175,7 @@ public Object removeProperty(Property name) {
       * {@inheritDoc}
       */
     @Override
-    public Set<Map.Entry<Property,Object>> propertiesSet() {
+    public Set<Map.Entry<Property, Object>> propertiesSet() {
         return attributes.entrySet();
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
index 25aed3269..a1825f1b5 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
@@ -13,25 +13,26 @@
 
 package org.asynchttpclient.providers.grizzly;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.glassfish.grizzly.http.CookiesBuilder.ServerCookiesBuilder;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.Cookie;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.providers.ResponseBase;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.http.Cookies;
-import org.glassfish.grizzly.utils.Charsets;
+import org.glassfish.grizzly.http.CookiesBuilder.ServerCookiesBuilder;
+import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.memory.Buffers;
 import org.glassfish.grizzly.memory.MemoryManager;
 import org.glassfish.grizzly.utils.BufferInputStream;
+import org.glassfish.grizzly.utils.Charsets;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -45,78 +46,49 @@
  * @since 1.7.0
  */
 public class GrizzlyResponse extends ResponseBase {
-    private final Buffer responseBody;
-    private final Boolean rfc6265Enabled;
 
-    // ------------------------------------------------------------ Constructors
+    private Buffer responseBody;
+    private boolean initialized;
 
+    // ------------------------------------------------------------ Constructors
 
-    public GrizzlyResponse(final HttpResponseStatus status,
-                           final HttpResponseHeaders headers,
-                           final List<HttpResponseBodyPart> bodyParts,
-                           final boolean rfc6265Enabled) {
+    public GrizzlyResponse(final HttpResponseStatus status, final HttpResponseHeaders headers, final List<HttpResponseBodyPart> bodyParts) {
         super(status, headers, bodyParts);
-        this.rfc6265Enabled = rfc6265Enabled;
-        if (isNonEmpty(bodyParts)) {
-            if (bodyParts.size() == 1) {
-                responseBody = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
-            } else {
-                final Buffer firstBuffer = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
-                final MemoryManager<?> mm = MemoryManager.DEFAULT_MEMORY_MANAGER;
-                Buffer constructedBodyBuffer = firstBuffer;
-                for (int i = 1, len = bodyParts.size(); i < len; i++) {
-                    constructedBodyBuffer =
-                            Buffers.appendBuffers(mm,
-                                    constructedBodyBuffer,
-                                    ((GrizzlyResponseBodyPart) bodyParts.get(i)).getBodyBuffer());
-                }
-                responseBody = constructedBodyBuffer;
-            }
-        } else {
-            responseBody = Buffers.EMPTY_BUFFER;
-        }
     }
 
-
     // --------------------------------------------------- Methods from Response
 
     /**
      * {@inheritDoc}
      */
     public InputStream getResponseBodyAsStream() throws IOException {
-
-        return new BufferInputStream(responseBody);
-
+        return new BufferInputStream(getResponseBody0());
     }
 
-
     /**
      * {@inheritDoc}
      */
     public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-       charset = calculateCharset(charset);
+        charset = calculateCharset(charset);
+        final Buffer responseBody = getResponseBody0();
         final int len = Math.min(responseBody.remaining(), maxLength);
         final int pos = responseBody.position();
         return responseBody.toStringContent(getCharset(charset), pos, len + pos);
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     public String getResponseBody(String charset) throws IOException {
-
-        return responseBody.toStringContent(getCharset(charset));
-
+        return getResponseBody0().toStringContent(getCharset(charset));
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public byte[] getResponseBodyAsBytes() throws IOException {
+        final Buffer responseBody = getResponseBody0();
         final byte[] responseBodyBytes = new byte[responseBody.remaining()];
         final int origPos = responseBody.position();
         responseBody.get(responseBodyBytes);
@@ -124,24 +96,23 @@ public String getResponseBody(String charset) throws IOException {
         return responseBodyBytes;
     }
 
+    @Override
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return ByteBuffer.wrap(getResponseBodyAsBytes());
+    }
 
     /**
      * {@inheritDoc}
      */
     public String getResponseBodyExcerpt(int maxLength) throws IOException {
-
         return getResponseBodyExcerpt(maxLength, null);
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     public String getResponseBody() throws IOException {
-
         return getResponseBody(null);
-
     }
 
     /**
@@ -149,7 +120,7 @@ public String getResponseBody() throws IOException {
      */
     @SuppressWarnings("UnusedDeclaration")
     public Buffer getResponseBodyAsBuffer() {
-        return responseBody;
+        return getResponseBody0();
     }
 
     /**
@@ -157,46 +128,33 @@ public Buffer getResponseBodyAsBuffer() {
      */
     public List<Cookie> buildCookies() {
 
-        List<String> values = headers.getHeaders().get("set-cookie");
+        List<String> values = headers.getHeaders().get(Header.SetCookie.toString());
         if (isNonEmpty(values)) {
-            ServerCookiesBuilder builder = new ServerCookiesBuilder(false, rfc6265Enabled);
-            for (String header : values) {
-                builder.parse(header);
+            ServerCookiesBuilder builder = new ServerCookiesBuilder(false, true);
+            for (int i = 0, len = values.size(); i < len; i++) {
+                builder.parse(values.get(i));
             }
             return convertCookies(builder.build());
 
         } else {
-            return Collections.unmodifiableList(Collections.<Cookie>emptyList());
+            return Collections.unmodifiableList(Collections.<Cookie> emptyList());
         }
     }
 
     // --------------------------------------------------------- Private Methods
 
-
     private List<Cookie> convertCookies(Cookies cookies) {
 
         final org.glassfish.grizzly.http.Cookie[] grizzlyCookies = cookies.get();
         List<Cookie> convertedCookies = new ArrayList<Cookie>(grizzlyCookies.length);
-        for (org.glassfish.grizzly.http.Cookie gCookie : grizzlyCookies) {
-            convertedCookies.add(new Cookie(gCookie.getDomain(),
-                                   gCookie.getName(),
-                                   gCookie.getValue(),
-                                   gCookie.getValue(),
-                                   gCookie.getPath(),
-                                   gCookie.getMaxAge(),
-                                   gCookie.isSecure(),
-                                   gCookie.getVersion(),
-                                   gCookie.isHttpOnly(),
-                                   false,
-                                   gCookie.getComment(),
-                                   null,
-                                   Collections.<Integer> emptySet()));
+        for (int i = 0, len = grizzlyCookies.length; i < len; i++) {
+            org.glassfish.grizzly.http.Cookie gCookie = grizzlyCookies[i];
+            convertedCookies.add(new Cookie(gCookie.getName(), gCookie.getValue(), gCookie.getValue(), gCookie.getDomain(), gCookie
+                    .getPath(), -1L, gCookie.getMaxAge(), gCookie.isSecure(), gCookie.isHttpOnly()));
         }
         return Collections.unmodifiableList(convertedCookies);
-
     }
 
-
     private Charset getCharset(final String charset) {
 
         String charsetLocal = charset;
@@ -213,6 +171,28 @@ private Charset getCharset(final String charset) {
         }
 
         return Charsets.lookupCharset(charsetLocal);
+    }
 
+    private synchronized Buffer getResponseBody0() {
+        if (!initialized) {
+            if (isNonEmpty(bodyParts)) {
+                if (bodyParts.size() == 1) {
+                    responseBody = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
+                } else {
+                    final Buffer firstBuffer = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
+                    final MemoryManager<?> mm = MemoryManager.DEFAULT_MEMORY_MANAGER;
+                    Buffer constructedBodyBuffer = firstBuffer;
+                    for (int i = 1, len = bodyParts.size(); i < len; i++) {
+                        constructedBodyBuffer = Buffers.appendBuffers(mm, constructedBodyBuffer,
+                                ((GrizzlyResponseBodyPart) bodyParts.get(i)).getBodyBuffer());
+                    }
+                    responseBody = constructedBodyBuffer;
+                }
+            } else {
+                responseBody = Buffers.EMPTY_BUFFER;
+            }
+            initialized = true;
+        }
+        return responseBody;
     }
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
index e0a2931ac..451ddae21 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
@@ -13,9 +13,7 @@
 
 package org.asynchttpclient.providers.grizzly;
 
-import org.asynchttpclient.AsyncHttpProvider;
 import org.asynchttpclient.HttpResponseBodyPart;
-
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.http.HttpContent;
@@ -24,7 +22,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.URI;
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -39,27 +36,17 @@
 
     private final HttpContent content;
     private final Connection<?> connection;
-    private final AtomicReference<byte[]> contentBytes =
-            new AtomicReference<byte[]>();
-
+    private final AtomicReference<byte[]> contentBytes = new AtomicReference<byte[]>();
 
     // ------------------------------------------------------------ Constructors
 
-
-    public GrizzlyResponseBodyPart(final HttpContent content,
-                                   final URI uri,
-                                   final Connection<?> connection,
-                                   final AsyncHttpProvider provider) {
-        super(uri, provider);
+    public GrizzlyResponseBodyPart(final HttpContent content, final Connection<?> connection) {
         this.content = content;
         this.connection = connection;
-
     }
 
-
     // --------------------------------------- Methods from HttpResponseBodyPart
 
-
     /**
      * {@inheritDoc}
      */
@@ -76,7 +63,6 @@ public GrizzlyResponseBodyPart(final HttpContent content,
         b.position(origPos);
         contentBytes.compareAndSet(null, bytes);
         return bytes;
-
     }
 
     @Override
@@ -88,7 +74,7 @@ public InputStream readBodyPartBytes() {
     public int length() {
         return content.getContent().remaining();
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -98,18 +84,14 @@ public int writeTo(OutputStream outputStream) throws IOException {
         final byte[] bytes = getBodyPartBytes();
         outputStream.write(bytes);
         return bytes.length;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public ByteBuffer getBodyByteBuffer() {
-
         return content.getContent().toByteBuffer();
-
     }
 
     /**
@@ -124,7 +106,7 @@ public boolean isLast() {
      * {@inheritDoc}
      */
     @Override
-    public void markUnderlyingConnectionAsClosed() {
+    public void markUnderlyingConnectionAsToBeClosed() {
         ConnectionManager.markConnectionAsDoNotCache(connection);
     }
 
@@ -132,18 +114,13 @@ public void markUnderlyingConnectionAsClosed() {
      * {@inheritDoc}
      */
     @Override
-    public boolean closeUnderlyingConnection() {
+    public boolean isUnderlyingConnectionToBeClosed() {
         return !ConnectionManager.isConnectionCacheable(connection);
     }
 
-
     // ----------------------------------------------- Package Protected Methods
 
-
     Buffer getBodyBuffer() {
-
         return content.getContent();
-
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
index 92534f502..3a13110f7 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
@@ -17,11 +17,9 @@
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.listenable.AbstractListenableFuture;
-
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.impl.FutureImpl;
 
-import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -47,14 +45,10 @@
 
     FutureImpl<V> delegate;
 
-
     // ------------------------------------------------------------ Constructors
 
-
-    public GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider,
-                          final Request request,
-                          final AsyncHandler handler,
-                          final ProxyServer proxyServer) {
+    public GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider, final Request request, final AsyncHandler handler,
+            final ProxyServer proxyServer) {
 
         this.provider = provider;
         this.request = request;
@@ -62,20 +56,16 @@ public GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider,
         this.proxyServer = proxyServer;
     }
 
-
     // ----------------------------------- Methods from AbstractListenableFuture
 
-
-    public void done(Callable callable) {
+    public void done() {
 
         if (!done.compareAndSet(false, true) || cancelled.get()) {
             return;
         }
-        done();
-
+        runListeners();
     }
 
-
     public void abort(Throwable t) {
 
         if (done.get() || !cancelled.compareAndSet(false, true)) {
@@ -89,46 +79,29 @@ public void abort(Throwable t) {
             }
         }
         closeConnection();
-        done();
-
-    }
-
-
-    public void content(V v) {
-
-        delegate.result(v);
-
+        runListeners();
     }
 
-
     public void touch() {
-
         provider.touchConnection(connection, request);
-
     }
 
-
     public boolean getAndSetWriteHeaders(boolean writeHeaders) {
 
         // TODO This doesn't currently do anything - and may not make sense
         // with our implementation.  Needs further analysis.
         return writeHeaders;
-
     }
 
-
     public boolean getAndSetWriteBody(boolean writeBody) {
 
         // TODO This doesn't currently do anything - and may not make sense
         // with our implementation.  Needs further analysis.
         return writeBody;
-
     }
 
-
     // ----------------------------------------------------- Methods from Future
 
-
     public boolean cancel(boolean mayInterruptIfRunning) {
 
         if (done.get() || !cancelled.compareAndSet(false, true)) {
@@ -140,33 +113,22 @@ public boolean cancel(boolean mayInterruptIfRunning) {
             } catch (Throwable ignore) {
             }
         }
-        done();
+        runListeners();
         return delegate.cancel(mayInterruptIfRunning);
-
     }
 
-
     public boolean isCancelled() {
-
         return delegate.isCancelled();
-
     }
 
-
     public boolean isDone() {
-
         return delegate.isDone();
-
     }
 
-
     public V get() throws InterruptedException, ExecutionException {
-
         return delegate.get();
-
     }
 
-
     public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
 
         if (!delegate.isCancelled() || !delegate.isDone()) {
@@ -174,36 +136,25 @@ public V get(long timeout, TimeUnit unit) throws InterruptedException, Execution
         } else {
             return null;
         }
-
     }
 
-
     // ------------------------------------------------- Package Private Methods
 
-
     void setConnection(final Connection connection) {
-
         this.connection = connection;
-
     }
 
-
     public void setDelegate(final FutureImpl<V> delegate) {
-
         this.delegate = delegate;
-
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private void closeConnection() {
 
         if (connection != null && connection.isOpen()) {
             connection.close().recycle(true);
         }
-
     }
 
     public ProxyServer getProxyServer() {
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
index 4352a51a9..6e0893b16 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
@@ -13,16 +13,11 @@
 
 package org.asynchttpclient.providers.grizzly;
 
-import org.asynchttpclient.AsyncHttpProvider;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseHeaders;
-
 import org.glassfish.grizzly.http.HttpResponsePacket;
 import org.glassfish.grizzly.http.util.MimeHeaders;
 
-import java.net.URI;
-
-
 /**
  * {@link HttpResponseHeaders} implementation using the Grizzly 2.0 HTTP client
  * codec.
@@ -32,39 +27,35 @@
  */
 class GrizzlyResponseHeaders extends HttpResponseHeaders {
 
-    private final FluentCaseInsensitiveStringsMap headers =
-            new FluentCaseInsensitiveStringsMap();
+    private FluentCaseInsensitiveStringsMap headers;
+    private MimeHeaders grizzlyHeaders;
 
     // ------------------------------------------------------------ Constructors
 
+    public GrizzlyResponseHeaders(final HttpResponsePacket response) {
 
-    public GrizzlyResponseHeaders(final HttpResponsePacket response,
-                                  final URI uri,
-                                  final AsyncHttpProvider provider) {
-
-        super(uri, provider);
-        final MimeHeaders headersLocal = response.getHeaders();
-        for (String name : headersLocal.names()) {
-            for (String header : headersLocal.values(name)) {
-                headers.add(name, header);
-            }
-        }
-
+        grizzlyHeaders = new MimeHeaders();
+        grizzlyHeaders.copyFrom(response.getHeaders());
     }
 
-
     // ---------------------------------------- Methods from HttpResponseHeaders
 
-
     /**
      * {@inheritDoc}
      */
     @Override
-    public FluentCaseInsensitiveStringsMap getHeaders() {
+    public synchronized FluentCaseInsensitiveStringsMap getHeaders() {
+        if (headers == null) {
+            headers = new FluentCaseInsensitiveStringsMap();
+            for (String name : grizzlyHeaders.names()) {
+                for (String header : grizzlyHeaders.values(name)) {
+                    headers.add(name, header);
+                }
+            }
+        }
         return headers;
     }
 
-
     @Override
     public String toString() {
         return getHeaders().toString();
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
index e4e74e3c9..882f0eed0 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,12 +13,15 @@
 
 package org.asynchttpclient.providers.grizzly;
 
-import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.http.HttpResponsePacket;
 
-import java.net.URI;
+import java.util.List;
 
 /**
  * {@link HttpResponseStatus} implementation using the Grizzly 2.0 HTTP client
@@ -35,92 +38,81 @@
     private final int majorVersion;
     private final int minorVersion;
     private final String protocolText;
-
-
-
+    private final HttpResponsePacket response;
+    
     // ------------------------------------------------------------ Constructors
 
+    public GrizzlyResponseStatus(final HttpResponsePacket response, final Uri uri, AsyncHttpClientConfig config) {
 
-    public GrizzlyResponseStatus(final HttpResponsePacket response,
-                                 final URI uri,
-                                 final AsyncHttpProvider provider) {
-
-        super(uri, provider);
+        super(uri, config);
         statusCode = response.getStatus();
         statusText = response.getReasonPhrase();
         majorVersion = response.getProtocol().getMajorVersion();
         minorVersion = response.getProtocol().getMinorVersion();
         protocolText = response.getProtocolString();
-
+        
+        this.response = response;
     }
 
-
     // ----------------------------------------- Methods from HttpResponseStatus
 
+    @Override
+    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
+        return new GrizzlyResponse(this, headers, bodyParts);
+    }
 
     /**
      * {@inheritDoc}
      */
     @Override
     public int getStatusCode() {
-
         return statusCode;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public String getStatusText() {
-
         return statusText;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public String getProtocolName() {
-
         return PROTOCOL_NAME;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public int getProtocolMajorVersion() {
-
         return majorVersion;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public int getProtocolMinorVersion() {
-
         return minorVersion;
-
     }
 
-
     /**
      * {@inheritDoc}
      */
     @Override
     public String getProtocolText() {
-
         return protocolText;
-
     }
 
+    /**
+     * @return internal Grizzly {@link HttpResponsePacket}
+     */
+    public HttpResponsePacket getResponse() {
+        return response;
+    }
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java
similarity index 58%
rename from providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java
index 5e726acac..15aae3159 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -17,24 +17,33 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
 import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
+import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 import org.asynchttpclient.websocket.WebSocket;
-import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.CloseListener;
+import org.glassfish.grizzly.CloseType;
+import org.glassfish.grizzly.Closeable;
 import org.glassfish.grizzly.Grizzly;
 import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.attributes.AttributeStorage;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContext;
 import org.glassfish.grizzly.websockets.HandShake;
 import org.glassfish.grizzly.websockets.ProtocolHandler;
 
-import java.util.concurrent.Callable;
+import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus;
+import org.asynchttpclient.providers.grizzly.filters.events.GracefulCloseEvent;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChain;
+import org.glassfish.grizzly.http.HttpResponsePacket;
 
-public final class HttpTransactionContext {
+public final class HttpTxContext {
 
-    private static final Attribute<HttpTransactionContext> REQUEST_STATE_ATTR =
-                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(HttpTransactionContext.class.getName());
+    private static final Attribute<HttpTxContext> REQUEST_STATE_ATTR = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
+            .createAttribute(HttpTxContext.class.getName());
 
     private final AtomicInteger redirectCount = new AtomicInteger(0);
 
@@ -43,7 +52,7 @@
     private final GrizzlyAsyncHttpProvider provider;
 
     private Request request;
-    private String requestUrl;
+    private Uri requestUri;
     private final AsyncHandler handler;
     private BodyHandler bodyHandler;
     private StatusHandler statusHandler;
@@ -54,66 +63,75 @@
     private final AtomicLong totalBodyWritten = new AtomicLong();
     private AsyncHandler.STATE currentState;
 
-    private String wsRequestURI;
+    private Uri wsRequestURI;
     private boolean isWSRequest;
     private HandShake handshake;
     private ProtocolHandler protocolHandler;
     private WebSocket webSocket;
-    private boolean establishingTunnel;
-
+    private final CloseListener listener = new CloseListener<Closeable, CloseType>() {
+        @Override
+        public void onClosed(Closeable closeable, CloseType type) throws IOException {
+            if (responseStatus != null && // responseStatus==null if request wasn't even sent
+                    isGracefullyFinishResponseOnClose()) {
+                // Connection was closed.
+                // This event is fired only for responses, which don't have
+                // associated transfer-encoding or content-length.
+                // We have to complete such a request-response processing gracefully.
+                final Connection c = responseStatus.getResponse()
+                        .getRequest().getConnection();
+                final FilterChain fc = (FilterChain) c.getProcessor();
+                
+                fc.fireEventUpstream(c,
+                        new GracefulCloseEvent(HttpTxContext.this), null);
+            } else if (CloseType.REMOTELY.equals(type)) {
+                abort(AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION);
+            }
+        }
+    };
 
     // -------------------------------------------------------- Constructors
 
-
-    private HttpTransactionContext(GrizzlyAsyncHttpProvider provider,
-                           final GrizzlyResponseFuture future,
-                           final Request request,
-                           final AsyncHandler handler) {
+    private HttpTxContext(final GrizzlyAsyncHttpProvider provider, final GrizzlyResponseFuture future, final Request request,
+            final AsyncHandler handler) {
         this.provider = provider;
-
         this.future = future;
         this.request = request;
         this.handler = handler;
-        redirectsAllowed = this.provider.getClientConfig().isRedirectEnabled();
+        redirectsAllowed = this.provider.getClientConfig().isFollowRedirect();
         maxRedirectCount = this.provider.getClientConfig().getMaxRedirects();
-        this.requestUrl = request.getUrl();
-
+        this.requestUri = request.getUri();
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
+    public static void set(final FilterChainContext ctx, final HttpTxContext httpTxContext) {
+        HttpContext httpContext = HttpContext.get(ctx);
+        httpContext.getCloseable().addCloseListener(httpTxContext.listener);
+        REQUEST_STATE_ATTR.set(httpContext, httpTxContext);
+    }
 
-    public static void set(final AttributeStorage storage,
-                           final HttpTransactionContext httpTransactionState) {
-
-        if (httpTransactionState == null) {
-            REQUEST_STATE_ATTR.remove(storage);
-        } else {
-            REQUEST_STATE_ATTR.set(storage, httpTransactionState);
+    public static HttpTxContext remove(final FilterChainContext ctx) {
+        final HttpContext httpContext = HttpContext.get(ctx);
+        final HttpTxContext httpTxContext = REQUEST_STATE_ATTR.remove(httpContext);
+        if (httpTxContext != null) {
+            httpContext.getCloseable().removeCloseListener(httpTxContext.listener);
         }
-
+        
+        return httpTxContext;
     }
 
-    public static HttpTransactionContext get(final AttributeStorage storage) {
-
-        return REQUEST_STATE_ATTR.get(storage);
-
+    public static HttpTxContext get(FilterChainContext ctx) {
+        HttpContext httpContext = HttpContext.get(ctx);
+        return ((httpContext != null) ? REQUEST_STATE_ATTR.get(httpContext) : null);
     }
 
-
-    public static HttpTransactionContext create(final GrizzlyAsyncHttpProvider provider,
-                                                final GrizzlyResponseFuture future,
-                                                final Request request,
-                                                final AsyncHandler handler,
-                                                final AttributeStorage storage) {
-        final HttpTransactionContext context =
-                new HttpTransactionContext(provider, future, request, handler);
-        set(storage, context);
-        return context;
+    public static HttpTxContext create(final RequestInfoHolder requestInfoHolder) {
+        return new HttpTxContext(requestInfoHolder.getProvider(),//
+                requestInfoHolder.getFuture(),//
+                requestInfoHolder.getRequest(),//
+                requestInfoHolder.getHandler());
     }
 
-
     public void abort(final Throwable t) {
         if (future != null) {
             future.abort(t);
@@ -144,12 +162,12 @@ public void setRequest(Request request) {
         this.request = request;
     }
 
-    public String getRequestUrl() {
-        return requestUrl;
+    public Uri getRequestUri() {
+        return requestUri;
     }
 
-    public void setRequestUrl(String requestUrl) {
-        this.requestUrl = requestUrl;
+    public void setRequestUri(Uri requestUri) {
+        this.requestUri = requestUri;
     }
 
     public AsyncHandler getHandler() {
@@ -216,11 +234,11 @@ public void setCurrentState(AsyncHandler.STATE currentState) {
         this.currentState = currentState;
     }
 
-    public String getWsRequestURI() {
+    public Uri getWsRequestURI() {
         return wsRequestURI;
     }
 
-    public void setWsRequestURI(String wsRequestURI) {
+    public void setWsRequestURI(Uri wsRequestURI) {
         this.wsRequestURI = wsRequestURI;
     }
 
@@ -256,24 +274,16 @@ public void setWebSocket(WebSocket webSocket) {
         this.webSocket = webSocket;
     }
 
-    public boolean isEstablishingTunnel() {
-        return establishingTunnel;
-    }
-
-    public void setEstablishingTunnel(boolean establishingTunnel) {
-        this.establishingTunnel = establishingTunnel;
+    private boolean isGracefullyFinishResponseOnClose() {
+        final HttpResponsePacket response = responseStatus.getResponse();
+        return !response.getProcessingState().isKeepAlive() &&
+                !response.isChunked() && response.getContentLength() == -1;
     }
-
-
+    
     // ------------------------------------------------- Package Private Methods
 
-
-    public HttpTransactionContext copy() {
-        final HttpTransactionContext newContext =
-                new HttpTransactionContext(provider,
-                                           future,
-                                           request,
-                                           handler);
+    public HttpTxContext copy() {
+        final HttpTxContext newContext = new HttpTxContext(provider, future, request, handler);
         newContext.invocationStatus = invocationStatus;
         newContext.bodyHandler = bodyHandler;
         newContext.currentState = currentState;
@@ -281,30 +291,19 @@ public HttpTransactionContext copy() {
         newContext.lastRedirectURI = lastRedirectURI;
         newContext.redirectCount.set(redirectCount.get());
         return newContext;
-
     }
 
-    void done(final Callable c) {
+    void done() {
         if (future != null) {
-            future.done(c);
+            future.done();
         }
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings({ "unchecked" })
     void result(Object result) {
         if (future != null) {
             future.delegate.result(result);
-            future.done(null);
+            future.done();
         }
     }
-
-    public boolean isTunnelEstablished(final Connection c) {
-        return c.getAttributes().getAttribute("tunnel-established") != null;
-    }
-
-
-    public void tunnelEstablished(final Connection c) {
-        c.getAttributes().setAttribute("tunnel-established", Boolean.TRUE);
-    }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
index 7d9744ce1..6276280be 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
@@ -17,6 +17,7 @@
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.providers.grizzly.filters.ProxyFilter;
 import org.asynchttpclient.providers.grizzly.filters.TunnelFilter;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.Processor;
 import org.glassfish.grizzly.filterchain.FilterChain;
 import org.glassfish.grizzly.filterchain.FilterChainBuilder;
@@ -24,51 +25,37 @@
 import org.glassfish.grizzly.nio.transport.TCPNIOConnectorHandler;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
 
-import java.net.URI;
-
-
 final class ProxyAwareConnectorHandler extends TCPNIOConnectorHandler {
 
     private FilterChainBuilder nonSecureTemplate;
     private FilterChainBuilder secureTemplate;
     private AsyncHttpClientConfig clientConfig;
-    private URI uri;
+    private Uri uri;
     private ProxyServer proxyServer;
 
     // ------------------------------------------------------------ Constructors
 
-
     private ProxyAwareConnectorHandler(final TCPNIOTransport transport) {
         super(transport);
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
     public static Builder builder(final TCPNIOTransport transport) {
         return new ProxyAwareConnectorHandler.Builder(transport);
     }
 
-
     // ------------------------------------------- Methods from ConnectorHandler
 
-
     @Override
     public Processor getProcessor() {
-        return ((proxyServer != null)
-                    ? createProxyFilterChain()
-                    : createFilterChain());
+        return ((proxyServer != null) ? createProxyFilterChain() : createFilterChain());
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private FilterChain createFilterChain() {
-        return Utils.isSecure(uri)
-                   ? secureTemplate.build()
-                   : nonSecureTemplate.build();
+        return Utils.isSecure(uri) ? secureTemplate.build() : nonSecureTemplate.build();
     }
 
     private FilterChain createProxyFilterChain() {
@@ -96,60 +83,52 @@ private void updateNonSecureFilterChain(final FilterChainBuilder builder) {
         builder.add(idx + 1, new ProxyFilter(proxyServer, clientConfig, false));
     }
 
-
     // ---------------------------------------------------------- Nested Classes
 
-
     public static final class Builder extends TCPNIOConnectorHandler.Builder {
 
         final ProxyAwareConnectorHandler connectorHandler;
 
-
         // -------------------------------------------------------- Constructors
 
-
         private Builder(final TCPNIOTransport transport) {
-            super(transport);
             connectorHandler = new ProxyAwareConnectorHandler(transport);
         }
 
-
         // ----------------------------------------------------- Builder Methods
 
-
-        public Builder setSecureFilterChainTemplate(final FilterChainBuilder secureTemplate) {
+        public Builder secureFilterChainTemplate(final FilterChainBuilder secureTemplate) {
             connectorHandler.secureTemplate = secureTemplate;
             return this;
         }
 
-        public Builder setNonSecureFilterChainTemplate(final FilterChainBuilder nonSecureTemplate) {
+        public Builder nonSecureFilterChainTemplate(final FilterChainBuilder nonSecureTemplate) {
             connectorHandler.nonSecureTemplate = nonSecureTemplate;
             return this;
         }
 
-        public Builder setAsyncHttpClientConfig(final AsyncHttpClientConfig clientConfig) {
+        public Builder asyncHttpClientConfig(final AsyncHttpClientConfig clientConfig) {
             connectorHandler.clientConfig = clientConfig;
             return this;
         }
 
-        public Builder setURI(final URI uri) {
+        public Builder uri(final Uri uri) {
             connectorHandler.uri = uri;
             return this;
         }
 
-        public Builder setProxyServer(final ProxyServer proxyServer) {
+        public Builder proxyServer(final ProxyServer proxyServer) {
             connectorHandler.proxyServer = proxyServer;
             return this;
         }
 
         @Override
         public ProxyAwareConnectorHandler build() {
-            assert(connectorHandler.secureTemplate != null);
-            assert(connectorHandler.nonSecureTemplate != null);
-            assert(connectorHandler.clientConfig != null);
-            assert(connectorHandler.uri != null);
+            assert (connectorHandler.secureTemplate != null);
+            assert (connectorHandler.nonSecureTemplate != null);
+            assert (connectorHandler.clientConfig != null);
+            assert (connectorHandler.uri != null);
             return connectorHandler;
         }
-
     } // END Builder
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java
new file mode 100644
index 000000000..94dfbdbd4
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+
+public class RequestInfoHolder {
+
+    private final GrizzlyAsyncHttpProvider provider;
+    private final Request request;
+    private final AsyncHandler handler;
+    private final GrizzlyResponseFuture future;
+    private final HttpTxContext httpTxContext;
+
+    // ------------------------------------------------------------ Constructors
+
+    public RequestInfoHolder(final GrizzlyAsyncHttpProvider provider, final Request request, final AsyncHandler handler,
+            final GrizzlyResponseFuture future, final HttpTxContext httpTxContext) {
+        this.provider = provider;
+        this.request = request;
+        this.handler = handler;
+        this.future = future;
+        this.httpTxContext = httpTxContext;
+    }
+
+    // ---------------------------------------------------------- Public Methods
+
+    public GrizzlyAsyncHttpProvider getProvider() {
+        return provider;
+    }
+
+    public Request getRequest() {
+        return request;
+    }
+
+    public AsyncHandler getHandler() {
+        return handler;
+    }
+
+    public GrizzlyResponseFuture getFuture() {
+        return future;
+    }
+
+    public HttpTxContext getHttpTxContext() {
+        return httpTxContext;
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
index 8d86c4b39..34d5fe43f 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
@@ -38,7 +38,5 @@
      *   These filters should generally be left alone.  But this does allow
      *   adding additional filters to the chain to add additional features.
      */
-    void customize(final TCPNIOTransport transport,
-                   final FilterChainBuilder filterChainBuilder);
-    
+    void customize(final TCPNIOTransport transport, final FilterChainBuilder filterChainBuilder);
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
index 31b4dd48f..44e1143a4 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,36 +13,30 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.Grizzly;
 import org.glassfish.grizzly.attributes.Attribute;
 import org.glassfish.grizzly.attributes.AttributeStorage;
 
-import java.net.URI;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public final class Utils {
 
-    private static final Attribute<Boolean> IGNORE =
-            Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IGNORE");
-    private static final Attribute<AtomicInteger> REQUEST_IN_FLIGHT =
-                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IN-FLIGHT");
-
+    private static final Attribute<Boolean> IGNORE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IGNORE");
+    private static final Attribute<AtomicInteger> REQUEST_IN_FLIGHT = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class
+            .getName() + "-IN-FLIGHT");
+    private static final Attribute<Boolean> SPDY = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName()
+            + "-SPDY-CONNECTION");
 
     // ------------------------------------------------------------ Constructors
 
-
-    private Utils() {}
-
+    private Utils() {
+    }
 
     // ---------------------------------------------------------- Public Methods
 
-
-    public static boolean isSecure(final String uri) {
-        return (uri.startsWith("https:") || uri.startsWith("wss:"));
-    }
-
-    public static boolean isSecure(final URI uri) {
+    public static boolean isSecure(final Uri uri) {
         final String scheme = uri.getScheme();
         return ("https".equals(scheme) || "wss".equals(scheme));
     }
@@ -79,6 +73,31 @@ public static void removeRequestInFlight(final AttributeStorage storage) {
 
     public static int getRequestInFlightCount(final AttributeStorage storage) {
         AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
-        return ((counter != null) ? counter.get() : 0);
+        return counter != null ? counter.get() : 0;
+    }
+
+    public static void setSpdyConnection(final Connection c) {
+        SPDY.set(c, Boolean.TRUE);
     }
+
+    public static boolean isSpdyConnection(final Connection c) {
+        Boolean result = SPDY.get(c);
+        return result != null ? result : false;
+    }
+    
+    static String discoverTestName(final String defaultName) {
+        final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+        final int strackTraceLen = stackTrace.length;
+        
+        if (stackTrace[strackTraceLen - 1].getClassName().contains("surefire")) {
+            for (int i = strackTraceLen - 2; i >= 0; i--) {
+                if (stackTrace[i].getClassName().contains("org.asynchttpclient.async")) {
+                    return "grizzly-kernel-" +
+                            stackTrace[i].getClassName() + "." + stackTrace[i].getMethodName();
+                }
+            }
+        }
+        
+        return defaultName;
+    }    
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
index b8f3437c5..53770d3b4 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -26,25 +26,21 @@
 
 import java.io.IOException;
 
-public final class BodyGeneratorBodyHandler implements BodyHandler {
+public final class BodyGeneratorBodyHandler extends BodyHandler {
 
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
         return (request.getBodyGenerator() != null);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
         final BodyGenerator generator = request.getBodyGenerator();
         final Body bodyLocal = generator.createBody();
         final long len = bodyLocal.getContentLength();
-        if (len > 0) {
+        if (len >= 0) {
             requestPacket.setContentLengthLong(len);
         } else {
             requestPacket.setChunked(true);
@@ -79,9 +75,7 @@ public boolean doHandle(final FilterChainContext ctx,
                 }
             }
 
-            final HttpContent content =
-                    requestPacket.httpContentBuilder().content(buffer).
-                            last(last).build();
+            final HttpContent content = requestPacket.httpContentBuilder().content(buffer).last(last).build();
             ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         }
 
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
index e476fdd26..2b6e17a32 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -19,14 +19,25 @@
 
 import java.io.IOException;
 
-public interface BodyHandler {
-
-    static int MAX_CHUNK_SIZE = 8192;
-
-    boolean handlesBodyType(final Request request);
-
-    boolean doHandle(final FilterChainContext ctx,
-                     final Request request,
-                     final HttpRequestPacket requestPacket) throws IOException;
-
+public abstract class BodyHandler {
+
+    public static int MAX_CHUNK_SIZE = 8192;
+
+    public abstract boolean handlesBodyType(final Request request);
+
+    public abstract boolean doHandle(final FilterChainContext ctx,
+            final Request request, final HttpRequestPacket requestPacket)
+            throws IOException;
+    
+    /**
+     * Tries to predict request content-length based on the {@link Request}.
+     * Not all the <tt>BodyHandler</tt>s can predict the content-length in advance.
+     * 
+     * @param request
+     * @return the content-length, or <tt>-1</tt> if the content-length can't be
+     * predicted
+     */
+    protected long getContentLength(final Request request) {
+        return request.getContentLength();
+    }
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
index 18ad3839e..8b5cf4ff6 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,25 +21,26 @@
     private final BodyHandler[] handlers;
 
     public BodyHandlerFactory(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        handlers = new BodyHandler[]{
-                new StringBodyHandler(grizzlyAsyncHttpProvider),
-                new ByteArrayBodyHandler(grizzlyAsyncHttpProvider),
-                new ParamsBodyHandler(grizzlyAsyncHttpProvider),
-                new EntityWriterBodyHandler(),
-                new StreamDataBodyHandler(),
-                new PartsBodyHandler(),
-                new FileBodyHandler(),
-                new BodyGeneratorBodyHandler()
+        handlers = new BodyHandler[] {//
+        new StringBodyHandler(grizzlyAsyncHttpProvider),//
+                new ByteArrayBodyHandler(grizzlyAsyncHttpProvider),//
+                new ParamsBodyHandler(grizzlyAsyncHttpProvider),//
+                new StreamDataBodyHandler(),//
+                new PartsBodyHandler(),//
+                new FileBodyHandler(grizzlyAsyncHttpProvider),//
+                new BodyGeneratorBodyHandler() //
         };
     }
 
     public BodyHandler getBodyHandler(final Request request) {
-        for (final BodyHandler h : handlers) {
+        for (int i = 0, len = handlers.length; i < len; i++) {
+            final BodyHandler h = handlers[i];
             if (h.handlesBodyType(request)) {
                 return h;
             }
         }
-        return new NoBodyHandler();
+        
+        return null;
     }
 
 } // END BodyHandlerFactory
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
index 9ed538e5f..bd9ddc23a 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,46 +21,48 @@
 import org.glassfish.grizzly.http.HttpRequestPacket;
 import org.glassfish.grizzly.memory.Buffers;
 import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.Charsets;
 
 import java.io.IOException;
 
-public final class ByteArrayBodyHandler implements BodyHandler {
+public final class ByteArrayBodyHandler extends BodyHandler {
 
     private final boolean compressionEnabled;
 
-    public ByteArrayBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled();
+    public ByteArrayBodyHandler(
+            final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
     }
 
-
     // -------------------------------------------- Methods from BodyHandler
 
     public boolean handlesBodyType(final Request request) {
         return (request.getByteData() != null);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request,
+            final HttpRequestPacket requestPacket) throws IOException {
 
-        String charset = request.getBodyEncoding();
-        if (charset == null) {
-            charset = Charsets.ASCII_CHARSET.name();
-        }
-        final byte[] data = new String(request.getByteData(), charset).getBytes(charset);
+        final byte[] data = request.getByteData();
         final MemoryManager mm = ctx.getMemoryManager();
         final Buffer gBuffer = Buffers.wrap(mm, data);
         if (requestPacket.getContentLength() == -1) {
-                if (!compressionEnabled) {
-                    requestPacket.setContentLengthLong(data.length);
-                }
+            if (!compressionEnabled) {
+                requestPacket.setContentLengthLong(data.length);
             }
+        }
         final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
         content.setLast(true);
         ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         return true;
     }
+
+    @Override
+    protected long getContentLength(final Request request) {
+        if (request.getContentLength() >= 0) {
+            return request.getContentLength();
+        }
+        
+        return compressionEnabled ? -1 : request.getByteData().length;
+    }
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java
deleted file mode 100644
index 7b2aad63a..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.BufferOutputStream;
-
-import java.io.IOException;
-
-public final class EntityWriterBodyHandler implements BodyHandler {
-
-    // -------------------------------------------- Methods from BodyHandler
-
-
-    public boolean handlesBodyType(final Request request) {
-        return (request.getEntityWriter() != null);
-    }
-
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
-
-        final MemoryManager mm = ctx.getMemoryManager();
-        Buffer b = mm.allocate(512);
-        BufferOutputStream o = new BufferOutputStream(mm, b, true);
-        final Request.EntityWriter writer = request.getEntityWriter();
-        writer.writeEntity(o);
-        b = o.getBuffer();
-        b.trim();
-        if (b.hasRemaining()) {
-            final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        }
-
-        return true;
-    }
-
-} // END EntityWriterBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
index dff737580..f322aa80d 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -19,7 +19,7 @@
 
 import java.io.IOException;
 
-public final class ExpectHandler implements BodyHandler {
+public final class ExpectHandler extends BodyHandler {
 
     private final BodyHandler delegate;
     private Request request;
@@ -27,25 +27,27 @@
 
     // -------------------------------------------------------- Constructors
 
-
     public ExpectHandler(final BodyHandler delegate) {
-
         this.delegate = delegate;
-
     }
 
-
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(Request request) {
         return delegate.handlesBodyType(request);
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings({ "unchecked" })
     public boolean doHandle(FilterChainContext ctx, Request request, HttpRequestPacket requestPacket) throws IOException {
         this.request = request;
         this.requestPacket = requestPacket;
+        
+        // Set content-length if possible
+        final long contentLength = delegate.getContentLength(request);
+        if (contentLength != -1) {
+            requestPacket.setContentLengthLong(contentLength);
+        }
+        
         ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         return true;
     }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
index 3085f7c14..0bdc2d062 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -16,7 +16,7 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.EmptyCompletionHandler;
 import org.glassfish.grizzly.FileTransfer;
@@ -31,38 +31,41 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
 
-public final class FileBodyHandler implements BodyHandler {
+public final class FileBodyHandler extends BodyHandler {
 
     private static final boolean SEND_FILE_SUPPORT;
     static {
         SEND_FILE_SUPPORT = configSendFileSupport();
     }
 
+    private final boolean compressionEnabled;
 
+    public FileBodyHandler(
+            final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
+    }
+    
     // ------------------------------------------------ Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
-        return (request.getFile() != null);
+        return request.getFile() != null;
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                            final Request request,
-                            final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
         final File f = request.getFile();
         requestPacket.setContentLengthLong(f.length());
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
-        if (!SEND_FILE_SUPPORT || requestPacket.isSecure()) {
+        final HttpTxContext context = HttpTxContext.get(ctx);
+        if (compressionEnabled || !SEND_FILE_SUPPORT || requestPacket.isSecure()) {
             final FileInputStream fis = new FileInputStream(request.getFile());
             final MemoryManager mm = ctx.getMemoryManager();
             AtomicInteger written = new AtomicInteger();
             boolean last = false;
             try {
-                for (byte[] buf = new byte[MAX_CHUNK_SIZE]; !last; ) {
+                for (byte[] buf = new byte[MAX_CHUNK_SIZE]; !last;) {
                     Buffer b = null;
                     int read;
                     if ((read = fis.read(buf)) < 0) {
@@ -74,9 +77,7 @@ public boolean doHandle(final FilterChainContext ctx,
                         b = Buffers.wrap(mm, buf, 0, read);
                     }
 
-                    final HttpContent content =
-                            requestPacket.httpContentBuilder().content(b).
-                                    last(last).build();
+                    final HttpContent content = requestPacket.httpContentBuilder().content(b).last(last).build();
                     ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
                 }
             } finally {
@@ -92,20 +93,12 @@ public boolean doHandle(final FilterChainContext ctx,
 
                 @Override
                 public void updated(WriteResult result) {
-                    final AsyncHandler handler = context.getHandler();
-                    if (handler != null) {
-                        if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                            // WriteResult keeps a track of the total amount written,
-                            // so we need to calculate the delta ourselves.
-                            final long resultTotal = result.getWrittenSize();
-                            final long written = resultTotal - context.getTotalBodyWritten().get();
-                            final long total = context.getTotalBodyWritten().addAndGet(written);
-                            ((TransferCompletionHandler) handler).onContentWriteProgress(
-                                    written,
-                                    total,
-                                    requestPacket.getContentLength());
-                        }
-                    }
+                    notifyHandlerIfNeeded(context, requestPacket, result);
+                }
+
+                @Override
+                public void completed(WriteResult result) {
+                    notifyHandlerIfNeeded(context, requestPacket, result);
                 }
             });
         }
@@ -113,17 +106,37 @@ public void updated(WriteResult result) {
         return true;
     }
 
-
+    @Override
+    protected long getContentLength(final Request request) {
+        if (request.getContentLength() >= 0) {
+            return request.getContentLength();
+        }
+        
+        return compressionEnabled ? -1 : request.getFile().length();
+    }
+    
     // --------------------------------------------------------- Private Methods
 
+    private static void notifyHandlerIfNeeded(final HttpTxContext context, final HttpRequestPacket requestPacket,
+            final WriteResult writeResult) {
+        final AsyncHandler handler = context.getHandler();
+        if (handler != null) {
+            if (handler instanceof TransferCompletionHandler) {
+                // WriteResult keeps a track of the total amount written,
+                // so we need to calculate the delta ourselves.
+                final long resultTotal = writeResult.getWrittenSize();
+                final long written = (resultTotal - context.getTotalBodyWritten().get());
+                final long total = context.getTotalBodyWritten().addAndGet(written);
+                ((TransferCompletionHandler) handler).onContentWriteProgress(written, total, requestPacket.getContentLength());
+            }
+        }
+    }
 
     private static boolean configSendFileSupport() {
-        return !((System.getProperty("os.name").equalsIgnoreCase("linux")
-                && !linuxSendFileSupported())
-                || System.getProperty("os.name").equalsIgnoreCase("HP-UX"));
+        return !((System.getProperty("os.name").equalsIgnoreCase("linux") && !linuxSendFileSupported()) || System.getProperty("os.name")
+                .equalsIgnoreCase("HP-UX"));
     }
 
-
     private static boolean linuxSendFileSupported() {
         final String version = System.getProperty("java.version");
         if (version.startsWith("1.6")) {
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
index 55eef5fb5..c3865952b 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,24 +21,18 @@
 
 import java.io.IOException;
 
-public final class NoBodyHandler implements BodyHandler {
-
+public final class NoBodyHandler extends BodyHandler {
 
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
         return false;
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
-        final HttpContent content = requestPacket.httpContentBuilder().content(
-                Buffers.EMPTY_BUFFER).build();
+        final HttpContent content = requestPacket.httpContentBuilder().content(Buffers.EMPTY_BUFFER).build();
         content.setLast(true);
         ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         return true;
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
index dc5a9d881..32ec96bfa 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,7 +13,9 @@
 
 package org.asynchttpclient.providers.grizzly.bodyhandler;
 
-import org.asynchttpclient.FluentStringsMap;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
 import org.glassfish.grizzly.Buffer;
@@ -27,32 +29,24 @@
 import java.io.IOException;
 import java.net.URLEncoder;
 import java.util.List;
-import java.util.Map;
-
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
-public final class ParamsBodyHandler implements BodyHandler {
+public final class ParamsBodyHandler extends BodyHandler {
 
     private final boolean compressionEnabled;
 
     public ParamsBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled();
+        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
     }
 
-
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
-        final FluentStringsMap params = request.getParams();
+        final List<Param> params = request.getFormParams();
         return isNonEmpty(params);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
         if (requestPacket.getContentType() == null) {
             requestPacket.setContentType("application/x-www-form-urlencoded");
@@ -62,24 +56,16 @@ public boolean doHandle(final FilterChainContext ctx,
         if (charset == null) {
             charset = Charsets.ASCII_CHARSET.name();
         }
-        final FluentStringsMap params = request.getParams();
+        final List<Param> params = request.getFormParams();
         if (!params.isEmpty()) {
-            for (Map.Entry<String, List<String>> entry : params.entrySet()) {
-                String name = entry.getKey();
-                List<String> values = entry.getValue();
-                if (isNonEmpty(values)) {
-                    if (sb == null) {
-                        sb = new StringBuilder(128);
-                    }
-                    for (String value : values) {
-                        if (sb.length() > 0) {
-                            sb.append('&');
-                        }
-                        sb.append(URLEncoder.encode(name, charset))
-                                .append('=').append(URLEncoder.encode(value, charset));
-                    }
-                }
+            if (sb == null) {
+                sb = new StringBuilder(128);
+            }
+            for (Param param : params) {
+                sb.append(URLEncoder.encode(param.getName(), charset)).append('=').append(URLEncoder.encode(param.getValue(), charset));
+                sb.append('&');
             }
+            sb.setLength(sb.length() - 1);
         }
         if (sb != null) {
             final byte[] data = sb.toString().getBytes(charset);
@@ -96,5 +82,4 @@ public boolean doHandle(final FilterChainContext ctx,
         }
         return true;
     }
-
 } // END ParamsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
index ba656d0d6..2c6e50616 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,54 +13,85 @@
 
 package org.asynchttpclient.providers.grizzly.bodyhandler;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.Body;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.multipart.MultipartRequestEntity;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.multipart.MultipartBody;
+import org.asynchttpclient.multipart.MultipartUtils;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
 import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
 import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.BufferOutputStream;
 
 import java.io.IOException;
+import java.util.List;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
-public final class PartsBodyHandler implements BodyHandler {
+public final class PartsBodyHandler extends BodyHandler {
 
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
         return isNonEmpty(request.getParts());
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
-        MultipartRequestEntity mre =
-                AsyncHttpProviderUtils.createMultipartRequestEntity(
-                        request.getParts(),
-                        request.getHeaders());
-        requestPacket.setContentLengthLong(mre.getContentLength());
-        requestPacket.setContentType(mre.getContentType());
-        final MemoryManager mm = ctx.getMemoryManager();
-        Buffer b = mm.allocate(512);
-        BufferOutputStream o = new BufferOutputStream(mm, b, true);
-        mre.writeRequest(o);
-        b = o.getBuffer();
-        b.trim();
-        if (b.hasRemaining()) {
-            final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        final List<Part> parts = request.getParts();
+        final MultipartBody multipartBody = MultipartUtils.newMultipartBody(parts, request.getHeaders());
+        requestPacket.setContentLengthLong(multipartBody.getContentLength());
+        requestPacket.setContentType(multipartBody.getContentType());
+        if (GrizzlyAsyncHttpProvider.LOGGER.isDebugEnabled()) {
+            GrizzlyAsyncHttpProvider.LOGGER.debug("REQUEST(modified): contentLength={}, contentType={}",
+                    new Object[] { requestPacket.getContentLength(), requestPacket.getContentType() });
         }
 
-        return true;
+        final FeedableBodyGenerator generator = new FeedableBodyGenerator() {
+            @Override
+            public Body createBody() throws IOException {
+                return multipartBody;
+            }
+        };
+        generator.setFeeder(new FeedableBodyGenerator.BaseFeeder(generator) {
+            @Override
+            public void flush() throws IOException {
+                final Body bodyLocal = feedableBodyGenerator.createBody();
+                try {
+                    final MemoryManager mm = ctx.getMemoryManager();
+                    boolean last = false;
+                    while (!last) {
+                        Buffer buffer = mm.allocate(BodyHandler.MAX_CHUNK_SIZE);
+                        buffer.allowBufferDispose(true);
+                        final long readBytes = bodyLocal.read(buffer.toByteBuffer());
+                        if (readBytes > 0) {
+                            buffer.position((int) readBytes);
+                            buffer.trim();
+                        } else {
+                            buffer.dispose();
+                            if (readBytes < 0) {
+                                last = true;
+                                buffer = Buffers.EMPTY_BUFFER;
+                            } else {
+                                throw new IllegalStateException("MultipartBody unexpectedly returned 0 bytes available");
+                            }
+                        }
+                        feed(buffer, last);
+                    }
+                } finally {
+                    if (bodyLocal != null) {
+                        try {
+                            bodyLocal.close();
+                        } catch (IOException ignore) {
+                        }
+                    }
+                }
+            }
+        });
+        generator.initializeAsynchronousTransfer(ctx, requestPacket);
+        return false;
     }
-
 } // END PartsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
index a9b5948ea..79eb60324 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,6 +13,8 @@
 
 package org.asynchttpclient.providers.grizzly.bodyhandler;
 
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.LOGGER;
+
 import org.asynchttpclient.Request;
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
@@ -23,23 +25,16 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.LOGGER;
-
-public final class StreamDataBodyHandler implements BodyHandler {
-
+public final class StreamDataBodyHandler extends BodyHandler {
 
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
         return (request.getStreamData() != null);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
         final MemoryManager mm = ctx.getMemoryManager();
         Buffer buffer = mm.allocate(512);
@@ -70,8 +65,6 @@ public boolean doHandle(final FilterChainContext ctx,
             content.setLast(true);
             ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         }
-
         return true;
     }
-
 } // END StreamDataBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
index ab7e42227..30ad9f39a 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -25,26 +25,21 @@
 
 import java.io.IOException;
 
-public final class StringBodyHandler implements BodyHandler {
+public final class StringBodyHandler extends BodyHandler {
     private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
 
     public StringBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
         this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
     }
 
-
     // -------------------------------------------- Methods from BodyHandler
 
-
     public boolean handlesBodyType(final Request request) {
         return (request.getStringData() != null);
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean doHandle(final FilterChainContext ctx,
-                         final Request request,
-                         final HttpRequestPacket requestPacket)
-    throws IOException {
+    @SuppressWarnings({ "unchecked" })
+    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
 
         String charset = request.getBodyEncoding();
         if (charset == null) {
@@ -54,7 +49,7 @@ public boolean doHandle(final FilterChainContext ctx,
         final MemoryManager mm = ctx.getMemoryManager();
         final Buffer gBuffer = Buffers.wrap(mm, data);
         if (requestPacket.getContentLength() == -1) {
-            if (!grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled()) {
+            if (!grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced()) {
                 requestPacket.setContentLengthLong(data.length);
             }
         }
@@ -63,5 +58,4 @@ public boolean doHandle(final FilterChainContext ctx,
         ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
         return true;
     }
-
 } // END StringBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
index 8b2aa0783..687984e6a 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -19,9 +19,13 @@
 import org.glassfish.grizzly.http.HttpClientFilter;
 import org.glassfish.grizzly.http.HttpContent;
 import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.http.HttpResponsePacket;
 
 import java.io.IOException;
+import org.asynchttpclient.providers.grizzly.filters.events.GracefulCloseEvent;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.http.HttpResponsePacket;
 
 /**
  * Extension of the {@link HttpClientFilter} that is responsible for handling
@@ -30,28 +34,44 @@
  * @since 2.0
  * @author The Grizzly Team
  */
-public final class AsyncHttpClientEventFilter extends HttpClientFilter
-        implements GrizzlyAsyncHttpProvider.Cleanup {
-
+public final class AsyncHttpClientEventFilter extends HttpClientFilter implements GrizzlyAsyncHttpProvider.Cleanup {
 
     private final EventHandler eventHandler;
 
     // -------------------------------------------------------- Constructors
 
-
     public AsyncHttpClientEventFilter(final EventHandler eventHandler) {
         this(eventHandler, DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
     }
 
-
-    public AsyncHttpClientEventFilter(final EventHandler eventHandler,
-                                      final int maxHeaderSize) {
+    public AsyncHttpClientEventFilter(final EventHandler eventHandler, final int maxHeaderSize) {
 
         super(maxHeaderSize);
         this.eventHandler = eventHandler;
     }
 
+    @Override
+    public NextAction handleEvent(final FilterChainContext ctx,
+            final FilterChainEvent event) throws IOException {
+        if (event.type() == GracefulCloseEvent.class) {
+            // Connection was closed.
+            // This event is fired only for responses, which don't have
+            // associated transfer-encoding or content-length.
+            // We have to complete such a request-response processing gracefully.
+            final GracefulCloseEvent closeEvent = (GracefulCloseEvent) event;
+            final HttpResponsePacket response = closeEvent.getHttpTxContext()
+                    .getResponseStatus().getResponse();
+            response.getProcessingState().getHttpContext().attach(ctx);
+            
+            onHttpPacketParsed(response, ctx);
+            
+            return ctx.getStopAction();
+        }
+        
+        return ctx.getInvokeAction();
+    }
 
+    
     @Override
     public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
         eventHandler.exceptionOccurred(ctx, error);
@@ -82,11 +102,23 @@ protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx,
         eventHandler.onHttpHeaderError(httpHeader, ctx, t);
     }
 
+    @Override
+    protected void onHttpContentError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
+        eventHandler.onHttpContentError(httpHeader, ctx, t);
+    }
+
     @Override
     protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
         eventHandler.onHttpHeadersParsed(httpHeader, ctx);
     }
 
+    @Override
+    protected boolean onHttpHeaderParsed(final HttpHeader httpHeader,
+            final Buffer buffer, final FilterChainContext ctx) {
+        super.onHttpHeaderParsed(httpHeader, buffer, ctx);
+        return eventHandler.onHttpHeaderParsed(httpHeader, buffer, ctx);
+    }
+    
     @Override
     protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
         return eventHandler.onHttpPacketParsed(httpHeader, ctx);
@@ -96,5 +128,4 @@ protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext c
     public void cleanup(final FilterChainContext ctx) {
         clearResponse(ctx.getConnection());
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
index d48869b7a..5159ed6c8 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,27 +13,40 @@
 
 package org.asynchttpclient.providers.grizzly.filters;
 
+import static org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter.getHandshakeError;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Cookie;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.FluentStringsMap;
 import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.UpgradeHandler;
+import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.listener.TransferCompletionHandler;
 import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
 import org.asynchttpclient.providers.grizzly.GrizzlyResponseFuture;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
+import org.asynchttpclient.providers.grizzly.RequestInfoHolder;
 import org.asynchttpclient.providers.grizzly.Utils;
+import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
+import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandlerFactory;
 import org.asynchttpclient.providers.grizzly.bodyhandler.ExpectHandler;
 import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
 import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
 import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.Grizzly;
 import org.glassfish.grizzly.attributes.Attribute;
 import org.glassfish.grizzly.filterchain.BaseFilter;
@@ -41,7 +54,10 @@
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.filterchain.FilterChainEvent;
 import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpContext;
 import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.http.HttpResponsePacket;
 import org.glassfish.grizzly.http.Method;
 import org.glassfish.grizzly.http.ProcessingState;
 import org.glassfish.grizzly.http.Protocol;
@@ -49,65 +65,73 @@
 import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.http.util.MimeHeaders;
 import org.glassfish.grizzly.impl.SafeFutureImpl;
+import org.glassfish.grizzly.spdy.SpdySession;
+import org.glassfish.grizzly.spdy.SpdyStream;
 import org.glassfish.grizzly.ssl.SSLConnectionContext;
 import org.glassfish.grizzly.ssl.SSLUtils;
 import org.glassfish.grizzly.websockets.Version;
+import org.slf4j.Logger;
 
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.net.URLEncoder;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentLinkedQueue;
-
-import static org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter.getHandshakeError;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import java.util.concurrent.locks.Lock;
 
 /**
- * This {@link org.glassfish.grizzly.filterchain.Filter} is typically the last
- * in the {@FilterChain}.  Its primary responsibility is converting the
- * async-http-client {@link Request} into a Grizzly {@link HttpRequestPacket}.
- *
+ * This {@link org.glassfish.grizzly.filterchain.Filter} is typically the last in the {@FilterChain}. Its primary responsibility is converting the async-http-client
+ * {@link Request} into a Grizzly {@link HttpRequestPacket}.
+ * 
  * @since 1.7
  * @author The Grizzly Team
  */
 public final class AsyncHttpClientFilter extends BaseFilter {
 
-    private ConcurrentLinkedQueue<HttpRequestPacketImpl> requestCache
-                    = new ConcurrentLinkedQueue<HttpRequestPacketImpl>();
+    private ConcurrentLinkedQueue<HttpRequestPacketImpl> requestCache = new ConcurrentLinkedQueue<HttpRequestPacketImpl>();
+    private final Logger logger;
 
     private final AsyncHttpClientConfig config;
     private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
+    private final BodyHandlerFactory bodyHandlerFactory;
 
-    private static final Attribute<Boolean> PROXY_AUTH_FAILURE =
-           Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(AsyncHttpClientFilter.class.getName() + "-PROXY-AUTH_FAILURE");
+    private static final Attribute<Boolean> PROXY_AUTH_FAILURE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
+            .createAttribute(AsyncHttpClientFilter.class.getName() + "-PROXY-AUTH_FAILURE");
 
     // -------------------------------------------------------- Constructors
 
-
     public AsyncHttpClientFilter(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider, final AsyncHttpClientConfig config) {
         this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
-
         this.config = config;
-
+        bodyHandlerFactory = new BodyHandlerFactory(grizzlyAsyncHttpProvider);
+        logger = GrizzlyAsyncHttpProvider.LOGGER;
     }
 
-
     // --------------------------------------------- Methods from BaseFilter
 
+    @Override
+    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
+        final HttpContent httpContent = ctx.getMessage();
+        if (httpContent.isLast()) {
+            // Perform the cleanup logic if it's the last chunk of the payload
+            final HttpResponsePacket response = (HttpResponsePacket) httpContent.getHttpHeader();
+
+            recycleRequestResponsePackets(ctx.getConnection(), response);
+            return ctx.getStopAction();
+        }
+
+        return ctx.getInvokeAction();
+    }
 
     @Override
-    public NextAction handleWrite(final FilterChainContext ctx)
-    throws IOException {
+    public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
 
         Object message = ctx.getMessage();
-        if (message instanceof Request) {
+        if (message instanceof RequestInfoHolder) {
             ctx.setMessage(null);
-            if (!sendAsGrizzlyRequest((Request) message, ctx)) {
+            if (!sendAsGrizzlyRequest((RequestInfoHolder) message, ctx)) {
                 return ctx.getSuspendAction();
             }
         } else if (message instanceof Buffer) {
@@ -119,14 +143,11 @@ public NextAction handleWrite(final FilterChainContext ctx)
 
     @SuppressWarnings("unchecked")
     @Override
-    public NextAction handleEvent(final FilterChainContext ctx,
-                                  final FilterChainEvent event)
-    throws IOException {
+    public NextAction handleEvent(final FilterChainContext ctx, final FilterChainEvent event) throws IOException {
 
         final Object type = event.type();
         if (type == ContinueEvent.class) {
-            final ContinueEvent
-                    continueEvent = (ContinueEvent) event;
+            final ContinueEvent continueEvent = (ContinueEvent) event;
             ((ExpectHandler) continueEvent.getContext().getBodyHandler()).finish(ctx);
         } else if (type == TunnelRequestEvent.class) {
             // Disable SSL for the time being...
@@ -134,7 +155,7 @@ public NextAction handleEvent(final FilterChainContext ctx,
             ctx.suspend();
             TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
             final ProxyServer proxyServer = tunnelRequestEvent.getProxyServer();
-            final URI requestUri = tunnelRequestEvent.getUri();
+            final Uri requestUri = tunnelRequestEvent.getUri();
 
             RequestBuilder builder = new RequestBuilder();
             builder.setMethod(Method.CONNECT.getMethodString());
@@ -142,82 +163,96 @@ public NextAction handleEvent(final FilterChainContext ctx,
             Request request = builder.build();
 
             AsyncHandler handler = new AsyncCompletionHandler() {
-                            @Override
-                            public Object onCompleted(Response response) throws Exception {
-                                if (response.getStatusCode() != 200) {
-                                    PROXY_AUTH_FAILURE.set(ctx.getConnection(), Boolean.TRUE);
-                                }
-                                ctx.notifyDownstream(new SSLSwitchingEvent(true, ctx.getConnection()));
-                                ctx.notifyDownstream(event);
-                                return response;
-                            }
-                        };
-            final GrizzlyResponseFuture future =
-                    new GrizzlyResponseFuture(grizzlyAsyncHttpProvider,
-                                              request,
-                                              handler,
-                                              proxyServer);
+                @Override
+                public Object onCompleted(Response response) throws Exception {
+                    if (response.getStatusCode() != 200) {
+                        PROXY_AUTH_FAILURE.set(ctx.getConnection(), Boolean.TRUE);
+                    }
+                    ctx.notifyDownstream(new SSLSwitchingEvent(true, ctx.getConnection()));
+                    ctx.notifyDownstream(event);
+                    return response;
+                }
+            };
+            final GrizzlyResponseFuture future = new GrizzlyResponseFuture(grizzlyAsyncHttpProvider, request, handler, proxyServer);
             future.setDelegate(SafeFutureImpl.create());
 
-            grizzlyAsyncHttpProvider.execute(ctx.getConnection(),
-                                             request,
-                                             handler,
-                                             future);
+            grizzlyAsyncHttpProvider.execute(ctx.getConnection(), request, handler, future, HttpTxContext.get(ctx));
             return ctx.getSuspendAction();
         }
 
         return ctx.getStopAction();
-
     }
 
-
     // ----------------------------------------------------- Private Methods
 
+    private static void recycleRequestResponsePackets(final Connection c, final HttpResponsePacket response) {
+        if (!Utils.isSpdyConnection(c)) {
+            HttpRequestPacket request = response.getRequest();
+            request.setExpectContent(false);
+            response.recycle();
+            request.recycle();
+        }
+    }
 
-    private boolean sendAsGrizzlyRequest(final Request request,
-                                         final FilterChainContext ctx)
-    throws IOException {
+    private boolean sendAsGrizzlyRequest(
+            final RequestInfoHolder requestInfoHolder,
+            final FilterChainContext ctx) throws IOException {
 
-        final HttpTransactionContext httpCtx = HttpTransactionContext.get(ctx.getConnection());
+        HttpTxContext httpTxContext = requestInfoHolder.getHttpTxContext();
+        if (httpTxContext == null) {
+            httpTxContext = HttpTxContext.create(requestInfoHolder);
+        }
 
-        if (checkProxyAuthFailure(ctx, httpCtx)) {
+        if (checkProxyAuthFailure(ctx, httpTxContext)) {
             return true;
         }
 
-        final URI uri = httpCtx.getRequest().getURI();
+        final Request request = httpTxContext.getRequest();
+        final Uri uri = request.getUri();
         boolean secure = Utils.isSecure(uri);
+        boolean isWebSocket = isWSRequest(httpTxContext.getRequestUri());
 
         // If the request is secure, check to see if an error occurred during
-        // the handshake.  We have to do this here, as the error would occur
-        // out of the scope of a HttpTransactionContext so there would be
+        // the handshake. We have to do this here, as the error would occur
+        // out of the scope of a HttpTxContext so there would be
         // no good way to communicate the problem to the caller.
-        if (secure && checkHandshakeError(ctx, httpCtx)) {
+        if (secure && checkHandshakeError(ctx, httpTxContext)) {
             return true;
         }
 
-        if (isUpgradeRequest(httpCtx.getHandler()) && isWSRequest(httpCtx.getRequestUrl())) {
-            httpCtx.setWSRequest(true);
-            convertToUpgradeRequest(httpCtx);
+        
+        if (isUpgradeRequest(httpTxContext.getHandler()) && isWebSocket) {
+            httpTxContext.setWSRequest(true);
+            convertToUpgradeRequest(httpTxContext);
         }
 
         HttpRequestPacket requestPacket = requestCache.poll();
         if (requestPacket == null) {
             requestPacket = new HttpRequestPacketImpl();
         }
-        requestPacket.setMethod(request.getMethod());
+        
+        final Method method = Method.valueOf(request.getMethod());
+        
+        requestPacket.setMethod(method);
         requestPacket.setProtocol(Protocol.HTTP_1_1);
 
         // Special handling for CONNECT.
-        if (Method.CONNECT.matchesMethod(request.getMethod())) {
+        if (method == Method.CONNECT) {
             final int port = uri.getPort();
             requestPacket.setRequestURI(uri.getHost() + ':' + (port == -1 ? 443 : port));
+        } else if ((secure || isWebSocket) && config.isUseRelativeURIsWithConnectProxies()) {
+            requestPacket.setRequestURI(getNonEmptyPath(uri));
         } else {
-            requestPacket.setRequestURI(uri.getPath());
+            requestPacket.setRequestURI(uri.toUrl());
         }
 
-        if (GrizzlyAsyncHttpProvider.requestHasEntityBody(request)) {
+        final BodyHandler bodyHandler = isPayloadAllowed(method) ?
+                bodyHandlerFactory.getBodyHandler(request) :
+                null;
+        
+        if (bodyHandler != null) {
             final long contentLength = request.getContentLength();
-            if (contentLength > 0) {
+            if (contentLength >= 0) {
                 requestPacket.setContentLengthLong(contentLength);
                 requestPacket.setChunked(false);
             } else {
@@ -225,16 +260,14 @@ private boolean sendAsGrizzlyRequest(final Request request,
             }
         }
 
-        if (httpCtx.isWSRequest() && !httpCtx.isEstablishingTunnel()) {
+        if (httpTxContext.isWSRequest()) {
             try {
-                final URI wsURI = new URI(httpCtx.getWsRequestURI());
-                httpCtx.setProtocolHandler(Version.DRAFT17.createHandler(true));
-                httpCtx.setHandshake(
-                        httpCtx.getProtocolHandler().createHandShake(wsURI));
-                requestPacket = (HttpRequestPacket)
-                        httpCtx.getHandshake().composeHeaders().getHttpHeader();
+                final URI wsURI = httpTxContext.getWsRequestURI().toJavaNetURI();
+                httpTxContext.setProtocolHandler(Version.RFC6455.createHandler(true));
+                httpTxContext.setHandshake(httpTxContext.getProtocolHandler().createHandShake(wsURI));
+                requestPacket = (HttpRequestPacket) httpTxContext.getHandshake().composeHeaders().getHttpHeader();
             } catch (URISyntaxException e) {
-                throw new IllegalArgumentException("Invalid WS URI: " + httpCtx.getWsRequestURI());
+                throw new IllegalArgumentException("Invalid WS URI: " + httpTxContext.getWsRequestURI());
             }
         }
 
@@ -243,71 +276,130 @@ private boolean sendAsGrizzlyRequest(final Request request,
         addHostHeader(request, uri, requestPacket);
         addGeneralHeaders(request, requestPacket);
         addCookies(request, requestPacket);
+        addAuthorizationHeader(request, requestPacket);
 
-        initTransferCompletionHandler(request, httpCtx.getHandler());
+        initTransferCompletionHandler(request, httpTxContext.getHandler());
 
         final HttpRequestPacket requestPacketLocal = requestPacket;
         FilterChainContext sendingCtx = ctx;
 
         if (secure) {
             // Check to see if the ProtocolNegotiator has given
-            // us a different FilterChain to use.  If so, we need
+            // us a different FilterChain to use. If so, we need
             // use a different FilterChainContext when invoking sendRequest().
             sendingCtx = checkAndHandleFilterChainUpdate(ctx, sendingCtx);
         }
+        final Connection c = ctx.getConnection();
+        final HttpContext httpCtx;
+        if (!Utils.isSpdyConnection(c)) {
+            httpCtx = HttpContext.newInstance(c, c, c, requestPacketLocal);
+        } else {
+            SpdySession session = SpdySession.get(c);
+            final Lock lock = session.getNewClientStreamLock();
+            try {
+                lock.lock();
+                SpdyStream stream = session.openStream(requestPacketLocal, session.getNextLocalStreamId(), 0, 0, 0, false,
+                        !requestPacketLocal.isExpectContent());
+                httpCtx = HttpContext.newInstance(stream, stream, stream, requestPacketLocal);
+            } finally {
+                lock.unlock();
+            }
+        }
+        httpCtx.attach(ctx);
+        HttpTxContext.set(ctx, httpTxContext);
+        requestPacketLocal.getProcessingState().setHttpContext(httpCtx);
+        requestPacketLocal.setConnection(c);
+        
+        return sendRequest(sendingCtx, request, requestPacketLocal,
+                wrapWithExpectHandlerIfNeeded(bodyHandler, requestPacket));
+    }
 
-        return grizzlyAsyncHttpProvider.sendRequest(sendingCtx,
-                                                    request,
-                                                    requestPacketLocal);
+    @SuppressWarnings("unchecked")
+    public boolean sendRequest(final FilterChainContext ctx,
+            final Request request, final HttpRequestPacket requestPacket,
+            final BodyHandler bodyHandler)
+            throws IOException {
+
+        boolean isWriteComplete = true;
+
+        if (bodyHandler != null) {
+            final HttpTxContext context = HttpTxContext.get(ctx);
+            context.setBodyHandler(bodyHandler);
+            if (logger.isDebugEnabled()) {
+                logger.debug("REQUEST: {}", requestPacket);
+            }
+            isWriteComplete = bodyHandler.doHandle(ctx, request, requestPacket);
+        } else {
+            HttpContent content = HttpContent.builder(requestPacket).last(true).build();
+            if (logger.isDebugEnabled()) {
+                logger.debug("REQUEST: {}", requestPacket);
+            }
+            ctx.write(content, ctx.getTransportContext().getCompletionHandler());
+        }
 
+        return isWriteComplete;
     }
 
-    private static FilterChainContext checkAndHandleFilterChainUpdate(final FilterChainContext ctx,
-                                                                      final FilterChainContext sendingCtx) {
+    private static FilterChainContext checkAndHandleFilterChainUpdate(final FilterChainContext ctx, final FilterChainContext sendingCtx) {
         FilterChainContext ctxLocal = sendingCtx;
-        SSLConnectionContext sslCtx =
-                SSLUtils.getSslConnectionContext(ctx.getConnection());
+        SSLConnectionContext sslCtx = SSLUtils.getSslConnectionContext(ctx.getConnection());
         if (sslCtx != null) {
             FilterChain fc = sslCtx.getNewConnectionFilterChain();
 
             if (fc != null) {
                 // Create a new FilterChain context using the new
                 // FilterChain.
-                // TODO:  We need to mark this connection somehow
-                //        as being only suitable for this type of
-                //        request.
+                // TODO: We need to mark this connection somehow
+                // as being only suitable for this type of
+                // request.
                 ctxLocal = obtainProtocolChainContext(ctx, fc);
             }
         }
         return ctxLocal;
     }
 
-    private static void initTransferCompletionHandler(final Request request,
-                                                      final AsyncHandler h)
-    throws IOException {
-        if (h != null) {
-            if (TransferCompletionHandler.class.isAssignableFrom(h.getClass())) {
-                final FluentCaseInsensitiveStringsMap map =
-                        new FluentCaseInsensitiveStringsMap(
-                                request.getHeaders());
-                TransferCompletionHandler.class.cast(h)
-                        .transferAdapter(new GrizzlyTransferAdapter(map));
-            }
+    /**
+     * check if we need to wrap the BodyHandler with ExpectHandler
+     */
+    private static BodyHandler wrapWithExpectHandlerIfNeeded(
+            final BodyHandler bodyHandler,
+            final HttpRequestPacket requestPacket) {
+
+        if (bodyHandler == null) {
+            return null;
+        }
+
+        // check if we need to wrap the BodyHandler with ExpectHandler
+        final MimeHeaders headers = requestPacket.getHeaders();
+        final int expectHeaderIdx = headers.indexOf(Header.Expect, 0);
+
+        return expectHeaderIdx != -1
+                && headers.getValue(expectHeaderIdx).equalsIgnoreCase("100-Continue")
+                ? new ExpectHandler(bodyHandler)
+                : bodyHandler;
+    }
+        
+    private static boolean isPayloadAllowed(final Method method) {
+        return method.getPayloadExpectation() != Method.PayloadExpectation.NOT_ALLOWED;
+    }
+    
+    private static void initTransferCompletionHandler(final Request request, final AsyncHandler h) throws IOException {
+        if (h instanceof TransferCompletionHandler) {
+            final FluentCaseInsensitiveStringsMap map = new FluentCaseInsensitiveStringsMap(request.getHeaders());
+            TransferCompletionHandler.class.cast(h).headers(map);
         }
     }
 
-    private static boolean checkHandshakeError(final FilterChainContext ctx,
-                                               final HttpTransactionContext httpCtx) {
-            Throwable t = getHandshakeError(ctx.getConnection());
-            if (t != null) {
-                httpCtx.abort(t);
-                return true;
-            }
+    private static boolean checkHandshakeError(final FilterChainContext ctx, final HttpTxContext httpCtx) {
+        Throwable t = getHandshakeError(ctx.getConnection());
+        if (t != null) {
+            httpCtx.abort(t);
+            return true;
+        }
         return false;
     }
 
-    private static boolean checkProxyAuthFailure(final FilterChainContext ctx,
-                                                 final HttpTransactionContext httpCtx) {
+    private static boolean checkProxyAuthFailure(final FilterChainContext ctx, final HttpTxContext httpCtx) {
         final Boolean failed = PROXY_AUTH_FAILURE.get(ctx.getConnection());
         if (failed != null && failed) {
             httpCtx.abort(new IllegalStateException("Unable to authenticate with proxy"));
@@ -316,37 +408,61 @@ private static boolean checkProxyAuthFailure(final FilterChainContext ctx,
         return false;
     }
 
-    private static FilterChainContext obtainProtocolChainContext(
-            final FilterChainContext ctx,
-            final FilterChain completeProtocolFilterChain) {
+    private static FilterChainContext obtainProtocolChainContext(final FilterChainContext ctx, final FilterChain completeProtocolFilterChain) {
 
-        final FilterChainContext newFilterChainContext =
-                completeProtocolFilterChain.obtainFilterChainContext(
-                        ctx.getConnection(),
-                        ctx.getStartIdx() + 1,
-                        completeProtocolFilterChain.size(),
-                        ctx.getFilterIdx() + 1);
+        final FilterChainContext newFilterChainContext = completeProtocolFilterChain.obtainFilterChainContext(ctx.getConnection(),
+                ctx.getStartIdx() + 1, completeProtocolFilterChain.size(), ctx.getFilterIdx() + 1);
 
         newFilterChainContext.setAddressHolder(ctx.getAddressHolder());
         newFilterChainContext.setMessage(ctx.getMessage());
-        newFilterChainContext.getInternalContext().setIoEvent(
-                ctx.getInternalContext().getIoEvent());
+        newFilterChainContext.getInternalContext().setIoEvent(ctx.getInternalContext().getIoEvent());
         ctx.getConnection().setProcessor(completeProtocolFilterChain);
         return newFilterChainContext;
     }
 
     private static void addHostHeader(final Request request,
-                                      final URI uri,
-                                      final HttpRequestPacket requestPacket) {
-        String host = request.getVirtualHost();
-        if (host != null) {
-            requestPacket.addHeader(Header.Host, host);
-        } else {
-            if (uri.getPort() == -1) {
-                requestPacket.addHeader(Header.Host, uri.getHost());
+            final Uri uri, final HttpRequestPacket requestPacket) {
+        if (!request.getHeaders().containsKey(Header.Host.toString())) {
+            String host = request.getVirtualHost();
+            if (host != null) {
+                requestPacket.addHeader(Header.Host, host);
             } else {
-                requestPacket.addHeader(Header.Host, uri.getHost() + ':' + uri.getPort());
+                if (uri.getPort() == -1) {
+                    requestPacket.addHeader(Header.Host, uri.getHost());
+                } else {
+                    requestPacket.addHeader(Header.Host, uri.getHost() + ':' + uri.getPort());
+                }
+            }
+        }
+    }
+
+    private void addAuthorizationHeader(final Request request, final HttpRequestPacket requestPacket) {
+        Realm realm = request.getRealm();
+        if (realm == null) {
+            realm = config.getRealm();
+        }
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+            final String authHeaderValue = generateAuthHeader(realm);
+            if (authHeaderValue != null) {
+                requestPacket.addHeader(Header.Authorization, authHeaderValue);
+            }
+        }
+    }
+
+    private String generateAuthHeader(final Realm realm) {
+        try {
+            switch (realm.getAuthScheme()) {
+            case BASIC:
+                return computeBasicAuthentication(realm);
+            case DIGEST:
+                return computeDigestAuthentication(realm);
+            case NTLM:
+                return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
+            default:
+                return null;
             }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
         }
     }
 
@@ -354,34 +470,31 @@ private static boolean isUpgradeRequest(final AsyncHandler handler) {
         return (handler instanceof UpgradeHandler);
     }
 
-    private static boolean isWSRequest(final String requestUri) {
-        return (requestUri.charAt(0) == 'w' && requestUri.charAt(1) == 's');
+    private static boolean isWSRequest(final Uri requestUri) {
+        return requestUri.getScheme().startsWith("ws");
     }
 
-    private static void convertToUpgradeRequest(final HttpTransactionContext ctx) {
-        final int colonIdx = ctx.getRequestUrl().indexOf(':');
+    private static void convertToUpgradeRequest(final HttpTxContext ctx) {
+        
+        final Uri requestUri = ctx.getRequestUri();
 
-        if (colonIdx < 2 || colonIdx > 3) {
-            throw new IllegalArgumentException("Invalid websocket URL: " + ctx.getRequestUrl());
-        }
-
-        final StringBuilder sb = new StringBuilder(ctx.getRequestUrl());
-        sb.replace(0, colonIdx, ((colonIdx == 2) ? "http" : "https"));
-        ctx.setWsRequestURI(ctx.getRequestUrl());
-        ctx.setRequestUrl(sb.toString());
+        ctx.setWsRequestURI(requestUri);
+        ctx.setRequestUri(requestUri.withNewScheme(
+                "ws".equals(requestUri.getScheme())
+                        ? "http"
+                        : "https"));
     }
 
-    private void addGeneralHeaders(final Request request,
-                                   final HttpRequestPacket requestPacket) {
+    private void addGeneralHeaders(final Request request, final HttpRequestPacket requestPacket) {
 
-        final FluentCaseInsensitiveStringsMap map = request.getHeaders();
-        if (isNonEmpty(map)) {
+        if (isNonEmpty(request.getHeaders())) {
+            final FluentCaseInsensitiveStringsMap map = request.getHeaders();
             for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
                 final String headerName = entry.getKey();
                 final List<String> headerValues = entry.getValue();
                 if (isNonEmpty(headerValues)) {
-                    for (final String headerValue : headerValues) {
-                        requestPacket.addHeader(headerName, headerValue);
+                    for (int i = 0, len = headerValues.size(); i < len; i++) {
+                        requestPacket.addHeader(headerName, headerValues.get(i));
                     }
                 }
             }
@@ -389,8 +502,8 @@ private void addGeneralHeaders(final Request request,
 
         final MimeHeaders headers = requestPacket.getHeaders();
         if (!headers.contains(Header.Connection)) {
-            //final boolean canCache = context.provider.clientConfig.getAllowPoolingConnection();
-            requestPacket.addHeader(Header.Connection, /*(canCache ? */"keep-alive" /*: "close")*/);
+            // final boolean canCache = context.provider.clientConfig.getAllowPoolingConnection();
+            requestPacket.addHeader(Header.Connection, /* (canCache ? */"keep-alive" /* : "close") */);
         }
 
         if (!headers.contains(Header.Accept)) {
@@ -400,98 +513,38 @@ private void addGeneralHeaders(final Request request,
         if (!headers.contains(Header.UserAgent)) {
             requestPacket.addHeader(Header.UserAgent, config.getUserAgent());
         }
-
     }
 
-
-    private void addCookies(final Request request,
-                                   final HttpRequestPacket requestPacket) {
+    private void addCookies(final Request request, final HttpRequestPacket requestPacket) {
 
         final Collection<Cookie> cookies = request.getCookies();
         if (isNonEmpty(cookies)) {
             StringBuilder sb = new StringBuilder(128);
-            org.glassfish.grizzly.http.Cookie[] gCookies =
-                    new org.glassfish.grizzly.http.Cookie[cookies.size()];
+            org.glassfish.grizzly.http.Cookie[] gCookies = new org.glassfish.grizzly.http.Cookie[cookies.size()];
             convertCookies(cookies, gCookies);
-            CookieSerializerUtils.serializeClientCookies(sb, false, config.isRfc6265CookieEncoding(), gCookies);
+            CookieSerializerUtils.serializeClientCookies(sb, false, true, gCookies);
             requestPacket.addHeader(Header.Cookie, sb.toString());
         }
-
     }
 
-
     private static void convertCookies(final Collection<Cookie> cookies,
-                                       final org.glassfish.grizzly.http.Cookie[] gCookies) {
+            final org.glassfish.grizzly.http.Cookie[] gCookies) {
         int idx = 0;
-        for (final Cookie cookie : cookies) {
-            final org.glassfish.grizzly.http.Cookie gCookie =
-                    new org.glassfish.grizzly.http.Cookie(cookie.getName(), cookie.getValue());
-            gCookie.setDomain(cookie.getDomain());
-            gCookie.setPath(cookie.getPath());
-            gCookie.setVersion(cookie.getVersion());
-            gCookie.setMaxAge(cookie.getMaxAge());
-            gCookie.setSecure(cookie.isSecure());
-            gCookies[idx] = gCookie;
-            idx++;
-        }
-
-    }
-
-
-    private static void addQueryString(final Request request,
-                                       final HttpRequestPacket requestPacket) {
-
-        final FluentStringsMap map = request.getQueryParams();
-        if (isNonEmpty(map)) {
-            StringBuilder sb = new StringBuilder(128);
-            for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
-                final String name = entry.getKey();
-                final List<String> values = entry.getValue();
-                if (isNonEmpty(values)) {
-                    try {
-                        for (int i = 0, len = values.size(); i < len; i++) {
-                            final String value = values.get(i);
-                            if (isNonEmpty(value)) {
-                                sb.append(URLEncoder.encode(name, "UTF-8")).append('=')
-                                    .append(URLEncoder.encode(values.get(i),
-                                                              "UTF-8")).append('&');
-                            } else {
-                                sb.append(URLEncoder.encode(name, "UTF-8")).append('&');
-                            }
-                        }
-                    } catch (UnsupportedEncodingException ignored) {
-                    }
-                }
+        if (!cookies.isEmpty()) {
+            for (final Cookie cookie : cookies) {
+                gCookies[idx++] = new org.glassfish.grizzly.http.Cookie(
+                        cookie.getName(), cookie.getValue());
             }
-            sb.setLength(sb.length() - 1);
-            String queryString = sb.toString();
-
-            requestPacket.setQueryString(queryString);
         }
-
     }
 
-    public static final class GrizzlyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
-
-
-        // -------------------------------------------------------- Constructors
-
+    private static void addQueryString(final Request request, final HttpRequestPacket requestPacket) {
 
-        public GrizzlyTransferAdapter(FluentCaseInsensitiveStringsMap headers) throws IOException {
-            super(headers);
+        String query = request.getUri().getQuery();
+        if (isNonEmpty(query)) {
+            requestPacket.setQueryString(query);
         }
-
-
-        // ---------------------------------------- Methods from TransferAdapter
-
-
-        @Override
-        public void getBytes(byte[] bytes) {
-            // TODO implement
-        }
-
-    } // END GrizzlyTransferAdapter
-
+    }
 
     class HttpRequestPacketImpl extends HttpRequestPacket {
 
@@ -499,7 +552,6 @@ public void getBytes(byte[] bytes) {
 
         // -------------------------------------- Methods from HttpRequestPacketImpl
 
-
         @Override
         public ProcessingState getProcessingState() {
             return processingState;
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java
deleted file mode 100644
index 8de7d9155..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.filterchain.TransportFilter;
-
-import java.io.EOFException;
-import java.io.IOException;
-
-/**
- * Custom {@link TransportFilter} implementation to capture and handle low-level
- * exceptions.
- *
- * @since 1.7
- * @author The Grizzly Team
- */
-public final class AsyncHttpClientTransportFilter extends TransportFilter {
-
-
-    // ----------------------------------------------------- Methods from Filter
-
-
-    @Override
-    public NextAction handleRead(FilterChainContext ctx) throws IOException {
-        final HttpTransactionContext context =
-                HttpTransactionContext.get(ctx.getConnection());
-        if (context == null) {
-            return super.handleRead(ctx);
-        }
-        ctx.getTransportContext().setCompletionHandler(new CompletionHandler() {
-            @Override
-            public void cancelled() {
-
-            }
-
-            @Override
-            public void failed(Throwable throwable) {
-                if (throwable instanceof EOFException) {
-                    context.abort(new IOException("Remotely Closed"));
-                }
-            }
-
-            @Override
-            public void completed(Object result) {
-            }
-
-            @Override
-            public void updated(Object result) {
-            }
-        });
-        return super.handleRead(ctx);
-    }
-
-    @Override
-    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
-        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
-        if (context != null) {
-            context.abort(error.getCause());
-        }
-    }
-
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
index e4741c4bb..758c6e778 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -31,18 +31,13 @@
  * @since 2.0
  * @author The Grizzly Team
  */
-public final class AsyncSpdyClientEventFilter extends SpdyHandlerFilter
-        implements GrizzlyAsyncHttpProvider.Cleanup {
-
+public final class AsyncSpdyClientEventFilter extends SpdyHandlerFilter implements GrizzlyAsyncHttpProvider.Cleanup {
 
     private final EventHandler eventHandler;
 
     // -------------------------------------------------------- Constructors
 
-
-    public AsyncSpdyClientEventFilter(final EventHandler eventHandler,
-                                      SpdyMode mode,
-                                      ExecutorService threadPool) {
+    public AsyncSpdyClientEventFilter(final EventHandler eventHandler, SpdyMode mode, ExecutorService threadPool) {
         super(mode, threadPool);
         this.eventHandler = eventHandler;
     }
@@ -77,6 +72,12 @@ protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx,
         eventHandler.onHttpHeaderError(httpHeader, ctx, t);
     }
 
+    @Override
+    protected void onHttpContentError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
+        eventHandler.onHttpContentError(httpHeader, ctx, t);
+    }
+
+
     @Override
     protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
         eventHandler.onHttpHeadersParsed(httpHeader, ctx);
@@ -91,5 +92,4 @@ protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext c
     public void cleanup(FilterChainContext ctx) {
 
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
index 095d6c64b..b3d7fa643 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
@@ -27,25 +27,17 @@
  */
 public final class ClientEncodingFilter implements EncodingFilter {
 
-
     // --------------------------------------------- Methods from EncodingFilter
 
-
     public boolean applyEncoding(HttpHeader httpPacket) {
-
-       httpPacket.addHeader(Header.AcceptEncoding, "gzip");
-       return true;
-
+        httpPacket.addHeader(Header.AcceptEncoding, "gzip");
+        return false;
     }
 
-
     public boolean applyDecoding(HttpHeader httpPacket) {
 
         final HttpResponsePacket httpResponse = (HttpResponsePacket) httpPacket;
         final DataChunk bc = httpResponse.getHeaders().getValue(Header.ContentEncoding);
         return bc != null && bc.indexOf("gzip", 0) != -1;
-
     }
-
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
index 9f479db7f..ac54fb8b4 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,11 +13,15 @@
 
 package org.asynchttpclient.providers.grizzly.filters;
 
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.glassfish.grizzly.filterchain.BaseFilter;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.filterchain.NextAction;
@@ -25,10 +29,7 @@
 import org.glassfish.grizzly.http.util.Header;
 
 import java.io.IOException;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
+import org.glassfish.grizzly.http.HttpPacket;
 
 /**
  * This Filter will be placed in the FilterChain when a request is being
@@ -44,46 +45,39 @@
     private final AsyncHttpClientConfig config;
     private final Boolean secure;
 
-
     // ------------------------------------------------------------ Constructors
 
-
-    public ProxyFilter(final ProxyServer proxyServer,
-                       final AsyncHttpClientConfig config,
-                       boolean secure) {
+    public ProxyFilter(final ProxyServer proxyServer, final AsyncHttpClientConfig config, boolean secure) {
         this.proxyServer = proxyServer;
         this.config = config;
         this.secure = secure;
     }
 
-
     // ----------------------------------------------------- Methods from Filter
 
-
     @Override
-    public NextAction handleWrite(FilterChainContext ctx)
-    throws IOException {
-        org.glassfish.grizzly.http.HttpContent content = ctx.getMessage();
-        HttpRequestPacket request = (HttpRequestPacket) content.getHttpHeader();
-        HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
-        assert(context != null);
-        Request req = context.getRequest();
-        if (!secure) {
-            request.setRequestURI(req.getURI().toString());
+    public NextAction handleWrite(FilterChainContext ctx) throws IOException {
+        final Object msg = ctx.getMessage();
+        if (HttpPacket.isHttp(msg)) {
+            HttpPacket httpPacket = (HttpPacket) msg;
+            final HttpRequestPacket request = (HttpRequestPacket) httpPacket.getHttpHeader();
+            if (!request.isCommitted()) {
+                HttpTxContext context = HttpTxContext.get(ctx);
+                assert (context != null);
+                Request req = context.getRequest();
+                if (!secure) {
+                    request.setRequestURI(req.getUrl());
+                }
+                addProxyHeaders(getRealm(req), request);
+            }
         }
-        addProxyHeaders(getRealm(req), request);
+        
         return ctx.getInvokeAction();
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
-    private void addProxyHeaders(final Realm realm,
-                                 final HttpRequestPacket request) {
-        if (!request.getHeaders().contains(Header.ProxyConnection)) {
-            request.setHeader(Header.ProxyConnection, "keep-alive");
-        }
+    private void addProxyHeaders(final Realm realm, final HttpRequestPacket request) {
         if (realm != null && realm.getUsePreemptiveAuth()) {
             final String authHeaderValue = generateAuthHeader(realm);
             if (authHeaderValue != null) {
@@ -103,18 +97,17 @@ private Realm getRealm(final Request request) {
     private String generateAuthHeader(final Realm realm) {
         try {
             switch (realm.getAuthScheme()) {
-                case BASIC:
-                    return computeBasicAuthentication(realm);
-                case DIGEST:
-                    return computeDigestAuthentication(proxyServer);
-                case NTLM:
-                     return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
-                default:
-                    return null;
+            case BASIC:
+                return computeBasicAuthentication(realm);
+            case DIGEST:
+                return computeDigestAuthentication(realm);
+            case NTLM:
+                return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
+            default:
+                return null;
             }
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
index a5700b10a..b0449e82d 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,7 +13,15 @@
 
 package org.asynchttpclient.providers.grizzly.filters;
 
+import java.io.IOException;
+import java.net.ConnectException;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSession;
 import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
+import org.asynchttpclient.util.Base64;
+import org.glassfish.grizzly.CompletionHandler;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.EmptyCompletionHandler;
 import org.glassfish.grizzly.Grizzly;
@@ -25,12 +33,9 @@
 import org.glassfish.grizzly.filterchain.NextAction;
 import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
 import org.glassfish.grizzly.ssl.SSLFilter;
-
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLHandshakeException;
-import java.io.IOException;
-import java.util.concurrent.ConcurrentHashMap;
-
+import org.glassfish.grizzly.ssl.SSLUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * SSL Filter that may be present within the FilterChain and may be
@@ -41,25 +46,21 @@
  */
 public final class SwitchingSSLFilter extends SSLFilter {
 
-    private static final Attribute<Boolean> CONNECTION_IS_SECURE =
-        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class.getName());
-    private static final Attribute<Throwable> HANDSHAKE_ERROR =
-        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class.getName() + "-HANDSHAKE-ERROR");
-
+    private static final Attribute<Boolean> CONNECTION_IS_SECURE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
+            .createAttribute(SwitchingSSLFilter.class.getName());
+    private static final Attribute<Throwable> HANDSHAKE_ERROR = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class
+            .getName() + "-HANDSHAKE-ERROR");
 
+    private final static Logger LOGGER = LoggerFactory.getLogger(SwitchingSSLFilter.class);
+    
     // ------------------------------------------------------------ Constructors
 
-
     public SwitchingSSLFilter(final SSLEngineConfigurator clientConfig) {
-
         super(null, clientConfig);
-        addHandshakeListener(new ProtocolHandshakeListener());
     }
 
-
     // -------------------------------------------------- Methods from SSLFilter
 
-
     @Override
     protected void notifyHandshakeFailed(Connection connection, Throwable t) {
         setError(connection, t);
@@ -73,35 +74,33 @@ public NextAction handleConnect(final FilterChainContext ctx) throws IOException
         // to determine if a connection is SPDY or HTTP as early as possible.
         ctx.suspend();
         final Connection c = ctx.getConnection();
-        handshake(ctx.getConnection(),
-                  new EmptyCompletionHandler<SSLEngine>() {
-                      @Override
-                      public void completed(SSLEngine result) {
-                          // Handshake was successful.  Resume the handleConnect
-                          // processing.  We pass in Invoke Action so the filter
-                          // chain will call handleConnect on the next filter.
-                          ctx.resume(ctx.getInvokeAction());
-                      }
-
-                      @Override
-                      public void cancelled() {
-                          // Handshake was cancelled.  Stop the handleConnect
-                          // processing.  The exception will be checked and
-                          // passed to the user later.
-                          setError(c, new SSLHandshakeException(
-                                  "Handshake canceled."));
-                          ctx.resume(ctx.getStopAction());
-                      }
-
-                      @Override
-                      public void failed(Throwable throwable) {
-                          // Handshake failed.  Stop the handleConnect
-                          // processing.  The exception will be checked and
-                          // passed to the user later.
-                          setError(c, throwable);
-                          ctx.resume(ctx.getStopAction());
-                      }
-                  });
+        handshake(ctx.getConnection(), new EmptyCompletionHandler<SSLEngine>() {
+            @Override
+            public void completed(SSLEngine result) {
+                // Handshake was successful.  Resume the handleConnect
+                // processing.  We pass in Invoke Action so the filter
+                // chain will call handleConnect on the next filter.
+                ctx.resume(ctx.getInvokeAction());
+            }
+
+            @Override
+            public void cancelled() {
+                // Handshake was cancelled.  Stop the handleConnect
+                // processing.  The exception will be checked and
+                // passed to the user later.
+                setError(c, new SSLHandshakeException("Handshake canceled."));
+                ctx.resume(ctx.getStopAction());
+            }
+
+            @Override
+            public void failed(Throwable throwable) {
+                // Handshake failed.  Stop the handleConnect
+                // processing.  The exception will be checked and
+                // passed to the user later.
+                setError(c, throwable);
+                ctx.resume(ctx.getStopAction());
+            }
+        });
 
         // This typically isn't advised, however, we need to be able to
         // read the response from the proxy and OP_READ isn't typically
@@ -115,8 +114,7 @@ public void failed(Throwable throwable) {
     }
 
     @Override
-    public NextAction handleEvent(final FilterChainContext ctx,
-                                  final FilterChainEvent event) throws IOException {
+    public NextAction handleEvent(final FilterChainContext ctx, final FilterChainEvent event) throws IOException {
 
         if (event.type() == SSLSwitchingEvent.class) {
             final SSLSwitchingEvent se = (SSLSwitchingEvent) event;
@@ -124,7 +122,6 @@ public NextAction handleEvent(final FilterChainContext ctx,
             return ctx.getStopAction();
         }
         return ctx.getInvokeAction();
-
     }
 
     @Override
@@ -134,7 +131,6 @@ public NextAction handleRead(final FilterChainContext ctx) throws IOException {
             return super.handleRead(ctx);
         }
         return ctx.getInvokeAction();
-
     }
 
     @Override
@@ -144,7 +140,6 @@ public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
             return super.handleWrite(ctx);
         }
         return ctx.getInvokeAction();
-
     }
 
     @Override
@@ -152,15 +147,12 @@ public void onFilterChainChanged(final FilterChain filterChain) {
         // no-op
     }
 
-
     public static Throwable getHandshakeError(final Connection c) {
         return HANDSHAKE_ERROR.remove(c);
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private static boolean isSecure(final Connection c) {
         Boolean secStatus = CONNECTION_IS_SECURE.get(c);
         return (secStatus == null ? true : secStatus);
@@ -177,51 +169,57 @@ private static void setError(final Connection c, Throwable t) {
     private static void enableRead(final Connection c) throws IOException {
         c.enableIOEvent(IOEvent.READ);
     }
-
-
-    // ---------------------------------------------------------- Nested Classes
-
-
-    private static interface HandshakeCompleteListener {
-            void complete();
-    }
-
-    private static final class ProtocolHandshakeListener implements HandshakeListener {
-
-
-        static final ConcurrentHashMap<Connection,HandshakeCompleteListener> listeners =
-                new ConcurrentHashMap<Connection,HandshakeCompleteListener>();
-
-
-        // --------------------------------------- Method from HandshakeListener
-
-
-        @Override
-        public void onStart(Connection connection) {
-            // no-op
-        }
-
-        @Override
-        public void onComplete(Connection connection) {
-            final HandshakeCompleteListener listener = listeners.get(connection);
-            if (listener != null) {
-                removeListener(connection);
-                listener.complete();
+    
+    // ================= HostnameVerifier section ========================
+    
+    public static CompletionHandler<Connection> wrapWithHostnameVerifierHandler(
+            final CompletionHandler<Connection> delegateCompletionHandler,
+            final HostnameVerifier verifier, final String host) {
+
+        return new CompletionHandler<Connection>() {
+
+            public void cancelled() {
+                if (delegateCompletionHandler != null) {
+                    delegateCompletionHandler.cancelled();
+                }
             }
-        }
-
-
-        // --------------------------------------------- Package Private Methods
 
+            public void failed(final Throwable throwable) {
+                if (delegateCompletionHandler != null) {
+                    delegateCompletionHandler.failed(throwable);
+                }
+            }
 
-        public static void addListener(final Connection c,
-                                       final HandshakeCompleteListener listener) {
-            listeners.putIfAbsent(c, listener);
-        }
+            public void completed(final Connection connection) {
+                if (getHandshakeError(connection) == null) {
+                    final SSLSession session = SSLUtils.getSSLEngine(connection).getSession();
+                    if (LOGGER.isDebugEnabled()) {
+                        LOGGER.debug("SSL Handshake onComplete: session = {}, id = {}, isValid = {}, host = {}",
+                                session.toString(), Base64.encode(session.getId()), session.isValid(), host);
+                    }
+
+                    if (!verifier.verify(host, session)) {
+                        connection.terminateSilently();
+
+                        if (delegateCompletionHandler != null) {
+                            IOException e = new ConnectException("Host name verification failed for host " + host);
+                            delegateCompletionHandler.failed(e);
+                        }
+
+                        return;
+                    }
+                }
+                
+                if (delegateCompletionHandler != null) {
+                    delegateCompletionHandler.completed(connection);
+                }
+            }
 
-        static void removeListener(final Connection c) {
-            listeners.remove(c);
-        }
+            public void updated(final Connection connection) {
+                if (delegateCompletionHandler != null) {
+                    delegateCompletionHandler.updated(connection);
+                }
+            }
+        };
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
index 4e4bd57bb..876e31109 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,18 +13,18 @@
 
 package org.asynchttpclient.providers.grizzly.filters;
 
+import java.io.IOException;
+
 import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.providers.grizzly.Utils;
 import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.IOEvent;
 import org.glassfish.grizzly.filterchain.BaseFilter;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.filterchain.FilterChainEvent;
 import org.glassfish.grizzly.filterchain.NextAction;
 
-import java.io.IOException;
-import java.net.URI;
-
 /**
  * This <code>Filter</code> is responsible for HTTP CONNECT
  * tunnelling when a connection should be secure and required to
@@ -36,24 +36,19 @@
 public final class TunnelFilter extends BaseFilter {
 
     private final ProxyServer proxyServer;
-    private final URI uri;
-
+    private final Uri uri;
 
     // ------------------------------------------------------------ Constructors
 
-
-    public TunnelFilter(final ProxyServer proxyServer, final URI uri) {
+    public TunnelFilter(final ProxyServer proxyServer, final Uri uri) {
         this.proxyServer = proxyServer;
         this.uri = uri;
     }
 
-
     // ----------------------------------------------------- Methods from Filter
 
-
     @Override
-    public NextAction handleConnect(FilterChainContext ctx)
-    throws IOException {
+    public NextAction handleConnect(FilterChainContext ctx) throws IOException {
         // We suspend the FilterChainContext here to prevent
         // notification of other filters of the connection event.
         // This allows us to control when the connection is returned
@@ -69,8 +64,7 @@ public NextAction handleConnect(FilterChainContext ctx)
         // When tunnel is complete, the AsyncHttpClientFilter will
         // send this event back to this filter in order to notify
         // it that the request processing is complete.
-        final TunnelRequestEvent tunnelRequestEvent =
-                new TunnelRequestEvent(ctx, proxyServer, uri);
+        final TunnelRequestEvent tunnelRequestEvent = new TunnelRequestEvent(ctx, proxyServer, uri);
         ctx.notifyUpstream(tunnelRequestEvent);
 
         // This typically isn't advised, however, we need to be able to
@@ -85,8 +79,7 @@ public NextAction handleConnect(FilterChainContext ctx)
     }
 
     @Override
-    public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event)
-    throws IOException {
+    public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException {
         if (event.type() == TunnelRequestEvent.class) {
             TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
 
@@ -97,14 +90,12 @@ public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event)
             // Obtain the context that was previously suspended and resume.
             // We pass in Invoke Action so the filter chain will call
             // handleConnect on the next filter.
-            FilterChainContext suspendedContext =
-                    tunnelRequestEvent.getSuspendedContext();
+            FilterChainContext suspendedContext = tunnelRequestEvent.getSuspendedContext();
             suspendedContext.resume(ctx.getInvokeAction());
 
             // Stop further event processing.
-            ctx.getStopAction();
+            return ctx.getStopAction();
         }
         return ctx.getInvokeAction();
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
index 247bed46f..c514d6677 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
@@ -13,7 +13,7 @@
 
 package org.asynchttpclient.providers.grizzly.filters.events;
 
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.glassfish.grizzly.filterchain.FilterChainEvent;
 
 /**
@@ -24,33 +24,24 @@
  */
 public final class ContinueEvent implements FilterChainEvent {
 
-    private final HttpTransactionContext context;
-
+    private final HttpTxContext context;
 
     // -------------------------------------------------------- Constructors
 
-
-    public ContinueEvent(final HttpTransactionContext context) {
-
+    public ContinueEvent(final HttpTxContext context) {
         this.context = context;
-
     }
 
-
     // --------------------------------------- Methods from FilterChainEvent
 
-
     @Override
     public Object type() {
         return ContinueEvent.class;
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
-    public HttpTransactionContext getContext() {
+    public HttpTxContext getContext() {
         return context;
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java
new file mode 100644
index 000000000..35252b610
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters.events;
+
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+
+/**
+ * {@link FilterChainEvent} to gracefully complete the request-response processing
+ * when {@link Connection} is getting closed by the remote host.
+ *
+ * @since 1.8.7
+ * @author The Grizzly Team
+ */
+public class GracefulCloseEvent implements FilterChainEvent {
+    private final HttpTxContext httpTxContext;
+
+    public GracefulCloseEvent(HttpTxContext httpTxContext) {
+        this.httpTxContext = httpTxContext;
+    }
+
+    public HttpTxContext getHttpTxContext() {
+        return httpTxContext;
+    }
+
+    @Override
+    public Object type() {
+        return GracefulCloseEvent.class;
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
index 84ae75f26..5fad70d10 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
@@ -16,8 +16,6 @@
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.filterchain.FilterChainEvent;
 
-import java.util.concurrent.Callable;
-
 /**
  * {@link FilterChainEvent} to dynamically enable/disable the SSLFilter on
  * a per-connection basis.
@@ -32,26 +30,20 @@
 
     // ------------------------------------------------------------ Constructors
 
-
     public SSLSwitchingEvent(final boolean secure, final Connection c) {
-
         this.secure = secure;
         connection = c;
-
     }
 
     // ------------------------------------------- Methods from FilterChainEvent
 
-
     @Override
     public Object type() {
         return SSLSwitchingEvent.class;
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
     public boolean isSecure() {
         return secure;
     }
@@ -59,5 +51,4 @@ public boolean isSecure() {
     public Connection getConnection() {
         return connection;
     }
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
index fc0285c96..ec18ac68e 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
@@ -13,11 +13,10 @@
 package org.asynchttpclient.providers.grizzly.filters.events;
 
 import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.filterchain.FilterChainEvent;
 
-import java.net.URI;
-
 /**
  * {@link FilterChainEvent} to initiate CONNECT tunnelling with a proxy server.
  *
@@ -26,35 +25,27 @@
  */
 public final class TunnelRequestEvent implements FilterChainEvent {
 
-
     private final FilterChainContext suspendedContext;
     private final ProxyServer proxyServer;
-    private final URI uri;
-
+    private final Uri uri;
 
     // ------------------------------------------------------------ Constructors
 
-    public TunnelRequestEvent(final FilterChainContext suspendedContext,
-                              final ProxyServer proxyServer,
-                              final URI uri) {
+    public TunnelRequestEvent(final FilterChainContext suspendedContext, final ProxyServer proxyServer, final Uri uri) {
         this.suspendedContext = suspendedContext;
         this.proxyServer = proxyServer;
         this.uri = uri;
     }
 
-
     // ------------------------------------------- Methods from FilterChainEvent
 
-
     @Override
     public Object type() {
         return TunnelRequestEvent.class;
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
     public FilterChainContext getSuspendedContext() {
         return suspendedContext;
     }
@@ -63,7 +54,7 @@ public ProxyServer getProxyServer() {
         return proxyServer;
     }
 
-    public URI getUri() {
+    public Uri getUri() {
         return uri;
     }
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
index 0660e27d1..d41dc9ef4 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
@@ -13,10 +13,12 @@
 
 package org.asynchttpclient.providers.grizzly.statushandler;
 
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.STOP;
+
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.providers.grizzly.ConnectionManager;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.asynchttpclient.util.AuthenticatorUtils;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
@@ -24,27 +26,22 @@
 import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.http.util.HttpStatus;
 
-import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
-
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.STOP;
+import java.util.Locale;
 
 public final class AuthorizationHandler implements StatusHandler {
 
-    public static final AuthorizationHandler INSTANCE =
-            new AuthorizationHandler();
+    public static final AuthorizationHandler INSTANCE = new AuthorizationHandler();
 
     // ---------------------------------------------- Methods from StatusHandler
 
-
     public boolean handlesStatus(int statusCode) {
         return (HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                final HttpTransactionContext httpTransactionContext,
-                                final FilterChainContext ctx) {
+    @SuppressWarnings({ "unchecked" })
+    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
+            final FilterChainContext ctx) {
 
         final String auth = responsePacket.getHeader(Header.WWWAuthenticate);
         if (auth == null) {
@@ -57,56 +54,44 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
         }
         if (realm == null) {
             httpTransactionContext.setInvocationStatus(STOP);
+            if (httpTransactionContext.getHandler() != null) {
+                try {
+                    httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
+                } catch (Exception e) {
+                    httpTransactionContext.abort(e);
+                }
+            }
             return true;
         }
 
         responsePacket.setSkipRemainder(true); // ignore the remainder of the response
 
         final Request req = httpTransactionContext.getRequest();
-        realm = new Realm.RealmBuilder().clone(realm)
-                        .setScheme(realm.getAuthScheme())
-                        .setUri(req.getURI().getPath())
-                        .setMethodName(req.getMethod())
-                        .setUsePreemptiveAuth(true)
-                        .parseWWWAuthenticateHeader(auth)
-                        .build();
-        if (auth.toLowerCase().startsWith("basic")) {
+        realm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(req.getUri())
+                .setMethodName(req.getMethod()).setUsePreemptiveAuth(true).parseWWWAuthenticateHeader(auth).build();
+        String lowerCaseAuth = auth.toLowerCase(Locale.ENGLISH);
+        if (lowerCaseAuth.startsWith("basic")) {
             req.getHeaders().remove(Header.Authorization.toString());
-            try {
-                req.getHeaders().add(Header.Authorization.toString(),
-                                     AuthenticatorUtils.computeBasicAuthentication(
-                                             realm));
-            } catch (UnsupportedEncodingException ignored) {
-            }
-        } else if (auth.toLowerCase().startsWith("digest")) {
+            req.getHeaders().add(Header.Authorization.toString(), AuthenticatorUtils.computeBasicAuthentication(realm));
+        } else if (lowerCaseAuth.startsWith("digest")) {
             req.getHeaders().remove(Header.Authorization.toString());
             try {
-                req.getHeaders().add(Header.Authorization.toString(),
-                                     AuthenticatorUtils.computeDigestAuthentication(realm));
+                req.getHeaders().add(Header.Authorization.toString(), AuthenticatorUtils.computeDigestAuthentication(realm));
             } catch (NoSuchAlgorithmException e) {
                 throw new IllegalStateException("Digest authentication not supported", e);
-            } catch (UnsupportedEncodingException e) {
-                throw new IllegalStateException("Unsupported encoding.", e);
             }
         } else {
             throw new IllegalStateException("Unsupported authorization method: " + auth);
         }
 
-
         try {
-            final Connection c = getConnectionForNextRequest(ctx,
-                                                             req,
-                                                             responsePacket,
-                                                             httpTransactionContext);
-            final HttpTransactionContext newContext =
-                    httpTransactionContext.copy();
+            final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
+            final HttpTxContext newContext = httpTransactionContext.copy();
             httpTransactionContext.setFuture(null);
-            HttpTransactionContext.set(c, newContext);
+            HttpTxContext.set(ctx, newContext);
             newContext.setInvocationStatus(STOP);
-            httpTransactionContext.getProvider().execute(c,
-                                                         req,
-                                                         httpTransactionContext.getHandler(),
-                                                         httpTransactionContext.getFuture());
+            httpTransactionContext.getProvider().execute(c, req, httpTransactionContext.getHandler(), httpTransactionContext.getFuture(),
+                    newContext);
             return false;
         } catch (Exception e) {
             httpTransactionContext.abort(e);
@@ -115,21 +100,17 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
         return false;
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
-    private Connection getConnectionForNextRequest(final FilterChainContext ctx,
-                                                   final Request request,
-                                                   final HttpResponsePacket response,
-                                                   final HttpTransactionContext httpCtx)
-    throws Exception {
+    private Connection getConnectionForNextRequest(final FilterChainContext ctx, final Request request, final HttpResponsePacket response,
+            final HttpTxContext httpCtx) throws Exception {
+        /*
         if (response.getProcessingState().isKeepAlive()) {
             return ctx.getConnection();
-        } else {
-            final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
-            return m.obtainConnection(request, httpCtx.getFuture());
-        }
+        } else { */
+        final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
+        return m.obtainConnection(request, httpCtx.getFuture());
+        /* } */
     }
 
 } // END AuthorizationHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
index f2a156592..4eb357dcb 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
@@ -18,12 +18,13 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.providers.grizzly.ConnectionManager;
 import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.asynchttpclient.util.AuthenticatorUtils;
 import org.asynchttpclient.util.Base64;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.Method;
 import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.http.util.HttpStatus;
 import org.ietf.jgss.GSSContext;
@@ -33,71 +34,48 @@
 import org.ietf.jgss.Oid;
 import org.slf4j.LoggerFactory;
 
-import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
+import java.util.Locale;
 
 public final class ProxyAuthorizationHandler implements StatusHandler {
 
-    public static final ProxyAuthorizationHandler INSTANCE =
-            new ProxyAuthorizationHandler();
-
+    public static final ProxyAuthorizationHandler INSTANCE = new ProxyAuthorizationHandler();
 
     // ---------------------------------------------- Methods from StatusHandler
 
-
     public boolean handlesStatus(int statusCode) {
-        return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407
-                .statusMatches(statusCode));
+        return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.statusMatches(statusCode));
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                final HttpTransactionContext httpTransactionContext,
-                                final FilterChainContext ctx) {
+    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
+            final FilterChainContext ctx) {
 
-        final String proxyAuth =
-                responsePacket.getHeader(Header.ProxyAuthenticate);
+        final String proxyAuth = responsePacket.getHeader(Header.ProxyAuthenticate);
         if (proxyAuth == null) {
-            throw new IllegalStateException(
-                    "407 response received, but no Proxy Authenticate header was present");
+            throw new IllegalStateException("407 response received, but no Proxy Authenticate header was present");
         }
 
         final Request req = httpTransactionContext.getRequest();
-        ProxyServer proxyServer = httpTransactionContext.getProvider()
-                .getClientConfig()
-                .getProxyServer();
+        ProxyServer proxyServer = httpTransactionContext.getProvider().getClientConfig().getProxyServerSelector()
+                .select(req.getUri());
         String principal = proxyServer.getPrincipal();
         String password = proxyServer.getPassword();
-        Realm realm = new Realm.RealmBuilder().setPrincipal(principal)
-                .setPassword(password)
-                .setUri("/")
-                .setMethodName("CONNECT")
-                .setUsePreemptiveAuth(true)
-                .parseProxyAuthenticateHeader(proxyAuth)
-                .build();
-        if (proxyAuth.toLowerCase().startsWith("basic")) {
+        Realm realm = new Realm.RealmBuilder().setPrincipal(principal).setPassword(password).setUri(req.getUri()).setOmitQuery(true)
+                .setMethodName(Method.CONNECT.getMethodString()).setUsePreemptiveAuth(true).parseProxyAuthenticateHeader(proxyAuth).build();
+        String proxyAuthLowerCase = proxyAuth.toLowerCase(Locale.ENGLISH);
+        if (proxyAuthLowerCase.startsWith("basic")) {
             req.getHeaders().remove(Header.ProxyAuthenticate.toString());
             req.getHeaders().remove(Header.ProxyAuthorization.toString());
-            try {
-                req.getHeaders().add(Header.ProxyAuthorization.toString(),
-                                     AuthenticatorUtils.computeBasicAuthentication(
-                                             realm));
-            } catch (UnsupportedEncodingException ignored) {
-            }
-        } else if (proxyAuth.toLowerCase().startsWith("digest")) {
+            req.getHeaders().add(Header.ProxyAuthorization.toString(), AuthenticatorUtils.computeBasicAuthentication(realm));
+        } else if (proxyAuthLowerCase.startsWith("digest")) {
             req.getHeaders().remove(Header.ProxyAuthenticate.toString());
             req.getHeaders().remove(Header.ProxyAuthorization.toString());
             try {
-                req.getHeaders().add(Header.ProxyAuthorization.toString(),
-                                     AuthenticatorUtils.computeDigestAuthentication(
-                                             realm));
+                req.getHeaders().add(Header.ProxyAuthorization.toString(), AuthenticatorUtils.computeDigestAuthentication(realm));
             } catch (NoSuchAlgorithmException e) {
-                throw new IllegalStateException(
-                        "Digest authentication not supported", e);
-            } catch (UnsupportedEncodingException e) {
-                throw new IllegalStateException("Unsupported encoding.", e);
+                throw new IllegalStateException("Digest authentication not supported", e);
             }
-        } else if (proxyAuth.toLowerCase().startsWith("ntlm")) {
+        } else if (proxyAuthLowerCase.startsWith("ntlm")) {
 
             req.getHeaders().remove(Header.ProxyAuthenticate.toString());
             req.getHeaders().remove(Header.ProxyAuthorization.toString());
@@ -105,31 +83,23 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
             String msg;
             try {
                 if (isNTLMFirstHandShake(proxyAuth)) {
-                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE
-                            .generateType1Msg(proxyServer.getNtlmDomain(), "");
+                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE.generateType1Msg(proxyServer.getNtlmDomain(), "");
                 } else {
-                    String serverChallenge =
-                            proxyAuth.trim().substring("NTLM ".length());
-                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE
-                            .generateType3Msg(principal, password,
-                                              proxyServer.getNtlmDomain(),
-                                              proxyServer.getHost(),
-                                              serverChallenge);
+                    String serverChallenge = proxyAuth.trim().substring("NTLM ".length());
+                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE.generateType3Msg(principal, password, proxyServer.getNtlmDomain(),
+                            proxyServer.getHost(), serverChallenge);
                 }
 
-                req.getHeaders()
-                        .add(Header.ProxyAuthorization.toString(),
-                             "NTLM " + msg);
+                req.getHeaders().add(Header.ProxyAuthorization.toString(), "NTLM " + msg);
             } catch (Exception e1) {
                 e1.printStackTrace();
             }
-        } else if (proxyAuth.toLowerCase().startsWith("negotiate")) {
+        } else if (proxyAuthLowerCase.startsWith("negotiate")) {
             //this is for kerberos
             req.getHeaders().remove(Header.ProxyAuthenticate.toString());
             req.getHeaders().remove(Header.ProxyAuthorization.toString());
         } else {
-            throw new IllegalStateException(
-                    "Unsupported authorization method: " + proxyAuth);
+            throw new IllegalStateException("Unsupported authorization method: " + proxyAuth);
         }
 
         InvocationStatus tempInvocationStatus = InvocationStatus.STOP;
@@ -139,14 +109,10 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
                 tempInvocationStatus = InvocationStatus.CONTINUE;
             }
             if (proxyAuth.toLowerCase().startsWith("negotiate")) {
-                final Connection c = getConnectionForNextRequest(ctx,
-                                                                 req,
-                                                                 responsePacket,
-                                                                 httpTransactionContext);
-                final HttpTransactionContext newContext =
-                        httpTransactionContext.copy();
+                final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
+                final HttpTxContext newContext = httpTransactionContext.copy();
                 httpTransactionContext.setFuture(null);
-                HttpTransactionContext.set(c, newContext);
+                HttpTxContext.set(ctx, newContext);
 
                 newContext.setInvocationStatus(tempInvocationStatus);
 
@@ -155,39 +121,30 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
 
                 challengeHeader = GSSSPNEGOWrapper.generateToken(server);
 
-                req.getHeaders()
-                        .add(Header.ProxyAuthorization.toString(),
-                             "Negotiate " + challengeHeader);
-
+                req.getHeaders().add(Header.ProxyAuthorization.toString(), "Negotiate " + challengeHeader);
 
-                return executeRequest(httpTransactionContext, req, c);
+                return executeRequest(httpTransactionContext, req, c, newContext);
             } else if (isNTLMSecondHandShake(proxyAuth)) {
                 final Connection c = ctx.getConnection();
-                final HttpTransactionContext newContext =
-                        httpTransactionContext.copy();
+                final HttpTxContext newContext = httpTransactionContext.copy();
 
                 httpTransactionContext.setFuture(null);
-                HttpTransactionContext.set(c, newContext);
+                HttpTxContext.set(ctx, newContext);
 
                 newContext.setInvocationStatus(tempInvocationStatus);
-                httpTransactionContext.setEstablishingTunnel(true);
 
-                return executeRequest(httpTransactionContext, req, c);
+                return executeRequest(httpTransactionContext, req, c, newContext);
 
             } else {
-                final Connection c = getConnectionForNextRequest(ctx,
-                                                                 req,
-                                                                 responsePacket,
-                                                                 httpTransactionContext);
-                final HttpTransactionContext newContext =
-                        httpTransactionContext.copy();
+                final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
+                final HttpTxContext newContext = httpTransactionContext.copy();
                 httpTransactionContext.setFuture(null);
-                HttpTransactionContext.set(c, newContext);
+                HttpTxContext.set(ctx, newContext);
 
                 newContext.setInvocationStatus(tempInvocationStatus);
 
                 //NTLM needs the same connection to be used for exchange of tokens
-                return executeRequest(httpTransactionContext, req, c);
+                return executeRequest(httpTransactionContext, req, c, newContext);
             }
         } catch (Exception e) {
             httpTransactionContext.abort(e);
@@ -196,62 +153,48 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
         return false;
     }
 
-    private boolean executeRequest(
-            final HttpTransactionContext httpTransactionContext,
-            final Request req, final Connection c) {
-        httpTransactionContext.getProvider().execute(c,
-                                                         req,
-                                                         httpTransactionContext.getHandler(),
-                                                         httpTransactionContext.getFuture());
-            return false;
+    private boolean executeRequest(final HttpTxContext httpTransactionContext, final Request req, final Connection c,
+            final HttpTxContext httpTxContext) {
+        httpTransactionContext.getProvider().execute(c, req, httpTransactionContext.getHandler(), httpTransactionContext.getFuture(),
+                httpTxContext);
+        return false;
     }
 
     public static boolean isNTLMSecondHandShake(final String proxyAuth) {
-        return (proxyAuth != null && proxyAuth.toLowerCase()
-                .startsWith("ntlm") && !proxyAuth.equalsIgnoreCase("ntlm"));
+        return (proxyAuth != null && proxyAuth.toLowerCase(Locale.ENGLISH).startsWith("ntlm") && !proxyAuth.equalsIgnoreCase("ntlm"));
     }
 
     private static boolean isNTLMFirstHandShake(final String proxy_auth) {
         return (proxy_auth.equalsIgnoreCase("ntlm"));
     }
 
-    private Connection getConnectionForNextRequest(final FilterChainContext ctx,
-                                                   final Request request,
-                                                   final HttpResponsePacket response,
-                                                   final HttpTransactionContext httpCtx)
-    throws Exception {
-        if (response.getProcessingState().isKeepAlive()) {
-            return ctx.getConnection();
-        } else {
-            final ConnectionManager m =
-                    httpCtx.getProvider().getConnectionManager();
-            return m.obtainConnection(request, httpCtx.getFuture());
-        }
+    private Connection getConnectionForNextRequest(final FilterChainContext ctx, final Request request, final HttpResponsePacket response,
+            final HttpTxContext httpCtx) throws Exception {
+        /*
+                if (response.getProcessingState().isKeepAlive()) {
+                    return ctx.getConnection();
+                } else { */
+        final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
+        return m.obtainConnection(request, httpCtx.getFuture());
+        /* } */
     }
 
-
     private static final class GSSSPNEGOWrapper {
-        private final static org.slf4j.Logger LOGGER = LoggerFactory.getLogger(
-                GSSSPNEGOWrapper.class);
+        private final static org.slf4j.Logger LOGGER = LoggerFactory.getLogger(GSSSPNEGOWrapper.class);
         private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
 
         static GSSManager getManager() {
             return GSSManager.getInstance();
         }
 
-        static byte[] generateGSSToken(
-                final byte[] input, final Oid oid, final String authServer)
-        throws GSSException {
+        static byte[] generateGSSToken(final byte[] input, final Oid oid, final String authServer) throws GSSException {
             byte[] token = input;
             if (token == null) {
                 token = new byte[0];
             }
             GSSManager manager = getManager();
-            GSSName serverName = manager.createName("HTTP@" + authServer,
-                                                    GSSName.NT_HOSTBASED_SERVICE);
-            GSSContext gssContext = manager.createContext(
-                    serverName.canonicalize(oid), oid, null,
-                    GSSContext.DEFAULT_LIFETIME);
+            GSSName serverName = manager.createName("HTTP@" + authServer, GSSName.NT_HOSTBASED_SERVICE);
+            GSSContext gssContext = manager.createContext(serverName.canonicalize(oid), oid, null, GSSContext.DEFAULT_LIFETIME);
             gssContext.requestMutualAuth(true);
             gssContext.requestCredDeleg(true);
             return gssContext.initSecContext(token, 0, token.length);
@@ -262,8 +205,7 @@ public static String generateToken(String authServer) {
             Oid oid;
             try {
                 oid = new Oid(KERBEROS_OID);
-                byte[] token = GSSSPNEGOWrapper.generateGSSToken(null, oid,
-                                                                 authServer);
+                byte[] token = GSSSPNEGOWrapper.generateGSSToken(null, oid, authServer);
                 returnVal = Base64.encode(token);
             } catch (GSSException e) {
                 LOGGER.warn(e.toString(), e);
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
index b9e2d6519..f2db96a9f 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,87 +13,71 @@
 
 package org.asynchttpclient.providers.grizzly.statushandler;
 
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
+
 import org.asynchttpclient.Request;
 import org.asynchttpclient.providers.grizzly.ConnectionManager;
 import org.asynchttpclient.providers.grizzly.EventHandler;
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
+import org.asynchttpclient.uri.Uri;
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.http.HttpResponsePacket;
 import org.glassfish.grizzly.http.util.Header;
 
-import java.net.URI;
-
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
-
 public final class RedirectHandler implements StatusHandler {
 
     public static final RedirectHandler INSTANCE = new RedirectHandler();
 
-
     // ------------------------------------------ Methods from StatusHandler
 
-
     public boolean handlesStatus(int statusCode) {
         return (EventHandler.isRedirect(statusCode));
     }
 
-    @SuppressWarnings({"unchecked"})
-    public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                final HttpTransactionContext httpTransactionContext,
-                                final FilterChainContext ctx) {
+    @SuppressWarnings({ "unchecked" })
+    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
+            final FilterChainContext ctx) {
 
         final String redirectURL = responsePacket.getHeader(Header.Location);
         if (redirectURL == null) {
             throw new IllegalStateException("redirect received, but no location header was present");
         }
 
-        URI orig;
+        Uri orig;
         if (httpTransactionContext.getLastRedirectURI() == null) {
-            orig = httpTransactionContext.getRequest().getURI();
+            orig = httpTransactionContext.getRequest().getUri();
         } else {
-            orig = AsyncHttpProviderUtils.getRedirectUri(
-                    httpTransactionContext.getRequest().getURI(),
+            orig = Uri.create(httpTransactionContext.getRequest().getUri(),
                     httpTransactionContext.getLastRedirectURI());
         }
         httpTransactionContext.setLastRedirectURI(redirectURL);
         Request requestToSend;
-        URI uri = AsyncHttpProviderUtils.getRedirectUri(orig, redirectURL);
-        if (!uri.toString().equalsIgnoreCase(orig.toString())) {
-            requestToSend = EventHandler
-                    .newRequest(uri,
-                                responsePacket,
-                                httpTransactionContext,
-                                sendAsGet(
-                                        responsePacket,
-                                        httpTransactionContext));
+        Uri uri = Uri.create(orig, redirectURL);
+        if (!uri.toUrl().equalsIgnoreCase(orig.toUrl())) {
+            requestToSend = EventHandler.newRequest(uri, responsePacket, httpTransactionContext,
+                    sendAsGet(responsePacket, httpTransactionContext));
         } else {
             httpTransactionContext.setStatusHandler(null);
             httpTransactionContext.setInvocationStatus(CONTINUE);
-                try {
-                    httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
-                } catch (Exception e) {
-                    httpTransactionContext.abort(e);
-                }
+            try {
+                httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
+            } catch (Exception e) {
+                httpTransactionContext.abort(e);
+            }
             return true;
         }
 
         final ConnectionManager m = httpTransactionContext.getProvider().getConnectionManager();
         try {
-            final Connection c = m.obtainConnection(requestToSend,
-                                                    httpTransactionContext.getFuture());
-            final HttpTransactionContext newContext =
-                    httpTransactionContext.copy();
+            final Connection c = m.obtainConnection(requestToSend, httpTransactionContext.getFuture());
+            final HttpTxContext newContext = httpTransactionContext.copy();
             httpTransactionContext.setFuture(null);
             newContext.setInvocationStatus(CONTINUE);
             newContext.setRequest(requestToSend);
-            newContext.setRequestUrl(requestToSend.getUrl());
-            HttpTransactionContext.set(c, newContext);
-            httpTransactionContext.getProvider().execute(c,
-                                                         requestToSend,
-                                                         newContext.getHandler(),
-                                                         newContext.getFuture());
+            newContext.setRequestUri(requestToSend.getUri());
+            HttpTxContext.set(ctx, newContext);
+            httpTransactionContext.getProvider().execute(c, requestToSend, newContext.getHandler(), newContext.getFuture(), newContext);
             return false;
         } catch (Exception e) {
             httpTransactionContext.abort(e);
@@ -104,15 +88,12 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
 
     }
 
-
     // ------------------------------------------------- Private Methods
 
-    private boolean sendAsGet(final HttpResponsePacket response,
-                              final HttpTransactionContext ctx) {
+    private boolean sendAsGet(final HttpResponsePacket response, final HttpTxContext ctx) {
         final int statusCode = response.getStatus();
-        return !(statusCode < 302 || statusCode > 303)
-                  && !(statusCode == 302
-                     && ctx.getProvider().getClientConfig().isStrict302Handling());
+        return !(statusCode < 302 || statusCode > 303) &&
+                !(statusCode == 302 && ctx.getProvider().getClientConfig().isStrict302Handling());
     }
 
 } // END RedirectHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
index 5ec587a42..bca0d2a26 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
@@ -13,21 +13,17 @@
 
 package org.asynchttpclient.providers.grizzly.statushandler;
 
-import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.HttpTxContext;
 import org.glassfish.grizzly.filterchain.FilterChainContext;
 import org.glassfish.grizzly.http.HttpResponsePacket;
 
 public interface StatusHandler {
 
     public enum InvocationStatus {
-        CONTINUE,
-        STOP
+        CONTINUE, STOP
     }
 
-    boolean handleStatus(final HttpResponsePacket httpResponse,
-                         final HttpTransactionContext httpTransactionContext,
-                         final FilterChainContext ctx);
+    boolean handleStatus(final HttpResponsePacket httpResponse, final HttpTxContext httpTransactionContext, final FilterChainContext ctx);
 
     boolean handlesStatus(final int statusCode);
-
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
index 1f245645a..1d2dd1291 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
@@ -19,8 +19,8 @@
 import org.asynchttpclient.websocket.WebSocketPingListener;
 import org.asynchttpclient.websocket.WebSocketPongListener;
 import org.asynchttpclient.websocket.WebSocketTextListener;
+import org.glassfish.grizzly.websockets.ClosingFrame;
 import org.glassfish.grizzly.websockets.DataFrame;
-import org.glassfish.grizzly.websockets.draft06.ClosingFrame;
 
 import java.io.ByteArrayOutputStream;
 
@@ -33,9 +33,7 @@
 
     // -------------------------------------------------------- Constructors
 
-
-    public AHCWebSocketListenerAdapter(final WebSocketListener ahcListener,
-                                       final GrizzlyWebSocketAdapter webSocket) {
+    public AHCWebSocketListenerAdapter(final WebSocketListener ahcListener, final GrizzlyWebSocketAdapter webSocket) {
         this.ahcListener = ahcListener;
         this.webSocket = webSocket;
         if (webSocket.bufferFragments) {
@@ -47,14 +45,12 @@ public AHCWebSocketListenerAdapter(final WebSocketListener ahcListener,
         }
     }
 
-
     // ------------------------------ Methods from Grizzly WebSocketListener
 
-
     @Override
     public void onClose(org.glassfish.grizzly.websockets.WebSocket gWebSocket, DataFrame dataFrame) {
         try {
-            if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(ahcListener.getClass())) {
+            if (ahcListener instanceof WebSocketCloseCodeReasonListener) {
                 ClosingFrame cf = ClosingFrame.class.cast(dataFrame);
                 WebSocketCloseCodeReasonListener.class.cast(ahcListener).onClose(webSocket, cf.getCode(), cf.getReason());
             } else {
@@ -77,7 +73,7 @@ public void onConnect(org.glassfish.grizzly.websockets.WebSocket gWebSocket) {
     @Override
     public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, String s) {
         try {
-            if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
+            if (ahcListener instanceof WebSocketTextListener) {
                 WebSocketTextListener.class.cast(ahcListener).onMessage(s);
             }
         } catch (Throwable e) {
@@ -88,7 +84,7 @@ public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, Stri
     @Override
     public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
         try {
-            if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
+            if (ahcListener instanceof WebSocketByteListener) {
                 WebSocketByteListener.class.cast(ahcListener).onMessage(bytes);
             }
         } catch (Throwable e) {
@@ -99,7 +95,7 @@ public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, byte
     @Override
     public void onPing(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
         try {
-            if (WebSocketPingListener.class.isAssignableFrom(ahcListener.getClass())) {
+            if (ahcListener instanceof WebSocketPingListener) {
                 WebSocketPingListener.class.cast(ahcListener).onPing(bytes);
             }
         } catch (Throwable e) {
@@ -110,7 +106,7 @@ public void onPing(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[]
     @Override
     public void onPong(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
         try {
-            if (WebSocketPongListener.class.isAssignableFrom(ahcListener.getClass())) {
+            if (ahcListener instanceof WebSocketPongListener) {
                 WebSocketPongListener.class.cast(ahcListener).onPong(bytes);
             }
         } catch (Throwable e) {
@@ -125,17 +121,13 @@ public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, Str
                 synchronized (this.webSocket) {
                     stringBuffer.append(s);
                     if (last) {
-                        if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
+                        if (ahcListener instanceof WebSocketTextListener) {
                             final String message = stringBuffer.toString();
                             stringBuffer.setLength(0);
                             WebSocketTextListener.class.cast(ahcListener).onMessage(message);
                         }
                     }
                 }
-            } else {
-                if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketTextListener.class.cast(ahcListener).onFragment(s, last);
-                }
             }
         } catch (Throwable e) {
             ahcListener.onError(e);
@@ -149,17 +141,13 @@ public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, byt
                 synchronized (this.webSocket) {
                     byteArrayOutputStream.write(bytes);
                     if (last) {
-                        if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
+                        if (ahcListener instanceof WebSocketByteListener) {
                             final byte[] bytesLocal = byteArrayOutputStream.toByteArray();
                             byteArrayOutputStream.reset();
                             WebSocketByteListener.class.cast(ahcListener).onMessage(bytesLocal);
                         }
                     }
                 }
-            } else {
-                if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketByteListener.class.cast(ahcListener).onFragment(bytes, last);
-                }
             }
         } catch (Throwable e) {
             ahcListener.onError(e);
@@ -168,8 +156,10 @@ public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, byt
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o)
+            return true;
+        if (o == null || getClass() != o.getClass())
+            return false;
 
         AHCWebSocketListenerAdapter that = (AHCWebSocketListenerAdapter) o;
 
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
index aea9a4ee9..e06538fdc 100644
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
@@ -13,12 +13,12 @@
 
 package org.asynchttpclient.providers.grizzly.websocket;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
 import org.asynchttpclient.websocket.WebSocket;
 import org.asynchttpclient.websocket.WebSocketListener;
 import org.glassfish.grizzly.websockets.SimpleWebSocket;
 
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-
 public final class GrizzlyWebSocketAdapter implements WebSocket {
 
     private final SimpleWebSocket gWebSocket;
@@ -26,17 +26,13 @@
 
     // -------------------------------------------------------- Constructors
 
-
-    public GrizzlyWebSocketAdapter(final SimpleWebSocket gWebSocket,
-                                   final boolean bufferFragments) {
+    public GrizzlyWebSocketAdapter(final SimpleWebSocket gWebSocket, final boolean bufferFragments) {
         this.gWebSocket = gWebSocket;
         this.bufferFragments = bufferFragments;
     }
 
-
     // ---------------------------------------------- Methods from AHC WebSocket
 
-
     @Override
     public WebSocket sendMessage(byte[] message) {
         gWebSocket.send(message);
@@ -60,13 +56,13 @@ public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
     }
 
     @Override
-    public WebSocket sendTextMessage(String message) {
+    public WebSocket sendMessage(String message) {
         gWebSocket.send(message);
         return this;
     }
 
     @Override
-    public WebSocket streamText(String fragment, boolean last) {
+    public WebSocket stream(String fragment, boolean last) {
         gWebSocket.stream(last, fragment);
         return this;
     }
@@ -105,10 +101,8 @@ public void close() {
         gWebSocket.close();
     }
 
-
     // ---------------------------------------------------------- Public Methods
 
-
     public SimpleWebSocket getGrizzlyWebSocket() {
         return gWebSocket;
     }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
index e393235e0..3c9403e20 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
@@ -17,43 +17,24 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.async.AsyncProvidersBasicTest;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.grizzly.TransportCustomizer;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
 import org.testng.annotations.Test;
 
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
-
+@Test
 public class GrizzlyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Override
-    @Test
-    public void asyncHeaderPOSTTest() throws Throwable {
-        super.asyncHeaderPOSTTest();    //To change body of overridden methods use File | Settings | File Templates.
-    }
-
-    @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
         final GrizzlyAsyncHttpProviderConfig config = new GrizzlyAsyncHttpProviderConfig();
-        config.addProperty(TRANSPORT_CUSTOMIZER, new TransportCustomizer() {
-            @Override
-            public void customize(TCPNIOTransport transport, FilterChainBuilder builder) {
-                transport.setTcpNoDelay(true);
-                transport.setIOStrategy(SameThreadIOStrategy.getInstance());
-            }
-        });
         return config;
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = false)
-    public void asyncDoPostBasicGZIPTest() throws Throwable {
+    @Override
+    protected String acceptEncodingHeader() {
+        return "gzip";
     }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
index 3e2c4953f..5f4dfd49b 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
index 9b705611a..cee8d596d 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
index 81a62f933..32dd91806 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
@@ -19,10 +19,8 @@
 
 public class GrizzlyAuthTimeoutTest extends AuthTimeoutTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
index 06bd657f2..08387273a 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
@@ -19,10 +19,13 @@
 
 public class GrizzlyBasicAuthTest extends BasicAuthTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
+    @Override
+    public String getProviderClass() {
+        return GrizzlyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
index b8e290246..c2cedc0ee 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
@@ -23,9 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
-    @Override
-    public void zeroCopyPostTest() throws Throwable {
-        super.zeroCopyPostTest();    //To change body of overridden methods use File | Settings | File Templates.
-    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
index 2fa8d6ddb..782d97308 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
index 3d43f261b..3151f436e 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
@@ -25,7 +25,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled=false)
-    public void basicByteBufferTest() throws Throwable {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicByteBufferTest() throws Exception {
     }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
index 904d17d50..eb20e31ab 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
index 8ef3813c5..4385eeb3a 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
index 5ed9e95bb..be0aed7b7 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
@@ -13,18 +13,18 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionsPool;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.async.ConnectionPoolTest;
-import org.glassfish.grizzly.Connection;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.TimeUnit;
 
-import static org.testng.Assert.*;
-
 public class GrizzlyConnectionPoolTest extends ConnectionPoolTest {
 
     @Override
@@ -33,119 +33,15 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    @Test(enabled=false)
+    @Test(enabled = false)
     public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
-        try {
-            String url = getTargetUrl();
-            int i;
-            Exception exception = null;
-            for (i = 0; i < 20; i++) {
-                try {
-                    log.info("{} requesting url [{}]...", i, url);
-
-                    if (i < 5) {
-                        client.prepareGet(url).execute().get();
-                    } else {
-                        client.prepareGet(url).execute();
-                    }
-                } catch (Exception ex) {
-                    exception = ex;
-                    break;
-                }
-            }
-            assertNotNull(exception);
-            assertNotNull(exception.getMessage());
-        } finally {
-            client.close();
-        }
-    }
-
-    @Override
-    public void testValidConnectionsPool() {
-        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
-
-            public boolean offer(String key, Connection connection) {
-                return true;
-            }
-
-            public Connection poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Connection connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return true;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
-        try {
-            Exception exception = null;
-            try {
-                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNull(exception);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled=false)
-    public void testInvalidConnectionsPool() {
-
-        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
-
-            public boolean offer(String key, Connection connection) {
-                return false;
-            }
-
-            public Connection poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Connection connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return false;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
-        try {
-            Exception exception = null;
-            try {
-                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNotNull(exception);
-        } finally {
-            client.close();
-        }
     }
 
     @Override
     @Test
-    public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+    public void multipleMaxConnectionOpenTest() throws Exception {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000)
+                .setMaxConnections(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
         try {
             String body = "hello there";
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
index f6e343593..ab5c9b901 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
index 161eeb260..58cd22bd2 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
index c8946c34b..a3f52b827 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
index b58e1a702..fe1f7cff1 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
@@ -17,11 +17,10 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.Expect100ContinueTest;
 
-public class GrizzlyExpectContinue100Test extends Expect100ContinueTest{
+public class GrizzlyExpectContinue100Test extends Expect100ContinueTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java
new file mode 100644
index 000000000..2beca1a78
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator.NonBlockingFeeder;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.http.server.HttpHandler;
+import org.glassfish.grizzly.http.server.HttpServer;
+import org.glassfish.grizzly.http.server.NetworkListener;
+import static org.glassfish.grizzly.http.server.NetworkListener.DEFAULT_NETWORK_HOST;
+import org.glassfish.grizzly.http.server.Request;
+import org.glassfish.grizzly.http.server.Response;
+import org.glassfish.grizzly.memory.Buffers;
+import static org.glassfish.grizzly.memory.MemoryManager.DEFAULT_MEMORY_MANAGER;
+import org.glassfish.grizzly.ssl.SSLContextConfigurator;
+import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
+import org.glassfish.grizzly.utils.Charsets;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+import static org.testng.AssertJUnit.assertEquals;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+public class GrizzlyFeedableBodyGeneratorTest {
+
+    private static final byte[] DATA =
+            "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ".getBytes(Charsets.ASCII_CHARSET);
+    private static final int TEMP_FILE_SIZE = 2 * 1024 * 1024;
+    private static final int NON_SECURE_PORT = 9991;
+    private static final int SECURE_PORT = 9992;
+
+
+    private HttpServer server;
+    private File tempFile;
+
+
+    // ------------------------------------------------------------------- Setup
+
+
+    @BeforeMethod
+    public void setup() throws Exception {
+        generateTempFile();
+        server = new HttpServer();
+        NetworkListener nonSecure =
+                new NetworkListener("nonsecure",
+                                    DEFAULT_NETWORK_HOST,
+                                    NON_SECURE_PORT);
+        NetworkListener secure =
+                new NetworkListener("secure",
+                                    DEFAULT_NETWORK_HOST,
+                                    SECURE_PORT);
+        secure.setSecure(true);
+        secure.setSSLEngineConfig(createSSLConfig());
+        server.addListener(nonSecure);
+        server.addListener(secure);
+        server.getServerConfiguration().addHttpHandler(new ConsumingHandler(), "/test");
+        server.start();
+    }
+
+
+    // --------------------------------------------------------------- Tear Down
+
+
+    @AfterMethod
+    public void tearDown() {
+        if (!tempFile.delete()) {
+            tempFile.deleteOnExit();
+        }
+        tempFile = null;
+        server.shutdownNow();
+        server = null;
+    }
+
+
+    // ------------------------------------------------------------ Test Methods
+
+
+    @Test
+    public void testSimpleFeederMultipleThreads() throws Exception {
+        doSimpleFeeder(false);
+    }
+
+    @Test
+    public void testSimpleFeederOverSSLMultipleThreads() throws Exception {
+        doSimpleFeeder(true);
+    }
+
+    @Test
+    public void testNonBlockingFeederMultipleThreads() throws Exception {
+        doNonBlockingFeeder(false);
+    }
+
+    @Test
+    public void testNonBlockingFeederOverSSLMultipleThreads() throws Exception {
+        doNonBlockingFeeder(true);
+    }
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private void doSimpleFeeder(final boolean secure) {
+        final int threadCount = 10;
+        final CountDownLatch latch = new CountDownLatch(threadCount);
+        final int port = (secure ? SECURE_PORT : NON_SECURE_PORT);
+        final String scheme = (secure ? "https" : "http");
+        ExecutorService service = Executors.newFixedThreadPool(threadCount);
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
+                .setMaxConnectionsPerHost(60)
+                .setMaxConnections(60)
+                .setAcceptAnyCertificate(true)
+                .build();
+        final AsyncHttpClient client =
+                new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        final int[] statusCodes = new int[threadCount];
+        final int[] totalsReceived = new int[threadCount];
+        final Throwable[] errors = new Throwable[threadCount];
+        for (int i = 0; i < threadCount; i++) {
+            final int idx = i;
+            service.execute(new Runnable() {
+                @Override
+                public void run() {
+                    FeedableBodyGenerator generator =
+                            new FeedableBodyGenerator();
+                    FeedableBodyGenerator.SimpleFeeder simpleFeeder =
+                            new FeedableBodyGenerator.SimpleFeeder(generator) {
+                                @Override
+                                public void flush() throws IOException {
+                                    FileInputStream in = null;
+                                    try {
+                                        final byte[] bytesIn = new byte[2048];
+                                        in = new FileInputStream(tempFile);
+                                        int read;
+                                        while ((read = in.read(bytesIn)) != -1) {
+                                            final Buffer b =
+                                                    Buffers.wrap(
+                                                            DEFAULT_MEMORY_MANAGER,
+                                                            bytesIn,
+                                                            0,
+                                                            read);
+                                            feed(b, false);
+                                        }
+                                        feed(Buffers.EMPTY_BUFFER, true);
+                                    } finally {
+                                        if (in != null) {
+                                            try {
+                                                in.close();
+                                            } catch (IOException ignored) {
+                                            }
+                                        }
+                                    }
+                                }
+                            };
+                    generator.setFeeder(simpleFeeder);
+                    generator.setMaxPendingBytes(10000);
+
+                    RequestBuilder builder = new RequestBuilder("POST");
+                    builder.setUrl(scheme + "://localhost:" + port + "/test");
+                    builder.setBody(generator);
+                    try {
+                        client.executeRequest(builder.build(),
+                                new AsyncCompletionHandler<org.asynchttpclient.Response>() {
+                                    @Override
+                                    public org.asynchttpclient.Response onCompleted(org.asynchttpclient.Response response)
+                                    throws Exception {
+                                        try {
+                                            totalsReceived[idx] = Integer.parseInt(response.getHeader("x-total"));
+                                        } catch (Exception e) {
+                                            errors[idx] = e;
+                                        }
+                                        statusCodes[idx] = response.getStatusCode();
+                                        latch.countDown();
+                                        return response;
+                                    }
+
+                                    @Override
+                                    public void onThrowable(Throwable t) {
+                                        errors[idx] = t;
+                                        t.printStackTrace();
+                                        latch.countDown();
+                                    }
+                               });
+                    } catch (IOException e) {
+                        errors[idx] = e;
+                        latch.countDown();
+                    }
+                }
+            });
+        }
+
+        try {
+            latch.await(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            fail("Latch interrupted");
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            assertEquals(200, statusCodes[i]);
+            assertNull(errors[i]);
+            assertEquals(tempFile.length(), totalsReceived[i]);
+        }
+    }
+
+    private void doNonBlockingFeeder(final boolean secure) {
+        final int threadCount = 10;
+        final CountDownLatch latch = new CountDownLatch(threadCount);
+        final int port = (secure ? SECURE_PORT : NON_SECURE_PORT);
+        final String scheme = (secure ? "https" : "http");
+        final ExecutorService service = Executors.newCachedThreadPool();
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
+                .setMaxConnectionsPerHost(60)
+                .setMaxConnections(60)
+                .setAcceptAnyCertificate(true)
+                .build();
+        final AsyncHttpClient client =
+                new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        final int[] statusCodes = new int[threadCount];
+        final int[] totalsReceived = new int[threadCount];
+        final Throwable[] errors = new Throwable[threadCount];
+        for (int i = 0; i < threadCount; i++) {
+            final int idx = i;
+            service.execute(new Runnable() {
+                @Override
+                public void run() {
+                    FeedableBodyGenerator generator =
+                            new FeedableBodyGenerator();
+                    FeedableBodyGenerator.NonBlockingFeeder nonBlockingFeeder =
+                            new FeedableBodyGenerator.NonBlockingFeeder(generator) {
+                                private final Random r = new Random();
+                                private final InputStream in;
+                                private final byte[] bytesIn = new byte[2048];
+                                private boolean isDone;
+                                
+                                {
+                                    try {
+                                        in = new FileInputStream(tempFile);
+                                    } catch (IOException e) {
+                                        throw new IllegalStateException(e);
+                                    }
+                                }
+
+                                @Override
+                                public void canFeed() throws IOException {
+                                    final int read = in.read(bytesIn);
+                                    if (read == -1) {
+                                        isDone = true;
+                                        feed(Buffers.EMPTY_BUFFER, true);
+                                        return;
+                                    }
+
+                                    final Buffer b =
+                                            Buffers.wrap(
+                                                    DEFAULT_MEMORY_MANAGER,
+                                                    bytesIn,
+                                                    0,
+                                                    read);
+                                    feed(b, false);
+                                }
+
+                                @Override
+                                public boolean isDone() {
+                                    return isDone;
+                                }
+
+                                @Override
+                                public boolean isReady() {
+                                    // simulate real-life usecase, where data could not be ready
+                                    return r.nextInt(100) < 80;
+                                }
+
+                                @Override
+                                public void notifyReadyToFeed(
+                                        final NonBlockingFeeder.ReadyToFeedListener listener) {
+                                    service.execute(new Runnable() {
+
+                                        public void run() {
+                                            try {
+                                                Thread.sleep(2);
+                                            } catch (InterruptedException e) {
+                                            }
+                                            
+                                            listener.ready();
+                                        }
+                                        
+                                    });
+                                }
+                            };
+                    generator.setFeeder(nonBlockingFeeder);
+                    generator.setMaxPendingBytes(10000);
+
+                    RequestBuilder builder = new RequestBuilder("POST");
+                    builder.setUrl(scheme + "://localhost:" + port + "/test");
+                    builder.setBody(generator);
+                    try {
+                        client.executeRequest(builder.build(),
+                                new AsyncCompletionHandler<org.asynchttpclient.Response>() {
+                                    @Override
+                                    public org.asynchttpclient.Response onCompleted(org.asynchttpclient.Response response)
+                                    throws Exception {
+                                        try {
+                                            totalsReceived[idx] = Integer.parseInt(response.getHeader("x-total"));
+                                        } catch (Exception e) {
+                                            errors[idx] = e;
+                                        }
+                                        statusCodes[idx] = response.getStatusCode();
+                                        latch.countDown();
+                                        return response;
+                                    }
+
+                                    @Override
+                                    public void onThrowable(Throwable t) {
+                                        errors[idx] = t;
+                                        t.printStackTrace();
+                                        latch.countDown();
+                                    }
+                               });
+                    } catch (IOException e) {
+                        errors[idx] = e;
+                        latch.countDown();
+                    }
+                }
+            });
+        }
+
+        try {
+            latch.await(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            fail("Latch interrupted");
+        } finally {
+            service.shutdownNow();
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            assertEquals(200, statusCodes[i]);
+            assertNull(errors[i]);
+            assertEquals(tempFile.length(), totalsReceived[i]);
+        }
+    }
+    
+    private static SSLEngineConfigurator createSSLConfig()
+    throws Exception {
+        final SSLContextConfigurator sslContextConfigurator =
+                new SSLContextConfigurator();
+        final ClassLoader cl = GrizzlyFeedableBodyGeneratorTest.class.getClassLoader();
+        // override system properties
+        final URL cacertsUrl = cl.getResource("ssltest-cacerts.jks");
+        if (cacertsUrl != null) {
+            sslContextConfigurator.setTrustStoreFile(cacertsUrl.getFile());
+            sslContextConfigurator.setTrustStorePass("changeit");
+        }
+
+        // override system properties
+        final URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
+        if (keystoreUrl != null) {
+            sslContextConfigurator.setKeyStoreFile(keystoreUrl.getFile());
+            sslContextConfigurator.setKeyStorePass("changeit");
+        }
+
+        return new SSLEngineConfigurator(
+                sslContextConfigurator.createSSLContext(),
+                false, false, false);
+    }
+
+
+    private void generateTempFile() throws IOException {
+        tempFile = File.createTempFile("feedable", null);
+        int total = 0;
+        byte[] chunk = new byte[1024];
+        Random r = new Random(System.currentTimeMillis());
+        FileOutputStream out = new FileOutputStream(tempFile);
+        while (total < TEMP_FILE_SIZE) {
+            for (int i = 0; i < chunk.length; i++) {
+                chunk[i] = DATA[r.nextInt(DATA.length)];
+            }
+            out.write(chunk);
+            total += chunk.length;
+        }
+        out.flush();
+        out.close();
+    }
+
+
+    // ---------------------------------------------------------- Nested Classes
+
+
+    private static final class ConsumingHandler extends HttpHandler {
+
+
+        // -------------------------------------------- Methods from HttpHandler
+
+
+        @Override
+        public void service(Request request, Response response)
+        throws Exception {
+            int total = 0;
+            byte[] bytesIn = new byte[2048];
+            InputStream in = request.getInputStream();
+            int read;
+            while ((read = in.read(bytesIn)) != -1) {
+                total += read;
+                Thread.sleep(5);
+            }
+            response.addHeader("X-Total", Integer.toString(total));
+        }
+
+    } // END ConsumingHandler
+
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
index fd138b590..b45f00a31 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
index 2e602fa67..4f3c80361 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
index d9975af03..af3f92b7d 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java
similarity index 78%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java
index 004a2eb43..7453f6a24 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,16 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+
+package org.asynchttpclient.providers.grizzly;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.HostnameVerifierTest;
 
-public class NettyHostnameVerifierTest extends HostnameVerifierTest {
+public class GrizzlyHostnameVerifierTest extends HostnameVerifierTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
index 6ac2d1083..bd14ab34b 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
index 395c489b3..adc6a1641 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
index b71ade1df..60503e83c 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
index bdfec6d84..866a09729 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
index 70872b6a6..f07f7abfe 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
@@ -26,7 +26,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    @Test(enabled=false)
+    @Test(enabled = false)
     public void testMaxConnectionsWithinThreads() {
         super.testMaxConnectionsWithinThreads();
     }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
index e0ceb7ac7..3cf596576 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
index cb38a7a42..3dfe5a935 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java
new file mode 100644
index 000000000..17ddbb69c
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2014 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.glassfish.grizzly.http.server.HttpHandler;
+import org.glassfish.grizzly.http.server.HttpServer;
+import org.glassfish.grizzly.http.server.NetworkListener;
+import static org.glassfish.grizzly.http.server.NetworkListener.DEFAULT_NETWORK_HOST;
+import org.glassfish.grizzly.http.server.Request;
+import org.glassfish.grizzly.http.server.Response;
+import org.testng.Assert;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+public class GrizzlyNoTransferEncodingTest {
+    private static final String TEST_MESSAGE = "Hello World!";
+    
+    private HttpServer server;
+    private int port;
+    // ------------------------------------------------------------------- Setup
+
+
+    @BeforeMethod
+    public void setup() throws Exception {
+        server = new HttpServer();
+        final NetworkListener listener =
+                new NetworkListener("server",
+                                    DEFAULT_NETWORK_HOST,
+                                    0);
+        // disable chunking
+        listener.setChunkingEnabled(false);
+        server.addListener(listener);
+        server.getServerConfiguration().addHttpHandler(
+                new HttpHandler() {
+
+                    @Override
+                    public void service(final Request request,
+                            final Response response) throws Exception {
+                        response.setContentType("plain/text;charset=\"utf-8\"");
+                        // flush to make sure content-length will be missed
+                        response.flush();
+                        
+                        response.getWriter().write(TEST_MESSAGE);
+                    }
+                }, "/test");
+        
+        server.start();
+        
+        port = listener.getPort();
+    }
+
+
+    // --------------------------------------------------------------- Tear Down
+
+
+    @AfterMethod
+    public void tearDown() {
+        server.shutdownNow();
+        server = null;
+    }
+
+
+    // ------------------------------------------------------------ Test Methods
+
+
+    @Test
+    public void testNoTransferEncoding() throws Exception {
+        String url = "http://localhost:" + port + "/test";
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
+            .setFollowRedirect(false)
+            .setConnectionTimeout(15000)
+            .setRequestTimeout(15000)
+            .setAllowPoolingConnections(false)
+            .setDisableUrlEncodingForBoundRequests(true)
+            .setIOThreadMultiplier(2) // 2 is default
+            .build();
+
+        AsyncHttpClient client = new DefaultAsyncHttpClient(
+                new GrizzlyAsyncHttpProvider(config), config);
+
+        try {
+            Future<org.asynchttpclient.Response> f = client.prepareGet(url).execute();
+            org.asynchttpclient.Response r = f.get(10, TimeUnit.SECONDS);
+            Assert.assertEquals(TEST_MESSAGE, r.getResponseBody());
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
index 08a2c5171..7534360a3 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
index dad25f32c..c49beec01 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
index 0ae732dd2..9f7aa9797 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
index 34f049e4e..14bccfc9d 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
@@ -23,12 +23,11 @@
 
     @Override
     protected void checkTimeoutMessage(String message) {
-        assertEquals("Timeout exceeded", message);
+        assertEquals(message, "Timeout exceeded");
     }
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
index 975f6e0b3..70f67cfc7 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
index 67021c923..501eb0ff7 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
@@ -17,7 +17,7 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.asynchttpclient.DefaultAsyncHttpClient;
 
 public class GrizzlyProviderUtil {
 
@@ -25,6 +25,6 @@ public static AsyncHttpClient grizzlyProvider(AsyncHttpClientConfig config) {
         if (config == null) {
             config = new AsyncHttpClientConfig.Builder().build();
         }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
     }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
index ed024c917..f3e1deab4 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
index eb6f39cd2..1828989c4 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
@@ -24,4 +24,8 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
+    @Override
+    public String getProviderClass() {
+        return GrizzlyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
index 89a52e4f6..a3c3bfd6b 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
index 5c57f8323..36ad0a8d5 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
@@ -17,11 +17,10 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.QueryParametersTest;
 
-public class GrizzlyQueryParametersTest extends QueryParametersTest{
+public class GrizzlyQueryParametersTest extends QueryParametersTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
index c68810799..b9fbc218a 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
@@ -15,15 +15,7 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.async.RedirectConnectionUsageTest;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.grizzly.TransportCustomizer;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
 
 public class GrizzlyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
 
@@ -31,19 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
-    @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
-        final GrizzlyAsyncHttpProviderConfig config = new GrizzlyAsyncHttpProviderConfig();
-        config.addProperty(TRANSPORT_CUSTOMIZER, new TransportCustomizer() {
-            @Override
-            public void customize(TCPNIOTransport transport, FilterChainBuilder builder) {
-                if (System.getProperty("blockingio") != null) {
-                    transport.configureBlocking(true);
-                }
-                transport.setIOStrategy(SameThreadIOStrategy.getInstance());
-            }
-        });
-        return config;
-    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
index 915755024..6b0dffe2c 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
index 3b0126d93..cdfa5455f 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
index 37cb4fe2e..8f27e132b 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java
similarity index 70%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java
index 39feea565..db9a6a157 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java
@@ -11,19 +11,20 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.providers.grizzly;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
+import org.asynchttpclient.async.SimpleAsyncClientErrorBehaviourTest;
 
-public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
+public class GrizzlySimpleAsyncClientErrorBehaviourTest extends SimpleAsyncClientErrorBehaviourTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
+    public String getProviderClass() {
+        return GrizzlyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
index 6a6d3041f..dbd541b93 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
@@ -24,4 +24,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
+    public String getProviderClass() {
+        return GrizzlyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
index 59e24152c..6173dbab4 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
@@ -23,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
index 3698d8e18..3829983aa 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
@@ -13,6 +13,11 @@
 
 package org.asynchttpclient.providers.grizzly;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -27,17 +32,13 @@
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
 public class GrizzlyUnexpectingTimeoutTest extends AbstractBasicTest {
 
     private static final String MSG = "Unauthorized without WWW-Authenticate header";
@@ -57,7 +58,8 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     private class ExpectExceptionHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
+                throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
             final Continuation continuation = ContinuationSupport.getContinuation(request);
             continuation.suspend();
@@ -67,7 +69,7 @@ public void run() {
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
                     } catch (IOException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     }
                 }
             }).start();
@@ -80,7 +82,7 @@ public void unexpectingTimeoutTest() throws IOException {
         final AtomicInteger counts = new AtomicInteger();
         final int timeout = 100;
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(timeout).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(timeout).build());
         try {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
                 @Override
@@ -113,7 +115,7 @@ public void onThrowable(Throwable t) {
                 fail("Interrupted.", e);
             }
             // the result should be either onCompleted or onThrowable.
-            assertEquals(1, counts.get(), "result should be one");
+            assertEquals(counts.get(), 1, "result should be one");
         } finally {
             client.close();
         }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
index 516e49928..7a809b1d7 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
@@ -15,7 +15,6 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.websocket.ByteMessageTest;
 import org.testng.annotations.Test;
 
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
index 9844fb439..7ff2884f7 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
@@ -17,7 +17,6 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
-import org.testng.annotations.Test;
 
 public class GrizzlyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
@@ -25,10 +24,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
-    @Override
-    @Test
-    public void onCloseWithCode() throws Throwable {
-        super.onCloseWithCode();    //To change body of overridden methods use File | Settings | File Templates.
-    }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java
similarity index 66%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java
index 723fc12d5..0d864e1fc 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,17 +10,19 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.providers.grizzly.websocket;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ListenableFutureTest;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.websocket.ProxyTunnellingTest;
+import org.testng.annotations.Test;
 
-public class NettyListenableFutureTest extends ListenableFutureTest {
+@Test
+public class GrizzlyProxyTunnellingTest extends ProxyTunnellingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
index 8600b57bb..d01f2424d 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
@@ -15,8 +15,6 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.websocket.RedirectTest;
 
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
index cf7db9228..c89bb0b0f 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
@@ -14,21 +14,12 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
 import org.asynchttpclient.websocket.ByteMessageTest;
-import org.testng.annotations.Test;
 
 public class GrizzlyTextMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return GrizzlyProviderUtil.grizzlyProvider(config);
     }
-
-    @Test(timeOut = 60000)
-    @Override
-    public void echoFragments() throws Exception {
-        super.echoFragments();    //To change body of overridden methods use File | Settings | File Templates.
-    }
 }
diff --git a/providers/grizzly/src/test/resources/ssltest-cacerts.jks b/providers/grizzly/src/test/resources/ssltest-cacerts.jks
index 9c1ffbe49..207b9646e 100644
Binary files a/providers/grizzly/src/test/resources/ssltest-cacerts.jks and b/providers/grizzly/src/test/resources/ssltest-cacerts.jks differ
diff --git a/providers/grizzly/src/test/resources/ssltest-keystore.jks b/providers/grizzly/src/test/resources/ssltest-keystore.jks
index a95b7c5f4..70267836e 100644
Binary files a/providers/grizzly/src/test/resources/ssltest-keystore.jks and b/providers/grizzly/src/test/resources/ssltest-keystore.jks differ
diff --git a/providers/netty-4/pom.xml b/providers/netty-4/pom.xml
deleted file mode 100644
index 5aefababc..000000000
--- a/providers/netty-4/pom.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-providers-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-netty-4-provider</artifactId>
-    <name>Asynchronous Http Client Netty 4 Provider</name>
-    <description>
-        The Async Http Client Netty 4 Provider.
-    </description>
-
-    <dependencies>
-        <dependency>
-            <groupId>io.netty</groupId>
-            <artifactId>netty-all</artifactId>
-            <version>4.0.0.Beta3</version>
-        </dependency>
-    </dependencies>
-
-</project>
\ No newline at end of file
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java
deleted file mode 100644
index d9704ca7a..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.Body;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.stream.ChunkedInput;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
- */
-class BodyChunkedInput
-        implements ChunkedInput<ByteBuf> {
-
-    private final Body body;
-
-    private final int chunkSize = 1024 * 8;
-
-    private ByteBuffer nextChunk;
-
-    private static final ByteBuffer EOF = ByteBuffer.allocate(0);
-
-    private boolean endOfInput = false;
-
-    public BodyChunkedInput(Body body) {
-        if (body == null) {
-            throw new IllegalArgumentException("no body specified");
-        }
-        this.body = body;
-    }
-
-    private ByteBuffer peekNextChunk()
-            throws IOException {
-
-        if (nextChunk == null) {
-            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-            long length = body.read(buffer);
-            if (length < 0) {
-                // Negative means this is finished
-                buffer.flip();
-                nextChunk = buffer;
-                endOfInput = true;
-            } else if (length == 0) {
-                // Zero means we didn't get anything this time, but may get next time
-                buffer.flip();
-                nextChunk = null;
-            } else {
-                buffer.flip();
-                nextChunk = buffer;
-            }
-        }
-        return nextChunk;
-    }
-
-    /**
-     * Having no next chunk does not necessarily means end of input, other chunks may arrive later
-     */
-    public boolean hasNextChunk() throws Exception {
-        return peekNextChunk() != null;
-    }
-
-    @Override
-    public boolean readChunk(ByteBuf b) throws Exception {
-        ByteBuffer buffer = peekNextChunk();
-        if (buffer == null || buffer == EOF) {
-            return false;
-        }
-        nextChunk = null;
-
-        b.writeBytes(buffer);
-        return true;
-    }
-
-    public boolean isEndOfInput() throws Exception {
-        return endOfInput;
-    }
-
-    public void close() throws Exception {
-        body.close();
-    }
-
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java
deleted file mode 100644
index cd7568498..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-
-/**
- * {@link BodyGenerator} which may return just part of the payload at the time
- * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
- * for finishing payload transferring asynchronously.
- */
-public class FeedableBodyGenerator implements BodyGenerator {
-    private final static byte[] END_PADDING = "\r\n".getBytes();
-    private final static byte[] ZERO = "0".getBytes();
-    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
-    private final AtomicInteger queueSize = new AtomicInteger();
-    private FeedListener listener;
-
-    @Override
-    public Body createBody() throws IOException {
-        return new PushBody();
-    }
-
-    public void feed(final ByteBuffer buffer, final boolean isLast) throws IOException {
-        queue.offer(new BodyPart(buffer, isLast));
-        queueSize.incrementAndGet();
-        if (listener != null) {
-            listener.onContentAdded();
-        }
-    }
-
-    public static interface FeedListener {
-        public void onContentAdded();
-    }
-
-    public void setListener(FeedListener listener) {
-        this.listener = listener;
-    }
-
-    private final class PushBody implements Body {
-        private final int ONGOING = 0;
-        private final int CLOSING = 1;
-        private final int FINISHED = 2;
-
-        private int finishState = 0;
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-
-        @Override
-        public long read(final ByteBuffer buffer) throws IOException {
-            BodyPart nextPart = queue.peek();
-            if (nextPart == null) {
-                // Nothing in the queue
-                switch (finishState) {
-                case ONGOING:
-                    return 0;
-                case CLOSING:
-                    buffer.put(ZERO);
-                    buffer.put(END_PADDING);
-                    finishState = FINISHED;
-                    return buffer.position();
-                case FINISHED:
-                    buffer.put(END_PADDING);
-                    return -1;
-                }
-            }
-            int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
-            int size = Math.min(nextPart.buffer.remaining(), capacity);
-            buffer.put(Integer.toHexString(size).getBytes());
-            buffer.put(END_PADDING);
-            for (int i=0; i < size; i++) {
-              buffer.put(nextPart.buffer.get());
-            }
-            buffer.put(END_PADDING);
-            if (!nextPart.buffer.hasRemaining()) {
-                if (nextPart.isLast) {
-                    finishState = CLOSING;
-                }
-                queue.remove();
-            }
-            return size;
-        }
-
-        @Override
-        public void close() throws IOException {
-        }
-
-    }
-
-    private final static class BodyPart {
-        private final boolean isLast;
-        private final ByteBuffer buffer;
-
-        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
-            this.buffer = buffer;
-            this.isLast = isLast;
-        }
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java
deleted file mode 100644
index 9026fe3a3..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java
+++ /dev/null
@@ -1,2504 +0,0 @@
-/*
- * Copyright 2010-2013 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.STATE;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.ConnectionPoolKeyStrategy;
-import org.asynchttpclient.ConnectionsPool;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.ProgressAsyncHandler;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.RandomAccessBody;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.ntlm.NTLMEngineException;
-import org.asynchttpclient.providers.netty_4.FeedableBodyGenerator.FeedListener;
-import org.asynchttpclient.providers.netty_4.spnego.SpnegoEngine;
-import org.asynchttpclient.providers.netty_4.spnego.SpnegoEngine;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
-import org.asynchttpclient.multipart.MultipartBody;
-import org.asynchttpclient.multipart.MultipartRequestEntity;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.providers.netty_4.util.CleanupChannelGroup;
-import org.asynchttpclient.util.ProxyUtils;
-import org.asynchttpclient.util.SslUtils;
-import org.asynchttpclient.util.UTF8UrlEncoder;
-import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.AbstractReferenceCounted;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.FileRegion;
-import io.netty.channel.group.ChannelGroup;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.oio.OioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.channel.socket.oio.OioSocketChannel;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpObject;
-import io.netty.handler.codec.http.DefaultCookie;
-import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpContentCompressor;
-import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpRequestEncoder;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpResponseDecoder;
-import io.netty.handler.codec.http.HttpVersion;
-import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
-import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
-import io.netty.handler.codec.http.websocketx.WebSocketFrame;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.handler.stream.ChunkedFile;
-import io.netty.handler.stream.ChunkedWriteHandler;
-import io.netty.util.AttributeKey;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.SSLEngine;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.lang.reflect.Field;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
-import java.nio.charset.Charset;
-import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-
-
-public class NettyAsyncHttpProvider extends ChannelInboundMessageHandlerAdapter<Object> implements AsyncHttpProvider {
-    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
-    private final static String HTTP_HANDLER = "httpHandler";
-    protected final static String SSL_HANDLER = "sslHandler";
-    private final static String HTTPS = "https";
-    private final static String HTTP = "http";
-    private static final String WEBSOCKET = "ws";
-    private static final String WEBSOCKET_SSL = "wss";
-
-    private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
-    private final static Charset UTF8 = Charset.forName("UTF-8");
-    public final static AttributeKey<Object> DEFAULT_ATTRIBUTE = new AttributeKey<Object>("default");
-
-    private final Bootstrap plainBootstrap;
-    private final Bootstrap secureBootstrap;
-    private final Bootstrap webSocketBootstrap;
-    private final Bootstrap secureWebSocketBootstrap;
-    private /* final */ EventLoopGroup eventLoop;
-    private final static int MAX_BUFFERED_BYTES = 8192;
-    private final AsyncHttpClientConfig config;
-    private final AtomicBoolean isClose = new AtomicBoolean(false);
-    private final Class<? extends SocketChannel> socketChannelFactory;
-    private final boolean allowReleaseSocketChannelFactory;
-
-    private final ChannelGroup openChannels = new
-            CleanupChannelGroup("asyncHttpClient") {
-                @Override
-                public boolean remove(Object o) {
-                    boolean removed = super.remove(o);
-                    if (removed && trackConnections) {
-                        freeConnections.release();
-                    }
-                    return removed;
-                }
-            };
-    private final ConnectionsPool<String, Channel> connectionsPool;
-    private Semaphore freeConnections = null;
-    private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
-    private boolean executeConnectAsync = true;
-    public static final ThreadLocal<Boolean> IN_IO_THREAD = new ThreadLocalBoolean();
-    private final boolean trackConnections;
-    private final boolean useRawUrl;
-    private final static NTLMEngine ntlmEngine = new NTLMEngine();
-    private static SpnegoEngine spnegoEngine = null;
-    private final Protocol httpProtocol = new HttpProtocol();
-    private final Protocol webSocketProtocol = new WebSocketProtocol();
-
-    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
-
-        if (config.getAsyncHttpProviderConfig() != null
-                && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
-            asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
-        } else {
-            asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
-        }
-
-        if (asyncHttpProviderConfig.isUseBlockingIO()) {
-            socketChannelFactory = OioSocketChannel.class;
-            this.allowReleaseSocketChannelFactory = true;
-        } else {
-            // check if external NioClientSocketChannelFactory is defined
-            Class<? extends SocketChannel> scf = asyncHttpProviderConfig.getSocketChannel();
-            if (scf != null) {
-            	this.socketChannelFactory = scf;
-
-            	// cannot allow releasing shared channel factory
-            	this.allowReleaseSocketChannelFactory = false;
-            } else {
-                socketChannelFactory = NioSocketChannel.class;
-                eventLoop = asyncHttpProviderConfig.getEventLoopGroup();
-                if (eventLoop == null) {
-                    if (socketChannelFactory == OioSocketChannel.class) {
-                        eventLoop = new OioEventLoopGroup();
-                    } else if (socketChannelFactory == NioSocketChannel.class) {
-                        eventLoop = new NioEventLoopGroup();
-                    } else {
-                        throw new IllegalArgumentException("No set event loop compatbile with socket channel " + scf);
-                    }
-                }
-            	int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
-            	log.debug("Number of application's worker threads is {}", numWorkers);
-            	this.allowReleaseSocketChannelFactory = true;
-            }
-        }
-        plainBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);
-        secureBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
-        webSocketBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
-        secureWebSocketBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
-        configureNetty();
-
-        this.config = config;
-
-        // This is dangerous as we can't catch a wrong typed ConnectionsPool
-        ConnectionsPool<String, Channel> cp = (ConnectionsPool<String, Channel>) config.getConnectionsPool();
-        if (cp == null && config.getAllowPoolingConnection()) {
-            cp = new NettyConnectionsPool(this);
-        } else if (cp == null) {
-            cp = new NonConnectionsPool();
-        }
-        this.connectionsPool = cp;
-
-        if (config.getMaxTotalConnections() != -1) {
-            trackConnections = true;
-            freeConnections = new Semaphore(config.getMaxTotalConnections());
-        } else {
-            trackConnections = false;
-        }
-
-        useRawUrl = config.isUseRawUrl();
-    }
-
-    @Override
-    public String toString() {
-        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",
-                config.getMaxTotalConnections() - freeConnections.availablePermits(),
-                openChannels.toString(),
-                connectionsPool.toString());
-    }
-
-    void configureNetty() {
-        Map<String, ChannelOption<Object>> optionMap = new HashMap<String, ChannelOption<Object>>();
-        for (Field field : ChannelOption.class.getDeclaredFields()) {
-            if (field.getType().isAssignableFrom(ChannelOption.class)) {
-                field.setAccessible(true);
-                try {
-                    optionMap.put(field.getName(), (ChannelOption<Object>) field.get(null));
-                } catch (IllegalAccessException ex) {
-                    throw new Error(ex);
-                }
-            }
-        }
-
-        if (asyncHttpProviderConfig != null) {
-            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                ChannelOption<Object> key = optionMap.get(entry.getKey());
-                Object value = entry.getValue();
-                plainBootstrap.option(key, value);
-                webSocketBootstrap.option(key, value);
-                secureBootstrap.option(key, value);
-                secureWebSocketBootstrap.option(key, value);
-            }
-        }
-
-        plainBootstrap.handler(createPlainPipelineFactory());
-        // DefaultChannelFuture.setUseDeadLockChecker(false);
-
-        if (asyncHttpProviderConfig != null) {
-            executeConnectAsync = asyncHttpProviderConfig.isAsyncConnect();
-            if (!executeConnectAsync) {
-                // DefaultChannelFuture.setUseDeadLockChecker(true);
-            }
-        }
-
-        webSocketBootstrap.handler(new ChannelInitializer() {
-            /* @Override */
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline();
-                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
-                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-            }
-        });
-    }
-
-    protected HttpClientCodec newHttpClientCodec() {
-        if (asyncHttpProviderConfig != null) {
-            return new HttpClientCodec(asyncHttpProviderConfig.getMaxInitialLineLength(), asyncHttpProviderConfig.getMaxHeaderSize(), asyncHttpProviderConfig.getMaxChunkSize(), false);
-
-        } else {
-            return new HttpClientCodec();
-        }
-    }
-
-    protected ChannelInitializer createPlainPipelineFactory() {
-        return new ChannelInitializer() {
-
-            /* @Override */
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline();
-
-                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
-
-                if (config.getRequestCompressionLevel() > 0) {
-                    pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
-                }
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-            }
-        };
-    }
-
-    void constructSSLPipeline(final NettyConnectListener<?> cl) {
-
-        secureBootstrap.handler(new ChannelInitializer() {
-            /* @Override */
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-            }
-        });
-
-        secureWebSocketBootstrap.handler(new ChannelInitializer() {
-
-            /* @Override */
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
-                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-            }
-        });
-    }
-
-    private Channel lookupInCache(URI uri, ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
-    	final Channel channel = connectionsPool.poll(connectionPoolKeyStrategy.getKey(uri));
-
-        if (channel != null) {
-            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
-
-            try {
-                // Always make sure the channel who got cached support the proper protocol. It could
-                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
-                // https.
-                return verifyChannelPipeline(channel, uri.getScheme());
-            } catch (Exception ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-        return null;
-    }
-
-    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
-        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
-        if (sslEngine == null) {
-            sslEngine = SslUtils.getSSLEngine();
-        }
-        return sslEngine;
-    }
-
-    private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
-
-        if (channel.pipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            channel.pipeline().remove(SSL_HANDLER);
-        } else if (channel.pipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            return channel;
-        } else if (channel.pipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.pipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-        }
-        return channel;
-    }
-
-    protected final <T> void writeRequest(final Channel channel,
-                                          final AsyncHttpClientConfig config,
-                                          final NettyResponseFuture<T> future,
-                                          final HttpRequest nettyRequest) {
-        try {
-            /**
-             * If the channel is dead because it was pooled and the remote server decided to close it,
-             * we just let it go and the closeChannel do it's work.
-             */
-            if (!channel.isOpen() || !channel.isActive()) {
-                return;
-            }
-
-            Body body = null;
-            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-                BodyGenerator bg = future.getRequest().getBodyGenerator();
-                if (bg != null) {
-                    // Netty issue with chunking.
-                    if (InputStreamBodyGenerator.class.isAssignableFrom(bg.getClass())) {
-                        InputStreamBodyGenerator.class.cast(bg).patchNettyChunkingIssue(true);
-                    }
-
-                    try {
-                        body = bg.createBody();
-                    } catch (IOException ex) {
-                        throw new IllegalStateException(ex);
-                    }
-                    long length = body.getContentLength();
-                    if (length >= 0) {
-                        nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, length);
-                    } else {
-                        nettyRequest.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
-                    }
-                } else {
-                    body = null;
-                }
-            }
-
-            if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
-
-                FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-                for (String s : future.getNettyRequest().headers().names()) {
-                    for (String header : future.getNettyRequest().headers().getAll(s)) {
-                        h.add(s, header);
-                    }
-                }
-
-                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(
-                        new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
-            }
-
-            // Leave it to true.
-            if (future.getAndSetWriteHeaders(true)) {
-                try {
-                    channel.write(nettyRequest).addListener(new ProgressListener(true, future.getAsyncHandler(), future));
-                } catch (Throwable cause) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        channel.close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-            }
-
-            if (future.getAndSetWriteBody(true)) {
-                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-
-                    if (future.getRequest().getFile() != null) {
-                        final File file = future.getRequest().getFile();
-                        long fileLength = 0;
-                        final RandomAccessFile raf = new RandomAccessFile(file, "r");
-
-                        try {
-                            fileLength = raf.length();
-
-                            ChannelFuture writeFuture;
-                            if (channel.pipeline().get(SslHandler.class) != null) {
-                                writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
-                            } else {
-                                final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
-                                writeFuture = channel.write(region);
-                            }
-                            writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future));
-                        } catch (IOException ex) {
-                            if (raf != null) {
-                                try {
-                                    raf.close();
-                                } catch (IOException e) {
-                                }
-                            }
-                            throw ex;
-                        }
-                    } else if (body != null || future.getRequest().getParts() != null) {
-                        /**
-                         * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                         */
-                        if (future.getRequest().getParts() != null) {
-                            String boundary = future.getNettyRequest().headers().get("Content-Type");
-                            String length = future.getNettyRequest().headers().get("Content-Length");
-                            body = new MultipartBody(future.getRequest().getParts(), boundary, length);
-                        }
-
-                        ChannelFuture writeFuture;
-                        if (channel.pipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
-                            BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
-                            writeFuture = channel.write(bodyFileRegion);
-                        } else {
-                            BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
-                            BodyGenerator bg = future.getRequest().getBodyGenerator();
-                                if (bg instanceof FeedableBodyGenerator) {
-                                    ((FeedableBodyGenerator)bg).setListener(new FeedListener() {
-                                        @Override public void onContentAdded() {
-                                            channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
-                                        }
-                                    });
-                                }
-                            writeFuture = channel.write(bodyChunkedInput);
-                        }
-
-                        final Body b = body;
-                        writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
-                            public void operationComplete(ChannelFuture cf) {
-                                try {
-                                    b.close();
-                                } catch (IOException e) {
-                                    log.warn("Failed to close request body: {}", e.getMessage(), e);
-                                }
-                                super.operationComplete(cf);
-                            }
-                        });
-                    }
-                }
-            }
-        } catch (Throwable ioe) {
-            try {
-                channel.close();
-            } catch (RuntimeException ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-
-        try {
-            future.touch();
-            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, future.getRequest());
-            if (requestTimeout != -1 && !future.isDone() && !future.isCancelled()) {
-                ReaperFuture reaperFuture = new ReaperFuture(future);
-                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, requestTimeout, TimeUnit.MILLISECONDS);
-                reaperFuture.setScheduledFuture(scheduledFuture);
-                future.setReaperFuture(reaperFuture);
-            }
-        } catch (RejectedExecutionException ex) {
-            abort(future, ex);
-        }
-
-    }
-
-    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
-                                                    boolean allowConnect, ByteBuf buffer, ProxyServer proxyServer) throws IOException {
-
-        String method = request.getMethod();
-        if (allowConnect && proxyServer != null && isSecure(uri)) {
-            method = HttpMethod.CONNECT.toString();
-        }
-        return construct(config, request, new HttpMethod(method), uri, buffer, proxyServer);
-    }
-
-    private static SpnegoEngine getSpnegoEngine() {
-        if(spnegoEngine == null)
-            spnegoEngine = new SpnegoEngine();
-        return spnegoEngine;
-    }
-
-    private static HttpRequest construct(AsyncHttpClientConfig config,
-                                         Request request,
-                                         HttpMethod m,
-                                         URI uri,
-                                         ByteBuf buffer,
-                                         ProxyServer proxyServer) throws IOException {
-
-        String host = AsyncHttpProviderUtils.getHost(uri);
-        boolean webSocket = isWebSocket(uri);
-
-        if (request.getVirtualHost() != null) {
-            host = request.getVirtualHost();
-        }
-
-        FullHttpRequest nettyRequest;
-        if (m.equals(HttpMethod.CONNECT)) {
-            nettyRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
-        } else {
-            String path = null;
-            if (proxyServer != null && !(isSecure(uri) && config.isUseRelativeURIsWithSSLProxies()))
-                path = uri.toString();
-            else if (uri.getRawQuery() != null)
-                path = uri.getRawPath() + "?" + uri.getRawQuery();
-            else
-                path = uri.getRawPath();
-            nettyRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, m, path);
-        }
-
-        if (webSocket) {
-            nettyRequest.headers().add(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
-            nettyRequest.headers().add(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
-            nettyRequest.headers().add("Origin", "http://" + uri.getHost() + ":"
-                    + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
-            nettyRequest.headers().add(WEBSOCKET_KEY, WebSocketUtil.getKey());
-            nettyRequest.headers().add("Sec-WebSocket-Version", "13");
-        }
-
-        if (host != null) {
-            if (uri.getPort() == -1) {
-                nettyRequest.headers().set(HttpHeaders.Names.HOST, host);
-            } else if (request.getVirtualHost() != null) {
-                nettyRequest.headers().set(HttpHeaders.Names.HOST, host);
-            } else {
-                nettyRequest.headers().set(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
-            }
-        } else {
-            host = "127.0.0.1";
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            FluentCaseInsensitiveStringsMap h = request.getHeaders();
-            if (h != null) {
-                for (String name : h.keySet()) {
-                    if (!"host".equalsIgnoreCase(name)) {
-                        for (String value : h.get(name)) {
-                            nettyRequest.headers().add(name, value);
-                        }
-                    }
-                }
-            }
-
-            if (config.isCompressionEnabled()) {
-                nettyRequest.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-            }
-        } else {
-            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-            if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM")) {
-                nettyRequest.headers().add(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
-            }
-        }
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-
-            String domain = realm.getNtlmDomain();
-            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
-                domain = proxyServer.getNtlmDomain();
-            }
-
-            String authHost = realm.getNtlmHost();
-            if (proxyServer != null && proxyServer.getHost() != null) {
-                host = proxyServer.getHost();
-            }
-
-            switch (realm.getAuthScheme()) {
-                case BASIC:
-                    nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(realm));
-                    break;
-                case DIGEST:
-                    if (isNonEmpty(realm.getNonce())) {
-                        try {
-                            nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION,
-                                    AuthenticatorUtils.computeDigestAuthentication(realm));
-                        } catch (NoSuchAlgorithmException e) {
-                            throw new SecurityException(e);
-                        }
-                    }
-                    break;
-                case NTLM:
-                    try {
-                        String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
-                        nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
-                    } catch (NTLMEngineException e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                    break;
-                case KERBEROS:
-                case SPNEGO:
-                    String challengeHeader = null;
-                    String server = proxyServer == null ? host : proxyServer.getHost();
-                    try {
-                        challengeHeader = getSpnegoEngine().generateToken(server);
-                    } catch (Throwable e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                    nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-                    break;
-                case NONE:
-                    break;
-                default:
-                    throw new IllegalStateException("Invalid Authentication " + realm);
-            }
-        }
-
-        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
-            nettyRequest.headers().set(HttpHeaders.Names.CONNECTION, AsyncHttpProviderUtils.keepAliveHeaderValue(config));
-        }
-
-        if (proxyServer != null) {
-            if (!request.getHeaders().containsKey("Proxy-Connection")) {
-                nettyRequest.headers().set("Proxy-Connection", AsyncHttpProviderUtils.keepAliveHeaderValue(config));
-            }
-
-            if (proxyServer.getPrincipal() != null) {
-                if (isNonEmpty(proxyServer.getNtlmDomain())) {
-
-                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-                    if (!(isNonEmpty(auth) && auth.get(0).startsWith("NTLM"))) {
-                        try {
-                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
-                                    proxyServer.getHost());
-                            nettyRequest.headers().set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
-                        } catch (NTLMEngineException e) {
-                            IOException ie = new IOException();
-                            ie.initCause(e);
-                            throw ie;
-                        }
-                    }
-                } else {
-                    nettyRequest.headers().set(HttpHeaders.Names.PROXY_AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(proxyServer));
-                }
-            }
-        }
-
-        // Add default accept headers.
-        if (request.getHeaders().getFirstValue("Accept") == null) {
-            nettyRequest.headers().set(HttpHeaders.Names.ACCEPT, "*/*");
-        }
-
-        if (request.getHeaders().getFirstValue("User-Agent") != null) {
-            nettyRequest.headers().set("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
-        } else if (config.getUserAgent() != null) {
-            nettyRequest.headers().set("User-Agent", config.getUserAgent());
-        } else {
-            nettyRequest.headers().set("User-Agent",
-                         AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class,
-                                                                   config));
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            if (isNonEmpty(request.getCookies())) {
-                CookieEncoder httpCookieEncoder = new CookieEncoder(false);
-                Iterator<Cookie> ic = request.getCookies().iterator();
-                Cookie c;
-                org.jboss.netty.handler.codec.http.Cookie cookie;
-                while (ic.hasNext()) {
-                    c = ic.next();
-                    cookie = new DefaultCookie(c.getName(), c.getValue());
-                    cookie.setPath(c.getPath());
-                    cookie.setMaxAge(c.getMaxAge());
-                    cookie.setDomain(c.getDomain());
-                    httpCookieEncoder.addCookie(cookie);
-                }
-                nettyRequest.headers().set(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
-            }
-
-            String reqType = request.getMethod();
-            if (!"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
-
-                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
-
-                // We already have processed the body.
-                if (buffer != null && buffer.writerIndex() != 0) {
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
-                    nettyRequest.setContent(buffer);
-                } else if (request.getByteData() != null) {
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
-                    nettyRequest.setContent(Unpooled.wrappedBuffer(request.getByteData()));
-                } else if (request.getStringData() != null) {
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
-                    nettyRequest.setContent(Unpooled.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
-                } else if (request.getStreamData() != null) {
-                    int[] lengthWrapper = new int[1];
-                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
-                    int length = lengthWrapper[0];
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-                    nettyRequest.setContent(Unpooled.wrappedBuffer(bytes, 0, length));
-                } else if (isNonEmpty(request.getParams())) {
-                    StringBuilder sb = new StringBuilder();
-                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
-                        final String key = paramEntry.getKey();
-                        for (final String value : paramEntry.getValue()) {
-                            if (sb.length() > 0) {
-                                sb.append("&");
-                            }
-                            UTF8UrlEncoder.appendEncoded(sb, key);
-                            sb.append("=");
-                            UTF8UrlEncoder.appendEncoded(sb, value);
-                        }
-                    }
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
-                    nettyRequest.setContent(Unpooled.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
-
-                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
-                        nettyRequest.headers().set(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
-                    }
-
-                } else if (request.getParts() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
-
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
-
-                    /**
-                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                     */
-
-                    if (isSecure(uri)) {
-                        ByteBuf b = Unpooled.buffer(lenght);
-                        mre.writeRequest(new ByteBufOutputStream(b));
-                        nettyRequest.setContent(b);
-                    }
-                } else if (request.getEntityWriter() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    ByteBuf b = Unpooled.buffer(lenght);
-                    request.getEntityWriter().writeEntity(new ByteBufOutputStream(b));
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
-                    nettyRequest.setContent(b);
-                } else if (request.getFile() != null) {
-                    File file = request.getFile();
-                    if (!file.isFile()) {
-                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
-                    }
-                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());
-                }
-            }
-        }
-        return nettyRequest;
-    }
-
-    public void close() {
-        isClose.set(true);
-        try {
-            connectionsPool.destroy();
-            openChannels.close();
-
-            for (Channel channel : openChannels) {
-                ChannelHandlerContext ctx = channel.pipeline().context(NettyAsyncHttpProvider.class);
-                if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof NettyResponseFuture<?>) {
-                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
-                    future.setReaperFuture(null);
-                }
-            }
-
-            config.executorService().shutdown();
-            config.reaper().shutdown();
-            if (this.allowReleaseSocketChannelFactory) {
-            	eventLoop.shutdown();
-            }
-        } catch (Throwable t) {
-            log.warn("Unexpected error on close", t);
-        }
-    }
-
-    /* @Override */
-
-    public Response prepareResponse(final HttpResponseStatus status,
-                                    final HttpResponseHeaders headers,
-                                    final List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(status, headers, bodyParts);
-    }
-
-    /* @Override */
-
-    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
-        return doConnect(request, asyncHandler, null, true, executeConnectAsync, false);
-    }
-
-    private <T> void execute(final Request request, final NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-        doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
-    }
-
-    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f,
-                                              boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-
-        if (isClose.get()) {
-            throw new IOException("Closed");
-        }
-
-        if (request.getUrl().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler)) {
-            throw new IOException("WebSocket method must be a GET");
-        }
-
-        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-        boolean useProxy = proxyServer != null;
-        URI uri;
-        if (useRawUrl) {
-            uri = request.getRawURI();
-        } else {
-            uri = request.getURI();
-        }
-        Channel channel = null;
-
-        if (useCache) {
-            if (f != null && f.reuseChannel() && f.channel() != null) {
-                channel = f.channel();
-            } else {
-                URI connectionKeyUri = useProxy? proxyServer.getURI() : uri;
-                channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
-            }
-        }
-
-        ByteBuf bufferedBytes = null;
-        if (f != null && f.getRequest().getFile() == null &&
-                !f.getNettyRequest().getMethod().name().equals(HttpMethod.CONNECT.name())) {
-            bufferedBytes = f.getNettyRequest().data();
-        }
-
-        boolean useSSl = isSecure(uri) && !useProxy;
-        if (channel != null && channel.isOpen() && channel.isActive()) {
-            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes, proxyServer);
-
-            if (f == null) {
-                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this, proxyServer);
-            } else {
-                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes, proxyServer);
-                f.setNettyRequest(nettyRequest);
-            }
-            f.setState(NettyResponseFuture.STATE.POOLED);
-            f.attachChannel(channel, false);
-
-            log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
-            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(DEFAULT_ATTRIBUTE).set(f);
-
-            try {
-                writeRequest(channel, config, f, nettyRequest);
-            } catch (Exception ex) {
-                log.debug("writeRequest failure", ex);
-                if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
-                    log.debug("SSLEngine failure", ex);
-                    f = null;
-                } else {
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("doConnect.writeRequest()", t);
-                    }
-                    IOException ioe = new IOException(ex.getMessage());
-                    ioe.initCause(ex);
-                    throw ioe;
-                }
-            }
-            return f;
-        }
-
-        // Do not throw an exception when we need an extra connection for a redirect.
-        if (!reclaimCache && !connectionsPool.canCacheConnection()) {
-            IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
-            try {
-                asyncHandler.onThrowable(ex);
-            } catch (Throwable t) {
-                log.warn("!connectionsPool.canCacheConnection()", t);
-            }
-            throw ex;
-        }
-
-        boolean acquiredConnection = false;
-
-        if (trackConnections) {
-            if (!reclaimCache) {
-                if (!freeConnections.tryAcquire()) {
-                    IOException ex = new IOException("Too many connections " +  config.getMaxTotalConnections());
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("!connectionsPool.canCacheConnection()", t);
-                    }
-                    throw ex;
-                } else {
-                    acquiredConnection = true;
-                }
-            }
-        }
-
-        NettyConnectListener<T> c = new NettyConnectListener.Builder<T>(config, request, asyncHandler, f, this, bufferedBytes).build(uri);
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
-
-        if (useSSl) {
-            constructSSLPipeline(c);
-        }
-
-        ChannelFuture channelFuture;
-        Bootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
-        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectionTimeoutInMs());
-
-        try {
-            InetSocketAddress remoteAddress;
-            if (request.getInetAddress() != null) {
-                remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
-            } else if (proxyServer == null || avoidProxy) {
-                remoteAddress = new InetSocketAddress(AsyncHttpProviderUtils.getHost(uri), AsyncHttpProviderUtils.getPort(uri));
-            } else {
-                remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
-            }
-
-            if(request.getLocalAddress() != null){
-                channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
-            }else{
-                channelFuture = bootstrap.connect(remoteAddress);
-            }
-
-        } catch (Throwable t) {
-            if (acquiredConnection) {
-                freeConnections.release();
-            }
-            abort(c.future(), t.getCause() == null ? t : t.getCause());
-            return c.future();
-        }
-
-        boolean directInvokation = true;
-        if (IN_IO_THREAD.get() && DefaultChannelFuture.isUseDeadLockChecker()) {
-            directInvokation = false;
-        }
-
-        if (directInvokation && !asyncConnect && request.getFile() == null) {
-            int timeOut = config.getConnectionTimeoutInMs() > 0 ? config.getConnectionTimeoutInMs() : Integer.MAX_VALUE;
-            if (!channelFuture.awaitUninterruptibly(timeOut, TimeUnit.MILLISECONDS)) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                channelFuture.cancel();
-                abort(c.future(), new ConnectException(String.format("Connect operation to %s timeout %s", uri, timeOut)));
-            }
-
-            try {
-                c.operationComplete(channelFuture);
-            } catch (Exception e) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                IOException ioe = new IOException(e.getMessage());
-                ioe.initCause(e);
-                try {
-                    asyncHandler.onThrowable(ioe);
-                } catch (Throwable t) {
-                    log.warn("c.operationComplete()", t);
-                }
-                throw ioe;
-            }
-        } else {
-            channelFuture.addListener(c);
-        }
-
-        log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
-
-        if (!c.future().isCancelled() || !c.future().isDone()) {
-            openChannels.add(channelFuture.channel());
-            c.future().attachChannel(channelFuture.channel(), false);
-        }
-        return c.future();
-    }
-
-    private void closeChannel(final ChannelHandlerContext ctx) {
-        connectionsPool.removeAll(ctx.channel());
-        finishChannel(ctx);
-    }
-
-    private void finishChannel(final ChannelHandlerContext ctx) {
-        ctx.attr(DEFAULT_ATTRIBUTE).set(new DiscardEvent());
-
-        // The channel may have already been removed if a timeout occurred, and this method may be called just after.
-        if (ctx.channel() == null) {
-            return;
-        }
-
-        log.debug("Closing Channel {} ", ctx.channel());
-
-
-        try {
-            ctx.channel().close();
-        } catch (Throwable t) {
-            log.debug("Error closing a connection", t);
-        }
-
-        if (ctx.channel() != null) {
-            openChannels.remove(ctx.channel());
-        }
-
-    }
-
-    @Override
-    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-        //call super to reset the read timeout
-        super.messageReceived(ctx, e);
-        IN_IO_THREAD.set(Boolean.TRUE);
-        if (ctx.getAttachment() == null) {
-            log.debug("ChannelHandlerContext wasn't having any attachment");
-        }
-
-        if (ctx.getAttachment() instanceof DiscardEvent) {
-            return;
-        } else if (ctx.getAttachment() instanceof AsyncCallable) {
-            if (e.getMessage() instanceof HttpChunk) {
-                HttpChunk chunk = (HttpChunk) e.getMessage();
-                if (chunk.isLast()) {
-                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                    ac.call();
-                } else {
-                    return;
-                }
-            } else {
-                AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                ac.call();
-            }
-            ctx.setAttachment(new DiscardEvent());
-            return;
-        } else if (!(ctx.getAttachment() instanceof NettyResponseFuture<?>)) {
-            try {
-                ctx.getChannel().close();
-            } catch (Throwable t) {
-                log.trace("Closing an orphan channel {}", ctx.getChannel());
-            }
-            return;
-        }
-
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.handle(ctx, e);
-    }
-
-    private Realm kerberosChallenge(List<String> proxyAuth,
-                                    Request request,
-                                    ProxyServer proxyServer,
-                                    FluentCaseInsensitiveStringsMap headers,
-                                    Realm realm,
-                                    NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        URI uri = request.getURI();
-        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
-        String server = proxyServer == null ? host : proxyServer.getHost();
-        try {
-            String challengeHeader = getSpnegoEngine().generateToken(server);
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-
-            Realm.RealmBuilder realmBuilder;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
-            }
-            return realmBuilder.setUri(uri.getRawPath())
-                    .setMethodName(request.getMethod())
-                    .setScheme(Realm.AuthScheme.KERBEROS)
-                    .build();
-        } catch (Throwable throwable) {
-            if (proxyAuth.contains("NTLM")) {
-                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-            }
-            abort(future, throwable);
-            return null;
-        }
-    }
-
-    private Realm ntlmChallenge(List<String> wwwAuth,
-                                Request request,
-                                ProxyServer proxyServer,
-                                FluentCaseInsensitiveStringsMap headers,
-                                Realm realm,
-                                NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        boolean useRealm = (proxyServer == null && realm != null);
-
-        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
-        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
-        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
-        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
-
-        Realm newRealm;
-        if (realm != null && !realm.isNtlmMessageType2Received()) {
-            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
-
-            URI uri = request.getURI();
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                    .setUri(uri.getRawPath())
-                    .setMethodName(request.getMethod())
-                    .setNtlmMessageType2Received(true)
-                    .build();
-            future.getAndSetAuth(false);
-        } else {
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-
-            if (wwwAuth.get(0).startsWith("NTLM ")) {
-                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-                String challengeHeader = ntlmEngine.generateType3Msg(principal, password,
-                        ntlmDomain, ntlmHost, serverChallenge);
-
-                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            }
-
-            Realm.RealmBuilder realmBuilder;
-            Realm.AuthScheme authScheme;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-                authScheme = realm.getAuthScheme();
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
-                authScheme = Realm.AuthScheme.NTLM;
-            }
-            newRealm = realmBuilder.setScheme(authScheme)
-                    .setUri(request.getURI().getPath())
-                    .setMethodName(request.getMethod())
-                    .build();
-        }
-
-        return newRealm;
-    }
-
-    private Realm ntlmProxyChallenge(List<String> wwwAuth,
-                                     Request request,
-                                     ProxyServer proxyServer,
-                                     FluentCaseInsensitiveStringsMap headers,
-                                     Realm realm,
-                                     NettyResponseFuture<?> future) throws NTLMEngineException {
-        future.getAndSetAuth(false);
-        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
-
-        if (wwwAuth.get(0).startsWith("NTLM ")) {
-            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(),
-                    proxyServer.getPassword(),
-                    proxyServer.getNtlmDomain(),
-                    proxyServer.getHost(),
-                    serverChallenge);
-            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-        }
-        Realm newRealm;
-        Realm.RealmBuilder realmBuilder;
-        if (realm != null) {
-            realmBuilder = new Realm.RealmBuilder().clone(realm);
-        } else {
-            realmBuilder = new Realm.RealmBuilder();
-        }
-        newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
-                .setUri(request.getURI().getPath())
-                .setMethodName(request.getMethod())
-                .build();
-
-        return newRealm;
-    }
-    
-    private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
-        URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
-        return future.getConnectionPoolKeyStrategy().getKey(uri);
-    }
-
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
-        ctx.setAttachment(new AsyncCallable(future) {
-            public Object call() throws Exception {
-                if (future.isKeepAlive() && ctx.channel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.channel())) {
-                    return null;
-                }
-
-                finishChannel(ctx);
-                return null;
-            }
-
-            @Override
-            public String toString() {
-                return "Draining task for channel " + ctx.channel();
-            }
-        });
-    }
-
-    private FilterContext handleIoException(FilterContext fc, NettyResponseFuture<?> future) {
-        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            } catch (FilterException efe) {
-                abort(future, efe);
-            }
-        }
-        return fc;
-    }
-
-    private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, HttpResponse response, ChannelHandlerContext ctx) throws IOException {
-        final Request newRequest = fc.getRequest();
-        future.setAsyncHandler(fc.getAsyncHandler());
-        future.setState(NettyResponseFuture.STATE.NEW);
-        future.touch();
-
-        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future);
-        nextRequest(newRequest, future);
-        return;
-    }
-
-    private List<String> getAuthorizationToken(List<Entry<String, String>> list, String headerAuth) {
-        ArrayList<String> l = new ArrayList<String>();
-        for (Entry<String, String> e : list) {
-            if (e.getKey().equalsIgnoreCase(headerAuth)) {
-                l.add(e.getValue().trim());
-            }
-        }
-        return l;
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future) throws IOException {
-        nextRequest(request, future, true);
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future, final boolean useCache) throws IOException {
-        execute(request, future, useCache, true, true);
-    }
-
-    private void abort(NettyResponseFuture<?> future, Throwable t) {
-        Channel channel = future.channel();
-        if (channel != null && openChannels.contains(channel)) {
-            closeChannel(channel.pipeline().context(NettyAsyncHttpProvider.class));
-            openChannels.remove(channel);
-        }
-
-        if (!future.isCancelled() && !future.isDone()) {
-            log.debug("Aborting Future {}\n", future);
-            log.debug(t.getMessage(), t);
-        }
-
-        future.abort(t);
-    }
-
-    private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOException, GeneralSecurityException {
-        if (p.get(HTTP_HANDLER) != null) {
-            p.remove(HTTP_HANDLER);
-        }
-
-        if (isSecure(scheme)) {
-            if (p.get(SSL_HANDLER) == null) {
-                p.addFirst(HTTP_HANDLER, newHttpClientCodec());
-                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-            } else {
-                p.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
-            }
-
-        } else {
-            p.addFirst(HTTP_HANDLER, newHttpClientCodec());
-        }
-    }
-
-    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-
-        if (isClose.get()) {
-            return;
-        }
-
-        connectionsPool.removeAll(ctx.getChannel());
-        try {
-            super.channelClosed(ctx, e);
-        } catch (Exception ex) {
-            log.trace("super.channelClosed", ex);
-        }
-
-        log.debug("Channel Closed: {} with attachment {}", e.getChannel(), ctx.getAttachment());
-
-        if (ctx.getAttachment() instanceof AsyncCallable) {
-            AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-            ctx.setAttachment(ac.future());
-            ac.call();
-            return;
-        }
-
-        if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-            NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-            future.touch();
-
-            if (config.getIOExceptionFilters().size() > 0) {
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                        .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                fc = handleIoException(fc, future);
-
-                if (fc.replayRequest() && !future.cannotBeReplay()) {
-                    replayRequest(future, fc, null, ctx);
-                    return;
-                }
-            }
-
-            Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-            p.onClose(ctx, e);
-
-            if (future != null && !future.isDone() && !future.isCancelled()) {
-                if (!remotelyClosed(ctx.getChannel(), future)) {
-                    abort(future, new IOException("Remotely Closed " + ctx.getChannel()));
-                }
-            } else {
-                closeChannel(ctx);
-            }
-        }
-    }
-
-    protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future) {
-
-        if (isClose.get()) {
-            return false;
-        }
-
-        connectionsPool.removeAll(channel);
-
-        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null
-                && NettyResponseFuture.class.isAssignableFrom(
-                channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
-            future = (NettyResponseFuture<?>)
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
-        }
-
-        if (future == null || future.cannotBeReplay()) {
-            log.debug("Unable to recover future {}\n", future);
-            return false;
-        }
-
-        future.setState(NettyResponseFuture.STATE.RECONNECTED);
-        future.getAndSetStatusReceived(false);
-
-        log.debug("Trying to recover request {}\n", future.getNettyRequest());
-
-        try {
-            nextRequest(future.getRequest(), future);
-            return true;
-        } catch (IOException iox) {
-            future.setState(NettyResponseFuture.STATE.CLOSED);
-            future.abort(iox);
-            log.error("Remotely Closed, unable to recover", iox);
-        }
-        return false;
-    }
-
-    private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx) throws MalformedURLException {
-        // We need to make sure everything is OK before adding the connection back to the pool.
-        try {
-            future.done(null);
-        } catch (Throwable t) {
-            // Never propagate exception once we know we are done.
-            log.debug(t.getMessage(), t);
-        }
-
-        if (!future.isKeepAlive() || !ctx.channel().isReadable()) {
-            closeChannel(ctx);
-        }
-    }
-
-    private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
-        if (lastValidChunk && future.isKeepAlive()) {
-            drainChannel(ctx, future);
-        } else {
-            if (future.isKeepAlive() && ctx.channel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.close())) {
-                markAsDone(future, ctx);
-                return;
-            }
-            finishChannel(ctx);
-        }
-        markAsDone(future, ctx);
-    }
-
-    private final boolean updateStatusAndInterrupt(AsyncHandler<?> handler, HttpResponseStatus c) throws Exception {
-        return handler.onStatusReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateHeadersAndInterrupt(AsyncHandler<?> handler, HttpResponseHeaders c) throws Exception {
-        return handler.onHeadersReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart c) throws Exception {
-        boolean state = handler.onBodyPartReceived(c) != STATE.CONTINUE;
-        if (c.closeUnderlyingConnection()) {
-            future.setKeepAlive(false);
-        }
-        return state;
-    }
-
-    //Simple marker for stopping publishing bytes.
-
-    final static class DiscardEvent {
-    }
-
-    @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
-            throws Exception {
-        Channel channel = ctx.channel();
-        Throwable cause = e.getCause();
-        NettyResponseFuture<?> future = null;
-
-        /** Issue 81
-        if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) {
-            return;
-        }
-        */
-        if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
-            return;
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("Unexpected I/O exception on channel {}", channel, cause);
-        }
-
-        try {
-
-            if (cause != null && ClosedChannelException.class.isAssignableFrom(cause.getClass())) {
-                return;
-            }
-
-            if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof NettyResponseFuture<?>) {
-                future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
-                future.attachChannel(null, false);
-                future.touch();
-
-                if (IOException.class.isAssignableFrom(cause.getClass())) {
-
-                    if (config.getIOExceptionFilters().size() > 0) {
-                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                                .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                        fc = handleIoException(fc, future);
-
-                        if (fc.replayRequest()) {
-                            replayRequest(future, fc, null, ctx);
-                            return;
-                        }
-                    } else {
-                        // Close the channel so the recovering can occurs.
-                        try {
-                            ctx.channel().close();
-                        } catch (Throwable t) {
-                            ; // Swallow.
-                        }
-                        return;
-                    }
-                }
-
-                if (abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
-                    log.debug("Trying to recover from dead Channel: {}", channel);
-                    return;
-                }
-            } else if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof AsyncCallable) {
-                future = ((AsyncCallable) ctx.attr(DEFAULT_ATTRIBUTE).get()).future();
-            }
-        } catch (Throwable t) {
-            cause = t;
-        }
-
-        if (future != null) {
-            try {
-                log.debug("Was unable to recover Future: {}", future);
-                abort(future, cause);
-            } catch (Throwable t) {
-                log.error(t.getMessage(), t);
-            }
-        }
-
-        Protocol p = (ctx.pipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.onError(ctx, e);
-
-        closeChannel(ctx);
-        ctx.sendUpstream(e);
-    }
-
-    protected static boolean abortOnConnectCloseException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl")
-                        && element.getMethodName().equals("checkConnect")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnDisconnectException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler")
-                        && element.getMethodName().equals("channelDisconnected")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnReadCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("read")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    protected static boolean abortOnWriteCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("write")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
-        int length = (int) request.getContentLength();
-        if (length == -1 && r.headers().get(HttpHeaders.Names.CONTENT_LENGTH) != null) {
-            length = Integer.valueOf(r.headers().get(HttpHeaders.Names.CONTENT_LENGTH));
-        }
-
-        if (length >= 0) {
-            r.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-        }
-        return length;
-    }
-
-    public static <T> NettyResponseFuture<T> newFuture(URI uri,
-                                                       Request request,
-                                                       AsyncHandler<T> asyncHandler,
-                                                       FullHttpRequest nettyRequest,
-                                                       AsyncHttpClientConfig config,
-                                                       NettyAsyncHttpProvider provider,
-                                                       ProxyServer proxyServer) {
-
-        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
-        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest, requestTimeout, config.getIdleConnectionTimeoutInMs(), provider, request.getConnectionPoolKeyStrategy(), proxyServer);
-
-        if (request.getHeaders().getFirstValue("Expect") != null
-                && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
-            f.getAndSetWriteBody(false);
-        }
-        return f;
-    }
-
-    private class ProgressListener implements ChannelFutureProgressListener {
-
-        private final boolean notifyHeaders;
-        private final AsyncHandler<?> asyncHandler;
-        private final NettyResponseFuture<?> future;
-
-        public ProgressListener(boolean notifyHeaders, AsyncHandler<?> asyncHandler, NettyResponseFuture<?> future) {
-            this.notifyHeaders = notifyHeaders;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-        }
-
-        public void operationComplete(ChannelFuture cf) {
-            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
-            // Let's retry a second time.
-            Throwable cause = cf.cause();
-            if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
-
-                if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        cf.channel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-
-                if (ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                        || abortOnReadCloseException(cause)
-                        || abortOnWriteCloseException(cause)) {
-
-                    if (log.isDebugEnabled()) {
-                        log.debug(cf.cause() == null ? "" : cf.cause().getMessage(), cf.cause());
-                    }
-
-                    try {
-                        cf.channel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                } else {
-                    future.abort(cause);
-                }
-                return;
-            }
-            future.touch();
-
-            /**
-             * We need to make sure we aren't in the middle of an authorization process before publishing events
-             * as we will re-publish again the same event after the authorization, causing unpredictable behavior.
-             */
-            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
-            boolean startPublishing = future.isInAuth()
-                    || realm == null
-                    || realm.getUsePreemptiveAuth() == true;
-
-            if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                if (notifyHeaders) {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
-                } else {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
-                }
-            }
-        }
-
-        public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
-            future.touch();
-            if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
-            }
-        }
-    }
-
-    /**
-     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run
-     * them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future
-     * this wrapper will release the references to the channel and the nettyResponseFuture immediately. Otherwise,
-     * the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
-     */
-    private final class ReaperFuture implements Future, Runnable {
-        private Future scheduledFuture;
-        private NettyResponseFuture<?> nettyResponseFuture;
-
-        public ReaperFuture(NettyResponseFuture<?> nettyResponseFuture) {
-            this.nettyResponseFuture = nettyResponseFuture;
-        }
-
-        public void setScheduledFuture(Future scheduledFuture) {
-            this.scheduledFuture = scheduledFuture;
-        }
-
-        /**
-         * @Override
-         */
-        public boolean cancel(boolean mayInterruptIfRunning) {
-            nettyResponseFuture = null;
-            return scheduledFuture.cancel(mayInterruptIfRunning);
-        }
-
-        /**
-         * @Override
-         */
-        public Object get() throws InterruptedException, ExecutionException {
-            return scheduledFuture.get();
-        }
-
-        /**
-         * @Override
-         */
-        public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-            return scheduledFuture.get(timeout, unit);
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isCancelled() {
-            return scheduledFuture.isCancelled();
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isDone() {
-            return scheduledFuture.isDone();
-        }
-
-        /**
-         * @Override
-         */
-        public synchronized void run() {
-            if (isClose.get()) {
-                cancel(true);
-                return;
-            }
-
-            if (nettyResponseFuture != null && nettyResponseFuture.hasExpired()
-                    && !nettyResponseFuture.isDone() && !nettyResponseFuture.isCancelled()) {
-                log.debug("Request Timeout expired for {}\n", nettyResponseFuture);
-
-                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, nettyResponseFuture.getRequest());
-
-                abort(nettyResponseFuture, new TimeoutException("No response received after " + requestTimeout));
-
-                nettyResponseFuture = null;
-            }
-
-            if (nettyResponseFuture == null || nettyResponseFuture.isDone() || nettyResponseFuture.isCancelled()) {
-                cancel(true);
-            }
-        }
-    }
-
-    private abstract class AsyncCallable implements Callable<Object> {
-
-        private final NettyResponseFuture<?> future;
-
-        public AsyncCallable(NettyResponseFuture<?> future) {
-            this.future = future;
-        }
-
-        abstract public Object call() throws Exception;
-
-        public NettyResponseFuture<?> future() {
-            return future;
-        }
-    }
-
-    public static class ThreadLocalBoolean extends ThreadLocal<Boolean> {
-
-        private final boolean defaultValue;
-
-        public ThreadLocalBoolean() {
-            this(false);
-        }
-
-        public ThreadLocalBoolean(boolean defaultValue) {
-            this.defaultValue = defaultValue;
-        }
-
-        @Override
-        protected Boolean initialValue() {
-            return defaultValue ? Boolean.TRUE : Boolean.FALSE;
-        }
-    }
-
-    public static class OptimizedFileRegion extends AbstractReferenceCounted implements FileRegion {
-
-        private final FileChannel file;
-        private final RandomAccessFile raf;
-        private final long position;
-        private final long count;
-        private long byteWritten;
-
-        public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
-            this.raf = raf;
-            this.file = raf.getChannel();
-            this.position = position;
-            this.count = count;
-        }
-
-        public long position() {
-            return position;
-        }
-
-        public long count() {
-            return count;
-        }
-
-        public long transferTo(WritableByteChannel target, long position) throws IOException {
-            long count = this.count - position;
-            if (count < 0 || position < 0) {
-                throw new IllegalArgumentException(
-                        "position out of range: " + position +
-                                " (expected: 0 - " + (this.count - 1) + ")");
-            }
-            if (count == 0) {
-                return 0L;
-            }
-
-            long bw = file.transferTo(this.position + position, count, target);
-            byteWritten += bw;
-            if (byteWritten == raf.length()) {
-                deallocate();
-            }
-            return bw;
-        }
-
-        public void deallocate() {
-            try {
-                file.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-
-            try {
-                raf.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-        }
-    }
-
-    private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
-
-        private final ByteBuf content;
-        private final FileInputStream file;
-        private int byteRead = 0;
-
-        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ByteBuf content, File file) throws IOException {
-            super(headers);
-            this.content = content;
-            if (file != null) {
-                this.file = new FileInputStream(file);
-            } else {
-                this.file = null;
-            }
-        }
-
-        @Override
-        public void getBytes(byte[] bytes) {
-            if (content.writableBytes() != 0) {
-                content.getBytes(byteRead, bytes);
-                byteRead += bytes.length;
-            } else if (file != null) {
-                try {
-                    byteRead += file.read(bytes);
-                } catch (IOException e) {
-                    log.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    protected AsyncHttpClientConfig getConfig() {
-        return config;
-    }
-
-    private static class NonConnectionsPool implements ConnectionsPool<String, Channel> {
-
-        public boolean offer(String uri, Channel connection) {
-            return false;
-        }
-
-        public Channel poll(String uri) {
-            return null;
-        }
-
-        public boolean removeAll(Channel connection) {
-            return false;
-        }
-
-        public boolean canCacheConnection() {
-            return true;
-        }
-
-        public void destroy() {
-        }
-    }
-
-    private static final boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-        if (request.getMethod() != "GET" || !WebSocketUpgradeHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-            return false;
-        }
-        return true;
-    }
-
-    private boolean redirect(Request request,
-                             NettyResponseFuture<?> future,
-                             HttpResponse response,
-                             final ChannelHandlerContext ctx) throws Exception {
-
-        int statusCode = response.getStatus().code();
-        boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
-        if (redirectEnabled && (statusCode == 302
-                || statusCode == 301
-                || statusCode == 303
-                || statusCode == 307)) {
-
-            if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
-                // We must allow 401 handling again.
-                future.getAndSetAuth(false);
-
-                String location = response.headers().get(HttpHeaders.Names.LOCATION);
-                URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
-                boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
-                if (!uri.toString().equals(future.getURI().toString())) {
-                    final RequestBuilder nBuilder = stripQueryString ?
-                            new RequestBuilder(future.getRequest()).setQueryParameters(null)
-                            : new RequestBuilder(future.getRequest());
-
-                    if (!(statusCode < 302 || statusCode > 303)
-                            && !(statusCode == 302
-                            && config.isStrict302Handling())) {
-                        nBuilder.setMethod("GET");
-                    }
-                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
-                    final String initialPoolKey = getPoolKey(future);
-                    future.setURI(uri);
-                    String newUrl = uri.toString();
-                    if (request.getUrl().startsWith(WEBSOCKET)) {
-                        newUrl = newUrl.replace(HTTP, WEBSOCKET);
-                    }
-
-                    log.debug("Redirecting to {}", newUrl);
-                    for (String cookieStr : future.getHttpResponse().headers().getAll(HttpHeaders.Names.SET_COOKIE)) {
-                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
-                        nBuilder.addOrReplaceCookie(c);
-                    }
-
-                    for (String cookieStr : future.getHttpResponse().headers().getAll(HttpHeaders.Names.SET_COOKIE2)) {
-                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
-                        nBuilder.addOrReplaceCookie(c);
-                    }
-
-                    AsyncCallable ac = new AsyncCallable(future) {
-                        public Object call() throws Exception {
-                            if (initialConnectionKeepAlive && ctx.channel().isReadable() && connectionsPool.offer(initialPoolKey, ctx.channel())) {
-                                return null;
-                            }
-                            finishChannel(ctx);
-                            return null;
-                        }
-                    };
-
-                    if (response.isChunked()) {
-                        // We must make sure there is no bytes left before executing the next request.
-                        ctx.attr(DEFAULT_ATTRIBUTE).set(ac);
-                    } else {
-                        ac.call();
-                    }
-                    nextRequest(nBuilder.setUrl(newUrl).build(), future);
-                    return true;
-                }
-            } else {
-                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-            }
-        }
-        return false;
-    }
-
-    private final class HttpProtocol implements Protocol<HttpObject> {
-        // @Override
-        public void handle(final ChannelHandlerContext ctx, final HttpObject e) throws Exception {
-            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
-            future.touch();
-
-            // The connect timeout occured.
-            if (future.isCancelled() || future.isDone()) {
-                finishChannel(ctx);
-                return;
-            }
-
-            HttpRequest nettyRequest = future.getNettyRequest();
-            AsyncHandler handler = future.getAsyncHandler();
-            Request request = future.getRequest();
-            ProxyServer proxyServer = future.getProxyServer();
-            HttpResponse response = null;
-            try {
-                if (e instanceof FullHttpResponse) {
-                    response = (FullHttpResponse) e;
-
-                    log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
-
-                    // Required if there is some trailing headers.
-                    future.setHttpResponse(response);
-
-                    int statusCode = response.getStatus().code();
-
-                    String ka = response.headers().get(HttpHeaders.Names.CONNECTION);
-                    future.setKeepAlive(ka == null || ! ka.toLowerCase().equals("close"));
-
-                    List<String> wwwAuth = getAuthorizationToken(response.headers(), HttpHeaders.Names.WWW_AUTHENTICATE);
-                    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-                    HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    FilterContext fc = new FilterContext.FilterContextBuilder()
-                            .asyncHandler(handler)
-                            .request(request)
-                            .responseStatus(status)
-                            .responseHeaders(responseHeaders)
-                            .build();
-
-                    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                        try {
-                            fc = asyncFilter.filter(fc);
-                            if (fc == null) {
-                                throw new NullPointerException("FilterContext is null");
-                            }
-                        } catch (FilterException efe) {
-                            abort(future, efe);
-                        }
-                    }
-
-                    // The handler may have been wrapped.
-                    handler = fc.getAsyncHandler();
-                    future.setAsyncHandler(handler);
-
-                    // The request has changed
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-
-                    Realm newRealm = null;
-                    final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
-                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
-
-                    //if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
-                    //    builder.setUrl(future.getURI().toString());
-                    //}
-
-                    if (statusCode == 401
-                            && realm != null
-                            && wwwAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-                        // NTLM
-                        if (!wwwAuth.contains("Kerberos") && (wwwAuth.contains("NTLM") || (wwwAuth.contains("Negotiate")))) {
-                            newRealm = ntlmChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (wwwAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
-                        } else {
-                            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                                    .setUri(request.getURI().getPath())
-                                    .setMethodName(request.getMethod())
-                                    .setUsePreemptiveAuth(true)
-                                    .parseWWWAuthenticateHeader(wwwAuth.get(0))
-                                    .build();
-                        }
-
-                        final Realm nr = new Realm.RealmBuilder().clone(newRealm)
-                                .setUri(URI.create(request.getUrl()).getPath()).build();
-
-                        log.debug("Sending authentication to {}", request.getUrl());
-                        AsyncCallable ac = new AsyncCallable(future) {
-                            public Object call() throws Exception {
-                                drainChannel(ctx, future);
-                                nextRequest(builder.headers().sets(headers).setRealm(nr).build(), future);
-                                return null;
-                            }
-                        };
-
-                        if (future.isKeepAlive() && response.isChunked()) {
-                            // We must make sure there is no bytes left before executing the next request.
-                            ctx.attr(DEFAULT_ATTRIBUTE).set(ac);
-                        } else {
-                            ac.call();
-                        }
-                        return;
-                    }
-
-                    if (statusCode == 100) {
-                        future.getAndSetWriteHeaders(false);
-                        future.getAndSetWriteBody(true);
-                        writeRequest(ctx.c, config, future, nettyRequest);
-                        return;
-                    }
-
-                    List<String> proxyAuth = getAuthorizationToken(response.headers(), HttpHeaders.Names.PROXY_AUTHENTICATE);
-                    if (statusCode == 407
-                            && realm != null
-                            && proxyAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
-
-                        log.debug("Sending proxy authentication to {}", request.getUrl());
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-
-                        if (!proxyAuth.contains("Kerberos") && (proxyAuth.get(0).contains("NTLM") || (proxyAuth.contains("Negotiate")))) {
-                            newRealm = ntlmProxyChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (proxyAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
-                        } else {
-                            newRealm = future.getRequest().getRealm();
-                        }
-
-                        Request req = builder.headers().sets(headers).setRealm(newRealm).build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(true);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)
-                            && statusCode == 200) {
-
-                        log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
-
-                        if (future.isKeepAlive()) {
-                            future.attachChannel(ctx.channel(), true);
-                        }
-
-                        try {
-                            log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
-                            upgradeProtocol(ctx.channel().pipeline(), request.getURI().getScheme());
-                        } catch (Throwable ex) {
-                            abort(future, ex);
-                        }
-                        Request req = builder.build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(false);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (redirect(request, future, response, ctx)) return;
-
-                    if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (updateHeadersAndInterrupt(handler, responseHeaders)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (!response.isChunked()) {
-                        if (response.getContent().readableBytes() != 0) {
-                            updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        }
-                        finishUpdate(future, ctx, false);
-                        return;
-                    }
-
-                    if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
-                        updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        markAsDone(future, ctx);
-                        drainChannel(ctx, future);
-                    }
-
-                } else if (e.getMessage() instanceof HttpContent) {
-                    HttpContent chunk = (HttpContent) e.getMessage();
-
-                    if (handler != null) {
-                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler,
-                                new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
-                            if (chunk instanceof DefaultHttpChunkTrailer) {
-                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(),
-                                        future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
-                            }
-                            finishUpdate(future, ctx, !chunk.isLast());
-                        }
-                    }
-                }
-            } catch (Exception t) {
-                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                            .request(future.getRequest()).ioException(IOException.class.cast(t)).build();
-                    fc = handleIoException(fc, future);
-
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-                }
-
-                try {
-                    abort(future, t);
-                } finally {
-                    finishUpdate(future, ctx, false);
-                    throw t;
-                }
-            }
-        }
-
-        // @Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-        }
-
-        // @Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-        }
-    }
-
-    private final class WebSocketProtocol implements Protocol {
-        private static final byte OPCODE_TEXT = 0x1;
-        private static final byte OPCODE_BINARY = 0x2;
-        private static final byte OPCODE_UNKNOWN = -1;
-
-    	   protected byte pendingOpcode = OPCODE_UNKNOWN;
- 
-        // @Override
-        public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-            NettyResponseFuture<?> future = NettyResponseFuture.class.cast(ctx.getAttachment());
-            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-            Request request = future.getRequest();
-
-            if (e.getMessage() instanceof HttpResponse) {
-                HttpResponse response = (HttpResponse) e.getMessage();
-
-                HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                FilterContext fc = new FilterContext.FilterContextBuilder()
-                        .asyncHandler(h)
-                        .request(request)
-                        .responseStatus(s)
-                        .responseHeaders(responseHeaders)
-                        .build();
-                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                    try {
-                        fc = asyncFilter.filter(fc);
-                        if (fc == null) {
-                            throw new NullPointerException("FilterContext is null");
-                        }
-                    } catch (FilterException efe) {
-                        abort(future, efe);
-                    }
-
-                }
-
-                // The handler may have been wrapped.
-                future.setAsyncHandler(fc.getAsyncHandler());
-
-                // The request has changed
-                if (fc.replayRequest()) {
-                    replayRequest(future, fc, response, ctx);
-                    return;
-                }
-
-                future.setHttpResponse(response);
-                if (redirect(request, future, response, ctx)) return;
-
-                final org.jboss.netty.handler.codec.http.HttpResponseStatus status =
-                        new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
-
-                final boolean validStatus = response.getStatus().equals(status);
-                final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
-                String c = response.getHeader(HttpHeaders.Names.CONNECTION);
-                if (c == null) {
-                    c = response.getHeader("connection");
-                }
-
-                final boolean validConnection = c == null ? false : c.equalsIgnoreCase(HttpHeaders.Values.UPGRADE);
-
-                s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                final boolean statusReceived = h.onStatusReceived(s) == STATE.UPGRADE;
-
-                if (!statusReceived) {
-                    h.onClose(new NettyWebSocket(ctx.getChannel()), 1002, "Bad response status " + response.getStatus().getCode());
-                    future.done(null);
-                    return;
-                }
-
-                if (!validStatus || !validUpgrade || !validConnection) {
-                    throw new IOException("Invalid handshake response");
-                }
-
-                String accept = response.getHeader("Sec-WebSocket-Accept");
-                String key = WebSocketUtil.getAcceptKey(future.getNettyRequest().getHeader(WEBSOCKET_KEY));
-                if (accept == null || !accept.equals(key)) {
-                    throw new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key));
-                }
-
-                ctx.getPipeline().replace("ws-decoder", "ws-decoder", new WebSocket08FrameDecoder(false, false));
-                ctx.getPipeline().replace("ws-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
-                if (h.onHeadersReceived(responseHeaders) == STATE.CONTINUE) {
-                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
-                }
-                future.done(null);
-            } else if (e.getMessage() instanceof WebSocketFrame) {
-                final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
-
-                if(frame instanceof TextWebSocketFrame) {
-                	pendingOpcode = OPCODE_TEXT;
-                }
-                else if(frame instanceof BinaryWebSocketFrame) {
-                	pendingOpcode = OPCODE_BINARY;
-                }
-                
-                HttpChunk webSocketChunk = new HttpChunk() {
-                    private ChannelBuffer content;
-
-                    // @Override
-                    public boolean isLast() {
-                        return false;
-                    }
-
-                    // @Override
-                    public ChannelBuffer getContent() {
-                        return content;
-                    }
-
-                    // @Override
-                    public void setContent(ChannelBuffer content) {
-                        this.content = content;
-                    }
-                };
-
-                if (frame.getBinaryData() != null) {
-                    webSocketChunk.setContent(Unpooled.wrappedBuffer(frame.getBinaryData()));
-                    ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
-                    h.onBodyPartReceived(rp);
-
-                    NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-                   
-                    if(pendingOpcode == OPCODE_BINARY) {
-                        webSocket.onBinaryFragment(rp.getBodyPartBytes(),frame.isFinalFragment());
-                    }
-                    else {
-                        webSocket.onTextFragment(frame.getBinaryData().toString(UTF8),frame.isFinalFragment());
-                    }
-
-                    if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
-                        try {
-                            webSocket.onClose(CloseWebSocketFrame.class.cast(frame).getStatusCode(), CloseWebSocketFrame.class.cast(frame).getReasonText());
-                        } catch (Throwable t) {
-                            // Swallow any exception that may comes from a Netty version released before 3.4.0
-                            log.trace("", t);
-                        }
-                    }
-                }
-            } else {
-                log.error("Invalid attachment {}", ctx.getAttachment());
-            }
-        }
-
-        //@Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-            try {
-                log.warn("onError {}", e);
-                if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                    return;
-                }
-
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-                webSocket.onError(e.getCause());
-                webSocket.close();
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-
-        //@Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-            log.trace("onClose {}", e);
-            if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                return;
-            }
-
-            try {
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-
-                webSocket.close();
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-    }
-
-    private static boolean isWebSocket(URI uri) {
-        return WEBSOCKET.equalsIgnoreCase(uri.getScheme()) || WEBSOCKET_SSL.equalsIgnoreCase(uri.getScheme());
-    }
-
-    private static boolean isSecure(String scheme) {
-        return HTTPS.equalsIgnoreCase(scheme) || WEBSOCKET_SSL.equalsIgnoreCase(scheme);
-    }
-
-    private static boolean isSecure(URI uri) {
-        return isSecure(uri.getScheme());
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java
deleted file mode 100644
index 86beea686..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.providers.netty_4;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-
-/**
- * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
- */
-public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProviderConfig.class);
-
-    /**
-     * Use Netty's blocking IO stategy.
-     */
-    private boolean useBlockingIO;
-
-    /**
-     * Allow configuring the Netty's event loop.
-     */
-    private EventLoopGroup eventLoopGroup;
-
-    /**
-     * Allow configuring the Netty's used socket channel.
-     */
-    private Class<? extends SocketChannel> socketChannel;
-
-    /**
-     * Execute the connect operation asynchronously.
-     */
-    private boolean asyncConnect;
-
-    /**
-     * HttpClientCodec's maxInitialLineLength
-     */
-    private int maxInitialLineLength = 4096;
-
-    /**
-     * HttpClientCodec's maxHeaderSize
-     */
-    private int maxHeaderSize = 8192;
-
-    /**
-     * HttpClientCodec's maxChunkSize
-     */
-    private int maxChunkSize = 8192;
-
-    /**
-     * Use direct {@link java.nio.ByteBuffer}
-     */
-    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
-
-    /**
-     * Allow nested request from any {@link org.asynchttpclient.AsyncHandler}
-     */
-    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
-
-    /**
-     * See {@link java.net.Socket#setReuseAddress(boolean)}
-     */
-    public final static String REUSE_ADDRESS = ChannelOption.SO_REUSEADDR.name();
-
-    private final Map<String, Object> properties = new HashMap<String, Object>();
-
-    public NettyAsyncHttpProviderConfig() {
-        properties.put(REUSE_ADDRESS, Boolean.FALSE);
-    }
-
-    /**
-     * Add a property that will be used when the AsyncHttpClient initialize its {@link org.asynchttpclient.AsyncHttpProvider}
-     * 
-     * @param name
-     *            the name of the property
-     * @param value
-     *            the value of the property
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
-
-        if (name.equals(REUSE_ADDRESS) && value == Boolean.TRUE && System.getProperty("os.name").toLowerCase().contains("win")) {
-            LOGGER.warn("Can't enable {} on Windows", REUSE_ADDRESS);
-        } else {
-            properties.put(name, value);
-        }
-
-        return this;
-    }
-
-    /**
-     * Return the value associated with the property's name
-     * 
-     * @param name
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public Object getProperty(String name) {
-        return properties.get(name);
-    }
-
-    /**
-     * Remove the value associated with the property's name
-     * 
-     * @param name
-     * @return true if removed
-     */
-    public Object removeProperty(String name) {
-        return properties.remove(name);
-    }
-
-    /**
-     * Return the curent entry set.
-     * 
-     * @return a the curent entry set.
-     */
-    public Set<Map.Entry<String, Object>> propertiesSet() {
-        return properties.entrySet();
-    }
-
-    public boolean isUseBlockingIO() {
-        return useBlockingIO;
-    }
-
-    public void setUseBlockingIO(boolean useBlockingIO) {
-        this.useBlockingIO = useBlockingIO;
-    }
-
-    public Class<? extends SocketChannel> getSocketChannel() {
-        return socketChannel;
-    }
-
-    public void setSocketChannel(Class<? extends SocketChannel> socketChannel) {
-        this.socketChannel = socketChannel;
-    }
-
-    public EventLoopGroup getEventLoopGroup() {
-        return eventLoopGroup;
-    }
-
-    public void setEventLoopGroup(EventLoopGroup eventLoopGroup) {
-        this.eventLoopGroup = eventLoopGroup;
-    }
-
-    public boolean isAsyncConnect() {
-        return asyncConnect;
-    }
-
-    public void setAsyncConnect(boolean asyncConnect) {
-        this.asyncConnect = asyncConnect;
-    }
-
-    public int getMaxInitialLineLength() {
-        return maxInitialLineLength;
-    }
-
-    public void setMaxInitialLineLength(int maxInitialLineLength) {
-        this.maxInitialLineLength = maxInitialLineLength;
-    }
-
-    public int getMaxHeaderSize() {
-        return maxHeaderSize;
-    }
-
-    public void setMaxHeaderSize(int maxHeaderSize) {
-        this.maxHeaderSize = maxHeaderSize;
-    }
-
-    public int getMaxChunkSize() {
-        return maxChunkSize;
-    }
-
-    public void setMaxChunkSize(int maxChunkSize) {
-        this.maxChunkSize = maxChunkSize;
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java
deleted file mode 100644
index 6a634de9e..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.providers.netty_4;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.net.ssl.HostnameVerifier;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.ssl.SslHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.util.ProxyUtils;
-
-
-/**
- * Non Blocking connect.
- */
-final class NettyConnectListener<T> implements ChannelFutureListener {
-    private final static Logger logger = LoggerFactory.getLogger(NettyConnectListener.class);
-    private final AsyncHttpClientConfig config;
-    private final NettyResponseFuture<T> future;
-    private final HttpRequest nettyRequest;
-    private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
-
-    private NettyConnectListener(AsyncHttpClientConfig config,
-                                 NettyResponseFuture<T> future,
-                                 HttpRequest nettyRequest) {
-        this.config = config;
-        this.future = future;
-        this.nettyRequest = nettyRequest;
-    }
-
-    public NettyResponseFuture<T> future() {
-        return future;
-    }
-
-    public final void operationComplete(ChannelFuture f) throws Exception {
-        if (f.isSuccess()) {
-            Channel channel = f.channel();
-            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(future);
-            SslHandler sslHandler = (SslHandler) channel.pipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
-            if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
-                ((SslHandler) channel.pipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
-                return;
-            }
-
-            HostnameVerifier v = config.getHostnameVerifier();
-            if (sslHandler != null) {
-                if (!v.verify(future.getURI().getHost(), sslHandler.engine().getSession())) {
-                	ConnectException exception = new ConnectException("HostnameVerifier exception.");
-                	future.abort(exception);
-                	throw exception;
-                }
-            }
-
-            future.provider().writeRequest(f.channel(), config, future, nettyRequest);
-        } else {
-            Throwable cause = f.cause();
-
-            logger.debug("Trying to recover a dead cached channel {} with a retry value of {} ", f.channel(), future.canRetry());
-            if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
-                    || ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                    || future.getState() != NettyResponseFuture.STATE.NEW)) {
-
-                logger.debug("Retrying {} ", nettyRequest);
-                if (future.provider().remotelyClosed(f.channel(), future)) {
-                    return;
-                }
-            }
-
-            logger.debug("Failed to recover from exception: {} with channel {}", cause, f.channel());
-
-            boolean printCause = f.cause() != null && cause.getMessage() != null;
-            ConnectException e = new ConnectException(printCause ? cause.getMessage() + " to " + future.getURI().toString() : future.getURI().toString());
-            if (cause != null) {
-                e.initCause(cause);
-            }
-            future.abort(e);
-        }
-    }
-
-    public static class Builder<T> {
-        private final AsyncHttpClientConfig config;
-
-        private final Request request;
-        private final AsyncHandler<T> asyncHandler;
-        private NettyResponseFuture<T> future;
-        private final NettyAsyncHttpProvider provider;
-        private final ByteBuf buffer;
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyAsyncHttpProvider provider, ByteBuf buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = null;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyResponseFuture<T> future, NettyAsyncHttpProvider provider, ByteBuf buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public NettyConnectListener<T> build(final URI uri) throws IOException {
-            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer, proxyServer);
-            if (future == null) {
-                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider, proxyServer);
-            } else {
-                future.setNettyRequest(nettyRequest);
-                future.setRequest(request);
-            }
-            return new NettyConnectListener<T>(config, future, nettyRequest);
-        }
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java
deleted file mode 100644
index 6b21e4911..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.ConnectionsPool;
-import io.netty.channel.Channel;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * A simple implementation of {@link org.asynchttpclient.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
- */
-public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
-
-    private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
-    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
-    private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
-    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-    private final Timer idleConnectionDetector = new Timer(true);
-    private final boolean sslConnectionPoolEnabled;
-    private final int maxTotalConnections;
-    private final int maxConnectionPerHost;
-    private final int maxConnectionLifeTimeInMs;
-    private final long maxIdleTime;
-
-    public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
-        this.maxTotalConnections = provider.getConfig().getMaxTotalConnections();
-        this.maxConnectionPerHost = provider.getConfig().getMaxConnectionPerHost();
-        this.sslConnectionPoolEnabled = provider.getConfig().isSslConnectionPoolEnabled();
-        this.maxIdleTime = provider.getConfig().getIdleConnectionInPoolTimeoutInMs();
-        this.maxConnectionLifeTimeInMs = provider.getConfig().getMaxConnectionLifeTimeInMs();
-        this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
-    }
-
-    private static class IdleChannel {
-        final String uri;
-        final Channel channel;
-        final long start;
-
-        IdleChannel(String uri, Channel channel) {
-            this.uri = uri;
-            this.channel = channel;
-            this.start = System.currentTimeMillis();
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof IdleChannel)) return false;
-
-            IdleChannel that = (IdleChannel) o;
-
-            if (channel != null ? !channel.equals(that.channel) : that.channel != null) return false;
-
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            return channel != null ? channel.hashCode() : 0;
-        }
-    }
-
-    private class IdleChannelDetector extends TimerTask {
-        @Override
-        public void run() {
-            try {
-                if (isClosed.get()) return;
-
-                if (log.isDebugEnabled()) {
-                    Set<String> keys = connectionsPool.keySet();
-
-                    for (String s : keys) {
-                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
-                    }
-                }
-
-                List<IdleChannel> channelsInTimeout = new ArrayList<IdleChannel>();
-                long currentTime = System.currentTimeMillis();
-
-                for (IdleChannel idleChannel : channel2IdleChannel.values()) {
-                    long age = currentTime - idleChannel.start;
-                    if (age > maxIdleTime) {
-
-                        log.debug("Adding Candidate Idle Channel {}", idleChannel.channel);
-
-                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
-                        channelsInTimeout.add(idleChannel);
-                    }
-                }
-                long endConcurrentLoop = System.currentTimeMillis();
-
-                for (IdleChannel idleChannel : channelsInTimeout) {
-                    Object attachment = idleChannel.channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).get();
-                    if (attachment != null) {
-                        if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
-                            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
-
-                        if (!future.isDone() && !future.isCancelled()) {
-                            log.debug("Future not in appropriate state %s\n", future);
-                            continue;
-                        }
-                    }
-                    }
-
-                    if (remove(idleChannel)) {
-                        log.debug("Closing Idle Channel {}", idleChannel.channel);
-                        close(idleChannel.channel);
-                    }
-                }
-
-                if (log.isTraceEnabled()) {
-                    int openChannels = 0;
-                    for (ConcurrentLinkedQueue<IdleChannel> hostChannels: connectionsPool.values()) {
-                        openChannels += hostChannels.size();
-                    }
-                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
-                            openChannels, channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
-                }
-            } catch (Throwable t) {
-                log.error("uncaught exception!", t);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean offer(String uri, Channel channel) {
-        if (isClosed.get()) return false;
-
-        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
-            return false;
-        }
-
-        Long createTime = channel2CreationDate.get(channel);
-        if (createTime == null){
-           channel2CreationDate.putIfAbsent(channel, System.currentTimeMillis());
-        }
-        else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < System.currentTimeMillis() ) {
-           log.debug("Channel {} expired", channel);
-           return false;
-        }
-
-        log.debug("Adding uri: {} for channel {}", uri, channel);
-        channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
-
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
-        if (idleConnectionForHost == null) {
-            ConcurrentLinkedQueue<IdleChannel> newPool = new ConcurrentLinkedQueue<IdleChannel>();
-            idleConnectionForHost = connectionsPool.putIfAbsent(uri, newPool);
-            if (idleConnectionForHost == null) idleConnectionForHost = newPool;
-        }
-
-        boolean added;
-        int size = idleConnectionForHost.size();
-        if (maxConnectionPerHost == -1 || size < maxConnectionPerHost) {
-            IdleChannel idleChannel = new IdleChannel(uri, channel);
-            synchronized (idleConnectionForHost) {
-                added = idleConnectionForHost.add(idleChannel);
-
-                if (channel2IdleChannel.put(channel, idleChannel) != null) {
-                    log.error("Channel {} already exists in the connections pool!", channel);
-                }
-            }
-        } else {
-            log.debug("Maximum number of requests per host reached {} for {}", maxConnectionPerHost, uri);
-            added = false;
-        }
-        return added;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Channel poll(String uri) {
-        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
-            return null;
-        }
-
-        IdleChannel idleChannel = null;
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
-        if (idleConnectionForHost != null) {
-            boolean poolEmpty = false;
-            while (!poolEmpty && idleChannel == null) {
-                if (idleConnectionForHost.size() > 0) {
-                    synchronized (idleConnectionForHost) {
-                        idleChannel = idleConnectionForHost.poll();
-                        if (idleChannel != null) {
-                            channel2IdleChannel.remove(idleChannel.channel);
-                        }
-                    }
-                }
-
-                if (idleChannel == null) {
-                    poolEmpty = true;
-                } else if (!idleChannel.channel.isActive() || !idleChannel.channel.isOpen()) {
-                    idleChannel = null;
-                    log.trace("Channel not connected or not opened!");
-                }
-            }
-        }
-        return idleChannel != null ? idleChannel.channel : null;
-    }
-
-    private boolean remove(IdleChannel pooledChannel) {
-        if (pooledChannel == null || isClosed.get()) return false;
-
-        boolean isRemoved = false;
-        ConcurrentLinkedQueue<IdleChannel> pooledConnectionForHost = connectionsPool.get(pooledChannel.uri);
-        if (pooledConnectionForHost != null) {
-            isRemoved = pooledConnectionForHost.remove(pooledChannel);
-        }
-        isRemoved |= channel2IdleChannel.remove(pooledChannel.channel) != null;
-        return isRemoved;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean removeAll(Channel channel) {
-        channel2CreationDate.remove(channel);
-        return !isClosed.get() && remove(channel2IdleChannel.get(channel));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean canCacheConnection() {
-        if (!isClosed.get() && maxTotalConnections != -1 && channel2IdleChannel.size() >= maxTotalConnections) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void destroy() {
-        if (isClosed.getAndSet(true)) return;
-
-        // stop timer
-        idleConnectionDetector.cancel();
-        idleConnectionDetector.purge();
-
-        for (Channel channel : channel2IdleChannel.keySet()) {
-            close(channel);
-        }
-        connectionsPool.clear();
-        channel2IdleChannel.clear();
-        channel2CreationDate.clear();
-    }
-
-    private void close(Channel channel) {
-        try {
-            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
-            channel2CreationDate.remove(channel);
-            channel.close();
-        } catch (Throwable t) {
-            // noop
-        }
-    }
-
-    public final String toString() {
-        return String.format("NettyConnectionPool: {pool-size: %d}", channel2IdleChannel.size());
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java
deleted file mode 100644
index 9e9ea53d2..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.providers.ResponseBase;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufInputStream;
-import io.netty.buffer.Unpooled;
-
-/**
- * Wrapper around the {@link org.asynchttpclient.Response} API.
- */
-public class NettyResponse extends ResponseBase {
-
-    public NettyResponse(HttpResponseStatus status,
-                         HttpResponseHeaders headers,
-                         List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
-    }
-
-    /* @Override */
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, null);
-    }
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        // should be fine; except that it may split multi-byte chars (last char may become '?')
-        charset = calculateCharset(charset);
-        byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
-        return new String(b, charset);
-    }
-    
-    protected List<Cookie> buildCookies() {
-    	List<Cookie> cookies = new ArrayList<Cookie>();
-        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                // TODO: ask for parsed header
-                List<String> v = header.getValue();
-                for (String value : v) {
-                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                    cookies.add(cookie);
-                }
-            }
-        }
-        return Collections.unmodifiableList(cookies);
-    }
-
-    /* @Override */
-    public byte[] getResponseBodyAsBytes() throws IOException {
-        return getResponseBodyAsByteBuffer().array();
-    }
-
-    /* @Override */
-    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
-        return getResponseBodyAsByteBuf().nioBuffer();
-    }
-
-    /* @Override */
-    public String getResponseBody() throws IOException {
-        return getResponseBody(null);
-    }
-
-    /* @Override */
-    public String getResponseBody(String charset) throws IOException {
-        return getResponseBodyAsByteBuf().toString(Charset.forName(calculateCharset(charset)));
-    }
-
-    /* @Override */
-    public InputStream getResponseBodyAsStream() throws IOException {
-        return new ByteBufInputStream(getResponseBodyAsByteBuf());
-    }
-
-    public ByteBuf getResponseBodyAsByteBuf() throws IOException {
-        ByteBuf b = null;
-        switch (bodyParts.size()) {
-        case 0:
-            b = Unpooled.EMPTY_BUFFER;
-            break;
-        case 1:
-            b = ResponseBodyPart.class.cast(bodyParts.get(0)).getChannelBuffer();
-            break;
-        default:
-            ByteBuf[] channelBuffers = new ByteBuf[bodyParts.size()];
-            for (int i = 0; i < bodyParts.size(); i++) {
-                channelBuffers[i] = ResponseBodyPart.class.cast(bodyParts.get(i)).getChannelBuffer();
-            }
-            b = Unpooled.wrappedBuffer(channelBuffers);
-        }
-
-        return b;
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java
deleted file mode 100644
index 6f5b2861c..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java
+++ /dev/null
@@ -1,515 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.ConnectionPoolKeyStrategy;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
- *
- * @param <V>
- */
-public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
-
-    private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
-    public final static String MAX_RETRY = "org.asynchttpclient.providers.netty.maxRetry";
-
-    enum STATE {
-        NEW,
-        POOLED,
-        RECONNECTED,
-        CLOSED,
-    }
-
-    private final CountDownLatch latch = new CountDownLatch(1);
-    private final AtomicBoolean isDone = new AtomicBoolean(false);
-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
-    private AsyncHandler<V> asyncHandler;
-    private final int responseTimeoutInMs;
-    private final int idleConnectionTimeoutInMs;
-    private Request request;
-    private FullHttpRequest nettyRequest;
-    private final AtomicReference<V> content = new AtomicReference<V>();
-    private URI uri;
-    private boolean keepAlive = true;
-    private HttpResponse httpResponse;
-    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
-    private final AtomicInteger redirectCount = new AtomicInteger();
-    private volatile Future<?> reaperFuture;
-    private final AtomicBoolean inAuth = new AtomicBoolean(false);
-    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
-    private final AtomicLong touch = new AtomicLong(System.currentTimeMillis());
-    private final long start = System.currentTimeMillis();
-    private final NettyAsyncHttpProvider asyncHttpProvider;
-    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
-    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    private Channel channel;
-    private boolean reuseChannel = false;
-    private final AtomicInteger currentRetry = new AtomicInteger(0);
-    private final int maxRetry;
-    private boolean writeHeaders;
-    private boolean writeBody;
-    private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
-    private boolean allowConnect = false;
-    private final ConnectionPoolKeyStrategy connectionPoolKeyStrategy;
-    private final ProxyServer proxyServer;
-    
-    public NettyResponseFuture(URI uri,
-                               Request request,
-                               AsyncHandler<V> asyncHandler,
-                               FullHttpRequest nettyRequest,
-                               int responseTimeoutInMs,
-                               int idleConnectionTimeoutInMs,
-                               NettyAsyncHttpProvider asyncHttpProvider,
-                               ConnectionPoolKeyStrategy connectionPoolKeyStrategy,
-                               ProxyServer proxyServer) {
-
-        this.asyncHandler = asyncHandler;
-        this.responseTimeoutInMs = responseTimeoutInMs;
-        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
-        this.request = request;
-        this.nettyRequest = nettyRequest;
-        this.uri = uri;
-        this.asyncHttpProvider = asyncHttpProvider;
-        this.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
-        this.proxyServer = proxyServer;
-
-        if (System.getProperty(MAX_RETRY) != null) {
-            maxRetry = Integer.valueOf(System.getProperty(MAX_RETRY));
-        } else {
-            maxRetry = asyncHttpProvider.getConfig().getMaxRequestRetry();
-        }
-        writeHeaders = true;
-        writeBody = true;
-    }
-
-    protected URI getURI() throws MalformedURLException {
-        return uri;
-    }
-
-    protected void setURI(URI uri) {
-        this.uri = uri;
-    }
-
-	public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
-		return connectionPoolKeyStrategy;
-	}
-
-	public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean isDone() {
-        return isDone.get();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean isCancelled() {
-        return isCancelled.get();
-    }
-
-    void setAsyncHandler(AsyncHandler<V> asyncHandler) {
-        this.asyncHandler = asyncHandler;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean cancel(boolean force) {
-        cancelReaper();
-
-        if (isCancelled.get()) return false;
-
-        try {
-            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
-            channel.close();
-        } catch (Throwable t) {
-            // Ignore
-        }
-        if (!throwableCalled.getAndSet(true)) {
-            try {
-                asyncHandler.onThrowable(new CancellationException());
-            } catch (Throwable t) {
-                logger.warn("cancel", t);
-            }
-        }
-        latch.countDown();
-        isCancelled.set(true);
-        super.done();
-        return true;
-    }
-
-    /**
-     * Is the Future still valid
-     *
-     * @return <code>true</code> if response has expired and should be terminated.
-     */
-    public boolean hasExpired() {
-        long now = System.currentTimeMillis();
-        return idleConnectionTimeoutInMs != -1 && ((now - touch.get()) >= idleConnectionTimeoutInMs)
-                || responseTimeoutInMs != -1 && ((now - start) >= responseTimeoutInMs);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public V get() throws InterruptedException, ExecutionException {
-        try {
-            return get(responseTimeoutInMs, TimeUnit.MILLISECONDS);
-        } catch (TimeoutException e) {
-            cancelReaper();
-            throw new ExecutionException(e);
-        }
-    }
-
-    void cancelReaper() {
-        if (reaperFuture != null) {
-            reaperFuture.cancel(true);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
-        if (!isDone() && !isCancelled()) {
-            boolean expired = false;
-            if (l == -1) {
-                latch.await();
-            } else {
-                expired = !latch.await(l, tu);
-            }
-
-            if (expired) {
-                isCancelled.set(true);
-                try {
-                    channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
-                    channel.close();
-                } catch (Throwable t) {
-                    // Ignore
-                }
-                TimeoutException te = new TimeoutException(String.format("No response received after %s %s", l, tu.name().toLowerCase()));
-                if (!throwableCalled.getAndSet(true)) {
-                    try {
-                        asyncHandler.onThrowable(te);
-                    } catch (Throwable t) {
-                        logger.debug("asyncHandler.onThrowable", t);
-                    } finally {
-                        cancelReaper();
-                        throw new ExecutionException(te);
-                    }
-                }
-            }
-            isDone.set(true);
-
-            ExecutionException e = exEx.getAndSet(null);
-            if (e != null) {
-                throw e;
-            }
-        }
-        return getContent();
-    }
-
-    V getContent() throws ExecutionException {
-        ExecutionException e = exEx.getAndSet(null);
-        if (e != null) {
-            throw e;
-        }
-
-        V update = content.get();
-        // No more retry
-        currentRetry.set(maxRetry);
-        if (exEx.get() == null && !contentProcessed.getAndSet(true)) {
-            try {
-                update = asyncHandler.onCompleted();
-            } catch (Throwable ex) {
-                if (!throwableCalled.getAndSet(true)) {
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        logger.debug("asyncHandler.onThrowable", t);
-                    } finally {
-                        cancelReaper();
-                        throw new RuntimeException(ex);
-                    }
-                }
-            }
-            content.compareAndSet(null, update);
-        }
-        return update;
-    }
-
-    public final void done(Callable callable) {
-
-        Throwable exception = null;
-
-        try {
-            cancelReaper();
-
-            if (exEx.get() != null) {
-                return;
-            }
-            getContent();
-            isDone.set(true);
-            if (callable != null) {
-                try {
-                    callable.call();
-                } catch (Exception ex) {
-                    exception = ex;
-                }
-            }
-        } catch (ExecutionException t) {
-            return;
-        } catch (RuntimeException t) {
-            exception = t.getCause() != null ? t.getCause() : t;
-
-        } finally {
-            latch.countDown();
-        }
-
-        if (exception != null)
-            exEx.compareAndSet(null, new ExecutionException(exception));
-
-        super.done();
-    }
-
-    public final void abort(final Throwable t) {
-        cancelReaper();
-
-        if (isDone.get() || isCancelled.get()) return;
-
-        exEx.compareAndSet(null, new ExecutionException(t));
-        if (!throwableCalled.getAndSet(true)) {
-            try {
-                asyncHandler.onThrowable(t);
-            } catch (Throwable te) {
-                logger.debug("asyncHandler.onThrowable", te);
-            } finally {
-                isCancelled.set(true);
-            }
-        }
-        latch.countDown();
-        super.done();
-    }
-
-    public void content(V v) {
-        content.set(v);
-    }
-
-    protected final Request getRequest() {
-        return request;
-    }
-
-    public final FullHttpRequest getNettyRequest() {
-        return nettyRequest;
-    }
-
-    protected final void setNettyRequest(HttpRequest nettyRequest) {
-        this.nettyRequest = nettyRequest;
-    }
-
-    protected final AsyncHandler<V> getAsyncHandler() {
-        return asyncHandler;
-    }
-
-    protected final boolean isKeepAlive() {
-        return keepAlive;
-    }
-
-    protected final void setKeepAlive(final boolean keepAlive) {
-        this.keepAlive = keepAlive;
-    }
-
-    protected final HttpResponse getHttpResponse() {
-        return httpResponse;
-    }
-
-    protected final void setHttpResponse(final HttpResponse httpResponse) {
-        this.httpResponse = httpResponse;
-    }
-
-    protected int incrementAndGetCurrentRedirectCount() {
-        return redirectCount.incrementAndGet();
-    }
-
-    protected void setReaperFuture(Future<?> reaperFuture) {
-        cancelReaper();
-        this.reaperFuture = reaperFuture;
-    }
-
-    protected boolean isInAuth() {
-        return inAuth.get();
-    }
-
-    protected boolean getAndSetAuth(boolean inDigestAuth) {
-        return inAuth.getAndSet(inDigestAuth);
-    }
-
-    protected STATE getState() {
-        return state.get();
-    }
-
-    protected void setState(STATE state) {
-        this.state.set(state);
-    }
-
-    public boolean getAndSetStatusReceived(boolean sr) {
-        return statusReceived.getAndSet(sr);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public void touch() {
-        touch.set(System.currentTimeMillis());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
-        boolean b = this.writeHeaders;
-        this.writeHeaders = writeHeaders;
-        return b;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteBody(boolean writeBody) {
-        boolean b = this.writeBody;
-        this.writeBody = writeBody;
-        return b;
-    }
-
-    protected NettyAsyncHttpProvider provider() {
-        return asyncHttpProvider;
-    }
-
-    protected void attachChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setReuseChannel(boolean reuseChannel) {
-        this.reuseChannel = reuseChannel;
-    }
-
-    public boolean isConnectAllowed() {
-        return allowConnect;
-    }
-
-    public void setConnectAllowed(boolean allowConnect) {
-        this.allowConnect = allowConnect;
-    }
-
-    protected void attachChannel(Channel channel, boolean reuseChannel) {
-        this.channel = channel;
-        this.reuseChannel = reuseChannel;
-    }
-
-    protected Channel channel() {
-        return channel;
-    }
-
-    protected boolean reuseChannel() {
-        return reuseChannel;
-    }
-
-    protected boolean canRetry() {
-        if (currentRetry.incrementAndGet() > maxRetry) {
-            return false;
-        }
-        return true;
-    }
-
-    public void setRequest(Request request) {
-        this.request = request;
-    }
-
-    /**
-     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be
-     * closed by an unexpected IOException, and in some situation we can recover from that exception.
-     *
-     * @return true if that {@link Future} cannot be recovered.
-     */
-    public boolean cannotBeReplay() {
-        return isDone()
-                || !canRetry()
-                || isCancelled()
-                || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0)
-                || isInAuth();
-    }
-
-    @Override
-    public String toString() {
-        return "NettyResponseFuture{" +
-                "currentRetry=" + currentRetry +
-                ",\n\tisDone=" + isDone +
-                ",\n\tisCancelled=" + isCancelled +
-                ",\n\tasyncHandler=" + asyncHandler +
-                ",\n\tresponseTimeoutInMs=" + responseTimeoutInMs +
-                ",\n\tnettyRequest=" + nettyRequest +
-                ",\n\tcontent=" + content +
-                ",\n\turi=" + uri +
-                ",\n\tkeepAlive=" + keepAlive +
-                ",\n\thttpResponse=" + httpResponse +
-                ",\n\texEx=" + exEx +
-                ",\n\tredirectCount=" + redirectCount +
-                ",\n\treaperFuture=" + reaperFuture +
-                ",\n\tinAuth=" + inAuth +
-                ",\n\tstatusReceived=" + statusReceived +
-                ",\n\ttouch=" + touch +
-                '}';
-    }
-
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java
deleted file mode 100644
index b88593056..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketByteListener;
-import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketTextListener;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import java.io.ByteArrayOutputStream;
-
-import static io.netty.buffer.Unpooled.wrappedBuffer;
-
-public class NettyWebSocket implements WebSocket {
-    private final static Logger logger = LoggerFactory.getLogger(NettyWebSocket.class);
-
-    private final Channel channel;
-    private final ConcurrentLinkedQueue<WebSocketListener> listeners = new ConcurrentLinkedQueue<WebSocketListener>();
-
-    private StringBuilder textBuffer;
-    private ByteArrayOutputStream byteBuffer;
-    private int maxBufferSize = 128000000;
-
-    public NettyWebSocket(Channel channel) {
-        this.channel = channel;
-    }
-
-    // @Override
-    public WebSocket sendMessage(byte[] message) {
-        channel.write(new BinaryWebSocketFrame(wrappedBuffer(message)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket stream(byte[] fragment, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket sendTextMessage(String message) {
-        channel.write(new TextWebSocketFrame(message));
-        return this;
-    }
-
-    // @Override
-    public WebSocket streamText(String fragment, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket sendPing(byte[] payload) {
-        channel.write(new PingWebSocketFrame(wrappedBuffer(payload)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket sendPong(byte[] payload) {
-        channel.write(new PongWebSocketFrame(wrappedBuffer(payload)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket addWebSocketListener(WebSocketListener l) {
-        listeners.add(l);
-        return this;
-    }
-
-    // @Override
-    public WebSocket removeWebSocketListener(WebSocketListener l) {
-        listeners.remove(l);
-        return this;
-    }
-
-    public int getMaxBufferSize() {
-    	return maxBufferSize;
-    }
-    
-    public void setMaxBufferSize(int bufferSize) {
-    	maxBufferSize = bufferSize;
-    	
-    	if(maxBufferSize < 8192)
-    		maxBufferSize = 8192;
-    }
-    
-    // @Override
-    public boolean isOpen() {
-        return channel.isOpen();
-    }
-
-    // @Override
-    public void close() {
-        onClose();
-        listeners.clear();
-        channel.close();
-    }
-
-    protected void onBinaryFragment(byte[] message, boolean last) {
-        for (WebSocketListener l : listeners) {
-            if (WebSocketByteListener.class.isAssignableFrom(l.getClass())) {
-                try {
-                	WebSocketByteListener.class.cast(l).onFragment(message,last);
-                	
-                	if(byteBuffer == null) {
-                		byteBuffer = new ByteArrayOutputStream();
-                	}
-                	
-                	byteBuffer.write(message);
-                	
-                	if(byteBuffer.size() > maxBufferSize) {
-                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
-                        l.onError(e);
-                		this.close();
-                		return;
-                	}
-                	
-
-                	if(last) {
-                    	WebSocketByteListener.class.cast(l).onMessage(byteBuffer.toByteArray());
-                    	byteBuffer = null;
-                    	textBuffer = null;
-                	}
-                } catch (Exception ex) {
-                    l.onError(ex);
-                }
-            }
-        }
-    }
-
-    protected void onTextFragment(String message, boolean last) {
-        for (WebSocketListener l : listeners) {
-            if (WebSocketTextListener.class.isAssignableFrom(l.getClass())) {
-                try {
-                    WebSocketTextListener.class.cast(l).onFragment(message,last);
-                    
-                	if(textBuffer == null) {
-                		textBuffer = new StringBuilder();
-                	}
-                	
-                	textBuffer.append(message);
-                	
-                	if(textBuffer.length() > maxBufferSize) {
-                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
-                        l.onError(e);
-                		this.close();
-                		return;
-                	}
-                	
-                	if(last) {
-                    	WebSocketTextListener.class.cast(l).onMessage(textBuffer.toString());
-                    	byteBuffer = null;
-                    	textBuffer = null;
-                	}
-                } catch (Exception ex) {
-                    l.onError(ex);
-                }
-            }
-        }
-    }
-
-    protected void onError(Throwable t) {
-        for (WebSocketListener l : listeners) {
-            try {
-                l.onError(t);
-            } catch (Throwable t2) {
-                logger.error("", t2);
-            }
-
-        }
-    }
-
-    protected void onClose() {
-        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
-    }
-
-    protected void onClose(int code, String reason) {
-        for (WebSocketListener l : listeners) {
-            try {
-                if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(l.getClass())) {
-                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
-                }
-                l.onClose(this);
-            } catch (Throwable t) {
-                l.onError(t);
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "NettyWebSocket{" +
-                "channel=" + channel +
-                '}';
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java
deleted file mode 100644
index 43ced26de..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseBodyPart;
-import io.netty.buffer.ByteBuf;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpContent;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * A callback class used when an HTTP response body is received.
- */
-public class ResponseBodyPart extends HttpResponseBodyPart {
-
-    private final HttpContent chunk;
-    private final FullHttpResponse response;
-    private final AtomicReference<byte[]> bytes = new AtomicReference<byte[]>(null);
-    private final boolean isLast;
-    private boolean closeConnection = false;
-
-    /**
-     * Constructor used for non-chunked GET requests and HEAD requests.
-     */
-    public ResponseBodyPart(URI uri, FullHttpResponse response, AsyncHttpProvider provider, boolean last) {
-        this(uri, response, provider, null, last);
-    }
-
-    public ResponseBodyPart(URI uri, FullHttpResponse response, AsyncHttpProvider provider, HttpContent chunk, boolean last) {
-        super(uri, provider);
-        this.chunk = chunk;
-        this.response = response;
-        isLast = last;
-    }
-    
-    /**
-     * Return the response body's part bytes received.
-     *
-     * @return the response body's part bytes received.
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        byte[] bp = bytes.get();
-        if (bp != null) {
-            return bp;
-        }
-
-        ByteBuf b = getChannelBuffer();
-        byte[] rb = b.nioBuffer().array();
-        bytes.set(rb);
-        return rb;
-    }
-
-    @Override
-    public InputStream readBodyPartBytes() {
-        return new ByteArrayInputStream(getBodyPartBytes());
-    }
-
-    @Override
-    public int length() {
-        ByteBuf b = (chunk != null) ? chunk.data() : response.data();
-        return b.readableBytes();
-    }
-    
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-        ByteBuf b = getChannelBuffer();
-        int available = b.readableBytes();
-        if (available > 0) {
-            b.getBytes(b.readerIndex(), outputStream, available);
-        }
-        return available;
-    }
-
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return ByteBuffer.wrap(getBodyPartBytes());
-    }
-
-    public ByteBuf getChannelBuffer() {
-        return chunk != null ? chunk.data() : response.data();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isLast() {
-        return isLast;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsClosed() {
-        closeConnection = true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean closeUnderlyingConnection() {
-        return closeConnection;
-    }
-
-    protected HttpContent chunk() {
-        return chunk;
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java
deleted file mode 100644
index 3ee78ae74..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseHeaders;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
-
-import java.net.URI;
-
-/**
- * A class that represent the HTTP headers.
- */
-public class ResponseHeaders extends HttpResponseHeaders {
-
-    private final LastHttpContent trailingHeaders;
-    private final HttpResponse response;
-    private final FluentCaseInsensitiveStringsMap headers;
-
-    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider) {
-        super(uri, provider, false);
-        this.trailingHeaders = null;
-        this.response = response;
-        headers = computerHeaders();
-    }
-
-    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider, LastHttpContent traillingHeaders) {
-        super(uri, provider, true);
-        this.trailingHeaders = traillingHeaders;
-        this.response = response;
-        headers = computerHeaders();
-    }
-
-    private FluentCaseInsensitiveStringsMap computerHeaders() {
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        for (String s : response.headers().names()) {
-            for (String header : response.headers().getAll(s)) {
-                h.add(s, header);
-            }
-        }
-
-        if (trailingHeaders != null) {
-            for (final String s : trailingHeaders.trailingHeaders().names()) {
-                for (String header : response.headers().getAll(s)) {
-                    h.add(s, header);
-                }
-            }
-        }
-
-        return h;
-    }
-
-    /**
-     * Return the HTTP header
-     *
-     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
-     */
-    @Override
-    public FluentCaseInsensitiveStringsMap getHeaders() {
-        return headers;
-    }
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java
deleted file mode 100644
index 0f9ae49d2..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpResponse;
-
-import java.net.URI;
-
-/**
- * A class that represent the HTTP response' status line (code + text)
- */
-public class ResponseStatus extends HttpResponseStatus {
-
-    private final HttpResponse response;
-
-    public ResponseStatus(URI uri, HttpResponse response, AsyncHttpProvider provider) {
-        super(uri, provider);
-        this.response = response;
-    }
-
-    /**
-     * Return the response status code
-     *
-     * @return the response status code
-     */
-    public int getStatusCode() {
-        return response.getStatus().code();
-    }
-
-    /**
-     * Return the response status text
-     *
-     * @return the response status text
-     */
-    public String getStatusText() {
-        return response.getStatus().reasonPhrase();
-    }
-
-    @Override
-    public String getProtocolName() {
-        return response.getProtocolVersion().protocolName();
-    }
-
-    @Override
-    public int getProtocolMajorVersion() {
-        return response.getProtocolVersion().majorVersion();
-    }
-
-    @Override
-    public int getProtocolMinorVersion() {
-        return response.getProtocolVersion().minorVersion();
-    }
-
-    @Override
-    public String getProtocolText() {
-        return response.getProtocolVersion().text();
-    }
-
-}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java
deleted file mode 100644
index b4ffdeb54..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty_4;
-
-import org.asynchttpclient.util.Base64;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public final class WebSocketUtil {
-    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
-
-    public static String getKey() {
-        byte[] nonce = createRandomBytes(16);
-        return base64Encode(nonce);
-    }
-
-    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
-        String acceptSeed = key + MAGIC_GUID;
-        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
-        return base64Encode(sha1);
-    }
-
-    public static byte[] md5(byte[] bytes) {
-        try {
-            MessageDigest md = MessageDigest.getInstance("MD5");
-            return md.digest(bytes);
-        } catch (NoSuchAlgorithmException e) {
-            throw new InternalError("MD5 not supported on this platform");
-        }
-    }
-
-    public static byte[] sha1(byte[] bytes) {
-        try {
-            MessageDigest md = MessageDigest.getInstance("SHA1");
-            return md.digest(bytes);
-        } catch (NoSuchAlgorithmException e) {
-            throw new InternalError("SHA-1 not supported on this platform");
-        }
-    }
-
-    public static String base64Encode(byte[] bytes) {
-        return Base64.encode(bytes);
-    }
-
-    public static byte[] createRandomBytes(int size) {
-        byte[] bytes = new byte[size];
-
-        for (int i = 0; i < size; i++) {
-            bytes[i] = (byte) createRandomNumber(0, 255);
-        }
-
-        return bytes;
-    }
-
-    public static int createRandomNumber(int min, int max) {
-        return (int) (Math.random() * max + min);
-    }
-
-}
-
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java
deleted file mode 100644
index bc989540d..000000000
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-/*
- * ====================================================================
- *
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- *
- */
-
-package org.asynchttpclient.providers.netty_4.spnego;
-
-import java.io.IOException;
-
-/**
- * Abstract SPNEGO token generator. Implementations should take an Kerberos ticket and transform
- * into a SPNEGO token.
- * <p/>
- * Implementations of this interface are expected to be thread-safe.
- *
- * @since 4.1
- */
-public interface SpnegoTokenGenerator {
-
-    byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
deleted file mode 100644
index 51739b168..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
-import static org.testng.Assert.assertEquals;
-
-import java.util.concurrent.Executors;
-
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-
-public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
-
-    @Test
-    public void bossThreadPoolExecutor() throws Throwable {
-        NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
-        conf.setBossExecutorService(Executors.newSingleThreadExecutor());
-
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-        try {
-            Response r = c.prepareGet(getTargetUrl()).execute().get();
-            assertEquals(r.getStatusCode(), 200);
-        } finally {
-            c.close();
-        }
-    }
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
deleted file mode 100644
index 41aea3c95..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.async.AsyncProvidersBasicTest;
-
-@Test
-public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-    @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
-        config.addProperty("tcpNoDelay", true);
-        return config;
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
deleted file mode 100644
index 806c3a7ea..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProvider;
-import static org.testng.Assert.assertEquals;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelPipeline;
-import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.channel.SimpleChannelHandler;
-import org.jboss.netty.handler.codec.http.HttpMessage;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-
-public class NettyAsyncProviderPipelineTest extends AbstractBasicTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return new AsyncHttpClient(new CopyEncodingNettyAsyncHttpProvider(config), config);
-    }
-
-    @Test(groups = { "standalone", "netty_provider" })
-    public void asyncPipelineTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build());
-        try {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
-            }
-        } finally {
-            p.close();
-        }
-    }
-
-    private static class CopyEncodingNettyAsyncHttpProvider extends NettyAsyncHttpProvider {
-        public CopyEncodingNettyAsyncHttpProvider(AsyncHttpClientConfig config) {
-            super(config);
-        }
-
-        protected ChannelPipelineFactory createPlainPipelineFactory() {
-            final ChannelPipelineFactory pipelineFactory = super.createPlainPipelineFactory();
-            return new ChannelPipelineFactory() {
-                public ChannelPipeline getPipeline() throws Exception {
-                    ChannelPipeline pipeline = pipelineFactory.getPipeline();
-                    pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
-                    return pipeline;
-                }
-            };
-        }
-    }
-
-    private static class CopyEncodingHandler extends SimpleChannelHandler {
-        @Override
-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
-            Object msg = e.getMessage();
-            if (msg instanceof HttpMessage) {
-                HttpMessage m = (HttpMessage) msg;
-                // for test there is no Content-Encoding header so just hard coding value
-                // for verification
-                m.setHeader("X-Original-Content-Encoding", "<original encoding>");
-            }
-            ctx.sendUpstream(e);
-        }
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
deleted file mode 100644
index 441048134..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.providers.netty_4.ResponseStatus;
-import org.asynchttpclient.providers.netty_4.NettyResponse;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.testng.annotations.Test;
-
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
-/**
- * @author Benjamin Hanzelmann
- */
-public class NettyAsyncResponseTest {
-
-    @Test(groups = "standalone")
-    public void testCookieParseExpires() {
-        // e.g. "Sun, 06-Feb-2012 03:45:24 GMT";
-        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
-        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
-
-        Date date = new Date(System.currentTimeMillis() + 60000); // sdf.parse( dateString );
-        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
-
-        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
-            @Override
-            public FluentCaseInsensitiveStringsMap getHeaders() {
-                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
-            }
-        }, null);
-
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
-
-        Cookie cookie = cookies.get(0);
-        assertTrue(cookie.getMaxAge() > 55 && cookie.getMaxAge() < 61, "");
-    }
-
-    @Test(groups = "standalone")
-    public void testCookieParseMaxAge() {
-        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
-            @Override
-            public FluentCaseInsensitiveStringsMap getHeaders() {
-                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
-            }
-        }, null);
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
-
-        Cookie cookie = cookies.get(0);
-        assertEquals(cookie.getMaxAge(), 60);
-    }
-
-    @Test(groups = "standalone")
-    public void testCookieParseWeirdExpiresValue() {
-        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
-            @Override
-            public FluentCaseInsensitiveStringsMap getHeaders() {
-                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
-            }
-        }, null);
-
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
-
-        Cookie cookie = cookies.get(0);
-        assertEquals(cookie.getMaxAge(), 60);
-    }
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
deleted file mode 100644
index 9760aa429..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamLifecycleTest;
-
-public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
deleted file mode 100644
index f8c7d3662..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicAuthTest;
-
-@Test
-public class NettyBasicAuthTest extends BasicAuthTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-    @Override
-    @Test
-    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        super.redirectAndBasicAuthTest(); // To change body of overridden methods use File | Settings | File Templates.
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
deleted file mode 100644
index 01e8daba4..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
-
-public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
deleted file mode 100644
index 8cabb0c63..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ByteBufferCapacityTest;
-
-public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
deleted file mode 100644
index 7783e21d5..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ChunkingTest;
-
-public class NettyChunkingTest extends ChunkingTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
deleted file mode 100644
index 7cb83020d..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ComplexClientTest;
-
-public class NettyComplexClientTest extends ComplexClientTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
deleted file mode 100644
index 945761d5e..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-
-import java.util.concurrent.TimeUnit;
-
-import org.jboss.netty.channel.Channel;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionsPool;
-import org.asynchttpclient.async.ConnectionPoolTest;
-
-public class NettyConnectionPoolTest extends ConnectionPoolTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-    @Override
-    public void testInvalidConnectionsPool() {
-        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
-
-            public boolean offer(String key, Channel connection) {
-                return false;
-            }
-
-            public Channel poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Channel connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return false;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
-        try {
-            Exception exception = null;
-            try {
-                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNotNull(exception);
-            assertEquals(exception.getMessage(), "Too many connections -1");
-        } finally {
-            client.close();
-        }
-    }
-
-    @Override
-    public void testValidConnectionsPool() {
-        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
-
-            public boolean offer(String key, Channel connection) {
-                return true;
-            }
-
-            public Channel poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Channel connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return true;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
-        try {
-            Exception exception = null;
-            try {
-                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNull(exception);
-        } finally {
-            client.close();
-        }
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
deleted file mode 100644
index 205fb73a1..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.DigestAuthTest;
-
-public class NettyDigestAuthTest extends DigestAuthTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
deleted file mode 100644
index 8cdbe19e6..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.EmptyBodyTest;
-
-public class NettyEmptyBodyTest extends EmptyBodyTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
deleted file mode 100644
index ee34de01f..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ErrorResponseTest;
-
-public class NettyErrorResponseTest extends ErrorResponseTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
deleted file mode 100644
index ce9759922..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Expect100ContinueTest;
-
-public class NettyExpect100ContinueTest extends Expect100ContinueTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
deleted file mode 100644
index 8b9adcbd6..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FilePartLargeFileTest;
-
-public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
deleted file mode 100644
index d1c6fd0eb..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FilterTest;
-
-public class NettyFilterTest extends FilterTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
deleted file mode 100644
index c3e2c8b75..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FollowingThreadTest;
-
-public class NettyFollowingThreadTest extends FollowingThreadTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
deleted file mode 100644
index 8fc323e3b..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Head302Test;
-
-public class NettyHead302Test extends Head302Test {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
deleted file mode 100644
index ec739b406..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.HttpToHttpsRedirectTest;
-
-public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
deleted file mode 100644
index 26dc2a2db..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.IdleStateHandlerTest;
-
-public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
deleted file mode 100644
index 5854ddc98..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.InputStreamTest;
-
-public class NettyInputStreamTest extends InputStreamTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
deleted file mode 100644
index 0e24c3d55..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2010-2012 Sonatype, Inc.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * and Apache License v2.0 which accompanies this distribution.
- * The Eclipse Public License is available at
- *   http://www.eclipse.org/legal/epl-v10.html
- * The Apache License v2.0 is available at
- *   http://www.apache.org/licenses/LICENSE-2.0.html
- * You may elect to redistribute this code under either of these licenses.
- *******************************************************************************/
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxConnectionsInThreads;
-
-public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
deleted file mode 100644
index 15e0892a6..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxTotalConnectionTest;
-
-public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
deleted file mode 100644
index 2198b1b1f..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MultipleHeaderTest;
-
-public class NettyMultipleHeaderTest extends MultipleHeaderTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
deleted file mode 100644
index d6b012226..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NoNullResponseTest;
-
-public class NettyNoNullResponseTest extends NoNullResponseTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
deleted file mode 100644
index 50fca62df..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NonAsciiContentLengthTest;
-
-public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
deleted file mode 100644
index d633d3797..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ParamEncodingTest;
-
-public class NettyParamEncodingTest extends ParamEncodingTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
deleted file mode 100644
index b0fabf1ef..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestRelative302Test;
-
-public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
deleted file mode 100644
index 637a7ec36..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestTimeoutTest;
-
-public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
deleted file mode 100644
index c244b89c0..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostWithQSTest;
-
-public class NettyPostWithQSTest extends PostWithQSTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
deleted file mode 100644
index 499e0025c..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-
-public class NettyProviderUtil {
-
-    public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
-        // FIXME why do tests fail with this set up? Seems like we have a race condition
-        // if (config == null) {
-        // config = new AsyncHttpClientConfig.Builder().build();
-        // }
-        // return new AsyncHttpClient(new NettyAsyncHttpProvider(config), config);
-
-        if (config == null) {
-            return new AsyncHttpClient();
-        } else {
-            return new AsyncHttpClient(config);
-        }
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
deleted file mode 100644
index a862e9ee8..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTunnellingTest;
-
-public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
deleted file mode 100644
index 550847c06..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PutLargeFileTest;
-
-public class NettyPutLargeFileTest extends PutLargeFileTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
deleted file mode 100644
index 7a38145ef..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.QueryParametersTest;
-
-public class NettyQueryParametersTest extends QueryParametersTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
deleted file mode 100644
index 33810c3d3..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.async.RedirectConnectionUsageTest;
-
-public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-    @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
-        if (System.getProperty("blockingio") != null) {
-            config.setUseBlockingIO(true);
-        }
-        return config;
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
deleted file mode 100644
index 22fca88ad..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Relative302Test;
-
-public class NettyRelative302Test extends Relative302Test {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
deleted file mode 100644
index f0685b456..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Future;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.continuation.Continuation;
-import org.eclipse.jetty.continuation.ContinuationSupport;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-
-public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
-    private static final String MSG = "Enough is enough.";
-    private static final int SLEEPTIME_MS = 1000;
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SlowHandler();
-    }
-
-    private class SlowHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
-            response.setStatus(HttpServletResponse.SC_OK);
-            final Continuation continuation = ContinuationSupport.getContinuation(request);
-            continuation.suspend();
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        Thread.sleep(SLEEPTIME_MS);
-                        response.getOutputStream().print(MSG);
-                        response.getOutputStream().flush();
-                        continuation.complete();
-                    } catch (InterruptedException e) {
-                        log.error(e.getMessage(), e);
-                    } catch (IOException e) {
-                        log.error(e.getMessage(), e);
-                    }
-                }
-            }).start();
-            baseRequest.setHandled(true);
-        }
-    }
-
-    @Test(groups = { "standalone", "netty_provider" })
-    public void testRequestTimeout() throws IOException {
-        final Semaphore requestThrottle = new Semaphore(1);
-
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
-        try {
-            final CountDownLatch latch = new CountDownLatch(2);
-
-            final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
-            for (int i = 0; i < 2; i++) {
-                new Thread(new Runnable() {
-
-                    public void run() {
-                        try {
-                            requestThrottle.acquire();
-                            Future<Response> responseFuture = null;
-                            try {
-                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2).execute(new AsyncCompletionHandler<Response>() {
-
-                                    @Override
-                                    public Response onCompleted(Response response) throws Exception {
-                                        requestThrottle.release();
-                                        return response;
-                                    }
-
-                                    @Override
-                                    public void onThrowable(Throwable t) {
-                                        requestThrottle.release();
-                                    }
-                                });
-                            } catch (Exception e) {
-                                tooManyConnections.add(e);
-                            }
-
-                            if (responseFuture != null)
-                                responseFuture.get();
-                        } catch (Exception e) {
-                        } finally {
-                            latch.countDown();
-                        }
-
-                    }
-                }).start();
-
-            }
-
-            try {
-                latch.await(30, TimeUnit.SECONDS);
-            } catch (Exception e) {
-                fail("failed to wait for requests to complete");
-            }
-
-            assertTrue(tooManyConnections.size() == 0, "Should not have any connection errors where too many connections have been attempted");
-        } finally {
-            client.close();
-        }
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
deleted file mode 100644
index 27834862d..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
-
-public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
-
-    /**
-     * Not Used with {@link org.asynchttpclient.SimpleAsyncHttpClient}
-     * @param config
-     * @return
-     */
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return null;
-    }
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
deleted file mode 100644
index 504607b65..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.TransferListenerTest;
-
-public class NettyTransferListenerTest extends TransferListenerTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
deleted file mode 100644
index e3f938171..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.WebDavBasicTest;
-
-public class NettyWebDavBasicTest extends WebDavBasicTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
deleted file mode 100644
index 3e98117d0..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ZeroCopyFileTest;
-
-public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
deleted file mode 100644
index 0b781e7c6..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.eclipse.jetty.servlet.ServletContextHandler;
-import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
-
-import static org.testng.Assert.assertTrue;
-
-
-public class RetryNonBlockingIssue {
-
-    private URI servletEndpointUri;
-
-    private Server server;
-
-    private int port1;
-
-    public static int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            // 0 is open a socket on any free port
-            socket = new ServerSocket(0);
-            return socket.getLocalPort();
-        } finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
-    }
-
-
-    @BeforeMethod
-    public void setUp() throws Exception {
-        server = new Server();
-
-        port1 = findFreePort();
-
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-
-        ServletContextHandler context = new
-                ServletContextHandler(ServletContextHandler.SESSIONS);
-
-        context.setContextPath("/");
-        server.setHandler(context);
-        context.addServlet(new ServletHolder(new
-                MockExceptionServlet()), "/*");
-
-        server.start();
-
-        servletEndpointUri = new URI("http://127.0.0.1:" + port1 + "/");
-    }
-
-    @AfterMethod
-    public void stop() {
-
-        try {
-            if (server != null) server.stop();
-        } catch (Exception e) {
-        }
-
-
-    }
-
-    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient
-            fetcher, int requests, String action, String id) throws IOException {
-        RequestBuilder builder = new RequestBuilder("GET");
-        builder.addQueryParameter(action, "1");
-
-        builder.addQueryParameter("maxRequests", "" + requests);
-        builder.addQueryParameter("id", id);
-        builder.setUrl(servletEndpointUri.toString());
-        Request r = builder.build();
-        return fetcher.executeRequest(r);
-
-    }
-
-    /**
-     * Tests that a head request can be made
-     *
-     * @throws IOException
-     * @throws ExecutionException
-     * @throws InterruptedException
-     */
-    @Test
-    public void testRetryNonBlocking() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
-        try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(60000);
-            bc.setRequestTimeoutInMs(30000);
-
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-
-            bc.setAsyncHttpClientProviderConfig(config);
-            c = new AsyncHttpClient(bc.build());
-
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
-            }
-
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                Map<String, List<String>> heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-                assertTrue(heads.size() > 0);
-            }
-            System.out.println(b.toString());
-            System.out.flush();
-
-        }
-        finally {
-            if (c != null) c.close();
-        }
-    }
-
-    @Test
-    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
-        try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(60000);
-            bc.setRequestTimeoutInMs(30000);
-
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-            config.setAsyncConnect(true);
-
-            bc.setAsyncHttpClientProviderConfig(config);
-            c = new AsyncHttpClient(bc.build());
-
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
-            }
-
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                Map<String, List<String>> heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-                assertTrue(heads.size() > 0);
-            }
-            System.out.println(b.toString());
-            System.out.flush();
-
-        }
-        finally {
-            if (c != null) c.close();
-        }
-    }
-
-    @Test
-    public void testRetryBlocking() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
-        try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(30000);
-            bc.setRequestTimeoutInMs(30000);
-
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-            config.setUseBlockingIO(true);
-
-            bc.setAsyncHttpClientProviderConfig(config);
-            c = new AsyncHttpClient(bc.build());
-
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
-            }
-
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                Map<String, List<String>> heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-                assertTrue(heads.size() > 0);
-
-            }
-            System.out.println(b.toString());
-            System.out.flush();
-
-        }
-        finally {
-            if (c != null) c.close();
-        }
-    }
-
-    @SuppressWarnings("serial")
-    public class MockExceptionServlet extends HttpServlet {
-
-        private Map<String, Integer> requests = new
-                ConcurrentHashMap<String, Integer>();
-
-        private synchronized int increment(String id) {
-            int val = 0;
-            if (requests.containsKey(id)) {
-                Integer i = requests.get(id);
-                val = i + 1;
-                requests.put(id, val);
-            } else {
-                requests.put(id, 1);
-                val = 1;
-            }
-            System.out.println("REQUESTS: " + requests);
-            return val;
-        }
-
-        public void service(HttpServletRequest req, HttpServletResponse res)
-                throws ServletException, IOException {
-            String maxRequests = req.getParameter("maxRequests");
-            int max = 0;
-            try {
-                max = Integer.parseInt(maxRequests);
-            }
-            catch (NumberFormatException e) {
-                max = 3;
-            }
-            String id = req.getParameter("id");
-            int requestNo = increment(id);
-            String servlet = req.getParameter("servlet");
-            String io = req.getParameter("io");
-            String error = req.getParameter("500");
-
-
-            if (requestNo >= max) {
-                res.setHeader("Success-On-Attempt", "" + requestNo);
-                res.setHeader("id", id);
-                if (servlet != null && servlet.trim().length() > 0)
-                    res.setHeader("type", "servlet");
-                if (error != null && error.trim().length() > 0)
-                    res.setHeader("type", "500");
-                if (io != null && io.trim().length() > 0)
-                    res.setHeader("type", "io");
-                res.setStatus(200);
-                res.setContentLength(0);
-                return;
-            }
-
-
-            res.setStatus(200);
-            res.setContentLength(100);
-            res.setContentType("application/octet-stream");
-
-            res.flushBuffer();
-
-            if (servlet != null && servlet.trim().length() > 0)
-                throw new ServletException("Servlet Exception");
-
-            if (io != null && io.trim().length() > 0)
-                throw new IOException("IO Exception");
-
-            if (error != null && error.trim().length() > 0)
-                res.sendError(500, "servlet process was 500");
-        }
-
-    }
-}
-
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
deleted file mode 100644
index 95b8d4cd5..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.ByteMessageTest;
-
-public class NettyByteMessageTest extends ByteMessageTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
deleted file mode 100644
index 7543bb701..000000000
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.TextMessageTest;
-
-public class NettyTextMessageTest extends TextMessageTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty-4/src/test/resources/client.keystore b/providers/netty-4/src/test/resources/client.keystore
deleted file mode 100644
index eaf8339f4..000000000
Binary files a/providers/netty-4/src/test/resources/client.keystore and /dev/null differ
diff --git a/providers/netty-4/src/test/resources/gzip.txt.gz b/providers/netty-4/src/test/resources/gzip.txt.gz
deleted file mode 100644
index 80aeb98d2..000000000
Binary files a/providers/netty-4/src/test/resources/gzip.txt.gz and /dev/null differ
diff --git a/providers/netty-4/src/test/resources/logback-test.xml b/providers/netty-4/src/test/resources/logback-test.xml
deleted file mode 100644
index 4acf27871..000000000
--- a/providers/netty-4/src/test/resources/logback-test.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<configuration>
-    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
-        <layout class="ch.qos.logback.classic.PatternLayout">
-            <Pattern>%d [%thread] %level %logger - %m%n</Pattern>
-        </layout>
-    </appender>
-
-    <logger name="org.eclipse" level="INFO"/>
-
-    <root level="debug">
-        <appender-ref ref="CONSOLE"/>
-    </root>
-</configuration>
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/realm.properties b/providers/netty-4/src/test/resources/realm.properties
deleted file mode 100644
index bc9faad66..000000000
--- a/providers/netty-4/src/test/resources/realm.properties
+++ /dev/null
@@ -1 +0,0 @@
-user=admin, admin
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/ssltest-cacerts.jks b/providers/netty-4/src/test/resources/ssltest-cacerts.jks
deleted file mode 100644
index 9c1ffbe49..000000000
Binary files a/providers/netty-4/src/test/resources/ssltest-cacerts.jks and /dev/null differ
diff --git a/providers/netty-4/src/test/resources/ssltest-keystore.jks b/providers/netty-4/src/test/resources/ssltest-keystore.jks
deleted file mode 100644
index a95b7c5f4..000000000
Binary files a/providers/netty-4/src/test/resources/ssltest-keystore.jks and /dev/null differ
diff --git a/providers/netty-4/src/test/resources/textfile.txt b/providers/netty-4/src/test/resources/textfile.txt
deleted file mode 100644
index 87daee60a..000000000
--- a/providers/netty-4/src/test/resources/textfile.txt
+++ /dev/null
@@ -1 +0,0 @@
-filecontent: hello
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/textfile2.txt b/providers/netty-4/src/test/resources/textfile2.txt
deleted file mode 100644
index 6a91fe609..000000000
--- a/providers/netty-4/src/test/resources/textfile2.txt
+++ /dev/null
@@ -1 +0,0 @@
-filecontent: hello2
\ No newline at end of file
diff --git a/providers/netty/pom.xml b/providers/netty/pom.xml
index 0fcfd6850..57510c4cf 100644
--- a/providers/netty/pom.xml
+++ b/providers/netty/pom.xml
@@ -1,6 +1,5 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-providers-parent</artifactId>
@@ -8,17 +7,45 @@
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-netty-provider</artifactId>
-    <name>Asynchronous Http Client Netty Provider</name>
+    <name>Asynchronous Http Client Netty 4 Provider</name>
     <description>
-        The Async Http Client Netty Provider.
+        The Async Http Client Netty 4 Provider.
     </description>
 
+    <repositories>
+        <repository>
+            <id>sonatype-releases</id>
+            <url>https://oss.sonatype.org/content/repositories/releases</url>
+            <releases>
+                <enabled>true</enabled>
+            </releases>
+            <snapshots>
+                <enabled>false</enabled>
+            </snapshots>
+        </repository>
+        <repository>
+            <id>sonatype-snapshots</id>
+            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
+            <releases>
+                <enabled>false</enabled>
+            </releases>
+            <snapshots>
+                <enabled>true</enabled>
+            </snapshots>
+        </repository>
+    </repositories>
+
     <dependencies>
         <dependency>
             <groupId>io.netty</groupId>
-            <artifactId>netty</artifactId>
-            <version>3.6.6.Final</version>
+            <artifactId>netty-all</artifactId>
+            <version>4.0.23.Final</version>
+        </dependency>
+        <dependency>
+            <groupId>org.javassist</groupId>
+            <artifactId>javassist</artifactId>
+            <version>3.18.2-GA</version>
         </dependency>
     </dependencies>
 
-</project>
\ No newline at end of file
+</project>
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java
deleted file mode 100644
index 1c9e49776..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.Body;
-import org.jboss.netty.buffer.ChannelBuffers;
-import org.jboss.netty.handler.stream.ChunkedInput;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
- */
-class BodyChunkedInput
-        implements ChunkedInput {
-
-    private final Body body;
-
-    private final int chunkSize = 1024 * 8;
-
-    private ByteBuffer nextChunk;
-
-    private static final ByteBuffer EOF = ByteBuffer.allocate(0);
-
-    private boolean endOfInput = false;
-
-    public BodyChunkedInput(Body body) {
-        if (body == null) {
-            throw new IllegalArgumentException("no body specified");
-        }
-        this.body = body;
-    }
-
-    private ByteBuffer peekNextChunk()
-            throws IOException {
-
-        if (nextChunk == null) {
-            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-            long length = body.read(buffer);
-            if (length < 0) {
-                // Negative means this is finished
-                buffer.flip();
-                nextChunk = buffer;
-                endOfInput = true;
-            } else if (length == 0) {
-                // Zero means we didn't get anything this time, but may get next time
-                buffer.flip();
-                nextChunk = null;
-            } else {
-                buffer.flip();
-                nextChunk = buffer;
-            }
-        }
-        return nextChunk;
-    }
-
-    /**
-     * Having no next chunk does not necessarily means end of input, other chunks may arrive later
-     */
-    public boolean hasNextChunk() throws Exception {
-        return peekNextChunk() != null;
-    }
-
-    public Object nextChunk() throws Exception {
-        ByteBuffer buffer = peekNextChunk();
-        if (buffer == null || buffer == EOF) {
-            return null;
-        }
-        nextChunk = null;
-
-        return ChannelBuffers.wrappedBuffer(buffer);
-    }
-
-    public boolean isEndOfInput() throws Exception {
-        return endOfInput;
-    }
-
-    public void close() throws Exception {
-        body.close();
-    }
-
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java
deleted file mode 100644
index 68a271a4d..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.RandomAccessBody;
-import org.jboss.netty.channel.FileRegion;
-
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
-
-/**
- * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
- */
-class BodyFileRegion
-        implements FileRegion {
-
-    private final RandomAccessBody body;
-
-    public BodyFileRegion(RandomAccessBody body) {
-        if (body == null) {
-            throw new IllegalArgumentException("no body specified");
-        }
-        this.body = body;
-    }
-
-    public long getPosition() {
-        return 0;
-    }
-
-    public long getCount() {
-        return body.getContentLength();
-    }
-
-    public long transferTo(WritableByteChannel target, long position)
-            throws IOException {
-        return body.transferTo(position, Long.MAX_VALUE, target);
-    }
-
-    public void releaseExternalResources() {
-        try {
-            body.close();
-        } catch (IOException e) {
-            // we tried
-        }
-    }
-
-}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java
similarity index 61%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java
index 61a633e00..14328ca42 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,15 +12,19 @@
  */
 package org.asynchttpclient.providers.netty;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AuthTimeoutTest;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
 
-public class NettyAuthTimeoutTest extends AuthTimeoutTest {
+public abstract class Callback {
 
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
+    private final NettyResponseFuture<?> future;
+
+    public Callback(NettyResponseFuture<?> future) {
+        this.future = future;
     }
 
+    abstract public void call() throws Exception;
+
+    public NettyResponseFuture<?> future() {
+        return future;
+    }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java
old mode 100644
new mode 100755
similarity index 62%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java
index 17f26efbb..a8590efa7
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,13 +12,9 @@
  */
 package org.asynchttpclient.providers.netty;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RC10KTest;
-
-public class NettyRC10KTest extends RC10KTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
+/**
+ * Simple marker for stopping publishing bytes.
+ */
+public enum DiscardEvent {
+    INSTANCE;
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
old mode 100644
new mode 100755
index f2bdb14c1..48cf1c06c
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
@@ -1,2403 +1,91 @@
 /*
- * Copyright 2010-2013 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.providers.netty;
 
+import io.netty.util.HashedWheelTimer;
+import io.netty.util.Timer;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.STATE;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.ConnectionPoolKeyStrategy;
-import org.asynchttpclient.ConnectionsPool;
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.ProgressAsyncHandler;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.RandomAccessBody;
-import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.multipart.MultipartBody;
-import org.asynchttpclient.multipart.MultipartRequestEntity;
-import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.ntlm.NTLMEngineException;
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieEncoder;
-import org.asynchttpclient.providers.netty.FeedableBodyGenerator.FeedListener;
-import org.asynchttpclient.providers.netty.spnego.SpnegoEngine;
-import org.asynchttpclient.providers.netty.util.CleanupChannelGroup;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.util.ProxyUtils;
-import org.asynchttpclient.util.SslUtils;
-import org.asynchttpclient.util.UTF8UrlEncoder;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
-import org.jboss.netty.bootstrap.ClientBootstrap;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.buffer.ChannelBufferOutputStream;
-import org.jboss.netty.buffer.ChannelBuffers;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureProgressListener;
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelPipeline;
-import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.ChannelStateEvent;
-import org.jboss.netty.channel.DefaultChannelFuture;
-import org.jboss.netty.channel.ExceptionEvent;
-import org.jboss.netty.channel.FileRegion;
-import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
-import org.jboss.netty.channel.group.ChannelGroup;
-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.oio.OioClientSocketChannelFactory;
-import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
-import org.jboss.netty.handler.codec.http.HttpChunk;
-import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.HttpClientCodec;
-import org.jboss.netty.handler.codec.http.HttpContentCompressor;
-import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
-import org.jboss.netty.handler.codec.http.HttpHeaders;
-import org.jboss.netty.handler.codec.http.HttpMethod;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpRequestEncoder;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-import org.jboss.netty.handler.codec.http.HttpResponseDecoder;
-import org.jboss.netty.handler.codec.http.HttpVersion;
-import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
-import org.jboss.netty.handler.ssl.SslHandler;
-import org.jboss.netty.handler.stream.ChunkedFile;
-import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLEngine;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
-import java.nio.charset.Charset;
-import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-import static org.asynchttpclient.util.DateUtil.millisTime;
-import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
-import static org.jboss.netty.channel.Channels.pipeline;
+public class NettyAsyncHttpProvider implements AsyncHttpProvider {
 
-public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
-    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
-    private final static String HTTP_HANDLER = "httpHandler";
-    protected final static String SSL_HANDLER = "sslHandler";
-    private final static String HTTPS = "https";
-    private final static String HTTP = "http";
-    private static final String WEBSOCKET = "ws";
-    private static final String WEBSOCKET_SSL = "wss";
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
 
-    private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
-    private final static Charset UTF8 = Charset.forName("UTF-8");
-
-    private final ClientBootstrap plainBootstrap;
-    private final ClientBootstrap secureBootstrap;
-    private final ClientBootstrap webSocketBootstrap;
-    private final ClientBootstrap secureWebSocketBootstrap;
-    private final static int MAX_BUFFERED_BYTES = 8192;
-    private final AsyncHttpClientConfig config;
-    private final AtomicBoolean isClose = new AtomicBoolean(false);
-    private final ClientSocketChannelFactory socketChannelFactory;
-    private final boolean allowReleaseSocketChannelFactory;
-
-    private final ChannelGroup openChannels = new CleanupChannelGroup("asyncHttpClient") {
-        @Override
-        public boolean remove(Object o) {
-            boolean removed = super.remove(o);
-            if (removed && trackConnections) {
-                freeConnections.release();
-            }
-            return removed;
-        }
-    };
-    private final ConnectionsPool<String, Channel> connectionsPool;
-    private Semaphore freeConnections = null;
-    private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
-    private boolean executeConnectAsync = true;
-    public static final ThreadLocal<Boolean> IN_IO_THREAD = new ThreadLocalBoolean();
-    private final boolean trackConnections;
-    private final boolean useRawUrl;
-    private final static NTLMEngine ntlmEngine = new NTLMEngine();
-    private static SpnegoEngine spnegoEngine = null;
-    private final Protocol httpProtocol = new HttpProtocol();
-    private final Protocol webSocketProtocol = new WebSocketProtocol();
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+    private final AtomicBoolean closed = new AtomicBoolean(false);
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+    private final boolean allowStopNettyTimer;
+    private final Timer nettyTimer;
 
     public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
 
-        if (config.getAsyncHttpProviderConfig() != null && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
-            asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
-        } else {
-            asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
-        }
-
-        if (asyncHttpProviderConfig.isUseBlockingIO()) {
-            socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
-            this.allowReleaseSocketChannelFactory = true;
-        } else {
-            // check if external NioClientSocketChannelFactory is defined
-            NioClientSocketChannelFactory scf = asyncHttpProviderConfig.getSocketChannelFactory();
-            if (scf != null) {
-                this.socketChannelFactory = scf;
-
-                // cannot allow releasing shared channel factory
-                this.allowReleaseSocketChannelFactory = false;
-            } else {
-                ExecutorService e = asyncHttpProviderConfig.getBossExecutorService();
-                if (e == null) {
-                    e = Executors.newCachedThreadPool();
-                }
-                int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
-                log.debug("Number of application's worker threads is {}", numWorkers);
-                socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
-                this.allowReleaseSocketChannelFactory = true;
-            }
-        }
-        plainBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureBootstrap = new ClientBootstrap(socketChannelFactory);
-        webSocketBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureWebSocketBootstrap = new ClientBootstrap(socketChannelFactory);
-        configureNetty();
-
-        this.config = config;
-
-        // This is dangerous as we can't catch a wrong typed ConnectionsPool
-        ConnectionsPool<String, Channel> cp = (ConnectionsPool<String, Channel>) config.getConnectionsPool();
-        if (cp == null && config.getAllowPoolingConnection()) {
-            cp = new NettyConnectionsPool(this);
-        } else if (cp == null) {
-            cp = new NonConnectionsPool();
-        }
-        this.connectionsPool = cp;
-
-        if (config.getMaxTotalConnections() != -1) {
-            trackConnections = true;
-            freeConnections = new Semaphore(config.getMaxTotalConnections());
-        } else {
-            trackConnections = false;
-        }
-
-        useRawUrl = config.isUseRawUrl();
-    }
-
-    @Override
-    public String toString() {
-        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s", config.getMaxTotalConnections() - freeConnections.availablePermits(), openChannels.toString(), connectionsPool.toString());
-    }
-
-    void configureNetty() {
-        if (asyncHttpProviderConfig != null) {
-            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                String key = entry.getKey();
-                Object value = entry.getValue();
-                plainBootstrap.setOption(key, value);
-                webSocketBootstrap.setOption(key, value);
-                secureBootstrap.setOption(key, value);
-                secureWebSocketBootstrap.setOption(key, value);
-            }
-        }
-
-        plainBootstrap.setPipelineFactory(createPlainPipelineFactory());
-        DefaultChannelFuture.setUseDeadLockChecker(false);
-
-        if (asyncHttpProviderConfig != null) {
-            executeConnectAsync = config.isAsyncConnectMode();
-            if (!executeConnectAsync) {
-                DefaultChannelFuture.setUseDeadLockChecker(true);
-            }
-        }
-
-        webSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-                pipeline.addLast("http-decoder", new HttpResponseDecoder());
-                pipeline.addLast("http-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        });
-    }
-
-    protected HttpClientCodec newHttpClientCodec() {
-        if (asyncHttpProviderConfig != null) {
-            return new HttpClientCodec(asyncHttpProviderConfig.getMaxInitialLineLength(), asyncHttpProviderConfig.getMaxHeaderSize(), asyncHttpProviderConfig.getMaxChunkSize(), false);
-
-        } else {
-            return new HttpClientCodec();
-        }
-    }
-
-    protected ChannelPipelineFactory createPlainPipelineFactory() {
-        return new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
-
-                if (config.getRequestCompressionLevel() > 0) {
-                    pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
-                }
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        };
-    }
-
-    void constructSSLPipeline(final NettyConnectListener<?> cl) {
-
-        secureBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        });
-
-        secureWebSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast("http-decoder", new HttpResponseDecoder());
-                pipeline.addLast("http-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-
-                return pipeline;
-            }
-        });
-    }
-
-    private Channel lookupInCache(URI uri, ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
-        final Channel channel = connectionsPool.poll(connectionPoolKeyStrategy.getKey(uri));
+        nettyConfig = config.getAsyncHttpProviderConfig() instanceof NettyAsyncHttpProviderConfig ? //
+        (NettyAsyncHttpProviderConfig) config.getAsyncHttpProviderConfig()
+                : new NettyAsyncHttpProviderConfig();
 
-        if (channel != null) {
-            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+        allowStopNettyTimer = nettyConfig.getNettyTimer() == null;
+        nettyTimer = allowStopNettyTimer ? newNettyTimer() : nettyConfig.getNettyTimer();
 
-            try {
-                // Always make sure the channel who got cached support the proper protocol. It could
-                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
-                // https.
-                return verifyChannelPipeline(channel, uri.getScheme());
-            } catch (Exception ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-        return null;
-    }
-
-    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
-        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
-        if (sslEngine == null) {
-            sslEngine = SslUtils.getSSLEngine();
-        }
-        return sslEngine;
-    }
-
-    private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
-
-        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            channel.getPipeline().remove(SSL_HANDLER);
-        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            return channel;
-        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-        }
-        return channel;
-    }
-
-    protected final <T> void writeRequest(final Channel channel, final AsyncHttpClientConfig config, final NettyResponseFuture<T> future, final HttpRequest nettyRequest) {
-        try {
-            /**
-             * If the channel is dead because it was pooled and the remote server decided to close it, we just let it go and the closeChannel do it's work.
-             */
-            if (!channel.isOpen() || !channel.isConnected()) {
-                return;
-            }
-
-            Body body = null;
-            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-                BodyGenerator bg = future.getRequest().getBodyGenerator();
-                if (bg != null) {
-                    // Netty issue with chunking.
-                    if (InputStreamBodyGenerator.class.isAssignableFrom(bg.getClass())) {
-                        InputStreamBodyGenerator.class.cast(bg).patchNettyChunkingIssue(true);
-                    }
-
-                    try {
-                        body = bg.createBody();
-                    } catch (IOException ex) {
-                        throw new IllegalStateException(ex);
-                    }
-                    long length = body.getContentLength();
-                    if (length >= 0) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, length);
-                    } else {
-                        nettyRequest.setHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
-                    }
-                } else {
-                    body = null;
-                }
-            }
-
-            if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
-
-                FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-                for (String s : future.getNettyRequest().getHeaderNames()) {
-                    for (String header : future.getNettyRequest().getHeaders(s)) {
-                        h.add(s, header);
-                    }
-                }
-
-                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
-            }
-
-            // Leave it to true.
-            if (future.getAndSetWriteHeaders(true)) {
-                try {
-                    channel.write(nettyRequest).addListener(new ProgressListener(true, future.getAsyncHandler(), future));
-                } catch (Throwable cause) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        channel.close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-            }
-
-            if (future.getAndSetWriteBody(true)) {
-                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-
-                    if (future.getRequest().getFile() != null) {
-                        final File file = future.getRequest().getFile();
-                        long fileLength = 0;
-                        final RandomAccessFile raf = new RandomAccessFile(file, "r");
-
-                        try {
-                            fileLength = raf.length();
-
-                            ChannelFuture writeFuture;
-                            if (channel.getPipeline().get(SslHandler.class) != null) {
-                                writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
-                            } else {
-                                final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
-                                writeFuture = channel.write(region);
-                            }
-                            writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
-                                public void operationComplete(ChannelFuture cf) {
-                                    try {
-                                        raf.close();
-                                    } catch (IOException e) {
-                                        log.warn("Failed to close request body: {}", e.getMessage(), e);
-                                    }
-                                    super.operationComplete(cf);
-                                }
-                            });
-                        } catch (IOException ex) {
-                            if (raf != null) {
-                                try {
-                                    raf.close();
-                                } catch (IOException e) {
-                                }
-                            }
-                            throw ex;
-                        }
-                    } else if (body != null || future.getRequest().getParts() != null) {
-                        /**
-                         * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                         */
-                        if (future.getRequest().getParts() != null) {
-                            String contentType = future.getNettyRequest().getHeader("Content-Type");
-                            String length = future.getNettyRequest().getHeader("Content-Length");
-                            body = new MultipartBody(future.getRequest().getParts(), contentType, length);
-                        }
-
-                        ChannelFuture writeFuture;
-                        if (channel.getPipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
-                            BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
-                            writeFuture = channel.write(bodyFileRegion);
-                        } else {
-                            BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
-                            BodyGenerator bg = future.getRequest().getBodyGenerator();
-                            if (bg instanceof FeedableBodyGenerator) {
-                                ((FeedableBodyGenerator) bg).setListener(new FeedListener() {
-                                    @Override
-                                    public void onContentAdded() {
-                                        channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
-                                    }
-                                });
-                            }
-                            writeFuture = channel.write(bodyChunkedInput);
-                        }
-
-                        final Body b = body;
-                        writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
-                            public void operationComplete(ChannelFuture cf) {
-                                try {
-                                    b.close();
-                                } catch (IOException e) {
-                                    log.warn("Failed to close request body: {}", e.getMessage(), e);
-                                }
-                                super.operationComplete(cf);
-                            }
-                        });
-                    }
-                }
-            }
-        } catch (Throwable ioe) {
-            try {
-                channel.close();
-            } catch (RuntimeException ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-
-        try {
-            future.touch();
-            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, future.getRequest());
-            int schedulePeriod = requestTimeout != -1 ? (config.getIdleConnectionTimeoutInMs() != -1 ? Math.min(requestTimeout, config.getIdleConnectionTimeoutInMs()) : requestTimeout) : config.getIdleConnectionTimeoutInMs();
-
-            if (schedulePeriod != -1 && !future.isDone() && !future.isCancelled()) {
-                ReaperFuture reaperFuture = new ReaperFuture(future);
-                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, schedulePeriod, TimeUnit.MILLISECONDS);
-                reaperFuture.setScheduledFuture(scheduledFuture);
-                future.setReaperFuture(reaperFuture);
-            }
-        } catch (RejectedExecutionException ex) {
-            abort(future, ex);
-        }
-
-    }
-
-    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri, boolean allowConnect, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
-
-        String method = request.getMethod();
-        if (allowConnect && proxyServer != null && isSecure(uri)) {
-            method = HttpMethod.CONNECT.toString();
-        }
-        return construct(config, request, new HttpMethod(method), uri, buffer, proxyServer);
-    }
-
-    private static SpnegoEngine getSpnegoEngine() {
-        if (spnegoEngine == null)
-            spnegoEngine = new SpnegoEngine();
-        return spnegoEngine;
+        channelManager = new ChannelManager(config, nettyConfig, nettyTimer);
+        requestSender = new NettyRequestSender(config, nettyConfig, channelManager, nettyTimer, closed);
+        channelManager.configureBootstraps(requestSender, closed);
     }
 
-    private static HttpRequest construct(AsyncHttpClientConfig config, Request request, HttpMethod m, URI uri, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
-
-        String host = null;
-        boolean webSocket = isWebSocket(uri);
-
-        if (request.getVirtualHost() != null) {
-            host = request.getVirtualHost();
-        } else {
-            AsyncHttpProviderUtils.getHost(uri);
-    	}
-
-        HttpRequest nettyRequest;
-        if (m.equals(HttpMethod.CONNECT)) {
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
-        } else {
-            String path = null;
-            if (proxyServer != null && !(isSecure(uri) && config.isUseRelativeURIsWithSSLProxies()))
-                path = uri.toString();
-            else if (uri.getRawQuery() != null)
-                path = uri.getRawPath() + "?" + uri.getRawQuery();
-            else
-                path = uri.getRawPath();
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path);
-        }
-
-        if (webSocket) {
-            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
-            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
-            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
-            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
-            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
-        }
-
-        if (host != null) {
-            if (request.getVirtualHost() != null || uri.getPort() == -1) {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
-            } else {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
-            }
-        } else {
-            host = "127.0.0.1";
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            for (Entry<String, List<String>> header : request.getHeaders()) {
-                String name = header.getKey();
-                if (!HttpHeaders.Names.HOST.equalsIgnoreCase(name)) {
-                    for (String value : header.getValue()) {
-                        nettyRequest.addHeader(name, value);
-                    }
-                }
-            }
-
-            if (config.isCompressionEnabled()) {
-                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-            }
-        } else {
-            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-            if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM")) {
-                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
-            }
-        }
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-
-            String domain = realm.getNtlmDomain();
-            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
-                domain = proxyServer.getNtlmDomain();
-            }
-
-            String authHost = realm.getNtlmHost();
-            if (proxyServer != null && proxyServer.getHost() != null) {
-                host = proxyServer.getHost();
-            }
-
-            switch (realm.getAuthScheme()) {
-            case BASIC:
-                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(realm));
-                break;
-            case DIGEST:
-                if (isNonEmpty(realm.getNonce())) {
-                    try {
-                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeDigestAuthentication(realm));
-                    } catch (NoSuchAlgorithmException e) {
-                        throw new SecurityException(e);
-                    }
-                }
-                break;
-            case NTLM:
-                try {
-                    String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
-                } catch (NTLMEngineException e) {
-                    IOException ie = new IOException();
-                    ie.initCause(e);
-                    throw ie;
-                }
-                break;
-            case KERBEROS:
-            case SPNEGO:
-                String challengeHeader = null;
-                String server = proxyServer == null ? host : proxyServer.getHost();
-                try {
-                    challengeHeader = getSpnegoEngine().generateToken(server);
-                } catch (Throwable e) {
-                    IOException ie = new IOException();
-                    ie.initCause(e);
-                    throw ie;
-                }
-                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-                break;
-            case NONE:
-                break;
-            default:
-                throw new IllegalStateException("Invalid Authentication " + realm);
-            }
-        }
-
-        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
-            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, AsyncHttpProviderUtils.keepAliveHeaderValue(config));
-        }
-
-        if (proxyServer != null) {
-            if (!request.getHeaders().containsKey("Proxy-Connection")) {
-                nettyRequest.setHeader("Proxy-Connection", AsyncHttpProviderUtils.keepAliveHeaderValue(config));
-            }
-
-            if (proxyServer.getPrincipal() != null) {
-                if (isNonEmpty(proxyServer.getNtlmDomain())) {
-
-                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-                    if (!(isNonEmpty(auth) && auth.get(0).startsWith("NTLM"))) {
-                        try {
-                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(), proxyServer.getHost());
-                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
-                        } catch (NTLMEngineException e) {
-                            IOException ie = new IOException();
-                            ie.initCause(e);
-                            throw ie;
-                        }
-                    }
-                } else {
-                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(proxyServer));
-                }
-            }
-        }
-
-        // Add default accept headers.
-        if (request.getHeaders().getFirstValue("Accept") == null) {
-            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
-        }
-
-        if (request.getHeaders().getFirstValue("User-Agent") != null) {
-            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
-        } else if (config.getUserAgent() != null) {
-            nettyRequest.setHeader("User-Agent", config.getUserAgent());
-        } else {
-            nettyRequest.setHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class, config));
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            if (isNonEmpty(request.getCookies())) {
-                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, CookieEncoder.encodeClientSide(request.getCookies(), config.isRfc6265CookieEncoding()));
-            }
-
-            String reqType = request.getMethod();
-            if (!"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
-
-                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
-
-                // We already have processed the body.
-                if (buffer != null && buffer.writerIndex() != 0) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
-                    nettyRequest.setContent(buffer);
-                } else if (request.getByteData() != null) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
-                } else if (request.getStringData() != null) {
-                    byte[] bytes = request.getStringData().getBytes(bodyCharset);
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(bytes.length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes));
-                } else if (request.getStreamData() != null) {
-                    int[] lengthWrapper = new int[1];
-                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
-                    int length = lengthWrapper[0];
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
-                } else if (isNonEmpty(request.getParams())) {
-                    StringBuilder sb = new StringBuilder();
-                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
-                        final String key = paramEntry.getKey();
-                        for (final String value : paramEntry.getValue()) {
-                            if (sb.length() > 0) {
-                                sb.append("&");
-                            }
-                            UTF8UrlEncoder.appendEncoded(sb, key);
-                            sb.append("=");
-                            UTF8UrlEncoder.appendEncoded(sb, value);
-                        }
-                    }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
-
-                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
-                    }
-
-                } else if (request.getParts() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getHeaders());
-
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
-
-                    /**
-                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                     */
-
-                    if (isSecure(uri)) {
-                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                        mre.writeRequest(new ChannelBufferOutputStream(b));
-                        nettyRequest.setContent(b);
-                    }
-                } else if (request.getEntityWriter() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
-                    nettyRequest.setContent(b);
-                } else if (request.getFile() != null) {
-                    File file = request.getFile();
-                    if (!file.isFile()) {
-                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
-                    }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
-                }
-            }
-        }
-        return nettyRequest;
+    private Timer newNettyTimer() {
+        HashedWheelTimer timer = new HashedWheelTimer();
+        timer.start();
+        return timer;
     }
 
+    @Override
     public void close() {
-        isClose.set(true);
-        try {
-            connectionsPool.destroy();
-            openChannels.close();
-
-            for (Channel channel : openChannels) {
-                ChannelHandlerContext ctx = channel.getPipeline().getContext(NettyAsyncHttpProvider.class);
-                if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-                    future.setReaperFuture(null);
-                }
-            }
-
-            config.executorService().shutdown();
-            config.reaper().shutdown();
-            if (this.allowReleaseSocketChannelFactory) {
-                socketChannelFactory.releaseExternalResources();
-                plainBootstrap.releaseExternalResources();
-                secureBootstrap.releaseExternalResources();
-                webSocketBootstrap.releaseExternalResources();
-                secureWebSocketBootstrap.releaseExternalResources();
-            }
-        } catch (Throwable t) {
-            log.warn("Unexpected error on close", t);
-        }
-    }
-
-    /* @Override */
-
-    public Response prepareResponse(final HttpResponseStatus status, final HttpResponseHeaders headers, final List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(status, headers, bodyParts);
-    }
-
-    /* @Override */
-
-    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
-        return doConnect(request, asyncHandler, null, true, executeConnectAsync, false);
-    }
-
-    private <T> void execute(final Request request, final NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-        doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
-    }
-
-    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-
-        if (isClose.get()) {
-            throw new IOException("Closed");
-        }
-
-        if (request.getUrl().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler)) {
-            throw new IOException("WebSocket method must be a GET");
-        }
-
-        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-        boolean useProxy = proxyServer != null;
-        URI uri;
-        if (useRawUrl) {
-            uri = request.getRawURI();
-        } else {
-            uri = request.getURI();
-        }
-        Channel channel = null;
-
-        if (useCache) {
-            if (f != null && f.reuseChannel() && f.channel() != null) {
-                channel = f.channel();
-            } else {
-                URI connectionKeyUri = useProxy ? proxyServer.getURI() : uri;
-                channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
-            }
-        }
-
-        ChannelBuffer bufferedBytes = null;
-        if (f != null && f.getRequest().getFile() == null && !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
-            bufferedBytes = f.getNettyRequest().getContent();
-        }
-
-        boolean useSSl = isSecure(uri) && !useProxy;
-        if (channel != null && channel.isOpen() && channel.isConnected()) {
-            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes, proxyServer);
-
-            if (f == null) {
-                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this, proxyServer);
-            } else {
-                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes, proxyServer);
-                f.setNettyRequest(nettyRequest);
-            }
-            f.setState(NettyResponseFuture.STATE.POOLED);
-            f.attachChannel(channel, false);
-
-            log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
-
-            try {
-                writeRequest(channel, config, f, nettyRequest);
-            } catch (Exception ex) {
-                log.debug("writeRequest failure", ex);
-                if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
-                    log.debug("SSLEngine failure", ex);
-                    f = null;
-                } else {
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("doConnect.writeRequest()", t);
-                    }
-                    IOException ioe = new IOException(ex.getMessage());
-                    ioe.initCause(ex);
-                    throw ioe;
-                }
-            }
-            return f;
-        }
-
-        // Do not throw an exception when we need an extra connection for a redirect.
-        if (!reclaimCache && !connectionsPool.canCacheConnection()) {
-            IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
-            try {
-                asyncHandler.onThrowable(ex);
-            } catch (Throwable t) {
-                log.warn("!connectionsPool.canCacheConnection()", t);
-            }
-            throw ex;
-        }
-
-        boolean acquiredConnection = false;
-
-        if (trackConnections) {
-            if (!reclaimCache) {
-                if (!freeConnections.tryAcquire()) {
-                    IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("!connectionsPool.canCacheConnection()", t);
-                    }
-                    throw ex;
-                } else {
-                    acquiredConnection = true;
-                }
-            }
-        }
-
-        NettyConnectListener<T> c = new NettyConnectListener.Builder<T>(config, request, asyncHandler, f, this, bufferedBytes).build(uri);
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
-
-        if (useSSl) {
-            constructSSLPipeline(c);
-        }
-
-        ChannelFuture channelFuture;
-        ClientBootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
-        bootstrap.setOption("connectTimeoutMillis", config.getConnectionTimeoutInMs());
-
-        try {
-            InetSocketAddress remoteAddress;
-            if (request.getInetAddress() != null) {
-                remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
-            } else if (proxyServer == null || avoidProxy) {
-                remoteAddress = new InetSocketAddress(AsyncHttpProviderUtils.getHost(uri), AsyncHttpProviderUtils.getPort(uri));
-            } else {
-                remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
-            }
-
-            if (request.getLocalAddress() != null) {
-                channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
-            } else {
-                channelFuture = bootstrap.connect(remoteAddress);
-            }
-
-        } catch (Throwable t) {
-            if (acquiredConnection) {
-                freeConnections.release();
-            }
-            abort(c.future(), t.getCause() == null ? t : t.getCause());
-            return c.future();
-        }
-
-        boolean directInvokation = true;
-        if (IN_IO_THREAD.get() && DefaultChannelFuture.isUseDeadLockChecker()) {
-            directInvokation = false;
-        }
-
-        if (directInvokation && !asyncConnect && request.getFile() == null) {
-            int timeOut = config.getConnectionTimeoutInMs() > 0 ? config.getConnectionTimeoutInMs() : Integer.MAX_VALUE;
-            if (!channelFuture.awaitUninterruptibly(timeOut, TimeUnit.MILLISECONDS)) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                channelFuture.cancel();
-                abort(c.future(), new ConnectException(String.format("Connect operation to %s timeout %s", uri, timeOut)));
-            }
-
+        if (closed.compareAndSet(false, true)) {
             try {
-                c.operationComplete(channelFuture);
-            } catch (Exception e) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                IOException ioe = new IOException(e.getMessage());
-                ioe.initCause(e);
-                try {
-                    asyncHandler.onThrowable(ioe);
-                } catch (Throwable t) {
-                    log.warn("c.operationComplete()", t);
-                }
-                throw ioe;
-            }
-        } else {
-            channelFuture.addListener(c);
-        }
-
-        log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
-
-        if (!c.future().isCancelled() || !c.future().isDone()) {
-            openChannels.add(channelFuture.getChannel());
-            c.future().attachChannel(channelFuture.getChannel(), false);
-        }
-        return c.future();
-    }
-
-    private void closeChannel(final ChannelHandlerContext ctx) {
-        connectionsPool.removeAll(ctx.getChannel());
-        finishChannel(ctx);
-    }
-
-    private void finishChannel(final ChannelHandlerContext ctx) {
-        ctx.setAttachment(new DiscardEvent());
-
-        // The channel may have already been removed if a timeout occurred, and this method may be called just after.
-        if (ctx.getChannel() == null) {
-            return;
-        }
-
-        log.debug("Closing Channel {} ", ctx.getChannel());
-
-        try {
-            ctx.getChannel().close();
-        } catch (Throwable t) {
-            log.debug("Error closing a connection", t);
-        }
-
-        if (ctx.getChannel() != null) {
-            openChannels.remove(ctx.getChannel());
-        }
-
-    }
+                channelManager.close();
 
-    @Override
-    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-        // call super to reset the read timeout
-        super.messageReceived(ctx, e);
-        IN_IO_THREAD.set(Boolean.TRUE);
-        if (ctx.getAttachment() == null) {
-            log.debug("ChannelHandlerContext wasn't having any attachment");
-        }
+                if (allowStopNettyTimer)
+                    nettyTimer.stop();
 
-        if (ctx.getAttachment() instanceof DiscardEvent) {
-            return;
-        } else if (ctx.getAttachment() instanceof AsyncCallable) {
-            if (e.getMessage() instanceof HttpChunk) {
-                HttpChunk chunk = (HttpChunk) e.getMessage();
-                if (chunk.isLast()) {
-                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                    ac.call();
-                } else {
-                    return;
-                }
-            } else {
-                AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                ac.call();
-            }
-            ctx.setAttachment(new DiscardEvent());
-            return;
-        } else if (!(ctx.getAttachment() instanceof NettyResponseFuture<?>)) {
-            try {
-                ctx.getChannel().close();
             } catch (Throwable t) {
-                log.trace("Closing an orphan channel {}", ctx.getChannel());
-            }
-            return;
-        }
-
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.handle(ctx, e);
-    }
-
-    private Realm kerberosChallenge(List<String> proxyAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        URI uri = request.getURI();
-        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
-        String server = proxyServer == null ? host : proxyServer.getHost();
-        try {
-            String challengeHeader = getSpnegoEngine().generateToken(server);
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-
-            Realm.RealmBuilder realmBuilder;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
+                LOGGER.warn("Unexpected error on close", t);
             }
-            return realmBuilder.setUri(uri.getRawPath()).setMethodName(request.getMethod()).setScheme(Realm.AuthScheme.KERBEROS).build();
-        } catch (Throwable throwable) {
-            if (proxyAuth.contains("NTLM")) {
-                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-            }
-            abort(future, throwable);
-            return null;
         }
     }
 
-    private Realm ntlmChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        boolean useRealm = (proxyServer == null && realm != null);
-
-        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
-        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
-        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
-        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
-
-        Realm newRealm;
-        if (realm != null && !realm.isNtlmMessageType2Received()) {
-            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
-
-            URI uri = request.getURI();
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(uri.getRawPath()).setMethodName(request.getMethod()).setNtlmMessageType2Received(true).build();
-            future.getAndSetAuth(false);
-        } else {
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-
-            if (wwwAuth.get(0).startsWith("NTLM ")) {
-                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-                String challengeHeader = ntlmEngine.generateType3Msg(principal, password, ntlmDomain, ntlmHost, serverChallenge);
-
-                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            }
-
-            Realm.RealmBuilder realmBuilder;
-            Realm.AuthScheme authScheme;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-                authScheme = realm.getAuthScheme();
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
-                authScheme = Realm.AuthScheme.NTLM;
-            }
-            newRealm = realmBuilder.setScheme(authScheme).setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
-        }
-
-        return newRealm;
-    }
-
-    private Realm ntlmProxyChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
-        future.getAndSetAuth(false);
-        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
-
-        if (wwwAuth.get(0).startsWith("NTLM ")) {
-            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getNtlmDomain(), proxyServer.getHost(), serverChallenge);
-            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-        }
-        Realm newRealm;
-        Realm.RealmBuilder realmBuilder;
-        if (realm != null) {
-            realmBuilder = new Realm.RealmBuilder().clone(realm);
-        } else {
-            realmBuilder = new Realm.RealmBuilder();
-        }
-        newRealm = realmBuilder// .setScheme(realm.getAuthScheme())
-                .setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
-
-        return newRealm;
-    }
-
-    private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
-        URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
-        return future.getConnectionPoolKeyStrategy().getKey(uri);
-    }
-
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
-        ctx.setAttachment(new AsyncCallable(future) {
-            public Object call() throws Exception {
-                if (future.isKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
-                    return null;
-                }
-
-                finishChannel(ctx);
-                return null;
-            }
-
-            @Override
-            public String toString() {
-                return "Draining task for channel " + ctx.getChannel();
-            }
-        });
-    }
-
-    private FilterContext handleIoException(FilterContext fc, NettyResponseFuture<?> future) {
-        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            } catch (FilterException efe) {
-                abort(future, efe);
-            }
-        }
-        return fc;
-    }
-
-    private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, HttpResponse response, ChannelHandlerContext ctx) throws IOException {
-        final Request newRequest = fc.getRequest();
-        future.setAsyncHandler(fc.getAsyncHandler());
-        future.setState(NettyResponseFuture.STATE.NEW);
-        future.touch();
-
-        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future);
-        nextRequest(newRequest, future);
-        return;
-    }
-
-    private List<String> getAuthorizationToken(List<Entry<String, String>> list, String headerAuth) {
-        ArrayList<String> l = new ArrayList<String>();
-        for (Entry<String, String> e : list) {
-            if (e.getKey().equalsIgnoreCase(headerAuth)) {
-                l.add(e.getValue().trim());
-            }
-        }
-        return l;
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future) throws IOException {
-        nextRequest(request, future, true);
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future, final boolean useCache) throws IOException {
-        execute(request, future, useCache, true, true);
-    }
-
-    private void abort(NettyResponseFuture<?> future, Throwable t) {
-        Channel channel = future.channel();
-        if (channel != null && openChannels.contains(channel)) {
-            closeChannel(channel.getPipeline().getContext(NettyAsyncHttpProvider.class));
-            openChannels.remove(channel);
-        }
-
-        if (!future.isCancelled() && !future.isDone()) {
-            log.debug("Aborting Future {}\n", future);
-            log.debug(t.getMessage(), t);
-        }
-
-        future.abort(t);
-    }
-
-    private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOException, GeneralSecurityException {
-        if (p.get(HTTP_HANDLER) != null) {
-            p.remove(HTTP_HANDLER);
-        }
-
-        if (isSecure(scheme)) {
-            if (p.get(SSL_HANDLER) == null) {
-                p.addFirst(HTTP_HANDLER, newHttpClientCodec());
-                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-            } else {
-                p.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
-            }
-
-        } else {
-            p.addFirst(HTTP_HANDLER, newHttpClientCodec());
-        }
-    }
-
-    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-
-        if (isClose.get()) {
-            return;
-        }
-
-        connectionsPool.removeAll(ctx.getChannel());
-        try {
-            super.channelClosed(ctx, e);
-        } catch (Exception ex) {
-            log.trace("super.channelClosed", ex);
-        }
-
-        log.debug("Channel Closed: {} with attachment {}", e.getChannel(), ctx.getAttachment());
-
-        if (ctx.getAttachment() instanceof AsyncCallable) {
-            AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-            ctx.setAttachment(ac.future());
-            ac.call();
-            return;
-        }
-
-        if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-            NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-            future.touch();
-
-            if (config.getIOExceptionFilters().size() > 0) {
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                fc = handleIoException(fc, future);
-
-                if (fc.replayRequest() && !future.cannotBeReplay()) {
-                    replayRequest(future, fc, null, ctx);
-                    return;
-                }
-            }
-
-            Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-            p.onClose(ctx, e);
-
-            if (future != null && !future.isDone() && !future.isCancelled()) {
-                if (!remotelyClosed(ctx.getChannel(), future)) {
-                    abort(future, new IOException("Remotely Closed " + ctx.getChannel()));
-                }
-            } else {
-                closeChannel(ctx);
-            }
-        }
-    }
-
-    protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future) {
-
-        if (isClose.get()) {
-            return false;
-        }
-
-        connectionsPool.removeAll(channel);
-
-        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null && NettyResponseFuture.class.isAssignableFrom(channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
-            future = (NettyResponseFuture<?>) channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
-        }
-
-        if (future == null || future.cannotBeReplay()) {
-            log.debug("Unable to recover future {}\n", future);
-            return false;
-        }
-
-        future.setState(NettyResponseFuture.STATE.RECONNECTED);
-        future.getAndSetStatusReceived(false);
-
-        log.debug("Trying to recover request {}\n", future.getNettyRequest());
-
-        try {
-            nextRequest(future.getRequest(), future);
-            return true;
-        } catch (IOException iox) {
-            future.setState(NettyResponseFuture.STATE.CLOSED);
-            future.abort(iox);
-            log.error("Remotely Closed, unable to recover", iox);
-        }
-        return false;
-    }
-
-    private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx) throws MalformedURLException {
-        // We need to make sure everything is OK before adding the connection back to the pool.
-        try {
-            future.done(null);
-        } catch (Throwable t) {
-            // Never propagate exception once we know we are done.
-            log.debug(t.getMessage(), t);
-        }
-
-        if (!future.isKeepAlive() || !ctx.getChannel().isReadable()) {
-            closeChannel(ctx);
-        }
-    }
-
-    private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
-        if (lastValidChunk && future.isKeepAlive()) {
-            drainChannel(ctx, future);
-        } else {
-            if (future.isKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
-                markAsDone(future, ctx);
-                return;
-            }
-            finishChannel(ctx);
-        }
-        markAsDone(future, ctx);
-    }
-
-    private final boolean updateStatusAndInterrupt(AsyncHandler<?> handler, HttpResponseStatus c) throws Exception {
-        return handler.onStatusReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateHeadersAndInterrupt(AsyncHandler<?> handler, HttpResponseHeaders c) throws Exception {
-        return handler.onHeadersReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart c) throws Exception {
-        boolean state = handler.onBodyPartReceived(c) != STATE.CONTINUE;
-        if (c.closeUnderlyingConnection()) {
-            future.setKeepAlive(false);
-        }
-        return state;
-    }
-
-    // Simple marker for stopping publishing bytes.
-
-    final static class DiscardEvent {
-    }
-
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
-        Channel channel = e.getChannel();
-        Throwable cause = e.getCause();
-        NettyResponseFuture<?> future = null;
-
-        /**
-         * Issue 81 if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) { return; }
-         */
-        if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
-            return;
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("Unexpected I/O exception on channel {}", channel, cause);
-        }
-
-        try {
-
-            if (cause != null && ClosedChannelException.class.isAssignableFrom(cause.getClass())) {
-                return;
-            }
-
-            if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                future = (NettyResponseFuture<?>) ctx.getAttachment();
-                future.attachChannel(null, false);
-                future.touch();
-
-                if (IOException.class.isAssignableFrom(cause.getClass())) {
-
-                    if (config.getIOExceptionFilters().size() > 0) {
-                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                        fc = handleIoException(fc, future);
-
-                        if (fc.replayRequest()) {
-                            replayRequest(future, fc, null, ctx);
-                            return;
-                        }
-                    } else {
-                        // Close the channel so the recovering can occurs.
-                        try {
-                            ctx.getChannel().close();
-                        } catch (Throwable t) {
-                            ; // Swallow.
-                        }
-                        return;
-                    }
-                }
-
-                if (abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
-                    log.debug("Trying to recover from dead Channel: {}", channel);
-                    return;
-                }
-            } else if (ctx.getAttachment() instanceof AsyncCallable) {
-                future = ((AsyncCallable) ctx.getAttachment()).future();
-            }
-        } catch (Throwable t) {
-            cause = t;
-        }
-
-        if (future != null) {
-            try {
-                log.debug("Was unable to recover Future: {}", future);
-                abort(future, cause);
-            } catch (Throwable t) {
-                log.error(t.getMessage(), t);
-            }
-        }
-
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.onError(ctx, e);
-
-        closeChannel(ctx);
-        ctx.sendUpstream(e);
-    }
-
-    protected static boolean abortOnConnectCloseException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl") && element.getMethodName().equals("checkConnect")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnDisconnectException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler") && element.getMethodName().equals("channelDisconnected")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnReadCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("read")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    protected static boolean abortOnWriteCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("write")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
-        int length = (int) request.getContentLength();
-        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
-            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
-        }
-
-        if (length >= 0) {
-            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-        }
-        return length;
-    }
-
-    public static <T> NettyResponseFuture<T> newFuture(URI uri, Request request, AsyncHandler<T> asyncHandler, HttpRequest nettyRequest, AsyncHttpClientConfig config, NettyAsyncHttpProvider provider, ProxyServer proxyServer) {
-
-        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
-        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri,//
-                request,//
-                asyncHandler,//
-                nettyRequest,//
-                requestTimeout,//
-                config.getIdleConnectionTimeoutInMs(),//
-                provider,//
-                request.getConnectionPoolKeyStrategy(),//
-                proxyServer);
-
-        if (request.getHeaders().getFirstValue("Expect") != null && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
-            f.getAndSetWriteBody(false);
-        }
-        return f;
-    }
-
-    private class ProgressListener implements ChannelFutureProgressListener {
-
-        private final boolean notifyHeaders;
-        private final AsyncHandler<?> asyncHandler;
-        private final NettyResponseFuture<?> future;
-
-        public ProgressListener(boolean notifyHeaders, AsyncHandler<?> asyncHandler, NettyResponseFuture<?> future) {
-            this.notifyHeaders = notifyHeaders;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-        }
-
-        public void operationComplete(ChannelFuture cf) {
-            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
-            // Let's retry a second time.
-            Throwable cause = cf.getCause();
-            if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
-
-                if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        cf.getChannel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-
-                if (ClosedChannelException.class.isAssignableFrom(cause.getClass()) || abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
-
-                    if (log.isDebugEnabled()) {
-                        log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
-                    }
-
-                    try {
-                        cf.getChannel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                } else {
-                    future.abort(cause);
-                }
-                return;
-            }
-            future.touch();
-
-            /**
-             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization, causing unpredictable behavior.
-             */
-            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
-            boolean startPublishing = future.isInAuth() || realm == null || realm.getUsePreemptiveAuth() == true;
-
-            if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                if (notifyHeaders) {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
-                } else {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
-                }
-            }
-        }
-
-        public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
-            future.touch();
-            if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
-            }
-        }
-    }
-
-    /**
-     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future this wrapper will release the references to the channel and the
-     * nettyResponseFuture immediately. Otherwise, the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
-     */
-    private final class ReaperFuture implements Future, Runnable {
-        private Future scheduledFuture;
-        private NettyResponseFuture<?> nettyResponseFuture;
-
-        public ReaperFuture(NettyResponseFuture<?> nettyResponseFuture) {
-            this.nettyResponseFuture = nettyResponseFuture;
-        }
-
-        public void setScheduledFuture(Future scheduledFuture) {
-            this.scheduledFuture = scheduledFuture;
-        }
-
-        /**
-         * @Override
-         */
-        public boolean cancel(boolean mayInterruptIfRunning) {
-            nettyResponseFuture = null;
-            return scheduledFuture.cancel(mayInterruptIfRunning);
-        }
-
-        /**
-         * @Override
-         */
-        public Object get() throws InterruptedException, ExecutionException {
-            return scheduledFuture.get();
-        }
-
-        /**
-         * @Override
-         */
-        public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-            return scheduledFuture.get(timeout, unit);
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isCancelled() {
-            return scheduledFuture.isCancelled();
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isDone() {
-            return scheduledFuture.isDone();
-        }
-
-        private void expire(String message) {
-            log.debug("{} for {}", message, nettyResponseFuture);
-            abort(nettyResponseFuture, new TimeoutException(message));
-            nettyResponseFuture = null;
-        }
-
-        /**
-         * @Override
-         */
-        public synchronized void run() {
-            if (isClose.get()) {
-                cancel(true);
-                return;
-            }
-
-            boolean futureDone = nettyResponseFuture.isDone();
-            boolean futureCanceled = nettyResponseFuture.isCancelled();
-
-            if (nettyResponseFuture != null && !futureDone && !futureCanceled) {
-                long now = millisTime();
-                if (nettyResponseFuture.hasRequestTimedOut(now)) {
-                    long age = now - nettyResponseFuture.getStart();
-                    expire("Request reached time out of " + nettyResponseFuture.getRequestTimeoutInMs() + " ms after " + age + " ms");
-                } else if (nettyResponseFuture.hasConnectionIdleTimedOut(now)) {
-                    long age = now - nettyResponseFuture.getStart();
-                    expire("Request reached idle time out of " + nettyResponseFuture.getIdleConnectionTimeoutInMs() + " ms after " + age + " ms");
-                }
-
-            } else if (nettyResponseFuture == null || futureDone || futureCanceled) {
-                cancel(true);
-            }
-        }
-    }
-
-    private abstract class AsyncCallable implements Callable<Object> {
-
-        private final NettyResponseFuture<?> future;
-
-        public AsyncCallable(NettyResponseFuture<?> future) {
-            this.future = future;
-        }
-
-        abstract public Object call() throws Exception;
-
-        public NettyResponseFuture<?> future() {
-            return future;
-        }
-    }
-
-    public static class ThreadLocalBoolean extends ThreadLocal<Boolean> {
-
-        private final boolean defaultValue;
-
-        public ThreadLocalBoolean() {
-            this(false);
-        }
-
-        public ThreadLocalBoolean(boolean defaultValue) {
-            this.defaultValue = defaultValue;
-        }
-
-        @Override
-        protected Boolean initialValue() {
-            return defaultValue ? Boolean.TRUE : Boolean.FALSE;
-        }
-    }
-
-    public static class OptimizedFileRegion implements FileRegion {
-
-        private final FileChannel file;
-        private final RandomAccessFile raf;
-        private final long position;
-        private final long count;
-        private long byteWritten;
-
-        public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
-            this.raf = raf;
-            this.file = raf.getChannel();
-            this.position = position;
-            this.count = count;
-        }
-
-        public long getPosition() {
-            return position;
-        }
-
-        public long getCount() {
-            return count;
-        }
-
-        public long transferTo(WritableByteChannel target, long position) throws IOException {
-            long count = this.count - position;
-            if (count < 0 || position < 0) {
-                throw new IllegalArgumentException("position out of range: " + position + " (expected: 0 - " + (this.count - 1) + ")");
-            }
-            if (count == 0) {
-                return 0L;
-            }
-
-            long bw = file.transferTo(this.position + position, count, target);
-            byteWritten += bw;
-            if (byteWritten == raf.length()) {
-                releaseExternalResources();
-            }
-            return bw;
-        }
-
-        public void releaseExternalResources() {
-            try {
-                file.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-
-            try {
-                raf.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-        }
-    }
-
-    private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
-
-        private final ChannelBuffer content;
-        private final FileInputStream file;
-        private int byteRead = 0;
-
-        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ChannelBuffer content, File file) throws IOException {
-            super(headers);
-            this.content = content;
-            if (file != null) {
-                this.file = new FileInputStream(file);
-            } else {
-                this.file = null;
-            }
-        }
-
-        @Override
-        public void getBytes(byte[] bytes) {
-            if (content.writableBytes() != 0) {
-                content.getBytes(byteRead, bytes);
-                byteRead += bytes.length;
-            } else if (file != null) {
-                try {
-                    byteRead += file.read(bytes);
-                } catch (IOException e) {
-                    log.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    protected AsyncHttpClientConfig getConfig() {
-        return config;
-    }
-
-    private static class NonConnectionsPool implements ConnectionsPool<String, Channel> {
-
-        public boolean offer(String uri, Channel connection) {
-            return false;
-        }
-
-        public Channel poll(String uri) {
-            return null;
-        }
-
-        public boolean removeAll(Channel connection) {
-            return false;
-        }
-
-        public boolean canCacheConnection() {
-            return true;
-        }
-
-        public void destroy() {
-        }
-    }
-
-    private static final boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-        if (request.getMethod() != "GET" || !WebSocketUpgradeHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-            return false;
-        }
-        return true;
-    }
-
-    private boolean redirect(Request request, NettyResponseFuture<?> future, HttpResponse response, final ChannelHandlerContext ctx) throws Exception {
-
-        int statusCode = response.getStatus().getCode();
-        boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
-        if (redirectEnabled && (statusCode == 302 || statusCode == 301 || statusCode == 303 || statusCode == 307)) {
-
-            if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
-                // We must allow 401 handling again.
-                future.getAndSetAuth(false);
-
-                String location = response.getHeader(HttpHeaders.Names.LOCATION);
-                URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
-                boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
-                if (!uri.toString().equals(future.getURI().toString())) {
-                    final RequestBuilder nBuilder = stripQueryString ? new RequestBuilder(future.getRequest()).setQueryParameters(null) : new RequestBuilder(future.getRequest());
-
-                    if (!(statusCode < 302 || statusCode > 303) && !(statusCode == 302 && config.isStrict302Handling())) {
-                        nBuilder.setMethod("GET");
-                    }
-                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
-                    final String initialPoolKey = getPoolKey(future);
-                    future.setURI(uri);
-                    String newUrl = uri.toString();
-                    if (request.getUrl().startsWith(WEBSOCKET)) {
-                        newUrl = newUrl.replace(HTTP, WEBSOCKET);
-                    }
-
-                    log.debug("Redirecting to {}", newUrl);
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE)) {
-                        for (Cookie c : CookieDecoder.decode(cookieStr)) {
-                            nBuilder.addOrReplaceCookie(c);
-                        }
-                    }
-
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE2)) {
-                        for (Cookie c : CookieDecoder.decode(cookieStr)) {
-                            nBuilder.addOrReplaceCookie(c);
-                        }
-                    }
-
-                    AsyncCallable ac = new AsyncCallable(future) {
-                        public Object call() throws Exception {
-                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(initialPoolKey, ctx.getChannel())) {
-                                return null;
-                            }
-                            finishChannel(ctx);
-                            return null;
-                        }
-                    };
-
-                    if (response.isChunked()) {
-                        // We must make sure there is no bytes left before executing the next request.
-                        ctx.setAttachment(ac);
-                    } else {
-                        ac.call();
-                    }
-                    nextRequest(nBuilder.setUrl(newUrl).build(), future);
-                    return true;
-                }
-            } else {
-                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-            }
-        }
-        return false;
-    }
-
-    private final class HttpProtocol implements Protocol {
-        // @Override
-        public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws Exception {
-            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-            future.touch();
-
-            // The connect timeout occured.
-            if (future.isCancelled() || future.isDone()) {
-                finishChannel(ctx);
-                return;
-            }
-
-            HttpRequest nettyRequest = future.getNettyRequest();
-            AsyncHandler handler = future.getAsyncHandler();
-            Request request = future.getRequest();
-            ProxyServer proxyServer = future.getProxyServer();
-            HttpResponse response = null;
-            try {
-                if (e.getMessage() instanceof HttpResponse) {
-                    response = (HttpResponse) e.getMessage();
-
-                    log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
-
-                    // Required if there is some trailing headers.
-                    future.setHttpResponse(response);
-
-                    int statusCode = response.getStatus().getCode();
-
-                    String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
-                    future.setKeepAlive(ka == null || !ka.toLowerCase().equals("close"));
-
-                    List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
-                    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-                    HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(request).responseStatus(status).responseHeaders(responseHeaders).build();
-
-                    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                        try {
-                            fc = asyncFilter.filter(fc);
-                            if (fc == null) {
-                                throw new NullPointerException("FilterContext is null");
-                            }
-                        } catch (FilterException efe) {
-                            abort(future, efe);
-                        }
-                    }
-
-                    // The handler may have been wrapped.
-                    handler = fc.getAsyncHandler();
-                    future.setAsyncHandler(handler);
-
-                    // The request has changed
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-
-                    Realm newRealm = null;
-                    final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
-                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
-
-                    // if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
-                    // builder.setUrl(future.getURI().toString());
-                    // }
-
-                    if (statusCode == 401 && realm != null && wwwAuth.size() > 0 && !future.getAndSetAuth(true)) {
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-                        // NTLM
-                        if (!wwwAuth.contains("Kerberos") && (wwwAuth.contains("NTLM") || (wwwAuth.contains("Negotiate")))) {
-                            newRealm = ntlmChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (wwwAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null)
-                                return;
-                        } else {
-                            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(request.getURI().getPath()).setMethodName(request.getMethod()).setUsePreemptiveAuth(true).parseWWWAuthenticateHeader(wwwAuth.get(0)).build();
-                        }
-
-                        final Realm nr = new Realm.RealmBuilder().clone(newRealm).setUri(URI.create(request.getUrl()).getPath()).build();
-
-                        log.debug("Sending authentication to {}", request.getUrl());
-                        AsyncCallable ac = new AsyncCallable(future) {
-                            public Object call() throws Exception {
-                                drainChannel(ctx, future);
-                                nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
-                                return null;
-                            }
-                        };
-
-                        if (future.isKeepAlive() && response.isChunked()) {
-                            // We must make sure there is no bytes left before executing the next request.
-                            ctx.setAttachment(ac);
-                        } else {
-                            ac.call();
-                        }
-                        return;
-                    }
-
-                    if (statusCode == 100) {
-                        future.getAndSetWriteHeaders(false);
-                        future.getAndSetWriteBody(true);
-                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
-                        return;
-                    }
-
-                    List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
-                    if (statusCode == 407 && realm != null && proxyAuth.size() > 0 && !future.getAndSetAuth(true)) {
-
-                        log.debug("Sending proxy authentication to {}", request.getUrl());
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-
-                        if (!proxyAuth.contains("Kerberos") && (proxyAuth.get(0).contains("NTLM") || (proxyAuth.contains("Negotiate")))) {
-                            newRealm = ntlmProxyChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (proxyAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null)
-                                return;
-                        } else {
-                            newRealm = future.getRequest().getRealm();
-                        }
-
-                        Request req = builder.setHeaders(headers).setRealm(newRealm).build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(true);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT) && statusCode == 200) {
-
-                        log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
-
-                        if (future.isKeepAlive()) {
-                            future.attachChannel(ctx.getChannel(), true);
-                        }
-
-                        try {
-                            log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
-                            upgradeProtocol(ctx.getChannel().getPipeline(), request.getURI().getScheme());
-                        } catch (Throwable ex) {
-                            abort(future, ex);
-                        }
-                        Request req = builder.build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(false);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (redirect(request, future, response, ctx))
-                        return;
-
-                    if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (updateHeadersAndInterrupt(handler, responseHeaders)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (!response.isChunked()) {
-                        if (response.getContent().readableBytes() != 0) {
-                            updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        }
-                        finishUpdate(future, ctx, false);
-                        return;
-                    }
-
-                    if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
-                        updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        markAsDone(future, ctx);
-                        drainChannel(ctx, future);
-                    }
-
-                } else if (e.getMessage() instanceof HttpChunk) {
-                    HttpChunk chunk = (HttpChunk) e.getMessage();
-
-                    if (handler != null) {
-                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
-                            if (chunk instanceof DefaultHttpChunkTrailer) {
-                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(), future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
-                            }
-                            finishUpdate(future, ctx, !chunk.isLast());
-                        }
-                    }
-                }
-            } catch (Exception t) {
-                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(IOException.class.cast(t)).build();
-                    fc = handleIoException(fc, future);
-
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-                }
-
-                try {
-                    abort(future, t);
-                } finally {
-                    finishUpdate(future, ctx, false);
-                    throw t;
-                }
-            }
-        }
-
-        // @Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-        }
-
-        // @Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-        }
-    }
-
-    private final class WebSocketProtocol implements Protocol {
-        private static final byte OPCODE_CONT = 0x0;
-        private static final byte OPCODE_TEXT = 0x1;
-        private static final byte OPCODE_BINARY = 0x2;
-        private static final byte OPCODE_UNKNOWN = -1;
-        protected byte pendingOpcode = OPCODE_UNKNOWN;
-
-        // We don't need to synchronize as replacing the "ws-decoder" will process using the same thread.
-        private void invokeOnSucces(ChannelHandlerContext ctx, WebSocketUpgradeHandler h) {
-            if (!h.touchSuccess()) {
-                try {
-                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
-                } catch (Exception ex) {
-                    NettyAsyncHttpProvider.this.log.warn("onSuccess unexexpected exception", ex);
-                }
-            }
-        }
-
-        // @Override
-        public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-            NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
-            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-            Request request = future.getRequest();
-
-            if (e.getMessage() instanceof HttpResponse) {
-                HttpResponse response = (HttpResponse) e.getMessage();
-
-                HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(h).request(request).responseStatus(s).responseHeaders(responseHeaders).build();
-                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                    try {
-                        fc = asyncFilter.filter(fc);
-                        if (fc == null) {
-                            throw new NullPointerException("FilterContext is null");
-                        }
-                    } catch (FilterException efe) {
-                        abort(future, efe);
-                    }
-
-                }
-
-                // The handler may have been wrapped.
-                future.setAsyncHandler(fc.getAsyncHandler());
-
-                // The request has changed
-                if (fc.replayRequest()) {
-                    replayRequest(future, fc, response, ctx);
-                    return;
-                }
-
-                future.setHttpResponse(response);
-                if (redirect(request, future, response, ctx))
-                    return;
-
-                final org.jboss.netty.handler.codec.http.HttpResponseStatus status = new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
-
-                final boolean validStatus = response.getStatus().equals(status);
-                final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
-                String c = response.getHeader(HttpHeaders.Names.CONNECTION);
-                if (c == null) {
-                    c = response.getHeader("connection");
-                }
-
-                final boolean validConnection = c == null ? false : c.equalsIgnoreCase(HttpHeaders.Values.UPGRADE);
-
-                s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                final boolean statusReceived = h.onStatusReceived(s) == STATE.UPGRADE;
-
-                final boolean headerOK = h.onHeadersReceived(responseHeaders) == STATE.CONTINUE;
-                if (!headerOK || !validStatus || !validUpgrade || !validConnection || !statusReceived) {
-                    abort(future, new IOException("Invalid handshake response"));
-                    return;
-                }
-
-                String accept = response.getHeader("Sec-WebSocket-Accept");
-                String key = WebSocketUtil.getAcceptKey(future.getNettyRequest().getHeader(WEBSOCKET_KEY));
-                if (accept == null || !accept.equals(key)) {
-                    throw new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key));
-                }
-
-                ctx.getPipeline().replace("http-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
-                ctx.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder", new WebSocket08FrameDecoder(false, false));
-
-                invokeOnSucces(ctx, h);
-                future.done(null);
-            } else if (e.getMessage() instanceof WebSocketFrame) {
-
-                invokeOnSucces(ctx, h);
-
-                final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
-
-                if (frame instanceof TextWebSocketFrame) {
-                    pendingOpcode = OPCODE_TEXT;
-                } else if (frame instanceof BinaryWebSocketFrame) {
-                    pendingOpcode = OPCODE_BINARY;
-                }
-
-                HttpChunk webSocketChunk = new HttpChunk() {
-                    private ChannelBuffer content;
-
-                    // @Override
-                    public boolean isLast() {
-                        return false;
-                    }
-
-                    // @Override
-                    public ChannelBuffer getContent() {
-                        return content;
-                    }
-
-                    // @Override
-                    public void setContent(ChannelBuffer content) {
-                        this.content = content;
-                    }
-                };
-
-                if (frame.getBinaryData() != null) {
-                    webSocketChunk.setContent(ChannelBuffers.wrappedBuffer(frame.getBinaryData()));
-                    ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
-                    h.onBodyPartReceived(rp);
-
-                    NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-
-                    if (webSocket != null) {
-                        if (pendingOpcode == OPCODE_BINARY) {
-                            webSocket.onBinaryFragment(rp.getBodyPartBytes(), frame.isFinalFragment());
-                        } else {
-                            webSocket.onTextFragment(frame.getBinaryData().toString(UTF8), frame.isFinalFragment());
-                        }
-
-                        if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
-                            try {
-                                ctx.setAttachment(DiscardEvent.class);
-                                webSocket.onClose(CloseWebSocketFrame.class.cast(frame).getStatusCode(), CloseWebSocketFrame.class.cast(frame).getReasonText());
-                            } catch (Throwable t) {
-                                // Swallow any exception that may comes from a Netty version released before 3.4.0
-                                log.trace("", t);
-                            }
-                        }
-                    } else {
-                        log.debug("UpgradeHandler returned a null NettyWebSocket ");
-                    }
-                }
-            } else {
-                log.error("Invalid attachment {}", ctx.getAttachment());
-            }
-        }
-
-        // @Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-            try {
-                log.warn("onError {}", e);
-                if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                    return;
-                }
-
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-                if (webSocket != null) {
-                    webSocket.onError(e.getCause());
-                    webSocket.close();
-                }
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-
-        // @Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-            log.trace("onClose {}", e);
-            if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                return;
-            }
-
-            try {
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-
-                if (ctx.getAttachment() == null || !DiscardEvent.class.isAssignableFrom(ctx.getAttachment().getClass()))
-                    webSocket.close(1006, "Connection was closed abnormally (that is, with no close frame being sent).");
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-    }
-
-    private static boolean isWebSocket(URI uri) {
-        return WEBSOCKET.equalsIgnoreCase(uri.getScheme()) || WEBSOCKET_SSL.equalsIgnoreCase(uri.getScheme());
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
+        return requestSender.sendRequest(request, asyncHandler, null, false);
     }
 
-    private static boolean isSecure(String scheme) {
-        return HTTPS.equalsIgnoreCase(scheme) || WEBSOCKET_SSL.equalsIgnoreCase(scheme);
+    public void flushChannelPoolPartition(String partitionId) {
+        channelManager.flushPartition(partitionId);
     }
 
-    private static boolean isSecure(URI uri) {
-        return isSecure(uri.getScheme());
+    public void flushChannelPoolPartitions(ChannelPoolPartitionSelector selector) {
+        channelManager.flushPartitions(selector);
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
old mode 100644
new mode 100755
index f338d570c..ce81243a5
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
@@ -1,184 +1,313 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.providers.netty;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.util.Timer;
+
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.ExecutorService;
-
-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.SSLEngineFactory;
+import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.providers.netty.response.EagerNettyResponseBodyPart;
+import org.asynchttpclient.providers.netty.response.LazyNettyResponseBodyPart;
+import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
+import org.asynchttpclient.providers.netty.ws.NettyWebSocket;
 
 /**
- * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
+ * This class can be used to pass Netty's internal configuration options. See
+ * Netty documentation for more information.
  */
-public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<ChannelOption<Object>, Object> {
 
-    private final static Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProviderConfig.class);
+    private final Map<ChannelOption<Object>, Object> properties = new HashMap<ChannelOption<Object>, Object>();
 
     /**
-     * Use Netty's blocking IO stategy.
+     * Add a property that will be used when the AsyncHttpClient initialize its
+     * {@link org.asynchttpclient.AsyncHttpProvider}
+     * 
+     * @param name the name of the property
+     * @param value the value of the property
+     * @return this instance of AsyncHttpProviderConfig
      */
-    private boolean useBlockingIO;
+    public NettyAsyncHttpProviderConfig addProperty(ChannelOption<Object> name, Object value) {
+        properties.put(name, value);
+        return this;
+    }
 
-    /**
-     * Allow configuring the Netty's socket channel factory.
-     */
-    private NioClientSocketChannelFactory socketChannelFactory;
+    @SuppressWarnings("unchecked")
+    public <T> NettyAsyncHttpProviderConfig addChannelOption(ChannelOption<T> name, T value) {
+        properties.put((ChannelOption<Object>) name, value);
+        return this;
+    }
 
     /**
-     * Allow configuring the Netty's boss executor service.
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
      */
-    private ExecutorService bossExecutorService;
+    public Object getProperty(ChannelOption<Object> name) {
+        return properties.get(name);
+    }
 
     /**
-     * HttpClientCodec's maxInitialLineLength
+     * Remove the value associated with the property's name
+     * 
+     * @param name
+     * @return true if removed
      */
-    private int maxInitialLineLength = 4096;
+    public Object removeProperty(ChannelOption<Object> name) {
+        return properties.remove(name);
+    }
 
     /**
-     * HttpClientCodec's maxHeaderSize
+     * Return the curent entry set.
+     * 
+     * @return a the curent entry set.
      */
-    private int maxHeaderSize = 8192;
+    public Set<Map.Entry<ChannelOption<Object>, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+
+    public static interface AdditionalChannelInitializer {
+
+        void initChannel(Channel ch) throws Exception;
+    }
+
+    public static interface ResponseBodyPartFactory {
+
+        NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+    }
+
+    public static class EagerResponseBodyPartFactory implements ResponseBodyPartFactory {
+
+        @Override
+        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+            return new EagerNettyResponseBodyPart(buf, last);
+        }
+    }
+
+    public static class LazyResponseBodyPartFactory implements ResponseBodyPartFactory {
+
+        @Override
+        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+            return new LazyNettyResponseBodyPart(buf, last);
+        }
+    }
+
+    public static interface NettyWebSocketFactory {
+        NettyWebSocket newNettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig);
+    }
+
+    public class DefaultNettyWebSocketFactory implements NettyWebSocketFactory {
+
+        @Override
+        public NettyWebSocket newNettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig) {
+            return new NettyWebSocket(channel, nettyConfig);
+        }
+    }
 
     /**
-     * HttpClientCodec's maxChunkSize
+     * Allow configuring the Netty's event loop.
      */
-    private int maxChunkSize = 8192;
+    private EventLoopGroup eventLoopGroup;
+
+    private AdditionalChannelInitializer httpAdditionalChannelInitializer;
+    private AdditionalChannelInitializer wsAdditionalChannelInitializer;
+    private AdditionalChannelInitializer httpsAdditionalChannelInitializer;
+    private AdditionalChannelInitializer wssAdditionalChannelInitializer;
 
     /**
-     * Use direct {@link java.nio.ByteBuffer}
+     * Allow configuring Netty's HttpClientCodecs.
      */
-    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
+    private int httpClientCodecMaxInitialLineLength = 4096;
+    private int httpClientCodecMaxHeaderSize = 8192;
+    private int httpClientCodecMaxChunkSize = 8192;
+
+    private ResponseBodyPartFactory bodyPartFactory = new EagerResponseBodyPartFactory();
+
+    private ChannelPool channelPool;
 
     /**
-     * Allow nested request from any {@link org.asynchttpclient.AsyncHandler}
+     * Allow one to disable zero copy for bodies and use chunking instead
      */
-    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
+    private boolean disableZeroCopy;
+
+    private Timer nettyTimer;
+
+    private long handshakeTimeout;
+
+    private SSLEngineFactory sslEngineFactory;
 
     /**
-     * See {@link java.net.Socket#setReuseAddress(boolean)}
+     * chunkedFileChunkSize
      */
-    public final static String REUSE_ADDRESS = "reuseAddress";
+    private int chunkedFileChunkSize = 8192;
+
+    private NettyWebSocketFactory nettyWebSocketFactory = new DefaultNettyWebSocketFactory();
+
+    private int webSocketMaxBufferSize = 128000000;
 
-    private final Map<String, Object> properties = new HashMap<String, Object>();
+    private int webSocketMaxFrameSize = 10 * 1024;
 
-    public NettyAsyncHttpProviderConfig() {
-        properties.put(REUSE_ADDRESS, Boolean.FALSE);
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
     }
 
-    /**
-     * Add a property that will be used when the AsyncHttpClient initialize its {@link org.asynchttpclient.AsyncHttpProvider}
-     * 
-     * @param name
-     *            the name of the property
-     * @param value
-     *            the value of the property
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+    public void setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+        this.eventLoopGroup = eventLoopGroup;
+    }
 
-        if (name.equals(REUSE_ADDRESS) && value == Boolean.TRUE && System.getProperty("os.name").toLowerCase().contains("win")) {
-            LOGGER.warn("Can't enable {} on Windows", REUSE_ADDRESS);
-        } else {
-            properties.put(name, value);
-        }
+    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
+        return httpAdditionalChannelInitializer;
+    }
 
-        return this;
+    public void setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
+        this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
     }
 
-    /**
-     * Return the value associated with the property's name
-     * 
-     * @param name
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public Object getProperty(String name) {
-        return properties.get(name);
+    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
+        return wsAdditionalChannelInitializer;
     }
 
-    /**
-     * Remove the value associated with the property's name
-     * 
-     * @param name
-     * @return true if removed
-     */
-    public Object removeProperty(String name) {
-        return properties.remove(name);
+    public void setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
+        this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
     }
 
-    /**
-     * Return the curent entry set.
-     * 
-     * @return a the curent entry set.
-     */
-    public Set<Map.Entry<String, Object>> propertiesSet() {
-        return properties.entrySet();
+    public AdditionalChannelInitializer getHttpsAdditionalChannelInitializer() {
+        return httpsAdditionalChannelInitializer;
+    }
+
+    public void setHttpsAdditionalChannelInitializer(AdditionalChannelInitializer httpsAdditionalChannelInitializer) {
+        this.httpsAdditionalChannelInitializer = httpsAdditionalChannelInitializer;
+    }
+
+    public AdditionalChannelInitializer getWssAdditionalChannelInitializer() {
+        return wssAdditionalChannelInitializer;
     }
 
-    public boolean isUseBlockingIO() {
-        return useBlockingIO;
+    public void setWssAdditionalChannelInitializer(AdditionalChannelInitializer wssAdditionalChannelInitializer) {
+        this.wssAdditionalChannelInitializer = wssAdditionalChannelInitializer;
     }
 
-    public void setUseBlockingIO(boolean useBlockingIO) {
-        this.useBlockingIO = useBlockingIO;
+    public int getHttpClientCodecMaxInitialLineLength() {
+        return httpClientCodecMaxInitialLineLength;
     }
 
-    public NioClientSocketChannelFactory getSocketChannelFactory() {
-        return socketChannelFactory;
+    public void setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
+        this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
     }
 
-    public void setSocketChannelFactory(NioClientSocketChannelFactory socketChannelFactory) {
-        this.socketChannelFactory = socketChannelFactory;
+    public int getHttpClientCodecMaxHeaderSize() {
+        return httpClientCodecMaxHeaderSize;
     }
 
-    public ExecutorService getBossExecutorService() {
-        return bossExecutorService;
+    public void setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
+        this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
     }
 
-    public void setBossExecutorService(ExecutorService bossExecutorService) {
-        this.bossExecutorService = bossExecutorService;
+    public int getHttpClientCodecMaxChunkSize() {
+        return httpClientCodecMaxChunkSize;
     }
 
-    public int getMaxInitialLineLength() {
-        return maxInitialLineLength;
+    public void setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
+        this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
     }
 
-    public void setMaxInitialLineLength(int maxInitialLineLength) {
-        this.maxInitialLineLength = maxInitialLineLength;
+    public ResponseBodyPartFactory getBodyPartFactory() {
+        return bodyPartFactory;
     }
 
-    public int getMaxHeaderSize() {
-        return maxHeaderSize;
+    public void setBodyPartFactory(ResponseBodyPartFactory bodyPartFactory) {
+        this.bodyPartFactory = bodyPartFactory;
     }
 
-    public void setMaxHeaderSize(int maxHeaderSize) {
-        this.maxHeaderSize = maxHeaderSize;
+    public ChannelPool getChannelPool() {
+        return channelPool;
     }
 
-    public int getMaxChunkSize() {
-        return maxChunkSize;
+    public void setChannelPool(ChannelPool channelPool) {
+        this.channelPool = channelPool;
     }
 
-    public void setMaxChunkSize(int maxChunkSize) {
-        this.maxChunkSize = maxChunkSize;
+    public boolean isDisableZeroCopy() {
+        return disableZeroCopy;
+    }
+
+    public void setDisableZeroCopy(boolean disableZeroCopy) {
+        this.disableZeroCopy = disableZeroCopy;
+    }
+
+    public Timer getNettyTimer() {
+        return nettyTimer;
+    }
+
+    public void setNettyTimer(Timer nettyTimer) {
+        this.nettyTimer = nettyTimer;
+    }
+
+    public long getHandshakeTimeout() {
+        return handshakeTimeout;
+    }
+
+    public void setHandshakeTimeout(long handshakeTimeout) {
+        this.handshakeTimeout = handshakeTimeout;
+    }
+
+    public SSLEngineFactory getSslEngineFactory() {
+        return sslEngineFactory;
+    }
+
+    public void setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
+        this.sslEngineFactory = sslEngineFactory;
+    }
+
+    public int getChunkedFileChunkSize() {
+        return chunkedFileChunkSize;
+    }
+
+    public void setChunkedFileChunkSize(int chunkedFileChunkSize) {
+        this.chunkedFileChunkSize = chunkedFileChunkSize;
+    }
+
+    public NettyWebSocketFactory getNettyWebSocketFactory() {
+        return nettyWebSocketFactory;
+    }
+
+    public void setNettyWebSocketFactory(NettyWebSocketFactory nettyWebSocketFactory) {
+        this.nettyWebSocketFactory = nettyWebSocketFactory;
+    }
+
+    public int getWebSocketMaxBufferSize() {
+        return webSocketMaxBufferSize;
+    }
+
+    public void setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
+        this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+    }
+
+    public int getWebSocketMaxFrameSize() {
+        return webSocketMaxFrameSize;
+    }
+    public void setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
+        this.webSocketMaxFrameSize = webSocketMaxFrameSize;
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java
deleted file mode 100644
index 5e3a7cfa6..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.providers.netty;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.net.ssl.HostnameVerifier;
-
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureListener;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.ssl.SslHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.util.ProxyUtils;
-
-
-/**
- * Non Blocking connect.
- */
-final class NettyConnectListener<T> implements ChannelFutureListener {
-    private final static Logger logger = LoggerFactory.getLogger(NettyConnectListener.class);
-    private final AsyncHttpClientConfig config;
-    private final NettyResponseFuture<T> future;
-    private final HttpRequest nettyRequest;
-    private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
-
-    private NettyConnectListener(AsyncHttpClientConfig config,
-                                 NettyResponseFuture<T> future,
-                                 HttpRequest nettyRequest) {
-        this.config = config;
-        this.future = future;
-        this.nettyRequest = nettyRequest;
-    }
-
-    public NettyResponseFuture<T> future() {
-        return future;
-    }
-
-    public final void operationComplete(ChannelFuture f) throws Exception {
-        if (f.isSuccess()) {
-            Channel channel = f.getChannel();
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(future);
-            SslHandler sslHandler = (SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
-            if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
-                ((SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
-                return;
-            }
-
-            HostnameVerifier v = config.getHostnameVerifier();
-            if (sslHandler != null) {
-                if (!v.verify(future.getURI().getHost(), sslHandler.getEngine().getSession())) {
-                	ConnectException exception = new ConnectException("HostnameVerifier exception.");
-                	future.abort(exception);
-                	throw exception;
-                }
-            }
-
-            future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
-        } else {
-            Throwable cause = f.getCause();
-
-            logger.debug("Trying to recover a dead cached channel {} with a retry value of {} ", f.getChannel(), future.canRetry());
-            if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
-                    || ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                    || future.getState() != NettyResponseFuture.STATE.NEW)) {
-
-                logger.debug("Retrying {} ", nettyRequest);
-                if (future.provider().remotelyClosed(f.getChannel(), future)) {
-                    return;
-                }
-            }
-
-            logger.debug("Failed to recover from exception: {} with channel {}", cause, f.getChannel());
-
-            boolean printCause = f.getCause() != null && cause.getMessage() != null;
-            ConnectException e = new ConnectException(printCause ? cause.getMessage() + " to " + future.getURI().toString() : future.getURI().toString());
-            if (cause != null) {
-                e.initCause(cause);
-            }
-            future.abort(e);
-        }
-    }
-
-    public static class Builder<T> {
-        private final AsyncHttpClientConfig config;
-
-        private final Request request;
-        private final AsyncHandler<T> asyncHandler;
-        private NettyResponseFuture<T> future;
-        private final NettyAsyncHttpProvider provider;
-        private final ChannelBuffer buffer;
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = null;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyResponseFuture<T> future, NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public NettyConnectListener<T> build(final URI uri) throws IOException {
-            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
-            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer, proxyServer);
-            if (future == null) {
-                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider, proxyServer);
-            } else {
-                future.setNettyRequest(nettyRequest);
-                future.setRequest(request);
-            }
-            return new NettyConnectListener<T>(config, future, nettyRequest);
-        }
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java
deleted file mode 100644
index 5afd504df..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import static org.asynchttpclient.util.DateUtil.millisTime;
-import org.asynchttpclient.ConnectionsPool;
-import org.jboss.netty.channel.Channel;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * A simple implementation of {@link org.asynchttpclient.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
- */
-public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
-
-    private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
-    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
-    private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
-    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-    private final Timer idleConnectionDetector = new Timer(true);
-    private final boolean sslConnectionPoolEnabled;
-    private final int maxTotalConnections;
-    private final int maxConnectionPerHost;
-    private final int maxConnectionLifeTimeInMs;
-    private final long maxIdleTime;
-
-    public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
-        this(provider.getConfig().getMaxTotalConnections(), provider.getConfig().getMaxConnectionPerHost(), provider.getConfig().getIdleConnectionInPoolTimeoutInMs(), provider.getConfig().isSslConnectionPoolEnabled(), provider.getConfig().getMaxConnectionLifeTimeInMs());
-    }
-
-    public NettyConnectionsPool(int maxTotalConnections, int maxConnectionPerHost, long maxIdleTime, boolean sslConnectionPoolEnabled, int maxConnectionLifeTimeInMs) {
-        this.maxTotalConnections = maxTotalConnections;
-        this.maxConnectionPerHost = maxConnectionPerHost;
-        this.sslConnectionPoolEnabled = sslConnectionPoolEnabled;
-        this.maxIdleTime = maxIdleTime;
-        this.maxConnectionLifeTimeInMs = maxConnectionLifeTimeInMs;
-        this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
-    }
-
-    private static class IdleChannel {
-        final String uri;
-        final Channel channel;
-        final long start;
-
-        IdleChannel(String uri, Channel channel) {
-            this.uri = uri;
-            this.channel = channel;
-            this.start = millisTime();
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof IdleChannel)) return false;
-
-            IdleChannel that = (IdleChannel) o;
-
-            if (channel != null ? !channel.equals(that.channel) : that.channel != null) return false;
-
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            return channel != null ? channel.hashCode() : 0;
-        }
-    }
-
-    private class IdleChannelDetector extends TimerTask {
-        @Override
-        public void run() {
-            try {
-                if (isClosed.get()) return;
-
-                if (log.isDebugEnabled()) {
-                    Set<String> keys = connectionsPool.keySet();
-
-                    for (String s : keys) {
-                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
-                    }
-                }
-
-                List<IdleChannel> channelsInTimeout = new ArrayList<IdleChannel>();
-                long currentTime = millisTime();
-
-                for (IdleChannel idleChannel : channel2IdleChannel.values()) {
-                    long age = currentTime - idleChannel.start;
-                    if (age > maxIdleTime) {
-
-                        log.debug("Adding Candidate Idle Channel {}", idleChannel.channel);
-
-                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
-                        channelsInTimeout.add(idleChannel);
-                    }
-                }
-                long endConcurrentLoop = millisTime();
-
-                for (IdleChannel idleChannel : channelsInTimeout) {
-                    Object attachment = idleChannel.channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
-                    if (attachment != null) {
-                        if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
-                            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
-
-                            if (!future.isDone() && !future.isCancelled()) {
-                                log.debug("Future not in appropriate state %s\n", future);
-                                continue;
-                            }
-                        }
-                    }
-
-                    if (remove(idleChannel)) {
-                        log.debug("Closing Idle Channel {}", idleChannel.channel);
-                        close(idleChannel.channel);
-                    }
-                }
-
-                if (log.isTraceEnabled()) {
-                    int openChannels = 0;
-                    for (ConcurrentLinkedQueue<IdleChannel> hostChannels: connectionsPool.values()) {
-                        openChannels += hostChannels.size();
-                    }
-                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
-                            openChannels, channelsInTimeout.size(), endConcurrentLoop - currentTime, millisTime() - endConcurrentLoop));
-                }
-            } catch (Throwable t) {
-                log.error("uncaught exception!", t);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean offer(String uri, Channel channel) {
-        if (isClosed.get()) return false;
-
-        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
-            return false;
-        }
-
-        Long createTime = channel2CreationDate.get(channel);
-        if (createTime == null){
-           channel2CreationDate.putIfAbsent(channel, millisTime());
-        }
-        else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < millisTime() ) {
-           log.debug("Channel {} expired", channel);
-           return false;
-        }
-
-        log.debug("Adding uri: {} for channel {}", uri, channel);
-        channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
-
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
-        if (idleConnectionForHost == null) {
-            ConcurrentLinkedQueue<IdleChannel> newPool = new ConcurrentLinkedQueue<IdleChannel>();
-            idleConnectionForHost = connectionsPool.putIfAbsent(uri, newPool);
-            if (idleConnectionForHost == null) idleConnectionForHost = newPool;
-        }
-
-        boolean added;
-        int size = idleConnectionForHost.size();
-        if (maxConnectionPerHost == -1 || size < maxConnectionPerHost) {
-            IdleChannel idleChannel = new IdleChannel(uri, channel);
-            synchronized (idleConnectionForHost) {
-                added = idleConnectionForHost.add(idleChannel);
-
-                if (channel2IdleChannel.put(channel, idleChannel) != null) {
-                    log.error("Channel {} already exists in the connections pool!", channel);
-                }
-            }
-        } else {
-            log.debug("Maximum number of requests per host reached {} for {}", maxConnectionPerHost, uri);
-            added = false;
-        }
-        return added;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Channel poll(String uri) {
-        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
-            return null;
-        }
-
-        IdleChannel idleChannel = null;
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
-        if (idleConnectionForHost != null) {
-            boolean poolEmpty = false;
-            while (!poolEmpty && idleChannel == null) {
-                if (idleConnectionForHost.size() > 0) {
-                    synchronized (idleConnectionForHost) {
-                        idleChannel = idleConnectionForHost.poll();
-                        if (idleChannel != null) {
-                            channel2IdleChannel.remove(idleChannel.channel);
-                        }
-                    }
-                }
-
-                if (idleChannel == null) {
-                    poolEmpty = true;
-                } else if (!idleChannel.channel.isConnected() || !idleChannel.channel.isOpen()) {
-                    idleChannel = null;
-                    log.trace("Channel not connected or not opened!");
-                }
-            }
-        }
-        return idleChannel != null ? idleChannel.channel : null;
-    }
-
-    private boolean remove(IdleChannel pooledChannel) {
-        if (pooledChannel == null || isClosed.get()) return false;
-
-        boolean isRemoved = false;
-        ConcurrentLinkedQueue<IdleChannel> pooledConnectionForHost = connectionsPool.get(pooledChannel.uri);
-        if (pooledConnectionForHost != null) {
-            isRemoved = pooledConnectionForHost.remove(pooledChannel);
-        }
-        isRemoved |= channel2IdleChannel.remove(pooledChannel.channel) != null;
-        return isRemoved;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean removeAll(Channel channel) {
-        channel2CreationDate.remove(channel);
-        return !isClosed.get() && remove(channel2IdleChannel.get(channel));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean canCacheConnection() {
-        if (!isClosed.get() && maxTotalConnections != -1 && channel2IdleChannel.size() >= maxTotalConnections) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void destroy() {
-        if (isClosed.getAndSet(true)) return;
-
-        // stop timer
-        idleConnectionDetector.cancel();
-        idleConnectionDetector.purge();
-
-        for (Channel channel : channel2IdleChannel.keySet()) {
-            close(channel);
-        }
-        connectionsPool.clear();
-        channel2IdleChannel.clear();
-        channel2CreationDate.clear();
-    }
-
-    private void close(Channel channel) {
-        try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
-            channel2CreationDate.remove(channel);
-            channel.close();
-        } catch (Throwable t) {
-            // noop
-        }
-    }
-
-    public final String toString() {
-        return String.format("NettyConnectionPool: {pool-size: %d}", channel2IdleChannel.size());
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java
deleted file mode 100644
index 81b520fbc..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.buffer.ChannelBufferInputStream;
-import org.jboss.netty.buffer.ChannelBuffers;
-
-import org.asynchttpclient.Cookie;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.providers.ResponseBase;
-import org.asynchttpclient.providers.netty.util.ChannelBufferUtil;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
-
-/**
- * Wrapper around the {@link org.asynchttpclient.Response} API.
- */
-public class NettyResponse extends ResponseBase {
-
-    public NettyResponse(HttpResponseStatus status,
-                         HttpResponseHeaders headers,
-                         List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
-    }
-
-    /* @Override */
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, null);
-    }
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        // should be fine; except that it may split multi-byte chars (last char may become '?')
-        charset = calculateCharset(charset);
-        byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
-        return new String(b, charset);
-    }
-    
-    protected List<Cookie> buildCookies() {
-    	List<Cookie> cookies = new ArrayList<Cookie>();
-        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                // TODO: ask for parsed header
-                List<String> v = header.getValue();
-                for (String value : v) {
-                    cookies.addAll(CookieDecoder.decode(value));
-                }
-            }
-        }
-        return Collections.unmodifiableList(cookies);
-    }
-
-    /* @Override */
-    public byte[] getResponseBodyAsBytes() throws IOException {
-        return ChannelBufferUtil.channelBuffer2bytes(getResponseBodyAsChannelBuffer());
-    }
-
-    /* @Override */
-    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
-        return getResponseBodyAsChannelBuffer().toByteBuffer();
-    }
-
-    /* @Override */
-    public String getResponseBody() throws IOException {
-        return getResponseBody(null);
-    }
-
-    /* @Override */
-    public String getResponseBody(String charset) throws IOException {
-        return getResponseBodyAsChannelBuffer().toString(Charset.forName(calculateCharset(charset)));
-    }
-
-    /* @Override */
-    public InputStream getResponseBodyAsStream() throws IOException {
-        return new ChannelBufferInputStream(getResponseBodyAsChannelBuffer());
-    }
-
-    public ChannelBuffer getResponseBodyAsChannelBuffer() throws IOException {
-        ChannelBuffer b = null;
-        switch (bodyParts.size()) {
-        case 0:
-            b = ChannelBuffers.EMPTY_BUFFER;
-            break;
-        case 1:
-            b = ResponseBodyPart.class.cast(bodyParts.get(0)).getChannelBuffer();
-            break;
-        default:
-            ChannelBuffer[] channelBuffers = new ChannelBuffer[bodyParts.size()];
-            for (int i = 0; i < bodyParts.size(); i++) {
-                channelBuffers[i] = ResponseBodyPart.class.cast(bodyParts.get(i)).getChannelBuffer();
-            }
-            b = ChannelBuffers.wrappedBuffer(channelBuffers);
-        }
-
-        return b;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java
deleted file mode 100755
index ca7773af7..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java
+++ /dev/null
@@ -1,528 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty;
-
-import static org.asynchttpclient.util.DateUtil.millisTime;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.ConnectionPoolKeyStrategy;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
- * 
- * @param <V>
- */
-public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
-
-    private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
-    public final static String MAX_RETRY = "org.asynchttpclient.providers.netty.maxRetry";
-
-    enum STATE {
-        NEW, POOLED, RECONNECTED, CLOSED,
-    }
-
-    private final CountDownLatch latch = new CountDownLatch(1);
-    private final AtomicBoolean isDone = new AtomicBoolean(false);
-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
-    private AsyncHandler<V> asyncHandler;
-    private final int requestTimeoutInMs;
-    private final int idleConnectionTimeoutInMs;
-    private Request request;
-    private HttpRequest nettyRequest;
-    private final AtomicReference<V> content = new AtomicReference<V>();
-    private URI uri;
-    private boolean keepAlive = true;
-    private HttpResponse httpResponse;
-    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
-    private final AtomicInteger redirectCount = new AtomicInteger();
-    private volatile Future<?> reaperFuture;
-    private final AtomicBoolean inAuth = new AtomicBoolean(false);
-    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
-    private final AtomicLong touch = new AtomicLong(millisTime());
-    private final long start = millisTime();
-    private final NettyAsyncHttpProvider asyncHttpProvider;
-    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
-    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    private Channel channel;
-    private boolean reuseChannel = false;
-    private final AtomicInteger currentRetry = new AtomicInteger(0);
-    private final int maxRetry;
-    private boolean writeHeaders;
-    private boolean writeBody;
-    private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
-    private boolean allowConnect = false;
-    private final ConnectionPoolKeyStrategy connectionPoolKeyStrategy;
-    private final ProxyServer proxyServer;
-
-    public NettyResponseFuture(URI uri,//
-            Request request,//
-            AsyncHandler<V> asyncHandler,//
-            HttpRequest nettyRequest,//
-            int requestTimeoutInMs,//
-            int idleConnectionTimeoutInMs,//
-            NettyAsyncHttpProvider asyncHttpProvider,//
-            ConnectionPoolKeyStrategy connectionPoolKeyStrategy,//
-            ProxyServer proxyServer) {
-
-        this.asyncHandler = asyncHandler;
-        this.requestTimeoutInMs = requestTimeoutInMs;
-        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
-        this.request = request;
-        this.nettyRequest = nettyRequest;
-        this.uri = uri;
-        this.asyncHttpProvider = asyncHttpProvider;
-        this.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
-        this.proxyServer = proxyServer;
-
-        if (System.getProperty(MAX_RETRY) != null) {
-            maxRetry = Integer.valueOf(System.getProperty(MAX_RETRY));
-        } else {
-            maxRetry = asyncHttpProvider.getConfig().getMaxRequestRetry();
-        }
-        writeHeaders = true;
-        writeBody = true;
-    }
-
-    protected URI getURI() throws MalformedURLException {
-        return uri;
-    }
-
-    protected void setURI(URI uri) {
-        this.uri = uri;
-    }
-
-    public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
-        return connectionPoolKeyStrategy;
-    }
-
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean isDone() {
-        return isDone.get();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean isCancelled() {
-        return isCancelled.get();
-    }
-
-    void setAsyncHandler(AsyncHandler<V> asyncHandler) {
-        this.asyncHandler = asyncHandler;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean cancel(boolean force) {
-        cancelReaper();
-
-        if (isCancelled.get())
-            return false;
-
-        try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
-            channel.close();
-        } catch (Throwable t) {
-            // Ignore
-        }
-        if (!throwableCalled.getAndSet(true)) {
-            try {
-                asyncHandler.onThrowable(new CancellationException());
-            } catch (Throwable t) {
-                logger.warn("cancel", t);
-            }
-        }
-        latch.countDown();
-        isCancelled.set(true);
-        super.done();
-        return true;
-    }
-
-    /**
-     * Is the Future still valid
-     * 
-     * @return <code>true</code> if response has expired and should be terminated.
-     */
-    public boolean hasExpired() {
-        long now = millisTime();
-        return hasConnectionIdleTimedOut(now) || hasRequestTimedOut(now);
-    }
-
-    public boolean hasConnectionIdleTimedOut(long now) {
-        return idleConnectionTimeoutInMs != -1 && (now - touch.get()) >= idleConnectionTimeoutInMs;
-    }
-
-    public boolean hasRequestTimedOut(long now) {
-        return requestTimeoutInMs != -1 && (now - start) >= requestTimeoutInMs;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public V get() throws InterruptedException, ExecutionException {
-        try {
-            return get(requestTimeoutInMs, TimeUnit.MILLISECONDS);
-        } catch (TimeoutException e) {
-            cancelReaper();
-            throw new ExecutionException(e);
-        }
-    }
-
-    void cancelReaper() {
-        if (reaperFuture != null) {
-            reaperFuture.cancel(false);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
-        if (!isDone() && !isCancelled()) {
-            boolean expired = false;
-            if (l == -1) {
-                latch.await();
-            } else {
-                expired = !latch.await(l, tu);
-            }
-
-            if (expired) {
-                isCancelled.set(true);
-                try {
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
-                    channel.close();
-                } catch (Throwable t) {
-                    // Ignore
-                }
-                TimeoutException te = new TimeoutException(String.format("No response received after %s %s", l, tu.name().toLowerCase()));
-                if (!throwableCalled.getAndSet(true)) {
-                    try {
-                        asyncHandler.onThrowable(te);
-                    } catch (Throwable t) {
-                        logger.debug("asyncHandler.onThrowable", t);
-                    } finally {
-                        cancelReaper();
-                        throw new ExecutionException(te);
-                    }
-                }
-            }
-            isDone.set(true);
-
-            ExecutionException e = exEx.getAndSet(null);
-            if (e != null) {
-                throw e;
-            }
-        }
-        return getContent();
-    }
-
-    V getContent() throws ExecutionException {
-        ExecutionException e = exEx.getAndSet(null);
-        if (e != null) {
-            throw e;
-        }
-
-        V update = content.get();
-        // No more retry
-        currentRetry.set(maxRetry);
-        if (exEx.get() == null && !contentProcessed.getAndSet(true)) {
-            try {
-                update = asyncHandler.onCompleted();
-            } catch (Throwable ex) {
-                if (!throwableCalled.getAndSet(true)) {
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        logger.debug("asyncHandler.onThrowable", t);
-                    } finally {
-                        cancelReaper();
-                        throw new RuntimeException(ex);
-                    }
-                }
-            }
-            content.compareAndSet(null, update);
-        }
-        return update;
-    }
-
-    public final void done(Callable callable) {
-
-        Throwable exception = null;
-
-        try {
-            cancelReaper();
-
-            if (exEx.get() != null) {
-                return;
-            }
-            getContent();
-            isDone.set(true);
-            if (callable != null) {
-                try {
-                    callable.call();
-                } catch (Exception ex) {
-                    exception = ex;
-                }
-            }
-        } catch (ExecutionException t) {
-            return;
-        } catch (RuntimeException t) {
-            exception = t.getCause() != null ? t.getCause() : t;
-
-        } finally {
-            latch.countDown();
-        }
-
-        if (exception != null)
-            exEx.compareAndSet(null, new ExecutionException(exception));
-
-        super.done();
-    }
-
-    public final void abort(final Throwable t) {
-        cancelReaper();
-
-        if (isDone.get() || isCancelled.get())
-            return;
-
-        exEx.compareAndSet(null, new ExecutionException(t));
-        if (!throwableCalled.getAndSet(true)) {
-            try {
-                asyncHandler.onThrowable(t);
-            } catch (Throwable te) {
-                logger.debug("asyncHandler.onThrowable", te);
-            } finally {
-                isCancelled.set(true);
-            }
-        }
-        latch.countDown();
-        super.done();
-    }
-
-    public void content(V v) {
-        content.set(v);
-    }
-
-    protected final Request getRequest() {
-        return request;
-    }
-
-    public final HttpRequest getNettyRequest() {
-        return nettyRequest;
-    }
-
-    protected final void setNettyRequest(HttpRequest nettyRequest) {
-        this.nettyRequest = nettyRequest;
-    }
-
-    protected final AsyncHandler<V> getAsyncHandler() {
-        return asyncHandler;
-    }
-
-    protected final boolean isKeepAlive() {
-        return keepAlive;
-    }
-
-    protected final void setKeepAlive(final boolean keepAlive) {
-        this.keepAlive = keepAlive;
-    }
-
-    protected final HttpResponse getHttpResponse() {
-        return httpResponse;
-    }
-
-    protected final void setHttpResponse(final HttpResponse httpResponse) {
-        this.httpResponse = httpResponse;
-    }
-
-    protected int incrementAndGetCurrentRedirectCount() {
-        return redirectCount.incrementAndGet();
-    }
-
-    protected void setReaperFuture(Future<?> reaperFuture) {
-        cancelReaper();
-        this.reaperFuture = reaperFuture;
-    }
-
-    protected boolean isInAuth() {
-        return inAuth.get();
-    }
-
-    protected boolean getAndSetAuth(boolean inDigestAuth) {
-        return inAuth.getAndSet(inDigestAuth);
-    }
-
-    protected STATE getState() {
-        return state.get();
-    }
-
-    protected void setState(STATE state) {
-        this.state.set(state);
-    }
-
-    public boolean getAndSetStatusReceived(boolean sr) {
-        return statusReceived.getAndSet(sr);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public void touch() {
-        touch.set(millisTime());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
-        boolean b = this.writeHeaders;
-        this.writeHeaders = writeHeaders;
-        return b;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteBody(boolean writeBody) {
-        boolean b = this.writeBody;
-        this.writeBody = writeBody;
-        return b;
-    }
-
-    protected NettyAsyncHttpProvider provider() {
-        return asyncHttpProvider;
-    }
-
-    protected void attachChannel(Channel channel) {
-        this.channel = channel;
-    }
-
-    public void setReuseChannel(boolean reuseChannel) {
-        this.reuseChannel = reuseChannel;
-    }
-
-    public boolean isConnectAllowed() {
-        return allowConnect;
-    }
-
-    public void setConnectAllowed(boolean allowConnect) {
-        this.allowConnect = allowConnect;
-    }
-
-    protected void attachChannel(Channel channel, boolean reuseChannel) {
-        this.channel = channel;
-        this.reuseChannel = reuseChannel;
-    }
-
-    protected Channel channel() {
-        return channel;
-    }
-
-    protected boolean reuseChannel() {
-        return reuseChannel;
-    }
-
-    protected boolean canRetry() {
-        if (currentRetry.incrementAndGet() > maxRetry) {
-            return false;
-        }
-        return true;
-    }
-
-    public void setRequest(Request request) {
-        this.request = request;
-    }
-
-    /**
-     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can recover from that exception.
-     * 
-     * @return true if that {@link Future} cannot be recovered.
-     */
-    public boolean cannotBeReplay() {
-        return isDone() || !canRetry() || isCancelled() || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0) || isInAuth();
-    }
-
-    public long getStart() {
-        return start;
-    }
-
-    public long getRequestTimeoutInMs() {
-        return requestTimeoutInMs;
-    }
-
-    public long getIdleConnectionTimeoutInMs() {
-        return idleConnectionTimeoutInMs;
-    }
-
-    @Override
-    public String toString() {
-        return "NettyResponseFuture{" + //
-                "currentRetry=" + currentRetry + //
-                ",\n\tisDone=" + isDone + //
-                ",\n\tisCancelled=" + isCancelled + //
-                ",\n\tasyncHandler=" + asyncHandler + //
-                ",\n\trequestTimeoutInMs=" + requestTimeoutInMs + //
-                ",\n\tnettyRequest=" + nettyRequest + //
-                ",\n\tcontent=" + content + //
-                ",\n\turi=" + uri + //
-                ",\n\tkeepAlive=" + keepAlive + //
-                ",\n\thttpResponse=" + httpResponse + //
-                ",\n\texEx=" + exEx + //
-                ",\n\tredirectCount=" + redirectCount + //
-                ",\n\treaperFuture=" + reaperFuture + //
-                ",\n\tinAuth=" + inAuth + //
-                ",\n\tstatusReceived=" + statusReceived + //
-                ",\n\ttouch=" + touch + //
-                '}';
-    }
-
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java
deleted file mode 100644
index 8ae4f1ee0..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketByteListener;
-import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketTextListener;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.PingWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.PongWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.ByteArrayOutputStream;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import static org.jboss.netty.buffer.ChannelBuffers.wrappedBuffer;
-
-public class NettyWebSocket implements WebSocket {
-    private final static Logger logger = LoggerFactory.getLogger(NettyWebSocket.class);
-
-    private final Channel channel;
-    private final ConcurrentLinkedQueue<WebSocketListener> listeners = new ConcurrentLinkedQueue<WebSocketListener>();
-
-    private StringBuilder textBuffer;
-    private ByteArrayOutputStream byteBuffer;
-    private int maxBufferSize = 128000000;
-
-    public NettyWebSocket(Channel channel) {
-        this.channel = channel;
-    }
-
-    // @Override
-    public WebSocket sendMessage(byte[] message) {
-        channel.write(new BinaryWebSocketFrame(wrappedBuffer(message)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket stream(byte[] fragment, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket sendTextMessage(String message) {
-        channel.write(new TextWebSocketFrame(message));
-        return this;
-    }
-
-    // @Override
-    public WebSocket streamText(String fragment, boolean last) {
-        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
-    }
-
-    // @Override
-    public WebSocket sendPing(byte[] payload) {
-        channel.write(new PingWebSocketFrame(wrappedBuffer(payload)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket sendPong(byte[] payload) {
-        channel.write(new PongWebSocketFrame(wrappedBuffer(payload)));
-        return this;
-    }
-
-    // @Override
-    public WebSocket addWebSocketListener(WebSocketListener l) {
-        listeners.add(l);
-        return this;
-    }
-
-    // @Override
-    public WebSocket removeWebSocketListener(WebSocketListener l) {
-        listeners.remove(l);
-        return this;
-    }
-
-    public int getMaxBufferSize() {
-    	return maxBufferSize;
-    }
-    
-    public void setMaxBufferSize(int bufferSize) {
-    	maxBufferSize = bufferSize;
-    	
-    	if(maxBufferSize < 8192)
-    		maxBufferSize = 8192;
-    }
-    
-    // @Override
-    public boolean isOpen() {
-        return channel.isOpen();
-    }
-
-    // @Override
-    public void close() {
-        onClose();
-        listeners.clear();
-        try {
-            channel.write(new CloseWebSocketFrame());
-            channel.getCloseFuture().awaitUninterruptibly();
-        } finally {
-            channel.close();
-        }
-    }
-
-    // @Override
-    public void close(int statusCode, String reason) {
-        onClose(statusCode, reason);
-        listeners.clear();
-    }
-
-    protected void onBinaryFragment(byte[] message, boolean last) {
-        for (WebSocketListener l : listeners) {
-            if (WebSocketByteListener.class.isAssignableFrom(l.getClass())) {
-                try {
-                	WebSocketByteListener.class.cast(l).onFragment(message,last);
-                	
-                	if(byteBuffer == null) {
-                		byteBuffer = new ByteArrayOutputStream();
-                	}
-                	
-                	byteBuffer.write(message);
-                	
-                	if(byteBuffer.size() > maxBufferSize) {
-                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
-                        l.onError(e);
-                		this.close();
-                		return;
-                	}
-                	
-
-                	if(last) {
-                    	WebSocketByteListener.class.cast(l).onMessage(byteBuffer.toByteArray());
-                    	byteBuffer = null;
-                    	textBuffer = null;
-                	}
-                } catch (Exception ex) {
-                    l.onError(ex);
-                }
-            }
-        }
-    }
-
-    protected void onTextFragment(String message, boolean last) {
-        for (WebSocketListener l : listeners) {
-            if (WebSocketTextListener.class.isAssignableFrom(l.getClass())) {
-                try {
-                    WebSocketTextListener.class.cast(l).onFragment(message,last);
-                    
-                	if(textBuffer == null) {
-                		textBuffer = new StringBuilder();
-                	}
-                	
-                	textBuffer.append(message);
-                	
-                	if(textBuffer.length() > maxBufferSize) {
-                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
-                        l.onError(e);
-                		this.close();
-                		return;
-                	}
-                	
-                	if(last) {
-                    	WebSocketTextListener.class.cast(l).onMessage(textBuffer.toString());
-                    	byteBuffer = null;
-                    	textBuffer = null;
-                	}
-                } catch (Exception ex) {
-                    l.onError(ex);
-                }
-            }
-        }
-    }
-
-    protected void onError(Throwable t) {
-        for (WebSocketListener l : listeners) {
-            try {
-                l.onError(t);
-            } catch (Throwable t2) {
-                logger.error("", t2);
-            }
-
-        }
-    }
-
-    protected void onClose() {
-        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
-    }
-
-    protected void onClose(int code, String reason) {
-        for (WebSocketListener l : listeners) {
-            try {
-                if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(l.getClass())) {
-                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
-                }
-                l.onClose(this);
-            } catch (Throwable t) {
-                l.onError(t);
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "NettyWebSocket{" +
-                "channel=" + channel +
-                '}';
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java
deleted file mode 100644
index f9d6f39ef..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelStateEvent;
-import org.jboss.netty.channel.ExceptionEvent;
-import org.jboss.netty.channel.MessageEvent;
-
-public interface Protocol {
-
-    void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception;
-
-    void onError(ChannelHandlerContext ctx, ExceptionEvent e);
-
-    void onClose(ChannelHandlerContext ctx, ChannelStateEvent e);
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java
deleted file mode 100644
index b8d6411d8..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.handler.codec.http.HttpChunk;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.providers.netty.util.ChannelBufferUtil;
-
-/**
- * A callback class used when an HTTP response body is received.
- */
-public class ResponseBodyPart extends HttpResponseBodyPart {
-
-    private final HttpChunk chunk;
-    private final HttpResponse response;
-    private final AtomicReference<byte[]> bytes = new AtomicReference<byte[]>(null);
-    private final boolean isLast;
-    private boolean closeConnection = false;
-
-    /**
-     * Constructor used for non-chunked GET requests and HEAD requests.
-     */
-    public ResponseBodyPart(URI uri, HttpResponse response, AsyncHttpProvider provider, boolean last) {
-        this(uri, response, provider, null, last);
-    }
-
-    public ResponseBodyPart(URI uri, HttpResponse response, AsyncHttpProvider provider, HttpChunk chunk, boolean last) {
-        super(uri, provider);
-        this.chunk = chunk;
-        this.response = response;
-        isLast = last;
-    }
-    
-    /**
-     * Return the response body's part bytes received.
-     *
-     * @return the response body's part bytes received.
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        byte[] bp = bytes.get();
-        if (bp != null) {
-            return bp;
-        }
-
-        byte[] rb = ChannelBufferUtil.channelBuffer2bytes(getChannelBuffer());
-        bytes.set(rb);
-        return rb;
-    }
-
-    @Override
-    public InputStream readBodyPartBytes() {
-        return new ByteArrayInputStream(getBodyPartBytes());
-    }
-
-    @Override
-    public int length() {
-        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
-        return b.readableBytes();
-    }
-    
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-        ChannelBuffer b = getChannelBuffer();
-        int available = b.readableBytes();
-        if (available > 0) {
-            b.getBytes(b.readerIndex(), outputStream, available);
-        }
-        return available;
-    }
-
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return ByteBuffer.wrap(getBodyPartBytes());
-    }
-
-    public ChannelBuffer getChannelBuffer() {
-        return chunk != null ? chunk.getContent() : response.getContent();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isLast() {
-        return isLast;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsClosed() {
-        closeConnection = true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean closeUnderlyingConnection() {
-        return closeConnection;
-    }
-
-    protected HttpChunk chunk() {
-        return chunk;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java
deleted file mode 100644
index 971eadbf7..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-
-import java.net.URI;
-import java.util.Map;
-
-/**
- * A class that represent the HTTP headers.
- */
-public class ResponseHeaders extends HttpResponseHeaders {
-
-    private final HttpChunkTrailer trailingHeaders;
-    private final HttpResponse response;
-    private final FluentCaseInsensitiveStringsMap headers;
-
-    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider) {
-        super(uri, provider, false);
-        this.trailingHeaders = null;
-        this.response = response;
-        headers = computerHeaders();
-    }
-
-    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider, HttpChunkTrailer traillingHeaders) {
-        super(uri, provider, true);
-        this.trailingHeaders = traillingHeaders;
-        this.response = response;
-        headers = computerHeaders();
-    }
-
-    private FluentCaseInsensitiveStringsMap computerHeaders() {
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        for (Map.Entry<String, String> header: response.getHeaders()) {
-            h.add(header.getKey(), header.getValue());
-        }
-
-        if (trailingHeaders != null) {
-            for (Map.Entry<String, String> header:  trailingHeaders.getHeaders()) {
-                h.add(header.getKey(), header.getValue());
-            }
-        }
-
-        return h;
-    }
-
-    /**
-     * Return the HTTP header
-     *
-     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
-     */
-    @Override
-    public FluentCaseInsensitiveStringsMap getHeaders() {
-        return headers;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java
deleted file mode 100644
index 4cec5faf8..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseStatus;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-
-import java.net.URI;
-
-/**
- * A class that represent the HTTP response' status line (code + text)
- */
-public class ResponseStatus extends HttpResponseStatus {
-
-    private final HttpResponse response;
-
-    public ResponseStatus(URI uri, HttpResponse response, AsyncHttpProvider provider) {
-        super(uri, provider);
-        this.response = response;
-    }
-
-    /**
-     * Return the response status code
-     *
-     * @return the response status code
-     */
-    public int getStatusCode() {
-        return response.getStatus().getCode();
-    }
-
-    /**
-     * Return the response status text
-     *
-     * @return the response status text
-     */
-    public String getStatusText() {
-        return response.getStatus().getReasonPhrase();
-    }
-
-    @Override
-    public String getProtocolName() {
-        return response.getProtocolVersion().getProtocolName();
-    }
-
-    @Override
-    public int getProtocolMajorVersion() {
-        return response.getProtocolVersion().getMajorVersion();
-    }
-
-    @Override
-    public int getProtocolMinorVersion() {
-        return response.getProtocolVersion().getMinorVersion();
-    }
-
-    @Override
-    public String getProtocolText() {
-        return response.getProtocolVersion().getText();
-    }
-
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java
new file mode 100755
index 000000000..233407e0b
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java
@@ -0,0 +1,438 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel;
+
+import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isWebSocket;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.util.Timer;
+
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionPoolPartitioning;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.providers.netty.Callback;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.providers.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.providers.netty.channel.pool.DefaultChannelPool;
+import org.asynchttpclient.providers.netty.channel.pool.NoopChannelPool;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.handler.HttpProtocol;
+import org.asynchttpclient.providers.netty.handler.Processor;
+import org.asynchttpclient.providers.netty.handler.WebSocketProtocol;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.SslUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChannelManager {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
+    public static final String HTTP_HANDLER = "httpHandler";
+    public static final String SSL_HANDLER = "sslHandler";
+    public static final String HTTP_PROCESSOR = "httpProcessor";
+    public static final String WS_PROCESSOR = "wsProcessor";
+    public static final String DEFLATER_HANDLER = "deflater";
+    public static final String INFLATER_HANDLER = "inflater";
+    public static final String CHUNKED_WRITER_HANDLER = "chunkedWriter";
+    public static final String WS_DECODER_HANDLER = "ws-decoder";
+    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
+    public static final String WS_ENCODER_HANDLER = "ws-encoder";
+
+    private final AsyncHttpClientConfig config;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+
+    private final EventLoopGroup eventLoopGroup;
+    private final boolean allowReleaseEventLoopGroup;
+
+    private final Bootstrap plainBootstrap;
+    private final Bootstrap secureBootstrap;
+    private final Bootstrap webSocketBootstrap;
+    private final Bootstrap secureWebSocketBootstrap;
+
+    private final long handshakeTimeout;
+
+    private final ChannelPool channelPool;
+    private final boolean maxConnectionsEnabled;
+    private final Semaphore freeChannels;
+    private final ChannelGroup openChannels;
+    private final boolean maxConnectionsPerHostEnabled;
+    private final ConcurrentHashMap<String, Semaphore> freeChannelsPerHost;
+    private final ConcurrentHashMap<Channel, String> channel2KeyPool;
+
+    private Processor wsProcessor;
+
+    public ChannelManager(AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, Timer nettyTimer) {
+
+        this.config = config;
+        this.nettyConfig = nettyConfig;
+
+        ChannelPool channelPool = nettyConfig.getChannelPool();
+        if (channelPool == null && config.isAllowPoolingConnections()) {
+            channelPool = new DefaultChannelPool(config, nettyTimer);
+        } else if (channelPool == null) {
+            channelPool = new NoopChannelPool();
+        }
+        this.channelPool = channelPool;
+
+        maxConnectionsEnabled = config.getMaxConnections() > 0;
+        maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
+
+        if (maxConnectionsEnabled) {
+            openChannels = new CleanupChannelGroup("asyncHttpClient") {
+                @Override
+                public boolean remove(Object o) {
+                    boolean removed = super.remove(o);
+                    if (removed) {
+                        freeChannels.release();
+                        if (maxConnectionsPerHostEnabled) {
+                            String poolKey = channel2KeyPool.remove(Channel.class.cast(o));
+                            if (poolKey != null) {
+                                Semaphore freeChannelsForHost = freeChannelsPerHost.get(poolKey);
+                                if (freeChannelsForHost != null)
+                                    freeChannelsForHost.release();
+                            }
+                        }
+                    }
+                    return removed;
+                }
+            };
+            freeChannels = new Semaphore(config.getMaxConnections());
+        } else {
+            openChannels = new CleanupChannelGroup("asyncHttpClient");
+            freeChannels = null;
+        }
+
+        if (maxConnectionsPerHostEnabled) {
+            freeChannelsPerHost = new ConcurrentHashMap<String, Semaphore>();
+            channel2KeyPool = new ConcurrentHashMap<Channel, String>();
+        } else {
+            freeChannelsPerHost = null;
+            channel2KeyPool = null;
+        }
+
+        handshakeTimeout = nettyConfig.getHandshakeTimeout();
+
+        // check if external EventLoopGroup is defined
+        allowReleaseEventLoopGroup = nettyConfig.getEventLoopGroup() == null;
+        eventLoopGroup = allowReleaseEventLoopGroup ? new NioEventLoopGroup() : nettyConfig.getEventLoopGroup();
+        if (!(eventLoopGroup instanceof NioEventLoopGroup))
+            throw new IllegalArgumentException("Only Nio is supported");
+
+        plainBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
+        secureBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
+        webSocketBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
+        secureWebSocketBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
+
+        if (config.getConnectionTimeout() > 0)
+            nettyConfig.addChannelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectionTimeout());
+        for (Entry<ChannelOption<Object>, Object> entry : nettyConfig.propertiesSet()) {
+            ChannelOption<Object> key = entry.getKey();
+            Object value = entry.getValue();
+            plainBootstrap.option(key, value);
+            webSocketBootstrap.option(key, value);
+            secureBootstrap.option(key, value);
+            secureWebSocketBootstrap.option(key, value);
+        }
+    }
+
+    public void configureBootstraps(NettyRequestSender requestSender, AtomicBoolean closed) {
+
+        HttpProtocol httpProtocol = new HttpProtocol(this, config, nettyConfig, requestSender);
+        final Processor httpProcessor = new Processor(config, this, requestSender, httpProtocol);
+
+        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, nettyConfig, requestSender);
+        wsProcessor = new Processor(config, this, requestSender, wsProtocol);
+
+        plainBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(INFLATER_HANDLER, new HttpContentDecompressor())//
+                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
+                        .addLast(HTTP_PROCESSOR, httpProcessor);
+
+                if (nettyConfig.getHttpAdditionalChannelInitializer() != null)
+                    nettyConfig.getHttpAdditionalChannelInitializer().initChannel(ch);
+            }
+        });
+
+        webSocketBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(WS_PROCESSOR, wsProcessor);
+
+                if (nettyConfig.getWsAdditionalChannelInitializer() != null) {
+                    nettyConfig.getWsAdditionalChannelInitializer().initChannel(ch);
+                }
+            }
+        });
+
+        secureBootstrap.handler(new ChannelInitializer<Channel>() {
+
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(SSL_HANDLER, new SslInitializer(ChannelManager.this))//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(INFLATER_HANDLER, new HttpContentDecompressor())//
+                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
+                        .addLast(HTTP_PROCESSOR, httpProcessor);
+
+                if (nettyConfig.getHttpsAdditionalChannelInitializer() != null)
+                    nettyConfig.getHttpsAdditionalChannelInitializer().initChannel(ch);
+            }
+        });
+
+        secureWebSocketBootstrap.handler(new ChannelInitializer<Channel>() {
+
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(SSL_HANDLER, new SslInitializer(ChannelManager.this))//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(WS_PROCESSOR, wsProcessor);
+
+                if (nettyConfig.getWssAdditionalChannelInitializer() != null) {
+                    nettyConfig.getWssAdditionalChannelInitializer().initChannel(ch);
+                }
+            }
+        });
+    }
+
+    public final void tryToOfferChannelToPool(Channel channel, boolean keepAlive, String partitionId) {
+        if (keepAlive && channel.isActive()) {
+            LOGGER.debug("Adding key: {} for channel {}", partitionId, channel);
+            channelPool.offer(channel, partitionId);
+            if (maxConnectionsPerHostEnabled)
+                channel2KeyPool.putIfAbsent(channel, partitionId);
+            Channels.setDiscard(channel);
+        } else {
+            // not offered
+            closeChannel(channel);
+        }
+    }
+
+    public Channel poll(Uri uri, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
+        String partitionId = connectionPoolPartitioning.getPartitionId(uri, proxy);
+        return channelPool.poll(partitionId);
+    }
+
+    public boolean removeAll(Channel connection) {
+        return channelPool.removeAll(connection);
+    }
+
+    private boolean tryAcquireGlobal() {
+        return !maxConnectionsEnabled || freeChannels.tryAcquire();
+    }
+
+    private Semaphore getFreeConnectionsForHost(String poolKey) {
+        Semaphore freeConnections = freeChannelsPerHost.get(poolKey);
+        if (freeConnections == null) {
+            // lazy create the semaphore
+            Semaphore newFreeConnections = new Semaphore(config.getMaxConnectionsPerHost());
+            freeConnections = freeChannelsPerHost.putIfAbsent(poolKey, newFreeConnections);
+            if (freeConnections == null)
+                freeConnections = newFreeConnections;
+        }
+        return freeConnections;
+    }
+
+    private boolean tryAcquirePerHost(String poolKey) {
+        return !maxConnectionsPerHostEnabled || getFreeConnectionsForHost(poolKey).tryAcquire();
+    }
+
+    public boolean preemptChannel(String poolKey) {
+        return channelPool.isOpen() && tryAcquireGlobal() && tryAcquirePerHost(poolKey);
+    }
+
+    public void close() {
+        channelPool.destroy();
+        openChannels.close();
+
+        for (Channel channel : openChannels) {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture<?>) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.cancelTimeouts();
+            }
+        }
+
+        if (allowReleaseEventLoopGroup)
+            eventLoopGroup.shutdownGracefully();
+    }
+
+    public void closeChannel(Channel channel) {
+
+        LOGGER.debug("Closing Channel {} ", channel);
+        removeAll(channel);
+        Channels.setDiscard(channel);
+        Channels.silentlyCloseChannel(channel);
+        openChannels.remove(channel);
+    }
+
+    public void abortChannelPreemption(String poolKey) {
+        if (maxConnectionsEnabled)
+            freeChannels.release();
+        if (maxConnectionsPerHostEnabled)
+            getFreeConnectionsForHost(poolKey).release();
+    }
+
+    public void registerOpenChannel(Channel channel) {
+        openChannels.add(channel);
+    }
+
+    private HttpClientCodec newHttpClientCodec() {
+        return new HttpClientCodec(//
+                nettyConfig.getHttpClientCodecMaxInitialLineLength(),//
+                nettyConfig.getHttpClientCodecMaxHeaderSize(),//
+                nettyConfig.getHttpClientCodecMaxChunkSize(),//
+                false);
+    }
+
+    public SslHandler createSslHandler(String peerHost, int peerPort) throws IOException, GeneralSecurityException {
+
+        SSLEngine sslEngine = null;
+        if (nettyConfig.getSslEngineFactory() != null) {
+            sslEngine = nettyConfig.getSslEngineFactory().newSSLEngine();
+
+        } else {
+            SSLContext sslContext = config.getSSLContext();
+            if (sslContext == null)
+                sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
+
+            sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
+            sslEngine.setUseClientMode(true);
+        }
+
+        SslHandler sslHandler = new SslHandler(sslEngine);
+        if (handshakeTimeout > 0)
+            sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
+
+        return sslHandler;
+    }
+
+    public static SslHandler getSslHandler(ChannelPipeline pipeline) {
+        return (SslHandler) pipeline.get(SSL_HANDLER);
+    }
+
+    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
+        return pipeline.get(SSL_HANDLER) != null;
+    }
+
+    public void upgradeProtocol(ChannelPipeline pipeline, String scheme, String host, int port) throws IOException, GeneralSecurityException {
+        if (pipeline.get(HTTP_HANDLER) != null)
+            pipeline.remove(HTTP_HANDLER);
+
+        if (isSecure(scheme))
+            if (isSslHandlerConfigured(pipeline)) {
+                pipeline.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
+            } else {
+                pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addFirst(SSL_HANDLER, createSslHandler(host, port));
+            }
+
+        else
+            pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+
+        if (isWebSocket(scheme)) {
+            pipeline.addAfter(HTTP_PROCESSOR, WS_PROCESSOR, wsProcessor);
+            pipeline.remove(HTTP_PROCESSOR);
+        }
+    }
+
+    public String getPartitionId(NettyResponseFuture<?> future) {
+        return future.getConnectionPoolPartitioning().getPartitionId(future.getUri(), future.getProxyServer());
+    }
+
+    /**
+     * Always make sure the channel who got cached support the proper protocol.
+     * It could only occurs when a HttpMethod. CONNECT is used against a proxy
+     * that requires upgrading from http to https.
+     */
+    public void verifyChannelPipeline(ChannelPipeline pipeline, String scheme) throws IOException, GeneralSecurityException {
+
+        boolean sslHandlerConfigured = isSslHandlerConfigured(pipeline);
+
+        if (isSecure(scheme)) {
+            if (!sslHandlerConfigured)
+                pipeline.addFirst(SSL_HANDLER, new SslInitializer(this));
+
+        } else if (sslHandlerConfigured)
+            pipeline.remove(SSL_HANDLER);
+    }
+
+    public Bootstrap getBootstrap(Uri uri, boolean useProxy, boolean useSSl) {
+        return uri.getScheme().startsWith(WEBSOCKET) && !useProxy ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : //
+                (useSSl ? secureBootstrap : plainBootstrap);
+    }
+
+    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
+        pipeline.addAfter(HTTP_HANDLER, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+        pipeline.remove(HTTP_HANDLER);
+        pipeline.addBefore(WS_PROCESSOR, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, nettyConfig.getWebSocketMaxFrameSize()));
+        pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(nettyConfig.getWebSocketMaxBufferSize()));
+    }
+
+    public final Callback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final String poolKey) {
+
+        return new Callback(future) {
+            public void call() throws Exception {
+                tryToOfferChannelToPool(channel, keepAlive, poolKey);
+            }
+        };
+    }
+
+    public void drainChannel(final Channel channel, final NettyResponseFuture<?> future) {
+        Channels.setAttribute(channel, newDrainCallback(future, channel, future.isKeepAlive(), getPartitionId(future)));
+    }
+
+    public void flushPartition(String partitionId) {
+        channelPool.flushPartition(partitionId);
+    } 
+
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+        channelPool.flushPartitions(selector);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java
new file mode 100755
index 000000000..02a0a6959
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel;
+
+import io.netty.channel.Channel;
+import io.netty.util.Attribute;
+import io.netty.util.AttributeKey;
+
+import org.asynchttpclient.providers.netty.DiscardEvent;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Channels {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
+
+    private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
+
+    public static Object getAttribute(Channel channel) {
+        Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
+        return attr != null ? attr.get() : null;
+    }
+
+    public static void setAttribute(Channel channel, Object o) {
+        channel.attr(DEFAULT_ATTRIBUTE).set(o);
+    }
+
+    public static void setDiscard(Channel channel) {
+        setAttribute(channel, DiscardEvent.INSTANCE);
+    }
+
+    public static boolean isChannelValid(Channel channel) {
+        return channel != null && channel.isActive();
+    }
+
+    public static void silentlyCloseChannel(Channel channel) {
+        try {
+            if (channel != null && channel.isActive())
+                channel.close();
+        } catch (Throwable t) {
+            LOGGER.debug("Failed to close channel", t);
+        }
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java
old mode 100644
new mode 100755
similarity index 78%
rename from providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java
index 74c2ec952..db52cb1de
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java
@@ -25,48 +25,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package org.asynchttpclient.providers.netty_4.util;
+package org.asynchttpclient.providers.netty.channel;
 
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.ChannelGroupFuture;
 import io.netty.channel.group.DefaultChannelGroup;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import io.netty.util.concurrent.GlobalEventExecutor;
 
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
  * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
  * supposed to be called once.
- *
+ * 
  * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
  */
 public class CleanupChannelGroup extends DefaultChannelGroup {
 
-    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
-
     // internal vars --------------------------------------------------------------------------------------------------
 
-    private final AtomicBoolean closed;
-    private final ReentrantReadWriteLock lock;
+    private final AtomicBoolean closed = new AtomicBoolean(false);
+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
 
     // constructors ---------------------------------------------------------------------------------------------------
 
     public CleanupChannelGroup() {
-        this.closed = new AtomicBoolean(false);
-        this.lock = new ReentrantReadWriteLock();
+        super(GlobalEventExecutor.INSTANCE);
     }
 
     public CleanupChannelGroup(String name) {
-        super(name);
-        this.closed = new AtomicBoolean(false);
-        this.lock = new ReentrantReadWriteLock();
+        super(name, GlobalEventExecutor.INSTANCE);
     }
 
     // DefaultChannelGroup --------------------------------------------------------------------------------------------
@@ -79,9 +68,12 @@ public ChannelGroupFuture close() {
                 // First time close() is called.
                 return super.close();
             } else {
-                Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
-                logger.debug("CleanupChannelGroup Already closed");
-                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
+                // FIXME DefaultChannelGroupFuture is package protected
+                // Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
+                // logger.debug("CleanupChannelGroup already closed");
+                // return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures,
+                // GlobalEventExecutor.INSTANCE);
+                throw new UnsupportedOperationException("CleanupChannelGroup already closed");
             }
         } finally {
             this.lock.writeLock().unlock();
@@ -97,7 +89,7 @@ public boolean add(Channel channel) {
         try {
             if (this.closed.get()) {
                 // Immediately close channel, as close() was already called.
-                channel.close();
+                Channels.silentlyCloseChannel(channel);
                 return false;
             }
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java
new file mode 100755
index 000000000..0a938b1f5
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2014 AsyncHttpClient Project.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty.channel;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.ssl.SslHandler;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+/**
+ * On connect, replaces itself with a SslHandler that has a SSLEngine configured with the remote host and port.
+ * 
+ * @author slandelle
+ */
+public class SslInitializer extends ChannelOutboundHandlerAdapter {
+
+    private final ChannelManager channelManager;
+
+    public SslInitializer(ChannelManager channelManager) {
+        this.channelManager = channelManager;
+    }
+
+    @Override
+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)
+            throws Exception {
+
+        InetSocketAddress remoteInetSocketAddress = (InetSocketAddress) remoteAddress;
+        String peerHost = remoteInetSocketAddress.getHostString();
+        int peerPort = remoteInetSocketAddress.getPort();
+
+        SslHandler sslHandler = channelManager.createSslHandler(peerHost, peerPort);
+
+        ctx.pipeline().replace(ChannelManager.SSL_HANDLER, ChannelManager.SSL_HANDLER, sslHandler);
+
+        ctx.connect(remoteAddress, localAddress, promise);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java
new file mode 100755
index 000000000..ce0480b77
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel.pool;
+
+import io.netty.channel.Channel;
+
+public interface ChannelPool {
+
+    /**
+     * Add a channel to the pool
+     * 
+     * @param partitionId a key used to retrieve the cached channel
+     * @param channel an I/O channel
+     * @return true if added.
+     */
+    boolean offer(Channel channel, String partitionId);
+
+    /**
+     * Remove the channel associated with the uri.
+     * 
+     * @param partitionId the partition used when invoking offer
+     * @return the channel associated with the uri
+     */
+    Channel poll(String partitionId);
+
+    /**
+     * Remove all channels from the cache. A channel might have been associated with several uri.
+     * 
+     * @param channel a channel
+     * @return the true if the channel has been removed
+     */
+    boolean removeAll(Channel channel);
+
+    /**
+     * Return true if a channel can be cached. A implementation can decide based on some rules to allow caching
+     * Calling this method is equivalent of checking the returned value of {@link ChannelPool#offer(Object, Object)}
+     * 
+     * @return true if a channel can be cached.
+     */
+    boolean isOpen();
+
+    /**
+     * Destroy all channels that has been cached by this instance.
+     */
+    void destroy();
+
+    /**
+     * Flush a partition
+     * 
+     * @param partitionId
+     */
+    void flushPartition(String partitionId);
+
+    /**
+     * Flush partitions based on a selector
+     * 
+     * @param selector
+     */
+    void flushPartitions(ChannelPoolPartitionSelector selector);
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java
new file mode 100644
index 000000000..9f76db0bc
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel.pool;
+
+public interface ChannelPoolPartitionSelector {
+
+   boolean select(String partitionId); 
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java
new file mode 100755
index 000000000..3e465a09a
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel.pool;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+import io.netty.channel.Channel;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A simple implementation of {@link com.ning.http.client.providers.netty.pool.ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ */
+public final class DefaultChannelPool implements ChannelPool {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
+
+    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> partitions = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
+    private final ConcurrentHashMap<Channel, ChannelCreation> channel2Creation = new ConcurrentHashMap<Channel, ChannelCreation>();
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final Timer nettyTimer;
+    private final boolean sslConnectionPoolEnabled;
+    private final int maxConnectionTTL;
+    private final boolean maxConnectionTTLDisabled;
+    private final long maxIdleTime;
+    private final boolean maxIdleTimeDisabled;
+    private final long cleanerPeriod;
+
+    public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
+        this(config.getPooledConnectionIdleTimeout(),//
+                config.getConnectionTTL(),//
+                config.isAllowPoolingSslConnections(),//
+                hashedWheelTimer);
+    }
+
+    public DefaultChannelPool(
+            long maxIdleTime,//
+            int maxConnectionTTL,//
+            boolean sslConnectionPoolEnabled,//
+            Timer nettyTimer) {
+        this.sslConnectionPoolEnabled = sslConnectionPoolEnabled;
+        this.maxIdleTime = maxIdleTime;
+        this.maxConnectionTTL = maxConnectionTTL;
+        maxConnectionTTLDisabled = maxConnectionTTL <= 0;
+        this.nettyTimer = nettyTimer;
+        maxIdleTimeDisabled = maxIdleTime <= 0;
+
+        cleanerPeriod = Math.min(maxConnectionTTLDisabled ? Long.MAX_VALUE : maxConnectionTTL, maxIdleTimeDisabled ? Long.MAX_VALUE
+                : maxIdleTime);
+
+        if (!maxConnectionTTLDisabled || !maxIdleTimeDisabled)
+            scheduleNewIdleChannelDetector(new IdleChannelDetector());
+    }
+
+    private void scheduleNewIdleChannelDetector(TimerTask task) {
+        nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
+    }
+
+    private static final class ChannelCreation {
+        final long creationTime;
+        final String poolKey;
+
+        ChannelCreation(long creationTime, String poolKey) {
+            this.creationTime = creationTime;
+            this.poolKey = poolKey;
+        }
+    }
+
+    private static final class IdleChannel {
+        final Channel channel;
+        final long start;
+
+        IdleChannel(Channel channel, long start) {
+            if (channel == null)
+                throw new NullPointerException("channel");
+            this.channel = channel;
+            this.start = start;
+        }
+
+        @Override
+        // only depends on channel
+        public boolean equals(Object o) {
+            return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
+        }
+
+        @Override
+        public int hashCode() {
+            return channel.hashCode();
+        }
+    }
+
+    private boolean isTTLExpired(Channel channel, long now) {
+        if (maxConnectionTTLDisabled)
+            return false;
+
+        ChannelCreation creation = channel2Creation.get(channel);
+        return creation == null || now - creation.creationTime >= maxConnectionTTL;
+    }
+
+    private boolean isRemotelyClosed(Channel channel) {
+        return !channel.isActive();
+    }
+
+    private final class IdleChannelDetector implements TimerTask {
+
+        private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
+            return !maxIdleTimeDisabled && now - idleChannel.start >= maxIdleTime;
+        }
+
+        private List<IdleChannel> expiredChannels(ConcurrentLinkedQueue<IdleChannel> partition, long now) {
+            // lazy create
+            List<IdleChannel> idleTimeoutChannels = null;
+            for (IdleChannel idleChannel : partition) {
+                if (isTTLExpired(idleChannel.channel, now) || isIdleTimeoutExpired(idleChannel, now)
+                        || isRemotelyClosed(idleChannel.channel)) {
+                    LOGGER.debug("Adding Candidate expired Channel {}", idleChannel.channel);
+                    if (idleTimeoutChannels == null)
+                        idleTimeoutChannels = new ArrayList<IdleChannel>();
+                    idleTimeoutChannels.add(idleChannel);
+                }
+            }
+
+            return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
+        }
+
+        private boolean isChannelCloseable(Channel channel) {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                if (!future.isDone())
+                    LOGGER.error("Future not in appropriate state %s, not closing", future);
+            }
+            return true;
+        }
+
+        private final List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+
+            // lazy create, only if we have a non-closeable channel
+            List<IdleChannel> closedChannels = null;
+            for (int i = 0; i < candidates.size(); i++) {
+                IdleChannel idleChannel = candidates.get(i);
+                if (!isChannelCloseable(idleChannel.channel))
+                    if (closedChannels == null) {
+                        // first non closeable to be skipped, copy all previously skipped closeable channels
+                        closedChannels = new ArrayList<IdleChannel>(candidates.size());
+                        for (int j = 0; j < i; j++)
+                            closedChannels.add(candidates.get(j));
+                    } else {
+                        LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
+                        close(idleChannel.channel);
+                        if (closedChannels != null) {
+                            closedChannels.add(idleChannel);
+                        }
+                    }
+            }
+
+            return closedChannels != null ? closedChannels : candidates;
+        }
+
+        public void run(Timeout timeout) throws Exception {
+
+            if (isClosed.get())
+                return;
+
+            try {
+                if (LOGGER.isDebugEnabled())
+                    for (String key : partitions.keySet()) {
+                        LOGGER.debug("Entry count for : {} : {}", key, partitions.get(key).size());
+                    }
+
+                long start = millisTime();
+                int closedCount = 0;
+                int totalCount = 0;
+
+                for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+
+                    // store in intermediate unsynchronized lists to minimize the impact on the ConcurrentLinkedQueue
+                    if (LOGGER.isDebugEnabled())
+                        totalCount += partition.size();
+
+                    List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
+
+                    if (!closedChannels.isEmpty()) {
+                        for (IdleChannel closedChannel : closedChannels)
+                            channel2Creation.remove(closedChannel.channel);
+
+                        partition.removeAll(closedChannels);
+                        closedCount += closedChannels.size();
+                    }
+                }
+
+                long duration = millisTime() - start;
+
+                LOGGER.debug("Closed {} connections out of {} in {}ms", closedCount, totalCount, duration);
+
+            } catch (Throwable t) {
+                LOGGER.error("uncaught exception!", t);
+            }
+
+            scheduleNewIdleChannelDetector(timeout.task());
+        }
+    }
+
+    private ConcurrentLinkedQueue<IdleChannel> getPartition(String partitionId) {
+        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionId);
+        if (partition == null) {
+            // lazy init pool
+            ConcurrentLinkedQueue<IdleChannel> newPartition = new ConcurrentLinkedQueue<IdleChannel>();
+            partition = partitions.putIfAbsent(partitionId, newPartition);
+            if (partition == null)
+                partition = newPartition;
+        }
+        return partition;
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public boolean offer(Channel channel, String partitionId) {
+        if (isClosed.get() || (!sslConnectionPoolEnabled && channel.pipeline().get(SslHandler.class) != null))
+            return false;
+
+        long now = millisTime();
+
+        if (isTTLExpired(channel, now))
+            return false;
+
+        boolean added = getPartition(partitionId).add(new IdleChannel(channel, now));
+        if (added)
+            channel2Creation.putIfAbsent(channel, new ChannelCreation(now, partitionId));
+
+        return added;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Channel poll(String partitionId) {
+        if (!sslConnectionPoolEnabled && partitionId.startsWith("https"))
+            return null;
+
+        IdleChannel idleChannel = null;
+        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionId);
+        if (partition != null) {
+            while (idleChannel == null) {
+                idleChannel = partition.poll();
+
+                if (idleChannel == null)
+                    // pool is empty
+                    break;
+                else if (isRemotelyClosed(idleChannel.channel)) {
+                    idleChannel = null;
+                    LOGGER.trace("Channel not connected or not opened, probably remotely closed!");
+                }
+            }
+        }
+        return idleChannel != null ? idleChannel.channel : null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean removeAll(Channel channel) {
+        ChannelCreation creation = channel2Creation.remove(channel);
+        return !isClosed.get() && creation != null && partitions.get(creation.poolKey).remove(channel);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isOpen() {
+        return !isClosed.get();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void destroy() {
+        if (isClosed.getAndSet(true))
+            return;
+
+        for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+            for (IdleChannel idleChannel : partition)
+                close(idleChannel.channel);
+        }
+
+        partitions.clear();
+        channel2Creation.clear();
+    }
+
+    private void close(Channel channel) {
+        // FIXME pity to have to do this here
+        Channels.setDiscard(channel);
+        channel2Creation.remove(channel);
+        Channels.silentlyCloseChannel(channel);
+    }
+
+    private void flushPartition(String partitionId, ConcurrentLinkedQueue<IdleChannel> partition) {
+        if (partition != null) {
+            partitions.remove(partitionId);
+            for (IdleChannel idleChannel : partition)
+                close(idleChannel.channel);
+        }
+    }
+    
+    @Override
+    public void flushPartition(String partitionId) {
+        flushPartition(partitionId, partitions.get(partitionId));
+    }
+    
+    @Override
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+
+        for (Map.Entry<String, ConcurrentLinkedQueue<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+            String partitionId = partitionsEntry.getKey();
+            if (selector.select(partitionId))
+                flushPartition(partitionId, partitionsEntry.getValue());
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java
new file mode 100755
index 000000000..342a044dd
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.channel.pool;
+
+import io.netty.channel.Channel;
+
+public class NoopChannelPool implements ChannelPool {
+
+    @Override
+    public boolean offer(Channel channel, String poolKey) {
+        return false;
+    }
+
+    @Override
+    public Channel poll(String poolKey) {
+        return null;
+    }
+
+    @Override
+    public boolean removeAll(Channel channel) {
+        return false;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return true;
+    }
+
+    @Override
+    public void destroy() {
+    }
+
+    @Override
+    public void flushPartition(String partitionId) {
+    }
+
+    @Override
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java
new file mode 100755
index 000000000..c9fbef429
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java
@@ -0,0 +1,472 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.future;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.net.SocketAddress;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ConnectionPoolPartitioning;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.request.NettyRequest;
+import org.asynchttpclient.providers.netty.request.timeout.TimeoutsHolder;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
+ * 
+ * @param <V>
+ */
+public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
+
+    public enum STATE {
+        NEW, POOLED, RECONNECTED, CLOSED,
+    }
+
+    private volatile boolean requestTimeoutReached;
+    private volatile boolean idleConnectionTimeoutReached;
+    private final long start = millisTime();
+    private final ConnectionPoolPartitioning connectionPoolPartitioning;
+    private final ProxyServer proxyServer;
+    private final int maxRetry;
+    private final CountDownLatch latch = new CountDownLatch(1);
+
+    // state mutated from outside the event loop
+    // TODO check if they are indeed mutated outside the event loop
+    private final AtomicBoolean isDone = new AtomicBoolean(false);
+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
+    private final AtomicInteger redirectCount = new AtomicInteger();
+    private final AtomicBoolean inAuth = new AtomicBoolean(false);
+    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
+    private final AtomicLong touch = new AtomicLong(millisTime());
+    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
+    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
+    private final AtomicInteger currentRetry = new AtomicInteger(0);
+    private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
+    private final AtomicReference<V> content = new AtomicReference<V>();
+    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
+    private volatile TimeoutsHolder timeoutsHolder;
+
+    // state mutated only inside the event loop
+    private Channel channel;
+    private Uri uri;
+    private boolean keepAlive = true;
+    private Request request;
+    private NettyRequest nettyRequest;
+    private HttpHeaders httpHeaders;
+    private AsyncHandler<V> asyncHandler;
+    private HttpResponse pendingResponse;
+    private boolean streamWasAlreadyConsumed;
+    private boolean reuseChannel;
+    private boolean headersAlreadyWrittenOnContinue;
+    private boolean dontWriteBodyBecauseExpectContinue;
+    private boolean allowConnect;
+
+    public NettyResponseFuture(Uri uri,//
+            Request request,//
+            AsyncHandler<V> asyncHandler,//
+            NettyRequest nettyRequest,//
+            int maxRetry,//
+            ConnectionPoolPartitioning connectionPoolPartitioning,//
+            ProxyServer proxyServer) {
+
+        this.asyncHandler = asyncHandler;
+        this.request = request;
+        this.nettyRequest = nettyRequest;
+        this.uri = uri;
+        this.connectionPoolPartitioning = connectionPoolPartitioning;
+        this.proxyServer = proxyServer;
+        this.maxRetry = maxRetry;
+    }
+
+    /*********************************************/
+    /**       java.util.concurrent.Future       **/
+    /*********************************************/
+
+    @Override
+    public boolean isDone() {
+        return isDone.get() || isCancelled.get();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return isCancelled.get();
+    }
+
+    @Override
+    public boolean cancel(boolean force) {
+        cancelTimeouts();
+
+        if (isCancelled.getAndSet(true))
+            return false;
+
+        Channels.setDiscard(channel);
+        Channels.silentlyCloseChannel(channel);
+
+        if (!onThrowableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(new CancellationException());
+            } catch (Throwable t) {
+                LOGGER.warn("cancel", t);
+            }
+        }
+        latch.countDown();
+        runListeners();
+        return true;
+    }
+
+    @Override
+    public V get() throws InterruptedException, ExecutionException {
+        latch.await();
+        return getContent();
+    }
+
+    @Override
+    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+        if (!latch.await(l, tu))
+            throw new TimeoutException();
+        return getContent();
+    }
+
+    private V getContent() throws ExecutionException {
+
+        ExecutionException e = exEx.get();
+        if (e != null)
+            throw e;
+
+        V update = content.get();
+        // No more retry
+        currentRetry.set(maxRetry);
+        if (!contentProcessed.getAndSet(true)) {
+            try {
+                update = asyncHandler.onCompleted();
+            } catch (Throwable ex) {
+                if (!onThrowableCalled.getAndSet(true)) {
+                    try {
+                        try {
+                            asyncHandler.onThrowable(ex);
+                        } catch (Throwable t) {
+                            LOGGER.debug("asyncHandler.onThrowable", t);
+                        }
+                        throw new RuntimeException(ex);
+                    } finally {
+                        cancelTimeouts();
+                    }
+                }
+            }
+            content.compareAndSet(null, update);
+        }
+        return update;
+    }
+
+    /*********************************************/
+    /**   org.asynchttpclient.ListenableFuture  **/
+    /*********************************************/
+
+    public final void done() {
+
+        cancelTimeouts();
+
+        if (isDone.getAndSet(true) || isCancelled.get())
+            return;
+
+        try {
+            getContent();
+
+        } catch (ExecutionException t) {
+            return;
+        } catch (RuntimeException t) {
+            Throwable exception = t.getCause() != null ? t.getCause() : t;
+            exEx.compareAndSet(null, new ExecutionException(exception));
+
+        } finally {
+            latch.countDown();
+        }
+
+        runListeners();
+    }
+
+    public final void abort(final Throwable t) {
+
+        cancelTimeouts();
+
+        if (isDone.get() || isCancelled.getAndSet(true))
+            return;
+
+        exEx.compareAndSet(null, new ExecutionException(t));
+        if (onThrowableCalled.compareAndSet(false, true)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                LOGGER.debug("asyncHandler.onThrowable", te);
+            }
+        }
+        latch.countDown();
+        runListeners();
+    }
+
+    @Override
+    public void touch() {
+        touch.set(millisTime());
+    }
+
+    /*********************************************/
+    /**                 INTERNAL                **/
+    /*********************************************/
+
+    public Uri getUri() {
+        return uri;
+    }
+
+    public void setUri(Uri uri) {
+        this.uri = uri;
+    }
+
+    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
+        return connectionPoolPartitioning;
+    }
+
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
+    public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+        this.asyncHandler = asyncHandler;
+    }
+
+    /**
+     * Is the Future still valid
+     * 
+     * @return <code>true</code> if response has expired and should be terminated.
+     */
+    public boolean hasExpired() {
+        return requestTimeoutReached || idleConnectionTimeoutReached;
+    }
+
+    public void setRequestTimeoutReached() {
+        this.requestTimeoutReached = true;
+    }
+
+    public boolean isRequestTimeoutReached() {
+        return requestTimeoutReached;
+    }
+
+    public void setIdleConnectionTimeoutReached() {
+        this.idleConnectionTimeoutReached = true;
+    }
+
+    public boolean isIdleConnectionTimeoutReached() {
+        return idleConnectionTimeoutReached;
+    }
+
+    public void cancelTimeouts() {
+        if (timeoutsHolder != null) {
+            timeoutsHolder.cancel();
+            timeoutsHolder = null;
+        }
+    }
+
+    public final Request getRequest() {
+        return request;
+    }
+
+    public final NettyRequest getNettyRequest() {
+        return nettyRequest;
+    }
+
+    public final void setNettyRequest(NettyRequest nettyRequest) {
+        this.nettyRequest = nettyRequest;
+    }
+
+    public final AsyncHandler<V> getAsyncHandler() {
+        return asyncHandler;
+    }
+
+    public final boolean isKeepAlive() {
+        return keepAlive;
+    }
+
+    public final void setKeepAlive(final boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
+
+    public final HttpHeaders getHttpHeaders() {
+        return httpHeaders;
+    }
+
+    public final void setHttpHeaders(HttpHeaders httpHeaders) {
+        this.httpHeaders = httpHeaders;
+    }
+
+    public int incrementAndGetCurrentRedirectCount() {
+        return redirectCount.incrementAndGet();
+    }
+
+    public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
+        this.timeoutsHolder = timeoutsHolder;
+    }
+
+    public boolean isInAuth() {
+        return inAuth.get();
+    }
+
+    public boolean getAndSetAuth(boolean inDigestAuth) {
+        return inAuth.getAndSet(inDigestAuth);
+    }
+
+    public STATE getState() {
+        return state.get();
+    }
+
+    public void setState(STATE state) {
+        this.state.set(state);
+    }
+
+    public boolean getAndSetStatusReceived(boolean sr) {
+        return statusReceived.getAndSet(sr);
+    }
+
+    public HttpResponse getPendingResponse() {
+        return pendingResponse;
+    }
+
+    public void setPendingResponse(HttpResponse pendingResponse) {
+        this.pendingResponse = pendingResponse;
+    }
+
+    public boolean isStreamWasAlreadyConsumed() {
+        return streamWasAlreadyConsumed;
+    }
+
+    public void setStreamWasAlreadyConsumed(boolean streamWasAlreadyConsumed) {
+        this.streamWasAlreadyConsumed = streamWasAlreadyConsumed;
+    }
+
+    public long getLastTouch() {
+        return touch.get();
+    }
+
+    public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
+        this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
+    }
+
+    public boolean isHeadersAlreadyWrittenOnContinue() {
+        return headersAlreadyWrittenOnContinue;
+    }
+
+    public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
+        this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
+    }
+
+    public boolean isDontWriteBodyBecauseExpectContinue() {
+        return dontWriteBodyBecauseExpectContinue;
+    }
+
+    public void setReuseChannel(boolean reuseChannel) {
+        this.reuseChannel = reuseChannel;
+    }
+
+    public boolean isConnectAllowed() {
+        return allowConnect;
+    }
+
+    public void setConnectAllowed(boolean allowConnect) {
+        this.allowConnect = allowConnect;
+    }
+
+    public void attachChannel(Channel channel, boolean reuseChannel) {
+        this.channel = channel;
+        this.reuseChannel = reuseChannel;
+    }
+
+    public Channel channel() {
+        return channel;
+    }
+
+    public boolean reuseChannel() {
+        return reuseChannel;
+    }
+
+    public boolean canRetry() {
+        if (currentRetry.incrementAndGet() > maxRetry) {
+            return false;
+        }
+        return true;
+    }
+
+    public SocketAddress getChannelRemoteAddress() {
+        return channel != null ? channel.remoteAddress() : null;
+    }
+
+    public void setRequest(Request request) {
+        this.request = request;
+    }
+
+    /**
+     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an
+     * unexpected IOException, and in some situation we can recover from that exception.
+     * 
+     * @return true if that {@link Future} cannot be recovered.
+     */
+    public boolean canBeReplayed() {
+        return !isDone() && canRetry()
+                && !(Channels.isChannelValid(channel) && !uri.getScheme().equalsIgnoreCase("https")) && !isInAuth();
+    }
+
+    public long getStart() {
+        return start;
+    }
+
+    @Override
+    public String toString() {
+        return "NettyResponseFuture{" + //
+                "currentRetry=" + currentRetry + //
+                ",\n\tisDone=" + isDone + //
+                ",\n\tisCancelled=" + isCancelled + //
+                ",\n\tasyncHandler=" + asyncHandler + //
+                ",\n\tnettyRequest=" + nettyRequest + //
+                ",\n\tcontent=" + content + //
+                ",\n\turi=" + uri + //
+                ",\n\tkeepAlive=" + keepAlive + //
+                ",\n\thttpHeaders=" + httpHeaders + //
+                ",\n\texEx=" + exEx + //
+                ",\n\tredirectCount=" + redirectCount + //
+                ",\n\ttimeoutsHolder=" + timeoutsHolder + //
+                ",\n\tinAuth=" + inAuth + //
+                ",\n\tstatusReceived=" + statusReceived + //
+                ",\n\ttouch=" + touch + //
+                '}';
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java
new file mode 100755
index 000000000..f4a658976
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.future;
+
+public class StackTraceInspector {
+
+    private static boolean exceptionInMethod(Throwable t, String className, String methodName) {
+        try {
+            for (StackTraceElement element : t.getStackTrace()) {
+                if (element.getClassName().equals(className) && element.getMethodName().equals(methodName))
+                    return true;
+            }
+        } catch (Throwable ignore) {
+        }
+        return false;
+    }
+
+    private static boolean abortOnConnectCloseException(Throwable t) {
+        return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
+                || (t.getCause() != null && abortOnConnectCloseException(t.getCause()));
+    }
+
+    public static boolean abortOnDisconnectException(Throwable t) {
+        return exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
+                || (t.getCause() != null && abortOnConnectCloseException(t.getCause()));
+    }
+
+    public static boolean abortOnReadOrWriteException(Throwable t) {
+
+        try {
+            for (StackTraceElement element : t.getStackTrace()) {
+                String className = element.getClassName();
+                String methodName = element.getMethodName();
+                if (className.equals("sun.nio.ch.SocketDispatcher") && (methodName.equals("read") || methodName.equals("write")))
+                    return true;
+            }
+        } catch (Throwable ignore) {
+        }
+
+        if (t.getCause() != null)
+            return abortOnReadOrWriteException(t.getCause());
+
+        return false;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java
new file mode 100755
index 000000000..a7e9e1873
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.handler;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+import static io.netty.handler.codec.http.HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED;
+import static io.netty.handler.codec.http.HttpResponseStatus.UNAUTHORIZED;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isNTLM;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getDefaultPort;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.STATE;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.ntlm.NTLMEngine;
+import org.asynchttpclient.ntlm.NTLMEngineException;
+import org.asynchttpclient.providers.netty.Callback;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
+import org.asynchttpclient.providers.netty.response.NettyResponseHeaders;
+import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
+import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.uri.Uri;
+
+public final class HttpProtocol extends Protocol {
+
+    public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, NettyRequestSender requestSender) {
+        super(channelManager, config, nettyConfig, requestSender);
+    }
+
+    private Realm.RealmBuilder newRealmBuilder(Realm realm) {
+        return realm != null ? new Realm.RealmBuilder().clone(realm) : new Realm.RealmBuilder();
+    }
+
+    private Realm kerberosChallenge(Channel channel, List<String> proxyAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
+            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
+
+        Uri uri = request.getUri();
+        String host = request.getVirtualHost() == null ? uri.getHost() : request.getVirtualHost();
+        String server = proxyServer == null ? host : proxyServer.getHost();
+        try {
+            String challengeHeader = SpnegoEngine.instance().generateToken(server);
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            return newRealmBuilder(realm)//
+                    .setUri(uri)//
+                    .setMethodName(request.getMethod())//
+                    .setScheme(Realm.AuthScheme.KERBEROS)//
+                    .build();
+
+        } catch (Throwable throwable) {
+            if (isNTLM(proxyAuth)) {
+                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future, proxyInd);
+            }
+            requestSender.abort(channel, future, throwable);
+            return null;
+        }
+    }
+
+    private String authorizationHeaderName(boolean proxyInd) {
+        return proxyInd ? HttpHeaders.Names.PROXY_AUTHORIZATION : HttpHeaders.Names.AUTHORIZATION;
+    }
+
+    private void addNTLMAuthorizationHeader(FluentCaseInsensitiveStringsMap headers, String challengeHeader, boolean proxyInd) {
+        headers.add(authorizationHeaderName(proxyInd), "NTLM " + challengeHeader);
+    }
+
+    private Realm ntlmChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
+            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
+
+        boolean useRealm = proxyServer == null && realm != null;
+
+        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
+        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
+        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
+        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
+        Uri uri = request.getUri();
+
+        if (realm != null && !realm.isNtlmMessageType2Received()) {
+            String challengeHeader = NTLMEngine.INSTANCE.generateType1Msg(ntlmDomain, ntlmHost);
+
+            addNTLMAuthorizationHeader(headers, challengeHeader, proxyInd);
+            future.getAndSetAuth(false);
+            return newRealmBuilder(realm)//
+                    .setScheme(realm.getAuthScheme())//
+                    .setUri(uri)//
+                    .setMethodName(request.getMethod())//
+                    .setNtlmMessageType2Received(true)//
+                    .build();
+
+        } else {
+            addType3NTLMAuthorizationHeader(wwwAuth, headers, principal, password, ntlmDomain, ntlmHost, proxyInd);
+            Realm.AuthScheme authScheme = realm != null ? realm.getAuthScheme() : Realm.AuthScheme.NTLM;
+            return newRealmBuilder(realm)//
+                    .setScheme(authScheme)//
+                    .setUri(uri)//
+                    .setMethodName(request.getMethod())//
+                    .build();
+        }
+    }
+
+    private Realm ntlmProxyChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
+            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
+        future.getAndSetAuth(false);
+        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
+
+        addType3NTLMAuthorizationHeader(wwwAuth, headers, proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getNtlmDomain(), proxyServer.getHost(), proxyInd);
+
+        return newRealmBuilder(realm)//
+                // .setScheme(realm.getAuthScheme())
+                .setUri(request.getUri())//
+                .setMethodName(request.getMethod()).build();
+    }
+
+    private void addType3NTLMAuthorizationHeader(List<String> auth, FluentCaseInsensitiveStringsMap headers, String username, String password, String domain, String workstation,
+            boolean proxyInd) throws NTLMEngineException {
+        headers.remove(authorizationHeaderName(proxyInd));
+
+        if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM ")) {
+            String serverChallenge = auth.get(0).trim().substring("NTLM ".length());
+            String challengeHeader = NTLMEngine.INSTANCE.generateType3Msg(username, password, domain, workstation, serverChallenge);
+            addNTLMAuthorizationHeader(headers, challengeHeader, proxyInd);
+        }
+    }
+
+    private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {
+
+        boolean keepAlive = future.isKeepAlive();
+        if (expectOtherChunks && keepAlive)
+            channelManager.drainChannel(channel, future);
+        else
+            channelManager.tryToOfferChannelToPool(channel, keepAlive, channelManager.getPartitionId(future));
+        markAsDone(future, channel);
+    }
+
+    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
+        boolean interrupt = handler.onBodyPartReceived(bodyPart) != STATE.CONTINUE;
+        if (bodyPart.isUnderlyingConnectionToBeClosed())
+            future.setKeepAlive(false);
+        return interrupt;
+    }
+
+    private void markAsDone(NettyResponseFuture<?> future, final Channel channel) {
+        // We need to make sure everything is OK before adding the
+        // connection back to the pool.
+        try {
+            future.done();
+        } catch (Throwable t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
+
+        if (!future.isKeepAlive() || !channel.isActive()) {
+            channelManager.closeChannel(channel);
+        }
+    }
+
+    private boolean exitAfterHandling401(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            final Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer) throws Exception {
+
+        if (statusCode == UNAUTHORIZED.code() && realm != null && !future.getAndSetAuth(true)) {
+
+            List<String> wwwAuthHeaders = response.headers().getAll(HttpHeaders.Names.WWW_AUTHENTICATE);
+
+            if (!wwwAuthHeaders.isEmpty()) {
+                future.setState(NettyResponseFuture.STATE.NEW);
+                Realm newRealm = null;
+                boolean negociate = wwwAuthHeaders.contains("Negotiate");
+                if (!wwwAuthHeaders.contains("Kerberos") && (isNTLM(wwwAuthHeaders) || negociate)) {
+                    // NTLM
+                    newRealm = ntlmChallenge(wwwAuthHeaders, request, proxyServer, request.getHeaders(), realm, future, false);
+                } else if (negociate) {
+                    newRealm = kerberosChallenge(channel, wwwAuthHeaders, request, proxyServer, request.getHeaders(), realm, future, false);
+                    // SPNEGO KERBEROS
+                    if (newRealm == null)
+                        return true;
+                } else {
+                    newRealm = new Realm.RealmBuilder()//
+                            .clone(realm)//
+                            .setScheme(realm.getAuthScheme())//
+                            .setUri(request.getUri())//
+                            .setMethodName(request.getMethod())//
+                            .setUsePreemptiveAuth(true)//
+                            .parseWWWAuthenticateHeader(wwwAuthHeaders.get(0))//
+                            .build();
+                }
+
+                Realm nr = newRealm;
+                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(nr).build();
+
+                logger.debug("Sending authentication to {}", request.getUri());
+                Callback callback = new Callback(future) {
+                    public void call() throws Exception {
+                        channelManager.drainChannel(channel, future);
+                        requestSender.sendNextRequest(nextRequest, future);
+                    }
+                };
+
+                if (future.isKeepAlive() && HttpHeaders.isTransferEncodingChunked(response))
+                    // We must make sure there is no bytes left
+                    // before executing the next request.
+                    Channels.setAttribute(channel, callback);
+                else
+                    callback.call();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
+        if (statusCode == CONTINUE.code()) {
+            future.setHeadersAlreadyWrittenOnContinue(true);
+            future.setDontWriteBodyBecauseExpectContinue(false);
+            // FIXME why not reuse the channel?
+            requestSender.writeRequest(future, channel);
+            return true;
+
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandling407(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer) throws Exception {
+
+        if (statusCode == PROXY_AUTHENTICATION_REQUIRED.code() && realm != null && !future.getAndSetAuth(true)) {
+
+            List<String> proxyAuthHeaders = response.headers().getAll(HttpHeaders.Names.PROXY_AUTHENTICATE);
+
+            if (!proxyAuthHeaders.isEmpty()) {
+                logger.debug("Sending proxy authentication to {}", request.getUri());
+
+                future.setState(NettyResponseFuture.STATE.NEW);
+                Realm newRealm = null;
+                FluentCaseInsensitiveStringsMap requestHeaders = request.getHeaders();
+
+                boolean negociate = proxyAuthHeaders.contains("Negotiate");
+                if (!proxyAuthHeaders.contains("Kerberos") && (isNTLM(proxyAuthHeaders) || negociate)) {
+                    newRealm = ntlmProxyChallenge(proxyAuthHeaders, request, proxyServer, requestHeaders, realm, future, true);
+                    // SPNEGO KERBEROS
+                } else if (negociate) {
+                    newRealm = kerberosChallenge(channel, proxyAuthHeaders, request, proxyServer, requestHeaders, realm, future, true);
+                    if (newRealm == null)
+                        return true;
+                } else {
+                    newRealm = new Realm.RealmBuilder().clone(realm)//
+                            .setScheme(realm.getAuthScheme())//
+                            .setUri(request.getUri())//
+                            .setOmitQuery(true)//
+                            .setMethodName(HttpMethod.CONNECT.name())//
+                            .setUsePreemptiveAuth(true)//
+                            .parseProxyAuthenticateHeader(proxyAuthHeaders.get(0))//
+                            .build();
+                }
+
+                future.setReuseChannel(true);
+                future.setConnectAllowed(true);
+                Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(requestHeaders).setRealm(newRealm).build();
+                requestSender.sendNextRequest(nextRequest, future);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandlingConnect(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            final Request request,//
+            ProxyServer proxyServer,//
+            int statusCode,//
+            HttpRequest httpRequest) throws IOException {
+
+        if (statusCode == OK.code() && httpRequest.getMethod() == HttpMethod.CONNECT) {
+
+            if (future.isKeepAlive())
+                future.attachChannel(channel, true);
+
+            try {
+                Uri requestUri = request.getUri();
+                String scheme = requestUri.getScheme();
+                String host = requestUri.getHost();
+                int port = getDefaultPort(requestUri);
+
+                logger.debug("Connecting to proxy {} for scheme {}", proxyServer, scheme);
+                channelManager.upgradeProtocol(channel.pipeline(), scheme, host, port);
+
+            } catch (Throwable ex) {
+                requestSender.abort(channel, future, ex);
+            }
+
+            future.setReuseChannel(true);
+            future.setConnectAllowed(false);
+            requestSender.sendNextRequest(new RequestBuilder(future.getRequest()).build(), future);
+            return true;
+        }
+
+        return false;
+    }
+
+    private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status)
+            throws IOException, Exception {
+        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != STATE.CONTINUE) {
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
+            return true;
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseHeaders responseHeaders)
+            throws IOException, Exception {
+        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != STATE.CONTINUE) {
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
+            return true;
+        }
+        return false;
+    }
+
+    private boolean handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        ProxyServer proxyServer = future.getProxyServer();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+
+        // store the original headers so we can re-send all them to
+        // the handler in case of trailing headers
+        future.setHttpHeaders(response.headers());
+
+        future.setKeepAlive(!HttpHeaders.Values.CLOSE.equalsIgnoreCase(response.headers().get(HttpHeaders.Names.CONNECTION)));
+
+        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response);
+        int statusCode = response.getStatus().code();
+        Request request = future.getRequest();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+
+        return exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)
+                || exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer) || //
+                exitAfterHandling407(channel, future, response, request, statusCode, realm, proxyServer) || //
+                exitAfterHandling100(channel, future, statusCode) || //
+                exitAfterHandlingRedirect(channel, future, response, request, statusCode) || //
+                exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest) || //
+                exitAfterHandlingStatus(channel, future, response, handler, status) || //
+                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders);
+    }
+
+    @Override
+    public void handle(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+
+        future.touch();
+
+        // future is already done because of an exception or a timeout
+        if (future.isDone()) {
+            // FIXME isn't the channel already properly closed?
+            channelManager.closeChannel(channel);
+            return;
+        }
+
+        AsyncHandler<?> handler = future.getAsyncHandler();
+        try {
+            if (e instanceof HttpResponse) {
+                HttpResponse response = (HttpResponse) e;
+                // we buffer the response until we get the LastHttpContent
+                future.setPendingResponse(response);
+                return;
+
+            } else if (e instanceof HttpContent) {
+                HttpResponse response = future.getPendingResponse();
+                future.setPendingResponse(null);
+                if (response != null && handleHttpResponse(response, channel, future, handler))
+                    return;
+
+                HttpContent chunk = (HttpContent) e;
+
+                boolean interrupt = false;
+                boolean last = chunk instanceof LastHttpContent;
+
+                // Netty 4: the last chunk is not empty
+                if (last) {
+                    LastHttpContent lastChunk = (LastHttpContent) chunk;
+                    HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
+                    if (!trailingHeaders.isEmpty()) {
+                        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), trailingHeaders);
+                        interrupt = handler.onHeadersReceived(responseHeaders) != STATE.CONTINUE;
+                    }
+                }
+
+                ByteBuf buf = chunk.content();
+                try {
+                    if (!interrupt && (buf.readableBytes() > 0 || last)) {
+                        NettyResponseBodyPart part = nettyConfig.getBodyPartFactory().newResponseBodyPart(buf, last);
+                        interrupt = updateBodyAndInterrupt(future, handler, part);
+                    }
+                } finally {
+                    // FIXME we shouldn't need this, should we? But a leak was reported there without it?!
+                    buf.release();
+                }
+
+                if (interrupt || last)
+                    finishUpdate(future, channel, !last);
+            }
+        } catch (Exception t) {
+            if (hasIOExceptionFilters//
+                    && t instanceof IOException//
+                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
+                return;
+            }
+
+            try {
+                requestSender.abort(channel, future, t);
+            } catch (Exception abortException) {
+                logger.debug("Abort failed", abortException);
+            } finally {
+                finishUpdate(future, channel, false);
+            }
+            throw t;
+        }
+    }
+
+    @Override
+    public void onError(NettyResponseFuture<?> future, Throwable error) {
+    }
+
+    @Override
+    public void onClose(NettyResponseFuture<?> future) {
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java
new file mode 100755
index 000000000..2c281133e
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.handler;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.PrematureChannelClosureException;
+import io.netty.handler.codec.http.LastHttpContent;
+
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.Callback;
+import org.asynchttpclient.providers.netty.DiscardEvent;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.future.StackTraceInspector;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Sharable
+public class Processor extends ChannelInboundHandlerAdapter {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class);
+
+    public static final IOException CHANNEL_CLOSED_EXCEPTION = new IOException("Channel Closed");
+    static {
+        CHANNEL_CLOSED_EXCEPTION.setStackTrace(new StackTraceElement[0]);
+    }
+
+    private final AsyncHttpClientConfig config;
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+    private final Protocol protocol;
+
+    public Processor(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender,//
+            Protocol protocol) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+        this.protocol = protocol;
+    }
+
+    @Override
+    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+
+        Channel channel = ctx.channel();
+        Object attribute = Channels.getAttribute(channel);
+
+        if (attribute instanceof Callback && msg instanceof LastHttpContent) {
+            Callback ac = (Callback) attribute;
+            ac.call();
+            Channels.setAttribute(channel, DiscardEvent.INSTANCE);
+
+        } else if (attribute instanceof NettyResponseFuture) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+            protocol.handle(channel, future, msg);
+
+        } else if (attribute != DiscardEvent.INSTANCE) {
+            LOGGER.trace("Closing an orphan channel {}", channel);
+            Channels.silentlyCloseChannel(channel);
+        }
+    }
+
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+
+        if (requestSender.isClosed())
+            return;
+
+        Channel channel = ctx.channel();
+        channelManager.removeAll(channel);
+
+        try {
+            super.channelInactive(ctx);
+        } catch (Exception ex) {
+            LOGGER.trace("super.channelClosed", ex);
+        }
+
+        Object attribute = Channels.getAttribute(channel);
+        LOGGER.debug("Channel Closed: {} with attribute {}", channel, attribute);
+
+        if (attribute instanceof Callback) {
+            Callback callback = (Callback) attribute;
+            Channels.setAttribute(channel, callback.future());
+            callback.call();
+
+        } else if (attribute instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = NettyResponseFuture.class.cast(attribute);
+            future.touch();
+
+            if (!config.getIOExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                return;
+
+            protocol.onClose(future);
+
+            if (future.isDone())
+                channelManager.closeChannel(channel);
+
+            else if (!requestSender.retry(future))
+                requestSender.abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+        }
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Exception {
+        Throwable cause = e.getCause() != null ? e.getCause() : e;
+
+        if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
+            return;
+
+        Channel channel = ctx.channel();
+        NettyResponseFuture<?> future = null;
+
+        LOGGER.debug("Unexpected I/O exception on channel {}", channel, cause);
+
+        try {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) attribute;
+                future.attachChannel(null, false);
+                future.touch();
+
+                if (cause instanceof IOException) {
+
+                    // FIXME why drop the original exception and throw a new one?
+                    if (!config.getIOExceptionFilters().isEmpty()) {
+                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                            // Close the channel so the recovering can occurs.
+                            Channels.silentlyCloseChannel(channel);
+                        return;
+                    }
+                }
+
+                if (StackTraceInspector.abortOnReadOrWriteException(cause)) {
+                    LOGGER.debug("Trying to recover from dead Channel: {}", channel);
+                    return;
+                }
+            } else if (attribute instanceof Callback) {
+                future = Callback.class.cast(attribute).future();
+            }
+        } catch (Throwable t) {
+            cause = t;
+        }
+
+        if (future != null)
+            try {
+                LOGGER.debug("Was unable to recover Future: {}", future);
+                requestSender.abort(channel, future, cause);
+                protocol.onError(future, e);
+            } catch (Throwable t) {
+                LOGGER.error(t.getMessage(), t);
+            }
+
+        channelManager.closeChannel(channel);
+        // FIXME not really sure
+        // ctx.fireChannelRead(e);
+        Channels.silentlyCloseChannel(channel);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java
new file mode 100755
index 000000000..a97c388e2
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.handler;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.FOUND;
+import static io.netty.handler.codec.http.HttpResponseStatus.MOVED_PERMANENTLY;
+import static io.netty.handler.codec.http.HttpResponseStatus.SEE_OTHER;
+import static io.netty.handler.codec.http.HttpResponseStatus.TEMPORARY_REDIRECT;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.HTTP;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.followRedirect;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.date.TimeConverter;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.providers.netty.Callback;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class Protocol {
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected final ChannelManager channelManager;
+    protected final AsyncHttpClientConfig config;
+    protected final NettyAsyncHttpProviderConfig nettyConfig;
+    protected final NettyRequestSender requestSender;
+
+    private final boolean hasResponseFilters;
+    protected final boolean hasIOExceptionFilters;
+    private final TimeConverter timeConverter;
+
+    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<Integer>();
+    static {
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.code());
+        REDIRECT_STATUSES.add(FOUND.code());
+        REDIRECT_STATUSES.add(SEE_OTHER.code());
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
+    }
+
+    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig,
+            NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.config = config;
+        this.requestSender = requestSender;
+        this.nettyConfig = nettyConfig;
+
+        hasResponseFilters = !config.getResponseFilters().isEmpty();
+        hasIOExceptionFilters = !config.getIOExceptionFilters().isEmpty();
+        timeConverter = config.getTimeConverter();
+    }
+
+    public abstract void handle(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+
+    public abstract void onError(NettyResponseFuture<?> future, Throwable error);
+
+    public abstract void onClose(NettyResponseFuture<?> future);
+
+    protected boolean exitAfterHandlingRedirect(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode) throws Exception {
+
+        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
+            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
+                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+
+            } else {
+                // We must allow 401 handling again.
+                future.getAndSetAuth(false);
+
+                HttpHeaders responseHeaders = response.headers();
+                String location = responseHeaders.get(HttpHeaders.Names.LOCATION);
+                Uri uri = Uri.create(future.getUri(), location);
+
+                if (!uri.equals(future.getUri())) {
+                    final RequestBuilder requestBuilder = new RequestBuilder(future.getRequest());
+
+                    if (!config.isRemoveQueryParamOnRedirect())
+                        requestBuilder.addQueryParams(future.getRequest().getQueryParams());
+
+                    // if we are to strictly handle 302, we should keep the original method (which browsers don't)
+                    // 303 must force GET
+                    if ((statusCode == FOUND.code() && !config.isStrict302Handling()) || statusCode == SEE_OTHER.code())
+                        requestBuilder.setMethod("GET");
+
+                    // in case of a redirect from HTTP to HTTPS, future attributes might change
+                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                    final String initialPoolKey = channelManager.getPartitionId(future);
+
+                    future.setUri(uri);
+                    String newUrl = uri.toUrl();
+                    if (request.getUri().getScheme().startsWith(WEBSOCKET)) {
+                        newUrl = newUrl.replaceFirst(HTTP, WEBSOCKET);
+                    }
+
+                    logger.debug("Redirecting to {}", newUrl);
+
+                    for (String cookieStr : responseHeaders.getAll(HttpHeaders.Names.SET_COOKIE)) {
+                        Cookie c = CookieDecoder.decode(cookieStr, timeConverter);
+                        if (c != null)
+                            requestBuilder.addOrReplaceCookie(c);
+                    }
+
+                    Callback callback = channelManager.newDrainCallback(future, channel, initialConnectionKeepAlive, initialPoolKey);
+
+                    if (HttpHeaders.isTransferEncodingChunked(response)) {
+                        // We must make sure there is no bytes left before
+                        // executing the next request.
+                        // FIXME investigate this
+                        Channels.setAttribute(channel, callback);
+                    } else {
+                        // FIXME don't understand: this offers the connection to the pool, or even closes it, while the
+                        // request has not been sent, right?
+                        callback.call();
+                    }
+
+                    Request redirectRequest = requestBuilder.setUrl(newUrl).build();
+                    // FIXME why not reuse the channel is same host?
+                    requestSender.sendNextRequest(redirectRequest, future);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    protected boolean exitAfterProcessingFilters(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler, //
+            HttpResponseStatus status,//
+            HttpResponseHeaders responseHeaders) throws IOException {
+
+        if (hasResponseFilters) {
+            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getRequest())
+                    .responseStatus(status).responseHeaders(responseHeaders).build();
+
+            for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                try {
+                    fc = asyncFilter.filter(fc);
+                    // FIXME Is it worth protecting against this?
+                    if (fc == null) {
+                        throw new NullPointerException("FilterContext is null");
+                    }
+                } catch (FilterException efe) {
+                    requestSender.abort(channel, future, efe);
+                }
+            }
+
+            // The handler may have been wrapped.
+            future.setAsyncHandler(fc.getAsyncHandler());
+
+            // The request has changed
+            if (fc.replayRequest()) {
+                requestSender.replayRequest(future, fc, channel);
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java
new file mode 100755
index 000000000..2b51c80fe
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.handler;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
+import static org.asynchttpclient.providers.netty.ws.WebSocketUtils.getAcceptKey;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.WebSocketFrame;
+
+import java.io.IOException;
+import java.util.Locale;
+
+import org.asynchttpclient.AsyncHandler.STATE;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
+import org.asynchttpclient.providers.netty.response.NettyResponseHeaders;
+import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
+import org.asynchttpclient.providers.netty.ws.NettyWebSocket;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+
+public final class WebSocketProtocol extends Protocol {
+
+    public WebSocketProtocol(ChannelManager channelManager,//
+            AsyncHttpClientConfig config,//
+            NettyAsyncHttpProviderConfig nettyConfig,//
+            NettyRequestSender requestSender) {
+        super(channelManager, config, nettyConfig, requestSender);
+    }
+
+    // We don't need to synchronize as replacing the "ws-decoder" will
+    // process using the same thread.
+    private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
+        if (!h.touchSuccess()) {
+            try {
+                h.onSuccess(nettyConfig.getNettyWebSocketFactory().newNettyWebSocket(channel, nettyConfig));
+            } catch (Exception ex) {
+                logger.warn("onSuccess unexpected exception", ex);
+            }
+        }
+    }
+
+    @Override
+    public void handle(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+        WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+        Request request = future.getRequest();
+
+        if (e instanceof HttpResponse) {
+            HttpResponse response = (HttpResponse) e;
+            // we buffer the response until we get the LastHttpContent
+            future.setPendingResponse(response);
+
+        } else if (e instanceof LastHttpContent) {
+            HttpResponse response = future.getPendingResponse();
+            future.setPendingResponse(null);
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response);
+            HttpResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+
+            if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+                return;
+            }
+
+            future.setHttpHeaders(response.headers());
+            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code()))
+                return;
+
+            boolean validStatus = response.getStatus().equals(SWITCHING_PROTOCOLS);
+            boolean validUpgrade = response.headers().get(HttpHeaders.Names.UPGRADE) != null;
+            String connection = response.headers().get(HttpHeaders.Names.CONNECTION);
+            if (connection == null)
+                connection = response.headers().get(HttpHeaders.Names.CONNECTION.toLowerCase(Locale.ENGLISH));
+            boolean validConnection = HttpHeaders.Values.UPGRADE.equalsIgnoreCase(connection);
+
+            status = new NettyResponseStatus(future.getUri(), config, response);
+            final boolean statusReceived = handler.onStatusReceived(status) == STATE.UPGRADE;
+
+            if (!statusReceived) {
+                try {
+                    handler.onCompleted();
+                } finally {
+                    future.done();
+                }
+                return;
+            }
+
+            final boolean headerOK = handler.onHeadersReceived(responseHeaders) == STATE.CONTINUE;
+            if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
+                requestSender.abort(channel, future, new IOException("Invalid handshake response"));
+                return;
+            }
+
+            String accept = response.headers().get(HttpHeaders.Names.SEC_WEBSOCKET_ACCEPT);
+            String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(HttpHeaders.Names.SEC_WEBSOCKET_KEY));
+            if (accept == null || !accept.equals(key)) {
+                requestSender.abort(channel, future, new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key)));
+            }
+
+            channelManager.upgradePipelineForWebSockets(channel.pipeline());
+
+            invokeOnSucces(channel, handler);
+            future.done();
+
+        } else if (e instanceof WebSocketFrame) {
+
+            final WebSocketFrame frame = (WebSocketFrame) e;
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(handler.onCompleted());
+            invokeOnSucces(channel, handler);
+
+            if (webSocket != null) {
+                if (frame instanceof CloseWebSocketFrame) {
+                    Channels.setDiscard(channel);
+                    CloseWebSocketFrame closeFrame = CloseWebSocketFrame.class.cast(frame);
+                    webSocket.onClose(closeFrame.statusCode(), closeFrame.reasonText());
+                } else {
+                    ByteBuf buf = frame.content();
+                    if (buf != null && buf.readableBytes() > 0) {
+                        try {
+                            NettyResponseBodyPart part = nettyConfig.getBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
+                            handler.onBodyPartReceived(part);
+
+                            if (frame instanceof BinaryWebSocketFrame) {
+                                webSocket.onBinaryFragment(part);
+                            } else if (frame instanceof TextWebSocketFrame) {
+                                webSocket.onTextFragment(part);
+                            } else if (frame instanceof PingWebSocketFrame) {
+                                webSocket.onPing(part);
+                            } else if (frame instanceof PongWebSocketFrame) {
+                                webSocket.onPong(part);
+                            }
+                        } finally {
+                            buf.release();
+                        }
+                    }
+                }
+            } else {
+                logger.debug("UpgradeHandler returned a null NettyWebSocket ");
+            }
+        } else {
+            logger.error("Invalid message {}", e);
+        }
+    }
+
+    @Override
+    public void onError(NettyResponseFuture<?> future, Throwable e) {
+        logger.warn("onError {}", e);
+
+        try {
+            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future);
+
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+            if (webSocket != null) {
+                webSocket.onError(e.getCause());
+                webSocket.close();
+            }
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
+    }
+
+    @Override
+    public void onClose(NettyResponseFuture<?> future) {
+        logger.trace("onClose {}");
+
+        try {
+            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future);
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+
+            logger.trace("Connection was closed abnormally (that is, with no close frame being sent).");
+            if (webSocket != null)
+                webSocket.close(1006, "Connection was closed abnormally (that is, with no close frame being sent).");
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java
new file mode 100755
index 000000000..933115a99
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+
+import java.net.ConnectException;
+import java.nio.channels.ClosedChannelException;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.asynchttpclient.AsyncHandlerExtensions;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.future.StackTraceInspector;
+import org.asynchttpclient.util.Base64;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Non Blocking connect.
+ */
+final class NettyConnectListener<T> implements ChannelFutureListener {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
+
+    private final AsyncHttpClientConfig config;
+    private final NettyRequestSender requestSender;
+    private final NettyResponseFuture<T> future;
+    private final ChannelManager channelManager;
+    private final boolean channelPreempted;
+    private final String poolKey;
+
+    public NettyConnectListener(AsyncHttpClientConfig config,//
+            NettyResponseFuture<T> future,//
+            NettyRequestSender requestSender,//
+            ChannelManager channelManager,//
+            boolean channelPreempted,//
+            String poolKey) {
+        this.config = config;
+        this.future = future;
+        this.requestSender = requestSender;
+        this.channelManager = channelManager;
+        this.channelPreempted = channelPreempted;
+        this.poolKey = poolKey;
+    }
+
+    private void abortChannelPreemption(String poolKey) {
+        if (channelPreempted)
+            channelManager.abortChannelPreemption(poolKey);
+    }
+
+    private void writeRequest(Channel channel) {
+
+        LOGGER.debug("Request using non cached Channel '{}':\n{}\n", channel, future.getNettyRequest().getHttpRequest());
+
+        if (future.isDone()) {
+            abortChannelPreemption(poolKey);
+            return;
+        }
+
+        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onConnectionOpen();
+
+        channelManager.registerOpenChannel(channel);
+        future.attachChannel(channel, false);
+        requestSender.writeRequest(future, channel);
+    }
+
+    public void onFutureSuccess(final Channel channel) throws ConnectException {
+        Channels.setAttribute(channel, future);
+        final HostnameVerifier hostnameVerifier = config.getHostnameVerifier();
+        final SslHandler sslHandler = ChannelManager.getSslHandler(channel.pipeline());
+        if (hostnameVerifier != null && sslHandler != null) {
+            final String host = future.getUri().getHost();
+            sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<? super Channel>>() {
+                @Override
+                public void operationComplete(Future<? super Channel> handshakeFuture) throws Exception {
+                    if (handshakeFuture.isSuccess()) {
+                        Channel channel = (Channel) handshakeFuture.getNow();
+                        SSLEngine engine = sslHandler.engine();
+                        SSLSession session = engine.getSession();
+
+                        LOGGER.debug("onFutureSuccess: session = {}, id = {}, isValid = {}, host = {}", session.toString(),
+                                Base64.encode(session.getId()), session.isValid(), host);
+                        if (hostnameVerifier.verify(host, session)) {
+                            writeRequest(channel);
+                        } else {
+                            abortChannelPreemption(poolKey);
+                            ConnectException exception = new ConnectException("HostnameVerifier exception");
+                            future.abort(exception);
+                            throw exception;
+                        }
+                    }
+                }
+            });
+        } else {
+            writeRequest(channel);
+        }
+    }
+
+    public void onFutureFailure(Channel channel, Throwable cause) {
+
+        abortChannelPreemption(poolKey);
+
+        boolean canRetry = future.canRetry();
+        LOGGER.debug("Trying to recover a dead cached channel {} with a retry value of {} ", channel, canRetry);
+        if (canRetry//
+                && cause != null//
+                && (cause instanceof ClosedChannelException || future.getState() != NettyResponseFuture.STATE.NEW || StackTraceInspector.abortOnDisconnectException(cause))) {
+
+            if (requestSender.retry(future)) {
+                return;
+            }
+        }
+
+        LOGGER.debug("Failed to recover from exception: {} with channel {}", cause, channel);
+
+        boolean printCause = cause != null && cause.getMessage() != null;
+        String url = future.getUri().toUrl();
+        String printedCause = printCause ? cause.getMessage() + " to " + url : url;
+        ConnectException e = new ConnectException(printedCause);
+        if (cause != null)
+            e.initCause(cause);
+        future.abort(e);
+    }
+
+    public final void operationComplete(ChannelFuture f) throws Exception {
+        if (f.isSuccess())
+            onFutureSuccess(f.channel());
+        else
+            onFutureFailure(f.channel(), f.cause());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java
new file mode 100755
index 000000000..aec5d2fd0
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request;
+
+import org.asynchttpclient.providers.netty.request.body.NettyBody;
+
+import io.netty.handler.codec.http.HttpRequest;
+
+public final class NettyRequest {
+
+    private final HttpRequest httpRequest;
+    private final NettyBody body;
+
+    public NettyRequest(HttpRequest httpRequest, NettyBody body) {
+        this.httpRequest = httpRequest;
+        this.body = body;
+    }
+
+    public HttpRequest getHttpRequest() {
+        return httpRequest;
+    }
+
+    public NettyBody getBody() {
+        return body;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java
new file mode 100755
index 000000000..f679a3b45
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request;
+
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isNTLM;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isWebSocket;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.useProxyConnect;
+import static org.asynchttpclient.providers.netty.ws.WebSocketUtils.getKey;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.keepAliveHeaderValue;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpVersion;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.security.NoSuchAlgorithmException;
+import java.util.List;
+import java.util.Map.Entry;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.cookie.CookieEncoder;
+import org.asynchttpclient.generators.FileBodyGenerator;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.ntlm.NTLMEngine;
+import org.asynchttpclient.ntlm.NTLMEngineException;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.request.body.NettyBody;
+import org.asynchttpclient.providers.netty.request.body.NettyBodyBody;
+import org.asynchttpclient.providers.netty.request.body.NettyByteArrayBody;
+import org.asynchttpclient.providers.netty.request.body.NettyFileBody;
+import org.asynchttpclient.providers.netty.request.body.NettyInputStreamBody;
+import org.asynchttpclient.providers.netty.request.body.NettyMultipartBody;
+import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.UTF8UrlEncoder;
+
+public final class NettyRequestFactory {
+
+    public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
+
+    private final AsyncHttpClientConfig config;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+
+    public NettyRequestFactory(AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig) {
+        this.config = config;
+        this.nettyConfig = nettyConfig;
+    }
+
+    private String requestUri(Uri uri, ProxyServer proxyServer, HttpMethod method) {
+        if (method == HttpMethod.CONNECT)
+            return getAuthority(uri);
+
+        else if (proxyServer != null && !(useProxyConnect(uri) && config.isUseRelativeURIsWithConnectProxies()))
+            return uri.toUrl();
+
+        else {
+            String path = getNonEmptyPath(uri);
+            if (isNonEmpty(uri.getQuery()))
+                return path + "?" + uri.getQuery();
+            else
+                return path;
+        }
+    }
+
+    private String hostHeader(Request request, Uri uri) {
+        String host = request.getVirtualHost() != null ? request.getVirtualHost() : uri.getHost();
+        return request.getVirtualHost() != null || uri.getPort() == -1 ? host : host + ":" + uri.getPort();
+    }
+
+    private String authorizationHeader(Request request, Uri uri, ProxyServer proxyServer, Realm realm) throws IOException {
+
+        String authorizationHeader = null;
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+
+            switch (realm.getAuthScheme()) {
+            case BASIC:
+                authorizationHeader = computeBasicAuthentication(realm);
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce())) {
+                    try {
+                        authorizationHeader = computeDigestAuthentication(realm);
+                    } catch (NoSuchAlgorithmException e) {
+                        throw new SecurityException(e);
+                    }
+                }
+                break;
+            case NTLM:
+                String domain;
+                if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
+                    domain = proxyServer.getNtlmDomain();
+                } else {
+                    domain = realm.getNtlmDomain();
+                }
+                try {
+                    String msg = NTLMEngine.INSTANCE.generateType1Msg("NTLM " + domain, realm.getNtlmHost());
+                    authorizationHeader = "NTLM " + msg;
+                } catch (NTLMEngineException e) {
+                    throw new IOException(e);
+                }
+                break;
+            case KERBEROS:
+            case SPNEGO:
+
+                String host;
+                if (proxyServer != null)
+                    host = proxyServer.getHost();
+                else if (request.getVirtualHost() != null)
+                    host = request.getVirtualHost();
+                else
+                    host = uri.getHost();
+
+                try {
+                    authorizationHeader = "Negotiate " + SpnegoEngine.instance().generateToken(host);
+                } catch (Throwable e) {
+                    throw new IOException(e);
+                }
+                break;
+            case NONE:
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication " + realm);
+            }
+        }
+
+        return authorizationHeader;
+    }
+
+    private String proxyAuthorizationHeader(Request request, ProxyServer proxyServer, HttpMethod method) throws IOException {
+
+        String proxyAuthorization = null;
+
+        if (method == HttpMethod.CONNECT) {
+            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+            if (isNTLM(auth)) {
+                proxyAuthorization = auth.get(0);
+            }
+
+        } else if (proxyServer != null && proxyServer.getPrincipal() != null) {
+            if (isNonEmpty(proxyServer.getNtlmDomain())) {
+                List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+                if (!isNTLM(auth)) {
+                    try {
+                        String msg = NTLMEngine.INSTANCE.generateType1Msg(proxyServer.getNtlmDomain(), proxyServer.getHost());
+                        proxyAuthorization = "NTLM " + msg;
+                    } catch (NTLMEngineException e) {
+                        IOException ie = new IOException();
+                        ie.initCause(e);
+                        throw ie;
+                    }
+                }
+            } else {
+                proxyAuthorization = computeBasicAuthentication(proxyServer);
+            }
+        }
+
+        return proxyAuthorization;
+    }
+
+    private byte[] computeBodyFromParams(List<Param> params, Charset bodyCharset) {
+
+        StringBuilder sb = new StringBuilder();
+        for (Param param : params) {
+            UTF8UrlEncoder.appendEncoded(sb, param.getName());
+            sb.append('=');
+            UTF8UrlEncoder.appendEncoded(sb, param.getValue());
+            sb.append('&');
+        }
+        sb.setLength(sb.length() - 1);
+        return sb.toString().getBytes(bodyCharset);
+    }
+
+    private NettyBody body(Request request, HttpMethod method) throws IOException {
+        NettyBody nettyBody = null;
+        if (method != HttpMethod.CONNECT) {
+
+            Charset bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : Charset.forName(request.getBodyEncoding());
+
+            if (request.getByteData() != null) {
+                nettyBody = new NettyByteArrayBody(request.getByteData());
+
+            } else if (request.getStringData() != null) {
+                nettyBody = new NettyByteArrayBody(request.getStringData().getBytes(bodyCharset));
+
+            } else if (request.getStreamData() != null) {
+                nettyBody = new NettyInputStreamBody(request.getStreamData());
+
+            } else if (isNonEmpty(request.getFormParams())) {
+
+                String contentType = null;
+                if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE))
+                    contentType = HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED;
+
+                nettyBody = new NettyByteArrayBody(computeBodyFromParams(request.getFormParams(), bodyCharset), contentType);
+
+            } else if (isNonEmpty(request.getParts())) {
+                nettyBody = new NettyMultipartBody(request.getParts(), request.getHeaders(), nettyConfig);
+
+            } else if (request.getFile() != null) {
+                nettyBody = new NettyFileBody(request.getFile(), nettyConfig);
+
+            } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
+                FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
+                nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), nettyConfig);
+
+            } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
+                nettyBody = new NettyInputStreamBody(InputStreamBodyGenerator.class.cast(request.getBodyGenerator()).getInputStream());
+
+            } else if (request.getBodyGenerator() != null) {
+                nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), nettyConfig);
+            }
+        }
+
+        return nettyBody;
+    }
+
+    public NettyRequest newNettyRequest(Request request, Uri uri, boolean forceConnect, ProxyServer proxyServer) throws IOException {
+
+        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+        HttpVersion httpVersion = method == HttpMethod.CONNECT ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
+        String requestUri = requestUri(uri, proxyServer, method);
+
+        NettyBody body = body(request, method);
+
+        HttpRequest httpRequest;
+        NettyRequest nettyRequest;
+        if (body instanceof NettyByteArrayBody) {
+            byte[] bytes = NettyByteArrayBody.class.cast(body).getBytes();
+            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.wrappedBuffer(bytes));
+            // body is passed as null as it's written directly with the request
+            nettyRequest = new NettyRequest(httpRequest, null);
+
+        } else if (body == null) {
+            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, null);
+
+        } else {
+            httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, body);
+        }
+
+        HttpHeaders headers = httpRequest.headers();
+
+        if (method != HttpMethod.CONNECT) {
+            // assign headers as configured on request
+            for (Entry<String, List<String>> header : request.getHeaders()) {
+                headers.set(header.getKey(), header.getValue());
+            }
+
+            if (isNonEmpty(request.getCookies()))
+                headers.set(HttpHeaders.Names.COOKIE, CookieEncoder.encode(request.getCookies()));
+
+            if (config.isCompressionEnforced() && !headers.contains(HttpHeaders.Names.ACCEPT_ENCODING))
+                headers.set(HttpHeaders.Names.ACCEPT_ENCODING, GZIP_DEFLATE);
+        }
+
+        if (body != null) {
+            if (body.getContentLength() < 0)
+                headers.set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            else
+                headers.set(HttpHeaders.Names.CONTENT_LENGTH, body.getContentLength());
+
+            if (body.getContentType() != null)
+                headers.set(HttpHeaders.Names.CONTENT_TYPE, body.getContentType());
+        }
+
+        // connection header and friends
+        boolean webSocket = isWebSocket(uri.getScheme());
+        if (method != HttpMethod.CONNECT && webSocket) {
+            headers.set(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET)//
+            .set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE)//
+            .set(HttpHeaders.Names.ORIGIN, "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()))//
+            .set(HttpHeaders.Names.SEC_WEBSOCKET_KEY, getKey())//
+            .set(HttpHeaders.Names.SEC_WEBSOCKET_VERSION, "13");
+
+        } else if (!headers.contains(HttpHeaders.Names.CONNECTION)) {
+            headers.set(HttpHeaders.Names.CONNECTION, keepAliveHeaderValue(config));
+        }
+
+        String hostHeader = hostHeader(request, uri);
+        if (hostHeader != null)
+            headers.set(HttpHeaders.Names.HOST, hostHeader);
+
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+        String authorizationHeader = authorizationHeader(request, uri, proxyServer, realm);
+        if (authorizationHeader != null)
+            // don't override authorization but append
+            headers.add(HttpHeaders.Names.AUTHORIZATION, authorizationHeader);
+
+        String proxyAuthorizationHeader = proxyAuthorizationHeader(request, proxyServer, method);
+        if (proxyAuthorizationHeader != null)
+            headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, proxyAuthorizationHeader);
+
+        // Add default accept headers
+        if (!headers.contains(HttpHeaders.Names.ACCEPT))
+            headers.set(HttpHeaders.Names.ACCEPT, "*/*");
+
+        // Add default user agent
+        if (!headers.contains(HttpHeaders.Names.USER_AGENT) && config.getUserAgent() != null)
+            headers.set(HttpHeaders.Names.USER_AGENT, config.getUserAgent());
+
+        return nettyRequest;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java
new file mode 100755
index 000000000..0637204cc
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java
@@ -0,0 +1,520 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request;
+
+import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
+import static org.asynchttpclient.providers.netty.util.HttpUtils.useProxyConnect;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getDefaultPort;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.requestTimeout;
+import static org.asynchttpclient.util.ProxyUtils.avoidProxy;
+import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandlerExtensions;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionPoolPartitioning;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.timeout.ReadTimeoutTimerTask;
+import org.asynchttpclient.providers.netty.request.timeout.RequestTimeoutTimerTask;
+import org.asynchttpclient.providers.netty.request.timeout.TimeoutsHolder;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public final class NettyRequestSender {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
+
+    private final AsyncHttpClientConfig config;
+    private final ChannelManager channelManager;
+    private final Timer nettyTimer;
+    private final AtomicBoolean closed;
+    private final NettyRequestFactory requestFactory;
+
+    public NettyRequestSender(AsyncHttpClientConfig config,//
+            NettyAsyncHttpProviderConfig nettyConfig,//
+            ChannelManager channelManager,//
+            Timer nettyTimer,//
+            AtomicBoolean closed) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.nettyTimer = nettyTimer;
+        this.closed = closed;
+        requestFactory = new NettyRequestFactory(config, nettyConfig);
+    }
+
+    public <T> ListenableFuture<T> sendRequest(final Request request,//
+            final AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache) throws IOException {
+
+        if (closed.get())
+            throw new IOException("Closed");
+
+        Uri uri = request.getUri();
+
+        // FIXME really useful? Why not do this check when building the request?
+        if (uri.getScheme().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler))
+            throw new IOException("WebSocket method must be a GET");
+
+        ProxyServer proxyServer = getProxyServer(config, request);
+        boolean resultOfAConnect = future != null && future.getNettyRequest() != null && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT;
+        boolean useProxy = proxyServer != null && !resultOfAConnect;
+
+        if (useProxy && useProxyConnect(uri))
+            // SSL proxy, have to handle CONNECT
+            if (future != null && future.isConnectAllowed())
+                // CONNECT forced
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, uri, proxyServer, true, true);
+            else
+                return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, uri, proxyServer);
+        else
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, uri, proxyServer, useProxy, false);
+    }
+
+    /**
+     * We know for sure if we have to force to connect or not, so we can build
+     * the HttpRequest right away This reduces the probability of having a
+     * pooled channel closed by the server by the time we build the request
+     */
+    private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache,//
+            Uri uri,//
+            ProxyServer proxyServer,//
+            boolean useProxy,//
+            boolean forceConnect) throws IOException {
+
+        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, forceConnect);
+
+        Channel channel = getCachedChannel(future, uri, request.getConnectionPoolPartitioning(), proxyServer, asyncHandler);
+
+        if (Channels.isChannelValid(channel))
+            return sendRequestWithCachedChannel(request, uri, proxyServer, newFuture, asyncHandler, channel);
+        else
+            return sendRequestWithNewChannel(request, uri, proxyServer, useProxy, newFuture, asyncHandler, reclaimCache);
+    }
+
+    /**
+     * Using CONNECT depends on wither we can fetch a valid channel or not Loop
+     * until we get a valid channel from the pool and it's still valid once the
+     * request is built
+     */
+    @SuppressWarnings("unused")
+    private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache,//
+            Uri uri,//
+            ProxyServer proxyServer) throws IOException {
+
+        NettyResponseFuture<T> newFuture = null;
+        for (int i = 0; i < 3; i++) {
+            Channel channel = getCachedChannel(future, uri, request.getConnectionPoolPartitioning(), proxyServer, asyncHandler);
+            if (Channels.isChannelValid(channel))
+                if (newFuture == null)
+                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, false);
+
+            if (Channels.isChannelValid(channel))
+                // if the channel is still active, we can use it, otherwise try gain
+                return sendRequestWithCachedChannel(request, uri, proxyServer, newFuture, asyncHandler, channel);
+            else
+                // pool is empty
+                break;
+        }
+
+        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, true);
+        return sendRequestWithNewChannel(request, uri, proxyServer, true, newFuture, asyncHandler, reclaimCache);
+    }
+
+    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
+            Uri uri, ProxyServer proxy, boolean forceConnect) throws IOException {
+
+        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, uri, forceConnect, proxy);
+
+        if (originalFuture == null) {
+            return newNettyResponseFuture(uri, request, asyncHandler, nettyRequest, proxy);
+        } else {
+            originalFuture.setNettyRequest(nettyRequest);
+            originalFuture.setRequest(request);
+            return originalFuture;
+        }
+    }
+
+    private Channel getCachedChannel(NettyResponseFuture<?> future, Uri uri, ConnectionPoolPartitioning poolKeyGen, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+
+        if (future != null && future.reuseChannel() && Channels.isChannelValid(future.channel()))
+            return future.channel();
+        else
+            return pollAndVerifyCachedChannel(uri, proxyServer, poolKeyGen, asyncHandler);
+    }
+
+    private <T> ListenableFuture<T> sendRequestWithCachedChannel(Request request, Uri uri, ProxyServer proxy, NettyResponseFuture<T> future,
+            AsyncHandler<T> asyncHandler, Channel channel) throws IOException {
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled();
+
+        future.setState(NettyResponseFuture.STATE.POOLED);
+        future.attachChannel(channel, false);
+
+        LOGGER.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, future.getNettyRequest().getHttpRequest());
+        Channels.setAttribute(channel, future);
+
+        try {
+            writeRequest(future, channel);
+        } catch (Exception ex) {
+            LOGGER.debug("writeRequest failure", ex);
+            if (ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
+                LOGGER.debug("SSLEngine failure", ex);
+                future = null;
+            } else {
+                try {
+                    asyncHandler.onThrowable(ex);
+                } catch (Throwable t) {
+                    LOGGER.warn("doConnect.writeRequest()", t);
+                }
+                IOException ioe = new IOException(ex.getMessage());
+                ioe.initCause(ex);
+                throw ioe;
+            }
+        }
+        return future;
+    }
+
+    private <T> ListenableFuture<T> sendRequestWithNewChannel(//
+            Request request,//
+            Uri uri,//
+            ProxyServer proxy,//
+            boolean useProxy,//
+            NettyResponseFuture<T> future,//
+            AsyncHandler<T> asyncHandler,//
+            boolean reclaimCache) throws IOException {
+
+        boolean useSSl = isSecure(uri) && !useProxy;
+
+        // Do not throw an exception when we need an extra connection for a
+        // redirect
+        // FIXME why? This violate the max connection per host handling, right?
+        Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), useProxy, useSSl);
+
+        boolean channelPreempted = false;
+        String poolKey = null;
+
+        // Do not throw an exception when we need an extra connection for a
+        // redirect.
+        if (!reclaimCache) {
+
+            // only compute when maxConnectionPerHost is enabled
+            // FIXME clean up
+            if (config.getMaxConnectionsPerHost() > 0)
+                poolKey = channelManager.getPartitionId(future);
+
+            channelPreempted = preemptChannel(asyncHandler, poolKey);
+        }
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onOpenConnection();
+
+        try {
+            ChannelFuture channelFuture = connect(request, uri, proxy, useProxy, bootstrap);
+            channelFuture.addListener(new NettyConnectListener<T>(config, future, this, channelManager, channelPreempted, poolKey));
+
+        } catch (Throwable t) {
+            if (channelPreempted)
+                channelManager.abortChannelPreemption(poolKey);
+
+            abort(null, future, t.getCause() == null ? t : t.getCause());
+        }
+
+        return future;
+    }
+
+    private <T> NettyResponseFuture<T> newNettyResponseFuture(Uri uri, Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
+
+        NettyResponseFuture<T> future = new NettyResponseFuture<T>(//
+                uri,//
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                config.getMaxRequestRetry(),//
+                request.getConnectionPoolPartitioning(),//
+                proxyServer);
+
+        String expectHeader = request.getHeaders().getFirstValue(HttpHeaders.Names.EXPECT);
+        if (expectHeader != null && expectHeader.equalsIgnoreCase(HttpHeaders.Values.CONTINUE))
+            future.setDontWriteBodyBecauseExpectContinue(true);
+        return future;
+    }
+
+    public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
+
+        NettyRequest nettyRequest = future.getNettyRequest();
+        HttpRequest httpRequest = nettyRequest.getHttpRequest();
+        AsyncHandler<T> handler = future.getAsyncHandler();
+
+        // if the channel is dead because it was pooled and the remote
+        // server decided to close it,
+        // we just let it go and the channelInactive do its work
+        if (!Channels.isChannelValid(channel))
+            return;
+
+        try {
+            if (handler instanceof TransferCompletionHandler)
+                configureTransferAdapter(handler, httpRequest);
+
+            if (!future.isHeadersAlreadyWrittenOnContinue()) {
+                try {
+                    if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+                        AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onSendRequest();
+
+                    channel.writeAndFlush(httpRequest, channel.newProgressivePromise()).addListener(new ProgressListener(config, future.getAsyncHandler(), future, true, 0L));
+                } catch (Throwable cause) {
+                    // FIXME why not notify?
+                    LOGGER.debug(cause.getMessage(), cause);
+                    Channels.silentlyCloseChannel(channel);
+                    return;
+                }
+            }
+
+            if (!future.isDontWriteBodyBecauseExpectContinue() && !httpRequest.getMethod().equals(HttpMethod.CONNECT) && nettyRequest.getBody() != null)
+                nettyRequest.getBody().write(channel, future, config);
+
+            // don't bother scheduling timeouts if channel became invalid
+            if (Channels.isChannelValid(channel))
+                scheduleTimeouts(future);
+
+        } catch (Throwable ioe) {
+            Channels.silentlyCloseChannel(channel);
+        }
+    }
+
+    private InetSocketAddress remoteAddress(Request request, Uri uri, ProxyServer proxy, boolean useProxy) {
+        if (request.getInetAddress() != null)
+            return new InetSocketAddress(request.getInetAddress(), getDefaultPort(uri));
+
+        else if (!useProxy || avoidProxy(proxy, uri.getHost()))
+            return new InetSocketAddress(uri.getHost(), getDefaultPort(uri));
+
+        else
+            return new InetSocketAddress(proxy.getHost(), proxy.getPort());
+    }
+
+    private ChannelFuture connect(Request request, Uri uri, ProxyServer proxy, boolean useProxy, Bootstrap bootstrap) {
+        InetSocketAddress remoteAddress = remoteAddress(request, uri, proxy, useProxy);
+
+        if (request.getLocalAddress() != null)
+            return bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
+        else
+            return bootstrap.connect(remoteAddress);
+    }
+
+    private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (Map.Entry<String, String> entries : httpRequest.headers()) {
+            h.add(entries.getKey(), entries.getValue());
+        }
+
+        TransferCompletionHandler.class.cast(handler).headers(h);
+    }
+
+    private void scheduleTimeouts(NettyResponseFuture<?> nettyResponseFuture) {
+
+        nettyResponseFuture.touch();
+        int requestTimeoutInMs = requestTimeout(config, nettyResponseFuture.getRequest());
+        TimeoutsHolder timeoutsHolder = new TimeoutsHolder();
+        if (requestTimeoutInMs != -1) {
+            Timeout requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs), requestTimeoutInMs);
+            timeoutsHolder.requestTimeout = requestTimeout;
+        }
+
+        int readTimeout = config.getReadTimeout();
+        if (readTimeout != -1 && readTimeout < requestTimeoutInMs) {
+            // no need for a idleConnectionTimeout that's less than the
+            // requestTimeoutInMs
+            Timeout idleConnectionTimeout = newTimeout(new ReadTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs, readTimeout), readTimeout);
+            timeoutsHolder.readTimeout = idleConnectionTimeout;
+        }
+        nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
+    }
+
+    public Timeout newTimeout(TimerTask task, long delay) {
+        return nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+    }
+
+    public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
+
+        if (channel != null)
+            channelManager.closeChannel(channel);
+
+        if (!future.isDone()) {
+            LOGGER.debug("Aborting Future {}\n", future);
+            LOGGER.debug(t.getMessage(), t);
+            future.abort(t);
+        }
+    }
+
+    public boolean retry(NettyResponseFuture<?> future) {
+
+        if (isClosed())
+            return false;
+
+        // FIXME what is this for???
+        //channelManager.removeAll(channel);
+
+        if (future.canBeReplayed()) {
+            future.setState(NettyResponseFuture.STATE.RECONNECTED);
+            future.getAndSetStatusReceived(false);
+
+            LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
+            if (future.getAsyncHandler() instanceof AsyncHandlerExtensions) {
+                AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRetry();
+            }
+
+            try {
+                sendNextRequest(future.getRequest(), future);
+                return true;
+
+            } catch (IOException iox) {
+                future.setState(NettyResponseFuture.STATE.CLOSED);
+                future.abort(iox);
+                LOGGER.error("Remotely Closed, unable to recover", iox);
+                return false;
+            }
+        } else {
+            LOGGER.debug("Unable to recover future {}\n", future);
+            return false;
+        }
+    }
+
+    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) throws IOException {
+
+        boolean replayed = false;
+
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(e).build();
+        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                if (fc == null) {
+                    throw new NullPointerException("FilterContext is null");
+                }
+            } catch (FilterException efe) {
+                abort(channel, future, efe);
+            }
+        }
+
+        if (fc.replayRequest()  && future.canBeReplayed()) {
+            replayRequest(future, fc, channel);
+            replayed = true;
+        }
+        return replayed;
+    }
+
+    public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) throws IOException {
+        sendRequest(request, future.getAsyncHandler(), future, true);
+    }
+
+    // FIXME is this useful? Can't we do that when building the request?
+    private boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        return request.getMethod().equals(HttpMethod.GET.name()) && asyncHandler instanceof WebSocketUpgradeHandler;
+    }
+
+    private Channel pollAndVerifyCachedChannel(Uri uri, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning, AsyncHandler<?> asyncHandler) {
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onPoolConnection();
+
+        final Channel channel = channelManager.poll(uri, proxy, connectionPoolPartitioning);
+
+        if (channel != null) {
+            LOGGER.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+
+            try {
+                channelManager.verifyChannelPipeline(channel.pipeline(), uri.getScheme());
+            } catch (Exception ex) {
+                LOGGER.debug(ex.getMessage(), ex);
+            }
+        }
+        return channel;
+    }
+
+    private boolean preemptChannel(AsyncHandler<?> asyncHandler, String poolKey) throws IOException {
+
+        boolean channelPreempted = false;
+        if (channelManager.preemptChannel(poolKey)) {
+            channelPreempted = true;
+        } else {
+            IOException ex = new IOException(String.format("Too many connections %s", config.getMaxConnections()));
+            try {
+                asyncHandler.onThrowable(ex);
+            } catch (Exception e) {
+                LOGGER.warn("asyncHandler.onThrowable crashed", e);
+            }
+            throw ex;
+        }
+        return channelPreempted;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) throws IOException {
+
+        Request newRequest = fc.getRequest();
+        future.setAsyncHandler(fc.getAsyncHandler());
+        future.setState(NettyResponseFuture.STATE.NEW);
+        future.touch();
+
+        LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRetry();
+
+        channelManager.drainChannel(channel, future);
+        sendNextRequest(newRequest, future);
+    }
+
+    public boolean isClosed() {
+        return closed.get();
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java
new file mode 100755
index 000000000..11aa82725
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.channel.ChannelProgressiveFutureListener;
+
+import java.nio.channels.ClosedChannelException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProgressAsyncHandler;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.providers.netty.channel.Channels;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.future.StackTraceInspector;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ProgressListener implements ChannelProgressiveFutureListener {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ProgressListener.class);
+
+    private final AsyncHttpClientConfig config;
+    private final AsyncHandler<?> asyncHandler;
+    private final NettyResponseFuture<?> future;
+    private final boolean notifyHeaders;
+    private final long expectedTotal;
+    private long lastProgress = 0L;
+
+    public ProgressListener(AsyncHttpClientConfig config,//
+            AsyncHandler<?> asyncHandler,//
+            NettyResponseFuture<?> future,//
+            boolean notifyHeaders,//
+            long expectedTotal) {
+        this.config = config;
+        this.asyncHandler = asyncHandler;
+        this.future = future;
+        this.notifyHeaders = notifyHeaders;
+        this.expectedTotal = expectedTotal;
+    }
+
+    private boolean abortOnThrowable(Throwable cause, Channel channel) {
+
+        if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
+            if (cause instanceof IllegalStateException) {
+                LOGGER.debug(cause.getMessage(), cause);
+                Channels.silentlyCloseChannel(channel);
+
+            } else if (cause instanceof ClosedChannelException || StackTraceInspector.abortOnReadOrWriteException(cause)) {
+                LOGGER.debug(cause.getMessage(), cause);
+                Channels.silentlyCloseChannel(channel);
+                
+            } else {
+                future.abort(cause);
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public void operationComplete(ChannelProgressiveFuture cf) {
+        // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+        // Let's retry a second time.
+        if (!abortOnThrowable(cf.cause(), cf.channel())) {
+
+            future.touch();
+
+            /**
+             * We need to make sure we aren't in the middle of an authorization
+             * process before publishing events as we will re-publish again the
+             * same event after the authorization, causing unpredictable
+             * behavior.
+             */
+            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : config.getRealm();
+            boolean startPublishing = future.isInAuth() || realm == null || realm.getUsePreemptiveAuth();
+
+            if (startPublishing && asyncHandler instanceof ProgressAsyncHandler) {
+                ProgressAsyncHandler<?> progressAsyncHandler = (ProgressAsyncHandler<?>) asyncHandler;
+                if (notifyHeaders) {
+                    progressAsyncHandler.onHeaderWriteCompleted();
+                } else {
+                    progressAsyncHandler.onContentWriteCompleted();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
+        future.touch();
+        if (!notifyHeaders && asyncHandler instanceof ProgressAsyncHandler) {
+            long lastLastProgress = lastProgress;
+            lastProgress = progress;
+            if (total < 0)
+                total = expectedTotal;
+            ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(progress - lastLastProgress, progress, total);
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java
new file mode 100755
index 000000000..a9b50bd40
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import org.asynchttpclient.Body;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.stream.ChunkedInput;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
+ */
+public class BodyChunkedInput implements ChunkedInput<ByteBuf> {
+
+    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
+
+    private final Body body;
+    private final int contentLength;
+    private final int chunkSize;
+
+    private boolean endOfInput;
+
+    public BodyChunkedInput(Body body) {
+        if (body == null)
+            throw new NullPointerException("body");
+        this.body = body;
+        contentLength = (int) body.getContentLength();
+        if (contentLength <= 0)
+            chunkSize = DEFAULT_CHUNK_SIZE;
+        else
+            chunkSize = Math.min(contentLength, DEFAULT_CHUNK_SIZE);
+    }
+
+    @Override
+    public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
+        if (endOfInput) {
+            return null;
+        } else {
+            // FIXME pass a visitor so we can directly pass a pooled ByteBuf
+            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
+            long r = body.read(buffer);
+            if (r < 0L) {
+                endOfInput = true;
+                return null;
+            } else {
+                endOfInput = r == contentLength || r < chunkSize && contentLength > 0;
+                buffer.flip();
+                return Unpooled.wrappedBuffer(buffer);
+            }
+        }
+    }
+
+    @Override
+    public boolean isEndOfInput() throws Exception {
+        return endOfInput;
+    }
+
+    @Override
+    public void close() throws Exception {
+        body.close();
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java
old mode 100644
new mode 100755
similarity index 54%
rename from providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java
index f5da85db3..b1d02275e
--- a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java
@@ -1,59 +1,68 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty_4;
+package org.asynchttpclient.providers.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 
 import org.asynchttpclient.RandomAccessBody;
-import io.netty.buffer.AbstractReferenceCounted;
-import io.netty.buffer.ReferenceCounted;
+
 import io.netty.channel.FileRegion;
+import io.netty.util.AbstractReferenceCounted;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
-
 /**
  * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
  */
-class BodyFileRegion
-        extends AbstractReferenceCounted
-        implements FileRegion {
+public class BodyFileRegion extends AbstractReferenceCounted implements FileRegion {
 
     private final RandomAccessBody body;
+    private long transfered;
 
     public BodyFileRegion(RandomAccessBody body) {
-        if (body == null) {
-            throw new IllegalArgumentException("no body specified");
-        }
+        if (body == null)
+            throw new NullPointerException("body");
         this.body = body;
     }
 
+    @Override
     public long position() {
         return 0;
     }
 
+    @Override
     public long count() {
         return body.getContentLength();
     }
 
-    public long transferTo(WritableByteChannel target, long position)
-            throws IOException {
-        return body.transferTo(position, Long.MAX_VALUE, target);
+    @Override
+    public long transfered() {
+        return transfered;
     }
 
-    public void deallocate() {
-        try {
-            body.close();
-        } catch (IOException e) {
-            // we tried
+    @Override
+    public long transferTo(WritableByteChannel target, long position) throws IOException {
+        long written = body.transferTo(position, target);
+        if (written > 0) {
+            transfered += written;
         }
+        return written;
+    }
+
+    @Override
+    protected void deallocate() {
+        closeSilently(body);
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java
old mode 100644
new mode 100755
similarity index 80%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java
index 2c121c46b..dbff02252
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java
@@ -1,16 +1,21 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.providers.netty.request.body;
+
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.util.StandardCharsets;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -18,17 +23,13 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-
 /**
- * {@link BodyGenerator} which may return just part of the payload at the time
- * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
- * for finishing payload transferring asynchronously.
+ * {@link BodyGenerator} which may return just part of the payload at the time handler is requesting it.
+ * If it happens, PartialBodyGenerator becomes responsible for finishing payload transferring asynchronously.
  */
 public class FeedableBodyGenerator implements BodyGenerator {
-    private final static byte[] END_PADDING = "\r\n".getBytes();
-    private final static byte[] ZERO = "0".getBytes();
+    private final static byte[] END_PADDING = "\r\n".getBytes(StandardCharsets.US_ASCII);
+    private final static byte[] ZERO = "0".getBytes(StandardCharsets.US_ASCII);
     private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
     private final AtomicInteger queueSize = new AtomicInteger();
     private FeedListener listener;
@@ -47,7 +48,7 @@ public void feed(final ByteBuffer buffer, final boolean isLast) throws IOExcepti
     }
 
     public static interface FeedListener {
-        public void onContentAdded();
+        void onContentAdded();
     }
 
     public void setListener(FeedListener listener) {
@@ -86,10 +87,10 @@ public long read(final ByteBuffer buffer) throws IOException {
             }
             int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
             int size = Math.min(nextPart.buffer.remaining(), capacity);
-            buffer.put(Integer.toHexString(size).getBytes());
+            buffer.put(Integer.toHexString(size).getBytes(StandardCharsets.US_ASCII));
             buffer.put(END_PADDING);
-            for (int i=0; i < size; i++) {
-              buffer.put(nextPart.buffer.get());
+            for (int i = 0; i < size; i++) {
+                buffer.put(nextPart.buffer.get());
             }
             buffer.put(END_PADDING);
             if (!nextPart.buffer.hasRemaining()) {
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java
old mode 100644
new mode 100755
similarity index 50%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java
index fdbfb52d1..cea79857c
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java
@@ -1,29 +1,30 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.providers.netty.request.body;
 
-import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MultipartUploadTest;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
 
-/**
- * @author dominict
- */
-public class NettyMultipartUploadTest extends MultipartUploadTest {
+import io.netty.channel.Channel;
+
+import java.io.IOException;
+
+public interface NettyBody {
+
+    long getContentLength();
 
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return NettyProviderUtil.nettyProvider(config);
-    }
+    String getContentType();
 
+    void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException;
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java
new file mode 100755
index 000000000..96957591a
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.stream.ChunkedWriteHandler;
+
+import java.io.IOException;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.RandomAccessBody;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.ProgressListener;
+import org.asynchttpclient.providers.netty.request.body.FeedableBodyGenerator.FeedListener;
+
+public class NettyBodyBody implements NettyBody {
+
+    private final Body body;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+
+    public NettyBodyBody(Body body, NettyAsyncHttpProviderConfig nettyConfig) {
+        this.body = body;
+        this.nettyConfig = nettyConfig;
+    }
+
+    public Body getBody() {
+        return body;
+    }
+
+    @Override
+    public long getContentLength() {
+        return body.getContentLength();
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    };
+
+    @Override
+    public void write(final Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+
+        Object msg;
+        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !nettyConfig.isDisableZeroCopy()) {
+            msg = new BodyFileRegion((RandomAccessBody) body);
+
+        } else {
+            msg = new BodyChunkedInput(body);
+
+            BodyGenerator bg = future.getRequest().getBodyGenerator();
+            if (bg instanceof FeedableBodyGenerator) {
+                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+                    @Override
+                    public void onContentAdded() {
+                        channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                    }
+                });
+            }
+        }
+        ChannelFuture writeFuture = channel.write(msg, channel.newProgressivePromise());
+
+        writeFuture.addListener(new ProgressListener(config, future.getAsyncHandler(), future, false, getContentLength()) {
+            public void operationComplete(ChannelProgressiveFuture cf) {
+                closeSilently(body);
+                super.operationComplete(cf);
+            }
+        });
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java
new file mode 100755
index 000000000..953461fb8
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+
+import io.netty.channel.Channel;
+
+import java.io.IOException;
+
+public class NettyByteArrayBody implements NettyBody {
+
+    private final byte[] bytes;
+    private final String contentType;
+
+    public NettyByteArrayBody(byte[] bytes) {
+        this(bytes, null);
+    }
+
+    public NettyByteArrayBody(byte[] bytes, String contentType) {
+        this.bytes = bytes;
+        this.contentType = contentType;
+    }
+
+    public byte[] getBytes() {
+        return bytes;
+    }
+
+    @Override
+    public long getContentLength() {
+        return bytes.length;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java
new file mode 100755
index 000000000..44a5349a7
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.FileRegion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.stream.ChunkedFile;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.channel.ChannelManager;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.ProgressListener;
+
+public class NettyFileBody implements NettyBody {
+
+    private final File file;
+    private final long offset;
+    private final long length;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+
+    public NettyFileBody(File file, NettyAsyncHttpProviderConfig nettyConfig) throws IOException {
+        this(file, 0, file.length(), nettyConfig);
+    }
+
+    public NettyFileBody(File file, long offset, long length, NettyAsyncHttpProviderConfig nettyConfig) throws IOException {
+        if (!file.isFile()) {
+            throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+        }
+        this.file = file;
+        this.offset = offset;
+        this.length = length;
+        this.nettyConfig = nettyConfig;
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public long getOffset() {
+        return offset;
+    }
+
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+        final RandomAccessFile raf = new RandomAccessFile(file, "r");
+
+        try {
+            ChannelFuture writeFuture;
+            if (ChannelManager.isSslHandlerConfigured(channel.pipeline()) || nettyConfig.isDisableZeroCopy()) {
+                writeFuture = channel.write(new ChunkedFile(raf, offset, length, nettyConfig.getChunkedFileChunkSize()), channel.newProgressivePromise());
+            } else {
+                FileRegion region = new DefaultFileRegion(raf.getChannel(), offset, length);
+                writeFuture = channel.write(region, channel.newProgressivePromise());
+            }
+            writeFuture.addListener(new ProgressListener(config, future.getAsyncHandler(), future, false, getContentLength()) {
+                public void operationComplete(ChannelProgressiveFuture cf) {
+                    closeSilently(raf);
+                    super.operationComplete(cf);
+                }
+            });
+            channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+        } catch (IOException ex) {
+            closeSilently(raf);
+            throw ex;
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java
new file mode 100755
index 000000000..9f7d84199
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.ProgressListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.stream.ChunkedStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public class NettyInputStreamBody implements NettyBody {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
+
+    private final InputStream inputStream;
+
+    public NettyInputStreamBody(InputStream inputStream) {
+        this.inputStream = inputStream;
+    }
+
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1L;
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+        final InputStream is = inputStream;
+
+        if (future.isStreamWasAlreadyConsumed()) {
+            if (is.markSupported())
+                is.reset();
+            else {
+                LOGGER.warn("Stream has already been consumed and cannot be reset");
+                return;
+            }
+        } else {
+            future.setStreamWasAlreadyConsumed(true);
+        }
+
+        channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
+                new ProgressListener(config, future.getAsyncHandler(), future, false, getContentLength()) {
+                    public void operationComplete(ChannelProgressiveFuture cf) {
+                        closeSilently(is);
+                        super.operationComplete(cf);
+                    }
+                });
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java
new file mode 100755
index 000000000..0c6944053
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.body;
+
+import static org.asynchttpclient.multipart.MultipartUtils.newMultipartBody;
+
+import java.util.List;
+
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.multipart.MultipartBody;
+import org.asynchttpclient.multipart.Part;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+
+public class NettyMultipartBody extends NettyBodyBody {
+
+    private final String contentType;
+
+    public NettyMultipartBody(List<Part> parts, FluentCaseInsensitiveStringsMap headers, NettyAsyncHttpProviderConfig nettyConfig) {
+        this(newMultipartBody(parts, headers), nettyConfig);
+    }
+
+    private NettyMultipartBody(MultipartBody body, NettyAsyncHttpProviderConfig nettyConfig) {
+        super(body, nettyConfig);
+        contentType = body.getContentType();
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java
new file mode 100755
index 000000000..2c56a0404
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.timeout;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+import io.netty.util.Timeout;
+
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+
+public class ReadTimeoutTimerTask extends TimeoutTimerTask {
+
+    private final long readTimeout;
+    private final long requestTimeoutInstant;
+
+    public ReadTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            long requestTimeout,//
+            long readTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.readTimeout = readTimeout;
+        requestTimeoutInstant = requestTimeout >= 0 ? nettyResponseFuture.getStart() + requestTimeout : Long.MAX_VALUE;
+    }
+
+    public void run(Timeout timeout) throws Exception {
+
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
+        
+        if (nettyResponseFuture.isDone()) {
+            timeoutsHolder.cancel();
+            return;
+        }
+
+        long now = millisTime();
+
+        long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
+        long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
+
+        if (durationBeforeCurrentReadTimeout <= 0L) {
+            // idleConnectionTimeout reached
+            String message = "Read timeout to " + remoteAddress + " of " + readTimeout + " ms";
+            long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
+            expire(message, durationSinceLastTouch);
+            // cancel request timeout sibling
+            timeoutsHolder.cancel();
+
+        } else if (currentReadTimeoutInstant < requestTimeoutInstant) {
+            // reschedule
+            done.set(false);
+            timeoutsHolder.readTimeout = requestSender.newTimeout(this, durationBeforeCurrentReadTimeout);
+
+        } else {
+            // otherwise, no need to reschedule: requestTimeout will happen sooner
+            timeoutsHolder.readTimeout = null;
+        }
+
+        // this task should be evacuated from the timer but who knows
+        nettyResponseFuture = null;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java
new file mode 100755
index 000000000..2c448a4b8
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.timeout;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+import io.netty.util.Timeout;
+
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+
+public class RequestTimeoutTimerTask extends TimeoutTimerTask {
+
+    private final long requestTimeout;
+
+    public RequestTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            long requestTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.requestTimeout = requestTimeout;
+    }
+
+    public void run(Timeout timeout) throws Exception {
+
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
+
+        // in any case, cancel possible idleConnectionTimeout sibling
+        timeoutsHolder.cancel();
+
+        if (nettyResponseFuture.isDone())
+            return;
+
+        String message = "Request timed out to " + remoteAddress + " of " + requestTimeout + " ms";
+        long age = millisTime() - nettyResponseFuture.getStart();
+        expire(message, age);
+        
+        // this task should be evacuated from the timer but who knows
+        nettyResponseFuture = null;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java
new file mode 100755
index 000000000..d0bc0328b
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.timeout;
+
+import io.netty.util.TimerTask;
+
+import java.net.SocketAddress;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class TimeoutTimerTask implements TimerTask {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
+
+    protected final AtomicBoolean done = new AtomicBoolean();
+    protected volatile NettyResponseFuture<?> nettyResponseFuture;
+    protected final NettyRequestSender requestSender;
+    protected final TimeoutsHolder timeoutsHolder;
+    protected final String remoteAddress;
+
+    public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
+        this.nettyResponseFuture = nettyResponseFuture;
+        this.requestSender = requestSender;
+        this.timeoutsHolder = timeoutsHolder;
+        // saving remote address as the channel might be removed from the future when an exception occurs
+        SocketAddress sa = nettyResponseFuture.getChannelRemoteAddress();
+        remoteAddress = sa != null ? sa.toString() : "not-connected";
+    }
+
+    protected void expire(String message, long time) {
+        LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
+        requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
+    }
+
+    /**
+     * When the timeout is cancelled, it could still be referenced for quite some time in the Timer.
+     * Holding a reference to the future might mean holding a reference to the channel, and heavy objects such as SslEngines
+     */
+    public void clean() {
+        if (done.compareAndSet(false, true))
+            nettyResponseFuture = null;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java
new file mode 100755
index 000000000..6fb7fa328
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.request.timeout;
+
+import io.netty.util.Timeout;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class TimeoutsHolder {
+
+    private final AtomicBoolean cancelled = new AtomicBoolean();
+    public volatile Timeout requestTimeout;
+    public volatile Timeout readTimeout;
+
+    public void cancel() {
+        if (cancelled.compareAndSet(false, true)) {
+            if (requestTimeout != null) {
+                requestTimeout.cancel();
+                RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
+                requestTimeout = null;
+            }
+            if (readTimeout != null) {
+                readTimeout.cancel();
+                ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
+                readTimeout = null;
+            }
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java
old mode 100644
new mode 100755
similarity index 53%
rename from api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java
index 3081baee6..e993bd497
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,84 +10,59 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.jdk;
+package org.asynchttpclient.providers.netty.response;
 
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.HttpResponseBodyPart;
+import static org.asynchttpclient.providers.netty.util.ByteBufUtils.*;
+
+import io.netty.buffer.ByteBuf;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.URI;
 import java.nio.ByteBuffer;
 
 /**
  * A callback class used when an HTTP response body is received.
+ * Bytes are eagerly fetched from the ByteBuf
  */
-public class ResponseBodyPart extends HttpResponseBodyPart {
+public class EagerNettyResponseBodyPart extends NettyResponseBodyPart {
 
-    private final byte[] chunk;
-    private final boolean isLast;
-    private boolean closeConnection;
+    private final byte[] bytes;
 
-    public ResponseBodyPart(URI uri, byte[] chunk, AsyncHttpProvider provider, boolean last) {
-        super(uri, provider);
-        this.chunk = chunk;
-        isLast = last;
+    public EagerNettyResponseBodyPart(ByteBuf buf, boolean last) {
+        super(last);
+        bytes = byteBuf2Bytes(buf);
     }
 
     /**
      * Return the response body's part bytes received.
-     *
+     * 
      * @return the response body's part bytes received.
      */
+    @Override
     public byte[] getBodyPartBytes() {
-        return chunk;
+        return bytes;
     }
 
     @Override
     public InputStream readBodyPartBytes() {
-        return new ByteArrayInputStream(chunk);
+        return new ByteArrayInputStream(bytes);
     }
 
     @Override
     public int length() {
-        return chunk.length;
+        return bytes.length;
     }
-    
+
     @Override
     public int writeTo(OutputStream outputStream) throws IOException {
-        outputStream.write(chunk);
-        return chunk.length;
+        outputStream.write(bytes);
+        return length();
     }
 
     @Override
     public ByteBuffer getBodyByteBuffer() {
-        return ByteBuffer.wrap(chunk);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isLast() {
-        return isLast;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsClosed() {
-        closeConnection = true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean closeUnderlyingConnection() {
-        return closeConnection;
+        return ByteBuffer.wrap(bytes);
     }
-}
\ No newline at end of file
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java
new file mode 100755
index 000000000..d3f136b9f
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.response;
+
+import io.netty.buffer.ByteBuf;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * A callback class used when an HTTP response body is received.
+ */
+public class LazyNettyResponseBodyPart extends NettyResponseBodyPart {
+
+    private static final String ERROR_MESSAGE = "This implementation is intended for one to directly read from the underlying ByteBuf and release after usage. Not for the fainted heart!";
+
+    private final ByteBuf buf;
+
+    public LazyNettyResponseBodyPart(ByteBuf buf, boolean last) {
+        super(last);
+        this.buf = buf;
+    }
+
+    public ByteBuf getBuf() {
+        return buf;
+    }
+
+    /**
+     * Return the response body's part bytes received.
+     * 
+     * @return the response body's part bytes received.
+     */
+    @Override
+    public byte[] getBodyPartBytes() {
+        throw new UnsupportedOperationException(ERROR_MESSAGE);
+    }
+
+    @Override
+    public InputStream readBodyPartBytes() {
+        throw new UnsupportedOperationException(ERROR_MESSAGE);
+    }
+
+    @Override
+    public int length() {
+        throw new UnsupportedOperationException(ERROR_MESSAGE);
+    }
+
+    @Override
+    public int writeTo(OutputStream outputStream) throws IOException {
+        throw new UnsupportedOperationException(ERROR_MESSAGE);
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        throw new UnsupportedOperationException(ERROR_MESSAGE);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java
new file mode 100755
index 000000000..17d593541
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.response;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.contentToBytes;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.date.TimeConverter;
+import org.asynchttpclient.providers.ResponseBase;
+
+/**
+ * Wrapper around the {@link org.asynchttpclient.Response} API.
+ */
+public class NettyResponse extends ResponseBase {
+
+    private final TimeConverter timeConverter;
+
+    public NettyResponse(HttpResponseStatus status,//
+            HttpResponseHeaders headers,//
+            List<HttpResponseBodyPart> bodyParts,//
+            TimeConverter timeConverter) {
+        super(status, headers, bodyParts);
+        this.timeConverter = timeConverter;
+    }
+
+    @Override
+    public String getResponseBodyExcerpt(int maxLength) throws IOException {
+        return getResponseBodyExcerpt(maxLength, null);
+    }
+
+    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
+        // should be fine; except that it may split multi-byte chars (last char may become '?')
+        charset = calculateCharset(charset);
+        byte[] b = contentToBytes(bodyParts, maxLength);
+        return new String(b, charset);
+    }
+
+    protected List<Cookie> buildCookies() {
+
+        List<String> setCookieHeaders = headers.getHeaders().get(HttpHeaders.Names.SET_COOKIE2);
+
+        if (!isNonEmpty(setCookieHeaders)) {
+            setCookieHeaders = headers.getHeaders().get(HttpHeaders.Names.SET_COOKIE);
+        }
+
+        if (isNonEmpty(setCookieHeaders)) {
+            List<Cookie> cookies = new ArrayList<Cookie>();
+            for (String value : setCookieHeaders) {
+                Cookie c = CookieDecoder.decode(value, timeConverter);
+                if (c != null)
+                    cookies.add(c);
+            }
+            return Collections.unmodifiableList(cookies);
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+    public byte[] getResponseBodyAsBytes() throws IOException {
+        return getResponseBodyAsByteBuffer().array();
+    }
+
+    @Override
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+
+        int length = 0;
+        for (HttpResponseBodyPart part : bodyParts)
+            length += part.length();
+
+        ByteBuffer target = ByteBuffer.wrap(new byte[length]);
+        for (HttpResponseBodyPart part : bodyParts)
+            target.put(part.getBodyPartBytes());
+
+        return target;
+    }
+
+    @Override
+    public String getResponseBody() throws IOException {
+        return getResponseBody(null);
+    }
+
+    @Override
+    public String getResponseBody(String charset) throws IOException {
+        return new String(getResponseBodyAsBytes(), calculateCharset(charset));
+    }
+
+    @Override
+    public InputStream getResponseBodyAsStream() throws IOException {
+        return new ByteArrayInputStream(getResponseBodyAsBytes());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java
new file mode 100755
index 000000000..76399a14e
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.response;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+
+/**
+ * A callback class used when an HTTP response body is received.
+ */
+public abstract class NettyResponseBodyPart extends HttpResponseBodyPart {
+
+    private final boolean last;
+    private boolean closeConnection;
+
+    public NettyResponseBodyPart(boolean last) {
+        this.last = last;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isLast() {
+        return last;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void markUnderlyingConnectionAsToBeClosed() {
+        closeConnection = true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isUnderlyingConnectionToBeClosed() {
+        return closeConnection;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java
old mode 100644
new mode 100755
similarity index 52%
rename from api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java
index 1a07b53c0..375f0cd3b
--- a/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java
@@ -1,60 +1,68 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.jdk;
+package org.asynchttpclient.providers.netty.response;
 
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
 
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.util.List;
 import java.util.Map;
 
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+
 /**
  * A class that represent the HTTP headers.
  */
-public class ResponseHeaders extends HttpResponseHeaders {
+public class NettyResponseHeaders extends HttpResponseHeaders {
 
-    private final HttpURLConnection urlConnection;
+    private final HttpHeaders responseHeaders;
+    private final HttpHeaders trailingHeaders;
     private final FluentCaseInsensitiveStringsMap headers;
 
-    public ResponseHeaders(URI uri, HttpURLConnection urlConnection, AsyncHttpProvider provider) {
-        super(uri, provider, false);
-        this.urlConnection = urlConnection;
+    // FIXME unused AsyncHttpProvider provider
+    public NettyResponseHeaders(HttpHeaders responseHeaders) {
+        this(responseHeaders, null);
+    }
+
+    public NettyResponseHeaders(HttpHeaders responseHeaders, HttpHeaders traillingHeaders) {
+        super(traillingHeaders != null);
+        this.responseHeaders = responseHeaders;
+        this.trailingHeaders = traillingHeaders;
         headers = computerHeaders();
     }
 
     private FluentCaseInsensitiveStringsMap computerHeaders() {
         FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (Map.Entry<String, String> header : responseHeaders) {
+            h.add(header.getKey(), header.getValue());
+        }
 
-        Map<String, List<String>> uh = urlConnection.getHeaderFields();
-
-        for (Map.Entry<String, List<String>> e : uh.entrySet()) {
-            if (e.getKey() != null) {
-                h.add(e.getKey(), e.getValue());
+        if (trailingHeaders != null) {
+            for (Map.Entry<String, String> header : trailingHeaders) {
+                h.add(header.getKey(), header.getValue());
             }
         }
+
         return h;
     }
 
     /**
      * Return the HTTP header
-     *
+     * 
      * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
      */
     @Override
     public FluentCaseInsensitiveStringsMap getHeaders() {
         return headers;
     }
-}
\ No newline at end of file
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java
new file mode 100755
index 000000000..b94260f56
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.response;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.util.List;
+
+/**
+ * A class that represent the HTTP response' status line (code + text)
+ */
+public class NettyResponseStatus extends HttpResponseStatus {
+
+    private final HttpResponse response;
+
+    public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse response) {
+        super(uri, config);
+        this.response = response;
+    }
+
+    @Override
+    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
+        return new NettyResponse(this, headers, bodyParts, config.getTimeConverter());
+    }
+
+    /**
+     * Return the response status code
+     * 
+     * @return the response status code
+     */
+    public int getStatusCode() {
+        return response.getStatus().code();
+    }
+
+    /**
+     * Return the response status text
+     * 
+     * @return the response status text
+     */
+    public String getStatusText() {
+        return response.getStatus().reasonPhrase();
+    }
+
+    @Override
+    public String getProtocolName() {
+        return response.getProtocolVersion().protocolName();
+    }
+
+    @Override
+    public int getProtocolMajorVersion() {
+        return response.getProtocolVersion().majorVersion();
+    }
+
+    @Override
+    public int getProtocolMinorVersion() {
+        return response.getProtocolVersion().minorVersion();
+    }
+
+    @Override
+    public String getProtocolText() {
+        return response.getProtocolVersion().text();
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java
deleted file mode 100644
index b0d653391..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-/*
- * ====================================================================
- *
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-package org.asynchttpclient.providers.netty.spnego;
-
-import org.asynchttpclient.util.Base64;
-import org.ietf.jgss.GSSContext;
-import org.ietf.jgss.GSSException;
-import org.ietf.jgss.GSSManager;
-import org.ietf.jgss.GSSName;
-import org.ietf.jgss.Oid;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-
-/**
- * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
- * scheme.
- *
- * @since 4.1
- */
-public class SpnegoEngine {
-    private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
-    private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
-
-    private final Logger log = LoggerFactory.getLogger(getClass());
-
-    private final SpnegoTokenGenerator spnegoGenerator;
-
-    public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
-        this.spnegoGenerator = spnegoGenerator;
-    }
-
-    public SpnegoEngine() {
-        this(null);
-    }
-
-    public String generateToken(String server) throws Throwable {
-        GSSContext gssContext = null;
-        byte[] token = null; // base64 decoded challenge
-        Oid negotiationOid = null;
-
-        try {
-            log.debug("init {}", server);
-            /* Using the SPNEGO OID is the correct method.
-             * Kerberos v5 works for IIS but not JBoss. Unwrapping
-             * the initial token when using SPNEGO OID looks like what is
-             * described here...
-             *
-             * http://msdn.microsoft.com/en-us/library/ms995330.aspx
-             *
-             * Another helpful URL...
-             *
-             * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
-             *
-             * Unfortunately SPNEGO is JRE >=1.6.
-             */
-
-            /** Try SPNEGO by default, fall back to Kerberos later if error */
-            negotiationOid = new Oid(SPNEGO_OID);
-
-            boolean tryKerberos = false;
-            try {
-                GSSManager manager = GSSManager.getInstance();
-                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(
-                        serverName.canonicalize(negotiationOid), negotiationOid, null,
-                        GSSContext.DEFAULT_LIFETIME);
-                gssContext.requestMutualAuth(true);
-                gssContext.requestCredDeleg(true);
-            } catch (GSSException ex) {
-                log.error("generateToken", ex);
-                // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
-                // Rethrow any other exception.
-                if (ex.getMajor() == GSSException.BAD_MECH) {
-                    log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
-                    tryKerberos = true;
-                } else {
-                    throw ex;
-                }
-
-            }
-            if (tryKerberos) {
-                /* Kerberos v5 GSS-API mechanism defined in RFC 1964.*/
-                log.debug("Using Kerberos MECH {}", KERBEROS_OID);
-                negotiationOid = new Oid(KERBEROS_OID);
-                GSSManager manager = GSSManager.getInstance();
-                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(
-                        serverName.canonicalize(negotiationOid), negotiationOid, null,
-                        GSSContext.DEFAULT_LIFETIME);
-                gssContext.requestMutualAuth(true);
-                gssContext.requestCredDeleg(true);
-            }
-
-            // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
-            if (token == null) {
-                token = new byte[0];
-            }
-
-            token = gssContext.initSecContext(token, 0, token.length);
-            if (token == null) {
-                throw new Exception("GSS security context initialization failed");
-            }
-
-            /*
-             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish?
-             * seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
-             */
-            if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
-                token = spnegoGenerator.generateSpnegoDERObject(token);
-            }
-
-            gssContext.dispose();
-
-            String tokenstr = new String(Base64.encode(token));
-            log.debug("Sending response '{}' back to the server", tokenstr);
-
-            return tokenstr;
-        } catch (GSSException gsse) {
-            log.error("generateToken", gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL
-                    || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
-                throw new Exception(gsse.getMessage(), gsse);
-            if (gsse.getMajor() == GSSException.NO_CRED)
-                throw new Exception(gsse.getMessage(), gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN
-                    || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
-                    || gsse.getMajor() == GSSException.OLD_TOKEN)
-                throw new Exception(gsse.getMessage(), gsse);
-            // other error
-            throw new Exception(gsse.getMessage());
-        } catch (IOException ex) {
-            throw new Exception(ex.getMessage());
-        }
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java
new file mode 100755
index 000000000..f370ac153
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty.util;
+
+import io.netty.buffer.ByteBuf;
+
+import java.util.List;
+
+public final class ByteBufUtils {
+
+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    private ByteBufUtils() {
+    }
+
+    public static byte[] byteBuf2Bytes(ByteBuf buf) {
+        int readable = buf.readableBytes();
+        int readerIndex = buf.readerIndex();
+        if (buf.hasArray()) {
+            byte[] array = buf.array();
+            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        buf.getBytes(readerIndex, array);
+        return array;
+    }
+
+    public static byte[] byteBufs2Bytes(List<ByteBuf> bufs) {
+
+        if (bufs.isEmpty()) {
+            return EMPTY_BYTE_ARRAY;
+
+        } else if (bufs.size() == 1) {
+            return byteBuf2Bytes(bufs.get(0));
+
+        } else {
+            int totalSize = 0;
+            for (ByteBuf buf : bufs) {
+                totalSize += buf.readableBytes();
+            }
+
+            byte[] bytes = new byte[totalSize];
+            int offset = 0;
+            for (ByteBuf buf : bufs) {
+                int readable = buf.readableBytes();
+                buf.getBytes(buf.readerIndex(), bytes, offset, readable);
+                offset += readable;
+            }
+            return bytes;
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java
deleted file mode 100644
index 486c61ef3..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-/*
- * Copyright 2010 Bruno de Carvalho
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.asynchttpclient.providers.netty.util;
-
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.group.ChannelGroup;
-import org.jboss.netty.channel.group.ChannelGroupFuture;
-import org.jboss.netty.channel.group.DefaultChannelGroup;
-import org.jboss.netty.channel.group.DefaultChannelGroupFuture;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-/**
- * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
- * supposed to be called once.
- *
- * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
- */
-public class CleanupChannelGroup extends DefaultChannelGroup {
-
-    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
-
-    // internal vars --------------------------------------------------------------------------------------------------
-
-    private final AtomicBoolean closed;
-    private final ReentrantReadWriteLock lock;
-
-    // constructors ---------------------------------------------------------------------------------------------------
-
-    public CleanupChannelGroup() {
-        this.closed = new AtomicBoolean(false);
-        this.lock = new ReentrantReadWriteLock();
-    }
-
-    public CleanupChannelGroup(String name) {
-        super(name);
-        this.closed = new AtomicBoolean(false);
-        this.lock = new ReentrantReadWriteLock();
-    }
-
-    // DefaultChannelGroup --------------------------------------------------------------------------------------------
-
-    @Override
-    public ChannelGroupFuture close() {
-        this.lock.writeLock().lock();
-        try {
-            if (!this.closed.getAndSet(true)) {
-                // First time close() is called.
-                return super.close();
-            } else {
-                Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
-                logger.debug("CleanupChannelGroup Already closed");
-                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
-            }
-        } finally {
-            this.lock.writeLock().unlock();
-        }
-    }
-
-    @Override
-    public boolean add(Channel channel) {
-        // Synchronization must occur to avoid add() and close() overlap (thus potentially leaving one channel open).
-        // This could also be done by synchronizing the method itself but using a read lock here (rather than a
-        // synchronized() block) allows multiple concurrent calls to add().
-        this.lock.readLock().lock();
-        try {
-            if (this.closed.get()) {
-                // Immediately close channel, as close() was already called.
-                channel.close();
-                return false;
-            }
-
-            return super.add(channel);
-        } finally {
-            this.lock.readLock().unlock();
-        }
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java
new file mode 100755
index 000000000..78b5a09a3
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.util;
+
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import java.util.List;
+
+import org.asynchttpclient.uri.Uri;
+
+public final class HttpUtils {
+
+    public static final String HTTPS = "https";
+    public static final String HTTP = "http";
+    public static final String WEBSOCKET = "ws";
+    public static final String WEBSOCKET_SSL = "wss";
+
+    private HttpUtils() {
+    }
+
+    public static boolean isNTLM(List<String> auth) {
+        return isNonEmpty(auth) && auth.get(0).startsWith("NTLM");
+    }
+
+    public static boolean isWebSocket(String scheme) {
+        return WEBSOCKET.equals(scheme) || WEBSOCKET_SSL.equals(scheme);
+    }
+
+    public static boolean isSecure(String scheme) {
+        return HTTPS.equals(scheme) || WEBSOCKET_SSL.equals(scheme);
+    }
+
+    public static boolean isSecure(Uri uri) {
+        return isSecure(uri.getScheme());
+    }
+
+    public static boolean useProxyConnect(Uri uri) {
+        return isSecure(uri) || isWebSocket(uri.getScheme());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java
new file mode 100755
index 000000000..a6a9a2a74
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.ws;
+
+import static io.netty.buffer.Unpooled.wrappedBuffer;
+import static org.asynchttpclient.util.StandardCharsets.UTF_8;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketByteFragmentListener;
+import org.asynchttpclient.websocket.WebSocketByteListener;
+import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketPingListener;
+import org.asynchttpclient.websocket.WebSocketPongListener;
+import org.asynchttpclient.websocket.WebSocketTextFragmentListener;
+import org.asynchttpclient.websocket.WebSocketTextListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyWebSocket implements WebSocket {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
+
+    protected final Channel channel;
+    protected final Collection<WebSocketListener> listeners;
+    protected final int maxBufferSize;
+    private int bufferSize;
+    private List<byte[]> _fragments;
+    private volatile boolean interestedInByteMessages;
+    private volatile boolean interestedInTextMessages;
+
+    public NettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig) {
+        this(channel, nettyConfig, new ConcurrentLinkedQueue<WebSocketListener>());
+    }
+
+    public NettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig, Collection<WebSocketListener> listeners) {
+        this.channel = channel;
+        this.listeners = listeners;
+        maxBufferSize = nettyConfig.getWebSocketMaxBufferSize();
+    }
+
+    @Override
+    public WebSocket sendMessage(byte[] message) {
+        channel.writeAndFlush(new BinaryWebSocketFrame(wrappedBuffer(message)));
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, boolean last) {
+        channel.writeAndFlush(new BinaryWebSocketFrame(last, 0, wrappedBuffer(fragment)));
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
+        channel.writeAndFlush(new BinaryWebSocketFrame(last, 0, wrappedBuffer(fragment, offset, len)));
+        return this;
+    }
+
+    @Override
+    public WebSocket sendMessage(String message) {
+        channel.writeAndFlush(new TextWebSocketFrame(message));
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(String fragment, boolean last) {
+        channel.writeAndFlush(new TextWebSocketFrame(last, 0, fragment));
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPing(byte[] payload) {
+        channel.writeAndFlush(new PingWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPong(byte[] payload) {
+        channel.writeAndFlush(new PongWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return channel.isOpen();
+    }
+
+    @Override
+    public void close() {
+        if (channel.isOpen()) {
+            onClose();
+            listeners.clear();
+            channel.writeAndFlush(new CloseWebSocketFrame()).addListener(ChannelFutureListener.CLOSE);
+        }
+    }
+
+    public void close(int statusCode, String reason) {
+        onClose(statusCode, reason);
+        listeners.clear();
+    }
+
+    public void onError(Throwable t) {
+        for (WebSocketListener listener : listeners) {
+            try {
+                listener.onError(t);
+            } catch (Throwable t2) {
+                LOGGER.error("", t2);
+            }
+        }
+    }
+
+    protected void onClose() {
+        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
+    }
+
+    public void onClose(int code, String reason) {
+        for (WebSocketListener l : listeners) {
+            try {
+                if (l instanceof WebSocketCloseCodeReasonListener) {
+                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
+                }
+                l.onClose(this);
+            } catch (Throwable t) {
+                l.onError(t);
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "NettyWebSocket{channel=" + channel + '}';
+    }
+
+    private boolean hasWebSocketByteListener() {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteListener)
+                return true;
+        }
+        return false;
+    }
+
+    private boolean hasWebSocketTextListener() {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextListener)
+                return true;
+        }
+        return false;
+    }
+
+    @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        listeners.add(l);
+        interestedInByteMessages = interestedInByteMessages || l instanceof WebSocketByteListener;
+        interestedInTextMessages = interestedInTextMessages || l instanceof WebSocketTextListener;
+        return this;
+    }
+
+    @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        listeners.remove(l);
+
+        if (l instanceof WebSocketByteListener)
+            interestedInByteMessages = hasWebSocketByteListener();
+        if (l instanceof WebSocketTextListener)
+            interestedInTextMessages = hasWebSocketTextListener();
+
+        return this;
+    }
+
+    private List<byte[]> fragments() {
+        if (_fragments == null)
+            _fragments = new ArrayList<byte[]>(2);
+        return _fragments;
+    }
+
+    private void bufferFragment(byte[] buffer) {
+        bufferSize += buffer.length;
+        if (bufferSize > maxBufferSize) {
+            onError(new Exception("Exceeded Netty Web Socket maximum buffer size of " + maxBufferSize));
+            reset();
+            close();
+        } else {
+            fragments().add(buffer);
+        }
+    }
+
+    private void reset() {
+        fragments().clear();
+        bufferSize = 0;
+    }
+
+    private void notifyByteListeners(byte[] message) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteListener)
+                WebSocketByteListener.class.cast(listener).onMessage(message);
+        }
+    }
+
+    private void notifyTextListeners(byte[] bytes) {
+        String message = new String(bytes, UTF_8);
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextListener)
+                WebSocketTextListener.class.cast(listener).onMessage(message);
+        }
+    }
+
+    public void onBinaryFragment(HttpResponseBodyPart part) {
+
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteFragmentListener)
+                WebSocketByteFragmentListener.class.cast(listener).onFragment(part);
+        }
+
+        if (interestedInByteMessages) {
+            byte[] fragment = NettyResponseBodyPart.class.cast(part).getBodyPartBytes();
+
+            if (part.isLast()) {
+                if (bufferSize == 0) {
+                    notifyByteListeners(fragment);
+
+                } else {
+                    bufferFragment(fragment);
+                    notifyByteListeners(fragmentsBytes());
+                }
+
+                reset();
+
+            } else
+                bufferFragment(fragment);
+        }
+    }
+
+    private byte[] fragmentsBytes() {
+        ByteArrayOutputStream os = new ByteArrayOutputStream(bufferSize);
+        for (byte[] bytes : _fragments)
+            try {
+                os.write(bytes);
+            } catch (IOException e) {
+                // yeah, right
+            }
+        return os.toByteArray();
+    }
+
+    public void onTextFragment(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextFragmentListener)
+                WebSocketTextFragmentListener.class.cast(listener).onFragment(part);
+        }
+
+        if (interestedInTextMessages) {
+            byte[] fragment = NettyResponseBodyPart.class.cast(part).getBodyPartBytes();
+
+            if (part.isLast()) {
+                if (bufferSize == 0) {
+                    notifyTextListeners(fragment);
+
+                } else {
+                    bufferFragment(fragment);
+                    notifyTextListeners(fragmentsBytes());
+                }
+
+                reset();
+
+            } else
+                bufferFragment(fragment);
+        }
+    }
+
+    public void onPing(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketPingListener)
+                // bytes are cached in the part
+                WebSocketPingListener.class.cast(listener).onPing(part.getBodyPartBytes());
+        }
+    }
+
+    public void onPong(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketPongListener)
+                // bytes are cached in the part
+                WebSocketPongListener.class.cast(listener).onPong(part.getBodyPartBytes());
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java
old mode 100644
new mode 100755
similarity index 84%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java
index 8aabcc954..c308edaea
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java
@@ -1,24 +1,27 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.providers.netty.ws;
 
 import org.asynchttpclient.util.Base64;
+import org.asynchttpclient.util.StandardCharsets;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-public final class WebSocketUtil {
+public final class WebSocketUtils {
+
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     public static String getKey() {
@@ -28,7 +31,7 @@ public static String getKey() {
 
     public static String getAcceptKey(String key) throws UnsupportedEncodingException {
         String acceptSeed = key + MAGIC_GUID;
-        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
+        byte[] sha1 = sha1(acceptSeed.getBytes(StandardCharsets.US_ASCII));
         return base64Encode(sha1);
     }
 
@@ -67,6 +70,4 @@ public static String base64Encode(byte[] bytes) {
     public static int createRandomNumber(int min, int max) {
         return (int) (Math.random() * max + min);
     }
-
 }
-
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
index 54262deaa..4ceea1570 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
@@ -12,35 +12,12 @@
  */
 package org.asynchttpclient.providers.netty;
 
-import static org.testng.Assert.assertEquals;
-
-import java.util.concurrent.Executors;
-
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.testng.annotations.Test;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.async.AbstractBasicTest;
 
 public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
 
-    @Test
-    public void bossThreadPoolExecutor() throws Throwable {
-        NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
-        conf.setBossExecutorService(Executors.newSingleThreadExecutor());
-
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-        try {
-            Response r = c.prepareGet(getTargetUrl()).execute().get();
-            assertEquals(r.getStatusCode(), 200);
-        } finally {
-            c.close();
-        }
-    }
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
index d422b202a..79c511286 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
@@ -12,15 +12,13 @@
  */
 package org.asynchttpclient.providers.netty;
 
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.testng.annotations.Test;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.async.AsyncProvidersBasicTest;
 
-@Test
+import io.netty.channel.ChannelOption;
+
 public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
     @Override
@@ -29,9 +27,12 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
-        config.addProperty("tcpNoDelay", true);
-        return config;
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
+        return new NettyAsyncHttpProviderConfig().addChannelOption(ChannelOption.TCP_NODELAY, Boolean.TRUE);
+    }
+
+    @Override
+    protected String acceptEncodingHeader() {
+        return "gzip,deflate";
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
index a8902eb65..259d93db8 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
@@ -14,19 +14,7 @@
 package org.asynchttpclient.providers.netty;
 
 import static org.testng.Assert.assertEquals;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProvider;
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelPipeline;
-import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.channel.SimpleChannelHandler;
-import org.jboss.netty.handler.codec.http.HttpMessage;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -34,17 +22,37 @@
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.async.AbstractBasicTest;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig.AdditionalChannelInitializer;
+import org.testng.annotations.Test;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.http.HttpMessage;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 public class NettyAsyncProviderPipelineTest extends AbstractBasicTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return new AsyncHttpClient(new CopyEncodingNettyAsyncHttpProvider(config), config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Test(groups = { "standalone", "netty_provider" })
-    public void asyncPipelineTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build());
+    public void asyncPipelineTest() throws Exception {
+
+        NettyAsyncHttpProviderConfig nettyConfig = new NettyAsyncHttpProviderConfig();
+        nettyConfig.setHttpAdditionalChannelInitializer(new AdditionalChannelInitializer() {
+            public void initChannel(Channel ch) throws Exception {
+                // super.initPlainChannel(ch);
+                ch.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+            }
+        });
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
+                .setAsyncHttpClientProviderConfig(nettyConfig).build());
+
         try {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
@@ -61,42 +69,24 @@ public Response onCompleted(Response response) throws Exception {
                 }
             }).get();
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                Assert.fail("Timeout out");
+                fail("Timeout out");
             }
         } finally {
             p.close();
         }
     }
 
-    private static class CopyEncodingNettyAsyncHttpProvider extends
-            NettyAsyncHttpProvider {
-        public CopyEncodingNettyAsyncHttpProvider(AsyncHttpClientConfig config) {
-            super(config);
-        }
-
-        protected ChannelPipelineFactory createPlainPipelineFactory() {
-            final ChannelPipelineFactory pipelineFactory = super.createPlainPipelineFactory();
-            return new ChannelPipelineFactory() {
-                public ChannelPipeline getPipeline() throws Exception {
-                    ChannelPipeline pipeline = pipelineFactory.getPipeline();
-                    pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
-                    return pipeline;
-                }
-            };
-        }
-    }
-
-    private static class CopyEncodingHandler extends SimpleChannelHandler {
+    private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
-            Object msg = e.getMessage();
-            if (msg instanceof HttpMessage) {
-                HttpMessage m = (HttpMessage) msg;
-                // for test there is no Content-Encoding header so just hard coding value
+        public void channelRead(ChannelHandlerContext ctx, Object e) {
+            if (e instanceof HttpMessage) {
+                HttpMessage m = (HttpMessage) e;
+                // for test there is no Content-Encoding header so just hard
+                // coding value
                 // for verification
-                m.setHeader("X-Original-Content-Encoding", "<original encoding>");
+                m.headers().set("X-Original-Content-Encoding", "<original encoding>");
             }
-            ctx.sendUpstream(e);
+            ctx.fireChannelRead(e);
         }
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
index 812a04e0f..915857185 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
@@ -13,11 +13,13 @@
 
 package org.asynchttpclient.providers.netty;
 
-import org.asynchttpclient.Cookie;
+import static org.testng.Assert.assertEquals;
+
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.providers.netty.NettyResponse;
-import org.asynchttpclient.providers.netty.ResponseStatus;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.providers.netty.response.NettyResponse;
+import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
 import org.testng.annotations.Test;
 
 import java.text.SimpleDateFormat;
@@ -26,9 +28,6 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
 /**
  * @author Benjamin Hanzelmann
  */
@@ -40,33 +39,33 @@ public void testCookieParseExpires() {
         SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
         sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
 
-        Date date = new Date(System.currentTimeMillis() + 60000); // sdf.parse( dateString );
+        Date date = new Date(System.currentTimeMillis() + 60000);
         final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-        NettyResponse
-                response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null);
+        }, null, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
         Cookie cookie = cookies.get(0);
-        assertTrue(cookie.getMaxAge() > 55 && cookie.getMaxAge() < 61, "");
+        long originalDateWith1SecPrecision = date.getTime() / 1000 * 1000;
+        assertEquals(cookie.getExpires(), originalDateWith1SecPrecision);
     }
 
     @Test(groups = "standalone")
     public void testCookieParseMaxAge() {
         final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null);
+        }, null, null);
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
@@ -77,18 +76,18 @@ public FluentCaseInsensitiveStringsMap getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseWeirdExpiresValue() {
         final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null);
+        }, null, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
         Cookie cookie = cookies.get(0);
-        assertEquals(cookie.getMaxAge(), 60);
+        assertEquals(cookie.getMaxAge(), -1);
     }
 
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
index 61a633e00..1056d502f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
@@ -22,5 +22,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
index f8c7d3662..589cfd1e6 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
@@ -12,16 +12,10 @@
  */
 package org.asynchttpclient.providers.netty;
 
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
-import org.testng.annotations.Test;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.BasicAuthTest;
 
-@Test
 public class NettyBasicAuthTest extends BasicAuthTest {
 
     @Override
@@ -30,8 +24,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    @Test
-    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        super.redirectAndBasicAuthTest(); // To change body of overridden methods use File | Settings | File Templates.
+    public String getProviderClass() {
+        return NettyAsyncHttpProvider.class.getName();
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
index 945761d5e..aad2b47ca 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
@@ -1,29 +1,31 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved. This program is licensed to you under the Apache License
+ * Version 2.0, and you may not use this file except in compliance with the Apache License Version 2.0. You may obtain a
+ * copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0. Unless required by applicable
+ * law or agreed to in writing, software distributed under the Apache License Version 2.0 is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Apache License Version 2.0
+ * for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.providers.netty;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import io.netty.channel.Channel;
 
+import java.net.ConnectException;
 import java.util.concurrent.TimeUnit;
 
-import org.jboss.netty.channel.Channel;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.async.ConnectionPoolTest;
+import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.providers.netty.channel.pool.NoopChannelPool;
+import org.testng.annotations.Test;
 
 public class NettyConnectionPoolTest extends ConnectionPoolTest {
 
@@ -32,32 +34,25 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
 
-    @Override
+    @Test(groups = { "standalone", "default_provider" })
     public void testInvalidConnectionsPool() {
-        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
-
-            public boolean offer(String key, Channel connection) {
-                return false;
-            }
-
-            public Channel poll(String connection) {
-                return null;
-            }
+        ChannelPool cp = new NoopChannelPool() {
 
-            public boolean removeAll(Channel connection) {
+            @Override
+            public boolean offer(Channel connection, String poolKey) {
                 return false;
             }
 
-            public boolean canCacheConnection() {
+            @Override
+            public boolean isOpen() {
                 return false;
             }
-
-            public void destroy() {
-
-            }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
+        providerConfig.setChannelPool(cp);
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build());
         try {
             Exception exception = null;
             try {
@@ -73,32 +68,20 @@ public void destroy() {
         }
     }
 
-    @Override
+    @Test(groups = { "standalone", "default_provider" })
     public void testValidConnectionsPool() {
-        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
-
-            public boolean offer(String key, Channel connection) {
-                return true;
-            }
-
-            public Channel poll(String connection) {
-                return null;
-            }
+        ChannelPool cp = new NoopChannelPool() {
 
-            public boolean removeAll(Channel connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
+            @Override
+            public boolean offer(Channel connection, String poolKey) {
                 return true;
             }
-
-            public void destroy() {
-
-            }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
+        providerConfig.setChannelPool(cp);
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build());
         try {
             Exception exception = null;
             try {
@@ -112,4 +95,33 @@ public void destroy() {
             client.close();
         }
     }
+
+    @Test
+    public void testHostNotContactable() {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+
+        try {
+            String url = null;
+            try {
+                url = "http://127.0.0.1:" + findFreePort();
+            } catch (Exception e) {
+                fail("unable to find free port to simulate downed host");
+            }
+            int i;
+            for (i = 0; i < 2; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+                    Response response = client.prepareGet(url).execute().get();
+                    log.info("{} response [{}].", i, response);
+                    fail("Shouldn't be here: should get an exception instead");
+                } catch (Exception ex) {
+                    assertNotNull(ex.getCause());
+                    Throwable cause = ex.getCause();
+                    assertTrue(cause instanceof ConnectException);
+                }
+            }
+        } finally {
+            client.close();
+        }
+    }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java
similarity index 84%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java
index 5790fd96b..51128081d 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java
@@ -14,10 +14,11 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicHttpsTest;
-
-public class NettyBasicHttpsTest extends BasicHttpsTest {
+import org.asynchttpclient.async.FastUnauthorizedUploadTest;
+import org.testng.annotations.Test;
 
+@Test
+public class NettyFastUnauthorizedUploadTest extends FastUnauthorizedUploadTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
index d1c6fd0eb..f725ea228 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
@@ -15,7 +15,9 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.FilterTest;
+import org.testng.annotations.Test;
 
+@Test
 public class NettyFilterTest extends FilterTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
index c4692cb47..960a039d9 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
@@ -19,13 +19,14 @@
 import org.asynchttpclient.async.PerRequestTimeoutTest;
 
 public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
-    
+
     @Override
     protected void checkTimeoutMessage(String message) {
-        assertTrue(message
-                .startsWith("Request reached time out of 100 ms after "));
+        assertTrue(message.startsWith("Request timed out"), "error message indicates reason of error");
+        assertTrue(message.contains("127.0.0.1"), "error message contains remote ip address");
+        assertTrue(message.contains("of 100 ms"), "error message contains timeout configuration value");
     }
-    
+
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
index 499e0025c..b6120976b 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
@@ -17,20 +17,14 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
 
 public class NettyProviderUtil {
 
     public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
-        // FIXME why do tests fail with this set up? Seems like we have a race condition
-        // if (config == null) {
-        // config = new AsyncHttpClientConfig.Builder().build();
-        // }
-        // return new AsyncHttpClient(new NettyAsyncHttpProvider(config), config);
-
         if (config == null) {
-            return new AsyncHttpClient();
-        } else {
-            return new AsyncHttpClient(config);
+            config = new AsyncHttpClientConfig.Builder().build();
         }
+        return new DefaultAsyncHttpClient(new NettyAsyncHttpProvider(config), config);
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
index a862e9ee8..2d4705854 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
@@ -21,4 +21,8 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
+
+    public String getProviderClass() {
+        return NettyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
index e376f9a41..cd62bb347 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
@@ -14,22 +14,11 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.asynchttpclient.async.RedirectConnectionUsageTest;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
 
 public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
-    @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
-        if (System.getProperty("blockingio") != null) {
-            config.setUseBlockingIO(true);
-        }
-        return config;
-    }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
index f0685b456..3836c1c3e 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
@@ -15,30 +15,30 @@
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.continuation.Continuation;
-import org.eclipse.jetty.continuation.ContinuationSupport;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-
 public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
     private static final String MSG = "Enough is enough.";
     private static final int SLEEPTIME_MS = 1000;
@@ -54,7 +54,8 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     private class SlowHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
+                throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_OK);
             final Continuation continuation = ContinuationSupport.getContinuation(request);
             continuation.suspend();
@@ -66,9 +67,9 @@ public void run() {
                         response.getOutputStream().flush();
                         continuation.complete();
                     } catch (InterruptedException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     } catch (IOException e) {
-                        log.error(e.getMessage(), e);
+                        logger.error(e.getMessage(), e);
                     }
                 }
             }).start();
@@ -80,12 +81,15 @@ public void run() {
     public void testRequestTimeout() throws IOException {
         final Semaphore requestThrottle = new Semaphore(1);
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnections(1).build());
+
+        int samples = 10;
+
         try {
-            final CountDownLatch latch = new CountDownLatch(2);
+            final CountDownLatch latch = new CountDownLatch(samples);
+            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
 
-            final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
-            for (int i = 0; i < 2; i++) {
+            for (int i = 0; i < samples; i++) {
                 new Thread(new Runnable() {
 
                     public void run() {
@@ -93,19 +97,24 @@ public void run() {
                             requestThrottle.acquire();
                             Future<Response> responseFuture = null;
                             try {
-                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2).execute(new AsyncCompletionHandler<Response>() {
-
-                                    @Override
-                                    public Response onCompleted(Response response) throws Exception {
-                                        requestThrottle.release();
-                                        return response;
-                                    }
-
-                                    @Override
-                                    public void onThrowable(Throwable t) {
-                                        requestThrottle.release();
-                                    }
-                                });
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2)
+                                        .execute(new AsyncCompletionHandler<Response>() {
+
+                                            @Override
+                                            public Response onCompleted(Response response) throws Exception {
+                                                return response;
+                                            }
+
+                                            @Override
+                                            public void onThrowable(Throwable t) {
+                                                logger.error("onThrowable got an error", t);
+                                                try {
+                                                    Thread.sleep(100);
+                                                } catch (InterruptedException e) {
+                                                }
+                                                requestThrottle.release();
+                                            }
+                                        });
                             } catch (Exception e) {
                                 tooManyConnections.add(e);
                             }
@@ -119,7 +128,6 @@ public void onThrowable(Throwable t) {
 
                     }
                 }).start();
-
             }
 
             try {
@@ -128,7 +136,10 @@ public void onThrowable(Throwable t) {
                 fail("failed to wait for requests to complete");
             }
 
-            assertTrue(tooManyConnections.size() == 0, "Should not have any connection errors where too many connections have been attempted");
+            for (Exception e : tooManyConnections)
+                logger.error("Exception while calling execute", e);
+
+            assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
         } finally {
             client.close();
         }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
index d00acde3c..8ea77a62f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
@@ -20,7 +20,7 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.async.RetryRequestTest;
 
-public class NettyRetryRequestTest extends RetryRequestTest{
+public class NettyRetryRequestTest extends RetryRequestTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java
similarity index 78%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java
index 979c761bd..c57b8b89d 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java
@@ -15,13 +15,16 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostRedirectGetTest;
+import org.asynchttpclient.async.SimpleAsyncClientErrorBehaviourTest;
 
-public class NettyPostRedirectGetTest extends PostRedirectGetTest {
+public class NettySimpleAsyncClientErrorBehaviourTest extends SimpleAsyncClientErrorBehaviourTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
 
+    public String getProviderClass() {
+        return NettyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
index 27834862d..0b117c9ee 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
@@ -20,6 +20,7 @@
 
     /**
      * Not Used with {@link org.asynchttpclient.SimpleAsyncHttpClient}
+     * 
      * @param config
      * @return
      */
@@ -28,4 +29,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return null;
     }
 
+    public String getProviderClass() {
+        return NettyAsyncHttpProvider.class.getName();
+    }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
index f99aeade6..c5d179859 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
@@ -12,29 +12,29 @@
  */
 package org.asynchttpclient.providers.netty;
 
+import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.Request;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.asynchttpclient.async.AbstractBasicTest;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+
 import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -42,158 +42,69 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
 
-import static org.testng.Assert.assertTrue;
-
-
-public class RetryNonBlockingIssue {
-
-    private URI servletEndpointUri;
-
-    private Server server;
+//FIXME there's no retry actually
+public class RetryNonBlockingIssue extends AbstractBasicTest {
 
-    private int port1;
-
-    public static int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            // 0 is open a socket on any free port
-            socket = new ServerSocket(0);
-            return socket.getLocalPort();
-        } finally {
-            if (socket != null) {
-                socket.close();
-            }
-        }
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
     }
 
-
-    @BeforeMethod
-    public void setUp() throws Exception {
-        server = new Server();
-
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
         port1 = findFreePort();
+        server = newJettyHttpServer(port1);
 
-        Connector listener = new SelectChannelConnector();
-        listener.setHost("127.0.0.1");
-        listener.setPort(port1);
-
-        server.addConnector(listener);
-
-
-        ServletContextHandler context = new
-                ServletContextHandler(ServletContextHandler.SESSIONS);
-
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
         context.setContextPath("/");
-        server.setHandler(context);
-        context.addServlet(new ServletHolder(new
-                MockExceptionServlet()), "/*");
+        context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
 
+        server.setHandler(context);
         server.start();
-
-        servletEndpointUri = new URI("http://127.0.0.1:" + port1 + "/");
     }
 
-    @AfterMethod
-    public void stop() {
-
-        try {
-            if (server != null) server.stop();
-        } catch (Exception e) {
-        }
-
-
+    protected String getTargetUrl() {
+        return String.format("http://127.0.0.1:%d/", port1);
     }
 
-    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient
-            fetcher, int requests, String action, String id) throws IOException {
-        RequestBuilder builder = new RequestBuilder("GET");
-        builder.addQueryParameter(action, "1");
-
-        builder.addQueryParameter("maxRequests", "" + requests);
-        builder.addQueryParameter("id", id);
-        builder.setUrl(servletEndpointUri.toString());
-        Request r = builder.build();
-        return fetcher.executeRequest(r);
-
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
+        Request r = new RequestBuilder("GET")//
+                .setUrl(getTargetUrl())//
+                .addQueryParam(action, "1")//
+                .addQueryParam("maxRequests", "" + requests)//
+                .addQueryParam("id", id)//
+                .build();
+        return client.executeRequest(r);
     }
 
     /**
      * Tests that a head request can be made
-     *
+     * 
      * @throws IOException
      * @throws ExecutionException
      * @throws InterruptedException
      */
     @Test
-    public void testRetryNonBlocking() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
-        try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(60000);
-            bc.setRequestTimeoutInMs(30000);
-
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-
-            bc.setAsyncHttpClientProviderConfig(config);
-            c = new AsyncHttpClient(bc.build());
-
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
-            }
+    public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
 
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                Map<String, List<String>> heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-                assertTrue(heads.size() > 0);
-            }
-            System.out.println(b.toString());
-            System.out.flush();
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnections(100)//
+                .setConnectionTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
 
-        }
-        finally {
-            if (c != null) c.close();
-        }
-    }
-
-    @Test
-    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
+        AsyncHttpClient client = getAsyncHttpClient(config);
         try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(60000);
-            bc.setRequestTimeoutInMs(30000);
-            bc.setAsyncConnectMode(true);
-
-            c = new AsyncHttpClient(bc.build());
-
+            List<ListenableFuture<Response>> res = new ArrayList<ListenableFuture<Response>>();
             for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
             }
 
             StringBuilder b = new StringBuilder();
             for (ListenableFuture<Response> r : res) {
                 Response theres = r.get();
+                assertEquals(200, theres.getStatusCode());
                 b.append("==============\r\n");
                 b.append("Response Headers\r\n");
                 Map<String, List<String>> heads = theres.getHeaders();
@@ -204,63 +115,52 @@ public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedEx
             System.out.println(b.toString());
             System.out.flush();
 
-        }
-        finally {
-            if (c != null) c.close();
+        } finally {
+            client.close();
         }
     }
 
     @Test
-    public void testRetryBlocking() throws IOException, InterruptedException,
-            ExecutionException {
-        AsyncHttpClient c = null;
-        List<ListenableFuture<Response>> res = new
-                ArrayList<ListenableFuture<Response>>();
-        try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
-
-            bc.setAllowPoolingConnection(true);
-            bc.setMaximumConnectionsTotal(100);
-            bc.setConnectionTimeoutInMs(30000);
-            bc.setRequestTimeoutInMs(30000);
+    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
 
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-            config.setUseBlockingIO(true);
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnections(100)//
+                .setConnectionTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
 
-            bc.setAsyncHttpClientProviderConfig(config);
-            c = new AsyncHttpClient(bc.build());
+        AsyncHttpClient client = getAsyncHttpClient(config);
 
+        try {
+            List<ListenableFuture<Response>> res = new ArrayList<ListenableFuture<Response>>();
             for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
             }
 
             StringBuilder b = new StringBuilder();
             for (ListenableFuture<Response> r : res) {
                 Response theres = r.get();
+                assertEquals(theres.getStatusCode(), 200);
                 b.append("==============\r\n");
                 b.append("Response Headers\r\n");
                 Map<String, List<String>> heads = theres.getHeaders();
                 b.append(heads + "\r\n");
                 b.append("==============\r\n");
                 assertTrue(heads.size() > 0);
-
             }
             System.out.println(b.toString());
             System.out.flush();
 
-        }
-        finally {
-            if (c != null) c.close();
+        } finally {
+            client.close();
         }
     }
 
     @SuppressWarnings("serial")
     public class MockExceptionServlet extends HttpServlet {
 
-        private Map<String, Integer> requests = new
-                ConcurrentHashMap<String, Integer>();
+        private Map<String, Integer> requests = new ConcurrentHashMap<String, Integer>();
 
         private synchronized int increment(String id) {
             int val = 0;
@@ -276,14 +176,12 @@ private synchronized int increment(String id) {
             return val;
         }
 
-        public void service(HttpServletRequest req, HttpServletResponse res)
-                throws ServletException, IOException {
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
             String maxRequests = req.getParameter("maxRequests");
             int max = 0;
             try {
                 max = Integer.parseInt(maxRequests);
-            }
-            catch (NumberFormatException e) {
+            } catch (NumberFormatException e) {
                 max = 3;
             }
             String id = req.getParameter("id");
@@ -292,7 +190,6 @@ public void service(HttpServletRequest req, HttpServletResponse res)
             String io = req.getParameter("io");
             String error = req.getParameter("500");
 
-
             if (requestNo >= max) {
                 res.setHeader("Success-On-Attempt", "" + requestNo);
                 res.setHeader("id", id);
@@ -304,26 +201,25 @@ public void service(HttpServletRequest req, HttpServletResponse res)
                     res.setHeader("type", "io");
                 res.setStatus(200);
                 res.setContentLength(0);
+                res.flushBuffer();
                 return;
             }
 
-
             res.setStatus(200);
             res.setContentLength(100);
             res.setContentType("application/octet-stream");
-
             res.flushBuffer();
 
+            // error after flushing the status
             if (servlet != null && servlet.trim().length() > 0)
                 throw new ServletException("Servlet Exception");
 
             if (io != null && io.trim().length() > 0)
                 throw new IOException("IO Exception");
 
-            if (error != null && error.trim().length() > 0)
+            if (error != null && error.trim().length() > 0) {
                 res.sendError(500, "servlet process was 500");
+            }
         }
-
     }
 }
-
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
index 2dc624466..deec16902 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
@@ -24,5 +24,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java
similarity index 80%
rename from providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java
index 63b875480..2ce2156d9 100644
--- a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -15,14 +15,14 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.RedirectTest;
+import org.asynchttpclient.websocket.ProxyTunnellingTest;
+import org.testng.annotations.Test;
 
-public class NettyRedirectTest extends RedirectTest {
+@Test
+public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
index 63b875480..185ffb180 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
@@ -15,7 +15,6 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
 import org.asynchttpclient.websocket.RedirectTest;
 
 public class NettyRedirectTest extends RedirectTest {
@@ -24,5 +23,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
 }
diff --git a/providers/netty/src/test/resources/ssltest-cacerts.jks b/providers/netty/src/test/resources/ssltest-cacerts.jks
index 9c1ffbe49..207b9646e 100644
Binary files a/providers/netty/src/test/resources/ssltest-cacerts.jks and b/providers/netty/src/test/resources/ssltest-cacerts.jks differ
diff --git a/providers/netty/src/test/resources/ssltest-keystore.jks b/providers/netty/src/test/resources/ssltest-keystore.jks
index a95b7c5f4..70267836e 100644
Binary files a/providers/netty/src/test/resources/ssltest-keystore.jks and b/providers/netty/src/test/resources/ssltest-keystore.jks differ
diff --git a/providers/pom.xml b/providers/pom.xml
index 64f8d2376..72af625a7 100644
--- a/providers/pom.xml
+++ b/providers/pom.xml
@@ -46,9 +46,6 @@
     <modules>
         <module>grizzly</module>
         <module>netty</module>
-        <!--
-        <module>netty-4</module>
-        -->
     </modules>
 
     <dependencies>
diff --git a/site/src/site/apt/proxy.apt b/site/src/site/apt/proxy.apt
index d62a0ebb4..a09932fc0 100644
--- a/site/src/site/apt/proxy.apt
+++ b/site/src/site/apt/proxy.apt
@@ -61,3 +61,26 @@ Response r = responseFuture.get();
 
   You can also set the <<<ProxyServer>>> at the <<<AsyncHttpClientConfig>>> level. In that case, all request will share
   the same proxy information.
+
+Using Java System Properties
+
+  The AsyncHttpClient library supports the standard
+  {{{http://docs.oracle.com/javase/7/docs/api/java/net/doc-files/net-properties.html#Proxies}Java Proxy System Properties}}.
+  You can configure this at a global level using the <<<setUseProxyProperties(true)>>> method on the
+  <<<AsyncHttpClientConfig.Builder>>>, or by setting the <<<org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties>>>
+  system property to true.
+
+Using JDK ProxySelectors
+
+  The AsyncHttpClient library also supports using the default
+  {{{http://docs.oracle.com/javase/7/docs/api/java/net/ProxySelector.html}JDK ProxySelector}}.  This allows for more
+  fine grained control over which proxies to use, for example, it can be used in combination with
+  {{{https://code.google.com/p/proxy-vole/}Proxy Vole}} to use OS configured proxies or to use a proxy.pac file.
+
+  You configure this at a global level using the <<<setUseProxySelector(true)>>> method on the
+  <<<AsyncHttpClientConfig.Builder>>>, or by setting the
+   <<<org.asynchttpclient.AsyncHttpClientConfig.useProxySelector>>> system property to true.
+
+  If you don't change the default JDK <<<ProxySelector>>>, this setting is very similar to the <<<useProxyProperties>>>
+  setting, though the <<<useProxyProperties>>> setting does allow more flexibility, such as the ability to use an
+  HTTPS proxy.
\ No newline at end of file
